[{"original_method":"/**\n   * Shows dialog with question to inline\n   */\n  @Nullable\n  private static InlineHandler.Settings inlineDialogResult(String localName,\n                                                           Project project,\n                                                           Collection<PsiReference> refs,\n                                                           boolean forField,\n                                                           final boolean inlineOnlyOneReference) {\n    Application application = ApplicationManager.getApplication();\n    if (!application.isUnitTestMode()) {\n      final String question =\n        GroovyRefactoringBundle.message(forField ? \"inline.field.prompt.0.1\" : \"inline.local.variable.prompt.0.1\", localName, refs.size());\n      RefactoringMessageDialog dialog =\n        new RefactoringMessageDialog(REFACTORING_NAME, question, forField ? HelpID.INLINE_FIELD : HelpID.INLINE_VARIABLE,\n                                     \"OptionPane.questionIcon\", true, project);\n      dialog.show();\n      if (!dialog.isOK()) {\n        WindowManager.getInstance().getStatusBar(project)\n          .setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n        return null;\n      }\n    }\n\n    return new InlineHandler.Settings() {\n      public boolean isOnlyOneReferenceToInline() {\n        return inlineOnlyOneReference;\n      }\n    };\n  }","id":40000,"modified_method":"private static InlineHandler.Settings inlineFieldDialogResult(Project project, GrField field, final boolean invokedOnReference) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return new InlineHandler.Settings() {\n        @Override\n        public boolean isOnlyOneReferenceToInline() {\n          return invokedOnReference;\n        }\n      };\n    }\n\n    final InlineGroovyFieldDialog dialog = new InlineGroovyFieldDialog(project, field, invokedOnReference);\n    dialog.show();\n    if (dialog.isOK()) {\n      return new InlineHandler.Settings() {\n        @Override\n        public boolean isOnlyOneReferenceToInline() {\n          return dialog.isInlineThisOnly();\n        }\n      };\n    }\n    else {\n      WindowManager.getInstance().getStatusBar(project).setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n      return InlineHandler.Settings.CANNOT_INLINE_SETTINGS;\n    }\n  }","commit_id":"a12908633255d17903100b5f45d402411d8822ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns Settings object for referenced definition in case of local variable\n   */\n  @Nullable\n  static InlineHandler.Settings inlineLocalVariableSettings(final GrVariable variable, Editor editor) {\n    final String localName = variable.getName();\n    final Project project = variable.getProject();\n    final Collection<PsiReference> refs = ReferencesSearch.search(variable).findAll();\n    ArrayList<PsiElement> exprs = new ArrayList<PsiElement>();\n    for (PsiReference ref : refs) {\n      exprs.add(ref.getElement());\n    }\n\n    GroovyRefactoringUtil.highlightOccurrences(project, editor, PsiUtilBase.toPsiElementArray(exprs));\n    if (variable.getInitializerGroovy() == null) {\n      String message = GroovyRefactoringBundle.message(\"cannot.find.a.single.definition.to.inline.local.var\");\n      CommonRefactoringUtil.showErrorHint(variable.getProject(), editor, message, REFACTORING_NAME, HelpID.INLINE_VARIABLE);\n      return null;\n    }\n    if (refs.isEmpty()) {\n      String message = GroovyRefactoringBundle.message(\"variable.is.never.used.0\", variable.getName());\n      CommonRefactoringUtil.showErrorHint(variable.getProject(), editor, message, REFACTORING_NAME, HelpID.INLINE_VARIABLE);\n      return null;\n    }\n\n    return inlineDialogResult(localName, project, refs, false, false);\n  }","id":40001,"modified_method":"/**\n   * Returns Settings object for referenced definition in case of local variable\n   */\n  @Nullable\n  static InlineHandler.Settings inlineLocalVariableSettings(final GrVariable variable, Editor editor) {\n    final String localName = variable.getName();\n    final Project project = variable.getProject();\n\n    if (variable.getInitializerGroovy() == null) {\n      String message = GroovyRefactoringBundle.message(\"cannot.find.a.single.definition.to.inline.local.var\");\n      CommonRefactoringUtil.showErrorHint(variable.getProject(), editor, message, INLINE_VARIABLE, HelpID.INLINE_VARIABLE);\n      return InlineHandler.Settings.CANNOT_INLINE_SETTINGS;\n    }\n\n    return inlineLocalVarDialogResult(localName, project);\n  }","commit_id":"a12908633255d17903100b5f45d402411d8822ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates new inliner for local variable occurences\n   */\n  static InlineHandler.Inliner createInlinerForVariable(final GrVariable variable) {\n    return new InlineHandler.Inliner() {\n\n      @Nullable\n      public MultiMap<PsiElement, String> getConflicts(PsiReference reference, PsiElement referenced) {\n        MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>();\n        GrExpression expr = (GrExpression)reference.getElement();\n        if (expr.getParent() instanceof GrAssignmentExpression) {\n          GrAssignmentExpression parent = (GrAssignmentExpression)expr.getParent();\n          if (expr.equals(parent.getLValue())) {\n            conflicts.putValue(expr, GroovyRefactoringBundle.message(\"local.varaible.is.lvalue\"));\n          }\n        }\n        return conflicts;\n      }\n\n      public void inlineUsage(final UsageInfo usage, final PsiElement referenced) {\n        GrExpression exprToBeReplaced = (GrExpression)usage.getElement();\n        if (exprToBeReplaced == null) return;\n        assert variable.getInitializerGroovy() != null;\n        GrExpression initializerGroovy = variable.getInitializerGroovy();\n        assert initializerGroovy != null;\n        GrExpression tempExpr = (GrExpression)skipParentheses(initializerGroovy, false);\n        if (tempExpr == null) return;\n        Project project = variable.getProject();\n        GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(project);\n        GrExpression newExpr;\n        newExpr = factory.createExpressionFromText(tempExpr.getText());\n        newExpr = exprToBeReplaced.replaceWithExpression(newExpr, true);\n        FileEditorManager manager = FileEditorManager.getInstance(project);\n        Editor editor = manager.getSelectedTextEditor();\n        GroovyRefactoringUtil.highlightOccurrences(project, editor, new PsiElement[]{newExpr});\n        WindowManager.getInstance().getStatusBar(project)\n          .setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n      }\n    };\n  }","id":40002,"modified_method":"/**\n   * Creates new inliner for local variable occurences\n   */\n  static InlineHandler.Inliner createInlinerForVariable(final GrVariable variable) {\n    return new GrVariableInliner(variable);\n  }","commit_id":"a12908633255d17903100b5f45d402411d8822ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void performRefactoring(UsageInfo[] usages) {\n    final List<PsiClassType> thrownExceptions = ExceptionUtil.getThrownCheckedExceptions(new PsiElement[]{myInitializer});\n    final Set<PsiVariable> varsUsedInInitializer = new HashSet<PsiVariable>();\n    final Set<PsiJavaCodeReferenceElement> paramRefsToInline = new HashSet<PsiJavaCodeReferenceElement>();\n    final Map<PsiElement, PsiElement> replacements = new HashMap<PsiElement, PsiElement>();\n    for (UsageInfo usage : usages) {\n      if (usage instanceof LocalReplacementUsageInfo) {\n        final LocalReplacementUsageInfo replacementUsageInfo = (LocalReplacementUsageInfo)usage;\n        final PsiElement element = replacementUsageInfo.getElement();\n        final PsiElement replacement = replacementUsageInfo.getReplacement();\n        if (element != null && replacement != null) {\n          replacements.put(element, replacement);\n        }\n        varsUsedInInitializer.add(replacementUsageInfo.getVariable());\n      }\n      else {\n        LOG.assertTrue(!myCreateLocal);\n        paramRefsToInline.add((PsiJavaCodeReferenceElement)usage.getElement());\n      }\n    }\n    myInitializer = (PsiExpression)RefactoringUtil.replaceElementsWithMap(myInitializer, replacements);\n\n    if (myCreateLocal) {\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(myMethod.getProject()).getElementFactory();\n      PsiDeclarationStatement localDeclaration =\n        factory.createVariableDeclarationStatement(myParameter.getName(), myParameter.getType(), myInitializer);\n      final PsiLocalVariable declaredVar = (PsiLocalVariable)localDeclaration.getDeclaredElements()[0];\n      PsiUtil.setModifierProperty(declaredVar, PsiModifier.FINAL, myParameter.hasModifierProperty(PsiModifier.FINAL));\n      final PsiExpression localVarInitializer =\n        InlineUtil.inlineVariable(myParameter, myInitializer, (PsiReferenceExpression)factory.createExpressionFromText(myParameter.getName(), myMethod));\n      final PsiExpression initializer = declaredVar.getInitializer();\n      LOG.assertTrue(initializer != null);\n      initializer.replace(localVarInitializer);\n      final PsiCodeBlock body = myMethod.getBody();\n      if (body != null) {\n        body.addAfter(localDeclaration, body.getLBrace());\n      }\n    } else {\n      for (PsiJavaCodeReferenceElement paramRef : paramRefsToInline) {\n        InlineUtil.inlineVariable(myParameter, myInitializer, paramRef);\n      }\n    }\n\n    //delete var if it becomes unused\n    for (PsiVariable variable : varsUsedInInitializer) {\n      if (variable != null && variable.isValid()) {\n        if (ReferencesSearch.search(variable).findFirst() == null) {\n          variable.delete();\n        }\n      }\n    }\n\n    SameParameterValueInspection.InlineParameterValueFix.removeParameter(myMethod, myParameter);\n\n    if (!thrownExceptions.isEmpty()) {\n      for (PsiClassType exception : thrownExceptions) {\n        PsiClass exceptionClass = exception.resolve();\n        if (exceptionClass != null) {\n          PsiUtil.addException(myMethod, exceptionClass);\n        }\n      }\n    }\n  }","id":40003,"modified_method":"@Override\n  protected void performRefactoring(UsageInfo[] usages) {\n    final List<PsiClassType> thrownExceptions = ExceptionUtil.getThrownCheckedExceptions(new PsiElement[]{myInitializer});\n    final Set<PsiVariable> varsUsedInInitializer = new HashSet<PsiVariable>();\n    final Set<PsiJavaCodeReferenceElement> paramRefsToInline = new HashSet<PsiJavaCodeReferenceElement>();\n    final Map<PsiElement, PsiElement> replacements = new HashMap<PsiElement, PsiElement>();\n    for (UsageInfo usage : usages) {\n      if (usage instanceof LocalReplacementUsageInfo) {\n        final LocalReplacementUsageInfo replacementUsageInfo = (LocalReplacementUsageInfo)usage;\n        final PsiElement element = replacementUsageInfo.getElement();\n        final PsiElement replacement = replacementUsageInfo.getReplacement();\n        if (element != null && replacement != null) {\n          replacements.put(element, replacement);\n        }\n        varsUsedInInitializer.add(replacementUsageInfo.getVariable());\n      }\n      else {\n        LOG.assertTrue(!myCreateLocal);\n        paramRefsToInline.add((PsiJavaCodeReferenceElement)usage.getElement());\n      }\n    }\n    myInitializer = (PsiExpression)RefactoringUtil.replaceElementsWithMap(myInitializer, replacements);\n\n    if (myCreateLocal) {\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(myMethod.getProject()).getElementFactory();\n      PsiDeclarationStatement localDeclaration =\n        factory.createVariableDeclarationStatement(myParameter.getName(), myParameter.getType(), myInitializer);\n      final PsiLocalVariable declaredVar = (PsiLocalVariable)localDeclaration.getDeclaredElements()[0];\n      PsiUtil.setModifierProperty(declaredVar, PsiModifier.FINAL, myParameter.hasModifierProperty(PsiModifier.FINAL));\n      final PsiExpression localVarInitializer =\n        InlineUtil.inlineVariable(myParameter, myInitializer, (PsiReferenceExpression)factory.createExpressionFromText(myParameter.getName(), myMethod));\n      final PsiExpression initializer = declaredVar.getInitializer();\n      LOG.assertTrue(initializer != null);\n      initializer.replace(localVarInitializer);\n      final PsiCodeBlock body = myMethod.getBody();\n      if (body != null) {\n        PsiElement anchor = findAnchorForLocalVariableDeclaration(body);\n        body.addAfter(localDeclaration, anchor);\n      }\n    } else {\n      for (PsiJavaCodeReferenceElement paramRef : paramRefsToInline) {\n        InlineUtil.inlineVariable(myParameter, myInitializer, paramRef);\n      }\n    }\n\n    //delete var if it becomes unused\n    for (PsiVariable variable : varsUsedInInitializer) {\n      if (variable != null && variable.isValid()) {\n        if (ReferencesSearch.search(variable).findFirst() == null) {\n          variable.delete();\n        }\n      }\n    }\n\n    SameParameterValueInspection.InlineParameterValueFix.removeParameter(myMethod, myParameter);\n\n    if (!thrownExceptions.isEmpty()) {\n      for (PsiClassType exception : thrownExceptions) {\n        PsiClass exceptionClass = exception.resolve();\n        if (exceptionClass != null) {\n          PsiUtil.addException(myMethod, exceptionClass);\n        }\n      }\n    }\n  }","commit_id":"27ec83e3d7fc26af86b7b62b6dacc2ad918f35f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void inlineElement(final Project project, final Editor editor, final PsiElement psiElement) {\n    final PsiParameter psiParameter = (PsiParameter) psiElement;\n    final PsiParameterList parameterList = (PsiParameterList) psiParameter.getParent();\n    if (!(parameterList.getParent() instanceof PsiMethod)) {\n      return;\n    }\n    final int index = parameterList.getParameterIndex(psiParameter);\n    final PsiMethod method = (PsiMethod) parameterList.getParent();\n\n    String errorMessage = getCannotInlineMessage(psiParameter, method);\n    if (errorMessage != null) {\n      CommonRefactoringUtil.showErrorHint(project, editor, errorMessage, RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    final Ref<PsiExpression> refInitializer = new Ref<PsiExpression>();\n    final Ref<PsiExpression> refConstantInitializer = new Ref<PsiExpression>();\n    final Ref<PsiCallExpression> refMethodCall = new Ref<PsiCallExpression>();\n    final List<PsiReference> occurrences = new ArrayList<PsiReference>();\n    final Collection<PsiFile> containingFiles = new HashSet<PsiFile>();\n    containingFiles.add(psiParameter.getContainingFile());\n    boolean result = ReferencesSearch.search(method).forEach(new Processor<PsiReference>() {\n      public boolean process(final PsiReference psiReference) {\n        PsiElement element = psiReference.getElement();\n        final PsiElement parent = element.getParent();\n        if (parent instanceof PsiCallExpression) {\n          final PsiCallExpression methodCall = (PsiCallExpression)parent;\n          occurrences.add(psiReference);\n          containingFiles.add(element.getContainingFile());\n          final PsiExpression[] expressions = methodCall.getArgumentList().getExpressions();\n          if (expressions.length <= index) return false;\n          PsiExpression argument = expressions[index];\n          if (!refInitializer.isNull()) {\n            return argument != null\n                   && PsiEquivalenceUtil.areElementsEquivalent(refInitializer.get(), argument)\n                   && PsiEquivalenceUtil.areElementsEquivalent(refMethodCall.get(), methodCall);\n          }\n          if (InlineToAnonymousConstructorProcessor.isConstant(argument) || getReferencedFinalField(argument) != null) {\n            if (refConstantInitializer.isNull()) {\n              refConstantInitializer.set(argument);\n            }\n            else if (!isSameConstant(argument, refConstantInitializer.get())) {\n              return false;\n            }\n          } else if (!isRecursiveReferencedParameter(argument, psiParameter)) {\n            if (!refConstantInitializer.isNull()) return false;\n            refInitializer.set(argument);\n            refMethodCall.set(methodCall);\n          }\n        }\n        return true;\n      }\n    });\n    if (occurrences.isEmpty()) {\n      final int offset = editor.getCaretModel().getOffset();\n      final PsiElement refExpr = psiElement.getContainingFile().findElementAt(offset);\n      final PsiCodeBlock codeBlock = PsiTreeUtil.getParentOfType(refExpr, PsiCodeBlock.class);\n      if (codeBlock != null) {\n        final PsiElement[] defs = DefUseUtil.getDefs(codeBlock, psiParameter, refExpr);\n        if (defs.length == 1) {\n          final PsiElement def = defs[0];\n          if (def instanceof PsiReferenceExpression && PsiUtil.isOnAssignmentLeftHand((PsiExpression)def)) {\n            final PsiExpression rExpr = ((PsiAssignmentExpression)def.getParent()).getRExpression();\n            if (rExpr != null) {\n              final PsiElement[] refs = DefUseUtil.getRefs(codeBlock, psiParameter, refExpr);\n\n              if (InlineLocalHandler.checkRefsInAugmentedAssignmentOrUnaryModified(refs) == null) {\n                new WriteCommandAction(project) {\n                  @Override\n                  protected void run(Result result) throws Throwable {\n                    for (final PsiElement ref : refs) {\n                      InlineUtil.inlineVariable(psiParameter, rExpr, (PsiJavaCodeReferenceElement)ref);\n                    }\n                    def.getParent().delete();\n                  }\n                }.execute();\n                return;\n              }\n            }\n          }\n        }\n      }\n      CommonRefactoringUtil\n        .showErrorHint(project, editor, \"Method has no usages\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n    if (!result) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Cannot find constant initializer for parameter\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n    if (!refInitializer.isNull()) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        final InlineParameterExpressionProcessor processor =\n          new InlineParameterExpressionProcessor(refMethodCall.get(), method, psiParameter, refInitializer.get(),\n                                                 method.getProject().getUserData(\n                                                   InlineParameterExpressionProcessor.CREATE_LOCAL_FOR_TESTS));\n        processor.run();\n      }\n      else {\n        final boolean createLocal = ReferencesSearch.search(psiParameter).findAll().size() > 1;\n        InlineParameterDialog dlg = new InlineParameterDialog(refMethodCall.get(), method, psiParameter, refInitializer.get(), createLocal);\n        dlg.show();\n      }\n      return;\n    }\n    if (refConstantInitializer.isNull()) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Cannot find constant initializer for parameter\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    final Ref<Boolean> isNotConstantAccessible = new Ref<Boolean>();\n    final PsiExpression constantExpression = refConstantInitializer.get();\n    constantExpression.accept(new JavaRecursiveElementVisitor(){\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        final PsiElement resolved = expression.resolve();\n        if (resolved instanceof PsiMember && !PsiUtil.isAccessible((PsiMember)resolved, method, null)) {\n          isNotConstantAccessible.set(Boolean.TRUE);\n        }\n      }\n    });\n    if (!isNotConstantAccessible.isNull() && isNotConstantAccessible.get()) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Constant initializer is not accessible in method body\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      String occurencesString = RefactoringBundle.message(\"occurences.string\", occurrences.size());\n      String question = RefactoringBundle.message(\"inline.parameter.confirmation\", psiParameter.getName(),\n                                                  constantExpression.getText()) + \" \" + occurencesString;\n      RefactoringMessageDialog dialog = new RefactoringMessageDialog(\n        REFACTORING_NAME,\n        question,\n        HelpID.INLINE_VARIABLE,\n        \"OptionPane.questionIcon\",\n        true,\n        project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return;\n      }\n    }\n\n    new WriteCommandAction(project,\n                           RefactoringBundle.message(\"inline.parameter.command.name\", psiParameter.getName()),\n                           containingFiles.toArray(new PsiFile[containingFiles.size()]) ) {\n      protected void run(final Result result) throws Throwable {\n        SameParameterValueInspection.InlineParameterValueFix.inlineSameParameterValue(method, psiParameter, constantExpression);\n      }\n\n      protected UndoConfirmationPolicy getUndoConfirmationPolicy() {\n        return UndoConfirmationPolicy.DEFAULT;\n      }\n    }.execute();\n  }","id":40004,"modified_method":"public void inlineElement(final Project project, final Editor editor, final PsiElement psiElement) {\n    final PsiParameter psiParameter = (PsiParameter) psiElement;\n    final PsiParameterList parameterList = (PsiParameterList) psiParameter.getParent();\n    if (!(parameterList.getParent() instanceof PsiMethod)) {\n      return;\n    }\n    final int index = parameterList.getParameterIndex(psiParameter);\n    final PsiMethod method = (PsiMethod) parameterList.getParent();\n\n    String errorMessage = getCannotInlineMessage(psiParameter, method);\n    if (errorMessage != null) {\n      CommonRefactoringUtil.showErrorHint(project, editor, errorMessage, RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    final Ref<PsiExpression> refInitializer = new Ref<PsiExpression>();\n    final Ref<PsiExpression> refConstantInitializer = new Ref<PsiExpression>();\n    final Ref<PsiCallExpression> refMethodCall = new Ref<PsiCallExpression>();\n    final List<PsiReference> occurrences = new ArrayList<PsiReference>();\n    final Collection<PsiFile> containingFiles = new HashSet<PsiFile>();\n    containingFiles.add(psiParameter.getContainingFile());\n    boolean result = ReferencesSearch.search(method).forEach(new Processor<PsiReference>() {\n      public boolean process(final PsiReference psiReference) {\n        PsiElement element = psiReference.getElement();\n        final PsiElement parent = element.getParent();\n        if (parent instanceof PsiCallExpression) {\n          final PsiCallExpression methodCall = (PsiCallExpression)parent;\n          occurrences.add(psiReference);\n          containingFiles.add(element.getContainingFile());\n          final PsiExpression[] expressions = methodCall.getArgumentList().getExpressions();\n          if (expressions.length <= index) return false;\n          PsiExpression argument = expressions[index];\n          if (!refInitializer.isNull()) {\n            return argument != null\n                   && PsiEquivalenceUtil.areElementsEquivalent(refInitializer.get(), argument)\n                   && PsiEquivalenceUtil.areElementsEquivalent(refMethodCall.get(), methodCall);\n          }\n          if (InlineToAnonymousConstructorProcessor.isConstant(argument) || getReferencedFinalField(argument) != null) {\n            if (refConstantInitializer.isNull()) {\n              refConstantInitializer.set(argument);\n            }\n            else if (!isSameConstant(argument, refConstantInitializer.get())) {\n              return false;\n            }\n          } else if (!isRecursiveReferencedParameter(argument, psiParameter)) {\n            if (!refConstantInitializer.isNull()) return false;\n            refInitializer.set(argument);\n            refMethodCall.set(methodCall);\n          }\n        }\n        return true;\n      }\n    });\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiElement refExpr = psiElement.getContainingFile().findElementAt(offset);\n    final PsiCodeBlock codeBlock = PsiTreeUtil.getParentOfType(refExpr, PsiCodeBlock.class);\n    if (codeBlock != null) {\n      final PsiElement[] defs = DefUseUtil.getDefs(codeBlock, psiParameter, refExpr);\n      if (defs.length == 1) {\n        final PsiElement def = defs[0];\n        if (def instanceof PsiReferenceExpression && PsiUtil.isOnAssignmentLeftHand((PsiExpression)def)) {\n          final PsiExpression rExpr = ((PsiAssignmentExpression)def.getParent()).getRExpression();\n          if (rExpr != null) {\n            final PsiElement[] refs = DefUseUtil.getRefs(codeBlock, psiParameter, refExpr);\n\n            if (InlineLocalHandler.checkRefsInAugmentedAssignmentOrUnaryModified(refs) == null) {\n              new WriteCommandAction(project) {\n                @Override\n                protected void run(Result result) throws Throwable {\n                  for (final PsiElement ref : refs) {\n                    InlineUtil.inlineVariable(psiParameter, rExpr, (PsiJavaCodeReferenceElement)ref);\n                  }\n                  def.getParent().delete();\n                }\n              }.execute();\n              return;\n            }\n          }\n        }\n      }\n    }\n    if (occurrences.isEmpty()) {\n      CommonRefactoringUtil\n        .showErrorHint(project, editor, \"Method has no usages\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n    if (!result) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Cannot find constant initializer for parameter\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n    if (!refInitializer.isNull()) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        final InlineParameterExpressionProcessor processor =\n          new InlineParameterExpressionProcessor(refMethodCall.get(), method, psiParameter, refInitializer.get(),\n                                                 method.getProject().getUserData(\n                                                   InlineParameterExpressionProcessor.CREATE_LOCAL_FOR_TESTS));\n        processor.run();\n      }\n      else {\n        final boolean createLocal = ReferencesSearch.search(psiParameter).findAll().size() > 1;\n        InlineParameterDialog dlg = new InlineParameterDialog(refMethodCall.get(), method, psiParameter, refInitializer.get(), createLocal);\n        dlg.show();\n      }\n      return;\n    }\n    if (refConstantInitializer.isNull()) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Cannot find constant initializer for parameter\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    final Ref<Boolean> isNotConstantAccessible = new Ref<Boolean>();\n    final PsiExpression constantExpression = refConstantInitializer.get();\n    constantExpression.accept(new JavaRecursiveElementVisitor(){\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        final PsiElement resolved = expression.resolve();\n        if (resolved instanceof PsiMember && !PsiUtil.isAccessible((PsiMember)resolved, method, null)) {\n          isNotConstantAccessible.set(Boolean.TRUE);\n        }\n      }\n    });\n    if (!isNotConstantAccessible.isNull() && isNotConstantAccessible.get()) {\n      CommonRefactoringUtil.showErrorHint(project, editor, \"Constant initializer is not accessible in method body\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n      return;\n    }\n\n    for (PsiReference psiReference : ReferencesSearch.search(psiParameter)) {\n      final PsiElement element = psiReference.getElement();\n      if (element instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)element)) {\n        CommonRefactoringUtil.showErrorHint(project, editor, \"Inline parameter which has write usages is not supported\", RefactoringBundle.message(\"inline.parameter.refactoring\"), null);\n        return;\n      }\n    }\n\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      String occurencesString = RefactoringBundle.message(\"occurences.string\", occurrences.size());\n      String question = RefactoringBundle.message(\"inline.parameter.confirmation\", psiParameter.getName(),\n                                                  constantExpression.getText()) + \" \" + occurencesString;\n      RefactoringMessageDialog dialog = new RefactoringMessageDialog(\n        REFACTORING_NAME,\n        question,\n        HelpID.INLINE_VARIABLE,\n        \"OptionPane.questionIcon\",\n        true,\n        project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return;\n      }\n    }\n\n    new WriteCommandAction(project,\n                           RefactoringBundle.message(\"inline.parameter.command.name\", psiParameter.getName()),\n                           containingFiles.toArray(new PsiFile[containingFiles.size()]) ) {\n      protected void run(final Result result) throws Throwable {\n        SameParameterValueInspection.InlineParameterValueFix.inlineSameParameterValue(method, psiParameter, constantExpression);\n      }\n\n      protected UndoConfirmationPolicy getUndoConfirmationPolicy() {\n        return UndoConfirmationPolicy.DEFAULT;\n      }\n    }.execute();\n  }","commit_id":"27ec83e3d7fc26af86b7b62b6dacc2ad918f35f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void invokeCompletion(final ExpressionContext context) {\n    final Project project = context.getProject();\n    final Editor editor = context.getEditor();\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    new WriteCommandAction.Simple(project, psiFile) {\n        public void run() {\n          PsiDocumentManager.getInstance(project).commitAllDocuments();\n          getCompletionHandler().invoke(project, editor, psiFile);\n        }\n      }.execute();\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (!project.isOpen()) return;\n        CommandProcessor.getInstance().executeCommand(\n            project, new Runnable() {\n            public void run() {\n              final LookupManager lookupManager = LookupManager.getInstance(project);\n              Lookup lookup = lookupManager.getActiveLookup();\n\n              if (lookup != null) {\n                lookup.addLookupListener(new MyLookupListener(context));\n              }\n              else {\n                TemplateState templateState = TemplateManagerImpl.getTemplateState(editor);\n                if (templateState != null) {\n                  TextRange range = templateState.getCurrentVariableRange();\n                  if (range != null && range.getLength() > 0/* && TemplateEditorUtil.getOffset(editor) == range.getEndOffset()*/) {\n                    templateState.nextTab();\n                  }\n                }\n              }\n            }\n          },\n            \"\",\n            null\n        );\n      }\n    });\n  }","id":40005,"modified_method":"private void invokeCompletion(final ExpressionContext context) {\n    final Project project = context.getProject();\n    final Editor editor = context.getEditor();\n\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    new WriteCommandAction.Simple(project, psiFile) {\n        public void run() {\n          PsiDocumentManager.getInstance(project).commitAllDocuments();\n        }\n      }.execute();\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      getCompletionHandler().invoke(project, editor, psiFile);\n    }\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (!project.isOpen()) return;\n\n        CommandProcessor.getInstance().executeCommand(\n            project, new Runnable() {\n            public void run() {\n              if (!ApplicationManager.getApplication().isUnitTestMode()) {\n                getCompletionHandler().invoke(project, editor, psiFile);\n              }\n\n              final LookupManager lookupManager = LookupManager.getInstance(project);\n              Lookup lookup = lookupManager.getActiveLookup();\n\n              if (lookup != null) {\n                lookup.addLookupListener(new MyLookupListener(context));\n              }\n              else {\n                TemplateState templateState = TemplateManagerImpl.getTemplateState(editor);\n                if (templateState != null) {\n                  TextRange range = templateState.getCurrentVariableRange();\n                  if (range != null && range.getLength() > 0/* && TemplateEditorUtil.getOffset(editor) == range.getEndOffset()*/) {\n                    templateState.nextTab();\n                  }\n                }\n              }\n            }\n          },\n            \"\",\n            null\n        );\n      }\n    });\n  }","commit_id":"0045dbbeb5d8b15af74f776074824f867c244609","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void invoke(final Project project, final Editor editor, PsiFile psiFile) {\n    final Document document = editor.getDocument();\n    if (editor.isViewer()) {\n      document.fireReadOnlyModificationAttempt();\n      return;\n    }\n    if (!psiFile.isWritable() && !FileDocumentManager.fileForDocumentCheckedOutSuccessfully(document, project)) {\n      return;\n    }\n\n    final CompletionProgressIndicator indicator = CompletionProgressIndicator.getCurrentCompletion();\n    if (indicator != null) {\n      if (!indicator.isRunning() &&\n          !indicator.isCanceled() &&\n          indicator.getHandler().getClass().equals(getClass()) &&\n          (!isAutocompleteCommonPrefixOnInvocation() || indicator.fillInCommonPrefix())) {\n        return;\n      }\n      indicator.closeAndFinish();\n    }\n\n    final PsiFile file = psiFile;\n\n    final CompletionInitializationContext initializationContext = new WriteCommandAction<CompletionInitializationContext>(project) {\n      protected void run(Result<CompletionInitializationContext> result) throws Throwable {\n        final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n\n        EditorUtil.fillVirtualSpaceUntil(editor, editor.getCaretModel().getLogicalPosition().column, editor.getCaretModel().getLogicalPosition().line);\n        documentManager.commitAllDocuments();\n        final CompletionInitializationContext initializationContext = new CompletionInitializationContext(editor, file, myCompletionType);\n        result.setResult(initializationContext);\n\n        DaemonCodeAnalyzer.getInstance(project).autoImportReferenceAtCursor(editor, file);\n        PostprocessReformattingAspect.getInstance(project).doPostponedFormatting(file.getViewProvider());\n\n        documentManager.commitAllDocuments();\n        for (final CompletionContributor contributor : Extensions.getExtensions(CompletionContributor.EP_NAME)) {\n          contributor.beforeCompletion(initializationContext);\n          assert !documentManager.isUncommited(editor.getDocument()) : \"Contributor \" + contributor + \" left the document uncommitted\";\n        }\n      }\n    }.execute().getResultObject();\n\n\n    final int offset1 = initializationContext.getStartOffset();\n    final int offset2 = initializationContext.getSelectionEndOffset();\n    final CompletionContext context = new CompletionContext(project, editor, file, initializationContext.getOffsetMap());\n\n    doComplete(offset1, offset2, context, initializationContext.getDummyIdentifier(), editor);\n  }","id":40006,"modified_method":"public final void invoke(final Project project, final Editor editor, PsiFile psiFile) {\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      assert !ApplicationManager.getApplication().isWriteAccessAllowed();\n    }\n\n    final Document document = editor.getDocument();\n    if (editor.isViewer()) {\n      document.fireReadOnlyModificationAttempt();\n      return;\n    }\n    if (!psiFile.isWritable() && !FileDocumentManager.fileForDocumentCheckedOutSuccessfully(document, project)) {\n      return;\n    }\n\n    final CompletionProgressIndicator indicator = CompletionProgressIndicator.getCurrentCompletion();\n    if (indicator != null) {\n      if (!indicator.isRunning() &&\n          !indicator.isCanceled() &&\n          indicator.getHandler().getClass().equals(getClass()) &&\n          (!isAutocompleteCommonPrefixOnInvocation() || indicator.fillInCommonPrefix())) {\n        return;\n      }\n      indicator.closeAndFinish();\n    }\n\n    final PsiFile file = psiFile;\n\n    final CompletionInitializationContext initializationContext = new WriteCommandAction<CompletionInitializationContext>(project) {\n      protected void run(Result<CompletionInitializationContext> result) throws Throwable {\n        final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n\n        EditorUtil.fillVirtualSpaceUntil(editor, editor.getCaretModel().getLogicalPosition().column, editor.getCaretModel().getLogicalPosition().line);\n        documentManager.commitAllDocuments();\n        final CompletionInitializationContext initializationContext = new CompletionInitializationContext(editor, file, myCompletionType);\n        result.setResult(initializationContext);\n\n        DaemonCodeAnalyzer.getInstance(project).autoImportReferenceAtCursor(editor, file);\n        PostprocessReformattingAspect.getInstance(project).doPostponedFormatting(file.getViewProvider());\n\n        documentManager.commitAllDocuments();\n        for (final CompletionContributor contributor : Extensions.getExtensions(CompletionContributor.EP_NAME)) {\n          contributor.beforeCompletion(initializationContext);\n          assert !documentManager.isUncommited(editor.getDocument()) : \"Contributor \" + contributor + \" left the document uncommitted\";\n        }\n      }\n    }.execute().getResultObject();\n\n\n    final int offset1 = initializationContext.getStartOffset();\n    final int offset2 = initializationContext.getSelectionEndOffset();\n    final CompletionContext context = new CompletionContext(project, editor, file, initializationContext.getOffsetMap());\n\n    doComplete(offset1, offset2, context, initializationContext.getDummyIdentifier(), editor);\n  }","commit_id":"0045dbbeb5d8b15af74f776074824f867c244609","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void handleEmptyLookup(CompletionContext context, LookupData lookupData, final CompletionParameters parameters) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n    Project project = context.project;\n    Editor editor = context.editor;\n\n    LOG.assertTrue(lookupData.items.length == 0);\n    final String text = CompletionService.getCompletionService().getEmptyLookupText(parameters);\n    if (StringUtil.isNotEmpty(text)) {\n      HintManager.getInstance().showErrorHint(editor, text);\n    }\n    DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    if (codeAnalyzer != null) {\n      codeAnalyzer.updateVisibleHighlighters(editor);\n    }\n  }","id":40007,"modified_method":"protected void handleEmptyLookup(CompletionContext context, LookupData lookupData, final CompletionParameters parameters) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n    Project project = context.project;\n    Editor editor = context.editor;\n\n    LOG.assertTrue(lookupData.items.length == 0);\n    String text = CompletionService.getCompletionService().getEmptyLookupText(parameters);\n    if (StringUtil.isEmpty(text)) {\n      text = LangBundle.message(\"completion.no.suggestions\");\n    }\n    HintManager.getInstance().showErrorHint(editor, text);\n    DaemonCodeAnalyzer codeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n    if (codeAnalyzer != null) {\n      codeAnalyzer.updateVisibleHighlighters(editor);\n    }\n  }","commit_id":"0045dbbeb5d8b15af74f776074824f867c244609","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void generateInstanceOfBarrierIfNeeded(\n            @NotNull InstructionAdapter iv,\n            @NotNull FunctionDescriptor descriptor,\n            @NotNull Method bridge,\n            @NotNull Method delegateTo\n    ) {\n        if (BuiltinMethodsWithSpecialJvmSignature.getOverriddenBuiltinFunctionWithErasedValueParametersInJava(descriptor) == null) return;\n\n        assert descriptor.getValueParameters().size() == 1 : \"Should be descriptor with one value parameter, but found: \" + descriptor;\n\n        iv.load(1, OBJECT_TYPE);\n\n        JetType jetType = descriptor.getValueParameters().get(0).getType();\n\n        // TODO: reuse logic from ExpressionCodegen\n        if (jetType.isMarkedNullable()) {\n            Label nope = new Label();\n            Label end = new Label();\n\n            iv.dup();\n            iv.ifnull(nope);\n            TypeIntrinsics.instanceOf(\n                    iv,\n                    jetType,\n                    boxType(delegateTo.getArgumentTypes()[0])\n            );\n            iv.goTo(end);\n            iv.mark(nope);\n            iv.pop();\n            iv.iconst(1);\n            iv.mark(end);\n        }\n        else {\n            TypeIntrinsics.instanceOf(\n                    iv,\n                    jetType,\n                    boxType(delegateTo.getArgumentTypes()[0])\n            );\n        }\n\n        Label afterBarrier = new Label();\n\n        iv.ifne(afterBarrier);\n\n        StackValue.none().put(bridge.getReturnType(), iv);\n        iv.areturn(bridge.getReturnType());\n\n        iv.visitLabel(afterBarrier);\n    }","id":40008,"modified_method":"private static void generateInstanceOfBarrierIfNeeded(\n            @NotNull InstructionAdapter iv,\n            @NotNull FunctionDescriptor descriptor,\n            @NotNull Method bridge,\n            @NotNull Method delegateTo\n    ) {\n        if (BuiltinMethodsWithSpecialJvmSignature.getOverriddenBuiltinFunctionWithErasedValueParametersInJava(descriptor) == null) return;\n\n        assert descriptor.getValueParameters().size() == 1 : \"Should be descriptor with one value parameter, but found: \" + descriptor;\n\n        iv.load(1, OBJECT_TYPE);\n\n        JetType jetType = descriptor.getValueParameters().get(0).getType();\n\n        // TODO: reuse logic from ExpressionCodegen\n        if (jetType.isMarkedNullable()) {\n            Label nope = new Label();\n            Label end = new Label();\n\n            iv.dup();\n            iv.ifnull(nope);\n            TypeIntrinsics.instanceOf(\n                    iv,\n                    jetType,\n                    boxType(delegateTo.getArgumentTypes()[0])\n            );\n            iv.goTo(end);\n            iv.mark(nope);\n            iv.pop();\n            iv.iconst(1);\n            iv.mark(end);\n        }\n        else {\n            TypeIntrinsics.instanceOf(\n                    iv,\n                    jetType,\n                    boxType(delegateTo.getArgumentTypes()[0])\n            );\n        }\n\n        Label afterBarrier = new Label();\n\n        iv.ifne(afterBarrier);\n\n        String shortName = getFqName(descriptor).shortName().asString();\n        StackValue returnValue =\n                (\"indexOf\".equals(shortName) || \"lastIndexOf\".equals(shortName)) ? StackValue.constant(-1, Type.INT_TYPE) : StackValue.none();\n\n        returnValue.put(bridge.getReturnType(), iv);\n        iv.areturn(bridge.getReturnType());\n\n        iv.visitLabel(afterBarrier);\n    }","commit_id":"935024db4ec834ab93bde3fa9251ba5783c166aa","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void onOutput(OutputEvent event) {\n        try {\n            if (event instanceof ProgressStartEvent) {\n                ProgressStartEvent startEvent = (ProgressStartEvent) event;\n                ProgressOperation op = operations.start(startEvent.getShortDescription(), startEvent.getStatus(), startEvent.getOperationId(), startEvent.getParentOperationId());\n                updateText(op);\n            } else if (event instanceof ProgressCompleteEvent) {\n                ProgressOperation op = operations.complete(((ProgressCompleteEvent) event).getOperationId());\n                updateText(op.getParent());\n            } else if (event instanceof ProgressEvent) {\n                ProgressEvent progressEvent = (ProgressEvent) event;\n                ProgressOperation op = operations.progress(progressEvent.getStatus(), progressEvent.getOperationId());\n                updateText(op);\n            }\n            listener.onOutput(event);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to process incoming event '\" + event\n                    + \"' (\" + event.getClass().getSimpleName() + \")\", e);\n        }\n    }","id":40009,"modified_method":"public void onOutput(OutputEvent event) {\n        try {\n            if (event instanceof ProgressStartEvent) {\n                ProgressStartEvent startEvent = (ProgressStartEvent) event;\n                ProgressOperation op = operations.start(startEvent.getShortDescription(), startEvent.getStatus(), startEvent.getOperationId().getId(), startEvent.getOperationId().getParentId());\n                updateText(op);\n            } else if (event instanceof ProgressCompleteEvent) {\n                ProgressOperation op = operations.complete(((ProgressCompleteEvent) event).getOperationId().getId());\n                updateText(op.getParent());\n            } else if (event instanceof ProgressEvent) {\n                ProgressEvent progressEvent = (ProgressEvent) event;\n                ProgressOperation op = operations.progress(progressEvent.getStatus(), progressEvent.getOperationId().getId());\n                updateText(op);\n            }\n            listener.onOutput(event);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to process incoming event '\" + event\n                    + \"' (\" + event.getClass().getSimpleName() + \")\", e);\n        }\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long currentOperationId() {\n            return hierarchy.currentOperationId();\n        }","id":40010,"modified_method":"public OperationIdentifier currentOperationId() {\n            return hierarchy.currentOperationId();\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public void started(String status) {\n            if (!GUtil.isTrue(description)) {\n                throw new IllegalStateException(\"A description must be specified before this operation is started.\");\n            }\n            if (state == State.started) {\n                throw new IllegalStateException(\"This operation has already been started.\");\n            }\n            assertNotCompleted();\n            state = State.started;\n            OperationIdentifier id = hierarchy.start();\n            listener.started(new ProgressStartEvent(id.getId(), id.getParentId(), timeProvider.getCurrentTime(), category, description, shortDescription, loggingHeader, toStatus(status)));\n        }","id":40011,"modified_method":"public void started(String status) {\n            if (!GUtil.isTrue(description)) {\n                throw new IllegalStateException(\"A description must be specified before this operation is started.\");\n            }\n            if (state == State.started) {\n                throw new IllegalStateException(\"This operation has already been started.\");\n            }\n            assertNotCompleted();\n            state = State.started;\n            OperationIdentifier id = hierarchy.start();\n            listener.started(new ProgressStartEvent(id, timeProvider.getCurrentTime(), category, description, shortDescription, loggingHeader, toStatus(status)));\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long completeCurrentOperation() {\n        assertOperationStarted();\n        assertHierarchyNotEmpty();\n        Long last = hierarchy.getLast();\n        if (id.getId() == last) {\n            //typical scenario\n            hierarchy.removeLast();\n        } else {\n            //this means that we're removing an operation id that has incomplete children\n            //this is not strictly correct, we might fail fast here\n            //however, this needs some discussion and making sure child operations are always completed before the parent\n            //(even in internal error conditions)\n            hierarchy.remove(id.getId());\n        }\n        long out = id.getId();\n        id = null;\n        return out;\n    }","id":40012,"modified_method":"public OperationIdentifier completeCurrentOperation() {\n        assertOperationStarted();\n        assertHierarchyNotEmpty();\n        Long last = hierarchy.getLast();\n        OperationIdentifier currentOp = id;\n        if (currentOp.getId() == last) {\n            //typical scenario\n            hierarchy.removeLast();\n        } else {\n            //this means that we're removing an operation id that has incomplete children\n            //this is not strictly correct, we might fail fast here\n            //however, this needs some discussion and making sure child operations are always completed before the parent\n            //(even in internal error conditions)\n            hierarchy.remove(currentOp.getId());\n        }\n        id = null;\n        return currentOp;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long currentOperationId() {\n        assertOperationStarted();\n        return id.getId();\n    }","id":40013,"modified_method":"public OperationIdentifier currentOperationId() {\n        assertOperationStarted();\n        return id;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public OperationsHierarchy currentHierarchy(ProgressLogger parentHint) {\n        LinkedList<Long> h = hierarchy.get();\n        if (h == null) {\n            h = new LinkedList<Long>();\n            if (parentHint != null) {\n                h.add(parentHint.currentOperationId());\n            }\n            hierarchy.set(h);\n        }\n        return new OperationsHierarchy(sharedCounter, h);\n    }","id":40014,"modified_method":"public OperationsHierarchy currentHierarchy(ProgressLogger parentHint) {\n        LinkedList<Long> h = hierarchy.get();\n        if (h == null) {\n            h = new LinkedList<Long>();\n            if (parentHint != null) {\n                h.add(parentHint.currentOperationId().getId());\n            }\n            hierarchy.set(h);\n        }\n        return new OperationsHierarchy(sharedCounter, h);\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressCompleteEvent(long operationId, long timestamp, String category, String description, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n        this.description = description;\n    }","id":40015,"modified_method":"public ProgressCompleteEvent(OperationIdentifier operationId, long timestamp, String category, String description, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n        this.description = description;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40016,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressEvent(long operationId, long timestamp, String category, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n    }","id":40017,"modified_method":"public ProgressEvent(OperationIdentifier operationId, long timestamp, String category, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40018,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public void completeHeader() {\n            boolean hasDescription = GUtil.isTrue(loggingHeader);\n            switch (state) {\n                case None:\n                    if (hasDescription) {\n                        listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, EOL));\n                    break;\n                case HeaderCompleted:\n                    return;\n                default:\n                    throw new IllegalStateException();\n            }\n            state = State.HeaderCompleted;\n        }","id":40019,"modified_method":"public void completeHeader() {\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader) {\n                        listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, EOL));\n                    break;\n                case HeaderCompleted:\n                    return;\n                default:\n                    throw new IllegalStateException(\"state is \" + state);\n            }\n            state = State.HeaderCompleted;\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"private void doOutput(RenderableOutputEvent event) {\n        for (Operation operation : operations) {\n            operation.completeHeader();\n        }\n        listener.onOutput(event);\n    }","id":40020,"modified_method":"private void doOutput(RenderableOutputEvent event) {\n        for (Operation operation : operations.values()) {\n            operation.completeHeader();\n        }\n        listener.onOutput(event);\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public void complete() {\n            boolean hasStatus = GUtil.isTrue(status);\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else if (hasLoggingHeader) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    assert hasLoggingHeader;\n                    if (hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(\" \"),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, EOL));\n                    }\n                    break;\n                case HeaderCompleted:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException();\n            }\n            state = State.Completed;\n        }","id":40021,"modified_method":"public void complete() {\n            boolean hasStatus = GUtil.isTrue(status);\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else if (hasLoggingHeader) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    assert hasLoggingHeader;\n                    if (hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(\" \"),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, EOL));\n                    }\n                    break;\n                case HeaderCompleted:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"state is \" + state);\n            }\n            state = State.Completed;\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"private void onStart(ProgressStartEvent progressStartEvent) {\n        Operation operation = new Operation(progressStartEvent.getCategory(), progressStartEvent.getLoggingHeader(), progressStartEvent.getTimestamp());\n        operations.add(operation);\n\n        if (!deferHeader || !(progressStartEvent.getLoggingHeader() != null && progressStartEvent.getLoggingHeader().equals(progressStartEvent.getShortDescription()))) {\n            operation.startHeader();\n        }\n    }","id":40022,"modified_method":"private void onStart(ProgressStartEvent progressStartEvent) {\n        Operation operation = new Operation(progressStartEvent.getCategory(), progressStartEvent.getLoggingHeader(), progressStartEvent.getTimestamp());\n        operations.put(progressStartEvent.getOperationId(), operation);\n\n        if (!deferHeader || !(progressStartEvent.getLoggingHeader() != null && progressStartEvent.getLoggingHeader().equals(progressStartEvent.getShortDescription()))) {\n            operation.startHeader();\n        }\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"private void doOutput(RenderableOutputEvent event) {\n            for (Operation pending : operations) {\n                if (pending == this) {\n                    break;\n                }\n                pending.completeHeader();\n            }\n            listener.onOutput(event);\n        }","id":40023,"modified_method":"private void doOutput(RenderableOutputEvent event) {\n            for (Operation pending : operations.values()) {\n                if (pending == this) {\n                    break;\n                }\n                pending.completeHeader();\n            }\n            listener.onOutput(event);\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"private void onComplete(ProgressCompleteEvent progressCompleteEvent) {\n        assert !operations.isEmpty();\n        Operation operation = operations.removeLast();\n        operation.status = progressCompleteEvent.getStatus();\n        operation.completeTime = progressCompleteEvent.getTimestamp();\n        operation.complete();\n    }","id":40024,"modified_method":"private void onComplete(ProgressCompleteEvent progressCompleteEvent) {\n        assert !operations.isEmpty();\n        Operation operation = operations.remove(progressCompleteEvent.getOperationId());\n\n        // Didn't find an operation with that id in the map\n        if (operation == null) {\n            // Remove last operation and complete that\n            Iterator<Map.Entry<OperationIdentifier, Operation>> entryIterator = operations.entrySet().iterator();\n            Map.Entry<OperationIdentifier, Operation> lastEntry = entryIterator.next();\n            while (entryIterator.hasNext()) {\n                lastEntry = entryIterator.next();\n            }\n            entryIterator.remove();\n            operation = lastEntry.getValue();\n            // TODO: Do we actually run into this case anymore?\n        }\n        completeOperation(progressCompleteEvent, operation);\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"private Operation(String category, String loggingHeader, long startTime) {\n            this.category = category;\n            this.loggingHeader = loggingHeader;\n            this.startTime = startTime;\n            hasLoggingHeader = GUtil.isTrue(loggingHeader);\n        }","id":40025,"modified_method":"private Operation(String category, String loggingHeader, long startTime) {\n            this.category = category;\n            this.loggingHeader = loggingHeader;\n            this.startTime = startTime;\n            this.hasLoggingHeader = GUtil.isTrue(loggingHeader);\n        }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressStartEvent(long operationId, Long parentOperationId, long timestamp, String category, String description, String shortDescription, String loggingHeader, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.parentOperationId = parentOperationId;\n        this.description = description;\n        this.shortDescription = shortDescription;\n        this.loggingHeader = loggingHeader;\n        this.status = status;\n    }","id":40026,"modified_method":"public ProgressStartEvent(OperationIdentifier operationId, long timestamp, String category, String description, String shortDescription, String loggingHeader, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.description = description;\n        this.shortDescription = shortDescription;\n        this.loggingHeader = loggingHeader;\n        this.status = status;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40027,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"cb401a1ebad0ba248f6c3b96188e41c25e53de59","url":"https://github.com/gradle/gradle"},{"original_method":"public void onOutput(OutputEvent event) {\n        try {\n            if (event instanceof ProgressStartEvent) {\n                ProgressStartEvent startEvent = (ProgressStartEvent) event;\n                ProgressOperation op = operations.start(startEvent.getShortDescription(), startEvent.getStatus(), startEvent.getOperationId(), startEvent.getParentOperationId());\n                updateText(op);\n            } else if (event instanceof ProgressCompleteEvent) {\n                ProgressOperation op = operations.complete(((ProgressCompleteEvent) event).getOperationId());\n                updateText(op.getParent());\n            } else if (event instanceof ProgressEvent) {\n                ProgressEvent progressEvent = (ProgressEvent) event;\n                ProgressOperation op = operations.progress(progressEvent.getStatus(), progressEvent.getOperationId());\n                updateText(op);\n            }\n            listener.onOutput(event);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to process incoming event '\" + event\n                    + \"' (\" + event.getClass().getSimpleName() + \")\", e);\n        }\n    }","id":40028,"modified_method":"public void onOutput(OutputEvent event) {\n        try {\n            if (event instanceof ProgressStartEvent) {\n                ProgressStartEvent startEvent = (ProgressStartEvent) event;\n                ProgressOperation op = operations.start(startEvent.getShortDescription(), startEvent.getStatus(), startEvent.getOperationId().getId(), startEvent.getOperationId().getParentId());\n                updateText(op);\n            } else if (event instanceof ProgressCompleteEvent) {\n                ProgressOperation op = operations.complete(((ProgressCompleteEvent) event).getOperationId().getId());\n                updateText(op.getParent());\n            } else if (event instanceof ProgressEvent) {\n                ProgressEvent progressEvent = (ProgressEvent) event;\n                ProgressOperation op = operations.progress(progressEvent.getStatus(), progressEvent.getOperationId().getId());\n                updateText(op);\n            }\n            listener.onOutput(event);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to process incoming event '\" + event\n                    + \"' (\" + event.getClass().getSimpleName() + \")\", e);\n        }\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long currentOperationId() {\n            return hierarchy.currentOperationId();\n        }","id":40029,"modified_method":"public OperationIdentifier currentOperationId() {\n            return hierarchy.currentOperationId();\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public void started(String status) {\n            if (!GUtil.isTrue(description)) {\n                throw new IllegalStateException(\"A description must be specified before this operation is started.\");\n            }\n            if (state == State.started) {\n                throw new IllegalStateException(\"This operation has already been started.\");\n            }\n            assertNotCompleted();\n            state = State.started;\n            OperationIdentifier id = hierarchy.start();\n            listener.started(new ProgressStartEvent(id.getId(), id.getParentId(), timeProvider.getCurrentTime(), category, description, shortDescription, loggingHeader, toStatus(status)));\n        }","id":40030,"modified_method":"public void started(String status) {\n            if (!GUtil.isTrue(description)) {\n                throw new IllegalStateException(\"A description must be specified before this operation is started.\");\n            }\n            if (state == State.started) {\n                throw new IllegalStateException(\"This operation has already been started.\");\n            }\n            assertNotCompleted();\n            state = State.started;\n            OperationIdentifier id = hierarchy.start();\n            listener.started(new ProgressStartEvent(id, timeProvider.getCurrentTime(), category, description, shortDescription, loggingHeader, toStatus(status)));\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long completeCurrentOperation() {\n        assertOperationStarted();\n        assertHierarchyNotEmpty();\n        Long last = hierarchy.getLast();\n        if (id.getId() == last) {\n            //typical scenario\n            hierarchy.removeLast();\n        } else {\n            //this means that we're removing an operation id that has incomplete children\n            //this is not strictly correct, we might fail fast here\n            //however, this needs some discussion and making sure child operations are always completed before the parent\n            //(even in internal error conditions)\n            hierarchy.remove(id.getId());\n        }\n        long out = id.getId();\n        id = null;\n        return out;\n    }","id":40031,"modified_method":"public OperationIdentifier completeCurrentOperation() {\n        assertOperationStarted();\n        assertHierarchyNotEmpty();\n        Long last = hierarchy.getLast();\n        OperationIdentifier currentOp = id;\n        if (currentOp.getId() == last) {\n            //typical scenario\n            hierarchy.removeLast();\n        } else {\n            //this means that we're removing an operation id that has incomplete children\n            //this is not strictly correct, we might fail fast here\n            //however, this needs some discussion and making sure child operations are always completed before the parent\n            //(even in internal error conditions)\n            hierarchy.remove(currentOp.getId());\n        }\n        id = null;\n        return currentOp;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long currentOperationId() {\n        assertOperationStarted();\n        return id.getId();\n    }","id":40032,"modified_method":"public OperationIdentifier currentOperationId() {\n        assertOperationStarted();\n        return id;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public OperationsHierarchy currentHierarchy(ProgressLogger parentHint) {\n        LinkedList<Long> h = hierarchy.get();\n        if (h == null) {\n            h = new LinkedList<Long>();\n            if (parentHint != null) {\n                h.add(parentHint.currentOperationId());\n            }\n            hierarchy.set(h);\n        }\n        return new OperationsHierarchy(sharedCounter, h);\n    }","id":40033,"modified_method":"public OperationsHierarchy currentHierarchy(ProgressLogger parentHint) {\n        LinkedList<Long> h = hierarchy.get();\n        if (h == null) {\n            h = new LinkedList<Long>();\n            if (parentHint != null) {\n                h.add(parentHint.currentOperationId().getId());\n            }\n            hierarchy.set(h);\n        }\n        return new OperationsHierarchy(sharedCounter, h);\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressCompleteEvent(long operationId, long timestamp, String category, String description, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n        this.description = description;\n    }","id":40034,"modified_method":"public ProgressCompleteEvent(OperationIdentifier operationId, long timestamp, String category, String description, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n        this.description = description;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40035,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40036,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressEvent(long operationId, long timestamp, String category, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n    }","id":40037,"modified_method":"public ProgressEvent(OperationIdentifier operationId, long timestamp, String category, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.status = status;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public void completeHeader() {\n            boolean hasDescription = GUtil.isTrue(loggingHeader);\n            switch (state) {\n                case None:\n                    if (hasDescription) {\n                        listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, EOL));\n                    break;\n                case HeaderCompleted:\n                    return;\n                default:\n                    throw new IllegalStateException();\n            }\n            state = State.HeaderCompleted;\n        }","id":40038,"modified_method":"public void completeHeader() {\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader) {\n                        listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    listener.onOutput(new StyledTextOutputEvent(startTime, category, LogLevel.LIFECYCLE, EOL));\n                    break;\n                case HeaderCompleted:\n                    return;\n                default:\n                    throw new IllegalStateException(\"state is \" + state);\n            }\n            state = State.HeaderCompleted;\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"private void doOutput(RenderableOutputEvent event) {\n            for (Operation pending : operations) {\n                if (pending == this) {\n                    break;\n                }\n                pending.completeHeader();\n            }\n            listener.onOutput(event);\n        }","id":40039,"modified_method":"private void doOutput(RenderableOutputEvent event) {\n            for (Operation pending : operations.values()) {\n                if (pending == this) {\n                    break;\n                }\n                pending.completeHeader();\n            }\n            listener.onOutput(event);\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"private Operation(String category, String loggingHeader, long startTime) {\n            this.category = category;\n            this.loggingHeader = loggingHeader;\n            this.startTime = startTime;\n            hasLoggingHeader = GUtil.isTrue(loggingHeader);\n        }","id":40040,"modified_method":"private Operation(String category, String loggingHeader, long startTime) {\n            this.category = category;\n            this.loggingHeader = loggingHeader;\n            this.startTime = startTime;\n            this.hasLoggingHeader = GUtil.isTrue(loggingHeader);\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public void complete() {\n            boolean hasStatus = GUtil.isTrue(status);\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else if (hasLoggingHeader) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    assert hasLoggingHeader;\n                    if (hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(\" \"),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, EOL));\n                    }\n                    break;\n                case HeaderCompleted:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException();\n            }\n            state = State.Completed;\n        }","id":40041,"modified_method":"public void complete() {\n            boolean hasStatus = GUtil.isTrue(status);\n            switch (state) {\n                case None:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else if (hasLoggingHeader) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, loggingHeader + EOL));\n                    }\n                    break;\n                case HeaderStarted:\n                    assert hasLoggingHeader;\n                    if (hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(\" \"),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    } else {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE, EOL));\n                    }\n                    break;\n                case HeaderCompleted:\n                    if (hasLoggingHeader && hasStatus) {\n                        doOutput(new StyledTextOutputEvent(completeTime, category, LogLevel.LIFECYCLE,\n                                new StyledTextOutputEvent.Span(loggingHeader + ' '),\n                                new StyledTextOutputEvent.Span(Style.ProgressStatus, status),\n                                new StyledTextOutputEvent.Span(EOL)));\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"state is \" + state);\n            }\n            state = State.Completed;\n        }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"private void onComplete(ProgressCompleteEvent progressCompleteEvent) {\n        assert !operations.isEmpty();\n        Operation operation = operations.removeLast();\n        operation.status = progressCompleteEvent.getStatus();\n        operation.completeTime = progressCompleteEvent.getTimestamp();\n        operation.complete();\n    }","id":40042,"modified_method":"private void onComplete(ProgressCompleteEvent progressCompleteEvent) {\n        assert !operations.isEmpty();\n        Operation operation = operations.remove(progressCompleteEvent.getOperationId());\n\n        // Didn't find an operation with that id in the map\n        if (operation == null) {\n            // Remove last operation and complete that\n            Iterator<Map.Entry<OperationIdentifier, Operation>> entryIterator = operations.entrySet().iterator();\n            Map.Entry<OperationIdentifier, Operation> lastEntry = entryIterator.next();\n            while (entryIterator.hasNext()) {\n                lastEntry = entryIterator.next();\n            }\n            entryIterator.remove();\n            operation = lastEntry.getValue();\n            // TODO: Do we actually run into this case anymore?\n        }\n        completeOperation(progressCompleteEvent, operation);\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"private void doOutput(RenderableOutputEvent event) {\n        for (Operation operation : operations) {\n            operation.completeHeader();\n        }\n        listener.onOutput(event);\n    }","id":40043,"modified_method":"private void doOutput(RenderableOutputEvent event) {\n        for (Operation operation : operations.values()) {\n            operation.completeHeader();\n        }\n        listener.onOutput(event);\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"private void onStart(ProgressStartEvent progressStartEvent) {\n        Operation operation = new Operation(progressStartEvent.getCategory(), progressStartEvent.getLoggingHeader(), progressStartEvent.getTimestamp());\n        operations.add(operation);\n\n        if (!deferHeader || !(progressStartEvent.getLoggingHeader() != null && progressStartEvent.getLoggingHeader().equals(progressStartEvent.getShortDescription()))) {\n            operation.startHeader();\n        }\n    }","id":40044,"modified_method":"private void onStart(ProgressStartEvent progressStartEvent) {\n        Operation operation = new Operation(progressStartEvent.getCategory(), progressStartEvent.getLoggingHeader(), progressStartEvent.getTimestamp());\n        operations.put(progressStartEvent.getOperationId(), operation);\n\n        if (!deferHeader || !(progressStartEvent.getLoggingHeader() != null && progressStartEvent.getLoggingHeader().equals(progressStartEvent.getShortDescription()))) {\n            operation.startHeader();\n        }\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public long getOperationId() {\n        return operationId;\n    }","id":40045,"modified_method":"public OperationIdentifier getOperationId() {\n        return operationId;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"public ProgressStartEvent(long operationId, Long parentOperationId, long timestamp, String category, String description, String shortDescription, String loggingHeader, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.parentOperationId = parentOperationId;\n        this.description = description;\n        this.shortDescription = shortDescription;\n        this.loggingHeader = loggingHeader;\n        this.status = status;\n    }","id":40046,"modified_method":"public ProgressStartEvent(OperationIdentifier operationId, long timestamp, String category, String description, String shortDescription, String loggingHeader, String status) {\n        super(timestamp, category, LogLevel.LIFECYCLE);\n        this.operationId = operationId;\n        this.description = description;\n        this.shortDescription = shortDescription;\n        this.loggingHeader = loggingHeader;\n        this.status = status;\n    }","commit_id":"73d46bd60427b880c4e6698f425ff5136d92291d","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                            String verb, String basePath, final String uriTemplate,\n                            String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // use a dummy endpoint\n        Endpoint endpoint = camelContext.getEndpoint(\"stub:dummy\");\n\n        return new DefaultProducer(endpoint) {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                String query = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class);\n                if (query != null) {\n                    String name = ObjectHelper.after(query, \"name=\");\n                    exchange.getIn().setBody(\"Bye \" + name);\n                }\n                String uri = exchange.getIn().getHeader(Exchange.HTTP_URI, String.class);\n                if (uri != null) {\n                    int pos = uri.lastIndexOf('/');\n                    String name = uri.substring(pos + 1);\n                    exchange.getIn().setBody(\"Hello \" + name);\n                }\n            }\n        };\n    }","id":40047,"modified_method":"@Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                            String verb, String basePath, final String uriTemplate, String queryParameters,\n                            String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        // use a dummy endpoint\n        Endpoint endpoint = camelContext.getEndpoint(\"stub:dummy\");\n\n        return new DefaultProducer(endpoint) {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                String query = exchange.getIn().getHeader(Exchange.REST_HTTP_QUERY, String.class);\n                if (query != null) {\n                    String name = ObjectHelper.after(query, \"name=\");\n                    exchange.getIn().setBody(\"Bye \" + name);\n                }\n                String uri = exchange.getIn().getHeader(Exchange.REST_HTTP_URI, String.class);\n                if (uri != null) {\n                    int pos = uri.lastIndexOf('/');\n                    String name = uri.substring(pos + 1);\n                    exchange.getIn().setBody(\"Hello \" + name);\n                }\n            }\n        };\n    }","commit_id":"b05fd50222b99d80920938bf99d02d670c6885d6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer() throws Exception {\n        RestProducerFactory factory = null;\n\n        if (apiDoc != null) {\n            LOG.debug(\"Discovering camel-swagger-java on classpath for using api-doc: {}\", apiDoc);\n            // lookup on classpath using factory finder to automatic find it (just add camel-swagger-java to classpath etc)\n            try {\n                FactoryFinder finder = getCamelContext().getFactoryFinder(RESOURCE_PATH);\n                Object instance = finder.newInstance(DEFAULT_API_COMPONENT_NAME);\n                if (instance instanceof RestProducerFactory) {\n                    // this factory from camel-swagger-java will facade the http component in use\n                    factory = (RestProducerFactory) instance;\n                }\n                parameters.put(\"apiDoc\", apiDoc);\n            } catch (NoFactoryAvailableException e) {\n                throw new IllegalStateException(\"Cannot find camel-swagger-java on classpath to use with api-doc: \" + apiDoc);\n            }\n        }\n\n        String cname = null;\n        if (factory == null && getComponentName() != null) {\n            Object comp = getCamelContext().getRegistry().lookupByName(getComponentName());\n            if (comp != null && comp instanceof RestProducerFactory) {\n                factory = (RestProducerFactory) comp;\n            } else {\n                comp = getCamelContext().getComponent(getComponentName());\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                }\n            }\n\n            if (factory == null) {\n                if (comp != null) {\n                    throw new IllegalArgumentException(\"Component \" + getComponentName() + \" is not a RestProducerFactory\");\n                } else {\n                    throw new NoSuchBeanException(getComponentName(), RestProducerFactory.class.getName());\n                }\n            }\n            cname = getComponentName();\n        }\n\n        // try all components\n        if (factory == null) {\n            for (String name : getCamelContext().getComponentNames()) {\n                Component comp = getCamelContext().getComponent(name);\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                    cname = name;\n                    break;\n                }\n            }\n        }\n\n        parameters.put(\"componentName\", cname);\n\n        // lookup in registry\n        if (factory == null) {\n            Set<RestProducerFactory> factories = getCamelContext().getRegistry().findByType(RestProducerFactory.class);\n            if (factories != null && factories.size() == 1) {\n                factory = factories.iterator().next();\n            }\n        }\n\n        if (factory != null) {\n            LOG.debug(\"Using RestProducerFactory: {}\", factory);\n            Producer producer = factory.createProducer(getCamelContext(), host, method, path, uriTemplate, queryParameters, consumes, produces, parameters);\n            return new RestProducer(this, producer);\n        } else {\n            throw new IllegalStateException(\"Cannot find RestProducerFactory in Registry or as a Component to use\");\n        }\n    }","id":40048,"modified_method":"@Override\n    public Producer createProducer() throws Exception {\n        RestProducerFactory apiDocFactory = null;\n        RestProducerFactory factory = null;\n\n        if (apiDoc != null) {\n            LOG.debug(\"Discovering camel-swagger-java on classpath for using api-doc: {}\", apiDoc);\n            // lookup on classpath using factory finder to automatic find it (just add camel-swagger-java to classpath etc)\n            try {\n                FactoryFinder finder = getCamelContext().getFactoryFinder(RESOURCE_PATH);\n                Object instance = finder.newInstance(DEFAULT_API_COMPONENT_NAME);\n                if (instance instanceof RestProducerFactory) {\n                    // this factory from camel-swagger-java will facade the http component in use\n                    apiDocFactory = (RestProducerFactory) instance;\n                }\n                parameters.put(\"apiDoc\", apiDoc);\n            } catch (NoFactoryAvailableException e) {\n                throw new IllegalStateException(\"Cannot find camel-swagger-java on classpath to use with api-doc: \" + apiDoc);\n            }\n        }\n\n        String cname = getComponentName();\n        if (cname != null) {\n            Object comp = getCamelContext().getRegistry().lookupByName(getComponentName());\n            if (comp != null && comp instanceof RestProducerFactory) {\n                factory = (RestProducerFactory) comp;\n            } else {\n                comp = getCamelContext().getComponent(getComponentName());\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                }\n            }\n\n            if (factory == null) {\n                if (comp != null) {\n                    throw new IllegalArgumentException(\"Component \" + getComponentName() + \" is not a RestProducerFactory\");\n                } else {\n                    throw new NoSuchBeanException(getComponentName(), RestProducerFactory.class.getName());\n                }\n            }\n            cname = getComponentName();\n        }\n\n        // try all components\n        if (factory == null) {\n            for (String name : getCamelContext().getComponentNames()) {\n                Component comp = getCamelContext().getComponent(name);\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                    cname = name;\n                    break;\n                }\n            }\n        }\n\n        parameters.put(\"componentName\", cname);\n\n        // lookup in registry\n        if (factory == null) {\n            Set<RestProducerFactory> factories = getCamelContext().getRegistry().findByType(RestProducerFactory.class);\n            if (factories != null && factories.size() == 1) {\n                factory = factories.iterator().next();\n            }\n        }\n\n        if (factory != null) {\n            LOG.debug(\"Using RestProducerFactory: {}\", factory);\n\n            Producer producer;\n            if (apiDocFactory != null) {\n                // wrap the factory using the api doc factory which will use the factory\n                parameters.put(\"restProducerFactory\", factory);\n                producer = apiDocFactory.createProducer(getCamelContext(), host, method, path, uriTemplate, queryParameters, consumes, produces, parameters);\n            } else {\n                producer = factory.createProducer(getCamelContext(), host, method, path, uriTemplate, queryParameters, consumes, produces, parameters);\n            }\n            return new RestProducer(this, producer);\n        } else {\n            throw new IllegalStateException(\"Cannot find RestProducerFactory in Registry or as a Component to use\");\n        }\n    }","commit_id":"b05fd50222b99d80920938bf99d02d670c6885d6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        String apiDoc = (String) parameters.get(\"apiDoc\");\n        // load json model\n        if (apiDoc == null) {\n            throw new IllegalArgumentException(\"Swagger api-doc must be configured using the apiDoc option\");\n        }\n\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        // path must start with a leading slash\n        if (!path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n\n        Swagger swagger = loadSwaggerModel(camelContext, apiDoc);\n        Operation operation = getSwaggerOperation(swagger, verb, path);\n        if (operation == null) {\n            throw new IllegalArgumentException(\"Swagger api-doc does not contain operation for \" + verb + \":\" + path);\n        }\n\n        String componentName = (String) parameters.get(\"componentName\");\n\n        Producer producer = createHttpProducer(camelContext, swagger, operation, host, verb, path, produces, consumes, componentName, parameters);\n        return producer;\n    }","id":40049,"modified_method":"@Override\n    public Producer createProducer(CamelContext camelContext, String host,\n                                   String verb, String basePath, String uriTemplate, String queryParameters,\n                                   String consumes, String produces, Map<String, Object> parameters) throws Exception {\n\n        String apiDoc = (String) parameters.get(\"apiDoc\");\n        // load json model\n        if (apiDoc == null) {\n            throw new IllegalArgumentException(\"Swagger api-doc must be configured using the apiDoc option\");\n        }\n\n        String path = uriTemplate != null ? uriTemplate : basePath;\n        // path must start with a leading slash\n        if (!path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n\n        Swagger swagger = loadSwaggerModel(camelContext, apiDoc);\n        Operation operation = getSwaggerOperation(swagger, verb, path);\n        if (operation == null) {\n            throw new IllegalArgumentException(\"Swagger api-doc does not contain operation for \" + verb + \":\" + path);\n        }\n\n        // validate if we have the query parameters also\n        if (queryParameters != null) {\n            for (Parameter param : operation.getParameters()) {\n                if (\"query\".equals(param.getIn()) && param.getRequired()) {\n                    // check if we have the required query parameter defined\n                    String key = param.getName();\n                    String token = key + \"=\";\n                    boolean hasQuery = queryParameters.contains(token);\n                    if (!hasQuery) {\n                        throw new IllegalArgumentException(\"Swagger api-doc does not contain query parameter \" + key + \" for \" + verb + \":\" + path);\n                    }\n                }\n            }\n        }\n\n        String componentName = (String) parameters.get(\"componentName\");\n\n        Producer producer = createHttpProducer(camelContext, swagger, operation, host, verb, path, queryParameters,\n                produces, consumes, componentName, parameters);\n        return producer;\n    }","commit_id":"b05fd50222b99d80920938bf99d02d670c6885d6","url":"https://github.com/apache/camel"},{"original_method":"private Producer createHttpProducer(CamelContext camelContext, Swagger swagger, Operation operation,\n                                        String host, String verb, String path, String consumes, String produces,\n                                        String componentName, Map<String, Object> parameters) throws Exception {\n\n        LOG.debug(\"Using Swagger operation: {} with {} {}\", operation, verb, path);\n\n        RestProducerFactory factory = null;\n        String cname = null;\n        if (componentName != null) {\n            Object comp = camelContext.getRegistry().lookupByName(componentName);\n            if (comp != null && comp instanceof RestProducerFactory) {\n                factory = (RestProducerFactory) comp;\n            } else {\n                comp = camelContext.getComponent(componentName);\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                }\n            }\n\n            if (factory == null) {\n                if (comp != null) {\n                    throw new IllegalArgumentException(\"Component \" + componentName + \" is not a RestProducerFactory\");\n                } else {\n                    throw new NoSuchBeanException(componentName, RestProducerFactory.class.getName());\n                }\n            }\n            cname = componentName;\n        }\n\n        // try all components\n        if (factory == null) {\n            for (String name : camelContext.getComponentNames()) {\n                Component comp = camelContext.getComponent(name);\n                if (comp != null && comp instanceof RestProducerFactory) {\n                    factory = (RestProducerFactory) comp;\n                    cname = name;\n                    break;\n                }\n            }\n        }\n\n        // lookup in registry\n        if (factory == null) {\n            Set<RestProducerFactory> factories = camelContext.getRegistry().findByType(RestProducerFactory.class);\n            if (factories != null && factories.size() == 1) {\n                factory = factories.iterator().next();\n            }\n        }\n\n        if (factory != null) {\n            LOG.debug(\"Using RestProducerFactory: {}\", factory);\n\n            if (produces == null) {\n                CollectionStringBuffer csb = new CollectionStringBuffer(\",\");\n                List<String> list = operation.getProduces();\n                if (list == null) {\n                    list = swagger.getProduces();\n                }\n                if (list != null) {\n                    for (String s : list) {\n                        csb.append(s);\n                    }\n                }\n                produces = csb.isEmpty() ? null : csb.toString();\n            }\n            if (consumes == null) {\n                CollectionStringBuffer csb = new CollectionStringBuffer(\",\");\n                List<String> list = operation.getConsumes();\n                if (list == null) {\n                    list = swagger.getConsumes();\n                }\n                if (list != null) {\n                    for (String s : list) {\n                        csb.append(s);\n                    }\n                }\n                consumes = csb.isEmpty() ? null : csb.toString();\n            }\n\n            String basePath;\n            String uriTemplate;\n            if (host == null) {\n                // if no explicit host has been configured then use host and base path from the swagger api-doc\n                host = swagger.getHost();\n                basePath = swagger.getBasePath();\n                uriTemplate = path;\n            } else {\n                // path includes also uri template\n                basePath = path;\n                uriTemplate = null;\n            }\n\n            return factory.createProducer(camelContext, host, verb, basePath, uriTemplate, consumes, produces, parameters);\n\n        } else {\n            throw new IllegalStateException(\"Cannot find RestProducerFactory in Registry or as a Component to use\");\n        }\n    }","id":40050,"modified_method":"private Producer createHttpProducer(CamelContext camelContext, Swagger swagger, Operation operation,\n                                        String host, String verb, String path, String queryParameters,\n                                        String consumes, String produces,\n                                        String componentName, Map<String, Object> parameters) throws Exception {\n\n        LOG.debug(\"Using Swagger operation: {} with {} {}\", operation, verb, path);\n\n        RestProducerFactory factory = (RestProducerFactory) parameters.remove(\"restProducerFactory\");\n\n        if (factory != null) {\n            LOG.debug(\"Using RestProducerFactory: {}\", factory);\n\n            if (produces == null) {\n                CollectionStringBuffer csb = new CollectionStringBuffer(\",\");\n                List<String> list = operation.getProduces();\n                if (list == null) {\n                    list = swagger.getProduces();\n                }\n                if (list != null) {\n                    for (String s : list) {\n                        csb.append(s);\n                    }\n                }\n                produces = csb.isEmpty() ? null : csb.toString();\n            }\n            if (consumes == null) {\n                CollectionStringBuffer csb = new CollectionStringBuffer(\",\");\n                List<String> list = operation.getConsumes();\n                if (list == null) {\n                    list = swagger.getConsumes();\n                }\n                if (list != null) {\n                    for (String s : list) {\n                        csb.append(s);\n                    }\n                }\n                consumes = csb.isEmpty() ? null : csb.toString();\n            }\n\n            String basePath;\n            String uriTemplate;\n            if (host == null) {\n                // if no explicit host has been configured then use host and base path from the swagger api-doc\n                host = swagger.getHost();\n                basePath = swagger.getBasePath();\n                uriTemplate = path;\n            } else {\n                // path includes also uri template\n                basePath = path;\n                uriTemplate = null;\n            }\n\n            return factory.createProducer(camelContext, host, verb, basePath, uriTemplate, queryParameters, consumes, produces, parameters);\n\n        } else {\n            throw new IllegalStateException(\"Cannot find RestProducerFactory in Registry or as a Component to use\");\n        }\n    }","commit_id":"b05fd50222b99d80920938bf99d02d670c6885d6","url":"https://github.com/apache/camel"},{"original_method":"private Operation getSwaggerOperation(Swagger swagger, String verb, String path) {\n        Path modelPath = swagger.getPath(path);\n        if (modelPath == null) {\n            return null;\n        }\n\n        // get,put,post,head,delete,patch,options\n        Operation op = null;\n        if (\"get\".equals(verb)) {\n            op = modelPath.getGet();\n        } else if (\"put\".equals(verb)) {\n            op = modelPath.getPut();\n        } else if (\"post\".equals(verb)) {\n            op = modelPath.getPost();\n        } else if (\"head\".equals(verb)) {\n            op = modelPath.getHead();\n        } else if (\"delete\".equals(verb)) {\n            op = modelPath.getDelete();\n        } else if (\"patch\".equals(verb)) {\n            op = modelPath.getPatch();\n        } else if (\"options\".equals(verb)) {\n            op = modelPath.getOptions();\n        }\n        return op;\n    }","id":40051,"modified_method":"private Operation getSwaggerOperation(Swagger swagger, String verb, String path) {\n        // path may include base path so skip that\n        String basePath = swagger.getBasePath();\n        if (basePath != null && path.startsWith(basePath)) {\n            path = path.substring(basePath.length());\n        }\n\n        Path modelPath = swagger.getPath(path);\n        if (modelPath == null) {\n            return null;\n        }\n\n        // get,put,post,head,delete,patch,options\n        Operation op = null;\n        if (\"get\".equals(verb)) {\n            op = modelPath.getGet();\n        } else if (\"put\".equals(verb)) {\n            op = modelPath.getPut();\n        } else if (\"post\".equals(verb)) {\n            op = modelPath.getPost();\n        } else if (\"head\".equals(verb)) {\n            op = modelPath.getHead();\n        } else if (\"delete\".equals(verb)) {\n            op = modelPath.getDelete();\n        } else if (\"patch\".equals(verb)) {\n            op = modelPath.getPatch();\n        } else if (\"options\".equals(verb)) {\n            op = modelPath.getOptions();\n        }\n        return op;\n    }","commit_id":"b05fd50222b99d80920938bf99d02d670c6885d6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String apiDocAsJson() {\n        // see if there is a rest-api endpoint which would be the case if rest api-doc has been explicit enabled\n        Endpoint restApiEndpoint = null;\n        Endpoint restEndpoint = null;\n        for (Map.Entry<String, Endpoint> entry : getContext().getEndpointMap().entrySet()) {\n            String uri = entry.getKey();\n            if (uri.startsWith(\"rest-api:\")) {\n                restApiEndpoint = entry.getValue();\n                break;\n            } else if (restEndpoint == null && uri.startsWith(\"rest:\")) {\n                restEndpoint = entry.getValue();\n            }\n        }\n\n        if (restApiEndpoint == null && restEndpoint != null) {\n            // no rest-api has been explicit enabled, then we need to create it first\n            RestEndpoint rest = (RestEndpoint) restEndpoint;\n            String componentName = rest.getComponentName();\n\n            if (componentName != null) {\n                RestConfiguration config = getContext().getRestConfiguration(componentName, true);\n                String apiComponent = config.getApiComponent() != null ? config.getApiComponent() : RestApiEndpoint.DEFAULT_API_COMPONENT_NAME;\n                String path = config.getApiContextPath() != null ? config.getApiContextPath() : \"api-doc\";\n                restApiEndpoint = getContext().getEndpoint(String.format(\"rest-api:%s/%s?componentName=%s&apiComponentName=%s&contextIdPattern=#name#\", path, getCamelId(), componentName, apiComponent));\n            }\n        }\n\n        try {\n            if (restApiEndpoint != null) {\n                Producer producer = restApiEndpoint.createProducer();\n                ServiceHelper.startService(producer);\n\n                try {\n                    Exchange dummy = restApiEndpoint.createExchange();\n                    producer.process(dummy);\n\n                    String json = dummy.hasOut() ? dummy.getOut().getBody(String.class) : dummy.getIn().getBody(String.class);\n                    return json;\n                } finally {\n                    ServiceHelper.stopService(producer);\n                }\n            }\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        return null;\n    }","id":40052,"modified_method":"@Override\n    public String apiDocAsJson() {\n        // see if there is a rest-api endpoint which would be the case if rest api-doc has been explicit enabled\n        if (apiProducer == null) {\n            Endpoint restApiEndpoint = null;\n            Endpoint restEndpoint = null;\n            for (Map.Entry<String, Endpoint> entry : getContext().getEndpointMap().entrySet()) {\n                String uri = entry.getKey();\n                if (uri.startsWith(\"rest-api:\")) {\n                    restApiEndpoint = entry.getValue();\n                    break;\n                } else if (restEndpoint == null && uri.startsWith(\"rest:\")) {\n                    restEndpoint = entry.getValue();\n                }\n            }\n\n            if (restApiEndpoint == null && restEndpoint != null) {\n                // no rest-api has been explicit enabled, then we need to create it first\n                RestEndpoint rest = (RestEndpoint) restEndpoint;\n                String componentName = rest.getComponentName();\n\n                if (componentName != null) {\n                    RestConfiguration config = getContext().getRestConfiguration(componentName, true);\n                    String apiComponent = config.getApiComponent() != null ? config.getApiComponent() : RestApiEndpoint.DEFAULT_API_COMPONENT_NAME;\n                    String path = config.getApiContextPath() != null ? config.getApiContextPath() : \"api-doc\";\n                    restApiEndpoint = getContext().getEndpoint(String.format(\"rest-api:%s/%s?componentName=%s&apiComponentName=%s&contextIdPattern=#name#\", path, getCamelId(), componentName, apiComponent));\n                }\n            }\n\n            if (restApiEndpoint != null) {\n                // reuse the producer to avoid creating it\n                try {\n                    apiProducer = restApiEndpoint.createProducer();\n                    getContext().addService(apiProducer, true);\n                } catch (Exception e) {\n                    throw ObjectHelper.wrapRuntimeCamelException(e);\n                }\n            }\n        }\n\n        if (apiProducer != null) {\n            try {\n                Exchange dummy = apiProducer.getEndpoint().createExchange();\n                apiProducer.process(dummy);\n\n                String json = dummy.hasOut() ? dummy.getOut().getBody(String.class) : dummy.getIn().getBody(String.class);\n                return json;\n            } catch (Exception e) {\n                throw ObjectHelper.wrapRuntimeCamelException(e);\n            }\n        }\n\n        return null;\n    }","commit_id":"e26541acb06d70563551341ba105b390d4084059","url":"https://github.com/apache/camel"},{"original_method":"public RestApiEndpoint(String endpointUri, RestApiComponent component) {\n        super(endpointUri, component);\n    }","id":40053,"modified_method":"public RestApiEndpoint(String endpointUri, RestApiComponent component) {\n        super(endpointUri, component);\n        setExchangePattern(ExchangePattern.InOut);\n    }","commit_id":"e26541acb06d70563551341ba105b390d4084059","url":"https://github.com/apache/camel"},{"original_method":"public RestEndpoint(String endpointUri, RestComponent component) {\n        super(endpointUri, component);\n    }","id":40054,"modified_method":"public RestEndpoint(String endpointUri, RestComponent component) {\n        super(endpointUri, component);\n        setExchangePattern(ExchangePattern.InOut);\n    }","commit_id":"e26541acb06d70563551341ba105b390d4084059","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createApiProcessor(CamelContext camelContext, String contextPath, String contextIdPattern, boolean contextIdListing,\n                                        RestConfiguration configuration, Map<String, Object> parameters) throws Exception {\n\n        Map<String, Object> options = new HashMap<String, Object>(parameters);\n        options.putAll(configuration.getApiProperties());\n\n        // need to include host in options\n        String host = (String) options.get(\"host\");\n        if (host == null) {\n            host = configuration.getHost();\n            int port = configuration.getPort();\n            if (host != null && port > 0) {\n                options.put(\"host\", host + \":\" + port);\n            } else if (host != null) {\n                options.put(\"host\", host);\n            } else {\n                options.put(\"host\", \"localhost\");\n            }\n        }\n        // and context path is the base.path\n        String path = configuration.getContextPath();\n        options.put(\"base.path\", path);\n\n        return new RestSwaggerProcessor(contextIdPattern, contextIdListing, options);\n    }","id":40055,"modified_method":"@Override\n    public Processor createApiProcessor(CamelContext camelContext, String contextPath, String contextIdPattern, boolean contextIdListing,\n                                        RestConfiguration configuration, Map<String, Object> parameters) throws Exception {\n\n        Map<String, Object> options = new HashMap<String, Object>(parameters);\n        if (configuration.getApiProperties() != null) {\n            options.putAll(configuration.getApiProperties());\n        }\n\n        // need to include host in options\n        String host = (String) options.get(\"host\");\n        if (host == null) {\n            host = configuration.getHost();\n            int port = configuration.getPort();\n            if (host != null && port > 0) {\n                options.put(\"host\", host + \":\" + port);\n            } else if (host != null) {\n                options.put(\"host\", host);\n            } else {\n                options.put(\"host\", \"localhost\");\n            }\n        }\n        // and context path is the base.path\n        String path = configuration.getContextPath();\n        options.put(\"base.path\", path);\n\n        return new RestSwaggerProcessor(contextIdPattern, contextIdListing, options);\n    }","commit_id":"e26541acb06d70563551341ba105b390d4084059","url":"https://github.com/apache/camel"},{"original_method":"@PostConstruct\n    public void postConstruct() {\n        log.info(ReplyingMDB.class.getSimpleName() + \" was created\");\n        try {\n            connection = factory.createQueueConnection();\n            session = connection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);\n            sender = session.createSender(null);\n        } catch (JMSException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":40056,"modified_method":"@PostConstruct\n    public void postConstruct() {\n        log.info(ReplyingMDB.class.getSimpleName() + \" was created\");\n        try {\n            connection = factory.createConnection();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            sender = session.createProducer(null);\n        } catch (JMSException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void onMessage(Message message) {\n        try {\n            TextMessage replyMessage;\n            if (message instanceof TextMessage) {\n                String text = ((TextMessage) message).getText();\n                if (text.equals(\"await\")) {\n                    // we have received the first message\n                    HelperSingletonImpl.barrier.await(WAIT_S, SECONDS);\n                    HelperSingletonImpl.barrier.reset();\n                    // wait for undeploy\n                    HelperSingletonImpl.barrier.await(WAIT_S, SECONDS);\n                    HelperSingletonImpl.barrier.reset();\n                }\n                replyMessage = session.createTextMessage(\"Reply: \" + text);\n            } else {\n                replyMessage = session.createTextMessage(\"Unknown message\");\n            }\n            Destination destination = message.getJMSReplyTo();\n            sender.send(destination, replyMessage, NON_PERSISTENT, 1, SECONDS.toMillis(WAIT_S));\n            log.info(\"onMessage method [OK], msg: \" + message.toString());\n        } catch (JMSException e) {\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } catch (BrokenBarrierException e) {\n            throw new RuntimeException(e);\n        } catch (TimeoutException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":40057,"modified_method":"public void onMessage(Message m) {\n        try {\n            TextMessage message = (TextMessage) m;\n            String text = message.getText();\n\n            TextMessage replyMessage;\n            if (message instanceof TextMessage) {\n                if (text.equals(\"await\") && !message.getJMSRedelivered()) {\n                    // we have received the first message\n                    HelperSingletonImpl.barrier.await(WAIT_S, SECONDS);\n                    HelperSingletonImpl.barrier.reset();\n                    // wait for undeploy, the MDB will be interrupted when it is undeployed\n                    Thread.sleep(SECONDS.toMillis(WAIT_S));\n                }\n                replyMessage = session.createTextMessage(\"Reply: \" + text);\n            } else {\n                replyMessage = session.createTextMessage(\"Unknown message\");\n            }\n            Destination destination = message.getJMSReplyTo();\n            message.setJMSDeliveryMode(NON_PERSISTENT);\n            sender.send(destination, replyMessage);\n            log.info(\"onMessage method [OK], msg: \" + message.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@PreDestroy\n    public void preDestroy() {\n        log.info(\"Destroying MDB \" + ReplyingMDB.class.getSimpleName());\n        try {\n            if (sender != null)\n                sender.close();\n            if (session != null)\n                session.close();\n            if (connection != null)\n                connection.close();\n        } catch (JMSException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":40058,"modified_method":"@PreDestroy\n    public void preDestroy() {\n        log.info(\"Destroying MDB \" + ReplyingMDB.class.getSimpleName());\n        try {\n            if (connection != null)\n                connection.close();\n        } catch (JMSException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void setup(final ManagementClient managementClient, final String containerId) throws Exception {\n            final JMSOperations operations = getInstance(managementClient);\n            operations.createJmsQueue(QUEUE_SEND, \"java:jboss/exported/\" + QUEUE_SEND);\n            operations.createJmsQueue(QUEUE_REPLY, \"java:jboss/exported/\" + QUEUE_REPLY);\n        }","id":40059,"modified_method":"@Override\n        public void setup(final ManagementClient managementClient, final String containerId) throws Exception {\n            final JMSOperations operations = getInstance(managementClient);\n            operations.createJmsQueue(QUEUE_SEND, \"java:jboss/exported/\" + QUEUE_SEND);\n        }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void tearDown(final ManagementClient managementClient, final String containerId) throws Exception {\n            final JMSOperations operations = getInstance(managementClient);\n            operations.removeJmsQueue(QUEUE_SEND);\n            operations.removeJmsQueue(QUEUE_REPLY);\n        }","id":40060,"modified_method":"@Override\n        public void tearDown(final ManagementClient managementClient, final String containerId) throws Exception {\n            final JMSOperations operations = getInstance(managementClient);\n            operations.removeJmsQueue(QUEUE_SEND);\n        }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void sendMessage(Session session, MessageProducer sender, Queue replyQueue, String txt) throws JMSException {\n        TextMessage msg = session.createTextMessage(txt);\n        msg.setJMSDeliveryMode(DeliveryMode.NON_PERSISTENT);\n        msg.setJMSReplyTo(replyQueue);\n        sender.send(msg, NON_PERSISTENT, SEND_TIMEOUT_S, SECONDS.toMillis(WAIT_S));\n    }","id":40061,"modified_method":"private static void sendMessage(Session session, MessageProducer sender, Queue replyQueue, String txt) throws JMSException {\n        TextMessage msg = session.createTextMessage(txt);\n        msg.setJMSReplyTo(replyQueue);\n        msg.setJMSDeliveryMode(DeliveryMode.NON_PERSISTENT);\n        sender.send(msg);\n    }","commit_id":"859421bb1ae68af20b3ce946193918461e4226a7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static boolean call_hasSameParameters_855369272314187138(SNode thisNode, SNode checked) {\n    for (int i = 0; i < ListSequence.fromList(SLinkOperations.getChildren(thisNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).count(); i++) {\n      String searchedParamType = check_tq0gdw_a0a0a0p(check_tq0gdw_a0a0a0a51(ListSequence.fromList(SLinkOperations.getChildren(checked, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(i)));\n      String foundParamType = check_tq0gdw_a0b0a0p(check_tq0gdw_a0a1a0a51(ListSequence.fromList(SLinkOperations.getChildren(thisNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(i)));\n      if (searchedParamType == null || foundParamType == null) {\n        return false;\n      }\n      if (!(foundParamType.equals(searchedParamType))) {\n        return false;\n      }\n    }\n    return true;\n  }","id":40062,"modified_method":"public static boolean call_hasSameParameters_855369272314187138(SNode thisNode, SNode checked) {\n    if (ListSequence.fromList(SLinkOperations.getChildren(thisNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).count() != ListSequence.fromList(SLinkOperations.getChildren(checked, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).count()) {\n      return false;\n    }\n    for (int i = 0; i < ListSequence.fromList(SLinkOperations.getChildren(thisNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).count(); i++) {\n      String searchedParamType = check_tq0gdw_a0a0b0p(check_tq0gdw_a0a0a1a51(ListSequence.fromList(SLinkOperations.getChildren(checked, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(i)));\n      String foundParamType = check_tq0gdw_a0b0b0p(check_tq0gdw_a0a1a1a51(ListSequence.fromList(SLinkOperations.getChildren(thisNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(i)));\n      if (searchedParamType == null || foundParamType == null) {\n        return false;\n      }\n      if (!(foundParamType.equals(searchedParamType))) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String check_tq0gdw_a0b0a0p(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return BehaviorReflection.invokeVirtual(String.class, checkedDotOperand, \"virtual_getErasureSignature_1213877337313\", new Object[]{});\n    }\n    return null;\n  }","id":40063,"modified_method":"private static String check_tq0gdw_a0a0b0p(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return BehaviorReflection.invokeVirtual(String.class, checkedDotOperand, \"virtual_getErasureSignature_1213877337313\", new Object[]{});\n    }\n    return null;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode check_tq0gdw_a0a0a0a51(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"));\n    }\n    return null;\n  }","id":40064,"modified_method":"private static SNode check_tq0gdw_a0a0a1a51(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"));\n    }\n    return null;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode check_tq0gdw_a0a1a0a51(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"));\n    }\n    return null;\n  }","id":40065,"modified_method":"private static SNode check_tq0gdw_a0a1a1a51(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"));\n    }\n    return null;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String check_tq0gdw_a0a0a0p(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return BehaviorReflection.invokeVirtual(String.class, checkedDotOperand, \"virtual_getErasureSignature_1213877337313\", new Object[]{});\n    }\n    return null;\n  }","id":40066,"modified_method":"private static String check_tq0gdw_a0b0b0p(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return BehaviorReflection.invokeVirtual(String.class, checkedDotOperand, \"virtual_getErasureSignature_1213877337313\", new Object[]{});\n    }\n    return null;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getMethodsToOverride_5418393554803767537(SNode thisNode) {\n    List<SNode> methods = new ArrayList<SNode>();\n    for (SNode method : Sequence.fromIterable(IClassifierType_Behavior.call_getMembers_7405920559687277275(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), thisNode, \"virtual_getThisType_7405920559687254782\", new Object[]{}))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      }\n    })) {\n      SNode cls = SNodeOperations.getNodeAncestor(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, \"jetbrains.mps.baseLanguage.structure.Classifier\"), false, false);\n      if (cls == thisNode) {\n        continue;\n      }\n      if (!(SNodeOperations.isInstanceOf(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")))) {\n        continue;\n      }\n      if (SPropertyOperations.getBoolean(method, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x113294bffd2L, \"isFinal\"))) {\n        continue;\n      }\n      if (SPropertyOperations.getBoolean(method, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\"))) {\n        continue;\n      }\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, \"visibility\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10af9586f0cL, \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\"))) {\n        continue;\n      }\n      ListSequence.fromList(methods).addElement(method);\n    }\n    return methods;\n  }","id":40067,"modified_method":"public static List<SNode> virtual_getMethodsToOverride_5418393554803767537(SNode thisNode) {\n    List<SNode> methods = new ArrayList<SNode>();\n    Iterable<SNode> myMethods = Sequence.fromIterable(IClassifierType_Behavior.call_getMembers_7405920559687277275(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), thisNode, \"virtual_getThisType_7405920559687254782\", new Object[]{}))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      }\n    });\n\n    for (SNode method : myMethods) {\n      SNode cls = SNodeOperations.getNodeAncestor(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, \"jetbrains.mps.baseLanguage.structure.Classifier\"), false, false);\n      if (cls == thisNode) {\n        continue;\n      }\n      if (!(SNodeOperations.isInstanceOf(cls, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")))) {\n        continue;\n      }\n      if (SPropertyOperations.getBoolean(method, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x113294bffd2L, \"isFinal\")) || SPropertyOperations.getBoolean(SNodeOperations.cast(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\")) || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, \"visibility\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10af9586f0cL, \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\"))) {\n        continue;\n      }\n      ListSequence.fromList(methods).addElement(method);\n    }\n\n    SNode superclass = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), thisNode, \"virtual_getSuperclass_1240936569950\", new Object[]{});\n    final Iterable<SNode> myConstructors = Sequence.fromIterable(IClassifierType_Behavior.call_getMembers_7405920559687277275(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), thisNode, \"virtual_getThisType_7405920559687254782\", new Object[]{}))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"));\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"));\n      }\n    });\n    Iterable<SNode> superConstructors = Sequence.fromIterable(IClassifierType_Behavior.call_getMembers_7405920559687277275(superclass)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"));\n      }\n    }).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"));\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, \"visibility\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10af9586f0cL, \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\")));\n      }\n    });\n    Iterable<SNode> unimplementedConstructors = Sequence.fromIterable(superConstructors).where(new IWhereFilter<SNode>() {\n      public boolean accept(final SNode candidate) {\n        return !(Sequence.fromIterable(myConstructors).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode m) {\n            return BaseMethodDeclaration_Behavior.call_hasSameParameters_855369272314187138(candidate, m);\n          }\n        }));\n      }\n    });\n\n    ListSequence.fromList(methods).addSequence(Sequence.fromIterable(unimplementedConstructors));\n    return methods;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getMethodsToOverride_5418393554803767537(SNode thisNode) {\n    final List<SNode> methodsToOverride = BehaviorReflection.invokeSuper((Class<List<SNode>>) ((Class) Object.class), thisNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"virtual_getMethodsToOverride_5418393554803767537\", new Object[]{});\n    Iterable<SNode> ownMethods = ListSequence.fromList(BehaviorReflection.invokeVirtual((Class<List<SNode>>) ((Class) Object.class), SNodeOperations.getNode(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Enum\"), \"virtual_getOwnMethods_1906502351318572840\", new Object[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        SNode v = SLinkOperations.getTarget(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, \"visibility\"));\n        return (v != null) && !(SNodeOperations.isInstanceOf(v, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10af9586f0cL, \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\"))) && !(SPropertyOperations.getBoolean(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x113294bffd2L, \"isFinal\")));\n      }\n    });\n    Iterable<SNode> allToBeAdded = Sequence.fromIterable(ownMethods).where(new IWhereFilter<SNode>() {\n      public boolean accept(final SNode own) {\n        return !(ListSequence.fromList(methodsToOverride).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode toBeOverriden) {\n            return BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(own, toBeOverriden);\n          }\n        }));\n      }\n    });\n    return ListSequence.fromList(methodsToOverride).addSequence(Sequence.fromIterable(allToBeAdded));\n  }","id":40068,"modified_method":"public static List<SNode> virtual_getMethodsToOverride_5418393554803767537(SNode thisNode) {\n    final List<SNode> methodsToOverride = BehaviorReflection.invokeSuper((Class<List<SNode>>) ((Class) Object.class), thisNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", \"virtual_getMethodsToOverride_5418393554803767537\", new Object[]{});\n    Iterable<SNode> ownMethods = ListSequence.fromList(BehaviorReflection.invokeVirtual((Class<List<SNode>>) ((Class) Object.class), SNodeOperations.getNode(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Enum\"), \"virtual_getOwnMethods_1906502351318572840\", new Object[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")) || SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"));\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        SNode v = SLinkOperations.getTarget(SNodeOperations.cast(it, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, \"jetbrains.mps.baseLanguage.structure.IVisible\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, \"visibility\"));\n        return (v != null) && !(SNodeOperations.isInstanceOf(v, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10af9586f0cL, \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\"))) && !(SPropertyOperations.getBoolean(SNodeOperations.as(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x113294bffd2L, \"isFinal\")));\n      }\n    });\n    Iterable<SNode> allToBeAdded = Sequence.fromIterable(ownMethods).where(new IWhereFilter<SNode>() {\n      public boolean accept(final SNode own) {\n        return !(ListSequence.fromList(methodsToOverride).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode toBeOverriden) {\n            return BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(own, toBeOverriden);\n          }\n        }));\n      }\n    });\n    return ListSequence.fromList(methodsToOverride).addSequence(Sequence.fromIterable(allToBeAdded));\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SNode getReturnStatement(SNode returnExpr) {\n    if ((returnExpr == null)) {\n      return null;\n    }\n\n    if (myNeedReturnKW) {\n      return _quotation_createNode_tfz3o4_a0a2a9(returnExpr);\n    } else {\n      return _quotation_createNode_tfz3o4_a0a0c0j(returnExpr);\n    }\n  }","id":40069,"modified_method":"private SNode getReturnStatement(SNode returnExpr) {\n    if ((returnExpr == null)) {\n      return null;\n    }\n\n    if (myNeedReturnKW) {\n      return _quotation_createNode_tfz3o4_a0a2a01(returnExpr);\n    } else {\n      return _quotation_createNode_tfz3o4_a0a0c0k(returnExpr);\n    }\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_tfz3o4_a0a0a7a8(Object parameter_1, Object parameter_2) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf9d78b55aaL, \"jetbrains.mps.baseLanguage.structure.SuperMethodCall\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_3, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), (SNode) parameter_1);\n    {\n      List<SNode> nodes = (List<SNode>) parameter_2;\n      for (SNode child : nodes) {\n        quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, \"actualArgument\"), HUtil.copyIfNecessary(child));\n      }\n    }\n    return quotedNode_3;\n  }","id":40070,"modified_method":"private static SNode _quotation_createNode_tfz3o4_a0a0a1a6a8(Object parameter_1, Object parameter_2) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf9d78b55aaL, \"jetbrains.mps.baseLanguage.structure.SuperMethodCall\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_3, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), (SNode) parameter_1);\n    {\n      List<SNode> nodes = (List<SNode>) parameter_2;\n      for (SNode child : nodes) {\n        quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, \"actualArgument\"), HUtil.copyIfNecessary(child));\n      }\n    }\n    return quotedNode_3;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"void update(SNode method, SNode baseMethod) {\n    if (SModelStereotype.isStubModelStereotype(jetbrains.mps.util.SNodeOperations.getModelStereotype(SNodeOperations.getModel(baseMethod)))) {\n      setVariableNames(method, MapSequence.fromMap(new HashMap<String, Integer>()));\n    }\n    if (myRemoveAttributes) {\n      for (SNode child : SNodeOperations.getChildren(method)) {\n        removeAttributes(child);\n      }\n    }\n    boolean isInterfaceMethod = SNodeOperations.isInstanceOf(SNodeOperations.getParent(baseMethod), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, \"jetbrains.mps.baseLanguage.structure.Interface\")) || SPropertyOperations.getBoolean(baseMethod, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\"));\n    if (myInsertOverride && !(isInterfaceMethod)) {\n      boolean isNeedAddAnnotation = true;\n      for (SNode annotation : SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6be947aL, 0x114a6beb0bdL, \"annotation\"))) {\n        if (SLinkOperations.getTarget(annotation, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6b4ccabL, 0x114a6b85d40L, \"annotation\")) == SNodeOperations.getNode(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Override\")) {\n          isNeedAddAnnotation = false;\n          break;\n        }\n      }\n      if (isNeedAddAnnotation) {\n        ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6be947aL, 0x114a6beb0bdL, \"annotation\"))).addElement(_quotation_createNode_tfz3o4_a0a0a2a3a8());\n      }\n    }\n\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return _quotation_createNode_tfz3o4_a0a0a0a5a8(it);\n      }\n    });\n    SNode defaultExpr;\n    if (isInterfaceMethod) {\n      defaultExpr = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SLinkOperations.getTarget(baseMethod, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), \"virtual_createDefaultTypeExpression_3359611512358152580\", new Object[]{});\n    } else {\n      defaultExpr = _quotation_createNode_tfz3o4_a0a0a7a8(baseMethod, Sequence.fromIterable(paramList).toListSequence());\n    }\n\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc6bf96dL, \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n      if (!(isInterfaceMethod)) {\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_tfz3o4_a0a0a0a9a8(defaultExpr));\n      }\n    } else {\n      ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(getReturnStatement(defaultExpr));\n    }\n  }","id":40071,"modified_method":"void update(SNode method, SNode baseMethod) {\n    if (SModelStereotype.isStubModelStereotype(jetbrains.mps.util.SNodeOperations.getModelStereotype(SNodeOperations.getModel(baseMethod)))) {\n      setVariableNames(method, MapSequence.fromMap(new HashMap<String, Integer>()));\n    }\n    if (myRemoveAttributes) {\n      for (SNode child : SNodeOperations.getChildren(method)) {\n        removeAttributes(child);\n      }\n    }\n    boolean isInterfaceMethod = SNodeOperations.isInstanceOf(SNodeOperations.getParent(baseMethod), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, \"jetbrains.mps.baseLanguage.structure.Interface\")) || SPropertyOperations.getBoolean(SNodeOperations.as(baseMethod, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\"));\n    if (myInsertOverride && !(isInterfaceMethod) && SNodeOperations.isInstanceOf(baseMethod, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"))) {\n      boolean isNeedAddAnnotation = true;\n      for (SNode annotation : SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6be947aL, 0x114a6beb0bdL, \"annotation\"))) {\n        if (SLinkOperations.getTarget(annotation, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6b4ccabL, 0x114a6b85d40L, \"annotation\")) == SNodeOperations.getNode(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Override\")) {\n          isNeedAddAnnotation = false;\n          break;\n        }\n      }\n      if (isNeedAddAnnotation) {\n        ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x114a6be947aL, 0x114a6beb0bdL, \"annotation\"))).addElement(_quotation_createNode_tfz3o4_a0a0a2a3a8());\n      }\n    }\n\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return _quotation_createNode_tfz3o4_a0a0a0a5a8(it);\n      }\n    });\n    if (SNodeOperations.isInstanceOf(baseMethod, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"))) {\n      SNode defaultExpr;\n      if (isInterfaceMethod) {\n        defaultExpr = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SLinkOperations.getTarget(baseMethod, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), \"virtual_createDefaultTypeExpression_3359611512358152580\", new Object[]{});\n      } else {\n        defaultExpr = _quotation_createNode_tfz3o4_a0a0a1a6a8(baseMethod, Sequence.fromIterable(paramList).toListSequence());\n      }\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc6bf96dL, \"jetbrains.mps.baseLanguage.structure.VoidType\"))) {\n        if (!(isInterfaceMethod)) {\n          ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_tfz3o4_a0a0a0a2a6a8(defaultExpr));\n        }\n      } else {\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(getReturnStatement(defaultExpr));\n      }\n    } else {\n      if (SNodeOperations.isInstanceOf(baseMethod, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\"))) {\n        SNode superConstructor = _quotation_createNode_tfz3o4_a0a0a0a6a8(Sequence.fromIterable(paramList).toListSequence());\n        SLinkOperations.setTarget(superConstructor, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), baseMethod);\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(superConstructor);\n      }\n    }\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_tfz3o4_a0a0c0j(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","id":40072,"modified_method":"private static SNode _quotation_createNode_tfz3o4_a0a0c0k(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_tfz3o4_a0a2a9(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7feL, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7feL, 0xf8cc6bf96cL, \"expression\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","id":40073,"modified_method":"private static SNode _quotation_createNode_tfz3o4_a0a2a01(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7feL, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7feL, 0xf8cc6bf96cL, \"expression\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> insertMethods(List<SNode> baseMethods) {\n    int index = (myContextMember != null && SNodeOperations.getParent(myContextMember) == myClassConcept ? ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).indexOf(myContextMember) + 1 : -1);\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode m : baseMethods) {\n      SNode baseMethod = SNodeOperations.cast(m, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      SNode method = SNodeOperations.cast(BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), baseMethod, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\", \"call_getMethodToImplement_69709522611978987\", new Object[]{myClassConcept}), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"));\n      SPropertyOperations.set(method, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\"), \"\" + (false));\n      SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\"), SNodeFactoryOperations.createNewNode(SNodeOperations.getModel(myClassConcept), SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\")), null));\n      if (index != -1) {\n        ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).insertElement(index++, method);\n      } else {\n        ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).addElement(method);\n      }\n      update(method, baseMethod);\n      ListSequence.fromList(result).addElement(method);\n    }\n    return result;\n  }","id":40074,"modified_method":"public List<SNode> insertMethods(List<SNode> baseMethods) {\n    int index = (myContextMember != null && SNodeOperations.getParent(myContextMember) == myClassConcept ? ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).indexOf(myContextMember) + 1 : -1);\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode baseMethod : baseMethods) {\n      SNode method = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), baseMethod, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\", \"call_getMethodToImplement_69709522611978987\", new Object[]{myClassConcept});\n      SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, \"body\"), SNodeFactoryOperations.createNewNode(SNodeOperations.getModel(myClassConcept), SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\")), null));\n      if (SNodeOperations.isInstanceOf(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\"))) {\n        SPropertyOperations.set(SNodeOperations.cast(method, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\")), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b21dL, 0x1126a8d157dL, \"isAbstract\"), \"\" + (false));\n      }\n      if (index != -1) {\n        ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).insertElement(index++, SNodeOperations.cast(method, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\")));\n      } else {\n        ListSequence.fromList(SLinkOperations.getChildren(myClassConcept, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, \"member\"))).addElement(SNodeOperations.cast(method, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\")));\n      }\n      update(method, baseMethod);\n      ListSequence.fromList(result).addElement(method);\n    }\n    return result;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_tfz3o4_a0a0a0a9a8(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_3 = (SNode) parameter_1;\n    if (quotedNode_3 != null) {\n      quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), HUtil.copyIfNecessary(quotedNode_3));\n    }\n    return quotedNode_2;\n  }","id":40075,"modified_method":"private static SNode _quotation_createNode_tfz3o4_a0a0a0a6a8(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93d512e1eL, \"jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation\"), null, null, false);\n    quotedNode_2.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), quotedNode_2, facade.createModelReference(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065/f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\"), facade.createNodeId(\"~Object.<init>()\")));\n    {\n      List<SNode> nodes = (List<SNode>) parameter_1;\n      for (SNode child : nodes) {\n        quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, \"actualArgument\"), HUtil.copyIfNecessary(child));\n      }\n    }\n    return quotedNode_2;\n  }","commit_id":"ffd17d05321b75fa0594d37f2176208555f6cbd3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode method, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    // name \n    if (neq_p6nv7a_a0b0b(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")), SPropertyOperations.getString(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")))) {\n      SPropertyOperations.set(method, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")));\n    }\n\n    // ret type \n    SNode retType = MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")));\n    if (SNodeOperations.isInstanceOf(retType, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"))) {\n      if (!((SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")) || SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")), MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, 0x340eb2bd2e03d16cL, \"decl\")) != retType))) {\n        SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\"), DependentTypeDeclaration_Behavior.call_create_2613537504709871067(SNodeOperations.cast(retType, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")), method));\n      }\n    } else {\n      if (!((MatchingUtil.matchNodes(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), retType)))) {\n        SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\"), SNodeOperations.copyNode(retType));\n      }\n    }\n\n    // parameters \n    for (int i = 0, cur = 0; i < ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d167L, 0x340eb2bd2e03d168L, \"param\"))).count(); i++) {\n      SNode formalPar = ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d167L, 0x340eb2bd2e03d168L, \"param\"))).getElement(i);\n      SNode actualPar = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(cur), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, \"jetbrains.mps.lang.classLike.structure.ClassLikeMethodParameter\"));\n\n      // conditional? need to check presence conforms with condition \n      if (SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x1c6f8dad3c495fe9L, \"condition\")) != null) {\n        // needed, but not present \n        if (ParameterDescriptor_Behavior.call_isNeeded_8880393040217583693(formalPar, method) && SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) != formalPar) {\n          ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).insertElement(cur, ParameterDescriptor_Behavior.call_create_2613537504709874302(formalPar, method));\n          cur++;\n          continue;\n        }\n        // not needed, but present \n        if (!(ParameterDescriptor_Behavior.call_isNeeded_8880393040217583693(formalPar, method)) && SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) == formalPar) {\n          SNodeOperations.deleteNode(actualPar);\n          continue;\n        }\n        // otherwise, check as a regular parameter \n      }\n\n      if (SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) != formalPar) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(method, \"Wrong method signature. Can't repair automatically. Error in parameter with index \" + cur, \"c7d5b9dd-a05f-4be2-bc73-f2e16994cc67/r:e04b7053-8c89-4f87-b296-94779c625d9d(jetbrains.mps.lang.classLike/jetbrains.mps.lang.classLike.typesystem)\", \"2613537504710096180\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.lang.classLike.typesystem.fix_SignatureMismatch_QuickFix\", false);\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n        return;\n      }\n\n      if (SPropertyOperations.getString(actualPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) != SPropertyOperations.getString(formalPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"))) {\n        SPropertyOperations.set(actualPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString(formalPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")));\n      }\n\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"))) {\n        if (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")))) {\n          SLinkOperations.setTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), DependentTypeDeclaration_Behavior.call_create_2613537504709871067(SNodeOperations.cast(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")), method));\n        }\n      } else {\n        if (!((MatchingUtil.matchNodes(SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\")), SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")))))) {\n          SLinkOperations.setTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), SNodeOperations.copyNode(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\"))));\n        }\n      }\n      cur++;\n    }\n  }","id":40076,"modified_method":"public void applyRule(final SNode method, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    // name \n    if (neq_p6nv7a_a0b0b(SPropertyOperations.getString(method, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")), SPropertyOperations.getString(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")))) {\n      SPropertyOperations.set(method, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")));\n    }\n\n    // ret type \n    SNode retType = MethodDescriptor_Behavior.call_getReturnType_3855110916779541832(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")));\n    if (SNodeOperations.isInstanceOf(retType, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"))) {\n      if (!((SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")) || SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")), MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, 0x340eb2bd2e03d16cL, \"decl\")) != retType))) {\n        SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\"), DependentTypeDeclaration_Behavior.call_create_2613537504709871067(SNodeOperations.cast(retType, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")), method));\n      }\n    } else {\n      if (!((MatchingUtil.matchNodes(SLinkOperations.getTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\")), retType)))) {\n        SLinkOperations.setTarget(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, \"returnType\"), SNodeOperations.copyNode(retType));\n      }\n    }\n\n    // parameters \n    for (int i = 0, cur = 0; i < ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d167L, 0x340eb2bd2e03d168L, \"param\"))).count(); i++) {\n      SNode formalPar = ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(method, MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d154L, 0x443e89bb321537L, \"decl\")), MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d167L, 0x340eb2bd2e03d168L, \"param\"))).getElement(i);\n      SNode actualPar = ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(cur);\n\n      // todo this condition should be removed after migration to our params \n      if (SNodeOperations.isInstanceOf(ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).getElement(cur), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, \"jetbrains.mps.lang.classLike.structure.ClassLikeMethodParameter\"))) {\n        // conditional? need to check presence conforms with condition \n        if (SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x1c6f8dad3c495fe9L, \"condition\")) != null) {\n          // needed, but not present \n          if (ParameterDescriptor_Behavior.call_isNeeded_8880393040217583693(formalPar, method) && SLinkOperations.getTarget(SNodeOperations.cast(actualPar, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, \"jetbrains.mps.lang.classLike.structure.ClassLikeMethodParameter\")), MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) != formalPar) {\n            ListSequence.fromList(SLinkOperations.getChildren(method, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, \"parameter\"))).insertElement(cur, ParameterDescriptor_Behavior.call_create_2613537504709874302(formalPar, method));\n            cur++;\n            continue;\n          }\n          // not needed, but present \n          if (!(ParameterDescriptor_Behavior.call_isNeeded_8880393040217583693(formalPar, method)) && SLinkOperations.getTarget(SNodeOperations.cast(actualPar, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, \"jetbrains.mps.lang.classLike.structure.ClassLikeMethodParameter\")), MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) == formalPar) {\n            SNodeOperations.deleteNode(actualPar);\n            continue;\n          }\n          // otherwise, check as a regular parameter \n        }\n\n        if (SLinkOperations.getTarget(SNodeOperations.cast(actualPar, MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, \"jetbrains.mps.lang.classLike.structure.ClassLikeMethodParameter\")), MetaAdapterFactory.getReferenceLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x7b3d7e6b74000c44L, 0x7b3d7e6b7400c831L, \"decl\")) != formalPar) {\n          {\n            MessageTarget errorTarget = new NodeMessageTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(method, \"Wrong method signature. Can't repair automatically. Error in parameter with index \" + cur, \"c7d5b9dd-a05f-4be2-bc73-f2e16994cc67/r:e04b7053-8c89-4f87-b296-94779c625d9d(jetbrains.mps.lang.classLike/jetbrains.mps.lang.classLike.typesystem)\", \"2613537504710096180\", null, errorTarget);\n            {\n              BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.lang.classLike.typesystem.fix_SignatureMismatch_QuickFix\", false);\n              _reporter_2309309498.addIntentionProvider(intentionProvider);\n            }\n          }\n          return;\n        }\n      }\n\n      if (SPropertyOperations.getString(actualPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) != SPropertyOperations.getString(formalPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"))) {\n        SPropertyOperations.set(actualPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString(formalPar, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")));\n      }\n\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\"))) {\n        if (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d16bL, \"jetbrains.mps.lang.classLike.structure.DependentTypeInstance\")))) {\n          SLinkOperations.setTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), DependentTypeDeclaration_Behavior.call_create_2613537504709871067(SNodeOperations.cast(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")), MetaAdapterFactory.getConcept(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d15cL, \"jetbrains.mps.lang.classLike.structure.DependentTypeDeclaration\")), method));\n        }\n      } else {\n        if (!((MatchingUtil.matchNodes(SLinkOperations.getTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\")), SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\")))))) {\n          SLinkOperations.setTarget(actualPar, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), SNodeOperations.copyNode(SLinkOperations.getTarget(formalPar, MetaAdapterFactory.getContainmentLink(0xc7d5b9dda05f4be2L, 0xbc73f2e16994cc67L, 0x340eb2bd2e03d164L, 0x340eb2bd2e03d166L, \"type\"))));\n        }\n      }\n      cur++;\n    }\n  }","commit_id":"3e97c66ff9c7d12f422ddb3c72b1ed770d48682d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void virtual_collectUncaughtMethodThrowables_5412515780383134223(SNode thisNode, Set<SNode> throwables, boolean ignoreMayBeThrowables) {\n    if (!(ignoreMayBeThrowables)) {\n      Statement_Behavior.collectUncaughtMethodThrowables_5412515780383112967(throwables, SLinkOperations.getTarget(thisNode, \"throwable\", true));\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(thisNode, \"throwable\", true), \"jetbrains.mps.baseLanguage.structure.GenericNewExpression\")) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(thisNode, \"throwable\", true), \"jetbrains.mps.baseLanguage.structure.GenericNewExpression\"), \"creator\", true), \"jetbrains.mps.baseLanguage.structure.ClassCreator\")) {\n        SNode throwableType = SNodeOperations.getAncestor(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(thisNode, \"throwable\", true), \"jetbrains.mps.baseLanguage.structure.GenericNewExpression\"), \"creator\", true), \"jetbrains.mps.baseLanguage.structure.ClassCreator\"), \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n        SetSequence.fromSet(throwables).addElement(throwableType);\n      }\n    }\n  }","id":40077,"modified_method":"public static void virtual_collectUncaughtMethodThrowables_5412515780383134223(SNode thisNode, Set<SNode> throwables, boolean ignoreMayBeThrowables) {\n    if (!(ignoreMayBeThrowables)) {\n      Statement_Behavior.collectUncaughtMethodThrowables_5412515780383112967(throwables, SLinkOperations.getTarget(thisNode, \"throwable\", true));\n    }\n    if (SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(thisNode, \"throwable\", true)), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n      SetSequence.fromSet(throwables).addElement(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(thisNode, \"throwable\", true)), \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n    }\n  }","commit_id":"aa72b37a82745e14bbee37c8f758e8ad527986b1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@CheckForNull\n  public Characteristic findRequirementByRule(Rule rule) {\n    return null;\n  }","id":40078,"modified_method":"/**\n   * @deprecated since 4.3. Always return null\n   */\n  @Deprecated\n  @CheckForNull\n  public Characteristic findRequirementByRule(Rule rule) {\n    return null;\n  }","commit_id":"056360c6010312df0c2a1a9ad1c022153f899643","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addCharacteristics(IssueQueryResult result, DefaultIssue issue, JsonWriter json) {\n    Characteristic requirement = technicalDebtManager.findRequirementByRule(result.rule(issue));\n    // Requirement can be null if it has been disabled\n    if (requirement != null) {\n      Characteristic characteristic = findCharacteristicById(requirement.rootId());\n      json.prop(\"characteristic\", characteristic != null ? characteristic.name() : null);\n      Characteristic subCharacteristic = findCharacteristicById(requirement.parentId());\n      json.prop(\"subCharacteristic\", subCharacteristic != null ? subCharacteristic.name() : null);\n    }\n  }","id":40079,"modified_method":"private void addCharacteristics(IssueQueryResult result, DefaultIssue issue, JsonWriter json) {\n    Integer subCharacteristicId = result.rule(issue).getCharacteristicId() != null ? result.rule(issue).getCharacteristicId() : result.rule(issue).getDefaultCharacteristicId();\n    Characteristic subCharacteristic = findCharacteristicById(subCharacteristicId);\n    if (subCharacteristic != null) {\n      json.prop(\"subCharacteristic\", subCharacteristic.name());\n      Characteristic characteristic = findCharacteristicById(subCharacteristic.parentId());\n      json.prop(\"characteristic\", characteristic != null ? characteristic.name() : null);\n    }\n  }","commit_id":"056360c6010312df0c2a1a9ad1c022153f899643","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void show_issue_with_characteristics() throws Exception {\n    Issue issue = createStandardIssue().setDebt(Duration.create(7260L));\n    issues.add(issue);\n\n    Characteristic requirement = new DefaultCharacteristic().setId(5).setParentId(2).setRootId(1);\n    Characteristic characteristic = new DefaultCharacteristic().setId(1).setName(\"Maintainability\");\n    Characteristic subCharacteristic = new DefaultCharacteristic().setId(2).setName(\"Readability\");\n    when(technicalDebtManager.findRequirementByRule(result.rule(issue))).thenReturn(requirement);\n    when(technicalDebtManager.findCharacteristicById(1)).thenReturn(characteristic);\n    when(technicalDebtManager.findCharacteristicById(2)).thenReturn(subCharacteristic);\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issue.key());\n    request.execute().assertJson(getClass(), \"show_issue_with_characteristics.json\");\n  }","id":40080,"modified_method":"@Test\n  public void show_issue_with_user_characteristics() throws Exception {\n    Issue issue = createStandardIssue().setDebt(Duration.create(7260L));\n    issues.add(issue);\n\n    result.rule(issue).setCharacteristicId(2);\n    when(technicalDebtManager.findCharacteristicById(1)).thenReturn(new DefaultCharacteristic().setId(1).setName(\"Maintainability\"));\n    when(technicalDebtManager.findCharacteristicById(2)).thenReturn(new DefaultCharacteristic().setId(2).setName(\"Readability\").setParentId(1));\n\n    MockUserSession.set();\n    WsTester.TestRequest request = tester.newRequest(\"show\").setParam(\"key\", issue.key());\n    request.execute().assertJson(getClass(), \"show_issue_with_characteristics.json\");\n  }","commit_id":"056360c6010312df0c2a1a9ad1c022153f899643","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public <F, T> Adapter rule(TypeReference<F> fromRef, TypeReference<T> toRef, Function<F, T> toFun, Function<T, F> fromFun) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":40081,"modified_method":"@Override\n    public <F, T> Adapter rule(TypeReference<F> fromRef, TypeReference<T> toRef,\n            FunctionThrowsException<F, T> toFun, FunctionThrowsException<T, F> fromFun) {\n        // TODO Auto-generated method stub\n        return null;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public <F, T> Adapter rule(Type fromType, Type toType, Function<F, T> toFun, Function<T, F> fromFun) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":40082,"modified_method":"@Override\n    public <F, T> Adapter rule(Type fromType, Type toType,\n            FunctionThrowsException<F, T> toFun, FunctionThrowsException<T, F> fromFun) {\n        // TODO Auto-generated method stub\n        return null;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"@Override\n        public Object to(Type type) {\n            if (object != null) {\n                Function<Object, Object> f = classRules.get(\n                    new TypePair(object.getClass(), Util.primitiveToBoxed(type)));\n                if (f != null) {\n                    try {\n                        return f.apply(object);\n                    } catch (Exception ex) {\n                        if (hasDefault)\n                            return defaultValue;\n                        else\n                            throw new ConversionException(\"Cannot convert \" + object + \" to \" + type, ex);\n                    }\n                }\n            }\n\n            return del.to(type);\n        }","id":40083,"modified_method":"@Override\n        public Object to(Type type) {\n            if (object != null) {\n                FunctionThrowsException<Object, Object> f = classRules.get(\n                    new TypePair(object.getClass(), Util.primitiveToBoxed(type)));\n                if (f != null) {\n                    try {\n                        return f.apply(object);\n                    } catch (Exception ex) {\n                        if (hasDefault)\n                            return defaultValue;\n                        else\n                            throw new ConversionException(\"Cannot convert \" + object + \" to \" + type, ex);\n                    }\n                }\n            }\n\n            return del.to(type);\n        }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public <F, T> Adapter rule(Class<F> fromCls, Class<T> toCls,\n            Function<F, T> toFun, Function<T, F> fromFun) {\n        if (fromCls.equals(toCls))\n            throw new IllegalArgumentException();\n\n        classRules.put(new TypePair(fromCls, toCls), (Function<Object, Object>) toFun);\n        classRules.put(new TypePair(toCls, fromCls), (Function<Object, Object>) fromFun);\n        return this;\n    }","id":40084,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public <F, T> Adapter rule(Class<F> fromCls, Class<T> toCls,\n            FunctionThrowsException<F, T> toFun, FunctionThrowsException<T, F> fromFun) {\n        if (fromCls.equals(toCls))\n            throw new IllegalArgumentException();\n\n        classRules.put(new TypePair(fromCls, toCls), (FunctionThrowsException<Object, Object>) toFun);\n        classRules.put(new TypePair(toCls, fromCls), (FunctionThrowsException<Object, Object>) fromFun);\n        return this;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"public ConverterService() {\n        Adapter a = new ConverterImpl().getAdapter();\n        a.rule(UUID.class, String.class, UUID::toString, UUID::fromString);\n        a.rule(Pattern.class, String.class, Pattern::toString, Pattern::compile);\n        a.rule(LocalDateTime.class, String.class, LocalDateTime::toString, LocalDateTime::parse);\n        a.rule(LocalDate.class, String.class, LocalDate::toString, LocalDate::parse);\n        a.rule(LocalTime.class, String.class, LocalTime::toString, LocalTime::parse);\n        a.rule(OffsetDateTime.class, String.class, OffsetDateTime::toString, OffsetDateTime::parse);\n        a.rule(OffsetTime.class, String.class, OffsetTime::toString, OffsetTime::parse);\n        a.rule(ZonedDateTime.class, String.class, ZonedDateTime::toString, ZonedDateTime::parse);\n        a.rule(Integer.class, String.class, v -> v.toString(), Integer::parseInt);\n        adapter = a;\n    }","id":40085,"modified_method":"public ConverterService() {\n        Adapter a = new ConverterImpl().getAdapter();\n        a.rule(Character.class, Boolean.class, v -> v.charValue() != 0,\n                v -> v.booleanValue() ? (char) 1 : (char) 0);\n        a.rule(Character.class, String.class, v -> v.toString(),\n                v -> v.length() > 0 ? v.charAt(0) : 0);\n        a.rule(Class.class, String.class, Class::toString,\n                v -> getClass().getClassLoader().loadClass(v));\n        a.rule(Integer.class, String.class, v -> v.toString(), Integer::parseInt);\n        a.rule(LocalDateTime.class, String.class, LocalDateTime::toString, LocalDateTime::parse);\n        a.rule(LocalDate.class, String.class, LocalDate::toString, LocalDate::parse);\n        a.rule(LocalTime.class, String.class, LocalTime::toString, LocalTime::parse);\n        a.rule(OffsetDateTime.class, String.class, OffsetDateTime::toString, OffsetDateTime::parse);\n        a.rule(OffsetTime.class, String.class, OffsetTime::toString, OffsetTime::parse);\n        a.rule(Pattern.class, String.class, Pattern::toString, Pattern::compile);\n        a.rule(UUID.class, String.class, UUID::toString, UUID::fromString);\n        a.rule(ZonedDateTime.class, String.class, ZonedDateTime::toString, ZonedDateTime::parse);\n        adapter = a;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"private Object handleNull(Class<?> cls) {\n        Class<?> boxed = Util.primitiveToBoxed(cls);\n        if (boxed.equals(cls)) {\n            // This is not a primitive, just return null\n            return null;\n        }\n        if (cls.equals(boolean.class)) {\n            return false;\n        } else {\n            return 0;\n        }\n    }","id":40086,"modified_method":"private Object handleNull(Class<?> cls) {\n        if (hasDefault)\n            return converter.convert(defaultValue).to(cls);\n\n        Class<?> boxed = Util.primitiveToBoxed(cls);\n        if (boxed.equals(cls)) {\n            // This is not a primitive, just return null\n            return null;\n        }\n        if (cls.equals(boolean.class)) {\n            return false;\n        } else {\n            return 0;\n        }\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"private Object trySpecialCases(Class<?> targetCls) {\n        // TODO some of these can probably be implemented as an adapter\n\n        if (Boolean.class.equals(targetCls)) {\n            if (object instanceof Character) {\n                return ((Character) object).charValue() != (char) 0;\n            } else if (object instanceof Number) {\n                return ((Number) object).longValue() != 0;\n            } else if (object instanceof Collection && ((Collection<?>) object).size() == 0) {\n                return Boolean.FALSE;\n            }\n        } else if (Character.class.equals(targetCls)) {\n            if (object instanceof Boolean) {\n                return ((Boolean) object).booleanValue() ? Character.valueOf((char) 1) : Character.valueOf((char) 0);\n            } else if (object instanceof Number) {\n                return Character.valueOf((char) ((Number) object).intValue());\n            } else {\n                String v = converter.convert(object).toString();\n                if (v == null)\n                    return 0;\n                else\n                    return v.length() > 0 ? v.charAt(0) : 0;\n            }\n        } else if (Integer.class.equals(targetCls)) {\n            if (object instanceof Boolean) {\n                return ((Boolean) object).booleanValue() ? Integer.valueOf(1) : Integer.valueOf(0);\n            }\n        } else if (Class.class.equals(targetCls)) {\n            if (object instanceof Collection && ((Collection<?>) object).size() == 0) {\n                return null;\n            } else {\n                try {\n                    return getClass().getClassLoader().loadClass(converter.convert(object).toString());\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        } else if (Enum.class.isAssignableFrom(targetCls)) {\n            if (object instanceof Boolean) {\n                try {\n                    Method m = targetCls.getMethod(\"valueOf\", String.class);\n                    return m.invoke(null, object.toString().toUpperCase());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (object instanceof Number) {\n                try {\n                    Method m = targetCls.getMethod(\"values\");\n                    Object[] values = (Object[]) m.invoke(null);\n                    return values[((Number) object).intValue()];\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n        }\n        return null;\n    }","id":40087,"modified_method":"private Object trySpecialCases(Class<?> targetCls) {\n        // TODO some of these can probably be implemented as an adapter\n\n        if (Boolean.class.equals(targetCls)) {\n            if (object instanceof Number) {\n                return ((Number) object).longValue() != 0;\n            } else if (object instanceof Collection && ((Collection<?>) object).size() == 0) {\n                // TODO What about arrays?\n                return Boolean.FALSE;\n            }\n        } else if (Character.class.equals(targetCls)) {\n            if (object instanceof Number) {\n                return Character.valueOf((char) ((Number) object).intValue());\n            }\n        } else if (Number.class.isAssignableFrom(targetCls)) {\n            if (object instanceof Boolean) {\n                return ((Boolean) object).booleanValue() ? 1 : 0;\n            }\n        } else if (Class.class.equals(targetCls)) {\n            if (object instanceof Collection && ((Collection<?>) object).size() == 0) {\n                return null;\n            }\n        } else if (Enum.class.isAssignableFrom(targetCls)) {\n            if (object instanceof Boolean) {\n                try {\n                    Method m = targetCls.getMethod(\"valueOf\", String.class);\n                    return m.invoke(null, object.toString().toUpperCase());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (object instanceof Number) {\n                try {\n                    Method m = targetCls.getMethod(\"values\");\n                    Object[] values = (Object[]) m.invoke(null);\n                    return values[((Number) object).intValue()];\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n        }\n        return null;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public Converting defaultValue(Object defVal) {\n        if (object == null)\n            object = defVal; // TODO do we need this???\n        else\n            defaultValue = defVal;\n\n        hasDefault = true;\n\n        return this;\n    }","id":40088,"modified_method":"@Override\n    public Converting defaultValue(Object defVal) {\n        defaultValue = defVal;\n        hasDefault = true;\n\n        return this;\n    }","commit_id":"179daf0a1962e8b8d897e851aca64ecb036f64e2","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public <F, T> Adapter rule(Rule<F, T> rule) {\n        ConvertFunction<F, T> toFun = rule.getToFunction();\n        if (toFun != null)\n            classRules.put(new TypePair(rule.getFromClass(), rule.getToClass()),\n                (ConvertFunction<Object, Object>) toFun);\n\n\n        ConvertFunction<T, F> fromFun = rule.getFromFunction();\n        if (fromFun != null)\n            classRules.put(new TypePair(rule.getToClass(), rule.getFromClass()),\n                (ConvertFunction<Object, Object>) fromFun);\n        return this;\n    }","id":40089,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private <F, T> AdapterImpl rule(Rule<F, T> rule) {\n        ConvertFunction<F, T> toFun = rule.getToFunction();\n        if (toFun != null)\n            classRules.put(new TypePair(rule.getFromClass(), rule.getToClass()),\n                (ConvertFunction<Object, Object>) toFun);\n\n\n        ConvertFunction<T, F> fromFun = rule.getFromFunction();\n        if (fromFun != null)\n            classRules.put(new TypePair(rule.getToClass(), rule.getFromClass()),\n                (ConvertFunction<Object, Object>) fromFun);\n        return this;\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"AdapterImpl(InternalConverter converter) {\n        this.delegate = converter;\n    }","id":40090,"modified_method":"AdapterImpl(InternalConverter converter, List<Rule<?,?>> rules) {\n        this.delegate = converter;\n        for (Rule<?,?> r : rules) {\n            rule(r);\n        }\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testCannotHandleSpecific() {\n        Adapter ca = converter.newAdapter();\n\n        ca.rule(new Rule<Integer, Long>(Integer.class, Long.class, new ConvertFunction<Integer,Long>() {\n            @Override\n            public Long convert(Integer obj, Type targetType) throws Exception {\n                if (obj.intValue() != 1)\n                    return new Long(-obj.intValue());\n                return null;\n            }\n        }));\n\n        assertEquals(Long.valueOf(-2), ca.convert(Integer.valueOf(2)).to(Long.class));\n\n        // This is the exception that the rule cannot handle\n        assertEquals(Long.valueOf(1), ca.convert(Integer.valueOf(1)).to(Long.class));\n    }","id":40091,"modified_method":"@Test\n    public void testCannotHandleSpecific() {\n        Converter ca = converter.newConverterBuilder().rule(\n                new Rule<Integer, Long>(Integer.class, Long.class, new ConvertFunction<Integer,Long>() {\n            @Override\n            public Long convert(Integer obj, Type targetType) throws Exception {\n                if (obj.intValue() != 1)\n                    return new Long(-obj.intValue());\n                return null;\n            }\n        })).build();\n\n        assertEquals(Long.valueOf(-2), ca.convert(Integer.valueOf(2)).to(Long.class));\n\n        // This is the exception that the rule cannot handle\n        assertEquals(Long.valueOf(1), ca.convert(Integer.valueOf(1)).to(Long.class));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test @SuppressWarnings(\"rawtypes\")\n    public void testWildcardAdapter() {\n        ConvertFunction<List, Object> foo = new ConvertFunction<List, Object>() {\n            @Override\n            public Object convert(List t, Type type) throws Exception {\n                if (type instanceof Class) {\n                    if (Number.class.isAssignableFrom((Class<?>) type))\n                        return converter.convert(t.size()).to(type);\n                }\n                return null;\n            }\n        };\n\n        Rule<List, Object> r = new Rule<>(List.class, Object.class, foo);\n        Rule<Object, Object> allCatch = new Rule<>(Object.class, Object.class,\n                (v,t) -> v.toString());\n\n        Adapter ca = converter.newAdapter();\n        ca.rule(r);\n        ca.rule(allCatch);\n\n        assertEquals(3L, (long) ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(Long.class));\n        assertEquals(3, (long) ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(Integer.class));\n        assertEquals(\"[a, b, c]\", ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(String.class));\n    }","id":40092,"modified_method":"@Test @SuppressWarnings(\"rawtypes\")\n    public void testWildcardAdapter() {\n        ConvertFunction<List, Object> foo = new ConvertFunction<List, Object>() {\n            @Override\n            public Object convert(List t, Type type) throws Exception {\n                if (type instanceof Class) {\n                    if (Number.class.isAssignableFrom((Class<?>) type))\n                        return converter.convert(t.size()).to(type);\n                }\n                return null;\n            }\n        };\n\n        Rule<List, Object> r = new Rule<>(List.class, Object.class, foo);\n        Rule<Object, Object> allCatch = new Rule<>(Object.class, Object.class,\n                (v,t) -> v.toString());\n\n        ConverterBuilder cb = converter.newConverterBuilder();\n        cb.rule(r);\n        cb.rule(allCatch);\n        Converter ca = cb.build();\n\n        assertEquals(3L, (long) ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(Long.class));\n        assertEquals(3, (long) ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(Integer.class));\n        assertEquals(\"[a, b, c]\", ca.convert(Arrays.asList(\"a\", \"b\", \"c\")).to(String.class));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testStringArrayToStringAdapter() {\n        Adapter ca = converter.newAdapter();\n        ca.rule(String[].class, String.class,\n                v -> Stream.of(v).collect(Collectors.joining(\",\")),\n                v -> v.split(\",\"));\n\n        assertEquals(\"A\", converter.convert(new String[] {\"A\", \"B\"}).to(String.class));\n        assertEquals(\"A,B\", ca.convert(new String[] {\"A\", \"B\"}).to(String.class));\n\n        assertArrayEquals(new String [] {\"A,B\"},\n                converter.convert(\"A,B\").to(String[].class));\n        assertArrayEquals(new String [] {\"A\",\"B\"},\n                ca.convert(\"A,B\").to(String[].class));\n    }","id":40093,"modified_method":"@Test\n    public void testStringArrayToStringAdapter() {\n        ConverterBuilder cb = converter.newConverterBuilder();\n        Converter ca = cb.rule(String[].class, String.class,\n                v -> Stream.of(v).collect(Collectors.joining(\",\")),\n                v -> v.split(\",\")).build();\n\n        assertEquals(\"A\", converter.convert(new String[] {\"A\", \"B\"}).to(String.class));\n        assertEquals(\"A,B\", ca.convert(new String[] {\"A\", \"B\"}).to(String.class));\n\n        assertArrayEquals(new String [] {\"A,B\"},\n                converter.convert(\"A,B\").to(String[].class));\n        assertArrayEquals(new String [] {\"A\",\"B\"},\n                ca.convert(\"A,B\").to(String[].class));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testSecondLevelAdapter() {\n        Adapter ca = converter.newAdapter();\n\n        ca.rule(char[].class, String.class, AdapterTest::convertToString, null);\n        ca.rule(new Rule<String, Number>(String.class, Number.class, new ConvertFunction<String, Number>() {\n            @Override\n            public Number convert(String obj, Type targetType) throws Exception {\n                if (Integer.class.equals(targetType))\n                    return Integer.valueOf(-1);\n                else if (Long.class.equals(targetType))\n                    return Long.valueOf(-1);\n                return null;\n            }\n        }));\n\n        assertEquals(\"hi\", ca.convert(new char[] {'h', 'i'}).to(String.class));\n        assertEquals(Integer.valueOf(-1), ca.convert(\"Hello\").to(Integer.class));\n        assertEquals(Long.valueOf(-1), ca.convert(\"Hello\").to(Long.class));\n\n        Adapter ca2 = ca.newAdapter();\n        // Shadow the Integer variant but keep Long going to the Number variant.\n        ca2.rule(String.class, Integer.class, v -> v.length(), null);\n        assertEquals(5, (int) ca2.convert(\"Hello\").to(Integer.class));\n        assertEquals(Long.valueOf(-1), ca2.convert(\"Hello\").to(Long.class));\n    }","id":40094,"modified_method":"@Test\n    public void testSecondLevelAdapter() {\n        ConverterBuilder cb = converter.newConverterBuilder();\n\n        cb.rule(char[].class, String.class, AdapterTest::convertToString, null);\n        cb.rule(new Rule<String, Number>(String.class, Number.class, new ConvertFunction<String, Number>() {\n            @Override\n            public Number convert(String obj, Type targetType) throws Exception {\n                if (Integer.class.equals(targetType))\n                    return Integer.valueOf(-1);\n                else if (Long.class.equals(targetType))\n                    return Long.valueOf(-1);\n                return null;\n            }\n        }));\n        Converter ca = cb.build();\n\n        assertEquals(\"hi\", ca.convert(new char[] {'h', 'i'}).to(String.class));\n        assertEquals(Integer.valueOf(-1), ca.convert(\"Hello\").to(Integer.class));\n        assertEquals(Long.valueOf(-1), ca.convert(\"Hello\").to(Long.class));\n\n        // Shadow the Integer variant but keep Long going to the Number variant.\n        Converter ca2 = ca.newConverterBuilder().rule(String.class, Integer.class, v -> v.length(), null).build();\n        assertEquals(5, (int) ca2.convert(\"Hello\").to(Integer.class));\n        assertEquals(Long.valueOf(-1), ca2.convert(\"Hello\").to(Long.class));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test @SuppressWarnings(\"rawtypes\")\n    public void testWildcardAdapter2() {\n        Map<Object, Object> snooped = new HashMap<>();\n        Rule<Object, ArrayList> r = new Rule<>(Object.class, ArrayList.class,\n                (v,t) -> null,\n                (v,t) -> \"arraylist\");\n        Rule<Object, List> r2 = new Rule<>(Object.class, List.class,\n                (v,t) -> null,\n                (v,t) -> \"list\");\n        Rule<Object, Object> allCatch = new Rule<>(Object.class, Object.class,\n                (v,t) -> {snooped.put(v,t); return null;}, null);\n\n        Adapter ca = converter.newAdapter();\n        ca.rule(r);\n        ca.rule(r2);\n        ca.rule(allCatch);\n\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"arraylist\", ca.convert(\n                new ArrayList<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"list\",ca.convert(\n                new LinkedList<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"a\", ca.convert(\n                new HashSet<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(String.class, snooped.get(new HashSet<String>(Arrays.asList(\"a\", \"b\", \"c\"))));\n    }","id":40095,"modified_method":"@Test @SuppressWarnings(\"rawtypes\")\n    public void testWildcardAdapter2() {\n        Map<Object, Object> snooped = new HashMap<>();\n        Rule<Object, ArrayList> r = new Rule<>(Object.class, ArrayList.class,\n                (v,t) -> null,\n                (v,t) -> \"arraylist\");\n        Rule<Object, List> r2 = new Rule<>(Object.class, List.class,\n                (v,t) -> null,\n                (v,t) -> \"list\");\n        Rule<Object, Object> allCatch = new Rule<>(Object.class, Object.class,\n                (v,t) -> {snooped.put(v,t); return null;}, null);\n\n        ConverterBuilder cb = converter.newConverterBuilder();\n        cb.rule(r);\n        cb.rule(r2);\n        cb.rule(allCatch);\n        Converter ca = cb.build();\n\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"arraylist\", ca.convert(\n                new ArrayList<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"list\",ca.convert(\n                new LinkedList<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(\"Precondition\", 0, snooped.size());\n        assertEquals(\"a\", ca.convert(\n                new HashSet<String>(Arrays.asList(\"a\", \"b\", \"c\"))).to(String.class));\n        assertEquals(String.class, snooped.get(new HashSet<String>(Arrays.asList(\"a\", \"b\", \"c\"))));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"public void addStandardRules(Adapter a) {\n        a.rule(Byte.class, String.class, v -> v.toString(), Byte::parseByte); // TODO test\n        a.rule(Character.class, Boolean.class, v -> v.charValue() != 0,\n                v -> v.booleanValue() ? (char) 1 : (char) 0);\n        a.rule(Character.class, String.class, v -> v.toString(),\n                v -> v.length() > 0 ? v.charAt(0) : 0);\n        a.rule(Class.class, String.class, Class::toString,\n                v -> getClass().getClassLoader().loadClass(v));\n        a.rule(Double.class, String.class, v -> v.toString(), Double::parseDouble); // TODO test\n        a.rule(Float.class, String.class, v -> v.toString(), Float::parseFloat); // TODO test\n        a.rule(Integer.class, String.class, v -> v.toString(), Integer::parseInt);\n        a.rule(LocalDateTime.class, String.class, LocalDateTime::toString, LocalDateTime::parse);\n        a.rule(LocalDate.class, String.class, LocalDate::toString, LocalDate::parse);\n        a.rule(LocalTime.class, String.class, LocalTime::toString, LocalTime::parse);\n        a.rule(Long.class, String.class, v -> v.toString(), Long::parseLong); // TODO test\n        a.rule(OffsetDateTime.class, String.class, OffsetDateTime::toString, OffsetDateTime::parse);\n        a.rule(OffsetTime.class, String.class, OffsetTime::toString, OffsetTime::parse);\n        a.rule(Pattern.class, String.class, Pattern::toString, Pattern::compile);\n        a.rule(Short.class, String.class, v -> v.toString(), Short::parseShort); // TODO test\n        a.rule(UUID.class, String.class, UUID::toString, UUID::fromString);\n        a.rule(ZonedDateTime.class, String.class, ZonedDateTime::toString, ZonedDateTime::parse);\n    }","id":40096,"modified_method":"public void addStandardRules(ConverterBuilder a) {\n        a.rule(Byte.class, String.class, v -> v.toString(), Byte::parseByte); // TODO test\n        a.rule(Character.class, Boolean.class, v -> v.charValue() != 0,\n                v -> v.booleanValue() ? (char) 1 : (char) 0);\n        a.rule(Character.class, String.class, v -> v.toString(),\n                v -> v.length() > 0 ? v.charAt(0) : 0);\n        a.rule(Class.class, String.class, Class::toString,\n                v -> getClass().getClassLoader().loadClass(v));\n        a.rule(Double.class, String.class, v -> v.toString(), Double::parseDouble); // TODO test\n        a.rule(Float.class, String.class, v -> v.toString(), Float::parseFloat); // TODO test\n        a.rule(Integer.class, String.class, v -> v.toString(), Integer::parseInt);\n        a.rule(LocalDateTime.class, String.class, LocalDateTime::toString, LocalDateTime::parse);\n        a.rule(LocalDate.class, String.class, LocalDate::toString, LocalDate::parse);\n        a.rule(LocalTime.class, String.class, LocalTime::toString, LocalTime::parse);\n        a.rule(Long.class, String.class, v -> v.toString(), Long::parseLong); // TODO test\n        a.rule(OffsetDateTime.class, String.class, OffsetDateTime::toString, OffsetDateTime::parse);\n        a.rule(OffsetTime.class, String.class, OffsetTime::toString, OffsetTime::parse);\n        a.rule(Pattern.class, String.class, Pattern::toString, Pattern::compile);\n        a.rule(Short.class, String.class, v -> v.toString(), Short::parseShort); // TODO test\n        a.rule(UUID.class, String.class, UUID::toString, UUID::fromString);\n        a.rule(ZonedDateTime.class, String.class, ZonedDateTime::toString, ZonedDateTime::parse);\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Before\n    public void setUp() {\n        converter = new ConverterService();\n    }","id":40097,"modified_method":"@Before\n    public void setUp() {\n        converter = new StandardConverter();\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testCustomStringArrayConverstion() {\n        Adapter adapter = converter.newAdapter();\n        adapter.rule(String[].class, String.class,\n                v -> Stream.of(v).collect(Collectors.joining(\",\")),\n                v -> v.split(\",\"));\n\n        String[] sa = {\"A\", \"B\"};\n        assertEquals(\"A,B\", adapter.convert(sa).to(String.class));\n        assertArrayEquals(sa, adapter.convert(\"A,B\").to(String[].class));\n    }","id":40098,"modified_method":"@Test\n    public void testCustomStringArrayConverstion() {\n        ConverterBuilder cb = converter.newConverterBuilder();\n        cb.rule(String[].class, String.class,\n                v -> Stream.of(v).collect(Collectors.joining(\",\")),\n                v -> v.split(\",\"));\n        Converter adapted = cb.build();\n\n        String[] sa = {\"A\", \"B\"};\n        assertEquals(\"A,B\", adapted.convert(sa).to(String.class));\n        assertArrayEquals(sa, adapted.convert(\"A,B\").to(String[].class));\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Before\n    public void setUp() {\n        converter = new ConverterService();\n    }","id":40099,"modified_method":"@Before\n    public void setUp() {\n        converter = new StandardConverter();\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testUUIDConversion() {\n        ConverterService cs = new ConverterService();\n        UUID uuid = UUID.randomUUID();\n        String s = cs.convert(uuid).to(String.class);\n        assertTrue(\"UUID should be something\", s.length() > 0);\n        UUID uuid2 = cs.convert(s).to(UUID.class);\n        assertEquals(uuid, uuid2);\n    }","id":40100,"modified_method":"@Test\n    public void testUUIDConversion() {\n        UUID uuid = UUID.randomUUID();\n        String s = converter.convert(uuid).to(String.class);\n        assertTrue(\"UUID should be something\", s.length() > 0);\n        UUID uuid2 = converter.convert(s).to(UUID.class);\n        assertEquals(uuid, uuid2);\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testCodecWithAdapter() throws JSONException {\n        Map<String, Foo> m1 = new HashMap<>();\n        m1.put(\"f\", new Foo(\"fofofo\"));\n        Map<String, Object> m = new HashMap<>();\n        m.put(\"submap\", m1);\n\n        Adapter ca = converter.newAdapter();\n        ca.rule(Foo.class, String.class, Foo::tsFun, v -> Foo.fsFun(v));\n\n        JsonSerializerImpl jsonCodec = new JsonSerializerImpl();\n        String json = jsonCodec.serialize(m).with(ca).toString();\n\n        JSONObject jo = new JSONObject(json);\n        assertEquals(1, jo.length());\n        JSONObject jo1 = jo.getJSONObject(\"submap\");\n        assertEquals(\"<fofofo>\", jo1.getString(\"f\"));\n\n        // TODO convert back into a Map<String, Foo> via TypeReference\n    }","id":40101,"modified_method":"@Test\n    public void testCodecWithAdapter() throws JSONException {\n        Map<String, Foo> m1 = new HashMap<>();\n        m1.put(\"f\", new Foo(\"fofofo\"));\n        Map<String, Object> m = new HashMap<>();\n        m.put(\"submap\", m1);\n\n        Converter ca = converter.newConverterBuilder().\n                rule(Foo.class, String.class, Foo::tsFun, v -> Foo.fsFun(v)).build();\n\n        JsonSerializerImpl jsonCodec = new JsonSerializerImpl();\n        String json = jsonCodec.serialize(m).with(ca).toString();\n\n        JSONObject jo = new JSONObject(json);\n        assertEquals(1, jo.length());\n        JSONObject jo1 = jo.getJSONObject(\"submap\");\n        assertEquals(\"<fofofo>\", jo1.getString(\"f\"));\n\n        // TODO convert back into a Map<String, Foo> via TypeReference\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public Converting convert(Object obj) {\n        return adapter.convert(obj);\n    }","id":40102,"modified_method":"@Override\n    public Converting convert(Object obj) {\n        return converter.convert(obj);\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"public StandardConverter() {\n        ConverterImpl impl = new ConverterImpl();\n        Adapter a = impl.newAdapter();\n        impl.addStandardRules(a);\n        adapter = a;\n    }","id":40103,"modified_method":"public StandardConverter() {\n        ConverterImpl impl = new ConverterImpl();\n        ConverterBuilderImpl cb = impl.newConverterBuilder();\n        impl.addStandardRules(cb);\n        converter = cb.build();\n    }","commit_id":"1e321d429493a23be6e4651c2b509753e67c76b2","url":"https://github.com/apache/felix"},{"original_method":"@Nullable\n  public ChangesBrowserNode getParentNodeFor(final ChangesBrowserNode node, final ChangesBrowserNode rootNode) {\n    ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n    final FilePath path = TreeModelBuilder.getPathForObject(node.getUserObject());\n    VirtualFile vFile = path.getVirtualFile();\n    if (vFile != null && vFile == index.getContentRootForFile(vFile)) {\n      Module module = index.getModuleForFile(vFile);\n      return getNodeForModule(module, rootNode);\n    }\n    return null;\n  }","id":40104,"modified_method":"@Nullable\n  public ChangesBrowserNode getParentNodeFor(final StaticFilePath node, final ChangesBrowserNode rootNode) {\n    ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n\n    VirtualFile vFile = node.getVf();\n    if (vFile != null && vFile == index.getContentRootForFile(vFile)) {\n      Module module = index.getModuleForFile(vFile);\n      return getNodeForModule(module, rootNode);\n    }\n    return null;\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insertFilesIntoNode(List<VirtualFile> files, ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (VirtualFile file : files) {\n      insertChangeNode(file, policy, baseNode, defaultNodeCreator(file));\n    }\n  }","id":40105,"modified_method":"private void insertFilesIntoNode(final List<VirtualFile> files, ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    Collections.sort(files, VirtualFileHierarchicalComparator.getInstance());\n    \n    for (VirtualFile file : files) {\n      insertChangeNode(file, policy, baseNode, defaultNodeCreator(file));\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildLogicallyLockedFiles(final Map<VirtualFile, LogicalLock> logicallyLockedFiles) {\n    final ChangesBrowserNode baseNode = createNode(ChangesBrowserNode.LOGICALLY_LOCKED_TAG);\n\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (Map.Entry<VirtualFile, LogicalLock> entry : logicallyLockedFiles.entrySet()) {\n      final VirtualFile file = entry.getKey();\n      final LogicalLock lock = entry.getValue();\n      final ChangesBrowserLogicallyLockedFile obj = new ChangesBrowserLogicallyLockedFile(myProject, file, lock);\n      insertChangeNode(obj, policy, baseNode,\n                       defaultNodeCreator(obj));\n    }\n  }","id":40106,"modified_method":"private void buildLogicallyLockedFiles(final Map<VirtualFile, LogicalLock> logicallyLockedFiles) {\n    final ChangesBrowserNode baseNode = createNode(ChangesBrowserNode.LOGICALLY_LOCKED_TAG);\n\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    final List<VirtualFile> keys = new ArrayList<VirtualFile>(logicallyLockedFiles.keySet());\n    Collections.sort(keys, VirtualFileHierarchicalComparator.getInstance());\n\n    for (final VirtualFile file : keys) {\n      final LogicalLock lock = logicallyLockedFiles.get(file);\n      final ChangesBrowserLogicallyLockedFile obj = new ChangesBrowserLogicallyLockedFile(myProject, file, lock);\n      insertChangeNode(obj, policy, baseNode, defaultNodeCreator(obj));\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildFilePaths(final Collection<FilePath> filePaths, final ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (FilePath file : filePaths) {\n      assert file != null;\n      // todo: or path from filepath?\n      final String pathKey = FilePathsHelper.convertPath(file.getIOFile().getAbsolutePath());\n      ChangesBrowserNode oldNode = myFoldersCache.get(pathKey);\n      if (oldNode == null) {\n        final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, file);\n        final ChangesBrowserNode parentNode = getParentNodeFor(node, policy, baseNode);\n        model.insertNodeInto(node, parentNode, 0);\n        myFoldersCache.put(pathKey, node);\n      }\n    }\n  }","id":40107,"modified_method":"private void buildFilePaths(final Collection<FilePath> filePaths, final ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (FilePath file : filePaths) {\n      assert file != null;\n      // whether a folder does not matter\n      final StaticFilePath pathKey = new StaticFilePath(false, file.getIOFile().getAbsolutePath(), file.getVirtualFile());\n      ChangesBrowserNode oldNode = myFoldersCache.get(pathKey.getKey());\n      if (oldNode == null) {\n        final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, file);\n        final ChangesBrowserNode parentNode = getParentNodeFor(pathKey, policy, baseNode);\n        model.insertNodeInto(node, parentNode, 0);\n        // we could also ask whether a file or directory, though for deleted files not a good idea\n        myFoldersCache.put(pathKey.getKey(), node);\n      }\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildSwitchedRoots(final Map<VirtualFile, String> switchedRoots) {\n    final ChangesBrowserNode rootsHeadNode = ChangesBrowserNode.create(myProject, ChangesBrowserNode.SWITCHED_ROOTS_TAG);\n    rootsHeadNode.setAttributes(SimpleTextAttributes.GRAYED_BOLD_ATTRIBUTES);\n    model.insertNodeInto(rootsHeadNode, root, root.getChildCount());\n\n    for (VirtualFile vf : switchedRoots.keySet()) {\n      final ChangesGroupingPolicy policy = createGroupingPolicy();\n      final ContentRevision cr = new CurrentContentRevision(new FilePathImpl(vf));\n      final Change change = new Change(cr, cr, FileStatus.NOT_CHANGED);\n      final String branchName = switchedRoots.get(vf);\n      insertChangeNode(vf, policy, rootsHeadNode, new Computable<ChangesBrowserNode>() {\n        public ChangesBrowserNode compute() {\n          return new ChangesBrowserChangeNode(myProject, change, new ChangeNodeDecorator() {\n            public void decorate(Change change, SimpleColoredComponent component, boolean isShowFlatten) {\n            }\n            public List<Pair<String, Stress>> stressPartsOfFileName(Change change, String parentPath) {\n              return null;\n            }\n            public void preDecorate(Change change, ChangesBrowserNodeRenderer renderer, boolean showFlatten) {\n              renderer.append(\"[\" + branchName + \"] \", SimpleTextAttributes.GRAYED_BOLD_ATTRIBUTES);\n            }\n          });\n        }\n      });\n    }\n  }","id":40108,"modified_method":"private void buildSwitchedRoots(final Map<VirtualFile, String> switchedRoots) {\n    final ChangesBrowserNode rootsHeadNode = ChangesBrowserNode.create(myProject, ChangesBrowserNode.SWITCHED_ROOTS_TAG);\n    rootsHeadNode.setAttributes(SimpleTextAttributes.GRAYED_BOLD_ATTRIBUTES);\n    model.insertNodeInto(rootsHeadNode, root, root.getChildCount());\n\n    final List<VirtualFile> files = new ArrayList<VirtualFile>(switchedRoots.keySet());\n    Collections.sort(files, VirtualFileHierarchicalComparator.getInstance());\n    \n    for (VirtualFile vf : files) {\n      final ChangesGroupingPolicy policy = createGroupingPolicy();\n      final ContentRevision cr = new CurrentContentRevision(new FilePathImpl(vf));\n      final Change change = new Change(cr, cr, FileStatus.NOT_CHANGED);\n      final String branchName = switchedRoots.get(vf);\n      insertChangeNode(vf, policy, rootsHeadNode, new Computable<ChangesBrowserNode>() {\n        public ChangesBrowserNode compute() {\n          return new ChangesBrowserChangeNode(myProject, change, new ChangeNodeDecorator() {\n            public void decorate(Change change, SimpleColoredComponent component, boolean isShowFlatten) {\n            }\n            public List<Pair<String, Stress>> stressPartsOfFileName(Change change, String parentPath) {\n              return null;\n            }\n            public void preDecorate(Change change, ChangesBrowserNodeRenderer renderer, boolean showFlatten) {\n              renderer.append(\"[\" + branchName + \"] \", SimpleTextAttributes.GRAYED_BOLD_ATTRIBUTES);\n            }\n          });\n        }\n      });\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ChangesBrowserNode getParentNodeFor(ChangesBrowserNode node, @Nullable ChangesGroupingPolicy policy, ChangesBrowserNode rootNode) {\n    if (showFlatten) {\n      return rootNode;\n    }\n\n    final FilePath path = getPathForObject(node.getUserObject());\n\n    if (policy != null) {\n      ChangesBrowserNode nodeFromPolicy = policy.getParentNodeFor(node, rootNode);\n      if (nodeFromPolicy != null) {\n        return nodeFromPolicy;\n      }\n    }\n\n    FilePath parentPath = path.getParentPath();\n    if (parentPath == null) {\n      return rootNode;\n    }\n\n    final String parentKey = FilePathsHelper.convertPath(parentPath);\n    ChangesBrowserNode parentNode = myFoldersCache.get(parentKey);\n    if (parentNode == null) {\n      parentNode = ChangesBrowserNode.create(myProject, parentPath);\n      ChangesBrowserNode grandPa = getParentNodeFor(parentNode, policy, rootNode);\n      model.insertNodeInto(parentNode, grandPa, grandPa.getChildCount());\n      myFoldersCache.put(parentKey, parentNode);\n    }\n\n    return parentNode;\n  }","id":40109,"modified_method":"private ChangesBrowserNode getParentNodeFor(final StaticFilePath nodePath, @Nullable ChangesGroupingPolicy policy, ChangesBrowserNode rootNode) {\n    if (showFlatten) {\n      return rootNode;\n    }\n\n    if (policy != null) {\n      ChangesBrowserNode nodeFromPolicy = policy.getParentNodeFor(nodePath, rootNode);\n      if (nodeFromPolicy != null) {\n        return nodeFromPolicy;\n      }\n    }\n\n    final StaticFilePath parentPath = nodePath.getParent();\n    if (parentPath == null) {\n      return rootNode;\n    }\n\n    ChangesBrowserNode parentNode = myFoldersCache.get(parentPath.getKey());\n    if (parentNode == null) {\n      parentNode = ChangesBrowserNode.create(myProject, new FilePathImpl(new File(parentPath.getPath()), true));\n      ChangesBrowserNode grandPa = getParentNodeFor(parentPath, policy, rootNode);\n      model.insertNodeInto(parentNode, grandPa, grandPa.getChildCount());\n      myFoldersCache.put(parentPath.getKey(), parentNode);\n    }\n\n    return parentNode;\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultTreeModel buildModel(List<? extends ChangeList> changeLists) {\n    final RemoteRevisionsCache revisionsCache = RemoteRevisionsCache.getInstance(myProject);\n    for (ChangeList list : changeLists) {\n      final Collection<Change> changes = list.getChanges();\n      final ChangeListRemoteState listRemoteState = new ChangeListRemoteState(changes.size());\n      ChangesBrowserNode listNode = new ChangesBrowserChangeListNode(myProject, list, listRemoteState);\n      model.insertNodeInto(listNode, root, 0);\n      resetGrouping();\n      final ChangesGroupingPolicy policy = createGroupingPolicy();\n      int i = 0;\n      for (final Change change : changes) {\n        final MyChangeNodeUnderChangeListDecorator decorator =\n          new MyChangeNodeUnderChangeListDecorator(revisionsCache, new ChangeListRemoteState.Reporter(i, listRemoteState));\n        insertChangeNode(change, policy, listNode, new Computable<ChangesBrowserNode>() {\n          public ChangesBrowserNode compute() {\n            return new ChangesBrowserChangeNode(myProject, change, decorator);\n          }\n        });\n        ++ i;\n      }\n    }\n    return model;\n  }","id":40110,"modified_method":"public DefaultTreeModel buildModel(List<? extends ChangeList> changeLists) {\n    final RemoteRevisionsCache revisionsCache = RemoteRevisionsCache.getInstance(myProject);\n    for (ChangeList list : changeLists) {\n      final List<Change> changes = new ArrayList<Change>(list.getChanges());\n      final ChangeListRemoteState listRemoteState = new ChangeListRemoteState(changes.size());\n      ChangesBrowserNode listNode = new ChangesBrowserChangeListNode(myProject, list, listRemoteState);\n      model.insertNodeInto(listNode, root, 0);\n      resetGrouping();\n      final ChangesGroupingPolicy policy = createGroupingPolicy();\n      int i = 0;\n      Collections.sort(changes, MyChangePathLengthComparator.getInstance());\n      for (final Change change : changes) {\n        final MyChangeNodeUnderChangeListDecorator decorator =\n          new MyChangeNodeUnderChangeListDecorator(revisionsCache, new ChangeListRemoteState.Reporter(i, listRemoteState));\n        insertChangeNode(change, policy, listNode, new Computable<ChangesBrowserNode>() {\n          public ChangesBrowserNode compute() {\n            return new ChangesBrowserChangeNode(myProject, change, decorator);\n          }\n        });\n        ++ i;\n      }\n    }\n    return model;\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getKey(final Object o) {\n    if (o instanceof Change) {\n      return FilePathsHelper.convertPath(ChangesUtil.getFilePath((Change) o));\n    }\n    else if (o instanceof VirtualFile) {\n      return FilePathsHelper.convertPath((VirtualFile) o);\n    }\n    else if (o instanceof FilePath) {\n      // todo ? or path from filepath\n      return FilePathsHelper.convertPath(((FilePath) o).getIOFile().getAbsolutePath());\n    } else if (o instanceof ChangesBrowserLogicallyLockedFile) {\n      return FilePathsHelper.convertPath(((ChangesBrowserLogicallyLockedFile) o).getUserObject());\n    } else if (o instanceof LocallyDeletedChange) {\n      return FilePathsHelper.convertPath(((LocallyDeletedChange) o).getPath());\n    }\n\n    return null;\n  }","id":40111,"modified_method":"private static StaticFilePath getKey(final Object o) {\n    if (o instanceof Change) {\n      return staticFrom(ChangesUtil.getFilePath((Change) o));\n    }\n    else if (o instanceof VirtualFile) {\n      return staticFrom((VirtualFile) o);\n    }\n    else if (o instanceof FilePath) {\n      return staticFrom((FilePath) o);\n    } else if (o instanceof ChangesBrowserLogicallyLockedFile) {\n      return staticFrom(((ChangesBrowserLogicallyLockedFile) o).getUserObject());\n    } else if (o instanceof LocallyDeletedChange) {\n      return staticFrom(((LocallyDeletedChange) o).getPath());\n    }\n\n    return null;\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildLocallyDeletedPaths(final Collection<LocallyDeletedChange> locallyDeletedChanges, final ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (LocallyDeletedChange change : locallyDeletedChanges) {\n      final String key = FilePathsHelper.convertPath(change.getPresentableUrl());\n      ChangesBrowserNode oldNode = myFoldersCache.get(key);\n      if (oldNode == null) {\n        final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n        final ChangesBrowserNode parent = getParentNodeFor(node, policy, baseNode);\n        model.insertNodeInto(node, parent, parent.getChildCount());\n        myFoldersCache.put(key, node);\n      }\n    }\n  }","id":40112,"modified_method":"private void buildLocallyDeletedPaths(final Collection<LocallyDeletedChange> locallyDeletedChanges, final ChangesBrowserNode baseNode) {\n    final ChangesGroupingPolicy policy = createGroupingPolicy();\n    for (LocallyDeletedChange change : locallyDeletedChanges) {\n      // whether a folder does not matter\n      final StaticFilePath key = new StaticFilePath(false, change.getPresentableUrl(), change.getPath().getVirtualFile());\n      ChangesBrowserNode oldNode = myFoldersCache.get(key.getKey());\n      if (oldNode == null) {\n        final ChangesBrowserNode node = ChangesBrowserNode.create(myProject, change);\n        final ChangesBrowserNode parent = getParentNodeFor(key, policy, baseNode);\n        model.insertNodeInto(node, parent, parent.getChildCount());\n        myFoldersCache.put(key.getKey(), node);\n      }\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildSwitchedFiles(final MultiMap<String, VirtualFile> switchedFiles) {\n    ChangesBrowserNode baseNode = ChangesBrowserNode.create(myProject, ChangesBrowserNode.SWITCHED_FILES_TAG);\n    model.insertNodeInto(baseNode, root, root.getChildCount());\n    for(String branchName: switchedFiles.keySet()) {\n      final Collection<VirtualFile> switchedFileList = switchedFiles.get(branchName);\n      if (switchedFileList.size() > 0) {\n        ChangesBrowserNode branchNode = ChangesBrowserNode.create(myProject, branchName);\n        model.insertNodeInto(branchNode, baseNode, baseNode.getChildCount());\n\n        final ChangesGroupingPolicy policy = createGroupingPolicy();\n        for (VirtualFile file : switchedFileList) {\n          insertChangeNode(file, policy, branchNode, defaultNodeCreator(file));\n        }\n      }\n    }\n  }","id":40113,"modified_method":"private void buildSwitchedFiles(final MultiMap<String, VirtualFile> switchedFiles) {\n    ChangesBrowserNode baseNode = ChangesBrowserNode.create(myProject, ChangesBrowserNode.SWITCHED_FILES_TAG);\n    model.insertNodeInto(baseNode, root, root.getChildCount());\n    for(String branchName: switchedFiles.keySet()) {\n      final List<VirtualFile> switchedFileList = new ArrayList<VirtualFile>(switchedFiles.get(branchName));\n      if (switchedFileList.size() > 0) {\n        ChangesBrowserNode branchNode = ChangesBrowserNode.create(myProject, branchName);\n        model.insertNodeInto(branchNode, baseNode, baseNode.getChildCount());\n\n        final ChangesGroupingPolicy policy = createGroupingPolicy();\n        Collections.sort(switchedFileList, VirtualFileHierarchicalComparator.getInstance());\n        for (VirtualFile file : switchedFileList) {\n          insertChangeNode(file, policy, branchNode, defaultNodeCreator(file));\n        }\n      }\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insertChangeNode(final Object change, final ChangesGroupingPolicy policy,\n                                final ChangesBrowserNode listNode, final Computable<ChangesBrowserNode> nodeCreator) {\n    final String pathKey = getKey(change);\n    ChangesBrowserNode oldNode = (pathKey == null) ? null : myFoldersCache.get(pathKey);\n    final ChangesBrowserNode node = nodeCreator.compute();\n    if (oldNode != null) {\n      for(int i=oldNode.getChildCount()-1; i >= 0; i--) {\n        MutableTreeNode child = (MutableTreeNode) model.getChild(oldNode, i);\n        model.removeNodeFromParent(child);\n        model.insertNodeInto(child, node, model.getChildCount(node));\n      }\n      final MutableTreeNode parent = (MutableTreeNode)oldNode.getParent();\n      int index = model.getIndexOfChild(parent, oldNode);\n      model.removeNodeFromParent(oldNode);\n      model.insertNodeInto(node, parent, index);\n    }\n    else {\n      ChangesBrowserNode parentNode = getParentNodeFor(node, policy, listNode);\n      model.insertNodeInto(node, parentNode, model.getChildCount(parentNode));\n    }\n\n    if (pathKey != null) {\n      myFoldersCache.put(pathKey, node);\n    }\n  }","id":40114,"modified_method":"private void insertChangeNode(final Object change, final ChangesGroupingPolicy policy,\n                                final ChangesBrowserNode listNode, final Computable<ChangesBrowserNode> nodeCreator) {\n    final StaticFilePath pathKey = getKey(change);\n    final ChangesBrowserNode node = nodeCreator.compute();\n    ChangesBrowserNode parentNode = getParentNodeFor(pathKey, policy, listNode);\n    model.insertNodeInto(node, parentNode, model.getChildCount(parentNode));\n\n    if (pathKey != null && pathKey.isDirectory()) {\n      myFoldersCache.put(pathKey.getKey(), node);\n    }\n  }","commit_id":"4b1e3b0697a31e71ead370ae93efe89460a294b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    // get basic information\n    final Project project = event.getData(PlatformDataKeys.PROJECT);\n    if (project == null || project.isDisposed()) {\n      notifyError(project, \"Project is null. \" + event.getPlace() + \", \" + event.getDataContext(), null);\n      return;\n    }\n    final VirtualFile[] vFiles = event.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null) {\n      notifyError(project, \"Selected incorrect virtual files array: \" + Arrays.toString(vFiles), null);\n      return;\n    }\n    final VirtualFile file = vFiles[0];\n    final VirtualFile vcsRoot = VcsUtil.getVcsRootFor(project, file);\n    if (vcsRoot == null) {\n      notifyError(project, \"The file \" + file + \" is not under Git version control.\", null);\n      return;\n    }\n\n    // get branches information\n    final List<GitBranch> branches = new ArrayList<GitBranch>();\n    GitBranch curBranch = null;\n    try {\n      curBranch = GitBranch.list(project, vcsRoot, true, true, branches, null);\n    } catch (VcsException e) {\n      notifyError(project, \"Couldn't get information about current branch\", e);\n    }\n    if (curBranch == null) {\n      notifyError(project, \"Current branch is null.\", null);\n      return;\n    }\n    final String currentBranch = curBranch.getName();\n\n    // prepare and invoke popup\n    final JBList list = new JBList(branches);\n    list.installCellRenderer(new NotNullFunction<GitBranch, JComponent>() { // display current branch in bold with asterisk\n      @NotNull public JComponent fun(GitBranch branch) {\n        if (branch.isActive()) {\n          JLabel label = new JLabel(branch.getName() + \" *\");\n          final Map<TextAttribute, Float> attributes = new HashMap<TextAttribute, Float>(1);\n          attributes.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);\n          label.setFont(label.getFont().deriveFont(attributes));\n          return label;\n        }\n        return new JLabel(branch.getName());\n      }\n    });\n\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Select branch to compare\")\n      .setItemChoosenCallback(\n        new Runnable() {\n          public void run() {\n            Application app = ApplicationManager.getApplication();\n            if (project.isDisposed() || app == null || !app.isActive() || app.isDisposed() || app.isDisposeInProgress()) { // safe check\n              return;\n            }\n            ApplicationManager.getApplication()\n              .invokeLater(new Runnable() { // don't block awt thread - getting revision content may take long\n\n                @Override\n                public void run() {\n                  try {\n                    showDiffWithBranch(project, file, currentBranch, list.getSelectedValue().toString());\n                  }\n                  catch (Exception e) {\n                    notifyError(project, \"Couldn't compare file [\" + file + \"] with selected branch [\" + list.getSelectedValue() + \"]\", e);\n                  }\n                }\n              });\n          }\n        })\n      .setAutoselectOnMouseMove(true)\n      .createPopup()\n      .showInBestPositionFor(event.getDataContext());\n  }","id":40115,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    final Project project = event.getProject();\n    assert project != null;\n\n    final VirtualFile file = getAffectedFile(event);\n\n    GitRepository repository = GitRepositoryManager.getInstance(project).getRepositoryForFile(file);\n    assert repository != null;\n\n    final String head = repository.getCurrentRevision();\n    final List<String> branchNames = getBranchNamesExceptCurrent(repository);\n\n    // prepare and invoke popup\n    final JBList list = new JBList(branchNames);\n\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Select branch to compare\")\n      .setItemChoosenCallback(new OnBranchChooseRunnable(project, file, head, list))\n      .setAutoselectOnMouseMove(true)\n      .createPopup()\n      .showInBestPositionFor(event.getDataContext());\n  }","commit_id":"1fd83a071620aa779b0be19e8f07d08e6499a36c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    Presentation presentation = e.getPresentation();\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    VirtualFile[] vFiles = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length == 0 || vFiles.length > 1) { // only 1 file for now\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n    GitVcs vcs = GitVcs.getInstance(project);\n    boolean enabled = ProjectLevelVcsManager.getInstance(project).checkAllFilesAreUnder(vcs, vFiles);\n    enabled &= vFiles[0] != null && !vFiles[0].isDirectory(); // not for dirs for now\n\n    presentation.setEnabled(enabled);\n    presentation.setVisible(enabled);\n  }","id":40116,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    Presentation presentation = e.getPresentation();\n    Project project = e.getProject();\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    VirtualFile[] vFiles = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null || vFiles[0].isDirectory()) { // only 1 file for now, not for dirs\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n\n    GitRepository repository = GitRepositoryManager.getInstance(project).getRepositoryForFile(vFiles[0]);\n    if (repository == null || repository.isFresh() || noBranchesToCompare(repository)) {\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n    }\n  }","commit_id":"1fd83a071620aa779b0be19e8f07d08e6499a36c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void showResult() {\n    if (!success.isNull()) {\n      SimpleDiffRequest req = new SimpleDiffRequest(myProject, SvnBundle.message(\"compare.with.branch.diff.title\"));\n      req.setContents(new SimpleContent(CharsetToolkit.bytesToString(content.get(), myVirtualFile.getCharset())),\n                      new FileContent(myProject, myVirtualFile));\n      req.setContentTitles(remoteTitleBuilder.toString(), myVirtualFile.getPresentableUrl());\n      DiffManager.getInstance().getDiffTool().show(req);\n    }\n  }","id":40117,"modified_method":"@Override\n  protected void showResult() {\n    if (!success.isNull()) {\n      String title = SvnBundle.message(\"compare.with.branch.diff.title\");\n\n      String title1 = remoteTitleBuilder.toString();\n      String title2 = myVirtualFile.getPresentableUrl();\n\n      String contentText = CharsetToolkit.bytesToString(content.get(), myVirtualFile.getCharset());\n      DiffContent content1 = FileAwareDocumentContent.create(myProject, contentText, myVirtualFile);\n      DiffContent content2 = DiffContentFactory.create(myProject, myVirtualFile);\n\n      DiffRequest request = new SimpleDiffRequest(title, content1, content2, title1, title2);\n\n      DiffManager.getInstance().showDiff(myProject, request, DiffDialogHints.DEFAULT);\n    }\n  }","commit_id":"12002786987610775b8025eec1f6b670127535db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    return myPanel;\n  }","id":40118,"modified_method":"protected JComponent createCenterPanel() {\n    BorderLayoutPanel rootPanel = JBUI.Panels.simplePanel(UIUtil.DEFAULT_HGAP, UIUtil.DEFAULT_VGAP);\n    rootPanel.addToTop(myRootLabel);\n    rootPanel.addToCenter(myTextArea);\n    return rootPanel;\n  }","commit_id":"f106bf3d6c6644c88e73c252ec6c78b2b982e0fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected GitRebaseUnstructuredEditor(@NotNull Project project, @NotNull VirtualFile root, @NotNull String rebaseFilePath)\n    throws IOException {\n    super(project, true);\n    setTitle(GitBundle.message(\"rebase.unstructured.editor.title\"));\n    setOKButtonText(GitBundle.message(\"rebase.unstructured.editor.button\"));\n    myGitRootLabel.setText(root.getPresentableUrl());\n    myEncoding = GitConfigUtil.getCommitEncoding(project, root);\n    myFile = new File(rebaseFilePath);\n    myTextArea.setText(FileUtil.loadFile(myFile, myEncoding));\n    myTextArea.setCaretPosition(0);\n    init();\n  }","id":40119,"modified_method":"protected GitRebaseUnstructuredEditor(@NotNull Project project, @NotNull VirtualFile root, @NotNull String rebaseFilePath)\n    throws IOException {\n    super(project, true);\n    setTitle(GitBundle.message(\"rebase.unstructured.editor.title\"));\n    setOKButtonText(GitBundle.message(\"rebase.unstructured.editor.button\"));\n\n    myRootLabel = new JBLabel(\"Git Root: \" + root.getPresentableUrl());\n    myEncoding = GitConfigUtil.getCommitEncoding(project, root);\n    myFile = new File(rebaseFilePath);\n    myTextArea = new JTextArea(FileUtil.loadFile(myFile, myEncoding));\n    myTextArea.setCaretPosition(0);\n    init();\n  }","commit_id":"f106bf3d6c6644c88e73c252ec6c78b2b982e0fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n  * Test Poisson regression on simple and small synthetic dataset.\n  * Equation is: y = exp(x+1);\n  */\n @Test public void testPoissonRegression() throws InterruptedException, ExecutionException {\n   Key raw = Key.make(\"poisson_test_data_raw\");\n   Key parsed = Key.make(\"poisson_test_data_parsed\");\n   Key model = Key.make(\"poisson_test\");\n   try {\n     // make data so that the expected coefficients is icept = col[0] = 1.0\n     Key k = FVecTest.makeByteVec(raw, \"x,y\\n0,2\\n1,4\\n2,8\\n3,16\\n4,32\\n5,64\\n6,128\\n7,256\");\n     Frame fr = ParseDataset2.parse(parsed, new Key[]{k});\n     new GLM2(\"GLM test of poisson regression.\",model,fr,false,Family.poisson, Family.poisson.defaultLink,0,0).fork().get();\n     GLMModel m = DKV.get(model).get();\n     for(double c:m.beta())assertEquals(Math.log(2),c,1e-4);\n     // Test 2, example from http://www.biostat.umn.edu/~dipankar/bmtry711.11/lecture_13.pdf\n     //new byte []{1,2,3,4,5,6,7,8, 9, 10,11,12,13,14},\n//     new byte []{0,1,2,3,1,4,9,18,23,31,20,25,37,45});\n\n     k = FVecTest.makeByteVec(raw, \"x,y\\n1,0\\n2,1\\n3,2\\n4,3\\n5,1\\n6,4\\n7,9\\n8,18\\n9,23\\n10,31\\n11,20\\n12,25\\n13,37\\n14,45\\n\");\n     fr = ParseDataset2.parse(parsed, new Key[]{k});\n     new GLM2(\"GLM test of poisson regression(2).\",model,fr,false,Family.poisson, Family.poisson.defaultLink,0,0).fork().get();\n     m = DKV.get(model).get();\n     assertEquals(0.3396,m.beta()[1],1e-4);\n     assertEquals(0.2565,m.beta()[0],1e-4);\n   }finally{\n     UKV.remove(raw);\n     UKV.remove(parsed);\n     UKV.remove(model);\n   }\n }","id":40120,"modified_method":"/**\n  * Test Poisson regression on simple and small synthetic dataset.\n  * Equation is: y = exp(x+1);\n  */\n @Test public void testPoissonRegression() throws InterruptedException, ExecutionException {\n   Key raw = Key.make(\"poisson_test_data_raw\");\n   Key parsed = Key.make(\"poisson_test_data_parsed\");\n   Key model = Key.make(\"poisson_test\");\n   try {\n     // make data so that the expected coefficients is icept = col[0] = 1.0\n     FVecTest.makeByteVec(raw, \"x,y\\n0,2\\n1,4\\n2,8\\n3,16\\n4,32\\n5,64\\n6,128\\n7,256\");\n     Frame fr = ParseDataset2.parse(parsed, new Key[]{raw});\n     new GLM2(\"GLM test of poisson regression.\",model,fr,false,Family.poisson, Family.poisson.defaultLink,0,0).fork().get();\n     GLMModel m = DKV.get(model).get();\n     for(double c:m.beta())assertEquals(Math.log(2),c,1e-4);\n     // Test 2, example from http://www.biostat.umn.edu/~dipankar/bmtry711.11/lecture_13.pdf\n     //new byte []{1,2,3,4,5,6,7,8, 9, 10,11,12,13,14},\n//     new byte []{0,1,2,3,1,4,9,18,23,31,20,25,37,45});\n\n     UKV.remove(raw);\n     FVecTest.makeByteVec(raw, \"x,y\\n1,0\\n2,1\\n3,2\\n4,3\\n5,1\\n6,4\\n7,9\\n8,18\\n9,23\\n10,31\\n11,20\\n12,25\\n13,37\\n14,45\\n\");\n     fr = ParseDataset2.parse(parsed, new Key[]{raw});\n     new GLM2(\"GLM test of poisson regression(2).\",model,fr,false,Family.poisson, Family.poisson.defaultLink,0,0).fork().get();\n     m = DKV.get(model).get();\n     assertEquals(0.3396,m.beta()[1],1e-4);\n     assertEquals(0.2565,m.beta()[0],1e-4);\n   }finally{\n     UKV.remove(raw);\n     UKV.remove(parsed);\n     UKV.remove(model);\n   }\n }","commit_id":"25e216b22030ad6bb9c4d083e029120fa0aaf46b","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Test Gamma regression on simple and small synthetic dataset.\n   * Equation is: y = 1/(x+1);\n   * @throws ExecutionException\n   * @throws InterruptedException\n   */\n  @Test public void testGammaRegression() throws InterruptedException, ExecutionException {\n    Key raw = Key.make(\"gamma_test_data_raw\");\n    Key parsed = Key.make(\"gamma_test_data_parsed\");\n    Key model = Key.make(\"gamma_test\");\n    try {\n      // make data so that the expected coefficients is icept = col[0] = 1.0\n      Key k = FVecTest.makeByteVec(raw, \"x,y\\n0,1\\n1,0.5\\n2,0.3333333\\n3,0.25\\n4,0.2\\n5,0.1666667\\n6,0.1428571\\n7,0.125\");\n      Frame fr = ParseDataset2.parse(parsed, new Key[]{k});\n//      /public GLM2(String desc, Key dest, Frame src, Family family, Link link, double alpha, double lambda) {\n      double [] vals = new double[] {1.0,1.0};\n      //public GLM2(String desc, Key dest, Frame src, Family family, Link link, double alpha, double lambda) {\n      new GLM2(\"GLM test of gamma regression.\",model,fr,false,Family.gamma, Family.gamma.defaultLink,0,0).fork().get();\n      GLMModel m = DKV.get(model).get();\n      for(double c:m.beta())assertEquals(1.0, c,1e-4);\n    }finally{\n      UKV.remove(raw);\n      UKV.remove(parsed);\n      UKV.remove(model);\n    }\n  }","id":40121,"modified_method":"/**\n   * Test Gamma regression on simple and small synthetic dataset.\n   * Equation is: y = 1/(x+1);\n   * @throws ExecutionException\n   * @throws InterruptedException\n   */\n  @Test public void testGammaRegression() throws InterruptedException, ExecutionException {\n    Key raw = Key.make(\"gamma_test_data_raw\");\n    Key parsed = Key.make(\"gamma_test_data_parsed\");\n    Key model = Key.make(\"gamma_test\");\n    try {\n      // make data so that the expected coefficients is icept = col[0] = 1.0\n      FVecTest.makeByteVec(raw, \"x,y\\n0,1\\n1,0.5\\n2,0.3333333\\n3,0.25\\n4,0.2\\n5,0.1666667\\n6,0.1428571\\n7,0.125\");\n      Frame fr = ParseDataset2.parse(parsed, new Key[]{raw});\n//      /public GLM2(String desc, Key dest, Frame src, Family family, Link link, double alpha, double lambda) {\n      double [] vals = new double[] {1.0,1.0};\n      //public GLM2(String desc, Key dest, Frame src, Family family, Link link, double alpha, double lambda) {\n      new GLM2(\"GLM test of gamma regression.\",model,fr,false,Family.gamma, Family.gamma.defaultLink,0,0).fork().get();\n      GLMModel m = DKV.get(model).get();\n      for(double c:m.beta())assertEquals(1.0, c,1e-4);\n    }finally{\n      UKV.remove(raw);\n      UKV.remove(parsed);\n      UKV.remove(model);\n    }\n  }","commit_id":"25e216b22030ad6bb9c4d083e029120fa0aaf46b","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testTweedieRegression() throws InterruptedException, ExecutionException{\n    Key raw = Key.make(\"gaussian_test_data_raw\");\n    Key parsed = Key.make(\"gaussian_test_data_parsed\");\n    Key model = Key.make(\"gaussian_test\");\n    try {\n      // make data so that the expected coefficients is icept = col[0] = 1.0\n      Key k = FVecTest.makeByteVec(raw, \"x,y\\n0,0\\n1,0.1\\n2,0.2\\n3,0.3\\n4,0.4\\n5,0.5\\n6,0.6\\n7,0.7\\n8,0.8\\n9,0.9\\n0,0\\n1,0\\n2,0\\n3,0\\n4,0\\n5,0\\n6,0\\n7,0\\n8,0\\n9,0\");\n      Frame fr = ParseDataset2.parse(parsed, new Key[]{k});\n      double [] powers = new double [] {1.5,1.1,1.9};\n      double [] intercepts = new double []{3.643,1.318,9.154};\n      double [] xs = new double []{-0.260,-0.0284,-0.853};\n      for(int i = 0; i < powers.length; ++i){\n        new GLM2(\"GLM test of gaussian(linear) regression.\",model,fr,false,Family.tweedie, Family.tweedie.defaultLink,0,0).setTweedieVarPower(powers[i]).fork().get();\n        GLMModel m = DKV.get(model).get();\n        HashMap<String, Double> coefs = m.coefficients();\n        assertEquals(intercepts[i],coefs.get(\"Intercept\"),1e-3);\n        assertEquals(xs[i],coefs.get(\"x\"),1e-3);\n      }\n    }finally{\n      UKV.remove(raw);\n      UKV.remove(parsed);\n      UKV.remove(model);\n    }\n  }","id":40122,"modified_method":"@Test public void testTweedieRegression() throws InterruptedException, ExecutionException{\n    Key raw = Key.make(\"gaussian_test_data_raw\");\n    Key parsed = Key.make(\"gaussian_test_data_parsed\");\n    Key model = Key.make(\"gaussian_test\");\n    try {\n      // make data so that the expected coefficients is icept = col[0] = 1.0\n      FVecTest.makeByteVec(raw, \"x,y\\n0,0\\n1,0.1\\n2,0.2\\n3,0.3\\n4,0.4\\n5,0.5\\n6,0.6\\n7,0.7\\n8,0.8\\n9,0.9\\n0,0\\n1,0\\n2,0\\n3,0\\n4,0\\n5,0\\n6,0\\n7,0\\n8,0\\n9,0\");\n      Frame fr = ParseDataset2.parse(parsed, new Key[]{raw});\n      double [] powers = new double [] {1.5,1.1,1.9};\n      double [] intercepts = new double []{3.643,1.318,9.154};\n      double [] xs = new double []{-0.260,-0.0284,-0.853};\n      for(int i = 0; i < powers.length; ++i){\n        new GLM2(\"GLM test of gaussian(linear) regression.\",model,fr,false,Family.tweedie, Family.tweedie.defaultLink,0,0).setTweedieVarPower(powers[i]).fork().get();\n        GLMModel m = DKV.get(model).get();\n        HashMap<String, Double> coefs = m.coefficients();\n        assertEquals(intercepts[i],coefs.get(\"Intercept\"),1e-3);\n        assertEquals(xs[i],coefs.get(\"x\"),1e-3);\n      }\n    }finally{\n      UKV.remove(raw);\n      UKV.remove(parsed);\n      UKV.remove(model);\n    }\n  }","commit_id":"25e216b22030ad6bb9c4d083e029120fa0aaf46b","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public static  Key makeByteVec(Key k, String... data) {\n    byte [][] chunks = new byte[data.length][];\n    long [] espc = new long[data.length+1];\n    for(int i = 0; i < chunks.length; ++i){\n      chunks[i] = data[i].getBytes();\n      espc[i+1] = espc[i] + data[i].length();\n    }\n    Futures fs = new Futures();\n    ByteVec bv = new ByteVec(Vec.newKey(),espc);\n    Frame fr = new Frame(bv);\n    DKV.put(k, fr, fs);\n    for(int i = 0; i < chunks.length; ++i){\n      Key chunkKey = bv.chunkKey(i);\n      DKV.put(chunkKey, new Value(chunkKey,chunks[i].length,chunks[i],TypeMap.C1NCHUNK,Value.ICE));\n    }\n    fs.blockForPending();\n    return k;\n  }","id":40123,"modified_method":"public static  Key makeByteVec(Key k, String... data) {\n    byte [][] chunks = new byte[data.length][];\n    long [] espc = new long[data.length+1];\n    for(int i = 0; i < chunks.length; ++i){\n      chunks[i] = data[i].getBytes();\n      espc[i+1] = espc[i] + data[i].length();\n    }\n    Futures fs = new Futures();\n    ByteVec bv = new ByteVec(Vec.newKey(),espc);\n    for(int i = 0; i < chunks.length; ++i){\n      Key chunkKey = bv.chunkKey(i);\n      DKV.put(chunkKey, new Value(chunkKey,chunks[i].length,chunks[i],TypeMap.C1NCHUNK,Value.ICE),fs);\n    }\n    DKV.put(bv._key,bv,fs);\n    Frame fr = new Frame(bv);\n    DKV.put(k, fr, fs);\n    fs.blockForPending();\n    return k;\n  }","commit_id":"f2ed6d680802d9d4e8e03dc7aa0ea9c2fc695e56","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Frame( String[] names, Vec[] vecs ) { \n    _names=names; \n    _vecs=vecs; \n    _keys = new Key[_vecs.length];\n    for( int i=0; i<_vecs.length; i++ ) _keys[i] = _vecs[i]._key;\n  }","id":40124,"modified_method":"public Frame( String[] names, Vec[] vecs ) { \n    _names=names; \n    _vecs=vecs; \n    _keys = new Key[vecs.length];\n    for( int i=0; i<vecs.length; i++ ) {\n      Key k = _keys[i] = vecs[i]._key;\n      if( DKV.get(k)==null )    // If not already in KV, put it there\n        DKV.put(k,vecs[i]);\n    }\n  }","commit_id":"f2ed6d680802d9d4e8e03dc7aa0ea9c2fc695e56","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testGaussianRegression() throws InterruptedException, ExecutionException{\n   Key raw = Key.make(\"gaussian_test_data_raw\");\n   Key parsed = Key.make(\"gaussian_test_data_parsed\");\n   Key model = Key.make(\"gaussian_test\");\n   try {\n     // make data so that the expected coefficients is icept = col[0] = 1.0\n     Key k = FVecTest.makeByteVec(raw, \"x,y\\n0,0\\n1,0.1\\n2,0.2\\n3,0.3\\n4,0.4\\n5,0.5\\n6,0.6\\n7,0.7\\n8,0.8\\n9,0.9\");\n     Frame fr = ParseDataset2.parse(parsed, new Key[]{k});\n     new GLM2(\"GLM test of gaussian(linear) regression.\",model,fr,false,Family.gaussian, Family.gaussian.defaultLink,0,0).fork().get();\n     GLMModel m = DKV.get(model).get();\n     HashMap<String, Double> coefs = m.coefficients();\n     assertEquals(0.0,coefs.get(\"Intercept\"),1e-4);\n     assertEquals(0.1,coefs.get(\"x\"),1e-4);\n   }finally{\n     UKV.remove(raw);\n     UKV.remove(parsed);\n     UKV.remove(model);\n   }\n }","id":40125,"modified_method":"@Test public void testGaussianRegression() throws InterruptedException, ExecutionException{\n   Key raw = Key.make(\"gaussian_test_data_raw\");\n   Key parsed = Key.make(\"gaussian_test_data_parsed\");\n   Key model = Key.make(\"gaussian_test\");\n   try {\n     // make data so that the expected coefficients is icept = col[0] = 1.0\n     FVecTest.makeByteVec(raw, \"x,y\\n0,0\\n1,0.1\\n2,0.2\\n3,0.3\\n4,0.4\\n5,0.5\\n6,0.6\\n7,0.7\\n8,0.8\\n9,0.9\");\n     Frame fr = ParseDataset2.parse(parsed, new Key[]{raw});\n     new GLM2(\"GLM test of gaussian(linear) regression.\",model,fr,false,Family.gaussian, Family.gaussian.defaultLink,0,0).fork().get();\n     GLMModel m = DKV.get(model).get();\n     HashMap<String, Double> coefs = m.coefficients();\n     assertEquals(0.0,coefs.get(\"Intercept\"),1e-4);\n     assertEquals(0.1,coefs.get(\"x\"),1e-4);\n   }finally{\n     UKV.remove(raw);\n     UKV.remove(parsed);\n     UKV.remove(model);\n   }\n }","commit_id":"f2ed6d680802d9d4e8e03dc7aa0ea9c2fc695e56","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private static Frame getFrameForFile(Key outputKey, String path,String [] ignores, String response){\n    File f = TestUtil.find_test_file(path);\n    Key k = NFSFileVec.make(f);\n    try{\n      Frame fr = ParseDataset2.parse(outputKey, new Key[]{k});\n      if(ignores != null)\n        for(String s:ignores)fr.remove(s);\n      // put the response to the end\n      fr.add(response, fr.remove(response));\n      return GLMTask.adaptFrame(fr);\n    }finally{\n      UKV.remove(k);\n    }\n  }","id":40126,"modified_method":"private static Frame getFrameForFile(Key outputKey, String path,String [] ignores, String response){\n    File f = TestUtil.find_test_file(path);\n    Key k = NFSFileVec.make(f);\n    try{\n      Frame fr = ParseDataset2.parse(outputKey, new Key[]{k});\n      if(ignores != null)\n        for(String s:ignores) UKV.remove(fr.remove(s)._key);\n      // put the response to the end\n      fr.add(response, fr.remove(response));\n      return GLMTask.adaptFrame(fr);\n    }finally{\n      UKV.remove(k);\n    }\n  }","commit_id":"f2ed6d680802d9d4e8e03dc7aa0ea9c2fc695e56","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private NodeDelegate findByJcrUuid(Tree tree, String id) {\n        \n       try {\n           QueryManagerImpl qm = new QueryManagerImpl(this);\n           Query q = qm.createQuery(\"SELECT * FROM [nt:base] WHERE [jcr:uuid] = $id\", Query.JCR_SQL2);\n           q.bindValue(\"id\", getValueFactory().createValue(id));\n           \n           QueryResult result = q.execute();\n           RowIterator ri = result.getRows();\n           if (!ri.hasNext()) {\n               // not found\n               return null;\n           }\n                   \n           Row r = ri.nextRow();\n           \n           if (ri.hasNext()) {\n               log.error(\"multiple results for query \" + q.getStatement());\n               return null;\n           }\n           \n           String path = r.getNode().getPath();\n           String oakPath = namePathMapper.getOakPath(path);\n           return getNode(oakPath);\n       }\n       catch (RepositoryException ex) {\n           log.error(\"query failed\", ex);\n           return null;\n       }\n        \n//       PropertyState p = tree.getProperty(\"jcr:uuid\");\n//        if (p != null && id.equals(p.getValue().getString())) {\n//            return new NodeDelegate(this, tree);\n//        }\n//        else {\n//            for (Tree c : tree.getChildren()) {\n//                NodeDelegate found = findByJcrUuid(c, id);\n//                if (found != null) {\n//                    return found;\n//                }\n//            }\n//        }\n//\n//        return null;\n    }","id":40127,"modified_method":"@CheckForNull\n    NodeDelegate findByJcrUuid(Tree tree, String id) {\n\n        try {\n            Map<String, CoreValue> bindings = Collections.singletonMap(\"id\", getValueFactory().getCoreValueFactory()\n                    .createValue(id));\n\n            Result result = getQueryEngine().executeQuery(\"SELECT * FROM [nt:base] WHERE [jcr:uuid] = $id\", Query.JCR_SQL2,\n                    getContentSession(), Long.MAX_VALUE, 0, bindings);\n\n            String path = null;\n\n            for (ResultRow rr : result.getRows()) {\n                String tmppath = PathUtils.concat(\"/\", PathUtils.relativize(\"/\" + getWorkspaceName(), rr.getPath()));\n\n                if (path != null) {\n                    log.error(\"multiple results for identifier lookup: \" + path + \" vs. \" + tmppath);\n                    return null;\n                } else {\n                    path = tmppath;\n                }\n            }\n\n            return path == null ? null : getNode(path);\n        } catch (ParseException ex) {\n            log.error(\"query failed\", ex);\n            return null;\n        }\n\n        // Tree-walking implementation...\n        // PropertyState p = tree.getProperty(\"jcr:uuid\");\n        // if (p != null && id.equals(p.getValue().getString())) {\n        // return new NodeDelegate(this, tree);\n        // }\n        // else {\n        // for (Tree c : tree.getChildren()) {\n        // NodeDelegate found = findByJcrUuid(c, id);\n        // if (found != null) {\n        // return found;\n        // }\n        // }\n        // }\n        //\n        // return null;\n    }","commit_id":"6da3120d7abcd83040c632a7b6794518b08e4439","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeType getDeclaringNodeType() {\n        return type;\n    }","id":40128,"modified_method":"@Override\n    public NodeType getDeclaringNodeType() {\n        return new NodeTypeImpl(definition.getParent(), factory, mapper);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getName() {\n        return node.getName(JcrConstants.JCR_NAME, NodeTypeConstants.RESIDUAL_NAME);\n    }","id":40129,"modified_method":"@Override\n    public String getName() {\n        String oakName = getName(JcrConstants.JCR_NAME);\n        if (oakName != null) {\n            return mapper.getJcrName(oakName);\n        } else {\n            return NodeTypeConstants.RESIDUAL_NAME;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public int getOnParentVersion() {\n        try {\n            return OnParentVersionAction.valueFromName(node.getString(\n                    \"jcr:onParentVersion\",\n                    OnParentVersionAction.ACTIONNAME_COPY));\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Unexpected jcr:onParentVersion value\", e);\n            return OnParentVersionAction.COPY;\n        }\n    }","id":40130,"modified_method":"@Override\n    public int getOnParentVersion() {\n        String action = getString(JcrConstants.JCR_ONPARENTVERSION);\n        if (action != null) {\n            return OnParentVersionAction.valueFromName(action);\n        } else {\n            return OnParentVersionAction.COPY;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isMandatory() {\n        return node.getBoolean(JcrConstants.JCR_MANDATORY);\n    }","id":40131,"modified_method":"@Override\n    public boolean isMandatory() {\n        return getBoolean(JcrConstants.JCR_MANDATORY);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isAutoCreated() {\n        return node.getBoolean(JcrConstants.JCR_AUTOCREATED);\n    }","id":40132,"modified_method":"@Override\n    public boolean isAutoCreated() {\n        return getBoolean(JcrConstants.JCR_AUTOCREATED);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isProtected() {\n        return node.getBoolean(JcrConstants.JCR_PROTECTED);\n    }","id":40133,"modified_method":"@Override\n    public boolean isProtected() {\n        return getBoolean(JcrConstants.JCR_PROTECTED);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"String getOakName() {\n        return node.getString(JcrConstants.JCR_NAME, NodeTypeConstants.RESIDUAL_NAME);\n    }","id":40134,"modified_method":"String getOakName() {\n        String oakName = getName(JcrConstants.JCR_NAME);\n        if (oakName == null) {\n            oakName = NodeTypeConstants.RESIDUAL_NAME;\n        }\n        return oakName;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getDefaultPrimaryTypeName() {\n        return node.getName(JcrConstants.JCR_DEFAULTPRIMARYTYPE, null);\n    }","id":40135,"modified_method":"@Override\n    public String getDefaultPrimaryTypeName() {\n        String oakName = getName(JcrConstants.JCR_DEFAULTPRIMARYTYPE);\n        if (oakName != null) {\n            return mapper.getJcrName(oakName);\n        } else {\n            return null;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeType getDefaultPrimaryType() {\n        String name = getDefaultPrimaryTypeName();\n        if (name != null) {\n            try {\n                return manager.getNodeType(name);\n            } catch (RepositoryException e) {\n                log.warn(\"Unable to access default primary type \"\n                        + name + \" of node \" + getName(), e);\n            }\n        }\n        return null;\n    }","id":40136,"modified_method":"@Override\n    public NodeType getDefaultPrimaryType() {\n        String oakName = getName(JcrConstants.JCR_DEFAULTPRIMARYTYPE);\n        if (oakName != null) {\n            Tree root = definition.getParent().getParent();\n            Tree type = root.getChild(oakName);\n            checkState(type != null);\n            return new NodeTypeImpl(type, factory, mapper);\n        } else {\n            return null;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeType[] getRequiredPrimaryTypes() {\n        String[] names = getRequiredPrimaryTypeNames();\n        List<NodeType> types = new ArrayList<NodeType>(names.length);\n        for (String name : names) {\n            try {\n                types.add(manager.getNodeType(name));\n            } catch (RepositoryException e) {\n                log.warn(\"Unable to access required primary type \"\n                        + name + \" of node \" + getName(), e);\n            }\n        }\n        return types.toArray(new NodeType[types.size()]);\n    }","id":40137,"modified_method":"@Override\n    public NodeType[] getRequiredPrimaryTypes() {\n        String[] oakNames = getNames(JcrConstants.JCR_REQUIREDPRIMARYTYPES);\n        if (oakNames == null) {\n            oakNames = new String[] { JcrConstants.NT_BASE };\n        }\n\n        NodeType[] types = new NodeType[oakNames.length];\n        Tree root = definition.getParent().getParent();\n        for (int i = 0; i < oakNames.length; i++) {\n            Tree type = root.getChild(oakNames[i]);\n            checkState(type != null);\n            types[i] = new NodeTypeImpl(type, factory, mapper);\n        }\n        return types;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getRequiredPrimaryTypeNames() {\n        return node.getNames(JcrConstants.JCR_REQUIREDPRIMARYTYPES, JcrConstants.NT_BASE);\n    }","id":40138,"modified_method":"@Override\n    public String[] getRequiredPrimaryTypeNames() {\n        String[] names = getNames(JcrConstants.JCR_REQUIREDPRIMARYTYPES);\n        if (names == null) {\n            names = new String[] { JcrConstants.NT_BASE };\n        }\n        for (int i = 0; i < names.length; i++) {\n            names[i] = mapper.getJcrName(names[i]);\n        }\n        return names;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean allowsSameNameSiblings() {\n        return node.getBoolean(JcrConstants.JCR_SAMENAMESIBLINGS);\n    }","id":40139,"modified_method":"@Override\n    public boolean allowsSameNameSiblings() {\n        return getBoolean(JcrConstants.JCR_SAMENAMESIBLINGS);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeTypeImpl(ReadOnlyNodeTypeManager manager, ValueFactory factory, NodeUtil node) {\n        this.manager = manager;\n        this.factory = factory;\n        this.node = node;\n    }","id":40140,"modified_method":"NodeTypeImpl(Tree type, ValueFactory factory, NamePathMapper mapper) {\n        super(type, factory, mapper);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeType[] getSupertypes() {\n        Collection<NodeType> types = new ArrayList<NodeType>();\n        Set<String> added = new HashSet<String>();\n        Queue<String> queue = new LinkedList<String>(Arrays.asList(getDeclaredSupertypeNames()));\n        while (!queue.isEmpty()) {\n            String name = queue.remove();\n            if (added.add(name)) {\n                try {\n                    NodeType type = manager.getNodeType(name);\n                    types.add(type);\n                    queue.addAll(Arrays.asList(type.getDeclaredSupertypeNames()));\n                } catch (RepositoryException e) {\n                    throw new IllegalStateException(\"Inconsistent node type: \" + this, e);\n                }\n            }\n        }\n        return types.toArray(new NodeType[types.size()]);\n    }","id":40141,"modified_method":"@Override\n    public NodeType[] getSupertypes() {\n        Map<String, NodeType> supertypes = Maps.newLinkedHashMap();\n        addSupertypes(definition, supertypes);\n        return supertypes.values().toArray(NO_NODE_TYPES);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getName() {\n        String name = node.getName(JCR_NODETYPENAME);\n        if (name == null) {\n            name = node.getName();\n        }\n        return name;\n    }","id":40142,"modified_method":"@Override\n    public String getName() {\n        return mapper.getJcrName(getOakName());\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isAbstract() {\n        return node.getBoolean(JCR_IS_ABSTRACT);\n    }","id":40143,"modified_method":"@Override\n    public boolean isAbstract() {\n        return getBoolean(JCR_IS_ABSTRACT);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isNodeType(String nodeTypeName) {\n        String oakName = node.getNameMapper().getOakNameOrNull(nodeTypeName);\n        return internalIsNodeType(oakName);\n    }","id":40144,"modified_method":"@Override\n    public boolean isNodeType(String nodeTypeName) {\n        String oakName = mapper.getOakNameOrNull(nodeTypeName);\n        return internalIsNodeType(oakName);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public PropertyDefinition[] getDeclaredPropertyDefinitions() {\n        List<NodeUtil> nodes = node.getNodes(JCR_PROPERTYDEFINITION);\n        PropertyDefinition[] definitions = new PropertyDefinition[nodes.size()];\n        for (int i = 0; i < nodes.size(); i++) {\n            definitions[i] = new PropertyDefinitionImpl(\n                    this, factory, nodes.get(i));\n        }\n        return definitions;\n    }","id":40145,"modified_method":"@Override\n    public PropertyDefinition[] getDeclaredPropertyDefinitions() {\n        List<PropertyDefinition> definitions = Lists.newArrayList();\n        for (Tree child : definition.getChildren()) {\n            if (child.getName().startsWith(JCR_PROPERTYDEFINITION)) {\n                definitions.add(\n                        new PropertyDefinitionImpl(child, factory, mapper));\n            }\n        }\n        return definitions.toArray(NO_PROPERTY_DEFINITIONS);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean hasOrderableChildNodes() {\n        return node.getBoolean(JCR_HASORDERABLECHILDNODES);\n    }","id":40146,"modified_method":"@Override\n    public boolean hasOrderableChildNodes() {\n        return getBoolean(JCR_HASORDERABLECHILDNODES);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getDeclaredSupertypeNames() {\n        return node.getNames(JCR_SUPERTYPES);\n    }","id":40147,"modified_method":"@Override\n    public String[] getDeclaredSupertypeNames() {\n        String[] names = getNames(JCR_SUPERTYPES);\n        if (names != null) {\n            for (int i = 0; i < names.length; i++) {\n                names[i] = mapper.getJcrName(names[i]);\n            }\n        } else {\n            names = NO_NAMES;\n        }\n        return names;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean canSetProperty(String propertyName, Value value) {\n        if (value == null) {\n            return canRemoveProperty(propertyName);\n        }\n\n        try {\n            Iterable<NodeType> nts = Collections.singleton((NodeType) this);\n            PropertyDefinition def = manager.getDefinition(nts, propertyName, false, value.getType(), false);\n            return !def.isProtected() &&\n                    meetsTypeConstraints(value, def.getRequiredType()) &&\n                    meetsValueConstraints(value, def.getValueConstraints());\n        } catch (RepositoryException e) {  // TODO don't use exceptions for flow control. Use internal method in ReadOnlyNodeTypeManager instead.\n            log.debug(e.getMessage());\n            return false;\n        }\n    }","id":40148,"modified_method":"@Override\n    public boolean canSetProperty(String propertyName, Value value) {\n        if (value == null) {\n            return canRemoveProperty(propertyName);\n        }\n\n        try {\n            Iterable<NodeType> nts = Collections.singleton((NodeType) this);\n            PropertyDefinition def = getManager().getDefinition(nts, propertyName, false, value.getType(), false);\n            return !def.isProtected() &&\n                    meetsTypeConstraints(value, def.getRequiredType()) &&\n                    meetsValueConstraints(value, def.getValueConstraints());\n        } catch (RepositoryException e) {  // TODO don't use exceptions for flow control. Use internal method in ReadOnlyNodeTypeManager instead.\n            log.debug(e.getMessage());\n            return false;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeTypeIterator getDeclaredSubtypes() {\n        Collection<NodeType> types = new ArrayList<NodeType>();\n        try {\n            NodeTypeIterator iterator = manager.getAllNodeTypes();\n            while (iterator.hasNext()) {\n                NodeType type = iterator.nextNodeType();\n                String name = type.getName();\n                if (type.isNodeType(getName()) && !isNodeType(name)) {\n                    List<String> declaredSuperTypeNames = Arrays.asList(type.getDeclaredSupertypeNames());\n                    if (declaredSuperTypeNames.contains(name)) {\n                        types.add(type);\n                    }\n                }\n            }\n        } catch (RepositoryException e) {\n            log.warn(\"Unable to access declared subtypes of \" + getName(), e);\n        }\n        return new NodeTypeIteratorAdapter(types);\n    }","id":40149,"modified_method":"@Override\n    public NodeTypeIterator getDeclaredSubtypes() {\n        List<NodeType> subtypes = Lists.newArrayList();\n\n        String oakName = getOakName();\n        Tree root = definition.getParent();\n        for (Tree child : root.getChildren()) {\n            PropertyState supertypes = child.getProperty(JCR_SUPERTYPES);\n            if (supertypes != null) {\n                for (String name : supertypes.getValue(Type.NAMES)) {\n                    if (oakName.equals(name)) {\n                        subtypes.add(new NodeTypeImpl(child, factory, mapper));\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new NodeTypeIteratorAdapter(subtypes);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeType[] getDeclaredSupertypes() {\n        String[] names = getDeclaredSupertypeNames();\n        List<NodeType> types = new ArrayList<NodeType>(names.length);\n        for (String name : names) {\n            try {\n                NodeType type = manager.getNodeType(name);\n                types.add(type);\n            }\n            catch (RepositoryException e) {\n                log.warn(\"Unable to access declared supertype \"\n                        + name + \" of \" + getName(), e);\n            }\n        }\n        return types.toArray(new NodeType[types.size()]);\n    }","id":40150,"modified_method":"@Override\n    public NodeType[] getDeclaredSupertypes() {\n        NodeType[] supertypes = NO_NODE_TYPES;\n        String[] oakNames = getNames(JCR_SUPERTYPES);\n        if (oakNames != null && oakNames.length > 0) {\n            supertypes = new NodeType[oakNames.length];\n            Tree root = definition.getParent();\n            for (int i = 0; i < oakNames.length; i++) {\n                Tree type = root.getChild(oakNames[i]);\n                checkState(type != null);\n                supertypes[i] = new NodeTypeImpl(type, factory, mapper);\n            }\n        }\n        return supertypes;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isMixin() {\n        return node.getBoolean(JCR_ISMIXIN);\n    }","id":40151,"modified_method":"@Override\n    public boolean isMixin() {\n        return getBoolean(JCR_ISMIXIN);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeDefinition[] getDeclaredChildNodeDefinitions() {\n        List<NodeUtil> nodes = node.getNodes(JCR_CHILDNODEDEFINITION);\n        NodeDefinition[] definitions = new NodeDefinition[nodes.size()];\n        for (int i = 0; i < nodes.size(); i++) {\n            definitions[i] = new NodeDefinitionImpl(manager, this, nodes.get(i));\n        }\n        return definitions;\n    }","id":40152,"modified_method":"@Override\n    public NodeDefinition[] getDeclaredChildNodeDefinitions() {\n        List<NodeDefinition> definitions = Lists.newArrayList();\n        for (Tree child : definition.getChildren()) {\n            if (child.getName().startsWith(JCR_CHILDNODEDEFINITION)) {\n                definitions.add(\n                        new NodeDefinitionImpl(child, factory, mapper));\n            }\n        }\n        return definitions.toArray(NO_NODE_DEFINITIONS);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"String getOakName() {\n        return node.getTree().getName();\n    }","id":40153,"modified_method":"private String getOakName() {\n        return getOakName(definition);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean canAddChildNode(String childNodeName, String nodeTypeName) {\n        NodeType type;\n        try {\n            type = manager.getNodeType(nodeTypeName);\n            if (type.isAbstract()) {\n                return false;\n            }\n        } catch (NoSuchNodeTypeException e) {\n            return false;\n        } catch (RepositoryException e) {\n            log.warn(\"Unable to access node type \" + nodeTypeName, e);\n            return false;\n        }\n        // FIXME: properly calculate matching definition\n        for (NodeDefinition definition : getChildNodeDefinitions()) {\n            String name = definition.getName();\n            if (matches(childNodeName, name) || RESIDUAL_NAME.equals(name)) {\n                if (definition.isProtected()) {\n                    return false;\n                }\n                for (String required : definition.getRequiredPrimaryTypeNames()) {\n                    if (type.isNodeType(required)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":40154,"modified_method":"@Override\n    public boolean canAddChildNode(String childNodeName, String nodeTypeName) {\n        NodeType type;\n        try {\n            type = getManager().getNodeType(nodeTypeName);\n            if (type.isAbstract()) {\n                return false;\n            }\n        } catch (NoSuchNodeTypeException e) {\n            return false;\n        } catch (RepositoryException e) {\n            log.warn(\"Unable to access node type \" + nodeTypeName, e);\n            return false;\n        }\n        // FIXME: properly calculate matching definition\n        for (NodeDefinition definition : getChildNodeDefinitions()) {\n            String name = definition.getName();\n            if (matches(childNodeName, name) || RESIDUAL_NAME.equals(name)) {\n                if (definition.isProtected()) {\n                    return false;\n                }\n                for (String required : definition.getRequiredPrimaryTypeNames()) {\n                    if (type.isNodeType(required)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean canSetProperty(String propertyName, Value[] values) {\n        if (values == null) {\n            return canRemoveProperty(propertyName);\n        }\n\n        try {\n            Iterable<NodeType> nts = Collections.singleton((NodeType) this);\n            int type = (values.length == 0) ? PropertyType.STRING : values[0].getType();\n            PropertyDefinition def = manager.getDefinition(nts, propertyName, true, type, false);\n            return !def.isProtected() &&\n                    meetsTypeConstraints(values, def.getRequiredType()) &&\n                    meetsValueConstraints(values, def.getValueConstraints());\n        } catch (RepositoryException e) {  // TODO don't use exceptions for flow control. Use internal method in ReadOnlyNodeTypeManager instead.\n            log.debug(e.getMessage());\n            return false;\n        }\n    }","id":40155,"modified_method":"@Override\n    public boolean canSetProperty(String propertyName, Value[] values) {\n        if (values == null) {\n            return canRemoveProperty(propertyName);\n        }\n\n        try {\n            Iterable<NodeType> nts = Collections.singleton((NodeType) this);\n            int type = (values.length == 0) ? PropertyType.STRING : values[0].getType();\n            PropertyDefinition def = getManager().getDefinition(nts, propertyName, true, type, false);\n            return !def.isProtected() &&\n                    meetsTypeConstraints(values, def.getRequiredType()) &&\n                    meetsValueConstraints(values, def.getValueConstraints());\n        } catch (RepositoryException e) {  // TODO don't use exceptions for flow control. Use internal method in ReadOnlyNodeTypeManager instead.\n            log.debug(e.getMessage());\n            return false;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getPrimaryItemName() {\n        return node.getName(JCR_PRIMARYITEMNAME);\n    }","id":40156,"modified_method":"@Override\n    public String getPrimaryItemName() {\n        String oakName = getName(JCR_PRIMARYITEMNAME);\n        if (oakName != null) {\n            return mapper.getJcrName(oakName);\n        } else {\n            return null;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isQueryable() {\n        return node.getBoolean(JCR_IS_QUERYABLE);\n    }","id":40157,"modified_method":"@Override\n    public boolean isQueryable() {\n        return getBoolean(JCR_IS_QUERYABLE);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeTypeIterator getSubtypes() {\n        Collection<NodeType> types = new ArrayList<NodeType>();\n        try {\n            NodeTypeIterator iterator = manager.getAllNodeTypes();\n            while (iterator.hasNext()) {\n                NodeType type = iterator.nextNodeType();\n                if (type.isNodeType(getName()) && !isNodeType(type.getName())) {\n                    types.add(type);\n                }\n            }\n        } catch (RepositoryException e) {\n            log.warn(\"Unable to access subtypes of \" + getName(), e);\n        }\n        return new NodeTypeIteratorAdapter(types);\n    }","id":40158,"modified_method":"@Override\n    public NodeTypeIterator getSubtypes() {\n        Map<String, Set<String>> inheritance = Maps.newHashMap();\n        \n        Tree root = definition.getParent();\n        for (Tree child : root.getChildren()) {\n            String oakName = getOakName(child);\n            PropertyState supertypes = child.getProperty(JCR_SUPERTYPES);\n            if (supertypes != null) {\n                for (String supername : supertypes.getValue(Type.NAMES)) {\n                    Set<String> subtypes = inheritance.get(supername);\n                    if (subtypes == null) {\n                        subtypes = Sets.newHashSet();\n                        inheritance.put(supername, subtypes);\n                    }\n                    subtypes.add(oakName);\n                }\n            }\n        }\n\n        Map<String, NodeType> subtypes = Maps.newHashMap();\n        addSubtypes(getOakName(), subtypes, root, inheritance);\n        return new NodeTypeIteratorAdapter(subtypes.values());\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean matches(String childNodeName, String name) {\n        String oakChildName = node.getNameMapper().getOakNameOrNull(childNodeName);\n        String oakName = node.getNameMapper().getOakNameOrNull(name);\n        // TODO need a better way to handle SNS\n        return oakChildName != null && oakChildName.startsWith(oakName);\n    }","id":40159,"modified_method":"private boolean matches(String childNodeName, String name) {\n        String oakChildName = mapper.getOakNameOrNull(childNodeName);\n        String oakName = mapper.getOakNameOrNull(name);\n        // TODO need a better way to handle SNS\n        return oakChildName != null && oakChildName.startsWith(oakName);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getAvailableQueryOperators() {\n        String[] ops = node.getStrings(NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS);\n        if (ops == null) {\n            ops = new String[] {\n                    QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LIKE };\n        }\n        return ops;\n    }","id":40160,"modified_method":"@Override\n    public String[] getAvailableQueryOperators() {\n        String[] operators =\n                getStrings(NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS);\n        if (operators == null) {\n            operators = new String[] {\n                    QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN,\n                    QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO,\n                    QueryObjectModelConstants.JCR_OPERATOR_LIKE };\n        }\n        return operators;\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public PropertyDefinitionImpl(NodeType type, ValueFactory factory, NodeUtil node) {\n        super(type, node);\n        this.factory = factory;\n    }","id":40161,"modified_method":"public PropertyDefinitionImpl(\n            Tree definition, ValueFactory factory, NamePathMapper mapper) {\n        super(definition, factory, mapper);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String[] getValueConstraints() {\n        // TODO: namespace mapping?\n        String[] constraints = node.getStrings(JcrConstants.JCR_VALUECONSTRAINTS);\n        if (constraints == null) {\n            constraints = new String[0];\n        }\n        return constraints;\n    }","id":40162,"modified_method":"@Override\n    public String[] getValueConstraints() {\n        // TODO: namespace mapping?\n        return getStrings(JcrConstants.JCR_VALUECONSTRAINTS);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isFullTextSearchable() {\n        return node.getBoolean(NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE);\n    }","id":40163,"modified_method":"@Override\n    public boolean isFullTextSearchable() {\n        return getBoolean(NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isMultiple() {\n        return node.getBoolean(JcrConstants.JCR_MULTIPLE);\n    }","id":40164,"modified_method":"@Override\n    public boolean isMultiple() {\n        return getBoolean(JcrConstants.JCR_MULTIPLE);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns the numeric constant value of the type with the specified name.\n     *\n     * In contrast to {@link javax.jcr.PropertyType#valueFromName(String)} this method\n     * requires all type names to be all upper case.\n     * See also: OAK-294 and http://java.net/jira/browse/JSR_283-811\n     *\n     * @param name the name of the property type.\n     * @return the numeric constant value.\n     * @throws IllegalArgumentException if {@code name} is not a valid property type name.\n     */\n    public static int valueFromName(String name) {\n        if (name.equals(TYPENAME_STRING.toUpperCase())) {\n            return STRING;\n        } else if (name.equals(TYPENAME_BINARY.toUpperCase())) {\n            return BINARY;\n        } else if (name.equals(TYPENAME_BOOLEAN.toUpperCase())) {\n            return BOOLEAN;\n        } else if (name.equals(TYPENAME_LONG.toUpperCase())) {\n            return LONG;\n        } else if (name.equals(TYPENAME_DOUBLE.toUpperCase())) {\n            return DOUBLE;\n        } else if (name.equals(TYPENAME_DECIMAL.toUpperCase())) {\n            return DECIMAL;\n        } else if (name.equals(TYPENAME_DATE.toUpperCase())) {\n            return DATE;\n        } else if (name.equals(TYPENAME_NAME.toUpperCase())) {\n            return NAME;\n        } else if (name.equals(TYPENAME_PATH.toUpperCase())) {\n            return PATH;\n        } else if (name.equals(TYPENAME_REFERENCE.toUpperCase())) {\n            return REFERENCE;\n        } else if (name.equals(TYPENAME_WEAKREFERENCE.toUpperCase())) {\n            return WEAKREFERENCE;\n        } else if (name.equals(TYPENAME_URI.toUpperCase())) {\n            return URI;\n        } else if (name.equals(TYPENAME_UNDEFINED.toUpperCase())) {\n            return UNDEFINED;\n        } else {\n            throw new IllegalArgumentException(\"unknown type: \" + name);\n        }\n    }","id":40165,"modified_method":"/**\n     * Returns the numeric constant value of the type with the specified name.\n     *\n     * In contrast to {@link javax.jcr.PropertyType#valueFromName(String)} this method\n     * requires all type names to be all upper case.\n     * See also: OAK-294 and http://java.net/jira/browse/JSR_283-811\n     *\n     * @param name the name of the property type.\n     * @return the numeric constant value.\n     * @throws IllegalStateException if {@code name} is not a valid property type name.\n     */\n    public static int valueFromName(String name) {\n        if (\"STRING\".equals(name)) {\n            return STRING;\n        } else if (\"BINARY\".equals(name)) {\n            return BINARY;\n        } else if (\"BOOLEAN\".equals(name)) {\n            return BOOLEAN;\n        } else if (\"LONG\".equals(name)) {\n            return LONG;\n        } else if (\"DOUBLE\".equals(name)) {\n            return DOUBLE;\n        } else if (\"DECIMAL\".equals(name)) {\n            return DECIMAL;\n        } else if (\"DATE\".equals(name)) {\n            return DATE;\n        } else if (\"NAME\".equals(name)) {\n            return NAME;\n        } else if (\"PATH\".equals(name)) {\n            return PATH;\n        } else if (\"REFERENCE\".equals(name)) {\n            return REFERENCE;\n        } else if (\"WEAKREFERENCE\".equals(name)) {\n            return WEAKREFERENCE;\n        } else if (\"URI\".equals(name)) {\n            return URI;\n        } else if (\"UNDEFINED\".equals(name)) {\n            return UNDEFINED;\n        } else {\n            throw new IllegalStateException(\"unknown property type: \" + name);\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Value[] getDefaultValues() {\n        if (factory != null) {\n            return node.getValues(JcrConstants.JCR_DEFAULTVALUES, factory);\n        } else {\n            log.warn(\"Cannot create default values: no value factory\");\n            return null;\n        }\n    }","id":40166,"modified_method":"@Override\n    public Value[] getDefaultValues() {\n        PropertyState property =\n                definition.getProperty(JcrConstants.JCR_DEFAULTVALUES);\n        if (property == null) {\n            return null;\n        } else if (property.isArray()) {\n            List<Value> values = ValueFactoryImpl.createValues(property, mapper);\n            return values.toArray(NO_VALUES);\n        } else {\n            Value value = ValueFactoryImpl.createValue(property, mapper);\n            return new Value[] { value };\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isQueryOrderable() {\n        return node.getBoolean(NodeTypeConstants.JCR_IS_QUERY_ORDERABLE);\n    }","id":40167,"modified_method":"@Override\n    public boolean isQueryOrderable() {\n        return getBoolean(NodeTypeConstants.JCR_IS_QUERY_ORDERABLE);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public int getRequiredType() {\n        try {\n            return valueFromName(node.getString(JcrConstants.JCR_REQUIREDTYPE, TYPENAME_UNDEFINED));\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Unexpected jcr:requiredType value\", e);\n            return UNDEFINED;\n        }\n    }","id":40168,"modified_method":"@Override\n    public int getRequiredType() {\n        String string = getString(JcrConstants.JCR_REQUIREDTYPE);\n        if (string != null) {\n            return valueFromName(string);\n        } else {\n            return UNDEFINED;\n        }\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"NodeTypeImpl internalGetNodeType(String oakName) throws NoSuchNodeTypeException {\n        Tree types = getTypes();\n        if (types != null) {\n            Tree type = types.getChild(oakName);\n            if (type != null) {\n                return new NodeTypeImpl(this, getValueFactory(), new NodeUtil(type, getNamePathMapper()));\n            }\n        }\n        throw new NoSuchNodeTypeException(getNamePathMapper().getJcrName(oakName));\n    }","id":40169,"modified_method":"NodeTypeImpl internalGetNodeType(String oakName) throws NoSuchNodeTypeException {\n        ValueFactory factory = getValueFactory();\n        NamePathMapper mapper = getNamePathMapper();\n\n        Tree types = getTypes();\n        if (types != null) {\n            Tree type = types.getChild(oakName);\n            if (type != null) {\n                return new NodeTypeImpl(type, factory, mapper);\n            }\n        }\n        throw new NoSuchNodeTypeException(mapper.getJcrName(oakName));\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeTypeIterator getAllNodeTypes() throws RepositoryException {\n        List<NodeType> list = Lists.newArrayList();\n        Tree types = getTypes();\n        if (types != null) {\n            for (Tree type : types.getChildren()) {\n                list.add(new NodeTypeImpl(this, getValueFactory(),\n                        new NodeUtil(type, getNamePathMapper())));\n\n            }\n        }\n        return new NodeTypeIteratorAdapter(list);\n    }","id":40170,"modified_method":"@Override\n    public NodeTypeIterator getAllNodeTypes() throws RepositoryException {\n        List<NodeType> list = Lists.newArrayList();\n        Tree types = getTypes();\n        if (types != null) {\n            ValueFactory factory = getValueFactory();\n            NamePathMapper mapper = getNamePathMapper();\n            for (Tree type : types.getChildren()) {\n                list.add(new NodeTypeImpl(type, factory, mapper));\n            }\n        }\n        return new NodeTypeIteratorAdapter(list);\n    }","commit_id":"d82e4ceb7a6dae19b3da314314e7eb05acfc8b75","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void handleGroup(PipelineContext pipelineContext, GroupContext groupContext, List<Element> statements, FunctionLibrary functionLibrary, PdfReader reader) throws DocumentException, IOException {\n\n        final NodeInfo contextNode = (NodeInfo) groupContext.contextNodeSet.get(groupContext.contextPosition - 1);\n        final Map<String, ValueRepresentation> variableToValueMap = new HashMap<String, ValueRepresentation>();\n\n\n        variableToValueMap.put(\"page-count\", new Int64Value(reader.getNumberOfPages()));\n        variableToValueMap.put(\"page-number\", new Int64Value(groupContext.pageNumber));\n        variableToValueMap.put(\"page-height\", new FloatValue(groupContext.pageHeight));\n\n        // Iterate through statements\n        for (final Element currentElement: statements) {\n\n            // Check whether this statement applies to the current page\n            final String elementPage = currentElement.attributeValue(\"page\");\n            if ((elementPage != null) && !Integer.toString(groupContext.pageNumber).equals(elementPage))\n                continue;\n\n            final NamespaceMapping namespaceMapping = new NamespaceMapping(Dom4jUtils.getNamespaceContextNoDefault(currentElement));\n\n            final String elementName = currentElement.getName();\n            if (elementName.equals(\"group\")) {\n                // Handle group\n\n                final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                final String ref = currentElement.attributeValue(\"ref\");\n                if (ref != null) {\n                    final NodeInfo newContextNode = (NodeInfo) XPathCache.evaluateSingle(groupContext.contextNodeSet, groupContext.contextPosition, ref, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                    if (newContextNode == null)\n                        continue;\n\n                    newGroupContext.contextNodeSet = Collections.singletonList((Item) newContextNode);\n                    newGroupContext.contextPosition = 1;\n                }\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                if (offsetXString != null) {\n                    newGroupContext.offsetX = groupContext.offsetX + Float.parseFloat(offsetXString);\n                }\n\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                if (offsetYString != null) {\n                    newGroupContext.offsetY = groupContext.offsetY + Float.parseFloat(offsetYString);\n                }\n\n                final String fontPitch = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-pitch\"));\n                if (fontPitch != null)\n                    newGroupContext.fontPitch = Float.parseFloat(fontPitch);\n\n                final String fontFamily = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-family\"));\n                if (fontFamily != null)\n                    newGroupContext.fontFamily = fontFamily;\n\n                final String fontSize = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-size\"));\n                if (fontSize != null)\n                    newGroupContext.fontSize = Float.parseFloat(fontSize);\n\n                handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n\n            } else if (elementName.equals(\"repeat\")) {\n                // Handle repeat\n\n                final String nodeset = currentElement.attributeValue(\"nodeset\");\n                final List iterations = XPathCache.evaluate(groupContext.contextNodeSet, groupContext.contextPosition, nodeset, namespaceMapping,\n                        variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                final float offsetIncrementX = (offsetXString == null) ? 0 : Float.parseFloat(offsetXString);\n                final float offsetIncrementY = (offsetYString == null) ? 0 : Float.parseFloat(offsetYString);\n\n                for (int iterationIndex = 1; iterationIndex <= iterations.size(); iterationIndex++) {\n\n                    final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                    newGroupContext.contextNodeSet = iterations;\n                    newGroupContext.contextPosition = iterationIndex;\n\n                    newGroupContext.offsetX = groupContext.offsetX + (iterationIndex - 1) * offsetIncrementX;\n                    newGroupContext.offsetY = groupContext.offsetY + (iterationIndex - 1) * offsetIncrementY;\n\n                    handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n                }\n            } else if (elementName.equals(\"field\")) {\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n\n                if (fieldNameStr != null) {\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                    // Get value from instance\n\n                    final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    groupContext.acroFields.setField(fieldName, text);\n\n                } else {\n                    // Handle field\n\n                    final String leftAttribute = currentElement.attributeValue(\"left\") == null ? currentElement.attributeValue(\"left-position\") : currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\") == null ? currentElement.attributeValue(\"top-position\") : currentElement.attributeValue(\"top\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n\n                    final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n\n                    // Output value\n                    final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n                    groupContext.contentByte.beginText();\n                    {\n                        groupContext.contentByte.setFontAndSize(baseFont, fontAttributes.fontSize);\n\n                        final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                        final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                        // Get value from instance\n                        final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                        // Iterate over characters and print them\n                        if (text != null) {\n                            int len = Math.min(text.length(), (size != null) ? Integer.parseInt(size) : Integer.MAX_VALUE);\n                            for (int j = 0; j < len; j++)\n                                groupContext.contentByte.showTextAligned(PdfContentByte.ALIGN_CENTER, text.substring(j, j + 1), xPosition + ((float) j) * fontAttributes.fontPitch, yPosition, 0);\n                        }\n                    }\n                    groupContext.contentByte.endText();\n                }\n            } else if (elementName.equals(\"barcode\")) {\n                // Handle barcode\n\n                final String leftAttribute = currentElement.attributeValue(\"left\");\n                final String topAttribute = currentElement.attributeValue(\"top\");\n\n                final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n//                final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                final String type = currentElement.attributeValue(\"type\") == null ? \"CODE39\" : currentElement.attributeValue(\"type\");\n                final float height = currentElement.attributeValue(\"height\") == null ? 10.0f : Float.parseFloat(currentElement.attributeValue(\"height\"));\n\n                final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n                final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n                final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n\n                final Barcode barcode = createBarCode(type);\n                barcode.setCode(text);\n                barcode.setBarHeight(height);\n                barcode.setFont(baseFont);\n                barcode.setSize(fontAttributes.fontSize);\n                final Image barcodeImage = barcode.createImageWithBarcode(groupContext.contentByte, null, null);\n                barcodeImage.setAbsolutePosition(xPosition, yPosition);\n                groupContext.contentByte.addImage(barcodeImage);\n            } else if (elementName.equals(\"image\")) {\n                // Handle image\n\n                final String leftAttribute = currentElement.attributeValue(\"left\");\n                final String topAttribute = currentElement.attributeValue(\"top\");\n                final String scalePercentAttribute = currentElement.attributeValue(\"scale-percent\");\n                final String dpiAttribute = currentElement.attributeValue(\"dpi\");\n\n                final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n                final String scalePercent = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, scalePercentAttribute);\n                final String dpi = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, dpiAttribute);\n\n                final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                final String hrefAttribute = currentElement.attributeValue(\"href\");\n\n                final Image image;\n                final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(hrefAttribute);\n                if (inputName != null) {\n                    // Read the input\n                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    readInputAsSAX(pipelineContext, inputName, new BinaryTextXMLReceiver(null, os, true, false, null, false, false, null, false));\n\n                    // Create the image\n                    image = Image.getInstance(os.toByteArray());\n                } else {\n                    // Read and create the image\n                    image = Image.getInstance(new URL(hrefAttribute));\n                }\n\n                // Set image parameters\n                image.setAbsolutePosition(xPosition, yPosition);\n                if (scalePercent != null) {\n                    image.scalePercent(Float.parseFloat(scalePercent));\n                }\n                if (dpi != null) {\n                    final int dpiInt = Integer.parseInt(dpi);\n                    image.setDpi(dpiInt, dpiInt);\n                }\n                // TODO: Lots of other parameters can be used to configure the image here\n                // Add image\n                groupContext.contentByte.addImage(image);\n            } else {\n                // NOP\n            }\n        }\n    }","id":40171,"modified_method":"private void handleGroup(PipelineContext pipelineContext, GroupContext groupContext, List<Element> statements, FunctionLibrary functionLibrary, PdfReader reader) throws DocumentException, IOException {\n\n        final NodeInfo contextNode = (NodeInfo) groupContext.contextNodeSet.get(groupContext.contextPosition - 1);\n        final Map<String, ValueRepresentation> variableToValueMap = new HashMap<String, ValueRepresentation>();\n\n\n        variableToValueMap.put(\"page-count\", new Int64Value(reader.getNumberOfPages()));\n        variableToValueMap.put(\"page-number\", new Int64Value(groupContext.pageNumber));\n        variableToValueMap.put(\"page-height\", new FloatValue(groupContext.pageHeight));\n\n        // Iterate through statements\n        for (final Element currentElement: statements) {\n\n            // Check whether this statement applies to the current page\n            final String elementPage = currentElement.attributeValue(\"page\");\n            if ((elementPage != null) && !Integer.toString(groupContext.pageNumber).equals(elementPage))\n                continue;\n\n            final NamespaceMapping namespaceMapping = new NamespaceMapping(Dom4jUtils.getNamespaceContextNoDefault(currentElement));\n\n            final String elementName = currentElement.getName();\n            if (elementName.equals(\"group\")) {\n                // Handle group\n\n                final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                final String ref = currentElement.attributeValue(\"ref\");\n                if (ref != null) {\n                    final NodeInfo newContextNode = (NodeInfo) XPathCache.evaluateSingle(groupContext.contextNodeSet, groupContext.contextPosition, ref, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                    if (newContextNode == null)\n                        continue;\n\n                    newGroupContext.contextNodeSet = Collections.singletonList((Item) newContextNode);\n                    newGroupContext.contextPosition = 1;\n                }\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                if (offsetXString != null) {\n                    newGroupContext.offsetX = groupContext.offsetX + Float.parseFloat(offsetXString);\n                }\n\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                if (offsetYString != null) {\n                    newGroupContext.offsetY = groupContext.offsetY + Float.parseFloat(offsetYString);\n                }\n\n                final String fontPitch = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-pitch\"));\n                if (fontPitch != null)\n                    newGroupContext.fontPitch = Float.parseFloat(fontPitch);\n\n                final String fontFamily = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-family\"));\n                if (fontFamily != null)\n                    newGroupContext.fontFamily = fontFamily;\n\n                final String fontSize = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-size\"));\n                if (fontSize != null)\n                    newGroupContext.fontSize = Float.parseFloat(fontSize);\n\n                handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n\n            } else if (elementName.equals(\"repeat\")) {\n                // Handle repeat\n\n                final String nodeset = currentElement.attributeValue(\"nodeset\");\n                final List iterations = XPathCache.evaluate(groupContext.contextNodeSet, groupContext.contextPosition, nodeset, namespaceMapping,\n                        variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                final float offsetIncrementX = (offsetXString == null) ? 0 : Float.parseFloat(offsetXString);\n                final float offsetIncrementY = (offsetYString == null) ? 0 : Float.parseFloat(offsetYString);\n\n                for (int iterationIndex = 1; iterationIndex <= iterations.size(); iterationIndex++) {\n\n                    final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                    newGroupContext.contextNodeSet = iterations;\n                    newGroupContext.contextPosition = iterationIndex;\n\n                    newGroupContext.offsetX = groupContext.offsetX + (iterationIndex - 1) * offsetIncrementX;\n                    newGroupContext.offsetY = groupContext.offsetY + (iterationIndex - 1) * offsetIncrementY;\n\n                    handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n                }\n            } else if (elementName.equals(\"field\")) {\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n\n                if (fieldNameStr != null) {\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                    // Get value from instance\n\n                    final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    groupContext.acroFields.setField(fieldName, text);\n\n                } else {\n                    // Handle field\n\n                    final String leftAttribute = currentElement.attributeValue(\"left\") == null ? currentElement.attributeValue(\"left-position\") : currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\") == null ? currentElement.attributeValue(\"top-position\") : currentElement.attributeValue(\"top\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n\n                    final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n\n                    // Output value\n                    final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n                    groupContext.contentByte.beginText();\n                    {\n                        groupContext.contentByte.setFontAndSize(baseFont, fontAttributes.fontSize);\n\n                        final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                        final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                        // Get value from instance\n                        final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                        // Iterate over characters and print them\n                        if (text != null) {\n                            int len = Math.min(text.length(), (size != null) ? Integer.parseInt(size) : Integer.MAX_VALUE);\n                            for (int j = 0; j < len; j++)\n                                groupContext.contentByte.showTextAligned(PdfContentByte.ALIGN_CENTER, text.substring(j, j + 1), xPosition + ((float) j) * fontAttributes.fontPitch, yPosition, 0);\n                        }\n                    }\n                    groupContext.contentByte.endText();\n                }\n            } else if (elementName.equals(\"barcode\")) {\n                // Handle barcode\n\n                final String leftAttribute = currentElement.attributeValue(\"left\");\n                final String topAttribute = currentElement.attributeValue(\"top\");\n\n                final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n//                final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                final String type = currentElement.attributeValue(\"type\") == null ? \"CODE39\" : currentElement.attributeValue(\"type\");\n                final float height = currentElement.attributeValue(\"height\") == null ? 10.0f : Float.parseFloat(currentElement.attributeValue(\"height\"));\n\n                final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n                final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n                final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n\n                final Barcode barcode = createBarCode(type);\n                barcode.setCode(text);\n                barcode.setBarHeight(height);\n                barcode.setFont(baseFont);\n                barcode.setSize(fontAttributes.fontSize);\n                final Image barcodeImage = barcode.createImageWithBarcode(groupContext.contentByte, null, null);\n                barcodeImage.setAbsolutePosition(xPosition, yPosition);\n                groupContext.contentByte.addImage(barcodeImage);\n            } else if (elementName.equals(\"image\")) {\n                // Handle image\n\n                // Read image\n                final Image image;\n                {\n                    final String hrefAttribute = currentElement.attributeValue(\"href\");\n                    final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(hrefAttribute);\n                    if (inputName != null) {\n                        // Read the input\n                        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        readInputAsSAX(pipelineContext, inputName, new BinaryTextXMLReceiver(null, os, true, false, null, false, false, null, false));\n\n                        // Create the image\n                        image = Image.getInstance(os.toByteArray());\n                    } else {\n                        // Read and create the image\n                        image = Image.getInstance(URLFactory.createURL(hrefAttribute));\n                    }\n                }\n\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n                if (fieldNameStr != null) {\n                    // Use field as placeholder\n\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final float[] positions = groupContext.acroFields.getFieldPositions(fieldName);\n\n                    final Rectangle rectangle = new Rectangle(positions[1], positions[2], positions[3], positions[4]);\n\n                    // This scales the image so that it fits in the box (but the aspect ratio is not changed)\n                    image.scaleToFit(rectangle.getWidth(), rectangle.getHeight());\n\n                    final float yPosition = positions[2] + rectangle.getHeight() - image.getScaledHeight();\n\n                    image.setAbsolutePosition(positions[1] + (rectangle.getWidth() - image.getScaledWidth()) / 2, yPosition);\n\n                } else {\n                    // Use position, etc.\n                    final String leftAttribute = currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\");\n                    final String scalePercentAttribute = currentElement.attributeValue(\"scale-percent\");\n                    final String dpiAttribute = currentElement.attributeValue(\"dpi\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                    final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                    final String scalePercent = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, scalePercentAttribute);\n                    final String dpi = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, dpiAttribute);\n\n                    // Set image parameters\n                    image.setAbsolutePosition(xPosition, yPosition);\n                    if (scalePercent != null) {\n                        image.scalePercent(Float.parseFloat(scalePercent));\n                    }\n                    if (dpi != null) {\n                        final int dpiInt = Integer.parseInt(dpi);\n                        image.setDpi(dpiInt, dpiInt);\n                    }\n                }\n\n                // TODO: Lots of other parameters can be used to configure the image here\n                // Add image\n                groupContext.contentByte.addImage(image);\n            } else {\n                // NOP\n            }\n        }\n    }","commit_id":"297fb44303adefaba3edd267f91c42614c18af2d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void handleGroup(PipelineContext pipelineContext, GroupContext groupContext, List<Element> statements, FunctionLibrary functionLibrary, PdfReader reader) throws DocumentException, IOException {\n\n        final NodeInfo contextNode = (NodeInfo) groupContext.contextNodeSet.get(groupContext.contextPosition - 1);\n        final Map<String, ValueRepresentation> variableToValueMap = new HashMap<String, ValueRepresentation>();\n\n\n        variableToValueMap.put(\"page-count\", new Int64Value(reader.getNumberOfPages()));\n        variableToValueMap.put(\"page-number\", new Int64Value(groupContext.pageNumber));\n        variableToValueMap.put(\"page-height\", new FloatValue(groupContext.pageHeight));\n\n        // Iterate through statements\n        for (final Element currentElement: statements) {\n\n            // Check whether this statement applies to the current page\n            final String elementPage = currentElement.attributeValue(\"page\");\n            if ((elementPage != null) && !Integer.toString(groupContext.pageNumber).equals(elementPage))\n                continue;\n\n            final NamespaceMapping namespaceMapping = new NamespaceMapping(Dom4jUtils.getNamespaceContextNoDefault(currentElement));\n\n            final String elementName = currentElement.getName();\n            if (elementName.equals(\"group\")) {\n                // Handle group\n\n                final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                final String ref = currentElement.attributeValue(\"ref\");\n                if (ref != null) {\n                    final NodeInfo newContextNode = (NodeInfo) XPathCache.evaluateSingle(groupContext.contextNodeSet, groupContext.contextPosition, ref, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                    if (newContextNode == null)\n                        continue;\n\n                    newGroupContext.contextNodeSet = Collections.singletonList((Item) newContextNode);\n                    newGroupContext.contextPosition = 1;\n                }\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                if (offsetXString != null) {\n                    newGroupContext.offsetX = groupContext.offsetX + Float.parseFloat(offsetXString);\n                }\n\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                if (offsetYString != null) {\n                    newGroupContext.offsetY = groupContext.offsetY + Float.parseFloat(offsetYString);\n                }\n\n                final String fontPitch = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-pitch\"));\n                if (fontPitch != null)\n                    newGroupContext.fontPitch = Float.parseFloat(fontPitch);\n\n                final String fontFamily = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-family\"));\n                if (fontFamily != null)\n                    newGroupContext.fontFamily = fontFamily;\n\n                final String fontSize = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-size\"));\n                if (fontSize != null)\n                    newGroupContext.fontSize = Float.parseFloat(fontSize);\n\n                handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n\n            } else if (elementName.equals(\"repeat\")) {\n                // Handle repeat\n\n                final String nodeset = currentElement.attributeValue(\"nodeset\");\n                final List iterations = XPathCache.evaluate(groupContext.contextNodeSet, groupContext.contextPosition, nodeset, namespaceMapping,\n                        variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                final float offsetIncrementX = (offsetXString == null) ? 0 : Float.parseFloat(offsetXString);\n                final float offsetIncrementY = (offsetYString == null) ? 0 : Float.parseFloat(offsetYString);\n\n                for (int iterationIndex = 1; iterationIndex <= iterations.size(); iterationIndex++) {\n\n                    final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                    newGroupContext.contextNodeSet = iterations;\n                    newGroupContext.contextPosition = iterationIndex;\n\n                    newGroupContext.offsetX = groupContext.offsetX + (iterationIndex - 1) * offsetIncrementX;\n                    newGroupContext.offsetY = groupContext.offsetY + (iterationIndex - 1) * offsetIncrementY;\n\n                    handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n                }\n            } else if (elementName.equals(\"field\")) {\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n\n                if (fieldNameStr != null) {\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                    // Get value from instance\n\n                    final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    groupContext.acroFields.setField(fieldName, text);\n\n                } else {\n                    // Handle field\n\n                    final String leftAttribute = currentElement.attributeValue(\"left\") == null ? currentElement.attributeValue(\"left-position\") : currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\") == null ? currentElement.attributeValue(\"top-position\") : currentElement.attributeValue(\"top\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n\n                    final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n\n                    // Output value\n                    final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n                    groupContext.contentByte.beginText();\n                    {\n                        groupContext.contentByte.setFontAndSize(baseFont, fontAttributes.fontSize);\n\n                        final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                        final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                        // Get value from instance\n                        final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                        // Iterate over characters and print them\n                        if (text != null) {\n                            int len = Math.min(text.length(), (size != null) ? Integer.parseInt(size) : Integer.MAX_VALUE);\n                            for (int j = 0; j < len; j++)\n                                groupContext.contentByte.showTextAligned(PdfContentByte.ALIGN_CENTER, text.substring(j, j + 1), xPosition + ((float) j) * fontAttributes.fontPitch, yPosition, 0);\n                        }\n                    }\n                    groupContext.contentByte.endText();\n                }\n            } else if (elementName.equals(\"barcode\")) {\n                // Handle barcode\n\n                final String leftAttribute = currentElement.attributeValue(\"left\");\n                final String topAttribute = currentElement.attributeValue(\"top\");\n\n                final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n//                final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                final String type = currentElement.attributeValue(\"type\") == null ? \"CODE39\" : currentElement.attributeValue(\"type\");\n                final float height = currentElement.attributeValue(\"height\") == null ? 10.0f : Float.parseFloat(currentElement.attributeValue(\"height\"));\n\n                final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n                final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n                final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n\n                final Barcode barcode = createBarCode(type);\n                barcode.setCode(text);\n                barcode.setBarHeight(height);\n                barcode.setFont(baseFont);\n                barcode.setSize(fontAttributes.fontSize);\n                final Image barcodeImage = barcode.createImageWithBarcode(groupContext.contentByte, null, null);\n                barcodeImage.setAbsolutePosition(xPosition, yPosition);\n                groupContext.contentByte.addImage(barcodeImage);\n            } else if (elementName.equals(\"image\")) {\n                // Handle image\n\n                // Read image\n                final Image image;\n                {\n                    final String hrefAttribute = currentElement.attributeValue(\"href\");\n                    final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(hrefAttribute);\n                    if (inputName != null) {\n                        // Read the input\n                        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        readInputAsSAX(pipelineContext, inputName, new BinaryTextXMLReceiver(null, os, true, false, null, false, false, null, false));\n\n                        // Create the image\n                        image = Image.getInstance(os.toByteArray());\n                    } else {\n                        // Read and create the image\n                        image = Image.getInstance(URLFactory.createURL(hrefAttribute));\n                    }\n                }\n\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n                if (fieldNameStr != null) {\n                    // Use field as placeholder\n\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final float[] positions = groupContext.acroFields.getFieldPositions(fieldName);\n\n                    final Rectangle rectangle = new Rectangle(positions[1], positions[2], positions[3], positions[4]);\n\n                    // This scales the image so that it fits in the box (but the aspect ratio is not changed)\n                    image.scaleToFit(rectangle.getWidth(), rectangle.getHeight());\n\n                    final float yPosition = positions[2] + rectangle.getHeight() - image.getScaledHeight();\n\n                    image.setAbsolutePosition(positions[1] + (rectangle.getWidth() - image.getScaledWidth()) / 2, yPosition);\n\n                } else {\n                    // Use position, etc.\n                    final String leftAttribute = currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\");\n                    final String scalePercentAttribute = currentElement.attributeValue(\"scale-percent\");\n                    final String dpiAttribute = currentElement.attributeValue(\"dpi\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                    final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                    final String scalePercent = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, scalePercentAttribute);\n                    final String dpi = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, dpiAttribute);\n\n                    // Set image parameters\n                    image.setAbsolutePosition(xPosition, yPosition);\n                    if (scalePercent != null) {\n                        image.scalePercent(Float.parseFloat(scalePercent));\n                    }\n                    if (dpi != null) {\n                        final int dpiInt = Integer.parseInt(dpi);\n                        image.setDpi(dpiInt, dpiInt);\n                    }\n                }\n\n                // TODO: Lots of other parameters can be used to configure the image here\n                // Add image\n                groupContext.contentByte.addImage(image);\n            } else {\n                // NOP\n            }\n        }\n    }","id":40172,"modified_method":"private void handleGroup(PipelineContext pipelineContext, GroupContext groupContext, List<Element> statements, FunctionLibrary functionLibrary, PdfReader reader) throws DocumentException, IOException {\n\n        final NodeInfo contextNode = (NodeInfo) groupContext.contextNodeSet.get(groupContext.contextPosition - 1);\n        final Map<String, ValueRepresentation> variableToValueMap = new HashMap<String, ValueRepresentation>();\n\n\n        variableToValueMap.put(\"page-count\", new Int64Value(reader.getNumberOfPages()));\n        variableToValueMap.put(\"page-number\", new Int64Value(groupContext.pageNumber));\n        variableToValueMap.put(\"page-height\", new FloatValue(groupContext.pageHeight));\n\n        // Iterate through statements\n        for (final Element currentElement: statements) {\n\n            // Check whether this statement applies to the current page\n            final String elementPage = currentElement.attributeValue(\"page\");\n            if ((elementPage != null) && !Integer.toString(groupContext.pageNumber).equals(elementPage))\n                continue;\n\n            final NamespaceMapping namespaceMapping = new NamespaceMapping(Dom4jUtils.getNamespaceContextNoDefault(currentElement));\n\n            final String elementName = currentElement.getName();\n            if (elementName.equals(\"group\")) {\n                // Handle group\n\n                final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                final String ref = currentElement.attributeValue(\"ref\");\n                if (ref != null) {\n                    final NodeInfo newContextNode = (NodeInfo) XPathCache.evaluateSingle(groupContext.contextNodeSet, groupContext.contextPosition, ref, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                    if (newContextNode == null)\n                        continue;\n\n                    newGroupContext.contextNodeSet = Collections.singletonList((Item) newContextNode);\n                    newGroupContext.contextPosition = 1;\n                }\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                if (offsetXString != null) {\n                    newGroupContext.offsetX = groupContext.offsetX + Float.parseFloat(offsetXString);\n                }\n\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                if (offsetYString != null) {\n                    newGroupContext.offsetY = groupContext.offsetY + Float.parseFloat(offsetYString);\n                }\n\n                final String fontPitch = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-pitch\"));\n                if (fontPitch != null)\n                    newGroupContext.fontPitch = Float.parseFloat(fontPitch);\n\n                final String fontFamily = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-family\"));\n                if (fontFamily != null)\n                    newGroupContext.fontFamily = fontFamily;\n\n                final String fontSize = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"font-size\"));\n                if (fontSize != null)\n                    newGroupContext.fontSize = Float.parseFloat(fontSize);\n\n                handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n\n            } else if (elementName.equals(\"repeat\")) {\n                // Handle repeat\n\n                final String nodeset = currentElement.attributeValue(\"nodeset\");\n                final List iterations = XPathCache.evaluate(groupContext.contextNodeSet, groupContext.contextPosition, nodeset, namespaceMapping,\n                        variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final String offsetXString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-x\"));\n                final String offsetYString = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"offset-y\"));\n                final float offsetIncrementX = (offsetXString == null) ? 0 : Float.parseFloat(offsetXString);\n                final float offsetIncrementY = (offsetYString == null) ? 0 : Float.parseFloat(offsetYString);\n\n                for (int iterationIndex = 1; iterationIndex <= iterations.size(); iterationIndex++) {\n\n                    final GroupContext newGroupContext = new GroupContext(groupContext);\n\n                    newGroupContext.contextNodeSet = iterations;\n                    newGroupContext.contextPosition = iterationIndex;\n\n                    newGroupContext.offsetX = groupContext.offsetX + (iterationIndex - 1) * offsetIncrementX;\n                    newGroupContext.offsetY = groupContext.offsetY + (iterationIndex - 1) * offsetIncrementY;\n\n                    handleGroup(pipelineContext, newGroupContext, Dom4jUtils.elements(currentElement), functionLibrary, reader);\n                }\n            } else if (elementName.equals(\"field\")) {\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n\n                if (fieldNameStr != null) {\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                    // Get value from instance\n\n                    final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    groupContext.acroFields.setField(fieldName, text);\n\n                } else {\n                    // Handle field\n\n                    final String leftAttribute = currentElement.attributeValue(\"left\") == null ? currentElement.attributeValue(\"left-position\") : currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\") == null ? currentElement.attributeValue(\"top-position\") : currentElement.attributeValue(\"top\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                    final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n\n                    final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n\n                    // Output value\n                    final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n                    groupContext.contentByte.beginText();\n                    {\n                        groupContext.contentByte.setFontAndSize(baseFont, fontAttributes.fontSize);\n\n                        final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                        final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                        // Get value from instance\n                        final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                        // Iterate over characters and print them\n                        if (text != null) {\n                            int len = Math.min(text.length(), (size != null) ? Integer.parseInt(size) : Integer.MAX_VALUE);\n                            for (int j = 0; j < len; j++)\n                                groupContext.contentByte.showTextAligned(PdfContentByte.ALIGN_CENTER, text.substring(j, j + 1), xPosition + ((float) j) * fontAttributes.fontPitch, yPosition, 0);\n                        }\n                    }\n                    groupContext.contentByte.endText();\n                }\n            } else if (elementName.equals(\"barcode\")) {\n                // Handle barcode\n\n                final String leftAttribute = currentElement.attributeValue(\"left\");\n                final String topAttribute = currentElement.attributeValue(\"top\");\n\n                final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n//                final String size = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, currentElement.attributeValue(\"size\"));\n                final String value = currentElement.attributeValue(\"value\") == null ? currentElement.attributeValue(\"ref\") : currentElement.attributeValue(\"value\");\n                final String type = currentElement.attributeValue(\"type\") == null ? \"CODE39\" : currentElement.attributeValue(\"type\");\n                final float height = currentElement.attributeValue(\"height\") == null ? 10.0f : Float.parseFloat(currentElement.attributeValue(\"height\"));\n\n                final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n                final String text = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, value, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n\n                final FontAttributes fontAttributes = getFontAttributes(currentElement, pipelineContext, groupContext, variableToValueMap, contextNode);\n                final BaseFont baseFont = BaseFont.createFont(fontAttributes.fontFamily, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);\n\n                final Barcode barcode = createBarCode(type);\n                barcode.setCode(text);\n                barcode.setBarHeight(height);\n                barcode.setFont(baseFont);\n                barcode.setSize(fontAttributes.fontSize);\n                final Image barcodeImage = barcode.createImageWithBarcode(groupContext.contentByte, null, null);\n                barcodeImage.setAbsolutePosition(xPosition, yPosition);\n                groupContext.contentByte.addImage(barcodeImage);\n            } else if (elementName.equals(\"image\")) {\n                // Handle image\n\n                // Read image\n                final Image image;\n                {\n                    final String hrefAttribute = currentElement.attributeValue(\"href\");\n                    final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(hrefAttribute);\n                    if (inputName != null) {\n                        // Read the input\n                        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        readInputAsSAX(pipelineContext, inputName, new BinaryTextXMLReceiver(null, os, true, false, null, false, false, null, false));\n\n                        // Create the image\n                        image = Image.getInstance(os.toByteArray());\n                    } else {\n                        // Read and create the image\n                        final URL url = URLFactory.createURL(hrefAttribute);\n\n                        // Use ConnectionResult so that header/session forwarding takes place\n                        final ConnectionResult connectionResult\n                            = new Connection().open(NetUtils.getExternalContext(), new IndentedLogger(logger, \"\"), false, Connection.Method.GET.name(),\n                                url, null, null, null, null, null, null, Connection.getForwardHeaders());\n\n                        if (connectionResult.statusCode != 200) {\n                            connectionResult.close();\n                            throw new OXFException(\"Got invalid return code while loading image: \" + url.toExternalForm() + \", \" + connectionResult.statusCode);\n                        }\n\n                        // Make sure things are cleaned-up not too late\n                        pipelineContext.addContextListener(new PipelineContext.ContextListener() {\n                            public void contextDestroyed(boolean success) {\n                                connectionResult.close();\n                            }\n                        });\n\n                        // Here we decide to copy to temp file and load as a URL. We could also provide bytes directly.\n                        final String tempURLString = NetUtils.inputStreamToAnyURI(connectionResult.getResponseInputStream(), NetUtils.REQUEST_SCOPE);\n                        image = Image.getInstance(URLFactory.createURL(tempURLString));\n                    }\n                }\n\n\n                final String fieldNameStr = currentElement.attributeValue(\"acro-field-name\");\n                if (fieldNameStr != null) {\n                    // Use field as placeholder\n\n                    final String fieldName = XPathCache.evaluateAsString(groupContext.contextNodeSet, groupContext.contextPosition, fieldNameStr, namespaceMapping, variableToValueMap, functionLibrary, null, null, (LocationData) currentElement.getData());\n                    final float[] positions = groupContext.acroFields.getFieldPositions(fieldName);\n\n                    if (positions != null) {\n                        final Rectangle rectangle = new Rectangle(positions[1], positions[2], positions[3], positions[4]);\n\n                        // This scales the image so that it fits in the box (but the aspect ratio is not changed)\n                        image.scaleToFit(rectangle.getWidth(), rectangle.getHeight());\n\n                        final float yPosition = positions[2] + rectangle.getHeight() - image.getScaledHeight();\n                        image.setAbsolutePosition(positions[1] + (rectangle.getWidth() - image.getScaledWidth()) / 2, yPosition);\n\n                        // Add image\n                        groupContext.contentByte.addImage(image);\n                    }\n\n                } else {\n                    // Use position, etc.\n                    final String leftAttribute = currentElement.attributeValue(\"left\");\n                    final String topAttribute = currentElement.attributeValue(\"top\");\n                    final String scalePercentAttribute = currentElement.attributeValue(\"scale-percent\");\n                    final String dpiAttribute = currentElement.attributeValue(\"dpi\");\n\n                    final String leftPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, leftAttribute);\n                    final String topPosition = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, topAttribute);\n\n                    final float xPosition = Float.parseFloat(leftPosition) + groupContext.offsetX;\n                    final float yPosition = groupContext.pageHeight - (Float.parseFloat(topPosition) + groupContext.offsetY);\n\n                    final String scalePercent = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, scalePercentAttribute);\n                    final String dpi = resolveAttributeValueTemplates(pipelineContext, contextNode, variableToValueMap, null, null, currentElement, dpiAttribute);\n\n                    // Set image parameters\n                    image.setAbsolutePosition(xPosition, yPosition);\n                    if (scalePercent != null) {\n                        image.scalePercent(Float.parseFloat(scalePercent));\n                    }\n                    if (dpi != null) {\n                        final int dpiInt = Integer.parseInt(dpi);\n                        image.setDpi(dpiInt, dpiInt);\n                    }\n\n                    // Add image\n                    groupContext.contentByte.addImage(image);\n                }\n            } else {\n                // NOP\n            }\n        }\n    }","commit_id":"052f3825c5095bc6e8625d1bd86d35085b6888f4","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Image respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        final Switchboard sb = (Switchboard)env;\n        \n        // the url to the image can be either submitted with an url in clear text, or using a license key\n        // if the url is given as clear text, the user must be authorized as admin\n        // the license can be used also from non-authorized users\n        \n        String urlString = post.get(\"url\", \"\");\n        final String urlLicense = post.get(\"code\", \"\");\n        final boolean auth = (header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")).equals(\"localhost\") || sb.verifyAuthentication(header, true); // handle access rights\n        \n        DigestURI url = null;\n        if ((urlString.length() > 0) && (auth)) try {\n            url = new DigestURI(urlString);\n        } catch (final MalformedURLException e1) {\n            url = null;\n        }\n        \n        if ((url == null) && (urlLicense.length() > 0)) {\n            url = sb.licensedURLs.releaseLicense(urlLicense);\n            urlString = (url == null) ? null : url.toNormalform(true, true);\n        }\n        \n        if (urlString == null) return null;\n        \n        int width = post.getInt(\"width\", 0);\n        int height = post.getInt(\"height\", 0);\n        int maxwidth = post.getInt(\"maxwidth\", 0);\n        int maxheight = post.getInt(\"maxheight\", 0);\n        \n        // get the image as stream\n        if (MemoryControl.shortStatus()) iconcache.clear();\n        Image scaled = iconcache.get(urlString);\n        if (scaled == null) {\n            byte[] resourceb = null;\n            if (url != null) try {\n                resourceb = sb.loader.loadContent(sb.loader.request(url, false, true), CrawlProfile.CacheStrategy.IFEXIST);\n            } catch (IOException e) {\n                Log.logFine(\"ViewImage\", \"cannot load: \" + e.getMessage());\n            }\n            byte[] imgb = null;\n            if (resourceb == null) {\n                if (urlString.endsWith(\".ico\")) {\n                    // load default favicon dfltfvcn.ico\n                    if (defaulticonb == null) try {\n                        imgb = FileUtils.read(new File(sb.getAppPath(), defaulticon));\n                    } catch (final IOException e) {\n                        return null;\n                    } else {\n                        imgb = defaulticonb;\n                    }\n                } else {\n                    return null;\n                }\n            } else {\n                final InputStream imgStream = new ByteArrayInputStream(resourceb);\n\n                // read image data\n                try {\n                    imgb = FileUtils.read(imgStream);\n                } catch (final IOException e) {\n                    return null;\n                } finally {\n                    try {\n                        imgStream.close();\n                    } catch (final Exception e) {/* ignore this */}\n                }\n            }\n\n            // read image\n            final Image image = ImageParser.parse(urlString, imgb);\n\n            if (image == null || (auth && (width == 0 || height == 0) && maxwidth == 0 && maxheight == 0)) return image;\n\n            // find original size\n            final int h = image.getHeight(null);\n            final int w = image.getWidth(null);\n            \n            // in case of not-authorized access shrink the image to prevent\n            // copyright problems, so that images are not larger than thumbnails\n            if (auth) {\n                maxwidth = (maxwidth == 0) ? w : maxwidth;\n                maxheight = (maxheight == 0) ? h : maxheight;\n            } else if ((w > 16) || (h > 16)) {\n                maxwidth = Math.min(96, w);\n                maxheight = Math.min(96, h);\n            } else {\n                maxwidth = 16;\n                maxheight = 16;\n            }\n\n            // calculate width & height from maxwidth & maxheight\n            if ((maxwidth < w) || (maxheight < h)) {\n                // scale image\n                final double hs = (w <= maxwidth) ? 1.0 : ((double) maxwidth) / ((double) w);\n                final double vs = (h <= maxheight) ? 1.0 : ((double) maxheight) / ((double) h);\n                double scale = Math.min(hs, vs);\n                //if (!auth) scale = Math.min(scale, 0.6); // this is for copyright purpose\n                if (scale < 1.0) {\n                    width = Math.max(1, (int) (w * scale));\n                    height = Math.max(1, (int) (h * scale));\n                } else {\n                    width = Math.max(1, w);\n                    height = Math.max(1, h);\n                }\n                \n                // compute scaled image\n                scaled = ((w == width) && (h == height)) ? image : image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING);\n                final MediaTracker mediaTracker = new MediaTracker(new Container());\n                mediaTracker.addImage(scaled, 0);\n                try {mediaTracker.waitForID(0);} catch (final InterruptedException e) {}\n            } else {\n                // do not scale\n                width = w;\n                height = h;\n                scaled = image;\n            }\n\n            if ((height == 16) && (width == 16) && (resourceb != null)) {\n                // this might be a favicon, store image to cache for faster re-load later on\n                iconcache.put(urlString, scaled);\n            }\n        }\n        \n        return scaled;\n    }","id":40173,"modified_method":"public static Image respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        final Switchboard sb = (Switchboard)env;\n        \n        // the url to the image can be either submitted with an url in clear text, or using a license key\n        // if the url is given as clear text, the user must be authorized as admin\n        // the license can be used also from non-authorized users\n        \n        String urlString = post.get(\"url\", \"\");\n        final String urlLicense = post.get(\"code\", \"\");\n        final boolean auth = (header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")).equals(\"localhost\") || sb.verifyAuthentication(header, true); // handle access rights\n        \n        DigestURI url = null;\n        if ((urlString.length() > 0) && (auth)) try {\n            url = new DigestURI(urlString);\n        } catch (final MalformedURLException e1) {\n            url = null;\n        }\n        \n        if ((url == null) && (urlLicense.length() > 0)) {\n            url = sb.licensedURLs.releaseLicense(urlLicense);\n            urlString = (url == null) ? null : url.toNormalform(true, true);\n        }\n        \n        if (urlString == null) return null;\n        \n        int width = post.getInt(\"width\", 0);\n        int height = post.getInt(\"height\", 0);\n        int maxwidth = post.getInt(\"maxwidth\", 0);\n        int maxheight = post.getInt(\"maxheight\", 0);\n        \n        // get the image as stream\n        if (MemoryControl.shortStatus()) iconcache.clear();\n        Image image = iconcache.get(urlString);\n        if (image == null) {\n            byte[] resourceb = null;\n            if (url != null) try {\n                resourceb = sb.loader.loadContent(sb.loader.request(url, false, true), CrawlProfile.CacheStrategy.IFEXIST);\n            } catch (IOException e) {\n                Log.logFine(\"ViewImage\", \"cannot load: \" + e.getMessage());\n            }\n            byte[] imgb = null;\n            if (resourceb == null) {\n                if (urlString.endsWith(\".ico\")) {\n                    // load default favicon dfltfvcn.ico\n                    if (defaulticonb == null) try {\n                        imgb = FileUtils.read(new File(sb.getAppPath(), defaulticon));\n                    } catch (final IOException e) {\n                        return null;\n                    } else {\n                        imgb = defaulticonb;\n                    }\n                } else {\n                    return null;\n                }\n            } else {\n                final InputStream imgStream = new ByteArrayInputStream(resourceb);\n\n                // read image data\n                try {\n                    imgb = FileUtils.read(imgStream);\n                } catch (final IOException e) {\n                    return null;\n                } finally {\n                    try {\n                        imgStream.close();\n                    } catch (final Exception e) {}\n                }\n            }\n\n            // read image\n            image = ImageParser.parse(urlString, imgb);\n\n            if (image == null || (auth && (width == 0 || height == 0) && maxwidth == 0 && maxheight == 0)) return image;\n\n            // find original size\n            final int h = image.getHeight(null);\n            final int w = image.getWidth(null);\n            \n            // in case of not-authorized access shrink the image to prevent\n            // copyright problems, so that images are not larger than thumbnails\n            if (auth) {\n                maxwidth = (maxwidth == 0) ? w : maxwidth;\n                maxheight = (maxheight == 0) ? h : maxheight;\n            } else if ((w > 16) || (h > 16)) {\n                maxwidth = Math.min(96, w);\n                maxheight = Math.min(96, h);\n            } else {\n                maxwidth = 16;\n                maxheight = 16;\n            }\n\n            // calculate width & height from maxwidth & maxheight\n            if (maxwidth < w || maxheight < h) {\n                // scale image\n                final double hs = (w <= maxwidth) ? 1.0 : ((double) maxwidth) / ((double) w);\n                final double vs = (h <= maxheight) ? 1.0 : ((double) maxheight) / ((double) h);\n                double scale = Math.min(hs, vs);\n                //if (!auth) scale = Math.min(scale, 0.6); // this is for copyright purpose\n                if (scale < 1.0) {\n                    width = Math.max(1, (int) (w * scale));\n                    height = Math.max(1, (int) (h * scale));\n                } else {\n                    width = Math.max(1, w);\n                    height = Math.max(1, h);\n                }\n                \n                if (w != width && h != height) {\n                    // compute scaled image\n                    Image scaled = image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING);\n                    final MediaTracker mediaTracker = new MediaTracker(new Container());\n                    mediaTracker.addImage(scaled, 0);\n                    try {mediaTracker.waitForID(0);} catch (final InterruptedException e) {}\n                    \n                    // make a BufferedImage out of that\n                    BufferedImage i = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                    try {\n                        i.createGraphics().drawImage(scaled, 0, 0, width, height, null); \n                        image = i;\n                        // check outcome\n                        Raster raster = i.getData();\n                        int[] pixel = new int[3];\n                        pixel = raster.getPixel(0, 0, pixel);\n                        if (pixel[0] != 0 || pixel[1] != 0 || pixel[2] != 0) image = i;\n                    } catch (Exception e) {\n                        //java.lang.ClassCastException: [I cannot be cast to [B\n                    }\n                    \n                }\n            } else {\n                // do not scale\n                width = w;\n                height = h;\n            }\n\n            if ((height == 16) && (width == 16) && (resourceb != null)) {\n                // this might be a favicon, store image to cache for faster re-load later on\n                iconcache.put(urlString, image);\n            }\n        }\n        \n        return image;\n    }","commit_id":"897b4e8b9cc9cfc110d4b12808b53c5f7876d9aa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches) {\n        if (source.isFlag())\n            return true;\n\n        ArgumentDefinition defaultDefinition = createDefaultArgumentDefinition(source);\n        String value = getArgumentValue( defaultDefinition, matches );\n        Object result;\n        Tags tags = getArgumentTags(matches);\n\n        // lets go through the types we support\n        try {\n            if (type.isPrimitive()) {\n                Method valueOf = primitiveToWrapperMap.get(type).getMethod(\"valueOf\",String.class);\n                if(value == null)\n                    throw new MissingArgumentValueException(createDefaultArgumentDefinition(source));\n                result = valueOf.invoke(null,value.trim());\n            } else if (type.isEnum()) {\n                Object[] vals = type.getEnumConstants();\n                Object defaultEnumeration = null;  // as we look at options, record the default option if it exists\n                for (Object val : vals) {\n                    if (String.valueOf(val).equalsIgnoreCase(value)) return val;\n                    try { if (type.getField(val.toString()).isAnnotationPresent(EnumerationArgumentDefault.class)) defaultEnumeration = val; }\n                    catch (NoSuchFieldException e) { throw new ReviewedStingException(\"parsing \" + type.toString() + \"doesn't contain the field \" + val.toString()); }\n                }\n                // if their argument has no value (null), and there's a default, return that default for the enum value\n                if (defaultEnumeration != null && value == null)\n                    result = defaultEnumeration;\n                    // if their argument has no value and there's no default, throw a missing argument value exception.\n                    // TODO: Clean this up so that null values never make it to this point.  To fix this, we'll have to clean up the implementation of -U.\n                else if (value == null)\n                    throw new MissingArgumentValueException(createDefaultArgumentDefinition(source));\n                else\n                    throw new UnknownEnumeratedValueException(createDefaultArgumentDefinition(source),value);\n            } else {\n                Constructor ctor = type.getConstructor(String.class);\n                result = ctor.newInstance(value);\n            }\n        } catch (UserException e) {\n            throw e;\n        } catch (InvocationTargetException e) {\n            throw new UserException.CommandLineException(String.format(\"Failed to parse value %s for argument %s.  This is most commonly caused by providing an incorrect data type (e.g. a double when an int is required)\",\n                            value, source.field.getName()));\n        } catch (Exception e) {\n            throw new DynamicClassResolutionException(String.class, e);\n        }\n\n        // TODO FIXME!\n\n        // WARNING: Side effect!\n        parsingEngine.addTags(result,tags);\n\n        return result;\n    }","id":40174,"modified_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Type fulltype, ArgumentMatches matches) {\n        Class type = makeRawTypeIfNecessary(fulltype);\n        if (source.isFlag())\n            return true;\n\n        ArgumentDefinition defaultDefinition = createDefaultArgumentDefinition(source);\n        String value = getArgumentValue( defaultDefinition, matches );\n        Object result;\n        Tags tags = getArgumentTags(matches);\n\n        // lets go through the types we support\n        try {\n            if (type.isPrimitive()) {\n                Method valueOf = primitiveToWrapperMap.get(type).getMethod(\"valueOf\",String.class);\n                if(value == null)\n                    throw new MissingArgumentValueException(createDefaultArgumentDefinition(source));\n                result = valueOf.invoke(null,value.trim());\n            } else if (type.isEnum()) {\n                Object[] vals = type.getEnumConstants();\n                Object defaultEnumeration = null;  // as we look at options, record the default option if it exists\n                for (Object val : vals) {\n                    if (String.valueOf(val).equalsIgnoreCase(value)) return val;\n                    try { if (type.getField(val.toString()).isAnnotationPresent(EnumerationArgumentDefault.class)) defaultEnumeration = val; }\n                    catch (NoSuchFieldException e) { throw new ReviewedStingException(\"parsing \" + type.toString() + \"doesn't contain the field \" + val.toString()); }\n                }\n                // if their argument has no value (null), and there's a default, return that default for the enum value\n                if (defaultEnumeration != null && value == null)\n                    result = defaultEnumeration;\n                    // if their argument has no value and there's no default, throw a missing argument value exception.\n                    // TODO: Clean this up so that null values never make it to this point.  To fix this, we'll have to clean up the implementation of -U.\n                else if (value == null)\n                    throw new MissingArgumentValueException(createDefaultArgumentDefinition(source));\n                else\n                    throw new UnknownEnumeratedValueException(createDefaultArgumentDefinition(source),value);\n            } else {\n                Constructor ctor = type.getConstructor(String.class);\n                result = ctor.newInstance(value);\n            }\n        } catch (UserException e) {\n            throw e;\n        } catch (InvocationTargetException e) {\n            throw new UserException.CommandLineException(String.format(\"Failed to parse value %s for argument %s.  This is most commonly caused by providing an incorrect data type (e.g. a double when an int is required)\",\n                    value, source.field.getName()));\n        } catch (Exception e) {\n            throw new DynamicClassResolutionException(String.class, e);\n        }\n\n        // TODO FIXME!\n\n        // WARNING: Side effect!\n        parsingEngine.addTags(result,tags);\n\n        return result;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Parses an argument source to an object.\n     * WARNING!  Mandatory side effect of parsing!  Each parse routine should register the tags it finds with the proper CommandLineProgram.\n     * TODO: Fix this, perhaps with an event model indicating that a new argument has been created.\n     *\n     * @param parsingEngine The engine responsible for parsing.\n     * @param source The source used to find the matches.\n     * @param matches The matches for the source.\n     * @return The parsed object.\n     */\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, ArgumentMatches matches) {\n        return parse(parsingEngine, source, source.field.getType(), matches);\n    }","id":40175,"modified_method":"/**\n     * Parses an argument source to an object.\n     * WARNING!  Mandatory side effect of parsing!  Each parse routine should register the tags it finds with the proper CommandLineProgram.\n     * TODO: Fix this, perhaps with an event model indicating that a new argument has been created.\n     *\n     * @param parsingEngine The engine responsible for parsing.\n     * @param source The source used to find the matches.\n     * @param matches The matches for the source.\n     * @return The parsed object.\n     */\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, ArgumentMatches matches) {\n        return parse(parsingEngine, source, source.field.getGenericType(), matches);\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches) {\n        if(multiplexedIds == null)\n            throw new ReviewedStingException(\"Cannot directly parse a MultiplexArgumentTypeDescriptor; must create a derivative type descriptor first.\");\n\n        Map<Object,Object> multiplexedMapping = new HashMap<Object,Object>();\n\n        Class componentType = getCollectionComponentType(source.field);\n\n\n        for(Object id: multiplexedIds) {\n            Object value = parsingEngine.selectBestTypeDescriptor(componentType).parse(parsingEngine,source,componentType,matches.transform(multiplexer,id));\n            multiplexedMapping.put(id,value);\n        }\n\n        parsingEngine.addTags(multiplexedMapping,getArgumentTags(matches));\n\n        return multiplexedMapping;\n    }","id":40176,"modified_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches) {\n        if(multiplexedIds == null)\n            throw new ReviewedStingException(\"Cannot directly parse a MultiplexArgumentTypeDescriptor; must create a derivative type descriptor first.\");\n\n        Map<Object,Object> multiplexedMapping = new HashMap<Object,Object>();\n\n        Class componentType = makeRawTypeIfNecessary(getCollectionComponentType(source.field));\n\n\n        for(Object id: multiplexedIds) {\n            Object value = parsingEngine.selectBestTypeDescriptor(componentType).parse(parsingEngine,source,componentType,matches.transform(multiplexer,id));\n            multiplexedMapping.put(id,value);\n        }\n\n        parsingEngine.addTags(multiplexedMapping,getArgumentTags(matches));\n\n        return multiplexedMapping;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public Object parse(ParsingEngine parsingEngine,ArgumentSource source, Class type, ArgumentMatches matches) {\n        Class componentType;\n        Object result;\n\n        if( Collection.class.isAssignableFrom(type) ) {\n\n            // If this is a generic interface, pick a concrete implementation to create and pass back.\n            // Because of type erasure, don't worry about creating one of exactly the correct type.\n            if( Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers()) )\n            {\n                if( java.util.List.class.isAssignableFrom(type) ) type = ArrayList.class;\n                else if( java.util.Queue.class.isAssignableFrom(type) ) type = java.util.ArrayDeque.class;\n                else if( java.util.Set.class.isAssignableFrom(type) ) type = java.util.TreeSet.class;\n            }\n\n            componentType = getCollectionComponentType( source.field );\n            ArgumentTypeDescriptor componentArgumentParser = parsingEngine.selectBestTypeDescriptor(componentType);\n\n            Collection collection;\n            try {\n                collection = (Collection)type.newInstance();\n            }\n            catch (InstantiationException e) {\n                logger.fatal(\"ArgumentParser: InstantiationException: cannot convert field \" + source.field.getName());\n                throw new ReviewedStingException(\"constructFromString:InstantiationException: Failed conversion \" + e.getMessage());\n            }\n            catch (IllegalAccessException e) {\n                logger.fatal(\"ArgumentParser: IllegalAccessException: cannot convert field \" + source.field.getName());\n                throw new ReviewedStingException(\"constructFromString:IllegalAccessException: Failed conversion \" + e.getMessage());\n            }\n\n            for( ArgumentMatch match: matches ) {\n                for( ArgumentMatch value: match ) {\n                    Object object = componentArgumentParser.parse(parsingEngine,source,componentType,new ArgumentMatches(value));\n                    collection.add( object );\n                    // WARNING: Side effect!\n                    parsingEngine.addTags(object,value.tags);\n                }\n            }\n\n            result = collection;\n\n        }\n        else if( type.isArray() ) {\n            componentType = type.getComponentType();\n            ArgumentTypeDescriptor componentArgumentParser = parsingEngine.selectBestTypeDescriptor(componentType);\n\n            // Assemble a collection of individual values used in this computation.\n            Collection<ArgumentMatch> values = new ArrayList<ArgumentMatch>();\n            for( ArgumentMatch match: matches )\n                for( ArgumentMatch value: match )\n                    values.add(value);\n\n            result = Array.newInstance(componentType,values.size());\n\n            int i = 0;\n            for( ArgumentMatch value: values ) {\n                Object object = componentArgumentParser.parse(parsingEngine,source,componentType,new ArgumentMatches(value));\n                Array.set(result,i++,object);\n                // WARNING: Side effect!\n                parsingEngine.addTags(object,value.tags);\n            }\n        }\n        else\n            throw new ReviewedStingException(\"Unsupported compound argument type: \" + type);\n\n        return result;\n    }","id":40177,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public Object parse(ParsingEngine parsingEngine,ArgumentSource source, Type fulltype, ArgumentMatches matches) {\n        Class type = makeRawTypeIfNecessary(fulltype);\n        Type componentType;\n        Object result;\n\n        if( Collection.class.isAssignableFrom(type) ) {\n\n            // If this is a generic interface, pick a concrete implementation to create and pass back.\n            // Because of type erasure, don't worry about creating one of exactly the correct type.\n            if( Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers()) )\n            {\n                if( java.util.List.class.isAssignableFrom(type) ) type = ArrayList.class;\n                else if( java.util.Queue.class.isAssignableFrom(type) ) type = java.util.ArrayDeque.class;\n                else if( java.util.Set.class.isAssignableFrom(type) ) type = java.util.TreeSet.class;\n            }\n\n            componentType = getCollectionComponentType( source.field );\n            ArgumentTypeDescriptor componentArgumentParser = parsingEngine.selectBestTypeDescriptor(makeRawTypeIfNecessary(componentType));\n\n            Collection collection;\n            try {\n                collection = (Collection)type.newInstance();\n            }\n            catch (InstantiationException e) {\n                logger.fatal(\"ArgumentParser: InstantiationException: cannot convert field \" + source.field.getName());\n                throw new ReviewedStingException(\"constructFromString:InstantiationException: Failed conversion \" + e.getMessage());\n            }\n            catch (IllegalAccessException e) {\n                logger.fatal(\"ArgumentParser: IllegalAccessException: cannot convert field \" + source.field.getName());\n                throw new ReviewedStingException(\"constructFromString:IllegalAccessException: Failed conversion \" + e.getMessage());\n            }\n\n            for( ArgumentMatch match: matches ) {\n                for( ArgumentMatch value: match ) {\n                    Object object = componentArgumentParser.parse(parsingEngine,source,componentType,new ArgumentMatches(value));\n                    collection.add( object );\n                    // WARNING: Side effect!\n                    parsingEngine.addTags(object,value.tags);\n                }\n            }\n\n            result = collection;\n\n        }\n        else if( type.isArray() ) {\n            componentType = type.getComponentType();\n            ArgumentTypeDescriptor componentArgumentParser = parsingEngine.selectBestTypeDescriptor(makeRawTypeIfNecessary(componentType));\n\n            // Assemble a collection of individual values used in this computation.\n            Collection<ArgumentMatch> values = new ArrayList<ArgumentMatch>();\n            for( ArgumentMatch match: matches )\n                for( ArgumentMatch value: match )\n                    values.add(value);\n\n            result = Array.newInstance(makeRawTypeIfNecessary(componentType),values.size());\n\n            int i = 0;\n            for( ArgumentMatch value: values ) {\n                Object object = componentArgumentParser.parse(parsingEngine,source,componentType,new ArgumentMatches(value));\n                Array.set(result,i++,object);\n                // WARNING: Side effect!\n                parsingEngine.addTags(object,value.tags);\n            }\n        }\n        else\n            throw new ReviewedStingException(\"Unsupported compound argument type: \" + type);\n\n        return result;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    @Override\n    protected Class getCollectionComponentType( Field field ) {\n        // Multiplex arguments must resolve to maps from which the clp should extract the second type.\n        if( field.getGenericType() instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType)field.getGenericType();\n            if( parameterizedType.getActualTypeArguments().length != 2 )\n                throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + field.toString());\n            return (Class)parameterizedType.getActualTypeArguments()[1];\n        }\n        else\n            return String.class;\n    }","id":40178,"modified_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    @Override\n    protected Type getCollectionComponentType( Field field ) {\n        // Multiplex arguments must resolve to maps from which the clp should extract the second type.\n        if( field.getGenericType() instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType)field.getGenericType();\n            if( parameterizedType.getActualTypeArguments().length != 2 )\n                throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + field.toString());\n            return (Class)parameterizedType.getActualTypeArguments()[1];\n        }\n        else\n            return String.class;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches) {\n        ArgumentDefinition defaultDefinition = createDefaultArgumentDefinition(source);\n        String value = getArgumentValue( defaultDefinition, matches );\n        try {\n            Tags tags = getArgumentTags(matches);\n            Constructor ctor = type.getConstructor(Class.class, String.class, String.class, Tags.class);\n            Class parameterType = getParameterizedTypeClass(source.field.getGenericType());\n            RodBinding result = (RodBinding)ctor.newInstance(parameterType, source.field.getName(), value, tags);\n            parsingEngine.addTags(result,tags);\n            return result;\n        } catch (InvocationTargetException e) {\n            throw new UserException.CommandLineException(\n                    String.format(\"Failed to parse value %s for argument %s.\",\n                            value, source.field.getName()));\n        } catch (Exception e) {\n            throw new UserException.CommandLineException(\n                    String.format(\"Failed to parse value %s for argument %s.\",\n                            value, source.field.getName()));\n        }\n    }","id":40179,"modified_method":"@Override\n    public Object parse(ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches) {\n        ArgumentDefinition defaultDefinition = createDefaultArgumentDefinition(source);\n        String value = getArgumentValue( defaultDefinition, matches );\n        try {\n            Tags tags = getArgumentTags(matches);\n            Constructor ctor = (makeRawTypeIfNecessary(type)).getConstructor(Class.class, String.class, String.class, Tags.class);\n            Class parameterType = getParameterizedTypeClass(type);\n            RodBinding result = (RodBinding)ctor.newInstance(parameterType, source.field.getName(), value, tags);\n            parsingEngine.addTags(result,tags);\n            return result;\n        } catch (InvocationTargetException e) {\n            throw new UserException.CommandLineException(\n                    String.format(\"Failed to parse value %s for argument %s.\",\n                            value, source.field.getName()));\n        } catch (Exception e) {\n            throw new UserException.CommandLineException(\n                    String.format(\"Failed to parse value %s for argument %s.\",\n                            value, source.field.getName()));\n        }\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Parses the argument matches for a class type into an object.\n     * @param source The original argument source used to find the matches.\n     * @param type The current class type being inspected.  May not match the argument source.field.getType() if this as a collection for example.\n     * @param matches The argument matches for the argument source, or the individual argument match for a scalar if this is being called to help parse a collection.\n     * @return The individual parsed object matching the argument match with Class type.\n     */\n    public abstract Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches );","id":40180,"modified_method":"/**\n     * Parses the argument matches for a class type into an object.\n     * @param source The original argument source used to find the matches.\n     * @param type The current class type being inspected.  May not match the argument source.field.getType() if this as a collection for example.\n     * @param matches The argument matches for the argument source, or the individual argument match for a scalar if this is being called to help parse a collection.\n     * @return The individual parsed object matching the argument match with Class type.\n     */\n    public abstract Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches );","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    protected Class getCollectionComponentType( Field field ) {\n        return null;\n    }","id":40181,"modified_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    protected Type getCollectionComponentType( Field field ) {\n        return null;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * By default, argument sources create argument definitions with a set of default values.\n     * Use this method to create the one simple argument definition.\n     * @param source argument source for which to create a default definition.\n     * @return The default definition for this argument source.\n     */\n    protected ArgumentDefinition createDefaultArgumentDefinition( ArgumentSource source ) {\n        Annotation argumentAnnotation = getArgumentAnnotation(source);\n        return new ArgumentDefinition( ArgumentIOType.getIOType(argumentAnnotation),\n                                       source.field.getType(),\n                                       ArgumentDefinition.getFullName(argumentAnnotation, source.field.getName()),\n                                       ArgumentDefinition.getShortName(argumentAnnotation),\n                                       ArgumentDefinition.getDoc(argumentAnnotation),\n                                       source.isRequired() && !createsTypeDefault(source) && !source.isFlag() && !source.isDeprecated(),\n                                       source.isFlag(),\n                                       source.isMultiValued(),\n                                       source.isHidden(),\n                                       getCollectionComponentType(source.field),\n                                       ArgumentDefinition.getExclusiveOf(argumentAnnotation),\n                                       ArgumentDefinition.getValidationRegex(argumentAnnotation),\n                                       getValidOptions(source) );\n    }","id":40182,"modified_method":"/**\n     * By default, argument sources create argument definitions with a set of default values.\n     * Use this method to create the one simple argument definition.\n     * @param source argument source for which to create a default definition.\n     * @return The default definition for this argument source.\n     */\n    protected ArgumentDefinition createDefaultArgumentDefinition( ArgumentSource source ) {\n        Annotation argumentAnnotation = getArgumentAnnotation(source);\n        return new ArgumentDefinition( ArgumentIOType.getIOType(argumentAnnotation),\n                source.field.getType(),\n                ArgumentDefinition.getFullName(argumentAnnotation, source.field.getName()),\n                ArgumentDefinition.getShortName(argumentAnnotation),\n                ArgumentDefinition.getDoc(argumentAnnotation),\n                source.isRequired() && !createsTypeDefault(source) && !source.isFlag() && !source.isDeprecated(),\n                source.isFlag(),\n                source.isMultiValued(),\n                source.isHidden(),\n                makeRawTypeIfNecessary(getCollectionComponentType(source.field)),\n                ArgumentDefinition.getExclusiveOf(argumentAnnotation),\n                ArgumentDefinition.getValidationRegex(argumentAnnotation),\n                getValidOptions(source) );\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    @Override\n    protected Class getCollectionComponentType( Field field ) {\n            // If this is a parameterized collection, find the contained type.  If blow up if more than one type exists.\n            if( field.getGenericType() instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType)field.getGenericType();\n                if( parameterizedType.getActualTypeArguments().length > 1 )\n                    throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + field.toString());\n                return (Class)parameterizedType.getActualTypeArguments()[0];\n            }\n            else\n                return String.class;\n    }","id":40183,"modified_method":"/**\n     * Return the component type of a field, or String.class if the type cannot be found.\n     * @param field The reflected field to inspect.\n     * @return The parameterized component type, or String.class if the parameterized type could not be found.\n     * @throws IllegalArgumentException If more than one parameterized type is found on the field.\n     */\n    @Override\n    protected Type getCollectionComponentType( Field field ) {\n        // If this is a parameterized collection, find the contained type.  If blow up if more than one type exists.\n        if( field.getGenericType() instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType)field.getGenericType();\n            if( parameterizedType.getActualTypeArguments().length > 1 )\n                throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + field.toString());\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n        else\n            return String.class;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object createTypeDefault(ParsingEngine parsingEngine,ArgumentSource source,Class<?> type) {\n        if(multiplexer == null || multiplexedIds == null)\n            throw new ReviewedStingException(\"No multiplexed ids available\");\n\n        Map<Object,Object> multiplexedMapping = new HashMap<Object,Object>();\n        Class componentType = getCollectionComponentType(source.field);\n        ArgumentTypeDescriptor componentTypeDescriptor = parsingEngine.selectBestTypeDescriptor(componentType);\n\n        for(Object id: multiplexedIds) {\n            Object value = null;\n            if(componentTypeDescriptor.createsTypeDefault(source))\n                value = componentTypeDescriptor.createTypeDefault(parsingEngine,source,componentType);\n            multiplexedMapping.put(id,value);\n        }\n        return multiplexedMapping;\n    }","id":40184,"modified_method":"@Override\n    public Object createTypeDefault(ParsingEngine parsingEngine,ArgumentSource source,Class<?> type) {\n        if(multiplexer == null || multiplexedIds == null)\n            throw new ReviewedStingException(\"No multiplexed ids available\");\n\n        Map<Object,Object> multiplexedMapping = new HashMap<Object,Object>();\n        Class componentType = makeRawTypeIfNecessary(getCollectionComponentType(source.field));\n        ArgumentTypeDescriptor componentTypeDescriptor = parsingEngine.selectBestTypeDescriptor(componentType);\n\n        for(Object id: multiplexedIds) {\n            Object value = null;\n            if(componentTypeDescriptor.createsTypeDefault(source))\n                value = componentTypeDescriptor.createTypeDefault(parsingEngine,source,componentType);\n            multiplexedMapping.put(id,value);\n        }\n        return multiplexedMapping;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Subclasses of CommandLinePrograms can provide their own types of command-line arguments.\n     * @return A collection of type descriptors generating implementation-dependent placeholders.\n     */\n    protected Collection<ArgumentTypeDescriptor> getArgumentTypeDescriptors() {\n        return Arrays.asList( new VCFWriterArgumentTypeDescriptor(engine,System.out,argumentSources),\n                              new SAMFileReaderArgumentTypeDescriptor(engine),\n                              new SAMFileWriterArgumentTypeDescriptor(engine,System.out),\n                              new OutputStreamArgumentTypeDescriptor(engine,System.out) );\n    }","id":40185,"modified_method":"/**\n     * Subclasses of CommandLinePrograms can provide their own types of command-line arguments.\n     * @return A collection of type descriptors generating implementation-dependent placeholders.\n     */\n    protected Collection<ArgumentTypeDescriptor> getArgumentTypeDescriptors() {\n        return Arrays.asList( new VCFWriterArgumentTypeDescriptor(engine,System.out,argumentSources),\n                              new SAMFileWriterArgumentTypeDescriptor(engine,System.out),\n                              new OutputStreamArgumentTypeDescriptor(engine,System.out) );\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    protected Collection<ArgumentTypeDescriptor> getArgumentTypeDescriptors() {\n        List<ArgumentTypeDescriptor> typeDescriptors = new ArrayList<ArgumentTypeDescriptor>();\n        typeDescriptors.add(new VCFWriterArgumentTypeDescriptor(GATKEngine,System.out,Collections.<Object>emptyList()));\n        typeDescriptors.add(new SAMFileReaderArgumentTypeDescriptor(GATKEngine));\n        typeDescriptors.add(new SAMFileWriterArgumentTypeDescriptor(GATKEngine,System.out));\n        typeDescriptors.add(new OutputStreamArgumentTypeDescriptor(GATKEngine,System.out));\n        return typeDescriptors;\n    }","id":40186,"modified_method":"@Override\n    protected Collection<ArgumentTypeDescriptor> getArgumentTypeDescriptors() {\n        List<ArgumentTypeDescriptor> typeDescriptors = new ArrayList<ArgumentTypeDescriptor>();\n        typeDescriptors.add(new VCFWriterArgumentTypeDescriptor(GATKEngine,System.out,Collections.<Object>emptyList()));\n        typeDescriptors.add(new SAMFileWriterArgumentTypeDescriptor(GATKEngine,System.out));\n        typeDescriptors.add(new OutputStreamArgumentTypeDescriptor(GATKEngine,System.out));\n        return typeDescriptors;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches )  {\n        ArgumentDefinition definition = createDefaultArgumentDefinition(source);\n        String fileName = getArgumentValue( definition, matches );\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(fileName == null && !source.isRequired())\n            throw new MissingArgumentValueException(definition);\n\n        OutputStreamStub stub = new OutputStreamStub(new File(fileName));\n\n        engine.addOutput(stub);\n\n        Object result = createInstanceOfClass(type,stub);\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(result,getArgumentTags(matches));\n        \n        return result;\n    }","id":40187,"modified_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches )  {\n        ArgumentDefinition definition = createDefaultArgumentDefinition(source);\n        String fileName = getArgumentValue( definition, matches );\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(fileName == null && !source.isRequired())\n            throw new MissingArgumentValueException(definition);\n\n        OutputStreamStub stub = new OutputStreamStub(new File(fileName));\n\n        engine.addOutput(stub);\n\n        Object result = createInstanceOfClass(makeRawTypeIfNecessary(type),stub);\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(result,getArgumentTags(matches));\n        \n        return result;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches ) {\n        SAMFileReaderBuilder builder = new SAMFileReaderBuilder();\n\n        String readerFileName = getArgumentValue( createDefaultArgumentDefinition(source), matches );\n\n        if( readerFileName == null )\n            throw new UserException.CommandLineException(\"SAM file compression was supplied, but no associated writer was supplied with it.\");\n\n        builder.setSAMFile(new File(readerFileName));\n\n        // WARNING: Skipping required side-effect because stub is impossible to generate.\n        engine.addInput(source, builder);\n\n        // MASSIVE KLUDGE!  SAMFileReader is tricky to implement and we don't yet have a stub.  Return null, then\n        // let the output tracker load it in.\n        // TODO: Add a stub for SAMFileReader.\n        return null;\n    }","id":40188,"modified_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches ) {\n        SAMFileReaderBuilder builder = new SAMFileReaderBuilder();\n\n        String readerFileName = getArgumentValue( createDefaultArgumentDefinition(source), matches );\n\n        if( readerFileName == null )\n            throw new UserException.CommandLineException(\"SAM file compression was supplied, but no associated writer was supplied with it.\");\n\n        builder.setSAMFile(new File(readerFileName));\n\n        // WARNING: Skipping required side-effect because stub is impossible to generate.\n        engine.addInput(source, builder);\n\n        // MASSIVE KLUDGE!  SAMFileReader is tricky to implement and we don't yet have a stub.  Return null, then\n        // let the output tracker load it in.\n        // TODO: Add a stub for SAMFileReader.\n        return null;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches )  {\n        // Extract all possible parameters that could be passed to a BAM file writer?\n        ArgumentDefinition bamArgumentDefinition = createBAMArgumentDefinition(source);\n        String writerFileName = getArgumentValue( bamArgumentDefinition, matches );\n\n        String compressionLevelText = getArgumentValue( createBAMCompressionArgumentDefinition(source), matches );\n        Integer compressionLevel = compressionLevelText != null ? Integer.valueOf(compressionLevelText) : null;\n\n        Boolean indexOnTheFly = !argumentIsPresent(disableWriteIndexArgumentDefinition(source),matches) ? true : null;\n        Boolean generateMD5 = argumentIsPresent(this.enableMD5GenerationArgumentDefinition(source),matches) ? true : null;\n        Boolean simplifyBAM = argumentIsPresent(createSimplifyBAMArgumentDefinition(source),matches);\n\n        // Validate the combination of parameters passed in.\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFileName == null) {\n            if(!source.isRequired())\n                throw new MissingArgumentValueException(bamArgumentDefinition);\n            if(generateMD5)\n                throw new ArgumentException(\"MD5 generation specified, but no output file specified.  If md5 generation is desired, please specify a BAM output file and an md5 file will be written alongside.\");\n        }\n\n        // Create the stub and set parameters.\n        SAMFileWriterStub stub = new SAMFileWriterStub(engine, new File(writerFileName));\n\n        if( compressionLevel != null )\n            stub.setCompressionLevel(compressionLevel);\n        if(indexOnTheFly != null)\n            stub.setIndexOnTheFly(indexOnTheFly);\n        if(generateMD5 != null)\n            stub.setGenerateMD5(generateMD5);\n        if(simplifyBAM != null)\n            stub.setSimplifyBAM(simplifyBAM);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","id":40189,"modified_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches )  {\n        // Extract all possible parameters that could be passed to a BAM file writer?\n        ArgumentDefinition bamArgumentDefinition = createBAMArgumentDefinition(source);\n        String writerFileName = getArgumentValue( bamArgumentDefinition, matches );\n\n        String compressionLevelText = getArgumentValue( createBAMCompressionArgumentDefinition(source), matches );\n        Integer compressionLevel = compressionLevelText != null ? Integer.valueOf(compressionLevelText) : null;\n\n        Boolean indexOnTheFly = !argumentIsPresent(disableWriteIndexArgumentDefinition(source),matches) ? true : null;\n        Boolean generateMD5 = argumentIsPresent(this.enableMD5GenerationArgumentDefinition(source),matches) ? true : null;\n        Boolean simplifyBAM = argumentIsPresent(createSimplifyBAMArgumentDefinition(source),matches);\n\n        // Validate the combination of parameters passed in.\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFileName == null) {\n            if(!source.isRequired())\n                throw new MissingArgumentValueException(bamArgumentDefinition);\n            if(generateMD5)\n                throw new ArgumentException(\"MD5 generation specified, but no output file specified.  If md5 generation is desired, please specify a BAM output file and an md5 file will be written alongside.\");\n        }\n\n        // Create the stub and set parameters.\n        SAMFileWriterStub stub = new SAMFileWriterStub(engine, new File(writerFileName));\n\n        if( compressionLevel != null )\n            stub.setCompressionLevel(compressionLevel);\n        if(indexOnTheFly != null)\n            stub.setIndexOnTheFly(indexOnTheFly);\n        if(generateMD5 != null)\n            stub.setGenerateMD5(generateMD5);\n        if(simplifyBAM != null)\n            stub.setSimplifyBAM(simplifyBAM);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Convert the given argument matches into a single object suitable for feeding into the ArgumentSource.\n     * @param source Source for this argument.\n     * @param type not used\n     * @param matches Matches that match with this argument.\n     * @return Transform from the matches into the associated argument.\n     */\n    @Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches )  {\n        ArgumentDefinition defaultArgumentDefinition = createDefaultArgumentDefinition(source);\n        // Get the filename for the genotype file, if it exists.  If not, we'll need to send output to out.\n        String writerFileName = getArgumentValue(defaultArgumentDefinition,matches);\n        File writerFile = writerFileName != null ? new File(writerFileName) : null;\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFile == null && !source.isRequired())\n            throw new MissingArgumentValueException(defaultArgumentDefinition);\n\n        // Should we compress the output stream?\n        boolean compress = isCompressed(writerFileName);\n\n        boolean skipWritingHeader = argumentIsPresent(createNoHeaderArgumentDefinition(),matches);\n        boolean doNotWriteGenotypes = argumentIsPresent(createSitesOnlyArgumentDefinition(),matches);\n\n        // Create a stub for the given object.\n        VCFWriterStub stub = (writerFile != null) ? new VCFWriterStub(engine, writerFile, compress, argumentSources, skipWritingHeader, doNotWriteGenotypes)\n                                                  : new VCFWriterStub(engine, defaultOutputStream, compress, argumentSources, skipWritingHeader, doNotWriteGenotypes);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","id":40190,"modified_method":"/**\n     * Convert the given argument matches into a single object suitable for feeding into the ArgumentSource.\n     * @param source Source for this argument.\n     * @param type not used\n     * @param matches Matches that match with this argument.\n     * @return Transform from the matches into the associated argument.\n     */\n    @Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches )  {\n        ArgumentDefinition defaultArgumentDefinition = createDefaultArgumentDefinition(source);\n        // Get the filename for the genotype file, if it exists.  If not, we'll need to send output to out.\n        String writerFileName = getArgumentValue(defaultArgumentDefinition,matches);\n        File writerFile = writerFileName != null ? new File(writerFileName) : null;\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFile == null && !source.isRequired())\n            throw new MissingArgumentValueException(defaultArgumentDefinition);\n\n        // Should we compress the output stream?\n        boolean compress = isCompressed(writerFileName);\n\n        boolean skipWritingHeader = argumentIsPresent(createNoHeaderArgumentDefinition(),matches);\n        boolean doNotWriteGenotypes = argumentIsPresent(createSitesOnlyArgumentDefinition(),matches);\n\n        // Create a stub for the given object.\n        VCFWriterStub stub = (writerFile != null) ? new VCFWriterStub(engine, writerFile, compress, argumentSources, skipWritingHeader, doNotWriteGenotypes)\n                                                  : new VCFWriterStub(engine, defaultOutputStream, compress, argumentSources, skipWritingHeader, doNotWriteGenotypes);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null ) // RodWalkers can make funky map calls\n            return 0;\n\n//        for ( RodBinding binding : variantsList )\n//            System.out.printf(\"VariantList binding %s tags=%s%n\", binding, getToolkit().getTags(binding).getPositionalTags());\n\n        if ( ++nRecords < MAX_RECORDS || MAX_RECORDS == -1 ) {\n            VariantContext vc = variants.getFirstValue(tracker, context.getLocation());\n            if ( (keepMultiAllelic || vc.isBiallelic()) && ( showFiltered || vc.isNotFiltered() ) ) {\n                List<String> vals = extractFields(vc, fieldsToTake, ALLOW_MISSING_DATA);\n                out.println(Utils.join(\"\\t\", vals));\n            }\n            return 1;\n        } else {\n            if ( nRecords >= MAX_RECORDS ) {\n                logger.warn(\"Calling sys exit to leave after \" + nRecords + \" records\");\n                System.exit(0); // todo -- what's the recommend way to abort like this?\n            }\n            return 0;\n        }\n    }","id":40191,"modified_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null ) // RodWalkers can make funky map calls\n            return 0;\n\n        for ( RodBinding binding : variantsList )\n            System.out.printf(\"VariantList binding %s tags=%s%n\", binding, binding.getTags().getPositionalTags());\n\n        if ( ++nRecords < MAX_RECORDS || MAX_RECORDS == -1 ) {\n            VariantContext vc = variants.getFirstValue(tracker, context.getLocation());\n            if ( (keepMultiAllelic || vc.isBiallelic()) && ( showFiltered || vc.isNotFiltered() ) ) {\n                List<String> vals = extractFields(vc, fieldsToTake, ALLOW_MISSING_DATA);\n                out.println(Utils.join(\"\\t\", vals));\n            }\n            return 1;\n        } else {\n            if ( nRecords >= MAX_RECORDS ) {\n                logger.warn(\"Calling sys exit to leave after \" + nRecords + \" records\");\n                System.exit(0); // todo -- what's the recommend way to abort like this?\n            }\n            return 0;\n        }\n    }","commit_id":"a6691ab2fd1b60bc3cbab6931e707d796910bb4f","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void processFile(File file, final CommandContext cmdCtx) {\n\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(file));\n            String line = reader.readLine();\n            while (!cmdCtx.isTerminated() && line != null) {\n                cmdCtx.handleSafe(line.trim());\n                line = reader.readLine();\n            }\n        } catch (Throwable e) {\n            cmdCtx.error(\"Failed to process file '\" + file.getAbsolutePath() + \"'\");\n            e.printStackTrace();\n        } finally {\n            StreamUtils.safeClose(reader);\n            if (!cmdCtx.isTerminated()) {\n                cmdCtx.terminateSession();\n            }\n            cmdCtx.disconnectController();\n        }\n    }","id":40192,"modified_method":"private static void processFile(File file, final CommandContext cmdCtx) {\n\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(file));\n            String line = reader.readLine();\n            while (!cmdCtx.isTerminated() && line != null) {\n                cmdCtx.handle(line.trim());\n                line = reader.readLine();\n            }\n        } catch (Throwable e) {\n            cmdCtx.error(\"Failed to process file '\" + file.getAbsolutePath() + \"'\");\n            e.printStackTrace();\n        } finally {\n            StreamUtils.safeClose(reader);\n            if (!cmdCtx.isTerminated()) {\n                cmdCtx.terminateSession();\n            }\n            cmdCtx.disconnectController();\n        }\n    }","commit_id":"3d9222f63c0924205935a9e15dfa3dc45b31a617","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void processCommands(String[] commands, CommandContext cmdCtx) {\n        try {\n            for (int i = 0; i < commands.length && !cmdCtx.isTerminated(); ++i) {\n                cmdCtx.handleSafe(commands[i]);\n            }\n        } catch(Throwable t) {\n            t.printStackTrace();\n        } finally {\n            if (!cmdCtx.isTerminated()) {\n                cmdCtx.terminateSession();\n            }\n            cmdCtx.disconnectController();\n        }\n    }","id":40193,"modified_method":"private static void processCommands(String[] commands, CommandContext cmdCtx) {\n        int i = 0;\n        try {\n            while (i < commands.length && !cmdCtx.isTerminated()) {\n                cmdCtx.handle(commands[i]);\n                ++i;\n            }\n        } catch(Throwable t) {\n            cmdCtx.error(\"Failed to process command '\" + commands[i] + \"': \" + t.getLocalizedMessage());\n            t.printStackTrace();\n        } finally {\n            if (!cmdCtx.isTerminated()) {\n                cmdCtx.terminateSession();\n            }\n            cmdCtx.disconnectController();\n        }\n    }","commit_id":"3d9222f63c0924205935a9e15dfa3dc45b31a617","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            ctx.error(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n            return;\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            ctx.error(\"Parsed request isn't available.\");\n            return;\n        }\n\n        try {\n            validateRequest(ctx, request);\n        } catch(CommandFormatException e) {\n            ctx.error(e.getLocalizedMessage());\n            return;\n        }\n\n        try {\n            ModelNode result = client.execute(request);\n            ctx.printLine(result.toString());\n        } catch(NoSuchElementException e) {\n            ctx.error(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            ctx.error(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.error(\"Communication error: \" + e.getLocalizedMessage());\n            ctx.disconnectController();\n        } catch (RuntimeException e) {\n            throw e;\n        }\n    }","id":40194,"modified_method":"@Override\n    public void handle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            ctx.error(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n            return;\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            ctx.error(\"Parsed request isn't available.\");\n            return;\n        }\n\n        try {\n            validateRequest(ctx, request);\n        } catch(CommandFormatException e) {\n            ctx.error(e.getLocalizedMessage());\n            return;\n        }\n\n        try {\n            final ModelNode result = client.execute(request);\n            if(Util.isSuccess(result)) {\n                ctx.printLine(result.toString());\n            } else {\n                ctx.error(result.toString());\n            }\n        } catch(NoSuchElementException e) {\n            ctx.error(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            ctx.error(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.error(\"Communication error: \" + e.getLocalizedMessage());\n            ctx.disconnectController();\n        } catch (RuntimeException e) {\n            throw e;\n        }\n    }","commit_id":"3d9222f63c0924205935a9e15dfa3dc45b31a617","url":"https://github.com/wildfly/wildfly"},{"original_method":"String getPrompt() {\n            StringBuilder buffer = new StringBuilder();\n            if(promptConnectPart == null) {\n                buffer.append('[');\n                if (controllerHost != null) {\n                    if (domainMode) {\n                        buffer.append(\"domain@\");\n                    } else {\n                        buffer.append(\"standalone@\");\n                    }\n                    buffer.append(controllerHost).append(':').append(controllerPort).append(' ');\n                } else {\n                    buffer.append(\"disconnected \");\n                }\n                promptConnectPart = buffer.toString();\n            } else {\n                buffer.append(promptConnectPart);\n            }\n\n            if (prefix.isEmpty()) {\n                buffer.append('/');\n            } else {\n                buffer.append(prefix.getNodeType());\n                final String nodeName = prefix.getNodeName();\n                if (nodeName != null) {\n                    buffer.append('=').append(nodeName);\n                }\n            }\n\n            if (isBatchMode()) {\n                buffer.append(\" #\");\n            }\n            buffer.append(\"] \");\n            return buffer.toString();\n        }","id":40195,"modified_method":"String getPrompt() {\n            StringBuilder buffer = new StringBuilder();\n            if(promptConnectPart == null) {\n                buffer.append('[');\n                if (controllerHost != null) {\n                    if (domainMode) {\n                        buffer.append(\"domain@\");\n                    } else {\n                        buffer.append(\"standalone@\");\n                    }\n                    buffer.append(controllerHost).append(':').append(controllerPort).append(' ');\n                    promptConnectPart = buffer.toString();\n                } else {\n                    buffer.append(\"disconnected \");\n                }\n            } else {\n                buffer.append(promptConnectPart);\n            }\n\n            if (prefix.isEmpty()) {\n                buffer.append('/');\n            } else {\n                buffer.append(prefix.getNodeType());\n                final String nodeName = prefix.getNodeName();\n                if (nodeName != null) {\n                    buffer.append('=').append(nodeName);\n                }\n            }\n\n            if (isBatchMode()) {\n                buffer.append(\" #\");\n            }\n            buffer.append(\"] \");\n            return buffer.toString();\n        }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ModelNode buildRequest(CommandContext ctx) throws OperationFormatException {\n\n        ParsedArguments args = ctx.getParsedArguments();\n        if (!args.hasArguments()) {\n            throw new OperationFormatException(\"Required arguments are missing.\");\n        }\n\n        final String filePath;\n        try {\n            filePath = path.getValue(args);\n        } catch(IllegalArgumentException e) {\n            throw new OperationFormatException(\"Missing required path argument.\");\n        }\n        String name = this.name.getValue(args);\n        String runtimeName = rtName.getValue(args);\n\n\n        File f = new File(filePath);\n        if(!f.exists()) {\n            throw new OperationFormatException(f.getAbsolutePath() + \" doesn't exist.\");\n        }\n\n        if(name == null) {\n            name = f.getName();\n        }\n\n        if(Util.isDeployed(name, ctx.getModelControllerClient())) {\n            if(force.isPresent(args)) {\n                DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n\n                // replace\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"full-replace-deployment\");\n                builder.addProperty(\"name\", name);\n                if(runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                byte[] bytes = readBytes(f);\n                builder.getModelNode().get(\"bytes\").set(bytes);\n                return builder.buildRequest();\n            } else {\n                throw new OperationFormatException(\"'\" + name + \"' is already deployed (use -f to force re-deploy).\");\n            }\n        }\n\n        final List<String> serverGroups;\n        if (ctx.isDomainMode()) {\n            if(allServerGroups.isPresent(args)) {\n                serverGroups = Util.getServerGroups(ctx.getModelControllerClient());\n            } else {\n                String serverGroupsStr = this.serverGroups.getValue(args);\n                if(serverGroupsStr == null) {\n                    new OperationFormatException(\"Either --all-server-groups or --server-groups must be specified.\");\n                }\n                serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n            }\n\n            if(serverGroups.isEmpty()) {\n                new OperationFormatException(\"No server group is available.\");\n            }\n        } else {\n            serverGroups = null;\n        }\n\n        ModelNode composite = new ModelNode();\n        composite.get(\"operation\").set(\"composite\");\n        composite.get(\"address\").setEmptyList();\n        ModelNode steps = composite.get(\"steps\");\n\n        DefaultOperationRequestBuilder builder;\n\n        // add\n        builder = new DefaultOperationRequestBuilder();\n        builder.setOperationName(\"add\");\n        builder.addNode(\"deployment\", name);\n        if (runtimeName != null) {\n            builder.addProperty(\"runtime-name\", runtimeName);\n        }\n\n        byte[] bytes = readBytes(f);\n        builder.getModelNode().get(\"bytes\").set(bytes);\n        steps.add(builder.buildRequest());\n\n        // deploy\n        if (ctx.isDomainMode()) {\n            for (String serverGroup : serverGroups) {\n                steps.add(Util.configureDeploymentOperation(\"add\", name, serverGroup));\n            }\n            for (String serverGroup : serverGroups) {\n                steps.add(Util.configureDeploymentOperation(\"deploy\", name, serverGroup));\n            }\n        } else {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"deploy\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n\n        return composite;\n    }","id":40196,"modified_method":"public ModelNode buildRequest(CommandContext ctx) throws OperationFormatException {\n\n        ParsedArguments args = ctx.getParsedArguments();\n        if (!args.hasArguments()) {\n            throw new OperationFormatException(\"Required arguments are missing.\");\n        }\n\n        final String filePath;\n        try {\n            filePath = path.getValue(args);\n        } catch(IllegalArgumentException e) {\n            throw new OperationFormatException(\"Missing required path argument.\");\n        }\n        String name = this.name.getValue(args);\n        String runtimeName = rtName.getValue(args);\n\n\n        File f = new File(filePath);\n        if(!f.exists()) {\n            throw new OperationFormatException(f.getAbsolutePath() + \" doesn't exist.\");\n        }\n\n        if(name == null) {\n            name = f.getName();\n        }\n\n        if(Util.isDeploymentInRepository(name, ctx.getModelControllerClient())) {\n            if(force.isPresent(args)) {\n                DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n\n                // replace\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"full-replace-deployment\");\n                builder.addProperty(\"name\", name);\n                if(runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                byte[] bytes = readBytes(f);\n                builder.getModelNode().get(\"bytes\").set(bytes);\n                return builder.buildRequest();\n            } else {\n                throw new OperationFormatException(\"'\" + name + \"' is already deployed (use -f to force re-deploy).\");\n            }\n        }\n\n        final List<String> serverGroups;\n        if (ctx.isDomainMode()) {\n            if(allServerGroups.isPresent(args)) {\n                serverGroups = Util.getServerGroups(ctx.getModelControllerClient());\n            } else {\n                String serverGroupsStr = this.serverGroups.getValue(args);\n                if(serverGroupsStr == null) {\n                    new OperationFormatException(\"Either --all-server-groups or --server-groups must be specified.\");\n                }\n                serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n            }\n\n            if(serverGroups.isEmpty()) {\n                new OperationFormatException(\"No server group is available.\");\n            }\n        } else {\n            serverGroups = null;\n        }\n\n        ModelNode composite = new ModelNode();\n        composite.get(\"operation\").set(\"composite\");\n        composite.get(\"address\").setEmptyList();\n        ModelNode steps = composite.get(\"steps\");\n\n        DefaultOperationRequestBuilder builder;\n\n        // add\n        builder = new DefaultOperationRequestBuilder();\n        builder.setOperationName(\"add\");\n        builder.addNode(\"deployment\", name);\n        if (runtimeName != null) {\n            builder.addProperty(\"runtime-name\", runtimeName);\n        }\n\n        byte[] bytes = readBytes(f);\n        builder.getModelNode().get(\"bytes\").set(bytes);\n        steps.add(builder.buildRequest());\n\n        // deploy\n        if (ctx.isDomainMode()) {\n            for (String serverGroup : serverGroups) {\n                steps.add(Util.configureDeploymentOperation(\"add\", name, serverGroup));\n            }\n            for (String serverGroup : serverGroups) {\n                steps.add(Util.configureDeploymentOperation(\"deploy\", name, serverGroup));\n            }\n        } else {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"deploy\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n\n        return composite;\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n\n        ParsedArguments args = ctx.getParsedArguments();\n        boolean l = this.l.isPresent(args);\n        if (!args.hasArguments() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                ctx.printLine(\"Path \" + f.getAbsolutePath() + \" doesn't exist.\");\n                return;\n            }\n        } else {\n            f = null;\n        }\n\n        String name = this.name.getValue(args);\n        if(name == null) {\n            if(f == null) {\n                ctx.printLine(\"Either path or --name is requied.\");\n                return;\n            }\n            name = f.getName();\n        }\n\n        String runtimeName = rtName.getValue(args);\n\n        if(Util.isDeployed(name, client) && f != null) {\n            if(force.isPresent(args)) {\n                DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n\n                ModelNode result;\n\n                // replace\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"full-replace-deployment\");\n                builder.addProperty(\"name\", name);\n                if(runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                FileInputStream is = null;\n                try {\n                    is = new FileInputStream(f);\n                    ModelNode request = builder.buildRequest();\n                    OperationBuilder op = OperationBuilder.Factory.create(request);\n                    op.addInputStream(is);\n                    request.get(\"input-stream-index\").set(0);\n                    result = client.execute(op.build());\n                } catch(Exception e) {\n                    ctx.printLine(\"Failed to replace the deployment: \" + e.getLocalizedMessage());\n                    return;\n                } finally {\n                    StreamUtils.safeClose(is);\n                }\n                if(!Util.isSuccess(result)) {\n                    ctx.printLine(Util.getFailureDescription(result));\n                    return;\n                }\n\n                ctx.printLine(\"'\" + name + \"' re-deployed successfully.\");\n            } else {\n                ctx.printLine(\"'\" + name + \"' is already deployed (use \" + force.getDefaultName() + \" to force re-deploy).\");\n            }\n\n            return;\n        } else {\n\n            final List<String> serverGroups;\n            if (ctx.isDomainMode()) {\n                if(allServerGroups.isPresent(args)) {\n                    serverGroups = Util.getServerGroups(client);\n                } else {\n                    String serverGroupsStr = this.serverGroups.getValue(args);\n                    if(serverGroupsStr == null) {\n                        ctx.printLine(\"Either --all-server-groups or --server-groups must be specified.\");\n                        return;\n                    }\n                    serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                }\n\n                if(serverGroups.isEmpty()) {\n                    ctx.printLine(\"No server group is available.\");\n                    return;\n                }\n            } else {\n                serverGroups = null;\n            }\n\n            DefaultOperationRequestBuilder builder;\n\n            ModelNode result;\n\n            // add\n            if (f != null) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"add\");\n                builder.addNode(\"deployment\", name);\n                if (runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                FileInputStream is = null;\n                try {\n                    is = new FileInputStream(f);\n                    ModelNode request = builder.buildRequest();\n                    OperationBuilder op = OperationBuilder.Factory.create(request);\n                    op.addInputStream(is);\n                    request.get(\"input-stream-index\").set(0);\n                    result = client.execute(op.build());\n                } catch (Exception e) {\n                    ctx.printLine(\"Failed to add the deployment content to the repository: \" + e.getLocalizedMessage());\n                    return;\n                } finally {\n                    StreamUtils.safeClose(is);\n                }\n                if (!Util.isSuccess(result)) {\n                    ctx.printLine(Util.getFailureDescription(result));\n                    return;\n                }\n            }\n\n            final ModelNode request;\n            // deploy\n            if (ctx.isDomainMode()) {\n                request = new ModelNode();\n                request.get(\"operation\").set(\"composite\");\n                request.get(\"address\").setEmptyList();\n                ModelNode steps = request.get(\"steps\");\n\n                for(String serverGroup : serverGroups) {\n                    steps.add(Util.configureDeploymentOperation(\"add\", name, serverGroup));\n                }\n\n                for(String serverGroup : serverGroups) {\n                    steps.add(Util.configureDeploymentOperation(\"deploy\", name, serverGroup));\n                }\n\n            } else {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"deploy\");\n                builder.addNode(\"deployment\", name);\n                try {\n                    request = builder.buildRequest();\n                } catch (Exception e) {\n                    ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n                    return;\n                }\n            }\n\n            try {\n                result = client.execute(request);\n            } catch (Exception e) {\n                ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n                return;\n            }\n\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(Util.getFailureDescription(result));\n                return;\n            }\n            ctx.printLine(\"'\" + name + \"' deployed successfully.\");\n        }\n    }","id":40197,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n\n        ParsedArguments args = ctx.getParsedArguments();\n        boolean l = this.l.isPresent(args);\n        if (!args.hasArguments() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                ctx.printLine(\"Path \" + f.getAbsolutePath() + \" doesn't exist.\");\n                return;\n            }\n        } else {\n            f = null;\n        }\n\n        String name = this.name.getValue(args);\n        if(name == null) {\n            if(f == null) {\n                ctx.printLine(\"Either path or --name is requied.\");\n                return;\n            }\n            name = f.getName();\n        }\n\n        String runtimeName = rtName.getValue(args);\n\n        if(Util.isDeploymentInRepository(name, client) && f != null) {\n            if(force.isPresent(args)) {\n                DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n\n                ModelNode result;\n\n                // replace\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"full-replace-deployment\");\n                builder.addProperty(\"name\", name);\n                if(runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                FileInputStream is = null;\n                try {\n                    is = new FileInputStream(f);\n                    ModelNode request = builder.buildRequest();\n                    OperationBuilder op = OperationBuilder.Factory.create(request);\n                    op.addInputStream(is);\n                    request.get(\"input-stream-index\").set(0);\n                    result = client.execute(op.build());\n                } catch(Exception e) {\n                    ctx.printLine(\"Failed to replace the deployment: \" + e.getLocalizedMessage());\n                    return;\n                } finally {\n                    StreamUtils.safeClose(is);\n                }\n                if(!Util.isSuccess(result)) {\n                    ctx.printLine(Util.getFailureDescription(result));\n                    return;\n                }\n\n                ctx.printLine(\"'\" + name + \"' re-deployed successfully.\");\n            } else {\n                ctx.printLine(\"'\" + name + \"' is already deployed (use \" + force.getDefaultName() + \" to force re-deploy).\");\n            }\n\n            return;\n        } else {\n\n            final List<String> serverGroups;\n            if (ctx.isDomainMode()) {\n                if(allServerGroups.isPresent(args)) {\n                    serverGroups = Util.getServerGroups(client);\n                } else {\n                    String serverGroupsStr = this.serverGroups.getValue(args);\n                    if(serverGroupsStr == null) {\n                        ctx.printLine(\"Either --all-server-groups or --server-groups must be specified.\");\n                        return;\n                    }\n                    serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                }\n\n                if(serverGroups.isEmpty()) {\n                    ctx.printLine(\"No server group is available.\");\n                    return;\n                }\n            } else {\n                serverGroups = null;\n            }\n\n            DefaultOperationRequestBuilder builder;\n\n            ModelNode result;\n\n            // add\n            if (f != null) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"add\");\n                builder.addNode(\"deployment\", name);\n                if (runtimeName != null) {\n                    builder.addProperty(\"runtime-name\", runtimeName);\n                }\n\n                FileInputStream is = null;\n                try {\n                    is = new FileInputStream(f);\n                    ModelNode request = builder.buildRequest();\n                    OperationBuilder op = OperationBuilder.Factory.create(request);\n                    op.addInputStream(is);\n                    request.get(\"input-stream-index\").set(0);\n                    result = client.execute(op.build());\n                } catch (Exception e) {\n                    ctx.printLine(\"Failed to add the deployment content to the repository: \" + e.getLocalizedMessage());\n                    return;\n                } finally {\n                    StreamUtils.safeClose(is);\n                }\n                if (!Util.isSuccess(result)) {\n                    ctx.printLine(Util.getFailureDescription(result));\n                    return;\n                }\n            }\n\n            final ModelNode request;\n            // deploy\n            if (ctx.isDomainMode()) {\n                request = new ModelNode();\n                request.get(\"operation\").set(\"composite\");\n                request.get(\"address\").setEmptyList();\n                ModelNode steps = request.get(\"steps\");\n\n                for(String serverGroup : serverGroups) {\n                    steps.add(Util.configureDeploymentOperation(\"add\", name, serverGroup));\n                }\n\n                for(String serverGroup : serverGroups) {\n                    steps.add(Util.configureDeploymentOperation(\"deploy\", name, serverGroup));\n                }\n\n            } else {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(\"deploy\");\n                builder.addNode(\"deployment\", name);\n                try {\n                    request = builder.buildRequest();\n                } catch (Exception e) {\n                    ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n                    return;\n                }\n            }\n\n            try {\n                result = client.execute(request);\n            } catch (Exception e) {\n                ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n                return;\n            }\n\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(Util.getFailureDescription(result));\n                return;\n            }\n            ctx.printLine(\"'\" + name + \"' deployed successfully.\");\n        }\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode buildRequest(CommandContext ctx) throws OperationFormatException {\n\n        ModelNode composite = new ModelNode();\n        composite.get(\"operation\").set(\"composite\");\n        composite.get(\"address\").setEmptyList();\n        ModelNode steps = composite.get(\"steps\");\n\n        final ParsedArguments args = ctx.getParsedArguments();\n        final String name = this.name.getValue(args);\n        if(name == null) {\n            throw new OperationFormatException(\"Required argument name are missing.\");\n        }\n\n        DefaultOperationRequestBuilder builder;\n\n        if(ctx.isDomainMode()) {\n            final List<String> serverGroups;\n            if(allServerGroups.isPresent(args)) {\n                serverGroups = Util.getServerGroups(ctx.getModelControllerClient());\n            } else {\n                final String serverGroupsStr = this.serverGroups.getValue(args);\n                if(serverGroupsStr == null) {\n                    throw new OperationFormatException(\"Either --all-server-groups or --server-groups must be specified.\");\n                }\n                serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n            }\n\n            if(serverGroups.isEmpty()) {\n                new OperationFormatException(\"No server group is available.\");\n            }\n\n            for (String group : serverGroups) {\n                ModelNode groupStep = Util.configureDeploymentOperation(DEPLOYMENT_UNDEPLOY_OPERATION, name, group);\n                steps.add(groupStep);\n            }\n\n            for (String group : serverGroups) {\n                ModelNode groupStep = Util.configureDeploymentOperation(DEPLOYMENT_REMOVE_OPERATION, name, group);\n                steps.add(groupStep);\n            }\n        } else {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"undeploy\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n\n        if (!keepContent.isPresent(args)) {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"remove\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n        return composite;\n    }","id":40198,"modified_method":"@Override\n    public ModelNode buildRequest(CommandContext ctx) throws OperationFormatException {\n\n        ModelNode composite = new ModelNode();\n        composite.get(\"operation\").set(\"composite\");\n        composite.get(\"address\").setEmptyList();\n        ModelNode steps = composite.get(\"steps\");\n\n        final ParsedArguments args = ctx.getParsedArguments();\n        final String name = this.name.getValue(args);\n        if(name == null) {\n            throw new OperationFormatException(\"Required argument name are missing.\");\n        }\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        boolean keepContent = this.keepContent.isPresent(args);\n        if(ctx.isDomainMode()) {\n            final List<String> serverGroups;\n            if(allRelevantServerGroups.isPresent(args)) {\n                if(keepContent) {\n                    serverGroups = Util.getAllEnabledServerGroups(name, client);\n                } else {\n                    serverGroups = Util.getAllReferencingServerGroups(name, client);\n                }\n            } else {\n                final String serverGroupsStr = this.serverGroups.getValue(args);\n                if(serverGroupsStr == null) {\n                    throw new OperationFormatException(\"Either --all-server-groups or --server-groups must be specified.\");\n                } else {\n                    serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                }\n            }\n\n/*            if(serverGroups.isEmpty()) {\n                throw new OperationFormatException(\"No server group is available.\");\n            }\n*/\n            for (String group : serverGroups) {\n                ModelNode groupStep = Util.configureDeploymentOperation(DEPLOYMENT_UNDEPLOY_OPERATION, name, group);\n                steps.add(groupStep);\n            }\n\n            if(!keepContent) {\n                for (String group : serverGroups) {\n                    ModelNode groupStep = Util.configureDeploymentOperation(DEPLOYMENT_REMOVE_OPERATION, name, group);\n                    steps.add(groupStep);\n                }\n            }\n        } else if(Util.isDeployedAndEnabledInStandalone(name, client)) {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"undeploy\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n\n        if (!keepContent) {\n            builder = new DefaultOperationRequestBuilder();\n            builder.setOperationName(\"remove\");\n            builder.addNode(\"deployment\", name);\n            steps.add(builder.buildRequest());\n        }\n        return composite;\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        ParsedArguments args = ctx.getParsedArguments();\n        boolean l = this.l.isPresent(args);\n        if(!args.hasArguments() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String name = this.name.getValue(ctx.getParsedArguments());\n        if (name == null) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (OperationFormatException e) {\n            ctx.printLine(e.getLocalizedMessage());\n            return;\n        }\n\n        ModelNode result;\n        try {\n            result = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Undeploy failed: \" + e.getLocalizedMessage());\n            return;\n        }\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(\"Undeploy failed: \" + Util.getFailureDescription(result));\n            return;\n        }\n\n        ctx.printLine(\"Successfully undeployed \" + name + \".\");\n    }","id":40199,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        ParsedArguments args = ctx.getParsedArguments();\n        boolean l = this.l.isPresent(args);\n        if(!args.hasArguments() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String name = this.name.getValue(ctx.getParsedArguments());\n        if (name == null) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (OperationFormatException e) {\n            ctx.printLine(e.getLocalizedMessage());\n            return;\n        }\n\n        ModelNode result;\n        try {\n            result = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Undeploy failed: \" + e.getLocalizedMessage());\n            return;\n        }\n        if (!Util.isSuccess(result)) {\n            if(ctx.isDomainMode()) {\n                ctx.printLine(\"Undeploy failed: \" + Util.getDomainFailureDescription(result));\n            } else {\n                ctx.printLine(\"Undeploy failed: \" + Util.getFailureDescription(result));\n            }\n            return;\n        }\n\n        ctx.printLine(\"Successfully undeployed \" + name + \".\");\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public UndeployHandler() {\n        super(\"undeploy\", true);\n\n        SimpleArgumentTabCompleter argsCompleter = (SimpleArgumentTabCompleter) this.getArgumentCompleter();\n\n        l = new ArgumentWithoutValue(\"-l\");\n        l.setExclusive(true);\n        argsCompleter.addArgument(l);\n\n        name = new ArgumentWithValue(false, new CommandLineCompleter() {\n            @Override\n            public int complete(CommandContext ctx, String buffer, int cursor, List<String> candidates) {\n\n                int nextCharIndex = 0;\n                while (nextCharIndex < buffer.length()) {\n                    if (!Character.isWhitespace(buffer.charAt(nextCharIndex))) {\n                        break;\n                    }\n                    ++nextCharIndex;\n                }\n\n                if(ctx.getModelControllerClient() != null) {\n                    List<String> deployments = Util.getDeployments(ctx.getModelControllerClient());\n                    if(deployments.isEmpty()) {\n                        return -1;\n                    }\n\n                    String opBuffer = buffer.substring(nextCharIndex).trim();\n                    if (opBuffer.isEmpty()) {\n                        candidates.addAll(deployments);\n                    } else {\n                        for(String name : deployments) {\n                            if(name.startsWith(opBuffer)) {\n                                candidates.add(name);\n                            }\n                        }\n                        Collections.sort(candidates);\n                    }\n                    return nextCharIndex;\n                } else {\n                    return -1;\n                }\n\n            }}, 0, \"--name\");\n        name.addCantAppearAfter(l);\n        argsCompleter.addArgument(name);\n\n        allServerGroups = new ArgumentWithoutValue(\"--all-server-groups\") {\n            @Override\n            public boolean isAvailable(CommandContext ctx) {\n                return ctx.isDomainMode();\n            }\n        };\n        argsCompleter.addArgument(allServerGroups);\n        allServerGroups.addRequiredPreceding(name);\n\n        serverGroups = new ArgumentWithValue(false, new CommandLineCompleter() {\n            @Override\n            public int complete(CommandContext ctx, String buffer, int cursor, List<String> candidates) {\n                List<String> allGroups = Util.getServerGroups(ctx.getModelControllerClient());\n                if(buffer.isEmpty()) {\n                    candidates.addAll(allGroups);\n                    Collections.sort(candidates);\n                    return 0;\n                }\n\n                final String[] groups = buffer.split(\",+\");\n\n                final String chunk;\n                final int lastGroupIndex;\n                if(buffer.charAt(buffer.length() - 1) == ',') {\n                    lastGroupIndex = groups.length;\n                    chunk = null;\n                } else {\n                    lastGroupIndex = groups.length - 1;\n                    chunk = groups[groups.length - 1];\n                }\n\n                for(int i = 0; i < lastGroupIndex; ++i) {\n                    allGroups.remove(groups[i]);\n                }\n\n                final int result;\n                if(chunk == null) {\n                    candidates.addAll(allGroups);\n                    result = buffer.length();\n                } else {\n                    for(String group : allGroups) {\n                        if(group.startsWith(chunk)) {\n                            candidates.add(group);\n                        }\n                    }\n                    result = buffer.lastIndexOf(',') + 1;\n                }\n                Collections.sort(candidates);\n                return result;\n            }}, \"--server-groups\") {\n            @Override\n            public boolean isAvailable(CommandContext ctx) {\n                return ctx.isDomainMode();\n            }\n        };\n        serverGroups.addRequiredPreceding(name);\n        argsCompleter.addArgument(serverGroups);\n\n        serverGroups.addCantAppearAfter(allServerGroups);\n        allServerGroups.addCantAppearAfter(serverGroups);\n\n        keepContent = new ArgumentWithoutValue(\"--keep-content\");\n        argsCompleter.addArgument(keepContent);\n        keepContent.addRequiredPreceding(name);\n    }","id":40200,"modified_method":"public UndeployHandler() {\n        super(\"undeploy\", true);\n\n        SimpleArgumentTabCompleter argsCompleter = (SimpleArgumentTabCompleter) this.getArgumentCompleter();\n\n        l = new ArgumentWithoutValue(\"-l\");\n        l.setExclusive(true);\n        argsCompleter.addArgument(l);\n\n        name = new ArgumentWithValue(false, new CommandLineCompleter() {\n            @Override\n            public int complete(CommandContext ctx, String buffer, int cursor, List<String> candidates) {\n\n                int nextCharIndex = 0;\n                while (nextCharIndex < buffer.length()) {\n                    if (!Character.isWhitespace(buffer.charAt(nextCharIndex))) {\n                        break;\n                    }\n                    ++nextCharIndex;\n                }\n\n                if(ctx.getModelControllerClient() != null) {\n                    List<String> deployments = Util.getDeployments(ctx.getModelControllerClient());\n                    if(deployments.isEmpty()) {\n                        return -1;\n                    }\n\n                    String opBuffer = buffer.substring(nextCharIndex).trim();\n                    if (opBuffer.isEmpty()) {\n                        candidates.addAll(deployments);\n                    } else {\n                        for(String name : deployments) {\n                            if(name.startsWith(opBuffer)) {\n                                candidates.add(name);\n                            }\n                        }\n                        Collections.sort(candidates);\n                    }\n                    return nextCharIndex;\n                } else {\n                    return -1;\n                }\n\n            }}, 0, \"--name\");\n        name.addCantAppearAfter(l);\n        argsCompleter.addArgument(name);\n\n        allRelevantServerGroups = new ArgumentWithoutValue(\"--all-relevant-server-groups\") {\n            @Override\n            public boolean isAvailable(CommandContext ctx) {\n                return ctx.isDomainMode();\n            }\n        };\n        argsCompleter.addArgument(allRelevantServerGroups);\n        allRelevantServerGroups.addRequiredPreceding(name);\n\n        serverGroups = new ArgumentWithValue(false, new CommandLineCompleter() {\n            @Override\n            public int complete(CommandContext ctx, String buffer, int cursor, List<String> candidates) {\n                List<String> allGroups = Util.getServerGroups(ctx.getModelControllerClient());\n                if(buffer.isEmpty()) {\n                    candidates.addAll(allGroups);\n                    Collections.sort(candidates);\n                    return 0;\n                }\n\n                final String[] groups = buffer.split(\",+\");\n\n                final String chunk;\n                final int lastGroupIndex;\n                if(buffer.charAt(buffer.length() - 1) == ',') {\n                    lastGroupIndex = groups.length;\n                    chunk = null;\n                } else {\n                    lastGroupIndex = groups.length - 1;\n                    chunk = groups[groups.length - 1];\n                }\n\n                for(int i = 0; i < lastGroupIndex; ++i) {\n                    allGroups.remove(groups[i]);\n                }\n\n                final int result;\n                if(chunk == null) {\n                    candidates.addAll(allGroups);\n                    result = buffer.length();\n                } else {\n                    for(String group : allGroups) {\n                        if(group.startsWith(chunk)) {\n                            candidates.add(group);\n                        }\n                    }\n                    result = buffer.lastIndexOf(',') + 1;\n                }\n                Collections.sort(candidates);\n                return result;\n            }}, \"--server-groups\") {\n            @Override\n            public boolean isAvailable(CommandContext ctx) {\n                return ctx.isDomainMode();\n            }\n        };\n        serverGroups.addRequiredPreceding(name);\n        argsCompleter.addArgument(serverGroups);\n\n        serverGroups.addCantAppearAfter(allRelevantServerGroups);\n        allRelevantServerGroups.addCantAppearAfter(serverGroups);\n\n        keepContent = new ArgumentWithoutValue(\"--keep-content\");\n        argsCompleter.addArgument(keepContent);\n        keepContent.addRequiredPreceding(name);\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static boolean isDeployed(String name, ModelControllerClient client) {\n        return getDeployments(client).contains(name);\n    }","id":40201,"modified_method":"public static boolean isDeployedAndEnabledInStandalone(String name, ModelControllerClient client) {\n\n        DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        ModelNode request;\n        try {\n            builder.operationName(\"read-children-names\");\n            builder.addProperty(\"child-type\", \"deployment\");\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                if(!listContains(outcome, name)) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n\n        builder = new DefaultOperationRequestBuilder();\n        builder.addNode(\"deployment\", name);\n        builder.setOperationName(\"read-attribute\");\n        builder.addProperty(\"name\", \"enabled\");\n        try {\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                if(!outcome.hasDefined(\"result\")) {\n                    return false;\n                }\n                return outcome.get(\"result\").asBoolean();\n            }\n        } catch(Exception e) {\n        }\n        return false;\n    }","commit_id":"e9917ff52df030323ac3c9f636d2a649e619f2cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void handleResponse(CommandContext ctx, ModelNode result) {\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(Util.getFailureDescription(result));\n            return;\n        }\n    }","id":40202,"modified_method":"protected void handleResponse(CommandContext ctx, ModelNode result, boolean composite) {\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(Util.getFailureDescription(result));\n            return;\n        }\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (CommandFormatException e1) {\n            ctx.printLine(e1.getLocalizedMessage());\n            return;\n        }\n\n        if(request == null) {\n            ctx.printLine(\"Operation request wasn't built.\");\n            return;\n        }\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        final ModelNode result;\n        try {\n            result = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to perform operation: \" + e.getLocalizedMessage());\n            return;\n        }\n        handleResponse(ctx, result);\n    }","id":40203,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        ModelNode request;\n        try {\n            request = buildRequest(ctx);\n        } catch (CommandFormatException e1) {\n            ctx.printLine(e1.getLocalizedMessage());\n            return;\n        }\n\n        if(request == null) {\n            ctx.printLine(\"Operation request wasn't built.\");\n            return;\n        }\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        final ModelNode result;\n        try {\n            result = client.execute(request);\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to perform operation: \" + e.getLocalizedMessage());\n            return;\n        }\n        handleResponse(ctx, result, Util.COMPOSITE.equals(request.get(Util.OPERATION).asString()));\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode getOperationDescription(CommandContext ctx, String operationName) throws IOException {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return null;\n        }\n        request.get(\"operation\").set(\"read-operation-description\");\n        request.get(\"name\").set(operationName);\n\n        ModelNode result = ctx.getModelControllerClient().execute(request);\n        if (!result.hasDefined(\"result\")) {\n            return null;\n        }\n        return result.get(\"result\");\n    }","id":40204,"modified_method":"protected ModelNode getOperationDescription(CommandContext ctx, String operationName) throws IOException {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return null;\n        }\n        request.get(Util.OPERATION).set(Util.READ_OPERATION_DESCRIPTION);\n        request.get(Util.NAME).set(operationName);\n        ModelNode result = ctx.getModelControllerClient().execute(request);\n        if (!result.hasDefined(Util.RESULT)) {\n            return null;\n        }\n        return result.get(Util.RESULT);\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void printNodeDescription(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return;\n        }\n        request.get(\"operation\").set(\"read-resource-description\");\n\n        try {\n            ModelNode result = ctx.getModelControllerClient().execute(request);\n            if(!result.hasDefined(\"result\")) {\n                ctx.printLine(\"Node description is not available.\");\n                return;\n            }\n            result = result.get(\"result\");\n            if(!result.hasDefined(\"description\")) {\n                ctx.printLine(\"Node description is not available.\");\n                return;\n            }\n            ctx.printLine(result.get(\"description\").asString());\n        } catch (Exception e) {\n        }\n    }","id":40205,"modified_method":"protected void printNodeDescription(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return;\n        }\n        request.get(Util.OPERATION).set(Util.READ_RESOURCE_DESCRIPTION);\n        ModelNode result = null;\n        try {\n            result = ctx.getModelControllerClient().execute(request);\n            if(!result.hasDefined(Util.RESULT)) {\n                ctx.printLine(\"Node description is not available.\");\n                return;\n            }\n            result = result.get(Util.RESULT);\n            if(!result.hasDefined(Util.DESCRIPTION)) {\n                ctx.printLine(\"Node description is not available.\");\n                return;\n            }\n        } catch (Exception e) {\n        }\n\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(\"\\nSYNOPSIS\\n\\n\");\n        buf.append(commandName).append(\" --help [--properties | --commands] |\\n\");\n        for(int i = 0; i <= commandName.length(); ++i) {\n            buf.append(' ');\n        }\n        buf.append(name.getFullName()).append(\"=<value> --<property>=<value> (--<property>=<value>)* |\\n\");\n        for(int i = 0; i <= commandName.length(); ++i) {\n            buf.append(' ');\n        }\n        buf.append(\"<command> \").append(name.getFullName()).append(\"=<value> (--<parameter>=<value>)*\");\n\n        buf.append(\"\\n\\nThe command is used to manage resources of type \" + this.nodeType + \".\");\n\n        buf.append(\"\\n\\nRESOURCE DESCRIPTION\\n\\n\");\n        if(result != null) {\n            buf.append(result.get(Util.DESCRIPTION).asString());\n        } else {\n            buf.append(\"N/A. Please, open a jira issue at https://issues.jboss.org/browse/AS7 to get this fixed. Thanks!\");\n        }\n\n        buf.append(\"\\n\\nARGUMENTS\\n\");\n\n        buf.append(\"\\n--help                - prints this content.\");\n        buf.append(\"\\n--help --properties   - prints the list of the resource properties including their access-type\");\n        buf.append(\"\\n                        (read/write/metric), value type, and the description.\");\n        buf.append(\"\\n--help --commands     - prints the list of the commands available for the resource.\");\n        buf.append(\"\\n                        To get the complete description of a specific command (including its parameters,\");\n        buf.append(\"\\n                        their types and descriptions), execute \").append(commandName).append(\" <command> --help.\");\n\n        buf.append(\"\\n\\n\").append(name.getFullName()).append(\"   - \");\n        if(idProperty == null) {\n            buf.append(\"is the name of the resource that completes the path \").append(nodeType).append(\" and \\n\");\n        } else {\n            buf.append(\"corresponds to a property of the resourse which \\n\");\n        }\n        for(int i = 0; i < name.getFullName().length() + 5; ++i) {\n            buf.append(' ');\n        }\n        buf.append(\"is used to identify the resourse against which the command should be executed.\");\n\n        buf.append(\"\\n\\n<property>   - property name of the resourse whose value should be updated.\");\n        buf.append(\"\\n               For a complete list of available property names, their types and descriptions,\");\n        buf.append(\"\\n               execute \").append(commandName).append(\" --help --properties.\");\n\n        buf.append(\"\\n\\n<command>    - command name provided by the resourse. For a complete list of available commands,\");\n        buf.append(\"\\n               execute \").append(commandName).append(\" --help --commands.\");\n\n        buf.append(\"\\n\\n<parameter>  - parameter name of the <command> provided by the resourse.\");\n        buf.append(\"\\n               For a complete list of available parameter names of a specific <command>,\");\n        buf.append(\"\\n               their types and descriptions, execute \").append(commandName).append(\" <command> --help.\");\n\n        ctx.printLine(buf.toString());\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleResponse(CommandContext ctx, ModelNode opResult) {\n        if (!Util.isSuccess(opResult)) {\n            ctx.printLine(Util.getFailureDescription(opResult));\n            return;\n        }\n\n        if(opResult.hasDefined(Util.RESULT)) {\n            final ModelNode result = opResult.get(Util.RESULT);\n            final ModelNodeFormatter formatter = ModelNodeFormatter.Factory.forType(result.getType());\n            final StringBuilder buf = new StringBuilder();\n            formatter.format(buf, 0, result);\n            ctx.printLine(buf.toString());\n        }\n    }","id":40206,"modified_method":"@Override\n    protected void handleResponse(CommandContext ctx, ModelNode opResponse, boolean composite) {\n        if (!Util.isSuccess(opResponse)) {\n            ctx.printLine(Util.getFailureDescription(opResponse));\n            return;\n        }\n        final StringBuilder buf = formatResponse(ctx, opResponse, composite, null);\n        if(buf != null) {\n            ctx.printLine(buf.toString());\n        }\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode initRequest(CommandContext ctx) {\n        ModelNode request = new ModelNode();\n        ModelNode address = request.get(\"address\");\n        if(ctx.isDomainMode()) {\n            final String profileName = profile.getValue(ctx.getParsedCommandLine());\n            if(profile == null) {\n                ctx.printLine(\"--profile argument is required to get the node description.\");\n                return null;\n            }\n            address.add(\"profile\", profileName);\n        }\n        for(OperationRequestAddress.Node node : nodePath) {\n            address.add(node.getType(), node.getName());\n        }\n        address.add(type, \"?\");\n        return request;\n    }","id":40207,"modified_method":"protected ModelNode initRequest(CommandContext ctx) {\n        ModelNode request = new ModelNode();\n        ModelNode address = request.get(Util.ADDRESS);\n        if(ctx.isDomainMode()) {\n            final String profileName = profile.getValue(ctx.getParsedCommandLine());\n            if(profile == null) {\n                ctx.printLine(\"--profile argument is required to get the node description.\");\n                return null;\n            }\n            address.add(Util.PROFILE, profileName);\n        }\n        for(OperationRequestAddress.Node node : nodePath) {\n            address.add(node.getType(), node.getName());\n        }\n        address.add(type, \"?\");\n        return request;\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode buildWritePropertyRequest(CommandContext ctx) throws CommandFormatException {\n\n        final String name = this.name.getValue(ctx.getParsedCommandLine(), true);\n\n        ModelNode composite = new ModelNode();\n        composite.get(\"operation\").set(\"composite\");\n        composite.get(\"address\").setEmptyList();\n        ModelNode steps = composite.get(\"steps\");\n\n        ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String profile;\n        if(ctx.isDomainMode()) {\n            profile = this.profile.getValue(args);\n            if(profile == null) {\n                throw new OperationFormatException(\"--profile argument value is missing.\");\n            }\n        } else {\n            profile = null;\n        }\n\n        final Map<String,CommandArgument> nodeProps = loadArguments(ctx, null);\n        for(String argName : args.getPropertyNames()) {\n            if(argName.equals(\"--profile\") || this.name.getFullName().equals(argName)) {\n                continue;\n            }\n\n            final ArgumentWithValue arg = (ArgumentWithValue) nodeProps.get(argName);\n            if(arg == null) {\n                throw new CommandFormatException(\"Unrecognized argument name '\" + argName + \"'\");\n            }\n\n            DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n            if (profile != null) {\n                builder.addNode(\"profile\", profile);\n            }\n\n            for(OperationRequestAddress.Node node : nodePath) {\n                builder.addNode(node.getType(), node.getName());\n            }\n            builder.addNode(type, name);\n            builder.setOperationName(\"write-attribute\");\n            final String propName;\n            if(argName.charAt(1) == '-') {\n                propName = argName.substring(2);\n            } else {\n                propName = argName.substring(1);\n            }\n            builder.addProperty(\"name\", propName);\n\n            final String valueString = args.getPropertyValue(argName);\n            ModelNode nodeValue = arg.getValueConverter().fromString(valueString);\n            builder.getModelNode().get(\"value\").set(nodeValue);\n\n            steps.add(builder.buildRequest());\n        }\n\n        return composite;\n    }","id":40208,"modified_method":"protected ModelNode buildWritePropertyRequest(CommandContext ctx) throws CommandFormatException {\n\n        final String name = this.name.getValue(ctx.getParsedCommandLine(), true);\n\n        ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        ModelNode steps = composite.get(Util.STEPS);\n\n        ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String profile;\n        if(ctx.isDomainMode()) {\n            profile = this.profile.getValue(args);\n            if(profile == null) {\n                throw new OperationFormatException(\"--profile argument value is missing.\");\n            }\n        } else {\n            profile = null;\n        }\n\n        final Map<String,CommandArgument> nodeProps = loadArguments(ctx, null);\n        for(String argName : args.getPropertyNames()) {\n            if(argName.equals(\"--profile\") || this.name.getFullName().equals(argName)) {\n                continue;\n            }\n\n            final ArgumentWithValue arg = (ArgumentWithValue) nodeProps.get(argName);\n            if(arg == null) {\n                throw new CommandFormatException(\"Unrecognized argument name '\" + argName + \"'\");\n            }\n\n            DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n            if (profile != null) {\n                builder.addNode(\"profile\", profile);\n            }\n\n            for(OperationRequestAddress.Node node : nodePath) {\n                builder.addNode(node.getType(), node.getName());\n            }\n            builder.addNode(type, name);\n            builder.setOperationName(\"write-attribute\");\n            final String propName;\n            if(argName.charAt(1) == '-') {\n                propName = argName.substring(2);\n            } else {\n                propName = argName.substring(1);\n            }\n            builder.addProperty(\"name\", propName);\n\n            final String valueString = args.getPropertyValue(argName);\n            ModelNode nodeValue = arg.getValueConverter().fromString(valueString);\n            builder.getModelNode().get(\"value\").set(nodeValue);\n\n            steps.add(builder.buildRequest());\n        }\n\n        return composite;\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected List<Property> getNodeProperties(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return Collections.emptyList();\n        }\n        request.get(\"operation\").set(\"read-resource-description\");\n\n        ModelNode result;\n        try {\n            result = ctx.getModelControllerClient().execute(request);\n        } catch (IOException e) {\n            return Collections.emptyList();\n        }\n        if(!result.hasDefined(\"result\")) {\n            return Collections.emptyList();\n        }\n        result = result.get(\"result\");\n        if(!result.hasDefined(\"attributes\")) {\n            return Collections.emptyList();\n        }\n\n        return result.get(\"attributes\").asPropertyList();\n    }","id":40209,"modified_method":"protected List<Property> getNodeProperties(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return Collections.emptyList();\n        }\n        request.get(Util.OPERATION).set(Util.READ_RESOURCE_DESCRIPTION);\n        ModelNode result;\n        try {\n            result = ctx.getModelControllerClient().execute(request);\n        } catch (IOException e) {\n            return Collections.emptyList();\n        }\n        if(!result.hasDefined(Util.RESULT)) {\n            return Collections.emptyList();\n        }\n        result = result.get(Util.RESULT);\n        if(!result.hasDefined(Util.ATTRIBUTES)) {\n            return Collections.emptyList();\n        }\n        return result.get(Util.ATTRIBUTES).asPropertyList();\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void printCommands(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return;\n        }\n        request.get(\"operation\").set(\"read-operation-names\");\n\n        try {\n            ModelNode result = ctx.getModelControllerClient().execute(request);\n            if(!result.hasDefined(\"result\")) {\n                ctx.printLine(\"Operation names aren't available.\");\n                return;\n            }\n            final List<String> list = Util.getList(result);\n            list.removeAll(this.excludeOps);\n            list.add(\"To read the description of a specific command execute '\" + this.commandName + \" command_name --help'.\");\n            for(String name : list) {\n                ctx.printLine(name);\n            }\n        } catch (Exception e) {\n        }\n    }","id":40210,"modified_method":"protected void printCommands(CommandContext ctx) {\n        ModelNode request = initRequest(ctx);\n        if(request == null) {\n            return;\n        }\n        request.get(Util.OPERATION).set(Util.READ_OPERATION_NAMES);\n        try {\n            ModelNode result = ctx.getModelControllerClient().execute(request);\n            if(!result.hasDefined(\"result\")) {\n                ctx.printLine(\"Operation names aren't available.\");\n                return;\n            }\n            final List<String> list = Util.getList(result);\n            list.removeAll(this.excludeOps);\n            list.add(\"To read the description of a specific command execute '\" + this.commandName + \" command_name --help'.\");\n            for(String name : list) {\n                ctx.printLine(name);\n            }\n        } catch (Exception e) {\n        }\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public GenericTypeOperationHandler(String nodeType, String idProperty, List<String> excludeOperations) {\n\n        super(\"generic-type-operation\", true);\n\n        helpArg = new ArgumentWithoutValue(this, \"--help\", \"-h\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n\n        nodePath = new DefaultOperationRequestAddress();\n        CommandLineParser.CallbackHandler handler = new DefaultCallbackHandler(nodePath);\n        try {\n            ParserUtil.parseOperationRequest(nodeType, handler);\n        } catch (CommandFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse nodeType: \" + e.getMessage());\n        }\n\n        if(!nodePath.endsOnType()) {\n            throw new IllegalArgumentException(\"The node path doesn't end on a type: '\" + nodeType + \"'\");\n        }\n        this.type = nodePath.getNodeType();\n        nodePath.toParentNode();\n        addRequiredPath(nodePath);\n        this.commandName = type;\n        this.idProperty = idProperty;\n\n        this.excludeOps = excludeOperations;\n\n        profile = new ArgumentWithValue(this, new DefaultCompleter(new CandidatesProvider(){\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                return Util.getNodeNames(ctx.getModelControllerClient(), null, \"profile\");\n            }}), \"--profile\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(!ctx.isDomainMode()) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        //profile.addCantAppearAfter(helpArg);\n\n        operation = new ArgumentWithValue(this, new DefaultCompleter(new CandidatesProvider(){\n                @Override\n                public Collection<String> getAllCandidates(CommandContext ctx) {\n                    DefaultOperationRequestAddress address = new DefaultOperationRequestAddress();\n                    if(ctx.isDomainMode()) {\n                        final String profileName = profile.getValue(ctx.getParsedCommandLine());\n                        if(profileName == null) {\n                            return Collections.emptyList();\n                        }\n                        address.toNode(\"profile\", profileName);\n                    }\n\n                    for(OperationRequestAddress.Node node : nodePath) {\n                        address.toNode(node.getType(), node.getName());\n                    }\n                    address.toNode(type, \"?\");\n                    Collection<String> ops = ctx.getOperationCandidatesProvider().getOperationNames(ctx, address);\n                    ops.removeAll(excludeOps);\n                    return ops;\n                }}), 0, \"--operation\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        operation.addCantAppearAfter(helpArg);\n\n        name = new ArgumentWithValue(this, new DefaultCompleter(new DefaultCompleter.CandidatesProvider() {\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                ModelControllerClient client = ctx.getModelControllerClient();\n                if (client == null) {\n                    return Collections.emptyList();\n                    }\n\n                DefaultOperationRequestAddress address = new DefaultOperationRequestAddress();\n                if(ctx.isDomainMode()) {\n                    final String profileName = profile.getValue(ctx.getParsedCommandLine());\n                    if(profile == null) {\n                        return Collections.emptyList();\n                    }\n                    address.toNode(\"profile\", profileName);\n                }\n\n                for(OperationRequestAddress.Node node : nodePath) {\n                    address.toNode(node.getType(), node.getName());\n                }\n\n                return Util.getNodeNames(ctx.getModelControllerClient(), address, type);\n                }\n            }), (idProperty == null ? \"--name\" : \"--\" + idProperty)) {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        name.addCantAppearAfter(helpArg);\n\n        helpArg.addCantAppearAfter(name);\n\n        helpProperties = new ArgumentWithoutValue(this, \"--properties\");\n        helpProperties.addRequiredPreceding(helpArg);\n        helpProperties.addCantAppearAfter(operation);\n\n        helpCommands = new ArgumentWithoutValue(this, \"--commands\");\n        helpCommands.addRequiredPreceding(helpArg);\n        helpCommands.addCantAppearAfter(operation);\n        helpCommands.addCantAppearAfter(helpProperties);\n        helpProperties.addCantAppearAfter(helpCommands);\n\n\n        ///\n        staticArgs.add(helpArg);\n        staticArgs.add(helpCommands);\n        staticArgs.add(helpProperties);\n        staticArgs.add(profile);\n        staticArgs.add(name);\n        staticArgs.add(operation);\n    }","id":40211,"modified_method":"public GenericTypeOperationHandler(String nodeType, String idProperty, List<String> excludeOperations) {\n\n        super(\"generic-type-operation\", true);\n\n        if(nodeType == null) {\n            throw new IllegalArgumentException(\"Node type is null.\");\n        }\n        this.nodeType = nodeType;\n\n        helpArg = new ArgumentWithoutValue(this, \"--help\", \"-h\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n\n        nodePath = new DefaultOperationRequestAddress();\n        CommandLineParser.CallbackHandler handler = new DefaultCallbackHandler(nodePath);\n        try {\n            ParserUtil.parseOperationRequest(nodeType, handler);\n        } catch (CommandFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse nodeType: \" + e.getMessage());\n        }\n\n        if(!nodePath.endsOnType()) {\n            throw new IllegalArgumentException(\"The node path doesn't end on a type: '\" + nodeType + \"'\");\n        }\n        this.type = nodePath.getNodeType();\n        nodePath.toParentNode();\n        addRequiredPath(nodePath);\n        this.commandName = type;\n        this.idProperty = idProperty;\n\n        this.excludeOps = excludeOperations;\n\n        profile = new ArgumentWithValue(this, new DefaultCompleter(new CandidatesProvider(){\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                return Util.getNodeNames(ctx.getModelControllerClient(), null, \"profile\");\n            }}), \"--profile\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(!ctx.isDomainMode()) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        //profile.addCantAppearAfter(helpArg);\n\n        operation = new ArgumentWithValue(this, new DefaultCompleter(new CandidatesProvider(){\n                @Override\n                public Collection<String> getAllCandidates(CommandContext ctx) {\n                    DefaultOperationRequestAddress address = new DefaultOperationRequestAddress();\n                    if(ctx.isDomainMode()) {\n                        final String profileName = profile.getValue(ctx.getParsedCommandLine());\n                        if(profileName == null) {\n                            return Collections.emptyList();\n                        }\n                        address.toNode(\"profile\", profileName);\n                    }\n\n                    for(OperationRequestAddress.Node node : nodePath) {\n                        address.toNode(node.getType(), node.getName());\n                    }\n                    address.toNode(type, \"?\");\n                    Collection<String> ops = ctx.getOperationCandidatesProvider().getOperationNames(ctx, address);\n                    ops.removeAll(excludeOps);\n                    return ops;\n                }}), 0, \"--operation\") {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        operation.addCantAppearAfter(helpArg);\n\n        name = new ArgumentWithValue(this, new DefaultCompleter(new DefaultCompleter.CandidatesProvider() {\n            @Override\n            public List<String> getAllCandidates(CommandContext ctx) {\n                ModelControllerClient client = ctx.getModelControllerClient();\n                if (client == null) {\n                    return Collections.emptyList();\n                    }\n\n                DefaultOperationRequestAddress address = new DefaultOperationRequestAddress();\n                if(ctx.isDomainMode()) {\n                    final String profileName = profile.getValue(ctx.getParsedCommandLine());\n                    if(profile == null) {\n                        return Collections.emptyList();\n                    }\n                    address.toNode(\"profile\", profileName);\n                }\n\n                for(OperationRequestAddress.Node node : nodePath) {\n                    address.toNode(node.getType(), node.getName());\n                }\n\n                return Util.getNodeNames(ctx.getModelControllerClient(), address, type);\n                }\n            }), (idProperty == null ? \"--name\" : \"--\" + idProperty)) {\n            @Override\n            public boolean canAppearNext(CommandContext ctx) throws CommandFormatException {\n                if(ctx.isDomainMode() && !profile.isValueComplete(ctx.getParsedCommandLine())) {\n                    return false;\n                }\n                return super.canAppearNext(ctx);\n            }\n        };\n        name.addCantAppearAfter(helpArg);\n\n        helpArg.addCantAppearAfter(name);\n\n        helpProperties = new ArgumentWithoutValue(this, \"--properties\");\n        helpProperties.addRequiredPreceding(helpArg);\n        helpProperties.addCantAppearAfter(operation);\n\n        helpCommands = new ArgumentWithoutValue(this, \"--commands\");\n        helpCommands.addRequiredPreceding(helpArg);\n        helpCommands.addCantAppearAfter(operation);\n        helpCommands.addCantAppearAfter(helpProperties);\n        helpProperties.addCantAppearAfter(helpCommands);\n\n\n        ///\n        staticArgs.add(helpArg);\n        staticArgs.add(helpCommands);\n        staticArgs.add(helpProperties);\n        staticArgs.add(profile);\n        staticArgs.add(name);\n        staticArgs.add(operation);\n    }","commit_id":"9a39fc25409dc3a54ed364fa803dc6556bee49a1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ContainerGUI() {\n\t\tsuper(\"CCN Tree [Popup Menus]\");\n\t\t\n\t\tsetupNameEnumerator();\n\n\t\tsetSize(400, 300);\n\n\t\tDefaultMutableTreeNode top = new DefaultMutableTreeNode(new IconData(\n\t\t\t\tICON_COMPUTER, null, \"/parc.com\"));\n\n\t\tDefaultMutableTreeNode node = null;\n\t\t// get whatever things I need at this point\n\t\t// query ccnd for stuff and stick it into the array\n\n\t\ttry {\n\t\t\tnode = new DefaultMutableTreeNode(new IconData(ICON_FOLDER, null,\n\t\t\t\t\tnew Name(\"files\", ContentName\n\t\t\t\t\t\t\t.fromNative(\"/parc.com\"))));\n\t\t\tnode.add(new DefaultMutableTreeNode( new Boolean(true) ));\n\t\t\tusableRoot = node;\n\t\t} catch (MalformedContentNameStringException e1) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\tSystem.out.println(\"Error in the content name\");\n\t\t\te1.printStackTrace();\n\t\t}\n\t\ttop.add(node);\n\n\t\t// File[] roots = File.listRoots();\n\t\t// for (int k=0; k<roots.length; k++)\n\t\t// {\n\t\t// node = new DefaultMutableTreeNode(new IconData(ICON_DISK,\n\t\t// null, new FileNode(roots[k])));\n\t\t// top.add(node);\n\t\t// node.add(new DefaultMutableTreeNode( new Boolean(true) ));\n\t\t// }\n\n\t\tm_model = new DefaultTreeModel(top);\n\t\ttree = new JTree(m_model);\n\n\t\ttree.putClientProperty(\"JTree.lineStyle\", \"Angled\");\n\n\t\tTreeCellRenderer renderer = new IconCellRenderer();\n\t\ttree.setCellRenderer(renderer);\n\n\t\ttree.addTreeSelectionListener(new DirSelectionListener());\n\n\t\ttree.getSelectionModel().setSelectionMode(\n\t\t\t\tTreeSelectionModel.SINGLE_TREE_SELECTION);\n\t\ttree.setShowsRootHandles(true);\n\t\ttree.setEditable(false);\n\n\t\t// JScrollPane treeView = new JScrollPane();\n\t\tString filename = File.separator + \"tmp\";\n\t\tJFileChooser fc = new JFileChooser(new File(filename));\n\n\t\tclass OpenFileAction extends AbstractAction {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\tJFrame frame;\n\t\t\tJFileChooser chooser;\n\n\t\t\tOpenFileAction(JFrame frame, JFileChooser chooser) {\n\t\t\t\tsuper(\"Send to Repo...\");\n\t\t\t\tthis.chooser = chooser;\n\t\t\t\tthis.frame = frame;\n\t\t\t}\n\n\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t// Show dialog; this method does not return until dialog is\n\t\t\t\t// closed\n\t\t\t\tint returnVal = chooser.showOpenDialog(frame);\n\n\t\t\t\t// Get the selected file\n\t\t\t\tFile file = chooser.getSelectedFile();\n\t\t\t\tif(file == null || file.getName().equals(\"\")){\n\t\t\t\t\tSystem.out.println(\"the user did not select a file\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//what if the user hits cancel...\n\t\t\t\tif(returnVal != JFileChooser.APPROVE_OPTION){\n\t\t\t\t\tSystem.out.println(\"user cancelled the send to repo option...  returning\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"Writing a file to the repo \" + file.getAbsolutePath() + \" \" + file.getName());\n\t\t\t\tSystem.out.println(\"Selected Node is \" + selectedPrefix);\n\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(\"Sending file \" + selectedPrefix + \"/\"\n\t\t\t\t\t\t\t+ file.getName());\n\t\t\t\t\tRepositoryOutputStream ros = _library.repoOpen(ContentName\n\t\t\t\t\t\t\t.fromNative(selectedPrefix + \"/\" + file.getName()),\n\t\t\t\t\t\t\tnull, _library.getDefaultPublisher());\n\t\t\t\t\tFileInputStream fs = new FileInputStream(file);\n\t\t\t\t\tbyte[] buffer = new byte[fs.available()];\n\t\t\t\t\tfs.read(buffer);\n\t\t\t\t\tros.write(buffer);\n\t\t\t\t\tros.close();\t\n\t\t\t\t} catch (MalformedContentNameStringException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (XMLStreamException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t;\n\n\t\tAction openAction = new OpenFileAction(this, fc);\n\t\tJButton openButton = new JButton(openAction);\n\n\t\t// New Stuff\n\t\t// Create the scroll pane and add the tree to it.\n\t\tJScrollPane treeView = new JScrollPane(tree);\n\n\t\t// Create the HTML viewing pane.\n\t\thtmlPane = new JEditorPane();\n\t\thtmlPane.setEditable(false);\n\t\tinitHelp();\n\t\tJScrollPane htmlView = new JScrollPane(htmlPane);\n\n\t\t// Add the scroll panes to a split pane.\n\t\tJSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);\n\t\tsplitPane.setTopComponent(treeView);\n\t\tsplitPane.setBottomComponent(htmlView);\n\n\t\tDimension minimumSize = new Dimension(100, 50);\n\t\thtmlView.setMinimumSize(minimumSize);\n\t\ttreeView.setMinimumSize(minimumSize);\n\t\tsplitPane.setDividerLocation(100);\n\t\tsplitPane.setPreferredSize(new Dimension(500, 300));\n\n\t\t// Add the split pane to this panel.\n\t\tadd(splitPane);\n\n\t\t// End new stuff\n\n\t\t// treeView.getViewport().add(tree);\n\t\tgetContentPane().add(openButton, BorderLayout.NORTH);\n\t\tgetContentPane().add(treeView, BorderLayout.CENTER);\n\t\tgetContentPane().add(splitPane, BorderLayout.SOUTH);\n\n\t\tpack();\n\n\t\t// m_display = new JTextField();\n\t\t// m_display.setEditable(false);\n\t\t// getContentPane().add(m_display, BorderLayout.NORTH);\n\n\t\ttree.setSelectionPath(new TreePath(node.getPath()));\n\n\t\t// NEW\n\t\tm_popup = new JPopupMenu();\n\t\tm_action = new AbstractAction() {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = -3875007136742502632L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (m_clickedPath == null)\n\t\t\t\t\treturn;\n\t\t\t\tif (tree.isExpanded(m_clickedPath))\n\t\t\t\t\ttree.collapsePath(m_clickedPath);\n\t\t\t\telse\n\t\t\t\t\ttree.expandPath(m_clickedPath);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(m_action);\n\t\tm_popup.addSeparator();\n\n\t\tAction a1 = new AbstractAction(\"Delete\") {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttree.repaint();\n\t\t\t\tJOptionPane.showMessageDialog(ContainerGUI.this,\n\t\t\t\t\t\t\"Delete option is not implemented\", \"Info\",\n\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(a1);\n\n\t\tAction a2 = new AbstractAction(\"Rename\") {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttree.repaint();\n\t\t\t\tJOptionPane.showMessageDialog(ContainerGUI.this,\n\t\t\t\t\t\t\"Rename option is not implemented\", \"Info\",\n\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(a2);\n\t\ttree.add(m_popup);\n\t\ttree.addMouseListener(new PopupTrigger());\n\n\t\tWindowListener wndCloser = new WindowAdapter() {\n\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t};\n\t\taddWindowListener(wndCloser);\n\n\t\tsetVisible(true);\n\n\t}","id":40212,"modified_method":"public ContainerGUI() {\n\t\tsuper(\"CCN Tree [Popup Menus]\");\n\t\t\n\t\tsetupNameEnumerator();\n\n\t\tsetSize(400, 300);\n\n\t\tDefaultMutableTreeNode top = new DefaultMutableTreeNode(new IconData(\n\t\t\t\tICON_COMPUTER, null, \"/parc.com\"));\n\n\t\tDefaultMutableTreeNode node = null;\n\t\t// get whatever things I need at this point\n\t\t// query ccnd for stuff and stick it into the array\n\n\t\ttry {\n\t\t\tnode = new DefaultMutableTreeNode(new IconData(ICON_FOLDER, null,\n\t\t\t\t\tnew Name(\"files\", ContentName\n\t\t\t\t\t\t\t.fromNative(\"/parc.com\"))));\n\t\t\tnode.add(new DefaultMutableTreeNode( new Boolean(true) ));\n\t\t\tusableRoot = node;\n\t\t} catch (MalformedContentNameStringException e1) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\tSystem.out.println(\"Error in the content name\");\n\t\t\te1.printStackTrace();\n\t\t}\n\t\ttop.add(node);\n\n\t\t// File[] roots = File.listRoots();\n\t\t// for (int k=0; k<roots.length; k++)\n\t\t// {\n\t\t// node = new DefaultMutableTreeNode(new IconData(ICON_DISK,\n\t\t// null, new FileNode(roots[k])));\n\t\t// top.add(node);\n\t\t// node.add(new DefaultMutableTreeNode( new Boolean(true) ));\n\t\t// }\n\n\t\tm_model = new DefaultTreeModel(top);\n\t\ttree = new JTree(m_model);\n\n\t\ttree.putClientProperty(\"JTree.lineStyle\", \"Angled\");\n\n\t\tTreeCellRenderer renderer = new IconCellRenderer();\n\t\ttree.setCellRenderer(renderer);\n\n\t\ttree.addTreeSelectionListener(new DirSelectionListener());\n\n\t\ttree.getSelectionModel().setSelectionMode(\n\t\t\t\tTreeSelectionModel.SINGLE_TREE_SELECTION);\n\t\ttree.setShowsRootHandles(true);\n\t\ttree.setEditable(false);\n\n\t\t// JScrollPane treeView = new JScrollPane();\n\t\tString filename = File.separator + \"tmp\";\n\t\tJFileChooser fc = new JFileChooser(new File(filename));\n\n\t\tclass OpenFileAction extends AbstractAction {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\tJFrame frame;\n\t\t\tJFileChooser chooser;\n\n\t\t\tOpenFileAction(JFrame frame, JFileChooser chooser) {\n\t\t\t\tsuper(\"Send to Repo...\");\n\t\t\t\tthis.chooser = chooser;\n\t\t\t\tthis.frame = frame;\n\t\t\t}\n\n\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t// Show dialog; this method does not return until dialog is\n\t\t\t\t// closed\n\t\t\t\tint returnVal = chooser.showOpenDialog(frame);\n\n\t\t\t\t// Get the selected file\n\t\t\t\tFile file = chooser.getSelectedFile();\n\t\t\t\tif(file == null || file.getName().equals(\"\")){\n\t\t\t\t\tSystem.out.println(\"the user did not select a file\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//what if the user hits cancel...\n\t\t\t\tif(returnVal != JFileChooser.APPROVE_OPTION){\n\t\t\t\t\tSystem.out.println(\"user cancelled the send to repo option...  returning\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"Writing a file to the repo \" + file.getAbsolutePath() + \" \" + file.getName());\n\t\t\t\tSystem.out.println(\"Selected Node is \" + selectedPrefix);\n\t\t\t\t\n\t\t\t\ttry{\n\t\t\t\t\tContentName contentName = ContentName.fromNative(selectedPrefix + \"/\" + file.getName());\n\t\t\t\t\tsendFile(file, contentName);\n\t\t\t\t\t/*\n\t\t\t\t\tSystem.out.println(\"Sending file \" + selectedPrefix + \"/\"\n\t\t\t\t\t\t\t+ file.getName());\n\t\t\t\t\tRepositoryOutputStream ros = _library.repoOpen(ContentName\n\t\t\t\t\t\t\t.fromNative(selectedPrefix + \"/\" + file.getName()),\n\t\t\t\t\t\t\tnull, _library.getDefaultPublisher());\n\t\t\t\t\tFileInputStream fs = new FileInputStream(file);\n\t\t\t\t\tbyte[] buffer = new byte[fs.available()];\n\t\t\t\t\tfs.read(buffer);\n\t\t\t\t\tros.write(buffer);\n\t\t\t\t\tros.close();\n\t\t\t\t\t*/\t\n\t\t\t\t} catch (MalformedContentNameStringException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t/*catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (XMLStreamException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t}\n\t\t}\n\t\t;\n\n\t\tAction openAction = new OpenFileAction(this, fc);\n\t\tJButton openButton = new JButton(openAction);\n\n\t\t// New Stuff\n\t\t// Create the scroll pane and add the tree to it.\n\t\tJScrollPane treeView = new JScrollPane(tree);\n\n\t\t// Create the HTML viewing pane.\n\t\thtmlPane = new JEditorPane();\n\t\thtmlPane.setEditable(false);\n\t\tinitHelp();\n\t\tJScrollPane htmlView = new JScrollPane(htmlPane);\n\n\t\t// Add the scroll panes to a split pane.\n\t\tJSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);\n\t\tsplitPane.setTopComponent(treeView);\n\t\tsplitPane.setBottomComponent(htmlView);\n\n\t\tDimension minimumSize = new Dimension(100, 50);\n\t\thtmlView.setMinimumSize(minimumSize);\n\t\ttreeView.setMinimumSize(minimumSize);\n\t\tsplitPane.setDividerLocation(100);\n\t\tsplitPane.setPreferredSize(new Dimension(500, 300));\n\n\t\t// Add the split pane to this panel.\n\t\tadd(splitPane);\n\n\t\t// End new stuff\n\n\t\t// treeView.getViewport().add(tree);\n\t\tgetContentPane().add(openButton, BorderLayout.NORTH);\n\t\tgetContentPane().add(treeView, BorderLayout.CENTER);\n\t\tgetContentPane().add(splitPane, BorderLayout.SOUTH);\n\n\t\tpack();\n\n\t\t// m_display = new JTextField();\n\t\t// m_display.setEditable(false);\n\t\t// getContentPane().add(m_display, BorderLayout.NORTH);\n\n\t\ttree.setSelectionPath(new TreePath(node.getPath()));\n\n\t\t// NEW\n\t\tm_popup = new JPopupMenu();\n\t\tm_action = new AbstractAction() {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = -3875007136742502632L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (m_clickedPath == null)\n\t\t\t\t\treturn;\n\t\t\t\tif (tree.isExpanded(m_clickedPath))\n\t\t\t\t\ttree.collapsePath(m_clickedPath);\n\t\t\t\telse\n\t\t\t\t\ttree.expandPath(m_clickedPath);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(m_action);\n\t\tm_popup.addSeparator();\n\n\t\tAction a1 = new AbstractAction(\"Delete\") {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttree.repaint();\n\t\t\t\tJOptionPane.showMessageDialog(ContainerGUI.this,\n\t\t\t\t\t\t\"Delete option is not implemented\", \"Info\",\n\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(a1);\n\n\t\tAction a2 = new AbstractAction(\"Rename\") {\n\t\t\t/**\n\t\t * \n\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttree.repaint();\n\t\t\t\tJOptionPane.showMessageDialog(ContainerGUI.this,\n\t\t\t\t\t\t\"Rename option is not implemented\", \"Info\",\n\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n\t\t\t}\n\t\t};\n\t\tm_popup.add(a2);\n\t\ttree.add(m_popup);\n\t\ttree.addMouseListener(new PopupTrigger());\n\n\t\tWindowListener wndCloser = new WindowAdapter() {\n\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t};\n\t\taddWindowListener(wndCloser);\n\n\t\tsetVisible(true);\n\n\t}","commit_id":"65410b1cab0e77222ed5c6cdb6ef88b846cc085b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void changePolicy(String policyFile) throws Exception {\n\t\tFileInputStream fis = new FileInputStream(_topdir + policyFile);\n\t\tbyte [] content = new byte[fis.available()];\n\t\tfis.read(content);\n\t\tfis.close();\n\t\tRepositoryOutputStream ros = putLibrary.repoOpen(ContentName.fromNative(_globalPrefix + '/' + \n\t\t\t\t_repoName + '/' + Repository.REPO_DATA + '/' + Repository.REPO_POLICY), null,\n\t\t\t\tputLibrary.getDefaultPublisher());\n\t\tros.write(content, 0, content.length);\n\t\tros.close();\n\t\tThread.sleep(4000);\n\t}","id":40213,"modified_method":"private void changePolicy(String policyFile) throws Exception {\n\t\tFileInputStream fis = new FileInputStream(_topdir + policyFile);\n\t\tbyte [] content = new byte[fis.available()];\n\t\tfis.read(content);\n\t\tfis.close();\n\t\tRepositoryFileOutputStream rfos = new RepositoryFileOutputStream(ContentName.fromNative(_globalPrefix + '/' + \n\t\t\t\t_repoName + '/' + Repository.REPO_DATA + '/' + Repository.REPO_POLICY),\n\t\t\t\tputLibrary.getDefaultPublisher(), putLibrary);\n\t\trfos.write(content, 0, content.length);\n\t\trfos.close();\n\t\tThread.sleep(4000);\n\t}","commit_id":"7dd5d83c75b782bee2633781ab7360df19b42ff3","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Test\n\tpublic void testGetLatestVersion() throws Exception {\n\t\tString name = \"/test/simon/versioned_name-\" + new Random().nextInt(10000);\n\t\t// include a base object, who's digest can potentially confuse getLatestVersion\n\t\tContentName base = ContentName.fromNative(name);\n\t\t\n\t\t// Don't do repeated get latest versions for now, not working.\n\t\tfinal int testCount = 2;\n\t\tfinal byte [][] data = new byte[testCount][1];\n\t\tfor (int i=0; i < testCount; ++i) {\n\t\t\tdata[i][0] = (byte)i;\n\t\t}\n\t\tCCNFlowControl f = new CCNFlowControl(base, putLibrary);\n\t\tContentObject [] cos = new ContentObject[testCount];\n\t\tcos[0] = ContentObject.buildContentObject(base, data[0]);\n\t\tfor (int i=1; i < testCount; ++i) {\n\t\t\tContentName versionedName = VersioningProfile.addVersion(base);\n\t\t\tThread.sleep(3);\n\t\t\tcos[i] = ContentObject.buildContentObject(versionedName, data[i]);\n\t\t}\n\t\tf.put(cos[0]);\n\t\tf.put(cos[1]);\n\t\t// java lacks nested functions, so use a class here...\n\t\tclass t {\n\t\t\tvoid check(ContentObject o, int i) throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, XMLStreamException, InterruptedException {\n\t\t\t\tSystem.out.println(\"Got content: \" + o.name());\n\t\t\t\tSystem.out.println(\"Original value: \" + i + \" returned value: \" + Byte.toString(o.content()[0]));\n\t\t\t\tAssert.assertTrue(o.verify(null));\n\t\t\t\tAssert.assertTrue(DataUtils.arrayEquals(o.content(), data[i]));\n\t\t\t}\n\t\t\t/**\n\t\t\t * Make sure the data is written to ccnd by reading it\n\t\t\t * @throws InterruptedException \n\t\t\t * @throws XMLStreamException \n\t\t\t * @throws NoSuchAlgorithmException \n\t\t\t * @throws SignatureException \n\t\t\t * @throws InvalidKeyException \n\t\t\t */\n\t\t\tvoid readAndCheck(ContentName name, int index) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException, XMLStreamException, InterruptedException {\n\t\t\t\tSystem.out.println(\"Getting content: \" + name);\n\t\t\t\tcheck(getLibrary.get(name, 2000), index);\n\t\t\t}\n\t\t} t test = new t();\n\t\ttest.readAndCheck(base, 0);\n\t\ttest.readAndCheck(cos[1].name(), 1);\n\t\ttest.check(VersioningProfile.getLatestVersionAfter(base, putLibrary.getDefaultPublisher(), 2000, getLibrary), 1);\n\t\t// Beef this up a bit...\n\t\tfor (int i=2; i < testCount; ++i) {\n\t\t\tf.put(cos[i]);\n\t\t\tSystem.out.println(\"Wrote content: \" + cos[i].name());\n\t\t\ttest.check(VersioningProfile.getLatestVersionAfter(cos[i-1].name(), putLibrary.getDefaultPublisher(), 2000, getLibrary), i);\n\t\t}\n\t}","id":40214,"modified_method":"@Test\n\tpublic void testGetLatestVersion() throws Exception {\n\t\tString name = \"/test/simon/versioned_name-\" + new Random().nextInt(10000);\n\t\t// include a base object, who's digest can potentially confuse getLatestVersion\n\t\tContentName base = ContentName.fromNative(name);\n\t\t\n\t\t// Don't do repeated get latest versions for now, not working.\n\t\tfinal int testCount = 2;\n\t\tfinal byte [][] data = new byte[testCount][1];\n\t\tfor (int i=0; i < testCount; ++i) {\n\t\t\tdata[i][0] = (byte)i;\n\t\t}\n\t\tCCNFlowControl f = new CCNFlowControl(base, putLibrary);\n\t\tContentObject [] cos = new ContentObject[testCount];\n\t\tcos[0] = ContentObject.buildContentObject(base, data[0]);\n\t\tfor (int i=1; i < testCount; ++i) {\n\t\t\tContentName versionedName = VersioningProfile.addVersion(base);\n\t\t\tThread.sleep(3);\n\t\t\tcos[i] = ContentObject.buildContentObject(versionedName, data[i]);\n\t\t}\n\t\tf.put(cos[0]);\n\t\tf.put(cos[1]);\n\t\t// java lacks nested functions, so use a class here...\n\t\tclass t {\n\t\t\tvoid check(ContentObject o, int i) throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, XMLStreamException, InterruptedException {\n\t\t\t\tSystem.out.println(\"Got content: \" + o.name());\n\t\t\t\tSystem.out.println(\"Original value: \" + i + \" returned value: \" + Byte.toString(o.content()[0]));\n\t\t\t\tAssert.assertTrue(o.verify(null));\n\t\t\t\tAssert.assertTrue(DataUtils.arrayEquals(o.content(), data[i]));\n\t\t\t}\n\t\t\t/**\n\t\t\t * Make sure the data is written to ccnd by reading it\n\t\t\t * @throws InterruptedException \n\t\t\t * @throws XMLStreamException \n\t\t\t * @throws NoSuchAlgorithmException \n\t\t\t * @throws SignatureException \n\t\t\t * @throws InvalidKeyException \n\t\t\t */\n\t\t\tvoid readAndCheck(ContentName name, int index) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException, XMLStreamException, InterruptedException {\n\t\t\t\tSystem.out.println(\"Getting content: \" + name);\n\t\t\t\tcheck(getLibrary.get(name, 2000), index);\n\t\t\t}\n\t\t} t test = new t();\n\t\ttest.readAndCheck(base, 0);\n\t\ttest.readAndCheck(cos[1].name(), 1);\n\t\tContentVerifier putVerifier = new ContentObject.SimpleVerifier(putLibrary.getDefaultPublisher());\n\t\ttest.check(VersioningProfile.getLatestVersionAfter(base, putLibrary.getDefaultPublisher(), 2000, putVerifier, getLibrary), 1);\n\t\t// Beef this up a bit...\n\t\tfor (int i=2; i < testCount; ++i) {\n\t\t\tf.put(cos[i]);\n\t\t\tSystem.out.println(\"Wrote content: \" + cos[i].name());\n\t\t\ttest.check(VersioningProfile.getLatestVersionAfter(cos[i-1].name(), putLibrary.getDefaultPublisher(), 2000, putVerifier, getLibrary), i);\n\t\t}\n\t}","commit_id":"063fe6f9cac1c6f35a1b52ae3b738e07ef9953bd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void versionTest(ContentName docName,\n\t\t\tbyte [] content1,\n\t\t\tbyte [] content2) throws Exception {\n\n\t\tCCNWriter writer = new CCNWriter(docName, putLibrary);\n\t\tContentName version1 = writer.newVersion(docName, content1);\n\t\tSystem.out.println(\"Inserted first version as: \" + version1);\n\t\tAssert.assertNotNull(\"New version is null!\", version1);\n\n\t\tContentObject latestVersion =\n\t\t\tVersioningProfile.getLatestVersionAfter(docName, null, CCNLibrary.NO_TIMEOUT, getLibrary);\n\t\tAssert.assertTrue(latestVersion.verify(null));\n\t\tAssert.assertNotNull(\"Retrieved latest version of \" + docName + \" got null!\", latestVersion);\n\t\tSystem.out.println(\"Latest version name: \" + latestVersion.name());\n\n\t\tContentName version2 = \n\t\t\twriter.newVersion(docName, content2);\n\n\t\tAssert.assertNotNull(\"New version is null!\", version2);\n\t\tSystem.out.println(\"Inserted second version as: \" + version2);\n\n\t\tContentObject newLatestVersion = \n\t\t\tVersioningProfile.getLatestVersionAfter(docName, null, CCNLibrary.NO_TIMEOUT, getLibrary);\n\t\tAssert.assertTrue(newLatestVersion.verify(null));\n\t\tAssert.assertNotNull(\"Retrieved new latest version of \" + docName + \" got null!\", newLatestVersion);\n\t\tSystem.out.println(\"Latest version name: \" + newLatestVersion.name());\n\n\t\tAssert.assertTrue(\"Version is not a version of the parent name!\", VersioningProfile.isVersionOf(version1, docName));\n\t\tAssert.assertTrue(\"Version is not a version of the parent name!\", VersioningProfile.isVersionOf(version2, docName));\n\t\tAssert.assertTrue(\"Version numbers don't increase!\", VersioningProfile.getLastVersionAsLong(version2) > VersioningProfile.getLastVersionAsLong(version1));\n\t}","id":40215,"modified_method":"public void versionTest(ContentName docName,\n\t\t\tbyte [] content1,\n\t\t\tbyte [] content2) throws Exception {\n\n\t\tCCNWriter writer = new CCNWriter(docName, putLibrary);\n\t\tContentName version1 = writer.newVersion(docName, content1);\n\t\tSystem.out.println(\"Inserted first version as: \" + version1);\n\t\tAssert.assertNotNull(\"New version is null!\", version1);\n\n\t\tContentVerifier putVerifier = new ContentObject.SimpleVerifier(putLibrary.getDefaultPublisher());\n\t\tContentObject latestVersion =\n\t\t\tVersioningProfile.getLatestVersionAfter(docName, null, CCNLibrary.NO_TIMEOUT, putVerifier, getLibrary);\n\t\tAssert.assertTrue(latestVersion.verify(null));\n\t\tAssert.assertNotNull(\"Retrieved latest version of \" + docName + \" got null!\", latestVersion);\n\t\tSystem.out.println(\"Latest version name: \" + latestVersion.name());\n\n\t\tContentName version2 = \n\t\t\twriter.newVersion(docName, content2);\n\n\t\tAssert.assertNotNull(\"New version is null!\", version2);\n\t\tSystem.out.println(\"Inserted second version as: \" + version2);\n\n\t\tContentObject newLatestVersion = \n\t\t\tVersioningProfile.getLatestVersionAfter(docName, null, CCNLibrary.NO_TIMEOUT, putVerifier, getLibrary);\n\t\tAssert.assertTrue(newLatestVersion.verify(null));\n\t\tAssert.assertNotNull(\"Retrieved new latest version of \" + docName + \" got null!\", newLatestVersion);\n\t\tSystem.out.println(\"Latest version name: \" + newLatestVersion.name());\n\n\t\tAssert.assertTrue(\"Version is not a version of the parent name!\", VersioningProfile.isVersionOf(version1, docName));\n\t\tAssert.assertTrue(\"Version is not a version of the parent name!\", VersioningProfile.isVersionOf(version2, docName));\n\t\tAssert.assertTrue(\"Version numbers don't increase!\", VersioningProfile.getLastVersionAsLong(version2) > VersioningProfile.getLastVersionAsLong(version1));\n\t}","commit_id":"063fe6f9cac1c6f35a1b52ae3b738e07ef9953bd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void loadKeyStore() throws ConfigurationException {\n\t\t// Is there an existing version of this key store? don't assume repo, so don't enumerate.\n\t\t// timeouts should be ok.\n\t\t// DKS TODO -- once streams pull first block on creation, don't need this much work.\n\t\tContentObject keystoreObject = null;\n\t\ttry {\n\t\t\tkeystoreObject = \n\t\t\t\tVersioningProfile.getFirstBlockOfLatestVersion(_keystoreName, _publisher, DEFAULT_TIMEOUT, _library);\n\t\t\tif (null == keystoreObject) {\n\t\t\t\tLibrary.logger().info(\"Creating new CCN key store...\" + _keystoreName);\n\t\t\t\t_keystore = createKeyStore();\t\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLibrary.logger().warning(\"Cannot get first block of existing key store: \" + _keystoreName);\n\t\t\tthrow new ConfigurationException(\"Cannot get first block of existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t} \n\t\tif ((null == _keystore) && (null != keystoreObject)){\n\t\t\tCCNVersionedInputStream in = null;\n\t\t\tLibrary.logger().info(\"Loading CCN key store from \" + _keystoreName + \"...\");\n\t\t\ttry {\n\t\t\t\tin = new CCNVersionedInputStream(keystoreObject, _library);\n\t\t\t\treadKeyStore(in);\n\t\t\t} catch (XMLStreamException e) {\n\t\t\t\tLibrary.logger().warning(\"Cannot open existing key store: \" + _keystoreName);\n\t\t\t\tthrow new ConfigurationException(\"Cannot open existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLibrary.logger().warning(\"Cannot open existing key store: \" + _keystoreName);\n\t\t\t\tthrow new ConfigurationException(\"Cannot open existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t\t} \n\t\t}\n\t\t\n\t\tif (!loadValuesFromKeystore(_keystore)) {\n\t\t\tLibrary.logger().warning(\"Cannot process keystore!\");\n\t\t}\n\t}","id":40216,"modified_method":"protected void loadKeyStore() throws ConfigurationException {\n\t\t// Is there an existing version of this key store? don't assume repo, so don't enumerate.\n\t\t// timeouts should be ok.\n\t\t// DKS TODO -- once streams pull first block on creation, don't need this much work.\n\t\tContentObject keystoreObject = null;\n\t\ttry {\n\t\t\tkeystoreObject = \n\t\t\t\tVersioningProfile.getFirstBlockOfLatestVersionAfter(_keystoreName, null, _publisher, DEFAULT_TIMEOUT, new ContentObject.SimpleVerifier(_publisher),  _library);\n\t\t\tif (null == keystoreObject) {\n\t\t\t\tLibrary.logger().info(\"Creating new CCN key store...\" + _keystoreName);\n\t\t\t\t_keystore = createKeyStore();\t\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLibrary.logger().warning(\"Cannot get first block of existing key store: \" + _keystoreName);\n\t\t\tthrow new ConfigurationException(\"Cannot get first block of existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t} \n\t\tif ((null == _keystore) && (null != keystoreObject)){\n\t\t\tCCNVersionedInputStream in = null;\n\t\t\tLibrary.logger().info(\"Loading CCN key store from \" + _keystoreName + \"...\");\n\t\t\ttry {\n\t\t\t\tin = new CCNVersionedInputStream(keystoreObject, _library);\n\t\t\t\treadKeyStore(in);\n\t\t\t} catch (XMLStreamException e) {\n\t\t\t\tLibrary.logger().warning(\"Cannot open existing key store: \" + _keystoreName);\n\t\t\t\tthrow new ConfigurationException(\"Cannot open existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLibrary.logger().warning(\"Cannot open existing key store: \" + _keystoreName);\n\t\t\t\tthrow new ConfigurationException(\"Cannot open existing key store: \" + _keystoreName + \": \" + e.getMessage(), e);\n\t\t\t} \n\t\t}\n\t\t\n\t\tif (!loadValuesFromKeystore(_keystore)) {\n\t\t\tLibrary.logger().warning(\"Cannot process keystore!\");\n\t\t}\n\t}","commit_id":"063fe6f9cac1c6f35a1b52ae3b738e07ef9953bd","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n   * Constructs a context. To have plugin support, the {@code pluginInstantiator} must not be null.\n   */\n  protected AbstractContext(Program program, RunId runId, Arguments arguments,\n                            Set<String> datasets, MetricsContext metricsContext,\n                            DatasetFramework dsFramework, TransactionSystemClient txClient,\n                            DiscoveryServiceClient discoveryServiceClient, boolean multiThreaded,\n                            @Nullable PluginInstantiator pluginInstantiator) {\n    super(program.getId());\n    this.program = program;\n    this.runId = runId;\n    this.runtimeArguments = ImmutableMap.copyOf(arguments.asMap());\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.owners = createOwners(program.getId());\n    this.programMetrics = metricsContext;\n\n    Map<String, Map<String, String>> staticDatasets = new HashMap<>();\n    for (String name : datasets) {\n      staticDatasets.put(name, runtimeArguments);\n    }\n    SystemDatasetInstantiator instantiator =\n      new SystemDatasetInstantiator(dsFramework, program.getClassLoader(), owners);\n    this.datasetCache = multiThreaded\n      ? new MultiThreadDatasetCache(instantiator, txClient, new NamespaceId(namespaceId),\n                                    runtimeArguments, programMetrics, staticDatasets)\n      : new SingleThreadDatasetCache(instantiator, txClient, new NamespaceId(namespaceId),\n                                     runtimeArguments, programMetrics, staticDatasets);\n    this.pluginInstantiator = pluginInstantiator;\n    this.pluginContext = new DefaultPluginContext(pluginInstantiator, program.getId(),\n                                                  program.getApplicationSpecification().getPlugins());\n  }","id":40217,"modified_method":"/**\n   * Constructs a context. To have plugin support, the {@code pluginInstantiator} must not be null.\n   */\n  protected AbstractContext(Program program, RunId runId, Arguments arguments,\n                            Set<String> datasets, MetricsContext metricsContext,\n                            DatasetFramework dsFramework, TransactionSystemClient txClient,\n                            DiscoveryServiceClient discoveryServiceClient, boolean multiThreaded,\n                            @Nullable PluginInstantiator pluginInstantiator) {\n    super(program.getId().toEntityId());\n    this.program = program;\n    this.runId = runId;\n    this.runtimeArguments = ImmutableMap.copyOf(arguments.asMap());\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.owners = createOwners(program.getId());\n    this.programMetrics = metricsContext;\n\n    Map<String, Map<String, String>> staticDatasets = new HashMap<>();\n    for (String name : datasets) {\n      staticDatasets.put(name, runtimeArguments);\n    }\n    SystemDatasetInstantiator instantiator =\n      new SystemDatasetInstantiator(dsFramework, program.getClassLoader(), owners);\n    this.datasetCache = multiThreaded\n      ? new MultiThreadDatasetCache(instantiator, txClient, program.getId().getNamespace().toEntityId(),\n                                    runtimeArguments, programMetrics, staticDatasets)\n      : new SingleThreadDatasetCache(instantiator, txClient, program.getId().getNamespace().toEntityId(),\n                                     runtimeArguments, programMetrics, staticDatasets);\n    this.pluginInstantiator = pluginInstantiator;\n    this.pluginContext = new DefaultPluginContext(pluginInstantiator, program.getId(),\n                                                  program.getApplicationSpecification().getPlugins());\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public AbstractServiceDiscoverer(Id.Program programId) {\n    this.namespaceId = programId.getNamespaceId();\n    this.applicationId = programId.getApplicationId();\n  }","id":40218,"modified_method":"public AbstractServiceDiscoverer(ProgramId programId) {\n    this.namespaceId = programId.getNamespace();\n    this.applicationId = programId.getApplication();\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public PluginContext getPluginContext() {\n    return new SparkPluginContext(pluginInstantiator, programId, applicationSpecification.getPlugins());\n  }","id":40219,"modified_method":"@Override\n  public PluginContext getPluginContext() {\n    return new SparkPluginContext(pluginInstantiator, programId.toEntityId(), applicationSpecification.getPlugins());\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ServiceDiscoverer getServiceDiscoverer() {\n    return new SparkServiceDiscoverer(getProgramId(), discoveryServiceClient);\n  }","id":40220,"modified_method":"@Override\n  public ServiceDiscoverer getServiceDiscoverer() {\n    return new SparkServiceDiscoverer(getProgramId().toEntityId(), discoveryServiceClient);\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"BasicFlowletContext(Program program, final String flowletId,\n                      int instanceId, RunId runId,\n                      int instanceCount, Set<String> datasets,\n                      Arguments runtimeArguments, FlowletSpecification flowletSpec,\n                      MetricsCollectionService metricsCollectionService,\n                      DiscoveryServiceClient discoveryServiceClient,\n                      TransactionSystemClient txClient,\n                      DatasetFramework dsFramework) {\n    super(program, runId, runtimeArguments, datasets,\n          getMetricCollector(metricsCollectionService, program, flowletId, runId.getId(), instanceId),\n          dsFramework, txClient, discoveryServiceClient, false);\n    this.namespaceId = program.getNamespaceId();\n    this.flowId = program.getName();\n    this.flowletId = flowletId;\n    this.groupId = FlowUtils.generateConsumerGroupId(program, flowletId);\n    this.instanceId = instanceId;\n    this.instanceCount = instanceCount;\n    this.flowletSpec = flowletSpec;\n    this.userMetrics = new ProgramUserMetrics(getMetricCollector(metricsCollectionService, program,\n                                                                 flowletId, runId.getId(), instanceId));\n    // TODO - does this have to cache the metric collectors? Metrics framework itself has a cache [CDAP-2334]\n    //noinspection NullableProblems\n    this.queueMetrics = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<String, MetricsContext>() {\n        @Override\n        public MetricsContext load(String key) throws Exception {\n          return getProgramMetrics().childContext(Constants.Metrics.Tag.FLOWLET_QUEUE, key);\n        }\n      });\n\n    //noinspection NullableProblems\n    this.producerMetrics = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<ImmutablePair<String, String>, MetricsContext>() {\n        @Override\n        public MetricsContext load(ImmutablePair<String, String> key) throws Exception {\n          return getProgramMetrics()\n            .childContext(ImmutableMap.of(Constants.Metrics.Tag.PRODUCER, key.getFirst(),\n                                          Constants.Metrics.Tag.FLOWLET_QUEUE, key.getSecond(),\n                                          Constants.Metrics.Tag.CONSUMER, BasicFlowletContext.this.flowletId));\n        }\n      });\n\n  }","id":40221,"modified_method":"BasicFlowletContext(Program program, final String flowletId,\n                      int instanceId, RunId runId,\n                      int instanceCount, Set<String> datasets,\n                      Arguments runtimeArguments, FlowletSpecification flowletSpec,\n                      MetricsCollectionService metricsCollectionService,\n                      DiscoveryServiceClient discoveryServiceClient,\n                      TransactionSystemClient txClient,\n                      DatasetFramework dsFramework) {\n    super(program, runId, runtimeArguments, datasets,\n          getMetricCollector(metricsCollectionService, program, flowletId, runId.getId(), instanceId),\n          dsFramework, txClient, discoveryServiceClient, false);\n    this.flowId = program.getName();\n    this.flowletId = flowletId;\n    this.groupId = FlowUtils.generateConsumerGroupId(program, flowletId);\n    this.instanceId = instanceId;\n    this.instanceCount = instanceCount;\n    this.flowletSpec = flowletSpec;\n    this.userMetrics = new ProgramUserMetrics(getMetricCollector(metricsCollectionService, program,\n                                                                 flowletId, runId.getId(), instanceId));\n    // TODO - does this have to cache the metric collectors? Metrics framework itself has a cache [CDAP-2334]\n    //noinspection NullableProblems\n    this.queueMetrics = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<String, MetricsContext>() {\n        @Override\n        public MetricsContext load(String key) throws Exception {\n          return getProgramMetrics().childContext(Constants.Metrics.Tag.FLOWLET_QUEUE, key);\n        }\n      });\n\n    //noinspection NullableProblems\n    this.producerMetrics = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<ImmutablePair<String, String>, MetricsContext>() {\n        @Override\n        public MetricsContext load(ImmutablePair<String, String> key) throws Exception {\n          return getProgramMetrics()\n            .childContext(ImmutableMap.of(Constants.Metrics.Tag.PRODUCER, key.getFirst(),\n                                          Constants.Metrics.Tag.FLOWLET_QUEUE, key.getSecond(),\n                                          Constants.Metrics.Tag.CONSUMER, BasicFlowletContext.this.flowletId));\n        }\n      });\n\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public DefaultPluginContext(@Nullable PluginInstantiator pluginInstantiator,\n                              Id.Program programId, Map<String, Plugin> plugins) {\n    this.pluginInstantiator = pluginInstantiator;\n    this.programId = programId;\n    this.plugins = plugins;\n  }","id":40222,"modified_method":"/**\n   * Constructor.\n   *\n   * @deprecated Use {@link #DefaultPluginContext(PluginInstantiator, ProgramId, Map)} instead.\n   */\n  @Deprecated\n  public DefaultPluginContext(@Nullable PluginInstantiator pluginInstantiator,\n                              Id.Program programId, Map<String, Plugin> plugins) {\n    this(pluginInstantiator, programId.toEntityId(), plugins);\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"private Plugin getPlugin(String pluginId) {\n    Plugin plugin = plugins.get(pluginId);\n    Preconditions.checkArgument(plugin != null, \"Plugin with id %s does not exist in program %s of application %s.\",\n                                pluginId, programId.getId(), programId.getApplicationId());\n    return plugin;\n  }","id":40223,"modified_method":"private Plugin getPlugin(String pluginId) {\n    Plugin plugin = plugins.get(pluginId);\n    Preconditions.checkArgument(plugin != null, \"Plugin with id %s does not exist in program %s of application %s.\",\n                                pluginId, programId.getProgram(), programId.getApplication());\n    return plugin;\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public SparkPluginContext(@Nullable PluginInstantiator pluginInstantiator,\n                            Id.Program programId, Map<String, Plugin> plugins) {\n    this.delegate = new DefaultPluginContext(pluginInstantiator, programId, plugins);\n  }","id":40224,"modified_method":"public SparkPluginContext(@Nullable PluginInstantiator pluginInstantiator,\n                            ProgramId programId, Map<String, Plugin> plugins) {\n    this.delegate = new DefaultPluginContext(pluginInstantiator, programId, plugins);\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public SparkPluginContext(ExecutionSparkContext context) {\n    this(context.getPluginInstantiator(), context.getProgramId(), context.getApplicationSpecification().getPlugins());\n  }","id":40225,"modified_method":"public SparkPluginContext(ExecutionSparkContext context) {\n    this(context.getPluginInstantiator(), context.getProgramId().toEntityId(),\n         context.getApplicationSpecification().getPlugins());\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public SparkServiceDiscoverer(Id.Program programId, DiscoveryServiceClient discoveryServiceClient) {\n    super(programId);\n    this.discoveryServiceClient = discoveryServiceClient;\n  }","id":40226,"modified_method":"public SparkServiceDiscoverer(ProgramId programId, DiscoveryServiceClient discoveryServiceClient) {\n    super(programId);\n    this.discoveryServiceClient = discoveryServiceClient;\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"public SparkServiceDiscoverer(ExecutionSparkContext context) {\n    this(context.getProgramId(), context.getDiscoveryServiceClient());\n  }","id":40227,"modified_method":"public SparkServiceDiscoverer(ExecutionSparkContext context) {\n    this(context.getProgramId().toEntityId(), context.getDiscoveryServiceClient());\n  }","commit_id":"dda151a711f49713da8a3ac65e0ddf6c97334a42","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    Alignment alignment = Alignment.get(c);\n    if (alignment != null && g instanceof Graphics2D) {\n      Rectangle bounds = new Rectangle(c.getSize());\n      JBInsets.removeFrom(bounds, c.getInsets());\n      if (c.isOpaque() && c.getParent() instanceof JScrollPane) {\n        g.setColor(c.getForeground());\n        switch (alignment) {\n          case TOP:\n            bounds.height--;\n            g.drawLine(bounds.x, bounds.y + bounds.height, bounds.x + bounds.width, bounds.y + bounds.height);\n            break;\n          case LEFT:\n            bounds.width--;\n            g.drawLine(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width, bounds.y + bounds.height);\n            break;\n          case RIGHT:\n            g.drawLine(bounds.x, bounds.y, bounds.x, bounds.y + bounds.height);\n            bounds.width--;\n            bounds.x++;\n            break;\n          case BOTTOM:\n            g.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);\n            bounds.height--;\n            bounds.y++;\n            break;\n        }\n      }\n      else if (isTrackVisible) {\n        paintTrack((Graphics2D)g, bounds.x, bounds.y, bounds.width, bounds.height, c);\n      }\n      // process a square area before the track\n      RegionPainter<Object> leading = UIUtil.getClientProperty(c, LEADING_AREA);\n      if (leading == null) {\n        myLeadingBounds.setSize(0, 0);\n      }\n      else if (alignment == Alignment.LEFT || alignment == Alignment.RIGHT) {\n        int size = bounds.width;\n        myLeadingBounds.setBounds(bounds.x, bounds.y, size, size);\n        leading.paint((Graphics2D)g, bounds.x, bounds.y, size, size, null);\n        bounds.height -= size;\n        bounds.y += size;\n      }\n      else {\n        int size = bounds.height;\n        myLeadingBounds.setBounds(bounds.x, bounds.y, size, size);\n        leading.paint((Graphics2D)g, bounds.x, bounds.y, size, size, null);\n        bounds.width -= size;\n        bounds.x += size;\n      }\n      // process additional drawing on the track\n      myTrackBounds.setBounds(bounds);\n      RegionPainter<Object> track = UIUtil.getClientProperty(c, JBScrollBar.TRACK);\n      if (track != null && myTrackBounds.width > 0 && myTrackBounds.height > 0) {\n        track.paint((Graphics2D)g, myTrackBounds.x, myTrackBounds.y, myTrackBounds.width, myTrackBounds.height, null);\n      }\n      // process drawing the thumb\n      updateThumbBounds();\n      if (myThumbBounds.width > 0 && myThumbBounds.height > 0) {\n        paintThumb((Graphics2D)g, myThumbBounds.x, myThumbBounds.y, myThumbBounds.width, myThumbBounds.height, c);\n      }\n    }\n  }","id":40228,"modified_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    Alignment alignment = Alignment.get(c);\n    if (alignment != null && g instanceof Graphics2D) {\n      Rectangle bounds = new Rectangle(c.getSize());\n      JBInsets.removeFrom(bounds, c.getInsets());\n      if (c.isOpaque() && c.getParent() instanceof JScrollPane) {\n        if (Registry.is(\"ide.scroll.track.border.paint\")) {\n          Color foreground = c.getForeground();\n          if (foreground != null && !foreground.equals(c.getBackground())) {\n            g.setColor(foreground);\n            switch (alignment) {\n              case TOP:\n                bounds.height--;\n                g.drawLine(bounds.x, bounds.y + bounds.height, bounds.x + bounds.width, bounds.y + bounds.height);\n                break;\n              case LEFT:\n                bounds.width--;\n                g.drawLine(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width, bounds.y + bounds.height);\n                break;\n              case RIGHT:\n                g.drawLine(bounds.x, bounds.y, bounds.x, bounds.y + bounds.height);\n                bounds.width--;\n                bounds.x++;\n                break;\n              case BOTTOM:\n                g.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);\n                bounds.height--;\n                bounds.y++;\n                break;\n            }\n          }\n        }\n      }\n      else if (isTrackVisible) {\n        paintTrack((Graphics2D)g, bounds.x, bounds.y, bounds.width, bounds.height, c);\n      }\n      // process a square area before the track\n      RegionPainter<Object> leading = UIUtil.getClientProperty(c, LEADING_AREA);\n      if (leading == null) {\n        myLeadingBounds.setSize(0, 0);\n      }\n      else if (alignment == Alignment.LEFT || alignment == Alignment.RIGHT) {\n        int size = bounds.width;\n        myLeadingBounds.setBounds(bounds.x, bounds.y, size, size);\n        leading.paint((Graphics2D)g, bounds.x, bounds.y, size, size, null);\n        bounds.height -= size;\n        bounds.y += size;\n      }\n      else {\n        int size = bounds.height;\n        myLeadingBounds.setBounds(bounds.x, bounds.y, size, size);\n        leading.paint((Graphics2D)g, bounds.x, bounds.y, size, size, null);\n        bounds.width -= size;\n        bounds.x += size;\n      }\n      // process additional drawing on the track\n      myTrackBounds.setBounds(bounds);\n      RegionPainter<Object> track = UIUtil.getClientProperty(c, JBScrollBar.TRACK);\n      if (track != null && myTrackBounds.width > 0 && myTrackBounds.height > 0) {\n        track.paint((Graphics2D)g, myTrackBounds.x, myTrackBounds.y, myTrackBounds.width, myTrackBounds.height, null);\n      }\n      // process drawing the thumb\n      updateThumbBounds();\n      if (myThumbBounds.width > 0 && myThumbBounds.height > 0) {\n        paintThumb((Graphics2D)g, myThumbBounds.x, myThumbBounds.y, myThumbBounds.width, myThumbBounds.height, c);\n      }\n    }\n  }","commit_id":"043f7dae424adee7a3b77e8b1bb85fd4bfb7bcdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n      Component component = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n      if (value instanceof ExcludeEntryDescription) {\n        ExcludeEntryDescription description = (ExcludeEntryDescription)value;\n        setText(description.getPresentableUrl());\n        setForeground(description.isValid()? table.getForeground() : Color.RED);\n      }\n\n      if (!isSelected) {\n        setBackground(table.getBackground());\n      }\n      return component;\n    }","id":40229,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n      final Component component = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n      final ExcludeEntryDescription description = myExcludeEntryDescriptions.get(row);\n      component.setForeground(!description.isValid() ? Color.RED : isSelected ? table.getSelectionForeground() : table.getForeground());\n      component.setBackground(isSelected ? table.getSelectionBackground() : table.getBackground());\n      return component;\n    }","commit_id":"20940d2bec85cf00bbf80c0b17787e4066bd47b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BooleanTableCellRenderer() {\n    super();\n    setHorizontalAlignment(CENTER);\n    setVerticalAlignment(CENTER);\n    setBorder(null);\n  }","id":40230,"modified_method":"public BooleanTableCellRenderer() {\n    super();\n    setBorderPainted(true);\n    setVerticalAlignment(CENTER);\n    setHorizontalAlignment(CENTER);\n  }","commit_id":"f1943914832766e8d6e47b090d5796b057409a52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value,\n                                                 boolean isSelected, boolean hasFocus,\n                                                 int row, int column) {\n    if(value == null) {\n      if(isSelected) {\n        myPanel.setBackground(table.getSelectionBackground());\n      }\n      else {\n        myPanel.setBackground(table.getBackground());\n      }\n      return myPanel;\n    }\n    if(isSelected) {\n      setForeground(table.getSelectionForeground());\n      super.setBackground(table.getSelectionBackground());\n    }\n    else {\n      setForeground(table.getForeground());\n      setBackground(table.getBackground());\n    }\n    if (value instanceof String) {\n      setSelected(Boolean.parseBoolean((String)value));\n    }\n    else {\n      setSelected(((Boolean)value).booleanValue());\n    }\n    setEnabled(table.isCellEditable(row, column));\n    return this;\n  }","id":40231,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSel, boolean hasFocus, int row, int column) {\n    final Color bg = table.getBackground();\n    final Color fg = table.getForeground();\n    final Color selBg = table.getSelectionBackground();\n    final Color selFg = table.getSelectionForeground();\n\n    myPanel.setBackground(isSel ? selBg : bg);\n    if (value == null) {\n      return myPanel;\n    }\n\n    setForeground(isSel ? selFg : fg);\n    if (isSel) super.setBackground(selBg); else setBackground(bg);\n\n    if (value instanceof String) {\n      setSelected(Boolean.parseBoolean((String)value));\n    } else {\n      setSelected(((Boolean)value).booleanValue());\n    }\n\n    setBorder(hasFocus ? UIUtil.getTableFocusCellHighlightBorder() : IdeBorderFactory.createEmptyBorder(1));\n\n    setEnabled(table.isCellEditable(row, column));\n\n    return this;\n  }","commit_id":"f1943914832766e8d6e47b090d5796b057409a52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, final boolean hasFocus, int row, int column) {\n    PsiCodeFragment codeFragment = (PsiCodeFragment)value;\n\n    final EditorTextField editorTextField;\n    if (codeFragment != null) {\n      Document document = PsiDocumentManager.getInstance(myProject).getDocument(codeFragment);\n      editorTextField = new EditorTextField(document, myProject, myFileType) {\n        protected boolean shouldHaveBorder() {\n          return false;\n        }\n      };\n    }\n    else {\n      editorTextField = new EditorTextField(\"\", myProject, myFileType) {\n        protected boolean shouldHaveBorder() {\n          return false;\n        }\n      };\n    }\n\n    if (!table.isShowing()) {\n      editorTextField.ensureWillComputePreferredSize();\n    }\n\n    editorTextField.putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n    editorTextField.setBorder(hasFocus ? BorderFactory.createLineBorder(table.getForeground()): new EmptyBorder(1, 1, 1, 1));\n    return editorTextField;\n  }","id":40232,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, final boolean hasFocus, int row, int column) {\n    PsiCodeFragment codeFragment = (PsiCodeFragment)value;\n\n    final EditorTextField editorTextField;\n    if (codeFragment != null) {\n      Document document = PsiDocumentManager.getInstance(myProject).getDocument(codeFragment);\n      editorTextField = new EditorTextField(document, myProject, myFileType) {\n        protected boolean shouldHaveBorder() {\n          return false;\n        }\n      };\n    }\n    else {\n      editorTextField = new EditorTextField(\"\", myProject, myFileType) {\n        protected boolean shouldHaveBorder() {\n          return false;\n        }\n      };\n    }\n\n    if (!table.isShowing()) {\n      editorTextField.ensureWillComputePreferredSize();\n    }\n\n    editorTextField.putClientProperty(\"JComboBox.isTableCellEditor\", Boolean.TRUE);\n    ListSelectionModel selModel = table.getSelectionModel();\n    final Color color = (selModel.getMaxSelectionIndex() - selModel.getMinSelectionIndex()) == 0\n                        ? table.getSelectionBackground() : table.getForeground();\n    editorTextField.setBorder(hasFocus ? BorderFactory.createLineBorder(color): IdeBorderFactory.createEmptyBorder(1));\n    return editorTextField;\n  }","commit_id":"f1943914832766e8d6e47b090d5796b057409a52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TableCellRenderer doCreateRenderer(ParameterTableModelItemBase<P> item) {\n      return new ColoredTableCellRenderer() {\n        public void customizeCellRenderer(JTable table, Object value,\n                                          boolean isSelected, boolean hasFocus, int row, int column) {\n          if (value == null) return;\n          append((String)value, new SimpleTextAttributes(Font.PLAIN, null));\n        }\n      };\n    }","id":40233,"modified_method":"public TableCellRenderer doCreateRenderer(ParameterTableModelItemBase<P> item) {\n      return new ColoredTableCellRenderer() {\n        public void customizeCellRenderer(JTable table, Object value,\n                                          boolean isSelected, boolean hasFocus, int row, int column) {\n          setBackground(table.getBackground());\n          setForeground(table.getForeground());\n\n          if (value == null) return;\n          append((String)value, new SimpleTextAttributes(Font.PLAIN, null));\n        }\n      };\n    }","commit_id":"f1943914832766e8d6e47b090d5796b057409a52","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final JCVariableDecl makeThis() {\n        // first append $this\n        String name;\n        if (primary instanceof Tree.BaseMemberOrTypeExpression) {\n            name = \"this\";\n        } else {\n            name = callVarName;\n        }\n        // TODO Fix this \n        ProducedType thisType = ((Tree.MemberOrTypeExpression)primary).getTarget().getQualifyingType();\n        //ProducedType thisType = gen().getThisType(getPrimaryDeclaration());\n        JCVariableDecl thisDecl = gen().makeVar(varBaseName + \"$this$\", \n                gen().makeJavaType(thisType, AbstractTransformer.NO_PRIMITIVES), \n                gen().makeUnquotedIdent(name));\n        return thisDecl;\n    }","id":40234,"modified_method":"protected final JCVariableDecl makeThis() {\n        // first append $this\n        JCExpression defaultedParameterInstance;\n        // TODO Fix how we figure out the thisType, because it's doesn't \n        // handle type parameters correctly\n        // we used to use thisType = gen().getThisType(getPrimaryDeclaration());\n        final JCExpression thisType;\n        ProducedReference target = ((Tree.MemberOrTypeExpression)primary).getTarget();\n        if (primary instanceof Tree.BaseMemberExpression) {\n            thisType = gen().makeJavaType(target.getQualifyingType(), AbstractTransformer.NO_PRIMITIVES);\n            defaultedParameterInstance = gen().makeUnquotedIdent(\"this\");\n        } else if (primary instanceof Tree.BaseTypeExpression\n                || primary instanceof Tree.QualifiedTypeExpression) {\n            Map<TypeParameter, ProducedType> typeA = target.getTypeArguments();\n            ListBuffer<JCExpression> typeArgs = ListBuffer.<JCExpression>lb();\n            for (TypeParameter tp : ((TypeDeclaration)target.getDeclaration()).getTypeParameters()) {\n                ProducedType producedType = typeA.get(tp);\n                typeArgs.append(gen().makeJavaType(producedType, gen().TYPE_ARGUMENT));\n            }\n            ClassOrInterface declaration = (ClassOrInterface)((Tree.BaseTypeExpression) primary).getDeclaration();\n            thisType = gen().makeCompanionType(declaration, typeArgs.toList());\n            defaultedParameterInstance = gen().make().NewClass(\n                    null, \n                    null,\n                    gen().makeCompanionType(declaration, typeArgs.toList()), \n                    List.<JCExpression>nil(), null);\n        } else {\n            thisType = gen().makeJavaType(target.getQualifyingType(), AbstractTransformer.NO_PRIMITIVES);\n            defaultedParameterInstance = gen().makeUnquotedIdent(callVarName);\n        }\n        \n        JCVariableDecl thisDecl = gen().makeVar(varBaseName + \"$this$\", \n                thisType, \n                defaultedParameterInstance);\n        return thisDecl;\n    }","commit_id":"18b6283e696662c2cbb59575395d0a47c3bbdb02","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            this.typeArguments = ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels();\n        } else {\n            this.typeArguments = null;\n        }\n        this.transformedTypArguments = transformTypeArguments(gen, getTypeArguments());\n        needsThis = primaryDeclaration != null ? Decl.withinClassOrInterface(primaryDeclaration) : false;\n    }","id":40235,"modified_method":"protected InvocationBuilder(AbstractTransformer gen, \n            Tree.Primary primary, Declaration primaryDeclaration,\n            ProducedType returnType, Node node) {\n        this.gen = gen;\n        this.primary = primary;\n        this.primaryDeclaration = primaryDeclaration;\n        this.returnType = returnType;\n        this.node = node;\n        if (primary instanceof Tree.StaticMemberOrTypeExpression){\n            this.typeArguments = ((Tree.StaticMemberOrTypeExpression)primary).getTypeArguments().getTypeModels();\n        } else {\n            this.typeArguments = null;\n        }\n        this.transformedTypArguments = transformTypeArguments(gen, getTypeArguments());\n        needsThis = primaryDeclaration != null ? Decl.withinClassOrInterface(primaryDeclaration) || primaryDeclaration instanceof Class : false;\n    }","commit_id":"18b6283e696662c2cbb59575395d0a47c3bbdb02","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder(AbstractTransformer owner, TypedDeclaration attrType, \n            String javaClassName, ClassDefinitionBuilder classBuilder, String attrName, String fieldName, boolean toplevel, boolean indirect) {\n        int typeFlags = 0;\n        TypedReference typedRef = owner.getTypedReference(attrType);\n        TypedReference nonWideningTypedRef = owner.nonWideningTypeDecl(typedRef);\n        Type nonWideningType = owner.nonWideningType(typedRef, nonWideningTypedRef);\n        if(attrType.isActual()\n                && CodegenUtil.hasTypeErased(attrType))\n            typeFlags |= AbstractTransformer.JT_RAW;\n        if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n            typeFlags |= AbstractTransformer.JT_NO_PRIMITIVES;\n        }\n        this.isHash = CodegenUtil.isHashAttribute((FunctionOrValue) attrType);\n        this.attrTypedDecl = attrType;\n        this.owner = owner;\n        this.javaClassName = javaClassName;\n        if (javaClassName != null) {\n            this.classBuilder = \n                    ClassDefinitionBuilder\n                    .klass(owner, javaClassName, null, false);\n        } else {\n            this.classBuilder = classBuilder;\n        }\n        this.attrType = nonWideningType;\n        this.typeFlags = typeFlags;\n        this.attrName = attrName;\n        this.fieldName = fieldName;\n        this.toplevel = toplevel;\n        this.late = attrType.isLate();\n        this.variable = attrType.isVariable();\n        \n        // Make sure we use the declaration for building the getter/setter names, as we might be trying to\n        // override a JavaBean property with an \"isFoo\" getter, or non-Ceylon casing, and we have to respect that.\n        getterBuilder = MethodDefinitionBuilder\n            .getter(owner, attrType, indirect)\n            .block(generateDefaultGetterBlock())\n            .isOverride(attrType.isActual())\n            .isTransient(Decl.isTransient(attrType))\n            .modelAnnotations(attrType.getAnnotations())\n            .resultType(attrType(), attrType);\n        \n        ParameterDefinitionBuilder pdb = ParameterDefinitionBuilder.systemParameter(owner, attrName);\n        pdb.modifiers(Flags.FINAL);\n        \n        pdb.aliasName(attrName);\n        int seterParamFlags = 0;\n        if (owner.rawParameters(attrType)) {\n            seterParamFlags |= AbstractTransformer.JT_RAW;\n        }\n        pdb.type(MethodDefinitionBuilder.paramType(owner, nonWideningTypedRef.getDeclaration(), nonWideningType, seterParamFlags, true), \n                owner.makeJavaTypeAnnotations(attrType));\n        \n        \n        setterBuilder = MethodDefinitionBuilder\n            .setter(owner, attrType)\n            .block(generateDefaultSetterBlock())\n            // only actual if the superclass is also variable\n            .isOverride(attrType.isActual() && ((TypedDeclaration)attrType.getRefinedDeclaration()).isVariable())\n            .parameter(pdb);\n    }","id":40236,"modified_method":"private AttributeDefinitionBuilder(AbstractTransformer owner, TypedDeclaration attrType, \n            String javaClassName, ClassDefinitionBuilder classBuilder, String attrName, String fieldName, boolean toplevel, boolean indirect) {\n        int typeFlags = 0;\n        TypedReference typedRef = owner.getTypedReference(attrType);\n        TypedReference nonWideningTypedRef = owner.nonWideningTypeDecl(typedRef);\n        Type nonWideningType = owner.nonWideningType(typedRef, nonWideningTypedRef);\n        if(attrType.isActual()\n                && CodegenUtil.hasTypeErased(attrType))\n            typeFlags |= AbstractTransformer.JT_RAW;\n        if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n            typeFlags |= AbstractTransformer.JT_NO_PRIMITIVES;\n        }\n        this.isHash = CodegenUtil.isHashAttribute((FunctionOrValue) attrType);\n        this.attrTypedDecl = attrType;\n        this.owner = owner;\n        this.javaClassName = javaClassName;\n        if (javaClassName != null) {\n            this.classBuilder = \n                    ClassDefinitionBuilder\n                    .klass(owner, javaClassName, null, false);\n        } else {\n            this.classBuilder = classBuilder;\n        }\n        this.attrType = nonWideningType;\n        this.typeFlags = typeFlags;\n        this.attrName = attrName;\n        this.fieldName = fieldName;\n        this.toplevel = toplevel;\n        this.late = attrType.isLate();\n        this.variable = attrType.isVariable();\n        \n        // Make sure we use the declaration for building the getter/setter names, as we might be trying to\n        // override a JavaBean property with an \"isFoo\" getter, or non-Ceylon casing, and we have to respect that.\n        getterBuilder = MethodDefinitionBuilder\n            .getter(owner, attrType, indirect)\n            .block(generateDefaultGetterBlock())\n            .isOverride(attrType.isActual())\n            .isTransient(Decl.isTransient(attrType))\n            .modelAnnotations(attrType.getAnnotations())\n            .resultType(attrType(), attrType);\n        \n        ParameterDefinitionBuilder pdb = ParameterDefinitionBuilder.systemParameter(owner, attrName);\n        pdb.modifiers(Flags.FINAL);\n        \n        pdb.aliasName(attrName);\n        int seterParamFlags = 0;\n        if (owner.rawParameters(attrType)) {\n            seterParamFlags |= AbstractTransformer.JT_RAW;\n        }\n        pdb.type(MethodDefinitionBuilder.paramType(owner, nonWideningTypedRef.getDeclaration(), nonWideningType, seterParamFlags), \n                owner.makeJavaTypeAnnotations(attrType));\n        \n        \n        setterBuilder = MethodDefinitionBuilder\n            .setter(owner, attrType)\n            .block(generateDefaultSetterBlock())\n            // only actual if the superclass is also variable\n            .isOverride(attrType.isActual() && ((TypedDeclaration)attrType.getRefinedDeclaration()).isVariable())\n            .parameter(pdb);\n    }","commit_id":"d8baf02d3f3386620148e1551147880cfc51a001","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private MethodDefinitionBuilder parameter(long modifiers, \n            java.util.List<Annotation> modelAnnotations, List<JCAnnotation> userAnnotations,\n            String name, String aliasedName, \n            Parameter decl, TypedDeclaration nonWideningDecl, Type nonWideningType, \n            int flags, boolean canWiden) {\n        ParameterDefinitionBuilder pdb = ParameterDefinitionBuilder.explicitParameter(gen, decl);\n        pdb.modifiers(modifiers);\n        pdb.modelAnnotations(modelAnnotations);\n        pdb.userAnnotations(userAnnotations);\n        pdb.aliasName(aliasedName);\n        pdb.sequenced(decl.isSequenced());\n        pdb.defaulted(decl.isDefaulted());\n        if (isParamTypeLocalToMethod(decl,\n                nonWideningType)) {\n            pdb.type(gen.make().Type(gen.syms().objectType), gen.makeJavaTypeAnnotations(decl.getModel()));\n        } else {\n            pdb.type(paramType(gen, nonWideningDecl, nonWideningType, flags, canWiden), gen.makeJavaTypeAnnotations(decl.getModel()));\n        }\n        return parameter(pdb);\n    }","id":40237,"modified_method":"private MethodDefinitionBuilder parameter(long modifiers, \n            java.util.List<Annotation> modelAnnotations, List<JCAnnotation> userAnnotations,\n            String name, String aliasedName, \n            Parameter decl, TypedDeclaration nonWideningDecl, Type nonWideningType, \n            int flags) {\n        ParameterDefinitionBuilder pdb = ParameterDefinitionBuilder.explicitParameter(gen, decl);\n        pdb.modifiers(modifiers);\n        pdb.modelAnnotations(modelAnnotations);\n        pdb.userAnnotations(userAnnotations);\n        pdb.aliasName(aliasedName);\n        pdb.sequenced(decl.isSequenced());\n        pdb.defaulted(decl.isDefaulted());\n        if (isParamTypeLocalToMethod(decl,\n                nonWideningType)) {\n            pdb.type(gen.make().Type(gen.syms().objectType), gen.makeJavaTypeAnnotations(decl.getModel()));\n        } else {\n            pdb.type(paramType(gen, nonWideningDecl, nonWideningType, flags), gen.makeJavaTypeAnnotations(decl.getModel()));\n        }\n        return parameter(pdb);\n    }","commit_id":"d8baf02d3f3386620148e1551147880cfc51a001","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public MethodDefinitionBuilder parameter(long modifiers, \n            java.util.List<Annotation> annos, \n            String name, \n            Parameter decl, \n            TypedDeclaration nonWideningDecl, \n            Type nonWideningType, \n            int flags, boolean canWiden) {\n        return parameter(modifiers, annos, null, name, name, decl, nonWideningDecl, nonWideningType, flags, canWiden);\n    }","id":40238,"modified_method":"public MethodDefinitionBuilder parameter(long modifiers, \n            java.util.List<Annotation> annos, \n            String name, \n            Parameter decl, \n            TypedDeclaration nonWideningDecl, \n            Type nonWideningType, \n            int flags, boolean canWiden) {\n        return parameter(modifiers, annos, null, name, name, decl, nonWideningDecl, nonWideningType, flags);\n    }","commit_id":"d8baf02d3f3386620148e1551147880cfc51a001","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"static JCExpression paramType(AbstractTransformer gen, TypedDeclaration nonWideningDecl,\n            Type nonWideningType, int flags, boolean canWiden) {\n        // keep in sync with gen.willEraseToBestBounds()\n        if (canWiden\n                && (gen.typeFact().isUnion(nonWideningType) \n                        || gen.typeFact().isIntersection(nonWideningType))) {\n            final Type refinedType = ((TypedDeclaration)CodegenUtil.getTopmostRefinedDeclaration(nonWideningDecl)).getType();\n            if (refinedType.isTypeParameter()\n                    && !refinedType.getSatisfiedTypes().isEmpty()) {\n                nonWideningType = refinedType.getSatisfiedTypes().get(0);\n                // Could be parameterized, and type param won't be in scope, so have to go raw\n                flags |= AbstractTransformer.JT_RAW;\n            }\n        }\n        JCExpression type = gen.makeJavaType(nonWideningDecl, nonWideningType, flags);\n        return type;\n    }","id":40239,"modified_method":"static JCExpression paramType(AbstractTransformer gen, TypedDeclaration nonWideningDecl,\n            Type nonWideningType, int flags) {\n        return gen.makeJavaType(nonWideningDecl, nonWideningType, flags);\n    }","commit_id":"d8baf02d3f3386620148e1551147880cfc51a001","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                // Does the parameter have a default value?\n                if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                    classBuilder.getCompanionBuilder().defs(transformDefaultedParameter(false, param, def, paramList));\n                }\n            }\n            \n            // Add overloaded constructors for defaulted parameter\n            for (Tree.Parameter param : paramList.getParameters()) {\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(\n                            overloadBuilder,\n                            def, def.getDeclarationModel(), true, paramList, param);\n                    \n                }\n            }\n            \n            // For each satisfied interface, instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)) {\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                ListBuffer<JCExpression> state = ListBuffer.<JCExpression>of(makeUnquotedIdent(\"this\"));\n                if (!iface.isToplevel()) {\n                    state.append(makeQuotedQualIdent(makeJavaType(iface.getType().getQualifyingType()), \"this\"));\n                }\n                final String fieldName = getCompanionFieldName(iface);\n                classBuilder.init(make().Exec(make().Assign(\n                        makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                        make().NewClass(null, \n                                null, // TODO Type args \n                                makeCompanionType(iface), \n                                state.toList(),  \n                                null))));\n                \n                classBuilder.field(PRIVATE | FINAL, fieldName, \n                        makeCompanionType(iface), null, false);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            // Give the $impl companion a constructor...\n            ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n            MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n            \n            // ...with a $this ctor parameter and field...\n            ProducedType thisType = def.getDeclarationModel().getType();\n            ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n            ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                    make().Exec(\n                            make().Assign(\n                                    makeSelect(\"this\", \"$this\"), \n                                    makeUnquotedIdent(\"$this\"))));\n            companionBuilder.field(PRIVATE | FINAL, \n                    \"$this\", \n                    makeJavaType(thisType), \n                    null, false);\n            if (!def.getDeclarationModel().isToplevel()) {\n                // ...and an $outer ctor parameter and field\n                ProducedType outerType = thisType.getQualifyingType();\n                ctor.parameter(0, \"$outer\", makeJavaType(outerType), null);\n                bodyStatements.append(\n                        make().Exec(\n                                make().Assign(\n                                        makeSelect(\"this\", \"$outer\"), \n                                        makeUnquotedIdent(\"$outer\"))));\n                companionBuilder.field(PRIVATE | FINAL, \n                        \"$outer\", \n                        makeJavaType(outerType), \n                        null, false);\n                \n                // Add an $outer() method to the interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtIgnore());\n                outerBuilder.modifiers(PUBLIC | ABSTRACT);\n                outerBuilder.resultType(null, makeJavaType(outerType));\n                classBuilder.defs(outerBuilder.build());\n            }\n            ctor.body(bodyStatements.toList());\n        }\n        \n        if (def instanceof Tree.AnyClass) {\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)\n                        || decl.isToplevel()) {\n                    // TODO What about local interfaces?\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                \n                // Generate $outer() impl if implementing an inner interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), true, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtOverride());\n                outerBuilder.annotations(makeAtIgnore());\n                outerBuilder.modifiers(FINAL | PUBLIC);\n                outerBuilder.resultType(null, makeJavaType(iface.getType().getQualifyingType()));\n                outerBuilder.body(make().Return(makeQuotedIdent(\"$outer\")));\n                classBuilder.defs(outerBuilder.build());\n            }\n        }\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (def instanceof Tree.AnyClass && Decl.isToplevel(def) && !Decl.isAbstract(def)) {\n            com.redhat.ceylon.compiler.typechecker.model.Class c = (com.redhat.ceylon.compiler.typechecker.model.Class) def.getDeclarationModel();\n            if (c.getParameterList().getParameters().isEmpty()) {\n                // Add a main() method\n                at(null);\n                JCExpression nameId = makeQuotedFQIdent(c.getQualifiedNameString());\n                JCNewClass expr = make().NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null);\n                classBuilder.body(makeMainMethod(def.getDeclarationModel(), expr));\n            }\n        }\n        \n        return classBuilder\n            .modelAnnotations(def.getDeclarationModel().getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .caseTypes(def.getDeclarationModel().getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","id":40240,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                // Does the parameter have a default value?\n                if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                    classBuilder.getCompanionBuilder().defs(transformDefaultedParameter(false, param, def, paramList));\n                }\n            }\n            \n            // Add overloaded constructors for defaulted parameter\n            for (Tree.Parameter param : paramList.getParameters()) {\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(\n                            overloadBuilder,\n                            def, def.getDeclarationModel(), true, paramList, param);\n                    \n                }\n            }\n            \n            // For each satisfied interface, instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)) {\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                ListBuffer<JCExpression> state = ListBuffer.<JCExpression>of(makeUnquotedIdent(\"this\"));\n                if (!iface.isToplevel()) {\n                    state.append(makeQuotedQualIdent(makeJavaType(iface.getType().getQualifyingType()), \"this\"));\n                }\n                final String fieldName = getCompanionFieldName(iface);\n                classBuilder.init(make().Exec(make().Assign(\n                        makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                        make().NewClass(null, \n                                null, // TODO Type args \n                                makeCompanionType(iface), \n                                state.toList(),  \n                                null))));\n                \n                classBuilder.field(PRIVATE | FINAL, fieldName, \n                        makeCompanionType(iface), null, false);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            // Give the $impl companion a $this field...\n            ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n            ProducedType thisType = def.getDeclarationModel().getType();\n            companionBuilder.field(PRIVATE | FINAL, \n                    \"$this\", \n                    makeJavaType(thisType), \n                    null, false);\n            MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n            \n            // ...initialize the $this field from a ctor parameter...\n            ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n            ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                    make().Exec(\n                            make().Assign(\n                                    makeSelect(\"this\", \"$this\"), \n                                    makeUnquotedIdent(\"$this\"))));\n            ctor.body(bodyStatements.toList());\n            if (!def.getDeclarationModel().isToplevel()) {\n                final ProducedType outerType = thisType.getQualifyingType();\n                // ...add a $outer() method to the impl\n                {\n                    MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                    outerBuilder.modifiers(PRIVATE | FINAL);\n                    outerBuilder.resultType(null, makeJavaType(outerType));\n                    final JCExpression expr;\n                    Scope container = def.getDeclarationModel().getContainer();\n                    if (container instanceof Class) {\n                        expr = makeSelect(makeQuotedQualIdentFromString(getFQDeclarationName((Class)container)), \"this\");\n                    } else if (container instanceof Interface) {\n                        expr = make().Apply(null,// TODO Type args\n                                makeSelect(\"$this\", \"$outer\"),\n                                List.<JCExpression>nil());\n                    } else {\n                        throw new RuntimeException();\n                    }\n                    outerBuilder.body(make().Return(expr));\n                    companionBuilder.defs(outerBuilder.build());\n                }\n                \n                {\n                // Add an $outer() method to the interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtIgnore());\n                outerBuilder.modifiers(PUBLIC | ABSTRACT);\n                outerBuilder.resultType(null, makeJavaType(outerType));\n                classBuilder.defs(outerBuilder.build());\n                }\n            }\n            \n        }\n        \n        if (def instanceof Tree.AnyClass) {\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)\n                        || decl.isToplevel()) {\n                    // TODO What about local interfaces?\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                \n                // Generate $outer() impl if implementing an inner interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), true, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtOverride());\n                outerBuilder.annotations(makeAtIgnore());\n                outerBuilder.modifiers(FINAL | PUBLIC);\n                outerBuilder.resultType(null, makeJavaType(iface.getType().getQualifyingType()));\n                outerBuilder.body(make().Return(makeQuotedIdent(\"$outer\")));\n                classBuilder.defs(outerBuilder.build());\n            }\n        }\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (def instanceof Tree.AnyClass && Decl.isToplevel(def) && !Decl.isAbstract(def)) {\n            com.redhat.ceylon.compiler.typechecker.model.Class c = (com.redhat.ceylon.compiler.typechecker.model.Class) def.getDeclarationModel();\n            if (c.getParameterList().getParameters().isEmpty()) {\n                // Add a main() method\n                at(null);\n                JCExpression nameId = makeQuotedFQIdent(c.getQualifiedNameString());\n                JCNewClass expr = make().NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null);\n                classBuilder.body(makeMainMethod(def.getDeclarationModel(), expr));\n            }\n        }\n        \n        return classBuilder\n            .modelAnnotations(def.getDeclarationModel().getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .caseTypes(def.getDeclarationModel().getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","commit_id":"d68eb48217b245e008d831c56ba0dd1f08f40a2b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(Tree.AnyMethod def, ClassDefinitionBuilder classBuilder) {\n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final Method model = def.getDeclarationModel();\n        \n        java.util.List<ParameterList> parameterLists = def.getParameterLists();\n        boolean mpl = parameterLists.size() > 1;\n        ProducedType innerResultType = model.getType();\n        ProducedType resultType = innerResultType;\n        boolean isVoid = gen().isVoid(def.getType().getTypeModel());\n        // Transform the method body of the 'inner-most method'\n        List<JCStatement> body = null;\n        if (def instanceof Tree.MethodDefinition) {\n            Scope container = model.getContainer();\n            boolean isInterface = container instanceof com.redhat.ceylon.compiler.typechecker.model.Interface;\n            if(!isInterface){\n                body = statementGen().transform(((Tree.MethodDefinition)def).getBlock()).getStatements();\n            }\n        } else if (def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() != null) {\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), ((MethodDeclaration) def).getSpecifierExpression(), def.getDeclarationModel());\n            if (isVoid) {\n                body = List.<JCStatement>of(make().Exec(specifierBuilder.build()));\n            } else {\n                body = List.<JCStatement>of(make().Return(specifierBuilder.build()));\n            }\n        }\n        \n        // Construct all but the outer-most method\n        for (int index = parameterLists.size() - 1; index >  0; index--) {\n            resultType = gen().typeFact().getCallableType(resultType);\n            CallableBuilder cb = CallableBuilder.mpl(gen(), resultType, def.getDeclarationModel().getParameterLists().get(index), body);\n            body = List.<JCStatement>of(make().Return(cb.build()));\n        }\n        \n        // Finally construct the outermost method using the body we've built so far\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(), \n                Util.quoteMethodNameIfProperty(model, gen()));\n        \n        ParameterList paramList = parameterLists.get(0);\n        \n        if (mpl) {\n            methodBuilder.resultType(null, makeJavaType(resultType));\n        } else {\n            methodBuilder.resultType(model);\n        }\n        \n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            methodBuilder.parameter(param);\n            // Does the parameter have a default value?\n            if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                JCMethodDecl defaultValueMethodImpl = transformDefaultedParameter(false, param, def, paramList);\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    lb.add(defaultValueMethodImpl);\n                } else {\n                    lb.add(transformDefaultedParameter(true, param, def, paramList));\n                    classBuilder.getCompanionBuilder().defs(defaultValueMethodImpl);\n                }\n            }\n        }\n        \n        if (body != null) {\n            methodBuilder.body(body);\n        } else {\n            methodBuilder.noBody();\n        }\n        \n        if(Util.hasCompilerAnnotation(def, \"test\")){\n            methodBuilder.annotations(List.of(make().Annotation(makeQualIdentFromString(\"org.junit.Test\"), List.<JCTree.JCExpression>nil())));\n        }\n        \n        methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(Decl.isActual(def))\n            .modelAnnotations(model.getAnnotations());\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            DefaultArgument defaultArgument = param.getDefaultArgument();\n            if (defaultArgument != null) {\n                MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(),\n                        Util.quoteMethodNameIfProperty(model, gen()));\n                JCMethodDecl overloadedMethod = transformForDefaultedParameter(overloadBuilder, \n                        def, model, isVoid, paramList, param).build();\n                lb.prepend(overloadedMethod);\n            }\n        }\n        \n        // Generate an impl for overloaded methods using the $impl instance\n        // TODO MPL\n        if (Decl.withinInterface(model.getRefinedDeclaration())\n                && !Decl.withinInterface(model)) {\n            java.util.List<Parameter> parameters = model.getParameterLists().get(0).getParameters();\n            for (Parameter p : parameters) {\n                if (p.isDefaulted()) {\n                    classBuilder.defs(transformDefaultValueMethodImpl(model, parameters, p));\n                    classBuilder.defs(overloadMethodImpl(model, parameters, p));\n                }\n            }\n        }\n        \n        lb.prepend(methodBuilder.build());\n        \n        return lb.toList();\n    }","id":40241,"modified_method":"public List<JCTree> transform(Tree.AnyMethod def, ClassDefinitionBuilder classBuilder) {\n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final Method model = def.getDeclarationModel();\n        final String methodName = Util.quoteMethodNameIfProperty(model, gen());\n        \n        java.util.List<ParameterList> parameterLists = def.getParameterLists();\n        boolean mpl = parameterLists.size() > 1;\n        ProducedType innerResultType = model.getType();\n        ProducedType resultType = innerResultType;\n        boolean isVoid = gen().isVoid(def.getType().getTypeModel());\n        // Transform the method body of the 'inner-most method'\n        List<JCStatement> body = null;\n        if (def instanceof Tree.MethodDefinition) {\n            Scope container = model.getContainer();\n            boolean isInterface = container instanceof com.redhat.ceylon.compiler.typechecker.model.Interface;\n            if(!isInterface){\n                body = statementGen().transform(((Tree.MethodDefinition)def).getBlock()).getStatements();\n            }\n        } else if (def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() != null) {\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), ((MethodDeclaration) def).getSpecifierExpression(), def.getDeclarationModel());\n            if (isVoid) {\n                body = List.<JCStatement>of(make().Exec(specifierBuilder.build()));\n            } else {\n                body = List.<JCStatement>of(make().Return(specifierBuilder.build()));\n            }\n        }\n        \n        // Construct all but the outer-most method\n        for (int index = parameterLists.size() - 1; index >  0; index--) {\n            resultType = gen().typeFact().getCallableType(resultType);\n            CallableBuilder cb = CallableBuilder.mpl(gen(), resultType, def.getDeclarationModel().getParameterLists().get(index), body);\n            body = List.<JCStatement>of(make().Return(cb.build()));\n        }\n        \n        // Finally construct the outermost method using the body we've built so far\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(), \n                methodName);\n        \n        ParameterList paramList = parameterLists.get(0);\n        \n        if (mpl) {\n            methodBuilder.resultType(null, makeJavaType(resultType));\n        } else {\n            methodBuilder.resultType(model);\n        }\n        \n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            methodBuilder.parameter(param);\n            // Does the parameter have a default value?\n            if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                JCMethodDecl defaultValueMethodImpl = transformDefaultedParameter(false, param, def, paramList);\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    lb.add(defaultValueMethodImpl);\n                } else {\n                    lb.add(transformDefaultedParameter(true, param, def, paramList));\n                    classBuilder.getCompanionBuilder().defs(defaultValueMethodImpl);\n                }\n            }\n        }\n        \n        if (body != null) {\n            methodBuilder.body(body);\n        } else {\n            methodBuilder.noBody();\n        }\n        \n        if(Util.hasCompilerAnnotation(def, \"test\")){\n            methodBuilder.annotations(List.of(make().Annotation(makeQualIdentFromString(\"org.junit.Test\"), List.<JCTree.JCExpression>nil())));\n        }\n        \n        methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(Decl.isActual(def))\n            .modelAnnotations(model.getAnnotations());\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            DefaultArgument defaultArgument = param.getDefaultArgument();\n            if (defaultArgument != null) {\n                MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(),\n                        methodName);\n                JCMethodDecl overloadedMethod = transformForDefaultedParameter(overloadBuilder, \n                        def, model, isVoid, paramList, param).build();\n                lb.prepend(overloadedMethod);\n            }\n        }\n        \n        // Generate an impl for overloaded methods using the $impl instance\n        // TODO MPL\n        if (Decl.withinInterface(model.getRefinedDeclaration())\n                && !Decl.withinInterface(model)) {\n            java.util.List<Parameter> parameters = model.getParameterLists().get(0).getParameters();\n            for (Parameter p : parameters) {\n                if (p.isDefaulted()) {\n                    classBuilder.defs(transformDefaultValueMethodImpl(model, parameters, p));\n                    classBuilder.defs(overloadMethodImpl(model, parameters, p));\n                }\n            }\n        }\n        \n        // If \n        if (Decl.withinInterface(model)\n                && def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() == null) {\n            MethodDefinitionBuilder delegateBuilder = MethodDefinitionBuilder.method(gen(), false, true, methodName);\n            delegateBuilder.modifiers(PRIVATE | FINAL);\n            if (def.getTypeParameterList() != null) {\n                for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                    delegateBuilder.typeParameter(t);\n                }\n            }\n            delegateBuilder.resultType(model);\n            ListBuffer<JCExpression> arguments = ListBuffer.<JCExpression>lb();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                delegateBuilder.parameter(param);\n                arguments.append(makeQuotedIdent(param.getDeclarationModel().getName()));\n            }\n            JCExpression expr = make().Apply(\n                    typeParams(model),\n                    makeSelect(\"$this\", methodName), \n                    arguments.toList());\n            if (isVoid) {\n                delegateBuilder.body(make().Exec(expr));\n            } else {\n                delegateBuilder.body(make().Return(expr));\n            }\n            classBuilder.getCompanionBuilder().defs(delegateBuilder.build());\n        }\n        \n        lb.prepend(methodBuilder.build());\n        \n        return lb.toList();\n    }","commit_id":"d68eb48217b245e008d831c56ba0dd1f08f40a2b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCMethodDecl transformConcreteInterfaceMember(MethodDefinition def, ProducedType type) {\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), true, Util.quoteMethodNameIfProperty(def.getDeclarationModel(), gen()));\n        \n        JCExpression typeExpr = makeJavaType(type);\n        methodBuilder.parameter(FINAL, \"$this\", typeExpr, List.<JCTree.JCAnnotation>nil());\n        for (Tree.Parameter param : def.getParameterLists().get(0).getParameters()) {\n            methodBuilder.parameter(param);\n        }\n\n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n\n        if (!(def.getType() instanceof VoidModifier)) {\n            methodBuilder.resultType(def.getDeclarationModel());\n        }\n        \n        // FIXME: this needs rewriting to map non-qualified refs to $this\n        JCBlock body = statementGen().transform(def.getBlock());\n        methodBuilder.block(body);\n                \n        return methodBuilder\n            .modifiers(transformMethodDeclFlags(def) | STATIC)\n            .isActual(Decl.isActual(def))\n            .build();\n    }","id":40242,"modified_method":"public JCMethodDecl transformConcreteInterfaceMember(MethodDefinition def, ProducedType type) {\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), true, Util.quoteMethodNameIfProperty(def.getDeclarationModel(), gen()));\n        \n        for (Tree.Parameter param : def.getParameterLists().get(0).getParameters()) {\n            methodBuilder.parameter(param);\n        }\n\n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n\n        if (!(def.getType() instanceof VoidModifier)) {\n            methodBuilder.resultType(def.getDeclarationModel());\n        }\n        \n        // FIXME: this needs rewriting to map non-qualified refs to $this\n        JCBlock body = statementGen().transform(def.getBlock());\n        methodBuilder.block(body);\n                \n        return methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(Decl.isActual(def))\n            .build();\n    }","commit_id":"d68eb48217b245e008d831c56ba0dd1f08f40a2b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n    * Capture 3xx return codes - specifically, if 301/302, then go tp the\n    * redirected url - note, this in turn may also be redirected.\n    * Note - do as little network connecting as possible. So as a start, assume\n    * \"ubc.ca\" domain images will not be redirected so skip these ones.\n    * @param value\n    * @return value\n    */\n    private static String capture3XXCodes(String value){\n        try{\n            String skip_protocol = value.substring(7);\n            String domain_only = skip_protocol.substring(0,skip_protocol.indexOf(\"/\"));\n            String work_value = value;\n            if (PROXY_REWRITE_NO_REDIRECT_DOMAIN.length() > 0 && !domain_only.endsWith(PROXY_REWRITE_NO_REDIRECT_DOMAIN)) {\n                boolean getRedirect = true;\n                while (getRedirect) {\n                    AddressTester tester = new AddressTester(work_value);\n                    int responseCode = tester.getResponseCode();\n                    if (responseCode != 301 ||responseCode != 302){\n                        LogService.log(LogService.DEBUG,\"ProxyWriter::capture3XXCodes(): could not get deeper in getting the image.\");\n                        return work_value;\n                    }\n                    getRedirect = false;\n                    URL url;\n                    url = new URL(work_value);\n                    URLConnection urlConnect = url.openConnection();\n                    HttpURLConnection httpUrlConnect = (HttpURLConnection) urlConnect;\n                    httpUrlConnect.setRequestMethod(\"HEAD\");\n                    httpUrlConnect.setInstanceFollowRedirects(false);\n                    httpUrlConnect.connect();\n                    int response = httpUrlConnect.getResponseCode();\n                    String location = httpUrlConnect.getHeaderField(\"Location\");\n                    httpUrlConnect.disconnect();\n                    if (response == 301 || response == 302) {\n                        getRedirect = true;\n                        work_value = location;\n                    }\n               }\n               if (!work_value.equals(value))\n                   value = work_value;\n            }\n\n            return value;\n\n         }catch(Exception e){\n             LogService.log(LogService.ERROR,\"ProxyWriter::catpture3XXCodes():Failed to rewrite the value: \" + e.getMessage());\n             return value;\n         }\n    }","id":40243,"modified_method":"/**\n    * Capture 3xx return codes - specifically, if 301/302, then go tp the\n    * redirected url - note, this in turn may also be redirected.\n    * Note - do as little network connecting as possible. So as a start, assume\n    * \"ubc.ca\" domain images will not be redirected so skip these ones.\n    * @param value\n    * @return value\n    */\n    private static String capture3XXCodes(String value){\n        try{\n            String skip_protocol = value.substring(7);\n            String domain_only = skip_protocol.substring(0,skip_protocol.indexOf(\"/\"));\n            String work_value = value;\n            if (PROXY_REWRITE_NO_REDIRECT_DOMAIN.length() > 0 && !domain_only.endsWith(PROXY_REWRITE_NO_REDIRECT_DOMAIN)) {\n              while (true) {\n                AddressTester tester = new AddressTester(work_value, true);\n                try {\n                  int responseCode = tester.getResponseCode();\n                  if (responseCode != HttpURLConnection.HTTP_MOVED_PERM &&\n                      responseCode != HttpURLConnection.HTTP_MOVED_TEMP) {\n                    LogService.log(LogService.DEBUG,\n                      \"ProxyWriter::capture3XXCodes(): could not get deeper in getting the image.\");\n                    return work_value;\n                  }\n\n                  /* At this point we will have a redirect directive */\n\n                  HttpURLConnection httpUrlConnect = (HttpURLConnection) tester.getConnection();\n                  httpUrlConnect.connect();\n\n                  work_value = httpUrlConnect.getHeaderField(\"Location\"); ;\n                } finally {\n                  tester.disconnect();\n                }\n              }\n            }\n\n            return value;\n\n         } catch(Exception e) {\n             LogService.log(LogService.ERROR,\"ProxyWriter::catpture3XXCodes():Failed to rewrite the value: \" + e.getMessage());\n             return value;\n         }\n    }","commit_id":"1d1cfc11313b342904e169e103c62f47ba0aa767","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Examines whther or not the proxying should be done and if so handles differnt situations by delegating\n     * the rewrite to other methods n the class.\n     * @param name\n     * @param localName\n     * @param value\n     * @return value\n     */\n    protected static String considerProxyRewrite(String name, String localName, String value)\n    {\n\n        if ((PROXY_ENABLED==true)&&((name.equalsIgnoreCase(\"src\"))||(name.equalsIgnoreCase(\"archive\")))&&(value.indexOf(\"http://\")!=-1))\n        {\n\n            //capture any resource redirect and set the value to the real address while proxying it\n            value = capture3XXCodes(value);\n\n            //if there is a script element with a src attribute the src should be rewriten\n            if(localName.equalsIgnoreCase(\"script\")){\n                value = reWrite(value);\n                return value;\n            }\n\n            //handle normal proxies\n            for (int i=0; i<_proxiableElements.length; i++)\n            {\n                if (localName.equalsIgnoreCase(_proxiableElements[i]))\n                {\n                    value = PROXY_REWRITE_PREFIX + value.substring(7);\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":40244,"modified_method":"/**\n     * Examines whther or not the proxying should be done and if so handles differnt situations by delegating\n     * the rewrite to other methods n the class.\n     * @param name\n     * @param localName\n     * @param value\n     * @return value\n     */\n    protected static String considerProxyRewrite(String name, String localName, String value)\n    {\n        if (PROXY_ENABLED && (name.equalsIgnoreCase(\"src\") || name.equalsIgnoreCase(\"archive\")) &&\n            value.indexOf(\"http://\")!=-1)\n        {\n\n            //capture any resource redirect and set the value to the real address while proxying it\n            value = capture3XXCodes(value);\n\n            //if there is a script element with a src attribute the src should be rewriten\n            if(localName.equalsIgnoreCase(\"script\")){\n                value = reWrite(value);\n                return value;\n            }\n\n            //handle normal proxies\n            for (int i=0; i<_proxiableElements.length; i++)\n            {\n                if (localName.equalsIgnoreCase(_proxiableElements[i]))\n                {\n                    value = PROXY_REWRITE_PREFIX + value.substring(7);\n                    break;\n                }\n            }\n        }\n        return value;\n    }","commit_id":"1d1cfc11313b342904e169e103c62f47ba0aa767","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * This method uses a URI and creates an html file name by simply ominting some characters from the URI.\n    * The purpose of using the address for the file name is that the file names will be unique and map to addresses.\n    * @param addr: is the address of the file\n    * @newName: is the name built form the address\n    */\n    private static String fileNameGenerator(String addr)\n    {\n        String newName = CommonUtils.replaceText(addr, \"/\", \"\");\n        newName = CommonUtils.replaceText(newName, \"http:\", \"\");\n        newName = CommonUtils.replaceText(newName, \"www.\", \"\");\n        newName = CommonUtils.replaceText(newName, \".\", \"\");\n        newName = CommonUtils.replaceText(newName, \"?\", \"\");\n        newName = CommonUtils.replaceText(newName, \"&\", \"\");\n        try {\n               newName = newName.substring(0,16) + \".html\";\n        } catch(IndexOutOfBoundsException ignore){\n           //could not truncate the file name then it is short enough send it as it is\n           return newName + \".html\";\n        }\n           return newName;\n    }","id":40245,"modified_method":"/**\n    * This method uses a URI and creates an html file name by simply omiting some characters from the URI.\n    * The purpose of using the address for the file name is that the file names will be unique and map to addresses.\n    * @param addr: is the address of the file\n    * @newName: is the name built form the address\n    */\n    private static String fileNameGenerator(String addr)\n    {\n        String newName = CommonUtils.replaceText(addr, \"/\", \"\");\n        newName = CommonUtils.replaceText(newName, \"http:\", \"\");\n        newName = CommonUtils.replaceText(newName, \"www.\", \"\");\n        newName = CommonUtils.replaceText(newName, \".\", \"\");\n        newName = CommonUtils.replaceText(newName, \"?\", \"\");\n        newName = CommonUtils.replaceText(newName, \"&\", \"\");\n\n        return newName.substring(0, Math.min(16, newName.length())) + \".html\";\n    }","commit_id":"1d1cfc11313b342904e169e103c62f47ba0aa767","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * This method rewrites include javascript files and replaces the refrences in these files\n     * to images' sources to use proxy.\n     * @param scriptUri: The string representing the address of script\n     * @return value: The new address of the script file which image sources have been rewritten\n     */\n     private static String  reWrite(String scriptUri){\n        String filePath = null;\n        String fileName = null;\n        BufferedReader in = null;\n        FileWriter out = null;\n        try{\n            fileName = fileNameGenerator(scriptUri);\n            filePath = PROXIED_FILES_PATH + fileName;\n            File outputFile = new File(filePath);\n            if ((outputFile.exists()==false) || (System.currentTimeMillis()-outputFile.lastModified()>(1800 * 1000)))\n            {\n              try{\n                AddressTester tester = new AddressTester(scriptUri);\n                if (tester.URLAvailable() == false){\n                  LogService.log(LogService.ERROR,\"ProxyWriter::rewrite(): The adress \" + scriptUri + \" is not available. \");\n                  return scriptUri;\n                }\n                URL url;\n                url = new URL(scriptUri);\n                URLConnection urlConnect = url.openConnection();\n                HttpURLConnection httpUrlConnect = (HttpURLConnection) urlConnect;\n                httpUrlConnect.setInstanceFollowRedirects(false);\n                httpUrlConnect.connect();\n                int response = httpUrlConnect.getResponseCode();\n                in = new BufferedReader(new InputStreamReader(httpUrlConnect.getInputStream()));\n                String line;\n                String newLine;\n                out = new FileWriter(outputFile);\n                while((line = in.readLine()) != null){\n                   newLine = processLine(line);\n                   out.write(newLine + \"\\t\\n\");\n                 }\n                 httpUrlConnect.disconnect();\n                 in.close();\n                 out.close();\n               }catch(Exception e){\n                 LogService.log(LogService.ERROR,\"ProxyWriter::rewrite():Failed to rewrite the file for: \" + scriptUri + \" \" + e.getMessage());\n                 if(in != null)\n                    in.close();\n                 if(out != null)\n                    out.close();\n                 outputFile.delete();\n                 return scriptUri;\n               }//end catch\n             }\n             AddressTester tester = new AddressTester(PROXIED_FILES_URI + fileName);\n             if (tester.URLAvailable() == false){\n                 LogService.log(LogService.ERROR,\"ProxyWriter::rewrite(): The file  \"  + filePath + \" is written but cannot be reached \");\n                 return scriptUri;\n             }else{\n                 return PROXY_REWRITE_PREFIX + PROXIED_FILES_URI.substring(7) + fileName;\n            }\n\n         }catch(Exception e){\n             LogService.log(LogService.ERROR,\"ProxyWriter::rewrite():Failed to read the file at : \"  + filePath + \" \" + e.getMessage());\n             return scriptUri;\n          }\n    }","id":40246,"modified_method":"/**\n     * This method rewrites include javascript files and replaces the refrences in these files\n     * to images' sources to use proxy.\n     * @param scriptUri: The string representing the address of script\n     * @return value: The new address of the script file which image sources have been rewritten\n     */\n     private static String  reWrite(String scriptUri){\n        String filePath = null;\n        String fileName = null;\n        try{\n            fileName = fileNameGenerator(scriptUri);\n            filePath = PROXIED_FILES_PATH + fileName;\n            File outputFile = new File(filePath);\n            if (!outputFile.exists() || (System.currentTimeMillis()-outputFile.lastModified() > 1800 * 1000))\n            {\n              try{\n                AddressTester tester = new AddressTester(scriptUri);\n                try {\n                  if (!tester.URLAvailable()){\n                    LogService.log(LogService.ERROR,\"ProxyWriter::rewrite(): The adress \" + scriptUri + \" is not available. \");\n                    return scriptUri;\n                  }\n                  HttpURLConnection httpUrlConnect = (HttpURLConnection) tester.getConnection();\n                  httpUrlConnect.connect();\n                  BufferedReader in = new BufferedReader(new InputStreamReader(httpUrlConnect.getInputStream()));\n                  try {\n                    FileWriter out = new FileWriter(outputFile);\n                    try {\n                      String line;\n                      while ((line = in.readLine()) != null) {\n                        out.write(processLine(line) + \"\\t\\n\");\n                      }\n                    } finally {\n                      out.close();\n                    }\n                  } finally {\n                    in.close();\n                  }\n                } finally {\n                  tester.disconnect();\n                }\n              } catch(Exception e) {\n                 LogService.log(LogService.ERROR,\n                                \"ProxyWriter::rewrite():Failed to rewrite the file for: \" +\n                                scriptUri + \" \" + e.getMessage());\n                 outputFile.delete();\n                 return scriptUri;\n               } //end catch\n             }\n             String newScriptPath = PROXIED_FILES_URI + fileName;\n             AddressTester tester = new AddressTester(newScriptPath);\n             try {\n               if (!tester.URLAvailable()) {\n                 LogService.log(LogService.ERROR,\n                                \"ProxyWriter::rewrite(): The file  \" + filePath +\n                                \" is written but cannot be reached at \" +\n                                newScriptPath);\n                 return scriptUri;\n               } else {\n                 return PROXY_REWRITE_PREFIX + PROXIED_FILES_URI.substring(7) +\n                   fileName;\n               }\n             } finally {\n               tester.disconnect();\n             }\n\n         } catch(Exception e) {\n             LogService.log(LogService.ERROR,\"ProxyWriter::rewrite():Failed to read the file at : \"  + filePath + \" \" + e.getMessage());\n             return scriptUri;\n          }\n    }","commit_id":"1d1cfc11313b342904e169e103c62f47ba0aa767","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\r\n    public void messageReceived( IoSession session, Object message ) throws Exception\r\n    {\r\n    \tif (message instanceof CaptureStartMessage) {\r\n    \t\tSystem.out.println(\"Got CaptureStartBlockEvent\");\r\n    \t\tCaptureStartMessage event = (CaptureStartMessage) message;\r\n//    \t\tsessionManager.createSession(event.getRoom());\r\n    \t} else if (message instanceof CaptureUpdateMessage) {\r\n//    \t\tSystem.out.println(\"Got CaptureUpdateBlockEvent\");\r\n    \t\tCaptureUpdateMessage event = (CaptureUpdateMessage) message;\r\n//    \t\tsessionManager.updateBlock(event.getRoom(), event.getSequenceNum());\r\n\t\t\tSharingStatus sharingStatus = app.getSharingStatus(event.getRoom(), event.getRoom()) ;\r\n    \t\tif (sharingStatus.sharingStopped) {\r\n    \t\t\t// The flash client told us to stop sharing. Force stopping by closing connection from applet.\r\n    \t\t\t// We're changing how to tell the applet to stop sharing as AS ExternalInterface to JS to Applet calls\r\n    \t\t\t// generates a popup dialog that users may or may not see causing the browser to hang. (ralam aug 24, 2014)\r\n    \t\t\tlog.info(\"Sharing has stopped for meeting [\" + event.getRoom() + \"]. Closing connection.\");\r\n    \t\t\tsession.close(true);\r\n    \t\t}\r\n    \t} else if (message instanceof CaptureEndMessage) {\r\n    \t\tCaptureEndMessage event = (CaptureEndMessage) message;\r\n//    \t\tsessionManager.removeSession(event.getRoom(), event.getSequenceNum());\r\n    \t} else if (message instanceof MouseLocationMessage) {\r\n    \t\tMouseLocationMessage event = (MouseLocationMessage) message;\r\n//    \t\tsessionManager.updateMouseLocation(event.getRoom(), event.getLoc(), event.getSequenceNum());\r\n    \t}\r\n    }","id":40247,"modified_method":"@Override\r\n    public void messageReceived( IoSession session, Object message ) throws Exception\r\n    {\r\n    \tif (message instanceof CaptureStartMessage) {\r\n    \t\tSystem.out.println(\"Got CaptureStartBlockEvent\");\r\n    \t\tCaptureStartMessage event = (CaptureStartMessage) message;\r\n//    \t\tsessionManager.createSession(event.getRoom());\r\n    \t} else if (message instanceof CaptureUpdateMessage) {\r\n//    \t\tSystem.out.println(\"Got CaptureUpdateBlockEvent\");\r\n    \t\tCaptureUpdateMessage event = (CaptureUpdateMessage) message;\r\n//    \t\tsessionManager.updateBlock(event.getRoom(), event.getSequenceNum());\r\n\t\t\tSharingStatus sharingStatus = app.getSharingStatus(event.getRoom(), event.getRoom()) ;\r\n    \t\tif (sharingStatus.equals(\"STOP\")) {\r\n    \t\t\t// The flash client told us to stop sharing. Force stopping by closing connection from applet.\r\n    \t\t\t// We're changing how to tell the applet to stop sharing as AS ExternalInterface to JS to Applet calls\r\n    \t\t\t// generates a popup dialog that users may or may not see causing the browser to hang. (ralam aug 24, 2014)\r\n    \t\t\tlog.info(\"Sharing has stopped for meeting [\" + event.getRoom() + \"]. Closing connection.\");\r\n    \t\t\tsession.close(true);\r\n    \t\t}\r\n    \t} else if (message instanceof CaptureEndMessage) {\r\n    \t\tCaptureEndMessage event = (CaptureEndMessage) message;\r\n//    \t\tsessionManager.removeSession(event.getRoom(), event.getSequenceNum());\r\n    \t} else if (message instanceof MouseLocationMessage) {\r\n    \t\tMouseLocationMessage event = (MouseLocationMessage) message;\r\n//    \t\tsessionManager.updateMouseLocation(event.getRoom(), event.getLoc(), event.getSequenceNum());\r\n    \t}\r\n    }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public ModelAndView screenCaptureHandler(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\t\r\n\t\tString event = request.getParameterValues(\"event\")[0];\t\r\n\t\tint captureRequest = Integer.parseInt(event);\r\n\r\n\t\tif (0 == captureRequest) {\r\n\t\t\thandleCaptureStartRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t} else if (1 == captureRequest) {\r\n\t\t\thandleCaptureUpdateRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t\tSharingStatus sharingStatus =  getSharingStatus(request, response);\r\n\t\t\tif (sharingStatus.sharingStopped) {\r\n\t\t\t\t//response.setStatus(HttpServletResponse.SC_NOT_FOUND);\r\n\t\t\t\tlog.warn(\"SHARING_STOPPED \" + sharingStatus.sharingStopped);\r\n\t\t\t\tresponse.addHeader(\"SHARING_STOPPED\", \"true\");\r\n\t\t\t} else if (sharingStatus.sharingPaused) {\r\n                //response.setStatus(HttpServletResponse.SC_NO_CONTENT);\r\n\t\t\t\tlog.warn(\"SHARING_PAUSED \" + sharingStatus.sharingPaused);\r\n\t\t\t\tresponse.addHeader(\"SHARING_PAUSED\", \"true\");\r\n            }\r\n\t\t} else if (2 == captureRequest) {\r\n\t\t\thandleCaptureEndRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t} else {\t\t\r\n\t\t\tlog.warn(\"Cannot handle screen capture event \" + captureRequest);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":40248,"modified_method":"public ModelAndView screenCaptureHandler(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\t\r\n\t\tString event = request.getParameterValues(\"event\")[0];\t\r\n\t\tint captureRequest = Integer.parseInt(event);\r\n\r\n\t\tif (0 == captureRequest) {\r\n\t\t\thandleCaptureStartRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t} else if (1 == captureRequest) {\r\n\t\t\thandleCaptureUpdateRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t\tSharingStatus sharingStatus =  getSharingStatus(request, response);\r\n\t\t\tlog.warn(\"SHARING_STATUS \" + sharingStatus.status);\r\n\t\t\tresponse.addHeader(\"SHARING_STATUS\", sharingStatus.status);\r\n\t\t} else if (2 == captureRequest) {\r\n\t\t\thandleCaptureEndRequest(request, response);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t} else {\t\t\r\n\t\t\tlog.warn(\"Cannot handle screen capture event \" + captureRequest);\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendUpdateMessage(ShareUpdateMessage message) {\r\n      ClientHttpRequest chr;\r\n\r\n      try {\r\n        // Open a connection to the web server and create a request that has\r\n        // the room and event type.\r\n//        System.out.println(getTimeStamp() + \" - Sending Update Sharing Event.\");\r\n        openConnection();\r\n        chr = new ClientHttpRequest(conn);\r\n        chr.setParameter(MEETING_ID, meetingId);\r\n        chr.setParameter(STREAM_ID, streamId);\r\n        chr.setParameter(EVENT, CaptureEvents.CAPTURE_UPDATE.getEvent());\r\n\r\n        // Post the multi-part form to the server\r\n        chr.post();\r\n        HttpURLConnection httpConnection = (HttpURLConnection) chr.connection;\r\n        int status = httpConnection.getResponseCode();\r\n\r\n        System.out.println(\"******* sendUpdateMessage response code = [\" + status + \"] ***************\");\r\n        String sharingStopped =  httpConnection.getHeaderField(\"SHARING_STOPPED\");\r\n        String sharingPaused =  httpConnection.getHeaderField(\"SHARING_PAUSED\");\r\n\r\n        if (sharingStopped != null) {\r\n          System.out.println(\"******* sendUpdateMessage sharingStopped = [\" + sharingStopped + \"] ***************\");\r\n          if (sharingStopped.toUpperCase().equals(\"TRUE\")) {\r\n           notifyNetworkStreamListener(ExitCode.NORMAL);\r\n          }\r\n        } else if (sharingPaused != null) {\r\n          System.out.println(\"******* sendUpdateMessage sharingPaused = [\" + sharingPaused + \"] ***************\");\r\n          if (sharingPaused.toUpperCase().equals(\"TRUE\")) {\r\n            notifyNetworkStreamListener(ExitCode.PAUSED);\r\n            System.out.println(\"******* GOT HERE sendUpdateMessage sharingPaused = [\" + sharingPaused + \"] ***************\");\r\n          }\r\n        }\r\n\r\n      } catch (IOException e) {\r\n        System.out.println(\"Exception in sendUpdateMessage\");\r\n        notifyNetworkStreamListener(ExitCode.NORMAL);\r\n      } catch (ConnectionException e) {\r\n        System.out.println(\"ERROR: Failed to send block data.\");\r\n      }\r\n  }","id":40249,"modified_method":"private void sendUpdateMessage(ShareUpdateMessage message) {\r\n      ClientHttpRequest chr;\r\n\r\n      try {\r\n        // Open a connection to the web server and create a request that has\r\n        // the room and event type.\r\n//        System.out.println(getTimeStamp() + \" - Sending Update Sharing Event.\");\r\n        openConnection();\r\n        chr = new ClientHttpRequest(conn);\r\n        chr.setParameter(MEETING_ID, meetingId);\r\n        chr.setParameter(STREAM_ID, streamId);\r\n        chr.setParameter(EVENT, CaptureEvents.CAPTURE_UPDATE.getEvent());\r\n\r\n        // Post the multi-part form to the server\r\n        chr.post();\r\n        HttpURLConnection httpConnection = (HttpURLConnection) chr.connection;\r\n        int status = httpConnection.getResponseCode();\r\n\r\n        System.out.println(\"******* sendUpdateMessage response code = [\" + status + \"] ***************\");\r\n        String sharingStatus =  httpConnection.getHeaderField(\"SHARING_STATUS\");\r\n\r\n        if (sharingStatus != null) {\r\n          System.out.println(\"******* sendUpdateMessage sharingStopped = [\" + sharingStatus + \"] ***************\");\r\n          if (sharingStatus.toUpperCase().equals(\"STOP\")) {\r\n           notifyNetworkStreamListener(ExitCode.NORMAL);\r\n          } else if (sharingStatus.toUpperCase().equals(\"PAUSE\")) {\r\n            notifyNetworkStreamListener(ExitCode.PAUSED);\r\n            System.out.println(\"******* GOT HERE sendUpdateMessage sharingPaused = [\" + sharingStatus + \"] ***************\");\r\n          } else if (sharingStatus.toUpperCase().equals(\"START\")) {\r\n            notifyNetworkStreamListener(ExitCode.START);\r\n            System.out.println(\"******* GOT HERE sendUpdateMessage sharingStart = [\" + sharingStatus + \"] ***************\");\r\n          }\r\n        }\r\n\r\n      } catch (IOException e) {\r\n        System.out.println(\"Exception in sendUpdateMessage\");\r\n        notifyNetworkStreamListener(ExitCode.NORMAL);\r\n      } catch (ConnectionException e) {\r\n        System.out.println(\"ERROR: Failed to send block data.\");\r\n      }\r\n  }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void start(boolean autoStart) {\r\n    CaptureRegionListener crl = new CaptureRegionListenerImp(this);\r\n    frame = new CaptureRegionFrame(crl, 5);\r\n    frame.setHeight(ssi.captureHeight);\r\n    frame.setWidth(ssi.captureWidth);\r\n    frame.setLocation(ssi.x, ssi.y);\r\n    System.out.println(NAME + \"Launching Screen Capture Frame\");\r\n    paused = false;\r\n    frame.start(autoStart);\r\n  }","id":40250,"modified_method":"public void start(boolean autoStart) {\r\n    if (status.toUpperCase().equals(STOP)) {\r\n      CaptureRegionListener crl = new CaptureRegionListenerImp(this);\r\n      frame = new CaptureRegionFrame(crl, 5);\r\n      frame.setHeight(ssi.captureHeight);\r\n      frame.setWidth(ssi.captureWidth);\r\n      frame.setLocation(ssi.x, ssi.y);\r\n      System.out.println(NAME + \"Launching Screen Capture Frame\");\r\n      status = \"START\";\r\n      frame.start(autoStart);\r\n    }\r\n\r\n  }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void pause() {\r\n    if (!paused) {\r\n      frame.setVisible(false);\r\n      sharer.stopSharing();\r\n      paused = true;\r\n      System.out.println(NAME + \"Paused. *************\");\r\n    }\r\n  }","id":40251,"modified_method":"private void pause() {\r\n    if (status.toUpperCase().equals(PAUSE)) {\r\n      frame.setVisible(false);\r\n      sharer.stopSharing();\r\n      status = PAUSE;\r\n      System.out.println(NAME + \"Paused. *************\");\r\n    }\r\n  }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n  public void networkConnectionException(ExitCode reason) {\r\n    if (listener != null) {\r\n      if (reason.getExitCode() == ExitCode.PAUSED.getExitCode()) {\r\n        System.out.println(NAME + \"Pausing. Reason=\" + reason.getExitCode());\r\n        pause();\r\n      } else {\r\n        System.out.println(NAME + \"Closing. Reason=\" + reason.getExitCode());\r\n        listener.onClientStop(reason);\r\n      }\r\n    }\r\n  }","id":40252,"modified_method":"@Override\r\n  public void networkConnectionException(ExitCode reason) {\r\n    if (listener != null) {\r\n      if (reason.getExitCode() == ExitCode.PAUSED.getExitCode()) {\r\n        System.out.println(NAME + \"Pausing. Reason=\" + reason.getExitCode());\r\n        pause();\r\n      } else if (reason.getExitCode() == ExitCode.START.getExitCode()) {\r\n        System.out.println(NAME + \"Pausing. Reason=\" + reason.getExitCode());\r\n        start(false);\r\n      } else {\r\n        System.out.println(NAME + \"Closing. Reason=\" + reason.getExitCode());\r\n        listener.onClientStop(reason);\r\n      }\r\n    }\r\n  }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void stop() {\r\n    frame.setVisible(false);\r\n    sharer.stopSharing();\r\n    signalChannel.stopSharing();\r\n    tray.removeIconFromSystemTray();\r\n    System.out.println(NAME + \"Closing Screen Capture Frame\");\r\n  }","id":40253,"modified_method":"public void stop() {\r\n    status = STOP;\r\n    frame.setVisible(false);\r\n    sharer.stopSharing();\r\n    signalChannel.stopSharing();\r\n    tray.removeIconFromSystemTray();\r\n    System.out.println(NAME + \"Closing Screen Capture Frame\");\r\n  }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public SharingStatus(Boolean sharingPaused, Boolean sharingStopped) {\n        this.sharingPaused = sharingPaused;\n        this.sharingStopped = sharingStopped;\n    }","id":40254,"modified_method":"public SharingStatus(String status) {\n        this.status = status;\n    }","commit_id":"68916c95f6af5183e51295ae33051b3c945bd514","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/**\n     * Uploads a list of changes in \"diff\" form to the server.\n     *\n     * @param list the list of changed OSM Primitives\n     * @return list of processed primitives\n     * @throws OsmTransferException if something is wrong\n     * @throws OsmTransferCancelledException  if the upload was cancelled by the user\n     */\n    public Collection<OsmPrimitive> uploadDiff(final Collection<OsmPrimitive> list) throws OsmTransferException {\n\n        if (changeset == null) {\n            throw new OsmTransferException(tr(\"No changeset present for diff upload\"));\n        }\n\n\n        final ArrayList<OsmPrimitive> processed = new ArrayList<OsmPrimitive>();\n\n        // this is the asynchronous update task\n        //\n        class UploadDiffTask extends  PleaseWaitRunnable {\n\n            private boolean uploadCancelled = false;\n            private boolean uploadFailed = false;\n            private Throwable lastThrowable = null;\n\n            public UploadDiffTask(String title) {\n                super(title,false /* don't ignore exceptions */);\n            }\n\n            @Override protected void realRun() throws SAXException, IOException {\n                CreateOsmChangeVisitor duv = new CreateOsmChangeVisitor(changeset, OsmApi.this);\n\n                for (OsmPrimitive osm : list) {\n                    int progress = Main.pleaseWaitDlg.progress.getValue();\n                    Main.pleaseWaitDlg.currentAction.setText(tr(\"Preparing...\"));\n                    osm.visit(duv);\n                    Main.pleaseWaitDlg.progress.setValue(progress+1);\n                }\n\n                Main.pleaseWaitDlg.currentAction.setText(tr(\"Uploading...\"));\n\n                String diff = duv.getDocument();\n                try {\n                    String diffresult = sendRequest(\"POST\", \"changeset/\" + changeset.id + \"/upload\", diff);\n                    DiffResultReader.parseDiffResult(diffresult, list, processed, duv.getNewIdMap(), Main.pleaseWaitDlg);\n                } catch (Exception sxe) {\n                    if (isUploadCancelled()) {\n                        // ignore exceptions thrown because the connection is aborted,\n                        // i.e. IOExceptions or SocketExceptions\n                        //\n                        System.out.println(\"Ignoring exception caught because upload is cancelled. Exception is: \" + sxe.toString());\n                        return;\n                    }\n                    uploadFailed = true;\n                    // remember last exception and don't throw it. If it was thrown again it would\n                    // have to be encapsulated in a RuntimeException which would be nested in yet\n                    // another RuntimeException by parent classes.\n                    // Rather check isUploadFailed() and retrieve getLastThrowable() after the task\n                    // is completed\n                    //\n                    lastThrowable = sxe;\n                }\n            }\n\n            @Override protected void finish() {\n                // do nothing\n            }\n\n            @Override protected void cancel() {\n                activeConnection.disconnect();\n                uploadCancelled = true;\n            }\n\n            public boolean isUploadCancelled() {\n                return uploadCancelled;\n            }\n\n            public boolean isUploadFailed() {\n                return uploadFailed;\n            }\n\n            public Throwable getLastThrowable() {\n                return lastThrowable;\n            }\n        }\n\n        UploadDiffTask uploadTask = new UploadDiffTask(tr(\"Uploading data\"));\n\n        // run  data upload as asynchronous task\n        //\n        try {\n            Void result = null;\n            FutureTask<Void> task = new FutureTask<Void>(uploadTask, result);\n            task.run();\n            task.get(); // wait for the task to complete, no return value expected, though\n        }  catch(Throwable e) {\n            if (uploadTask.isUploadCancelled()) {\n                throw new OsmTransferCancelledException();\n            }\n            throw new OsmTransferException(e);\n        }\n\n        // handle failed upload\n        //\n        if (uploadTask.isUploadFailed()) {\n            if (uploadTask.getLastThrowable() != null && uploadTask.getLastThrowable() instanceof OsmTransferException) {\n                OsmTransferException e = (OsmTransferException)uploadTask.getLastThrowable();\n                throw e;\n            }\n            // shouldn't happen, but just in case\n            //\n            throw new OsmTransferException(tr(\"Data upload failed for unknown reason\"));\n        }\n\n        // handle cancelled upload\n        //\n        if (uploadTask.isUploadCancelled()) {\n            throw new OsmTransferCancelledException();\n        }\n\n        return processed;\n    }","id":40255,"modified_method":"/**\n     * Uploads a list of changes in \"diff\" form to the server.\n     *\n     * @param list the list of changed OSM Primitives\n     * @return list of processed primitives\n     * @throws OsmTransferException if something is wrong\n     * @throws OsmTransferCancelledException  if the upload was cancelled by the user\n     */\n    public Collection<OsmPrimitive> uploadDiff(final Collection<OsmPrimitive> list) throws OsmTransferException {\n\n        if (changeset == null)\n            throw new OsmTransferException(tr(\"No changeset present for diff upload\"));\n\n        final ArrayList<OsmPrimitive> processed = new ArrayList<OsmPrimitive>();\n\n\n        CreateOsmChangeVisitor duv = new CreateOsmChangeVisitor(changeset, OsmApi.this);\n\n        for (OsmPrimitive osm : list) {\n            int progress = Main.pleaseWaitDlg.progress.getValue();\n            Main.pleaseWaitDlg.currentAction.setText(tr(\"Preparing...\"));\n            osm.visit(duv);\n            Main.pleaseWaitDlg.progress.setValue(progress+1);\n        }\n\n        Main.pleaseWaitDlg.currentAction.setText(tr(\"Uploading...\"));\n\n        String diff = duv.getDocument();\n        String diffresult = sendRequest(\"POST\", \"changeset/\" + changeset.id + \"/upload\", diff);\n        try {\n            DiffResultReader.parseDiffResult(diffresult, list, processed, duv.getNewIdMap(), Main.pleaseWaitDlg);\n        } catch(Exception e) {\n            throw new OsmTransferException(e);\n        }\n\n        return processed;\n    }","commit_id":"721413d627458e975ceaa394b520c06164110526","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Generic method for sending requests to the OSM API.\n     *\n     * This method will automatically re-try any requests that are answered with a 5xx\n     * error code, or that resulted in a timeout exception from the TCP layer.\n     *\n     * @param requestMethod The http method used when talking with the server.\n     * @param urlSuffix The suffix to add at the server url, not including the version number,\n     *    but including any object ids (e.g. \"/way/1234/history\").\n     * @param requestBody the body of the HTTP request, if any.\n     *\n     * @return the body of the HTTP response, if and only if the response code was \"200 OK\".\n     * @exception OsmTransferException if the HTTP return code was not 200 (and retries have\n     *    been exhausted), or rewrapping a Java exception.\n     */\n    private String sendRequest(String requestMethod, String urlSuffix,\n            String requestBody) throws OsmTransferException {\n\n        if (!initialized) throw new OsmTransferException(tr(\"Not initialized\"));\n\n        StringBuffer responseBody = new StringBuffer();\n        StringBuffer statusMessage = new StringBuffer();\n\n        int retries = 5; // configurable?\n\n        while(true) { // the retry loop\n            try {\n                URL url = new URL(new URL(getBaseUrl()), urlSuffix, new MyHttpHandler());\n                System.out.print(requestMethod + \" \" + url + \"... \");\n                activeConnection = (HttpURLConnection)url.openConnection();\n                activeConnection.setConnectTimeout(15000);\n                activeConnection.setRequestMethod(requestMethod);\n                addAuth(activeConnection);\n\n                if (requestMethod.equals(\"PUT\") || requestMethod.equals(\"POST\")) {\n                    activeConnection.setDoOutput(true);\n                    activeConnection.setRequestProperty(\"Content-type\", \"text/xml\");\n                    OutputStream out = activeConnection.getOutputStream();\n\n                    // It seems that certain bits of the Ruby API are very unhappy upon\n                    // receipt of a PUT/POST message withtout a Content-length header,\n                    // even if the request has no payload.\n                    // Since Java will not generate a Content-length header unless\n                    // we use the output stream, we create an output stream for PUT/POST\n                    // even if there is no payload.\n                    if (requestBody != null) {\n                        BufferedWriter bwr = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"));\n                        bwr.write(requestBody);\n                        bwr.flush();\n                    }\n                    out.close();\n                }\n\n                activeConnection.connect();\n                System.out.println(activeConnection.getResponseMessage());\n                int retCode = activeConnection.getResponseCode();\n\n                if (retCode >= 500) {\n                    if (retries-- > 0) {\n                        sleepAndListen();\n                        continue;\n                    }\n                }\n\n                // populate return fields.\n                responseBody.setLength(0);\n\n                // If the API returned an error code like 403 forbidden, getInputStream\n                // will fail with an IOException.\n                InputStream i = null;\n                try {\n                    i = activeConnection.getInputStream();\n                } catch (IOException ioe) {\n                    i = activeConnection.getErrorStream();\n                }\n                BufferedReader in = new BufferedReader(new InputStreamReader(i));\n\n                String s;\n                while((s = in.readLine()) != null) {\n                    responseBody.append(s);\n                    responseBody.append(\"\\n\");\n                }\n\n                statusMessage.setLength(0);\n                // Look for a detailed error message from the server\n                if (activeConnection.getHeaderField(\"Error\") != null) {\n                    String er = activeConnection.getHeaderField(\"Error\");\n                    System.err.println(\"Error header: \" + er);\n                    statusMessage.append(tr(er));\n                } else if (retCode != 200 && responseBody.length()>0) {\n                    System.err.println(\"Error body: \" + responseBody);\n                    statusMessage.append(tr(responseBody.toString()));\n                } else {\n                    statusMessage.append(activeConnection.getResponseMessage());\n                }\n                activeConnection.disconnect();\n\n                if (retCode != 200) {\n                    throw new OsmTransferException(statusMessage.toString());\n                }\n                return responseBody.toString();\n            } catch (UnknownHostException e) {\n                throw new OsmTransferException(tr(\"Unknown host\")+\": \"+e.getMessage(), e);\n            } catch (SocketTimeoutException e) {\n                if (retries-- > 0)\n                    continue;\n                throw new OsmTransferException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\n            } catch (ConnectException e) {\n                if (retries-- > 0)\n                    continue;\n                throw new OsmTransferException(e.getMessage()+ \" \" + e.getClass().getCanonicalName(), e);\n            } catch (Exception e) {\n                if (e instanceof OsmTransferException) throw (OsmTransferException) e;\n                throw new OsmTransferException(e);\n            }\n        }\n    }","id":40256,"modified_method":"/**\n     * Generic method for sending requests to the OSM API.\n     *\n     * This method will automatically re-try any requests that are answered with a 5xx\n     * error code, or that resulted in a timeout exception from the TCP layer.\n     *\n     * @param requestMethod The http method used when talking with the server.\n     * @param urlSuffix The suffix to add at the server url, not including the version number,\n     *    but including any object ids (e.g. \"/way/1234/history\").\n     * @param requestBody the body of the HTTP request, if any.\n     *\n     * @return the body of the HTTP response, if and only if the response code was \"200 OK\".\n     * @exception OsmTransferException if the HTTP return code was not 200 (and retries have\n     *    been exhausted), or rewrapping a Java exception.\n     */\n    private String sendRequest(String requestMethod, String urlSuffix,\n            String requestBody) throws OsmTransferException {\n\n        if (!initialized) throw new OsmTransferException(tr(\"Not initialized\"));\n\n        StringBuffer responseBody = new StringBuffer();\n\n        int retries = Main.pref.getInteger(\"osm-server.max-num-retries\", DEFAULT_MAX_NUM_RETRIES);\n        retries = Math.max(0,retries);\n\n\n        while(true) { // the retry loop\n            try {\n                URL url = new URL(new URL(getBaseUrl()), urlSuffix, new MyHttpHandler());\n                System.out.print(requestMethod + \" \" + url + \"... \");\n                activeConnection = (HttpURLConnection)url.openConnection();\n                activeConnection.setConnectTimeout(15000);\n                activeConnection.setRequestMethod(requestMethod);\n                addAuth(activeConnection);\n\n                if (requestMethod.equals(\"PUT\") || requestMethod.equals(\"POST\")) {\n                    activeConnection.setDoOutput(true);\n                    activeConnection.setRequestProperty(\"Content-type\", \"text/xml\");\n                    OutputStream out = activeConnection.getOutputStream();\n\n                    // It seems that certain bits of the Ruby API are very unhappy upon\n                    // receipt of a PUT/POST message withtout a Content-length header,\n                    // even if the request has no payload.\n                    // Since Java will not generate a Content-length header unless\n                    // we use the output stream, we create an output stream for PUT/POST\n                    // even if there is no payload.\n                    if (requestBody != null) {\n                        BufferedWriter bwr = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"));\n                        bwr.write(requestBody);\n                        bwr.flush();\n                    }\n                    out.close();\n                }\n\n                activeConnection.connect();\n                System.out.println(activeConnection.getResponseMessage());\n                int retCode = activeConnection.getResponseCode();\n\n                if (retCode >= 500) {\n                    if (retries-- > 0) {\n                        sleepAndListen();\n                        continue;\n                    }\n                }\n\n                // populate return fields.\n                responseBody.setLength(0);\n\n                // If the API returned an error code like 403 forbidden, getInputStream\n                // will fail with an IOException.\n                InputStream i = null;\n                try {\n                    i = activeConnection.getInputStream();\n                } catch (IOException ioe) {\n                    i = activeConnection.getErrorStream();\n                }\n                BufferedReader in = new BufferedReader(new InputStreamReader(i));\n\n                String s;\n                while((s = in.readLine()) != null) {\n                    responseBody.append(s);\n                    responseBody.append(\"\\n\");\n                }\n                String errorHeader = null;\n                // Look for a detailed error message from the server\n                if (activeConnection.getHeaderField(\"Error\") != null) {\n                    errorHeader = activeConnection.getHeaderField(\"Error\");\n                    System.err.println(\"Error header: \" + errorHeader);\n                } else if (retCode != 200 && responseBody.length()>0) {\n                    System.err.println(\"Error body: \" + responseBody);\n                }\n                activeConnection.disconnect();\n\n                if (retCode != 200)\n                    throw new OsmApiException(retCode,errorHeader,responseBody.toString());\n\n                return responseBody.toString();\n            } catch (UnknownHostException e) {\n                throw new OsmTransferException(e);\n            } catch (SocketTimeoutException e) {\n                if (retries-- > 0) {\n                    continue;\n                }\n                throw new OsmTransferException(e);\n            } catch (ConnectException e) {\n                if (retries-- > 0) {\n                    continue;\n                }\n                throw new OsmTransferException(e);\n            } catch (Exception e) {\n                if (e instanceof OsmTransferException) throw (OsmTransferException) e;\n                throw new OsmTransferException(e);\n            }\n        }\n    }","commit_id":"721413d627458e975ceaa394b520c06164110526","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Send the dataset to the server.\n     * @param the_version version of the data set\n     * @param list list of objects to send\n     */\n    public void uploadOsm(String the_version, Collection<OsmPrimitive> list) {\n        processed = new LinkedList<OsmPrimitive>();\n\n        // initialize API. Abort upload in case of configuration or network\n        // errors\n        //\n        try {\n            api.initialize();\n        } catch(Exception e) {\n            JOptionPane.showMessageDialog(\n                null,\n                tr(   \"Failed to initialize communication with the OSM server {0}.\\n\"\n                    + \"Check the server URL in your preferences and your internet connection.\",\n                    Main.pref.get(\"osm-server.url\")\n                ),\n                tr(\"Error\"),\n                JOptionPane.ERROR_MESSAGE\n            );\n            e.printStackTrace();\n            return;\n        }\n\n        Main.pleaseWaitDlg.progress.setMaximum(list.size());\n        Main.pleaseWaitDlg.progress.setValue(0);\n\n        boolean useChangesets = api.hasChangesetSupport();\n\n        // controls whether or not we try and upload the whole bunch in one go\n        boolean useDiffUploads = Main.pref.getBoolean(\"osm-server.atomic-upload\",\n            \"0.6\".equals(api.getVersion()));\n\n        // create changeset if required\n        try {\n            if (useChangesets) {\n                // add the last entered comment to the changeset\n                String cmt = \"\";\n                List<String> history = new LinkedList<String>(\n                Main.pref.getCollection(UploadAction.HISTORY_KEY, new LinkedList<String>()));\n                if(history.size() > 0) {\n                    cmt = history.get(0);\n                }\n                api.createChangeset(cmt);\n            }\n        } catch (OsmTransferException ex) {\n            dealWithTransferException(ex);\n            return;\n        }\n\n        try {\n            if (useDiffUploads) {\n                // all in one go\n                processed.addAll(api.uploadDiff(list));\n            } else {\n                // upload changes individually (90% of code is for the status display...)\n                NameVisitor v = new NameVisitor();\n                uploadStartTime = System.currentTimeMillis();\n                for (OsmPrimitive osm : list) {\n                    osm.visit(v);\n                    int progress = Main.pleaseWaitDlg.progress.getValue();\n                    String time_left_str = timeLeft(progress, list.size());\n                    Main.pleaseWaitDlg.currentAction.setText(\n                            tr(\"{0}% ({1}/{2}), {3} left. Uploading {4}: {5} (id: {6})\",\n                                    Math.round(100.0*progress/list.size()), progress,\n                                    list.size(), time_left_str, tr(v.className), v.name, osm.id));\n                    makeApiRequest(osm);\n                    processed.add(osm);\n                    Main.pleaseWaitDlg.progress.setValue(progress+1);\n                }\n            }\n            if (useChangesets) api.stopChangeset();\n        } catch (OsmTransferException e) {\n            try {\n                if (useChangesets) api.stopChangeset();\n            } catch (Exception ee) {\n                // ignore nested exception\n            }\n            dealWithTransferException(e);\n        }\n    }","id":40257,"modified_method":"/**\n     * Send the dataset to the server.\n     * \n     * @param apiVersion version of the data set\n     * @param primitives list of objects to send\n     */\n    public void uploadOsm(String apiVersion, Collection<OsmPrimitive> primitives) throws OsmTransferException {\n        processed = new LinkedList<OsmPrimitive>();\n\n        // initialize API. Abort upload in case of configuration or network\n        // errors\n        //\n        try {\n            api.initialize();\n        } catch(Exception e) {\n            throw new OsmApiInitializationException(e);\n        }\n\n        Main.pleaseWaitDlg.progress.setMaximum(primitives.size());\n        Main.pleaseWaitDlg.progress.setValue(0);\n\n        // check whether we can use changeset\n        //\n        boolean canUseChangeset = api.hasChangesetSupport();\n        boolean useChangeset = Main.pref.getBoolean(\"osm-server.atomic-upload\", apiVersion.compareTo(\"0.6\")>=0);\n        if (useChangeset && ! canUseChangeset) {\n            System.out.println(tr(\"WARNING: preference '{0}' or api version {1} of dataset requires to use changesets, but API is not handle them. Ignoring changesets.\", \"osm-server.atomic-upload\", apiVersion));\n            useChangeset = false;\n        }\n\n        if (useChangeset) {\n            // upload everything in one changeset\n            //\n            try {\n                api.createChangeset(getChangesetComment());\n                processed.addAll(api.uploadDiff(primitives));\n            } catch(OsmTransferException e) {\n                throw e;\n            } finally {\n                try {\n                    if (canUseChangeset) {\n                        api.stopChangeset();\n                    }\n                } catch (Exception ee) {\n                    // ignore nested exception\n                }\n            }\n        } else {\n            // upload changes individually (90% of code is for the status display...)\n            //\n            NameVisitor v = new NameVisitor();\n            uploadStartTime = System.currentTimeMillis();\n            for (OsmPrimitive osm : primitives) {\n                osm.visit(v);\n                int progress = Main.pleaseWaitDlg.progress.getValue();\n                String time_left_str = timeLeft(progress, primitives.size());\n                Main.pleaseWaitDlg.currentAction.setText(\n                        tr(\"{0}% ({1}/{2}), {3} left. Uploading {4}: {5} (id: {6})\",\n                                Math.round(100.0*progress/primitives.size()), progress,\n                                primitives.size(), time_left_str, tr(v.className), v.name, osm.id));\n                makeApiRequest(osm);\n                processed.add(osm);\n                Main.pleaseWaitDlg.progress.setValue(progress+1);\n            }\n        }\n    }","commit_id":"721413d627458e975ceaa394b520c06164110526","url":"https://github.com/openstreetmap/josm"},{"original_method":"public UploadAction() {\n        super(tr(\"Upload to OSM...\"), \"upload\", tr(\"Upload all changes to the OSM server.\"),\n        Shortcut.registerShortcut(\"file:upload\", tr(\"File: {0}\", tr(\"Upload to OSM...\")), KeyEvent.VK_U, Shortcut.GROUPS_ALT1+Shortcut.GROUP_HOTKEY), true);\n\n        /**\n         * Displays a screen where the actions that would be taken are displayed and\n         * give the user the possibility to cancel the upload.\n         */\n        uploadHooks.add(new UploadHook() {\n            public boolean checkUpload(Collection<OsmPrimitive> add, Collection<OsmPrimitive> update, Collection<OsmPrimitive> delete) {\n\n                JPanel p = new JPanel(new GridBagLayout());\n\n                OsmPrimitivRenderer renderer = new OsmPrimitivRenderer();\n\n                if (!add.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to add:\")), GBC.eol());\n                    JList l = new JList(add.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                if (!update.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to modify:\")), GBC.eol());\n                    JList l = new JList(update.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                if (!delete.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to delete:\")), GBC.eol());\n                    JList l = new JList(delete.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                p.add(new JLabel(tr(\"Provide a brief comment for the changes you are uploading:\")), GBC.eol().insets(0, 5, 10, 3));\n                SuggestingJHistoryComboBox cmt = new SuggestingJHistoryComboBox();\n                List<String> cmtHistory = new LinkedList<String>(Main.pref.getCollection(HISTORY_KEY, new LinkedList<String>()));\n                cmt.setHistory(cmtHistory);\n                //final JTextField cmt = new JTextField(lastCommitComment);\n                p.add(cmt, GBC.eol().fill(GBC.HORIZONTAL));\n\n                while(true) {\n                    int result = new ExtendedDialog(Main.parent,\n                        tr(\"Upload these changes?\"),\n                        p,\n                        new String[] {tr(\"Upload Changes\"), tr(\"Cancel\")},\n                        new String[] {\"upload.png\", \"cancel.png\"}).getValue();\n\n                    // cancel pressed\n                    if (result != 1) return false;\n\n                    // don't allow empty commit message\n                    if (cmt.getText().trim().length() < 3) continue;\n\n                    // store the history of comments\n                    cmt.addCurrentItemToHistory();\n                    Main.pref.putCollection(HISTORY_KEY, cmt.getHistory());\n\n                    break;\n                }\n                return true;\n            }\n        });\n    }","id":40258,"modified_method":"public UploadAction() {\n        super(tr(\"Upload to OSM...\"), \"upload\", tr(\"Upload all changes to the OSM server.\"),\n                Shortcut.registerShortcut(\"file:upload\", tr(\"File: {0}\", tr(\"Upload to OSM...\")), KeyEvent.VK_U, Shortcut.GROUPS_ALT1+Shortcut.GROUP_HOTKEY), true);\n\n        /**\n         * Displays a screen where the actions that would be taken are displayed and\n         * give the user the possibility to cancel the upload.\n         */\n        uploadHooks.add(new UploadHook() {\n            public boolean checkUpload(Collection<OsmPrimitive> add, Collection<OsmPrimitive> update, Collection<OsmPrimitive> delete) {\n\n                JPanel p = new JPanel(new GridBagLayout());\n\n                OsmPrimitivRenderer renderer = new OsmPrimitivRenderer();\n\n                if (!add.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to add:\")), GBC.eol());\n                    JList l = new JList(add.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                if (!update.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to modify:\")), GBC.eol());\n                    JList l = new JList(update.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                if (!delete.isEmpty()) {\n                    p.add(new JLabel(tr(\"Objects to delete:\")), GBC.eol());\n                    JList l = new JList(delete.toArray());\n                    l.setCellRenderer(renderer);\n                    l.setVisibleRowCount(l.getModel().getSize() < 6 ? l.getModel().getSize() : 10);\n                    p.add(new JScrollPane(l), GBC.eol().fill());\n                }\n\n                p.add(new JLabel(tr(\"Provide a brief comment for the changes you are uploading:\")), GBC.eol().insets(0, 5, 10, 3));\n                SuggestingJHistoryComboBox cmt = new SuggestingJHistoryComboBox();\n                List<String> cmtHistory = new LinkedList<String>(Main.pref.getCollection(HISTORY_KEY, new LinkedList<String>()));\n                cmt.setHistory(cmtHistory);\n                //final JTextField cmt = new JTextField(lastCommitComment);\n                p.add(cmt, GBC.eol().fill(GBC.HORIZONTAL));\n\n                while(true) {\n                    int result = new ExtendedDialog(Main.parent,\n                            tr(\"Upload these changes?\"),\n                            p,\n                            new String[] {tr(\"Upload Changes\"), tr(\"Cancel\")},\n                            new String[] {\"upload.png\", \"cancel.png\"}).getValue();\n\n                    // cancel pressed\n                    if (result != 1) return false;\n\n                    // don't allow empty commit message\n                    if (cmt.getText().trim().length() < 3) {\n                        continue;\n                    }\n\n                    // store the history of comments\n                    cmt.addCurrentItemToHistory();\n                    Main.pref.putCollection(HISTORY_KEY, cmt.getHistory());\n\n                    break;\n                }\n                return true;\n            }\n        });\n    }","commit_id":"721413d627458e975ceaa394b520c06164110526","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        if (Main.map == null) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"Nothing to upload. Get some data first.\"));\n            return;\n        }\n\n        if (!Main.map.conflictDialog.conflicts.isEmpty()) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"There are unresolved conflicts. You have to resolve these first.\"));\n            Main.map.conflictDialog.action.button.setSelected(true);\n            Main.map.conflictDialog.action.actionPerformed(null);\n            return;\n        }\n\n        final LinkedList<OsmPrimitive> add = new LinkedList<OsmPrimitive>();\n        final LinkedList<OsmPrimitive> update = new LinkedList<OsmPrimitive>();\n        final LinkedList<OsmPrimitive> delete = new LinkedList<OsmPrimitive>();\n        for (OsmPrimitive osm : Main.ds.allPrimitives()) {\n            if (osm.get(\"josm/ignore\") != null)\n                continue;\n            if (osm.id == 0 && !osm.deleted)\n                add.addLast(osm);\n            else if (osm.modified && !osm.deleted)\n                update.addLast(osm);\n            else if (osm.deleted && osm.id != 0)\n                delete.addFirst(osm);\n        }\n\n        if (add.isEmpty() && update.isEmpty() && delete.isEmpty()) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"No changes to upload.\"));\n            return;\n        }\n\n        // Call all upload hooks in sequence. The upload confirmation dialog\n        // is one of these.\n        for(UploadHook hook : uploadHooks)\n            if(!hook.checkUpload(add, update, delete))\n                return;\n\n        final OsmServerWriter server = new OsmServerWriter();\n        final Collection<OsmPrimitive> all = new LinkedList<OsmPrimitive>();\n        all.addAll(add);\n        all.addAll(update);\n        all.addAll(delete);\n\n        PleaseWaitRunnable uploadTask = new PleaseWaitRunnable(tr(\"Uploading data\")){\n            @Override protected void realRun() throws SAXException {\n                server.uploadOsm(Main.ds.version, all);\n            }\n            @Override protected void finish() {\n                Main.main.editLayer().cleanData(server.processed, !add.isEmpty());\n            }\n            @Override protected void cancel() {\n                // FIXME server.cancel();\n            }\n        };\n        Main.worker.execute(uploadTask);\n    }","id":40259,"modified_method":"public void actionPerformed(ActionEvent e) {\n        if (Main.map == null) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"Nothing to upload. Get some data first.\"));\n            return;\n        }\n\n        if (!Main.map.conflictDialog.conflicts.isEmpty()) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"There are unresolved conflicts. You have to resolve these first.\"));\n            Main.map.conflictDialog.action.button.setSelected(true);\n            Main.map.conflictDialog.action.actionPerformed(null);\n            return;\n        }\n\n        final LinkedList<OsmPrimitive> add = new LinkedList<OsmPrimitive>();\n        final LinkedList<OsmPrimitive> update = new LinkedList<OsmPrimitive>();\n        final LinkedList<OsmPrimitive> delete = new LinkedList<OsmPrimitive>();\n        for (OsmPrimitive osm : Main.ds.allPrimitives()) {\n            if (osm.get(\"josm/ignore\") != null) {\n                continue;\n            }\n            if (osm.id == 0 && !osm.deleted) {\n                add.addLast(osm);\n            } else if (osm.modified && !osm.deleted) {\n                update.addLast(osm);\n            } else if (osm.deleted && osm.id != 0) {\n                delete.addFirst(osm);\n            }\n        }\n\n        if (add.isEmpty() && update.isEmpty() && delete.isEmpty()) {\n            JOptionPane.showMessageDialog(Main.parent,tr(\"No changes to upload.\"));\n            return;\n        }\n\n        // Call all upload hooks in sequence. The upload confirmation dialog\n        // is one of these.\n        for(UploadHook hook : uploadHooks)\n            if(!hook.checkUpload(add, update, delete))\n                return;\n\n        final OsmServerWriter server = new OsmServerWriter();\n        final Collection<OsmPrimitive> all = new LinkedList<OsmPrimitive>();\n        all.addAll(add);\n        all.addAll(update);\n        all.addAll(delete);\n\n        class UploadDiffTask extends  PleaseWaitRunnable {\n\n            private boolean uploadCancelled = false;\n            private boolean uploadFailed = false;\n            private Exception lastException = null;\n\n            public UploadDiffTask() {\n                super(tr(\"Uploading\"),false /* don't ignore exceptions */);\n            }\n\n            @Override protected void realRun() throws SAXException, IOException {\n                try {\n                    server.uploadOsm(Main.ds.version, all);\n                    Main.main.editLayer().cleanData(server.processed, !add.isEmpty());\n                } catch (Exception sxe) {\n                    if (uploadCancelled) {\n                        System.out.println(\"Ignoring exception caught because upload is cancelled. Exception is: \" + sxe.toString());\n                        return;\n                    }\n                    System.out.println(\"got exception: \" + sxe.toString());\n                    uploadFailed = true;\n                    lastException = sxe;\n                }\n            }\n\n            @Override protected void finish() {\n                if (uploadFailed) {\n                    handleFailedUpload(lastException);\n                }\n            }\n\n            @Override protected void cancel() {\n                server.disconnectActiveConnection();\n                uploadCancelled = true;\n            };\n\n        }\n        Main.worker.execute(new UploadDiffTask());\n    }","commit_id":"721413d627458e975ceaa394b520c06164110526","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void processVariants(PrefixMatcher matcher, Consumer<LookupElement> consumer, GrReferenceExpressionImpl refExpr, CompletionParameters parameters) {\n    processRefInAnnotation(refExpr, matcher, consumer);\n\n    final CompleteReferenceProcessor processor = new CompleteReferenceProcessor(refExpr, consumer, matcher, parameters);\n    getVariantsImpl(refExpr, processor);\n    final GroovyResolveResult[] candidates = processor.getCandidates();\n    for (LookupElement o : GroovyCompletionUtil.getCompletionVariants(candidates, JavaClassNameCompletionContributor.AFTER_NEW.accepts(refExpr), matcher, refExpr)) {\n      consumer.consume(o);\n    }\n  }","id":40260,"modified_method":"public static void processVariants(PrefixMatcher matcher,\n                                     final Consumer<LookupElement> consumer,\n                                     GrReferenceExpressionImpl refExpr,\n                                     CompletionParameters parameters) {\n    processRefInAnnotation(refExpr, matcher, consumer);\n\n    final int[] count = new int[]{0};\n    final CompleteReferenceProcessor processor = new CompleteReferenceProcessor(refExpr, new Consumer<LookupElement>() {\n      @Override\n      public void consume(LookupElement element) {\n        count[0]++;\n        consumer.consume(element);\n      }\n    }, matcher, parameters);\n\n    getVariantsImpl(refExpr, processor);\n    final GroovyResolveResult[] candidates = processor.getCandidates();\n    List<LookupElement> results =\n      GroovyCompletionUtil.getCompletionVariants(candidates,\n                                                 JavaClassNameCompletionContributor.AFTER_NEW.accepts(refExpr), matcher, refExpr);\n\n    if (count[0] == 0 && results.size() == 0) {\n      results = GroovyCompletionUtil.getCompletionVariants(processor.getInapplicableResults(),\n                                                           JavaClassNameCompletionContributor.AFTER_NEW.accepts(refExpr), matcher, refExpr);\n    }\n    for (LookupElement o : results) {\n      consumer.consume(o);\n    }\n  }","commit_id":"20a11697e4c36bbb02012b7a6df2c2c41793dee1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void consume(Object o) {\n      if (!(o instanceof GroovyResolveResult)) {\n        LOG.error(o);\n        return;\n      }\n\n      GroovyResolveResult result = (GroovyResolveResult)o;\n      if (!result.isStaticsOK()) return;\n      if (!result.isAccessible() && myParameters.getInvocationCount() < 2) return;\n      if (mySkipPackages && result.getElement() instanceof PsiPackage) return;\n\n      PsiElement element = result.getElement();\n      if (element instanceof PsiVariable && !myMatcher.prefixMatches(((PsiVariable)element).getName())) {\n        return;\n      }\n\n      if (element instanceof GrReflectedMethod) {\n        element = ((GrReflectedMethod)element).getBaseMethod();\n        if (!myProcessedMethodWithOptionalParams.add((GrMethod)element)) return;\n\n        result = new GroovyResolveResultImpl(element, result.getCurrentFileResolveContext(), result.getSpreadState(),\n                                             result.getSubstitutor(), result.isAccessible(), result.isStaticsOK(),\n                                             result.isInvokedOnProperty());\n      }\n\n      if (myFieldPointerOperator && !(element instanceof PsiVariable)) {\n        return;\n      }\n      if (myMethodPointerOperator && !(element instanceof PsiMethod)) {\n        return;\n      }\n      addCandidate(result);\n\n      if (!myFieldPointerOperator && !myMethodPointerOperator) {\n        if (element instanceof PsiMethod) {\n          processProperty((PsiMethod)element, result);\n        }\n        else if (element instanceof GrField) {\n          if (((GrField)element).isProperty()) {\n            processPropertyFromField((GrField)element, result);\n          }\n        }\n      }\n      if (element instanceof GrVariable && !(element instanceof GrField)) {\n        myLocalVars.add(((GrVariable)element).getName());\n      }\n    }","id":40261,"modified_method":"public void consume(Object o) {\n      if (!(o instanceof GroovyResolveResult)) {\n        LOG.error(o);\n        return;\n      }\n\n      GroovyResolveResult result = (GroovyResolveResult)o;\n      if (!result.isStaticsOK()) {\n        if (myInapplicable == null) myInapplicable = ContainerUtil.newArrayList();\n        myInapplicable.add(result);\n        return;\n      }\n      if (!result.isAccessible() && myParameters.getInvocationCount() < 2) return;\n\n      if (mySkipPackages && result.getElement() instanceof PsiPackage) return;\n\n      PsiElement element = result.getElement();\n      if (element instanceof PsiVariable && !myMatcher.prefixMatches(((PsiVariable)element).getName())) {\n        return;\n      }\n\n      if (element instanceof GrReflectedMethod) {\n        element = ((GrReflectedMethod)element).getBaseMethod();\n        if (!myProcessedMethodWithOptionalParams.add((GrMethod)element)) return;\n\n        result = new GroovyResolveResultImpl(element, result.getCurrentFileResolveContext(), result.getSpreadState(),\n                                             result.getSubstitutor(), result.isAccessible(), result.isStaticsOK(),\n                                             result.isInvokedOnProperty());\n      }\n\n      if (myFieldPointerOperator && !(element instanceof PsiVariable)) {\n        return;\n      }\n      if (myMethodPointerOperator && !(element instanceof PsiMethod)) {\n        return;\n      }\n      addCandidate(result);\n\n      if (!myFieldPointerOperator && !myMethodPointerOperator) {\n        if (element instanceof PsiMethod) {\n          processProperty((PsiMethod)element, result);\n        }\n        else if (element instanceof GrField) {\n          if (((GrField)element).isProperty()) {\n            processPropertyFromField((GrField)element, result);\n          }\n        }\n      }\n      if (element instanceof GrVariable && !(element instanceof GrField)) {\n        myLocalVars.add(((GrVariable)element).getName());\n      }\n    }","commit_id":"20a11697e4c36bbb02012b7a6df2c2c41793dee1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    final VariantsProcessor processor = new VariantsProcessor(new PyResolveUtil.FilterNotInstance(myClass));\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    List<Object> ret = new ArrayList<Object>();\n    ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      ret.addAll(Arrays.asList((new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression)));\n    }\n    return ret.toArray();\n  }","id":40262,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    final VariantsProcessor processor = new VariantsProcessor(new PyResolveUtil.FilterNotInstance(myClass));\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    List<Object> ret = new ArrayList<Object>();\n    if (names_already != null) {\n      for (LookupElement le : processor.getResultList()) {\n        String name = le.getLookupString();\n        if (names_already.contains(name)) continue;\n        names_already.add(name);\n        ret.add(le);\n      }\n    }\n    else ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      Object[] ancestry = (new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression, context);\n      for (Object ob : ancestry) {\n        if (ob instanceof LookupItem) {\n          LookupItem item = (LookupItem)ob;\n          item.setAttribute(item.TAIL_TEXT_ATTR, \" | \" + ancestor.getName()); // from where it's inherited\n          item.setAttribute(item.TAIL_TEXT_SMALL_ATTR, \"\"); // make it gray\n        }\n      }\n      ret.addAll(Arrays.asList(ancestry));\n    }\n    return ret.toArray();\n  }","commit_id":"a6453aa51cda8210c2cede548f4adc01b37f688a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    List<Object> result = new ArrayList<Object>();\n    if (PsiTreeUtil.getParentOfType(referenceExpression, PyImportElement.class) == null) { // we're not in an import\n      final VariantsProcessor processor = new VariantsProcessor();\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      result.addAll(processor.getResultList());\n    }\n    LookupElementFactory maker = LookupElementFactory.getInstance();\n    for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n      String s = pfsi.getName();\n      int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n      if (pos > 0) s = s.substring(0, pos);\n      LookupItem item = (LookupItem)maker.createLookupElement(pfsi, s);\n      item.setPresentableText(s); // not raw filename\n      result.add(item);\n    }\n    return result.toArray();\n  }","id":40263,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    List<Object> result = new ArrayList<Object>();\n    if (PsiTreeUtil.getParentOfType(referenceExpression, PyImportElement.class) == null) { // we're not in an import\n      final VariantsProcessor processor = new VariantsProcessor();\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      if (names_already != null) {\n        for (LookupElement le : processor.getResultList()) {\n          String name = le.getLookupString();\n          if (!names_already.contains(name)) {\n            result.add(le);\n            names_already.add(name);\n          }\n        }\n      }\n      else result.addAll(processor.getResultList());\n    }\n    LookupElementFactory maker = LookupElementFactory.getInstance();\n    for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n      String s = pfsi.getName();\n      int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n      if (pos > 0) s = s.substring(0, pos);\n      if (!PyUtil.isIdentifier(s)) continue; // file is e.g. a script with a strange name, not a module\n      if (names_already != null) {\n        if (names_already.contains(s)) continue;\n        else names_already.add(s);\n      }\n      LookupItem item = (LookupItem)maker.createLookupElement(pfsi, s);\n      item.setPresentableText(s); // not raw filename\n      result.add(item);\n    }\n    return result.toArray();\n  }","commit_id":"a6453aa51cda8210c2cede548f4adc01b37f688a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":40264,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"a6453aa51cda8210c2cede548f4adc01b37f688a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    // qualifier limits the namespace\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      PyType qualifierType = qualifier.getType();\n      if (qualifierType != null) {\n        ArrayList<Object> variants = new ArrayList<Object>();\n        if (qualifier instanceof PyQualifiedExpression) {\n          Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n          variants.addAll(attrs);\n          Collections.addAll(variants, qualifierType.getCompletionVariants(this));\n          return variants.toArray();\n        }\n        else return qualifierType.getCompletionVariants(this);\n      }\n      return NO_VARIANTS;\n    }\n\n    // imports are another special case\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      // complete to possible modules\n      return ResolveImportUtil.suggestImportVariants(this);\n    }\n\n    // include our own names\n    final VariantsProcessor processor = new VariantsProcessor();\n    PyResolveUtil.treeCrawlUp(processor, this); // names from here\n    // scan all \"import *\" and include names provided by them\n    CollectProcessor collect_proc;\n    collect_proc = new CollectProcessor(PyStarImportElement.class);\n    PyResolveUtil.treeCrawlUp(collect_proc, this);\n    List<PsiElement> stars = collect_proc.getResult();\n    for (PsiElement star_elt : stars) {\n      final PyFromImportStatement from_import_stmt = (PyFromImportStatement)star_elt.getParent();\n      if (from_import_stmt != null) {\n        final PyReferenceExpression import_src = from_import_stmt.getImportSource();\n        if (import_src != null) {\n          processor.setNotice(\" | \" + import_src.getName());\n          PyResolveUtil.treeCrawlUp(processor, true, import_src.resolve()); // names from that module\n        }\n      }\n    }\n    // include builtin names\n    processor.setNotice(\" | __builtin__\");\n    PyResolveUtil.treeCrawlUp(processor, true, PyBuiltinCache.getInstance(getProject()).getBuiltinsFile()); // names from __builtin__\n    // if we're expanding a \"__\", include predefined __names__\n    String name = getName();\n    if (name != null && name.startsWith(\"__\")) {\n      List<LookupElement> result = processor.getResultList();\n      LookupElementFactory factory = LookupElementFactory.getInstance();\n      for (String s : PyNames.UnderscoredNames) {\n        LookupItem item = (LookupItem)factory.createLookupElement(s);\n        item.setAttribute(item.TAIL_TEXT_ATTR, \" | predefined\");\n        item.setIcon(PyIcons.PREDEFINED);\n        result.add(item);\n      }\n      return result.toArray(new LookupElement[result.size()]);\n    }\n    return processor.getResult();\n  }","id":40265,"modified_method":"public Object[] getVariants() {\n    // qualifier limits the namespace\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      PyType qualifierType = qualifier.getType();\n      ProcessingContext ctx = new ProcessingContext();\n      final HashSet<String> names_already = new HashSet<String>();\n      ctx.put(PyType.CTX_NAMES, names_already);\n      if (qualifierType != null) {\n        ArrayList<Object> variants = new ArrayList<Object>();\n        if (qualifier instanceof PyQualifiedExpression) {\n          Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n          variants.addAll(attrs);\n          for (PyExpression ex : attrs) {\n            if (ex instanceof PyReferenceExpression) {\n              PyReferenceExpression refex = (PyReferenceExpression)ex;\n              names_already.add(refex.getReferencedName());\n            }\n          }\n          Collections.addAll(variants, qualifierType.getCompletionVariants(this, ctx));\n          return variants.toArray();\n        }\n        else return qualifierType.getCompletionVariants(this, null);\n      }\n      return NO_VARIANTS;\n    }\n\n    // imports are another special case\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      // complete to possible modules\n      return ResolveImportUtil.suggestImportVariants(this);\n    }\n\n    // include our own names\n    final VariantsProcessor processor = new VariantsProcessor();\n    PyResolveUtil.treeCrawlUp(processor, this); // names from here\n    // scan all \"import *\" and include names provided by them\n    CollectProcessor collect_proc;\n    collect_proc = new CollectProcessor(PyStarImportElement.class);\n    PyResolveUtil.treeCrawlUp(collect_proc, this);\n    List<PsiElement> stars = collect_proc.getResult();\n    for (PsiElement star_elt : stars) {\n      final PyFromImportStatement from_import_stmt = (PyFromImportStatement)star_elt.getParent();\n      if (from_import_stmt != null) {\n        final PyReferenceExpression import_src = from_import_stmt.getImportSource();\n        if (import_src != null) {\n          processor.setNotice(\" | \" + import_src.getName());\n          PyResolveUtil.treeCrawlUp(processor, true, import_src.resolve()); // names from that module\n        }\n      }\n    }\n    // include builtin names\n    processor.setNotice(\" | __builtin__\");\n    PyResolveUtil.treeCrawlUp(processor, true, PyBuiltinCache.getInstance(getProject()).getBuiltinsFile()); // names from __builtin__\n    // if we're expanding a \"__\", include predefined __names__\n    String name = getName();\n    if (name != null && name.startsWith(\"__\")) {\n      List<LookupElement> result = processor.getResultList();\n      LookupElementFactory factory = LookupElementFactory.getInstance();\n      for (String s : PyNames.UnderscoredNames) {\n        LookupItem item = (LookupItem)factory.createLookupElement(s);\n        item.setAttribute(item.TAIL_TEXT_ATTR, \" | predefined\");\n        item.setIcon(PyIcons.PREDEFINED);\n        result.add(item);\n      }\n      return result.toArray(new LookupElement[result.size()]);\n    }\n    return processor.getResult();\n  }","commit_id":"a6453aa51cda8210c2cede548f4adc01b37f688a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    final VariantsProcessor processor = new VariantsProcessor(new PyResolveUtil.FilterNotInstance(myClass));\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    List<Object> ret = new ArrayList<Object>();\n    ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      ret.addAll(Arrays.asList((new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression)));\n    }\n    return ret.toArray();\n  }","id":40266,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    final VariantsProcessor processor = new VariantsProcessor(new PyResolveUtil.FilterNotInstance(myClass));\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    List<Object> ret = new ArrayList<Object>();\n    if (names_already != null) {\n      for (LookupElement le : processor.getResultList()) {\n        String name = le.getLookupString();\n        if (names_already.contains(name)) continue;\n        names_already.add(name);\n        ret.add(le);\n      }\n    }\n    else ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      Object[] ancestry = (new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression, context);\n      for (Object ob : ancestry) {\n        if (ob instanceof LookupItem) {\n          LookupItem item = (LookupItem)ob;\n          item.setAttribute(item.TAIL_TEXT_ATTR, \" | \" + ancestor.getName()); // from where it's inherited\n          item.setAttribute(item.TAIL_TEXT_SMALL_ATTR, \"\"); // make it gray\n        }\n      }\n      ret.addAll(Arrays.asList(ancestry));\n    }\n    return ret.toArray();\n  }","commit_id":"eeb16ad7017ecca2e39db303865551552304a17c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    List<Object> result = new ArrayList<Object>();\n    if (PsiTreeUtil.getParentOfType(referenceExpression, PyImportElement.class) == null) { // we're not in an import\n      final VariantsProcessor processor = new VariantsProcessor();\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      result.addAll(processor.getResultList());\n    }\n    LookupElementFactory maker = LookupElementFactory.getInstance();\n    for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n      String s = pfsi.getName();\n      int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n      if (pos > 0) s = s.substring(0, pos);\n      LookupItem item = (LookupItem)maker.createLookupElement(pfsi, s);\n      item.setPresentableText(s); // not raw filename\n      result.add(item);\n    }\n    return result.toArray();\n  }","id":40267,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    List<Object> result = new ArrayList<Object>();\n    if (PsiTreeUtil.getParentOfType(referenceExpression, PyImportElement.class) == null) { // we're not in an import\n      final VariantsProcessor processor = new VariantsProcessor();\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      if (names_already != null) {\n        for (LookupElement le : processor.getResultList()) {\n          String name = le.getLookupString();\n          if (!names_already.contains(name)) {\n            result.add(le);\n            names_already.add(name);\n          }\n        }\n      }\n      else result.addAll(processor.getResultList());\n    }\n    LookupElementFactory maker = LookupElementFactory.getInstance();\n    for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n      String s = pfsi.getName();\n      int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n      if (pos > 0) s = s.substring(0, pos);\n      if (!PyUtil.isIdentifier(s)) continue; // file is e.g. a script with a strange name, not a module\n      if (names_already != null) {\n        if (names_already.contains(s)) continue;\n        else names_already.add(s);\n      }\n      LookupItem item = (LookupItem)maker.createLookupElement(pfsi, s);\n      item.setPresentableText(s); // not raw filename\n      result.add(item);\n    }\n    return result.toArray();\n  }","commit_id":"eeb16ad7017ecca2e39db303865551552304a17c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":40268,"modified_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"eeb16ad7017ecca2e39db303865551552304a17c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    // qualifier limits the namespace\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      PyType qualifierType = qualifier.getType();\n      if (qualifierType != null) {\n        ArrayList<Object> variants = new ArrayList<Object>();\n        if (qualifier instanceof PyQualifiedExpression) {\n          Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n          variants.addAll(attrs);\n          Collections.addAll(variants, qualifierType.getCompletionVariants(this));\n          return variants.toArray();\n        }\n        else return qualifierType.getCompletionVariants(this);\n      }\n      return NO_VARIANTS;\n    }\n\n    // imports are another special case\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      // complete to possible modules\n      return ResolveImportUtil.suggestImportVariants(this);\n    }\n\n    // include our own names\n    final VariantsProcessor processor = new VariantsProcessor();\n    PyResolveUtil.treeCrawlUp(processor, this); // names from here\n    // scan all \"import *\" and include names provided by them\n    CollectProcessor collect_proc;\n    collect_proc = new CollectProcessor(PyStarImportElement.class);\n    PyResolveUtil.treeCrawlUp(collect_proc, this);\n    List<PsiElement> stars = collect_proc.getResult();\n    for (PsiElement star_elt : stars) {\n      final PyFromImportStatement from_import_stmt = (PyFromImportStatement)star_elt.getParent();\n      if (from_import_stmt != null) {\n        final PyReferenceExpression import_src = from_import_stmt.getImportSource();\n        if (import_src != null) {\n          processor.setNotice(\" | \" + import_src.getName());\n          PyResolveUtil.treeCrawlUp(processor, true, import_src.resolve()); // names from that module\n        }\n      }\n    }\n    // include builtin names\n    processor.setNotice(\" | __builtin__\");\n    PyResolveUtil.treeCrawlUp(processor, true, PyBuiltinCache.getInstance(getProject()).getBuiltinsFile()); // names from __builtin__\n    // if we're expanding a \"__\", include predefined __names__\n    String name = getName();\n    if (name != null && name.startsWith(\"__\")) {\n      List<LookupElement> result = processor.getResultList();\n      LookupElementFactory factory = LookupElementFactory.getInstance();\n      for (String s : PyNames.UnderscoredNames) {\n        LookupItem item = (LookupItem)factory.createLookupElement(s);\n        item.setAttribute(item.TAIL_TEXT_ATTR, \" | predefined\");\n        item.setIcon(PyIcons.PREDEFINED);\n        result.add(item);\n      }\n      return result.toArray(new LookupElement[result.size()]);\n    }\n    return processor.getResult();\n  }","id":40269,"modified_method":"public Object[] getVariants() {\n    // qualifier limits the namespace\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      PyType qualifierType = qualifier.getType();\n      ProcessingContext ctx = new ProcessingContext();\n      final Set<String> names_already = new HashSet<String>();\n      ctx.put(PyType.CTX_NAMES, names_already);\n      if (qualifierType != null) {\n        Collection<Object> variants = new ArrayList<Object>();\n        if (qualifier instanceof PyQualifiedExpression) {\n          Collection<PyExpression> attrs = collectAssignedAttributes((PyQualifiedExpression)qualifier);\n          variants.addAll(attrs);\n          for (PyExpression ex : attrs) {\n            if (ex instanceof PyReferenceExpression) {\n              PyReferenceExpression refex = (PyReferenceExpression)ex;\n              names_already.add(refex.getReferencedName());\n            }\n          }\n          Collections.addAll(variants, qualifierType.getCompletionVariants(this, ctx));\n          return variants.toArray();\n        }\n        else return qualifierType.getCompletionVariants(this, ctx);\n      }\n      return NO_VARIANTS;\n    }\n\n    // imports are another special case\n    if (PsiTreeUtil.getParentOfType(this, PyImportElement.class, PyFromImportStatement.class) != null) {\n      // complete to possible modules\n      return ResolveImportUtil.suggestImportVariants(this);\n    }\n\n    // include our own names\n    final VariantsProcessor processor = new VariantsProcessor();\n    PyResolveUtil.treeCrawlUp(processor, this); // names from here\n    // scan all \"import *\" and include names provided by them\n    CollectProcessor collect_proc;\n    collect_proc = new CollectProcessor(PyStarImportElement.class);\n    PyResolveUtil.treeCrawlUp(collect_proc, this);\n    List<PsiElement> stars = collect_proc.getResult();\n    for (PsiElement star_elt : stars) {\n      final PyFromImportStatement from_import_stmt = (PyFromImportStatement)star_elt.getParent();\n      if (from_import_stmt != null) {\n        final PyReferenceExpression import_src = from_import_stmt.getImportSource();\n        if (import_src != null) {\n          processor.setNotice(\" | \" + import_src.getName());\n          PyResolveUtil.treeCrawlUp(processor, true, import_src.resolve()); // names from that module\n        }\n      }\n    }\n    // include builtin names\n    processor.setNotice(\" | __builtin__\");\n    PyResolveUtil.treeCrawlUp(processor, true, PyBuiltinCache.getInstance(getProject()).getBuiltinsFile()); // names from __builtin__\n    // if we're expanding a \"__\", include predefined __names__\n    String name = getName();\n    if (name != null && name.startsWith(\"__\")) {\n      List<LookupElement> result = processor.getResultList();\n      LookupElementFactory factory = LookupElementFactory.getInstance();\n      for (String s : PyNames.UnderscoredNames) {\n        LookupItem item = (LookupItem)factory.createLookupElement(s);\n        item.setAttribute(item.TAIL_TEXT_ATTR, \" | predefined\");\n        item.setIcon(PyIcons.PREDEFINED);\n        result.add(item);\n      }\n      return result.toArray(new LookupElement[result.size()]);\n    }\n    return processor.getResult();\n  }","commit_id":"eeb16ad7017ecca2e39db303865551552304a17c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString backURL = ParamUtil.getString(liferayPortletRequest, \"backURL\");\n\n\t\tif (Validator.isNull(backURL) || Validator.isNull(portletResource)) {\n\t\t\tbackURL = getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn backURL;\n\t}","id":40270,"modified_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString redirect = ParamUtil.getString(\n\t\t\tliferayPortletRequest, \"redirect\");\n\n\t\tif (Validator.isNull(redirect) || Validator.isNull(portletResource)) {\n\t\t\treturn getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn redirect;\n\t}","commit_id":"d0c7e7ace20ff1af456ea0734bc97beb9aff852c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString backURL = ParamUtil.getString(liferayPortletRequest, \"backURL\");\n\n\t\tif (Validator.isNull(backURL)) {\n\t\t\tbackURL = getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn backURL;\n\t}","id":40271,"modified_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString redirect = ParamUtil.getString(\n\t\t\tliferayPortletRequest, \"redirect\");\n\n\t\tif (Validator.isNull(redirect)) {\n\t\t\treturn getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn redirect;\n\t}","commit_id":"d0c7e7ace20ff1af456ea0734bc97beb9aff852c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString backURL = ParamUtil.getString(liferayPortletRequest, \"backURL\");\n\n\t\tif (Validator.isNull(backURL)) {\n\t\t\tbackURL = getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn backURL;\n\t}","id":40272,"modified_method":"@Override\n\tpublic String getEditTemplateBackURL(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse, long classNameId,\n\t\t\tlong classPK, String portletResource)\n\t\tthrows Exception {\n\n\t\tString redirect = ParamUtil.getString(\n\t\t\tliferayPortletRequest, \"redirect\");\n\n\t\tif (Validator.isNull(redirect)) {\n\t\t\treturn getViewTemplatesURL(\n\t\t\t\tliferayPortletRequest, liferayPortletResponse, classNameId,\n\t\t\t\tclassPK);\n\t\t}\n\n\t\treturn redirect;\n\t}","commit_id":"d0c7e7ace20ff1af456ea0734bc97beb9aff852c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Iterable iterable = getIterable(o);\n    if (iterable == null) return context;\n\n    final String tagName = getTagName(o);\n    if (tagName != null) {\n      Element result = new Element(tagName);\n      for (Object e : iterable) {\n        if (e == null) {\n          throw new XmlSerializationException(\"Collection \" + myAccessor + \" contains 'null' object\");\n        }\n        final Binding binding = getElementBinding(e.getClass());\n        result.addContent((Content)binding.serialize(e, result, filter));\n      }\n\n      return result;\n    }\n    else {\n      List<Object> result = new ArrayList<Object>();\n      for (Object e : iterable) {\n        final Binding binding = getElementBinding(e.getClass());\n        result.add(binding.serialize(e, result, filter));\n      }\n\n      return result;\n    }\n  }","id":40273,"modified_method":"@Override\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Iterable iterable = getIterable(o);\n    if (iterable == null) return context;\n\n    final String tagName = getTagName(o);\n    if (tagName != null) {\n      Element result = new Element(tagName);\n      for (Object e : iterable) {\n        if (e == null) {\n          throw new XmlSerializationException(\"Collection \" + myAccessor + \" contains 'null' object\");\n        }\n        Content child = (Content)getElementBinding(e.getClass()).serialize(e, result, filter);\n        if (child != null) {\n          result.addContent(child);\n        }\n      }\n\n      return result;\n    }\n    else {\n      List<Object> result = new ArrayList<Object>();\n      for (Object e : iterable) {\n        ContainerUtil.addIfNotNull(result, getElementBinding(e.getClass()).serialize(e, result, filter));\n      }\n      return result;\n    }\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object serialize(@NotNull Object o, Object context, SerializationFilter filter) {\n    Element element = new Element(myTagName);\n\n    serializeInto(o, element, filter);\n\n    return element;\n  }","id":40274,"modified_method":"@Override\n  @Nullable\n  public Object serialize(@NotNull Object o, Object context, SerializationFilter filter) {\n    return serializeInto(o, null, filter);\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void serializeInto(@NotNull final Object o, final Element element, SerializationFilter filter) {\n    for (Binding binding : myPropertyBindingsList) {\n      Accessor accessor = myPropertyBindings.get(binding);\n      if (!filter.accepts(accessor, o)) continue;\n\n      //todo: optimize. Cache it.\n      final Property property = XmlSerializerImpl.findAnnotation(accessor.getAnnotations(), Property.class);\n      if (property != null) {\n        try {\n          if (!property.filter().newInstance().accepts(accessor, o)) continue;\n        }\n        catch (InstantiationException e) {\n          throw new XmlSerializationException(e);\n        }\n        catch (IllegalAccessException e) {\n          throw new XmlSerializationException(e);\n        }\n      }\n\n      Object node = binding.serialize(o, element, filter);\n      if (node != element) {\n        if (node instanceof org.jdom.Attribute) {\n          org.jdom.Attribute attr = (org.jdom.Attribute)node;\n          element.setAttribute(attr.getName(), attr.getValue());\n        }\n        else {\n          JDOMUtil.addContent(element, node);\n        }\n      }\n    }\n  }","id":40275,"modified_method":"@Nullable\n  public Element serializeInto(@NotNull Object o, @Nullable Element element, @NotNull SerializationFilter filter) {\n    for (Binding binding : myPropertyBindingsList) {\n      Accessor accessor = myPropertyBindings.get(binding);\n      if (!filter.accepts(accessor, o)) continue;\n\n      //todo: optimize. Cache it.\n      final Property property = XmlSerializerImpl.findAnnotation(accessor.getAnnotations(), Property.class);\n      if (property != null) {\n        try {\n          if (!property.filter().newInstance().accepts(accessor, o)) continue;\n        }\n        catch (InstantiationException e) {\n          throw new XmlSerializationException(e);\n        }\n        catch (IllegalAccessException e) {\n          throw new XmlSerializationException(e);\n        }\n      }\n\n      if (element == null) {\n        element = new Element(myTagName);\n      }\n\n      Object node = binding.serialize(o, element, filter);\n      if (node != null && node != element) {\n        if (node instanceof org.jdom.Attribute) {\n          org.jdom.Attribute attr = (org.jdom.Attribute)node;\n          element.setAttribute(attr.getName(), attr.getValue());\n        }\n        else {\n          JDOMUtil.addContent(element, node);\n        }\n      }\n    }\n    return element;\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Element targetElement = new Element(myTagName);\n    Object value = myAccessor.read(o);\n\n    if (!StringUtil.isEmpty(myNameAttribute)) {\n      targetElement.setAttribute(myNameAttribute, myName);\n    }\n\n    if (value == null) {\n      return targetElement;\n    }\n\n    if (myConverter != null) {\n      targetElement.setAttribute(myValueAttribute, myConverter.toString(value));\n    }\n    else {\n      assert myBinding != null;\n      Object node = myBinding.serialize(value, targetElement, filter);\n      if (node instanceof Text) {\n        Text text = (Text)node;\n        targetElement.setAttribute(myValueAttribute, text.getText());\n      }\n      else if (targetElement != node) {\n        JDOMUtil.addContent(targetElement, node);\n      }\n    }\n\n    return targetElement;\n  }","id":40276,"modified_method":"@Override\n  @Nullable\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Object value = myAccessor.read(o);\n    if (value == null) {\n      return null;\n    }\n\n    Element targetElement = new Element(myTagName);\n    if (myConverter != null) {\n      if (!StringUtil.isEmpty(myNameAttribute)) {\n        targetElement.setAttribute(myNameAttribute, myName);\n      }\n      targetElement.setAttribute(myValueAttribute, myConverter.toString(value));\n    }\n    else {\n      assert myBinding != null;\n      Object node = myBinding.serialize(value, targetElement, filter);\n      if (node == null) {\n        return null;\n      }\n\n      if (!StringUtil.isEmpty(myNameAttribute)) {\n        targetElement.setAttribute(myNameAttribute, myName);\n      }\n\n      if (node instanceof Text) {\n        Text text = (Text)node;\n        targetElement.setAttribute(myValueAttribute, text.getText());\n      }\n      else if (targetElement != node) {\n        JDOMUtil.addContent(targetElement, node);\n      }\n    }\n\n    return targetElement;\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Object value = accessor.read(o);\n    if (value == null) return context;\n\n    Element v = new Element(myTagName);\n\n    Object node = binding.serialize(value, v, filter);\n    if (node != v) {\n      JDOMUtil.addContent(v, node);\n    }\n\n    return v;\n  }","id":40277,"modified_method":"@Override\n  public Object serialize(Object o, Object context, SerializationFilter filter) {\n    Object value = accessor.read(o);\n    if (value == null) {\n      return null;\n    }\n\n    Element v = new Element(myTagName);\n    Object node = binding.serialize(value, v, filter);\n    if (node != null && node != v) {\n      JDOMUtil.addContent(v, node);\n    }\n\n    return v;\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Element serialize(@NotNull Object object) throws XmlSerializationException {\n    try {\n      return (Element)getBinding(object.getClass()).serialize(object, null, filter);\n    }\n    catch (XmlSerializationException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      throw new XmlSerializationException(\"Can't serialize instance of \" + object.getClass(), e);\n    }\n  }","id":40278,"modified_method":"@NotNull\n  Element serialize(@NotNull Object object) throws XmlSerializationException {\n    try {\n      Element serialized = (Element)getBinding(object.getClass()).serialize(object, null, filter);\n      if (serialized == null) {\n        // top level expects not null (null indicates error, empty element will be omitted)\n        return new Element(\"empty\");\n      }\n      return serialized;\n    }\n    catch (XmlSerializationException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      throw new XmlSerializationException(\"Can't serialize instance of \" + object.getClass(), e);\n    }\n  }","commit_id":"8272a35c093d62b051f06faa36a32e49df244b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternalWithNonDefaults(Element element) {\n      XmlSerializer.serializeInto(this, element, new SkipDefaultValuesSerializationFilters());\n    }","id":40279,"modified_method":"public void writeExternalWithNonDefaults(Element element, final IndentOptions defaultOptions) {\n      XmlSerializer.serializeInto(this, element, new SkipDefaultValuesSerializationFilters() {\n        @Override\n        protected void configure(Object o) {\n          if (o instanceof IndentOptions && defaultOptions != null) {\n            ((IndentOptions)o).copyFrom(defaultOptions);\n          }\n        }\n      });\n    }","commit_id":"85ab249ea853412b73a5acb7f03584169074ee24","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(Element element) throws WriteExternalException {\n    DefaultJDOMExternalizer.writeExternal(this, element, new DifferenceFilter<CommonCodeStyleSettings>(this, getDefaultSettings()));\n    if (myIndentOptions != null) {\n      myIndentOptions.writeExternalWithNonDefaults(element);\n    }\n  }","id":40280,"modified_method":"public void writeExternal(Element element) throws WriteExternalException {\n    CommonCodeStyleSettings defaultSettings = getDefaultSettings(); \n    DefaultJDOMExternalizer.writeExternal(this, element, new DifferenceFilter<CommonCodeStyleSettings>(this, defaultSettings));\n    if (myIndentOptions != null) {\n      IndentOptions defaultIndentOptions = defaultSettings != null ? defaultSettings.getIndentOptions() : null;\n      myIndentOptions.writeExternalWithNonDefaults(element, defaultIndentOptions);\n    }\n  }","commit_id":"85ab249ea853412b73a5acb7f03584169074ee24","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUpInWriteAction() throws Exception {\n    super.setUpInWriteAction();\n    CompilerManager.getInstance(myProject).addBeforeTask(new CompileTask() {\n      @Override\n      public boolean execute(CompileContext context) {\n        AccessToken token = ReadAction.start();\n        try {\n          new GradleResourceCompilerConfigurationGenerator(myProject, context).generateBuildConfiguration();\n        }\n        finally {\n          token.finish();\n        }\n        return true;\n      }\n    });\n  }","id":40281,"modified_method":"@Override\n  protected void setUpInWriteAction() throws Exception {\n    super.setUpInWriteAction();\n\n    final GradleResourceCompilerConfigurationGenerator buildConfigurationGenerator = new GradleResourceCompilerConfigurationGenerator(myProject);\n    CompilerManager.getInstance(myProject).addBeforeTask(new CompileTask() {\n      @Override\n      public boolean execute(CompileContext context) {\n        AccessToken token = ReadAction.start();\n        try {\n          buildConfigurationGenerator.generateBuildConfiguration(context);\n        }\n        finally {\n          token.finish();\n        }\n        return true;\n      }\n    });\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleResourceCompilerConfigurationGenerator(@NotNull final Project project, @NotNull final CompileContext context) {\n    myProject = project;\n    myContext = context;\n    myExternalProjectDataService =\n      (ExternalProjectDataService)ServiceManager.getService(ProjectDataManager.class).getDataService(ExternalProjectDataService.KEY);\n    assert myExternalProjectDataService != null;\n\n    myExternalProjectMap = new FactoryMap<String, ExternalProject>() {\n      @Nullable\n      @Override\n      protected ExternalProject create(String gradleProjectPath) {\n        return myExternalProjectDataService.getRootExternalProject(GradleConstants.SYSTEM_ID, new File(gradleProjectPath));\n      }\n    };\n  }","id":40282,"modified_method":"public GradleResourceCompilerConfigurationGenerator(@NotNull final Project project) {\n    myProject = project;\n    projectConfig = new GradleProjectConfiguration();\n    myExternalProjectDataService =\n      (ExternalProjectDataService)ServiceManager.getService(ProjectDataManager.class).getDataService(ExternalProjectDataService.KEY);\n    assert myExternalProjectDataService != null;\n\n    MessageBusConnection connection = project.getMessageBus().connect(project);\n    connection.subscribe(ProjectTopics.MODULES, new ModuleAdapter() {\n      public void moduleRemoved(Project project, Module module) {\n        projectConfig.moduleConfigurations.remove(module.getName());\n      }\n\n      @Override\n      public void modulesRenamed(Project project, List<Module> modules, Function<Module, String> oldNameProvider) {\n        for (Module module : modules) {\n          moduleRemoved(project, module);\n        }\n      }\n    });\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void generateBuildConfiguration() {\n\n    if(shouldBeBuiltByExternalSystem(myProject)) return;\n\n    if (!hasGradleModules()) return;\n\n    final BuildManager buildManager = BuildManager.getInstance();\n    final File projectSystemDir = buildManager.getProjectSystemDirectory(myProject);\n    if (projectSystemDir == null) return;\n\n    final File gradleConfigFile = new File(projectSystemDir, GradleProjectConfiguration.CONFIGURATION_FILE_RELATIVE_PATH);\n\n    GradleProjectConfiguration projectConfig = new GradleProjectConfiguration();\n    for (Module module : myContext.getCompileScope().getAffectedModules()) {\n      if (!ExternalSystemApiUtil.isExternalSystemAwareModule(GradleConstants.SYSTEM_ID, module)) continue;\n\n      if(shouldBeBuiltByExternalSystem(module)) continue;\n\n      final String gradleProjectPath = module.getOptionValue(ExternalSystemConstants.ROOT_PROJECT_PATH_KEY);\n      assert gradleProjectPath != null;\n      final ExternalProject externalRootProject = myExternalProjectMap.get(gradleProjectPath);\n      if (externalRootProject == null) {\n        myContext.addMessage(CompilerMessageCategory.ERROR,\n                             String.format(\"Unable to make the module: %s, related gradle configuration was not found. \" +\n                                           \"Please, re-import the Gradle project and try again.\",\n                                           module.getName()), VfsUtilCore.pathToUrl(gradleProjectPath), -1, -1);\n        continue;\n      }\n\n      ExternalProject externalProject = myExternalProjectDataService.findExternalProject(externalRootProject, module);\n      if (externalProject == null) {\n        LOG.warn(\"Unable to find config for module: \" + module.getName());\n        continue;\n      }\n\n      GradleModuleResourceConfiguration resourceConfig = new GradleModuleResourceConfiguration();\n      resourceConfig.id = new ModuleVersion(externalProject.getGroup(), externalProject.getName(), externalProject.getVersion());\n      resourceConfig.directory = FileUtil.toSystemIndependentName(externalProject.getProjectDir().getPath());\n\n      final ExternalSourceSet mainSourcesSet = externalProject.getSourceSets().get(\"main\");\n      addResources(resourceConfig.resources, mainSourcesSet, ExternalSystemSourceType.RESOURCE);\n\n      final ExternalSourceSet testSourcesSet = externalProject.getSourceSets().get(\"test\");\n      addResources(resourceConfig.testResources, testSourcesSet, ExternalSystemSourceType.TEST_RESOURCE);\n\n      final CompilerModuleExtension compilerModuleExtension = CompilerModuleExtension.getInstance(module);\n      if(compilerModuleExtension != null && compilerModuleExtension.isCompilerOutputPathInherited()) {\n        String outputPath = VfsUtilCore.urlToPath(compilerModuleExtension.getCompilerOutputUrl());\n        for (ResourceRootConfiguration resource : resourceConfig.resources) {\n          resource.targetPath = outputPath;\n        }\n\n        String testOutputPath = VfsUtilCore.urlToPath(compilerModuleExtension.getCompilerOutputUrlForTests());\n        for (ResourceRootConfiguration resource : resourceConfig.testResources) {\n          resource.targetPath = testOutputPath;\n        }\n      }\n\n      projectConfig.moduleConfigurations.put(module.getName(), resourceConfig);\n    }\n\n    final Document document = new Document(new Element(\"gradle-project-configuration\"));\n    XmlSerializer.serializeInto(projectConfig, document.getRootElement());\n    buildManager.runCommand(new Runnable() {\n      @Override\n      public void run() {\n        buildManager.clearState(myProject);\n        FileUtil.createIfDoesntExist(gradleConfigFile);\n        try {\n          JDOMUtil.writeDocument(document, gradleConfigFile, \"\\n\");\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n  }","id":40283,"modified_method":"public void generateBuildConfiguration(@NotNull final CompileContext context) {\n\n    if(shouldBeBuiltByExternalSystem(myProject)) return;\n\n    if (!hasGradleModules(context)) return;\n\n    final BuildManager buildManager = BuildManager.getInstance();\n    final File projectSystemDir = buildManager.getProjectSystemDirectory(myProject);\n    if (projectSystemDir == null) return;\n\n    final File gradleConfigFile = new File(projectSystemDir, GradleProjectConfiguration.CONFIGURATION_FILE_RELATIVE_PATH);\n\n    //noinspection MismatchedQueryAndUpdateOfCollection\n    final Map<String, ExternalProject> lazyExternalProjectMap = new FactoryMap<String, ExternalProject>() {\n      @Nullable\n      @Override\n      protected ExternalProject create(String gradleProjectPath) {\n        return myExternalProjectDataService.getRootExternalProject(GradleConstants.SYSTEM_ID, new File(gradleProjectPath));\n      }\n    };\n\n    Map<String, GradleModuleResourceConfiguration> affectedModuleConfigurations = new THashMap<String, GradleModuleResourceConfiguration>();\n    for (Module module : context.getCompileScope().getAffectedModules()) {\n      if (!ExternalSystemApiUtil.isExternalSystemAwareModule(GradleConstants.SYSTEM_ID, module)) continue;\n\n      if(shouldBeBuiltByExternalSystem(module)) continue;\n\n      final String gradleProjectPath = module.getOptionValue(ExternalSystemConstants.ROOT_PROJECT_PATH_KEY);\n      assert gradleProjectPath != null;\n      final ExternalProject externalRootProject = lazyExternalProjectMap.get(gradleProjectPath);\n      if (externalRootProject == null) {\n        context.addMessage(CompilerMessageCategory.ERROR,\n                             String.format(\"Unable to make the module: %s, related gradle configuration was not found. \" +\n                                           \"Please, re-import the Gradle project and try again.\",\n                                           module.getName()), VfsUtilCore.pathToUrl(gradleProjectPath), -1, -1);\n        continue;\n      }\n\n      ExternalProject externalProject = myExternalProjectDataService.findExternalProject(externalRootProject, module);\n      if (externalProject == null) {\n        LOG.warn(\"Unable to find config for module: \" + module.getName());\n        continue;\n      }\n\n      GradleModuleResourceConfiguration resourceConfig = new GradleModuleResourceConfiguration();\n      resourceConfig.id = new ModuleVersion(externalProject.getGroup(), externalProject.getName(), externalProject.getVersion());\n      resourceConfig.directory = FileUtil.toSystemIndependentName(externalProject.getProjectDir().getPath());\n\n      final ExternalSourceSet mainSourcesSet = externalProject.getSourceSets().get(\"main\");\n      addResources(resourceConfig.resources, mainSourcesSet, ExternalSystemSourceType.RESOURCE);\n\n      final ExternalSourceSet testSourcesSet = externalProject.getSourceSets().get(\"test\");\n      addResources(resourceConfig.testResources, testSourcesSet, ExternalSystemSourceType.TEST_RESOURCE);\n\n      final CompilerModuleExtension compilerModuleExtension = CompilerModuleExtension.getInstance(module);\n      if(compilerModuleExtension != null && compilerModuleExtension.isCompilerOutputPathInherited()) {\n        String outputPath = VfsUtilCore.urlToPath(compilerModuleExtension.getCompilerOutputUrl());\n        for (ResourceRootConfiguration resource : resourceConfig.resources) {\n          resource.targetPath = outputPath;\n        }\n\n        String testOutputPath = VfsUtilCore.urlToPath(compilerModuleExtension.getCompilerOutputUrlForTests());\n        for (ResourceRootConfiguration resource : resourceConfig.testResources) {\n          resource.targetPath = testOutputPath;\n        }\n      }\n\n      affectedModuleConfigurations.put(module.getName(), resourceConfig);\n    }\n\n    boolean configurationUpdateRequired = false;\n    for (Map.Entry<String, GradleModuleResourceConfiguration> entry : affectedModuleConfigurations.entrySet()) {\n      GradleModuleResourceConfiguration currentConfiguration = projectConfig.moduleConfigurations.get(entry.getKey());\n\n      if (currentConfiguration == null || !isSameModuleConfiguration(currentConfiguration, entry.getValue())) {\n        configurationUpdateRequired = true;\n        break;\n      }\n    }\n\n    if (configurationUpdateRequired || context.isRebuild()) {\n      projectConfig.moduleConfigurations.putAll(affectedModuleConfigurations);\n\n      final Document document = new Document(new Element(\"gradle-project-configuration\"));\n      XmlSerializer.serializeInto(projectConfig, document.getRootElement());\n      buildManager.runCommand(new Runnable() {\n        @Override\n        public void run() {\n          buildManager.clearState(myProject);\n          FileUtil.createIfDoesntExist(gradleConfigFile);\n          try {\n            JDOMUtil.writeDocument(document, gradleConfigFile, \"\\n\");\n          }\n          catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n    }\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addResources(@NotNull List<ResourceRootConfiguration> container,\n                                   @Nullable ExternalSourceSet externalSourceSet,\n                                   @NotNull ExternalSystemSourceType sourceType) {\n    if (externalSourceSet == null) return;\n    final ExternalSourceDirectorySet directorySet = externalSourceSet.getSources().get(sourceType);\n    if (directorySet == null) return;\n\n    for (File file : directorySet.getSrcDirs()) {\n      final String dir = file.getPath();\n      final ResourceRootConfiguration rootConfiguration = new ResourceRootConfiguration();\n      rootConfiguration.directory = FileUtil.toSystemIndependentName(dir);\n      final String target = directorySet.getOutputDir().getPath();\n      rootConfiguration.targetPath = FileUtil.toSystemIndependentName(target);\n\n      rootConfiguration.includes.clear();\n      for (String include : directorySet.getIncludes()) {\n        rootConfiguration.includes.add(include.trim());\n      }\n      rootConfiguration.excludes.clear();\n      for (String exclude : directorySet.getExcludes()) {\n        rootConfiguration.excludes.add(exclude.trim());\n      }\n\n      rootConfiguration.isFiltered = !directorySet.getFilters().isEmpty();\n      rootConfiguration.filters.clear();\n      for (ExternalFilter filter : directorySet.getFilters()) {\n        final ResourceRootFilter resourceRootFilter = new ResourceRootFilter();\n        resourceRootFilter.filterType = filter.getFilterType();\n        resourceRootFilter.properties = filter.getPropertiesAsJsonMap();\n        rootConfiguration.filters.add(resourceRootFilter);\n      }\n\n      container.add(rootConfiguration);\n    }\n  }","id":40284,"modified_method":"private static boolean hasGradleModules(@NotNull CompileContext context) {\n    for (Module module : context.getCompileScope().getAffectedModules()) {\n      if (ExternalSystemApiUtil.isExternalSystemAwareModule(GradleConstants.SYSTEM_ID, module)) return true;\n    }\n    return false;\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void runActivity(@NotNull final Project project) {\n    configureBuildClasspath(project);\n    showNotificationForUnlinkedGradleProject(project);\n    CompilerManager.getInstance(project).addBeforeTask(new CompileTask() {\n      @Override\n      public boolean execute(CompileContext context) {\n        AccessToken token = ReadAction.start();\n        try {\n          new GradleResourceCompilerConfigurationGenerator(project, context).generateBuildConfiguration();\n        }\n        finally {\n          token.finish();\n        }\n        return true;\n      }\n    });\n  }","id":40285,"modified_method":"@Override\n  public void runActivity(@NotNull final Project project) {\n    configureBuildClasspath(project);\n    showNotificationForUnlinkedGradleProject(project);\n\n    final GradleResourceCompilerConfigurationGenerator buildConfigurationGenerator = new GradleResourceCompilerConfigurationGenerator(project);\n    CompilerManager.getInstance(project).addBeforeTask(new CompileTask() {\n      @Override\n      public boolean execute(CompileContext context) {\n        AccessToken token = ReadAction.start();\n        try {\n          buildConfigurationGenerator.generateBuildConfiguration(context);\n        }\n        finally {\n          token.finish();\n        }\n        return true;\n      }\n    });\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int computeConfigurationHash() {\n    int result = filterType.hashCode();\n    result = 31 * result + properties.hashCode();\n    return result;\n  }","id":40286,"modified_method":"public int computeConfigurationHash() {\n    int result = filterType.hashCode();\n    result = 31 * result + getProperties().hashCode();\n    return result;\n  }","commit_id":"251d6cc7d2f76b6d614f6aff10f339c6effe4ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isBoxed(ProducedType type) {\n        return (type  != null) && (isOptional(type) || type.getDeclaration() instanceof TypeParameter);\n    }","id":40287,"modified_method":"private boolean isBoxed(ProducedType type) {\n        return (type  != null) && (isOptional(type) || isTypeParameter(type));\n    }","commit_id":"5b3c9ab9c7bc46fe546767c19d8f48ecec9d4433","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected JCExpression boxUnboxIfNecessary(JCExpression expr, ProducedType exprType, ProducedType targetType) {\n        if (isBoxed(targetType) && !isBoxed(exprType)) {\n            if (simplifyType(targetType).isExactly(exprType)) {\n                // box\n                expr = boxType(expr, exprType);\n            }\n        } else if (!isBoxed(targetType) && isBoxed(exprType)) {\n            if (targetType.isExactly(simplifyType(exprType))) {\n                // unbox\n                expr = unboxType(expr, targetType);\n            }\n        }\n        return expr;\n    }","id":40288,"modified_method":"protected JCExpression boxUnboxIfNecessary(JCExpression expr, ProducedType exprType, ProducedType targetType) {\n        if (isBoxed(targetType) && !isBoxed(exprType)) {\n            if (isTypeParameter(targetType) || simplifyType(targetType).isExactly(exprType)) {\n                // box\n                expr = boxType(expr, exprType);\n            }\n        } else if (!isBoxed(targetType) && isBoxed(exprType)) {\n            if (isTypeParameter(exprType) || targetType.isExactly(simplifyType(exprType))) {\n                // unbox\n                expr = unboxType(expr, targetType);\n            }\n        }\n        return expr;\n    }","commit_id":"5b3c9ab9c7bc46fe546767c19d8f48ecec9d4433","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected JCExpression makeJavaType(ProducedType type, int flags) {\n        int satisfiesOrExtendsOrTypeParam = flags & (SATISFIES | EXTENDS | TYPE_PARAM);\n        int satisfiesOrExtends = flags & (SATISFIES | EXTENDS);\n        \n        // ERASURE\n        if (willEraseToObject(type)) {\n            // For an erased type:\n            // - Any of the Ceylon types Void, Object, Nothing, Equality,\n            //   IdentifiableObject, and Bottom result in the Java type Object\n            // For any other union type U|V (U nor V is Optional):\n            // - The Ceylon type U|V results in the Java type Object\n            ProducedType iterType = typeFact().getNonemptyIterableType(typeFact().getDefiniteType(type));\n            if (iterType != null) {\n                // We special case the erasure of X[] and X[]?\n                type = iterType;\n            } else {\n                if ((flags & SATISFIES) != 0) {\n                    return null;\n                } else {\n                    return make().Type(syms().objectType);\n                }\n            }\n        } else if (satisfiesOrExtendsOrTypeParam == 0 && !isOptional(type)) {\n            if (isCeylonString(type)) {\n                return make().Type(syms().stringType);\n            } else if (isCeylonBoolean(type)) {\n                return make().TypeIdent(TypeTags.BOOLEAN);\n            } else if (isCeylonNatural(type)) {\n                return make().TypeIdent(TypeTags.LONG);\n            } else if (isCeylonInteger(type)) {\n                return make().TypeIdent(TypeTags.INT);\n            } else if (isCeylonFloat(type)) {\n                return make().TypeIdent(TypeTags.DOUBLE);\n            } else if (isCeylonCharacter(type)) {\n                return make().TypeIdent(TypeTags.CHAR);\n            }\n        }\n        \n        JCExpression jt;\n        type = simplifyType(type);\n        TypeDeclaration tdecl = type.getDeclaration();\n        java.util.List<ProducedType> tal = type.getTypeArgumentList();\n\n        if (((flags & WANT_RAW_TYPE) == 0) && tal != null && !tal.isEmpty()) {\n            // GENERIC TYPES\n\n            ListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\n            int idx = 0;\n            for (ProducedType ta : tal) {\n                if (isOptional(ta)) {\n                    // For an optional type T?:\n                    // - The Ceylon type Foo<T?> results in the Java type Foo<T>.\n                    ta = typeFact().getDefiniteType(ta);\n                }\n                if (typeFact().isUnion(ta)) {\n                    // For any other union type U|V (U nor V is Optional):\n                    // - The Ceylon type Foo<U|V> results in the raw Java type Foo.\n                    // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                    typeArgs = null;\n                    break;\n                }\n                JCExpression jta;\n                if (sameType(syms().ceylonVoidType, ta)) {\n                    // For the root type Void:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<Void> appearing in an extends or satisfies\n                        //   clause results in the Java raw type Foo<Object>\n                        jta = make().Type(syms().objectType);\n                    } else {\n                        // - The Ceylon type Foo<Void> appearing anywhere else results in the Java type\n                        // - Foo<Object> if Foo<T> is invariant in T\n                        // - Foo<?> if Foo<T> is covariant in T, or\n                        // - Foo<Object> if Foo<T> is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Type(syms().objectType);\n                        } else if (tp.isCovariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.UNBOUND), makeJavaType(ta));\n                        } else {\n                            jta = make().Type(syms().objectType);\n                        }\n                    }\n                } else if (ta.getDeclaration() instanceof BottomType) {\n                    // For the bottom type Bottom:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<Bottom> appearing in an extends or satisfies\n                        //   clause results in the Java raw type Foo\n                        // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                        typeArgs = null;\n                        break;\n                    } else {\n                        // - The Ceylon type Foo<Bottom> appearing anywhere else results in the Java type\n                        // - raw Foo if Foo<T> is invariant in T,\n                        // - raw Foo if Foo<T> is covariant in T, or\n                        // - Foo<?> if Foo<T> is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.UNBOUND), makeJavaType(ta));\n                        } else {\n                            // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                            typeArgs = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // For an ordinary class or interface type T:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<T> appearing in an extends or satisfies clause\n                        //   results in the Java type Foo<T>\n                        jta = makeJavaType(ta, satisfiesOrExtends);\n                    } else {\n                        // - The Ceylon type Foo<T> appearing anywhere else results in the Java type\n                        // - Foo<T> if Foo is invariant in T,\n                        // - Foo<? extends T> if Foo is covariant in T, or\n                        // - Foo<? super T> if Foo is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.SUPER), makeJavaType(ta, TYPE_PARAM));\n                        } else if (tp.isCovariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.EXTENDS), makeJavaType(ta, TYPE_PARAM));\n                        } else {\n                            jta = makeJavaType(ta, TYPE_PARAM);\n                        }\n                    }\n                }\n                typeArgs.add(jta);\n                idx++;\n            }\n\n            if (typeArgs != null && typeArgs.size() > 0) {\n                jt = make().TypeApply(makeIdent(tdecl.getQualifiedNameString()), typeArgs.toList());\n            } else {\n                jt = makeIdent(tdecl.getQualifiedNameString());\n            }\n        } else {\n            // For an ordinary class or interface type T:\n            // - The Ceylon type T results in the Java type T\n            if(tdecl instanceof TypeParameter)\n                jt = makeIdent(tdecl.getName());\n            else\n                jt = makeIdent(tdecl.getQualifiedNameString());\n        }\n        \n        return jt;\n    }","id":40289,"modified_method":"protected JCExpression makeJavaType(ProducedType type, int flags) {\n        int satisfiesOrExtendsOrTypeParam = flags & (SATISFIES | EXTENDS | TYPE_PARAM);\n        int satisfiesOrExtends = flags & (SATISFIES | EXTENDS);\n        \n        // ERASURE\n        if (willEraseToObject(type)) {\n            // For an erased type:\n            // - Any of the Ceylon types Void, Object, Nothing, Equality,\n            //   IdentifiableObject, and Bottom result in the Java type Object\n            // For any other union type U|V (U nor V is Optional):\n            // - The Ceylon type U|V results in the Java type Object\n            ProducedType iterType = typeFact().getNonemptyIterableType(typeFact().getDefiniteType(type));\n            if (iterType != null) {\n                // We special case the erasure of X[] and X[]?\n                type = iterType;\n            } else {\n                if ((flags & SATISFIES) != 0) {\n                    return null;\n                } else {\n                    return make().Type(syms().objectType);\n                }\n            }\n        } else if (satisfiesOrExtendsOrTypeParam == 0 && !isOptional(type)) {\n            if (isCeylonString(type)) {\n                return make().Type(syms().stringType);\n            } else if (isCeylonBoolean(type)) {\n                return make().TypeIdent(TypeTags.BOOLEAN);\n            } else if (isCeylonNatural(type)) {\n                return make().TypeIdent(TypeTags.LONG);\n            } else if (isCeylonInteger(type)) {\n                return make().TypeIdent(TypeTags.INT);\n            } else if (isCeylonFloat(type)) {\n                return make().TypeIdent(TypeTags.DOUBLE);\n            } else if (isCeylonCharacter(type)) {\n                return make().TypeIdent(TypeTags.CHAR);\n            }\n        }\n        \n        JCExpression jt;\n        type = simplifyType(type);\n        TypeDeclaration tdecl = type.getDeclaration();\n        java.util.List<ProducedType> tal = type.getTypeArgumentList();\n\n        if (((flags & WANT_RAW_TYPE) == 0) && tal != null && !tal.isEmpty()) {\n            // GENERIC TYPES\n\n            ListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\n            int idx = 0;\n            for (ProducedType ta : tal) {\n                if (isOptional(ta)) {\n                    // For an optional type T?:\n                    // - The Ceylon type Foo<T?> results in the Java type Foo<T>.\n                    ta = typeFact().getDefiniteType(ta);\n                }\n                if (typeFact().isUnion(ta)) {\n                    // For any other union type U|V (U nor V is Optional):\n                    // - The Ceylon type Foo<U|V> results in the raw Java type Foo.\n                    // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                    typeArgs = null;\n                    break;\n                }\n                JCExpression jta;\n                if (sameType(syms().ceylonVoidType, ta)) {\n                    // For the root type Void:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<Void> appearing in an extends or satisfies\n                        //   clause results in the Java raw type Foo<Object>\n                        jta = make().Type(syms().objectType);\n                    } else {\n                        // - The Ceylon type Foo<Void> appearing anywhere else results in the Java type\n                        // - Foo<Object> if Foo<T> is invariant in T\n                        // - Foo<?> if Foo<T> is covariant in T, or\n                        // - Foo<Object> if Foo<T> is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Type(syms().objectType);\n                        } else if (tp.isCovariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.UNBOUND), makeJavaType(ta));\n                        } else {\n                            jta = make().Type(syms().objectType);\n                        }\n                    }\n                } else if (ta.getDeclaration() instanceof BottomType) {\n                    // For the bottom type Bottom:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<Bottom> appearing in an extends or satisfies\n                        //   clause results in the Java raw type Foo\n                        // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                        typeArgs = null;\n                        break;\n                    } else {\n                        // - The Ceylon type Foo<Bottom> appearing anywhere else results in the Java type\n                        // - raw Foo if Foo<T> is invariant in T,\n                        // - raw Foo if Foo<T> is covariant in T, or\n                        // - Foo<?> if Foo<T> is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.UNBOUND), makeJavaType(ta));\n                        } else {\n                            // A bit ugly, but we need to escape from the loop and create a raw type, no generics\n                            typeArgs = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // For an ordinary class or interface type T:\n                    if (satisfiesOrExtends != 0) {\n                        // - The Ceylon type Foo<T> appearing in an extends or satisfies clause\n                        //   results in the Java type Foo<T>\n                        jta = makeJavaType(ta, satisfiesOrExtends);\n                    } else {\n                        // - The Ceylon type Foo<T> appearing anywhere else results in the Java type\n                        // - Foo<T> if Foo is invariant in T,\n                        // - Foo<? extends T> if Foo is covariant in T, or\n                        // - Foo<? super T> if Foo is contravariant in T\n                        TypeParameter tp = tdecl.getTypeParameters().get(idx);\n                        if (tp.isContravariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.SUPER), makeJavaType(ta, TYPE_PARAM));\n                        } else if (tp.isCovariant()) {\n                            jta = make().Wildcard(make().TypeBoundKind(BoundKind.EXTENDS), makeJavaType(ta, TYPE_PARAM));\n                        } else {\n                            jta = makeJavaType(ta, TYPE_PARAM);\n                        }\n                    }\n                }\n                typeArgs.add(jta);\n                idx++;\n            }\n\n            if (typeArgs != null && typeArgs.size() > 0) {\n                jt = make().TypeApply(makeIdent(getDeclarationName(tdecl)), typeArgs.toList());\n            } else {\n                jt = makeIdent(getDeclarationName(tdecl));\n            }\n        } else {\n            // For an ordinary class or interface type T:\n            // - The Ceylon type T results in the Java type T\n            if(tdecl instanceof TypeParameter)\n                jt = makeIdent(tdecl.getName());\n            else\n                jt = makeIdent(getDeclarationName(tdecl));\n        }\n        \n        return jt;\n    }","commit_id":"5b3c9ab9c7bc46fe546767c19d8f48ecec9d4433","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void concept_ref_1(SNode node) {\n    SNode concept1 = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    SNode concept2 = SNodeOperations.getConceptDeclaration(node);\n    if (SConceptOperations.isSuperConceptOf(concept1, NameUtil.nodeFQName(concept2))) {\n    }\n    if (SConceptOperations.isExactly(concept1, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) {\n    }\n    AbstractConceptDeclaration adapter = ((AbstractConceptDeclaration)SNodeOperations.getAdapter(concept1));\n  }","id":40290,"modified_method":"public void concept_ref_1(SNode node) {\n    SNode concept1 = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    SNode concept2 = SNodeOperations.getConceptDeclaration(node);\n    if (SConceptOperations.isSuperConceptOf(concept1, NameUtil.nodeFQName(concept2))) {\n    }\n    boolean b1 = SConceptOperations.isExactly(concept1, \"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    boolean b2 = SConceptOperations.isExactly(concept1, \"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    AbstractConceptDeclaration adapter = ((AbstractConceptDeclaration)SNodeOperations.getAdapter(concept1));\n  }","commit_id":"18a14ab36af836ea6bfc7dffc5d0174a66597866","url":"https://github.com/JetBrains/MPS"},{"original_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0b, fqName)) {\n      case 8:\n        return new RequiredDataDeclaration_BehaviorDescriptor();\n      case 1:\n        return new DataDependency_BehaviorDescriptor();\n      case 4:\n        return new MigrationScript_BehaviorDescriptor();\n      case 6:\n        return new ProducedDataDeclaration_BehaviorDescriptor();\n      case 2:\n        return new DataDependencyReference_BehaviorDescriptor();\n      case 3:\n        return new ExecuteAfterDeclaration_BehaviorDescriptor();\n      case 5:\n        return new OrderDependency_BehaviorDescriptor();\n      case 9:\n        return new TransformStatement_BehaviorDescriptor();\n      case 7:\n        return new QuotationConsequence_BehaviorDescriptor();\n      case 0:\n        return new ConsequenceFunction_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","id":40291,"modified_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0b, fqName)) {\n      case 11:\n        return new RequiredDataDeclaration_BehaviorDescriptor();\n      case 1:\n        return new DataDependency_BehaviorDescriptor();\n      case 5:\n        return new MigrationScript_BehaviorDescriptor();\n      case 8:\n        return new ProducedDataDeclaration_BehaviorDescriptor();\n      case 2:\n        return new DataDependencyReference_BehaviorDescriptor();\n      case 3:\n        return new ExecuteAfterDeclaration_BehaviorDescriptor();\n      case 7:\n        return new OrderDependency_BehaviorDescriptor();\n      case 12:\n        return new TransformStatement_BehaviorDescriptor();\n      case 10:\n        return new QuotationConsequence_BehaviorDescriptor();\n      case 0:\n        return new ConsequenceFunction_BehaviorDescriptor();\n      case 4:\n        return new LinkPatternVariableReference_BehaviorDescriptor();\n      case 6:\n        return new NodePatternVariableReference_BehaviorDescriptor();\n      case 9:\n        return new PropertyPatternVariableReference_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0b, fqName)) {\n      case 0:\n        return new DataDependencyReference_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","id":40292,"modified_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0b, fqName)) {\n      case 0:\n        return new DataDependencyReference_Constraints();\n      case 1:\n        return new LinkPatternVariableReference_Constraints();\n      case 2:\n        return new NodePatternVariableReference_Constraints();\n      case 3:\n        return new PropertyPatternVariableReference_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {\n    switch (Arrays.binarySearch(stringSwitchCases_xbvbvu_a0a0b, descriptor.getConceptFqName())) {\n      case 0:\n        return Collections.<ConceptEditor>singletonList(new DataDependency_Editor());\n      case 1:\n        return Collections.<ConceptEditor>singletonList(new DataDependencyReference_Editor());\n      case 2:\n        return Collections.<ConceptEditor>singletonList(new ExecuteAfterDeclaration_Editor());\n      case 3:\n        return Collections.<ConceptEditor>singletonList(new MigrationScript_Editor());\n      case 4:\n        return Collections.<ConceptEditor>singletonList(new OrderDependency_Editor());\n      case 5:\n        return Collections.<ConceptEditor>singletonList(new ProducedDataDeclaration_Editor());\n      case 6:\n        return Collections.<ConceptEditor>singletonList(new RequiredDataDeclaration_Editor());\n      case 7:\n        return Collections.<ConceptEditor>singletonList(new TransformStatement_Editor());\n      default:\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","id":40293,"modified_method":"public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {\n    switch (Arrays.binarySearch(stringSwitchCases_xbvbvu_a0a0b, descriptor.getConceptFqName())) {\n      case 0:\n        return Collections.<ConceptEditor>singletonList(new DataDependency_Editor());\n      case 1:\n        return Collections.<ConceptEditor>singletonList(new DataDependencyReference_Editor());\n      case 2:\n        return Collections.<ConceptEditor>singletonList(new ExecuteAfterDeclaration_Editor());\n      case 3:\n        return Collections.<ConceptEditor>singletonList(new LinkPatternVariableReference_Editor());\n      case 4:\n        return Collections.<ConceptEditor>singletonList(new MigrationScript_Editor());\n      case 5:\n        return Collections.<ConceptEditor>singletonList(new NodePatternVariableReference_Editor());\n      case 6:\n        return Collections.<ConceptEditor>singletonList(new OrderDependency_Editor());\n      case 7:\n        return Collections.<ConceptEditor>singletonList(new ProducedDataDeclaration_Editor());\n      case 8:\n        return Collections.<ConceptEditor>singletonList(new PropertyPatternVariableReference_Editor());\n      case 9:\n        return Collections.<ConceptEditor>singletonList(new RequiredDataDeclaration_Editor());\n      case 10:\n        return Collections.<ConceptEditor>singletonList(new TransformStatement_Editor());\n      default:\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_5636302460526820673(final SourceSubstituteMacroNodeContext _context) {\n    return (SLinkOperations.getTarget(_context.getNode(), \"precondition\", true) != null ? SLinkOperations.getTarget(_context.getNode(), \"precondition\", true) : _quotation_createNode_x583g4_a0a0ab());\n  }","id":40294,"modified_method":"public static SNode sourceNodeQuery_5636302460526820673(final SourceSubstituteMacroNodeContext _context) {\n    return (SLinkOperations.getTarget(_context.getNode(), \"precondition\", true) != null ? SLinkOperations.getTarget(_context.getNode(), \"precondition\", true) : _quotation_createNode_x583g4_a0a0db());\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_x583g4_a0a0ab() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\", null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_6, \"value\", \"true\");\n    quotedNode_4.addChild(\"expression\", quotedNode_6);\n    quotedNode_2.addChild(\"statement\", quotedNode_4);\n    quotedNode_1.addChild(\"body\", quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, \"name\", \"n\");\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SNodeType\", null, null, false);\n    quotedNode_3.addChild(\"type\", quotedNode_5);\n    quotedNode_1.addChild(\"parameter\", quotedNode_3);\n    return quotedNode_1;\n  }","id":40295,"modified_method":"private static SNode _quotation_createNode_x583g4_a0a0db() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\", null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, false);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_6, \"value\", \"true\");\n    quotedNode_4.addChild(\"expression\", quotedNode_6);\n    quotedNode_2.addChild(\"statement\", quotedNode_4);\n    quotedNode_1.addChild(\"body\", quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\", null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, \"name\", \"n\");\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.lang.smodel.structure.SNodeType\", null, null, false);\n    quotedNode_3.addChild(\"type\", quotedNode_5);\n    quotedNode_1.addChild(\"parameter\", quotedNode_3);\n    return quotedNode_1;\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<ConceptDescriptor> getDescriptors() {\n    return Arrays.asList(myConceptConsequenceFunction, myConceptDataDependency, myConceptDataDependencyReference, myConceptExecuteAfterDeclaration, myConceptMigrationScript, myConceptOrderDependency, myConceptProducedDataDeclaration, myConceptQuotationConsequence, myConceptRequiredDataDeclaration, myConceptTransformConsequence, myConceptTransformStatement);\n  }","id":40296,"modified_method":"@Override\n  public Collection<ConceptDescriptor> getDescriptors() {\n    return Arrays.asList(myConceptConsequenceFunction, myConceptDataDependency, myConceptDataDependencyReference, myConceptExecuteAfterDeclaration, myConceptLinkPatternVariableReference, myConceptMigrationScript, myConceptNodePatternVariableReference, myConceptOrderDependency, myConceptProducedDataDeclaration, myConceptPropertyPatternVariableReference, myConceptQuotationConsequence, myConceptRequiredDataDeclaration, myConceptTransformConsequence, myConceptTransformStatement);\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  @Nullable\n  public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0p, conceptFqName)) {\n      case 0:\n        return myConceptConsequenceFunction;\n      case 1:\n        return myConceptDataDependency;\n      case 2:\n        return myConceptDataDependencyReference;\n      case 3:\n        return myConceptExecuteAfterDeclaration;\n      case 4:\n        return myConceptMigrationScript;\n      case 5:\n        return myConceptOrderDependency;\n      case 6:\n        return myConceptProducedDataDeclaration;\n      case 7:\n        return myConceptQuotationConsequence;\n      case 8:\n        return myConceptRequiredDataDeclaration;\n      case 9:\n        return myConceptTransformConsequence;\n      case 10:\n        return myConceptTransformStatement;\n      default:\n        return null;\n    }\n  }","id":40297,"modified_method":"@Override\n  @Nullable\n  public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0s, conceptFqName)) {\n      case 0:\n        return myConceptConsequenceFunction;\n      case 1:\n        return myConceptDataDependency;\n      case 2:\n        return myConceptDataDependencyReference;\n      case 3:\n        return myConceptExecuteAfterDeclaration;\n      case 4:\n        return myConceptLinkPatternVariableReference;\n      case 5:\n        return myConceptMigrationScript;\n      case 6:\n        return myConceptNodePatternVariableReference;\n      case 7:\n        return myConceptOrderDependency;\n      case 8:\n        return myConceptProducedDataDeclaration;\n      case 9:\n        return myConceptPropertyPatternVariableReference;\n      case 10:\n        return myConceptQuotationConsequence;\n      case 11:\n        return myConceptRequiredDataDeclaration;\n      case 12:\n        return myConceptTransformConsequence;\n      case 13:\n        return myConceptTransformStatement;\n      default:\n        return null;\n    }\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope virtual_getScope_3734116213129936182(SNode thisNode, SNode kind, SNode child) {\n    if (!(SConceptOperations.isExactly(kind, \"jetbrains.mps.lang.pattern.structure.PatternVariableDeclaration\"))) {\n      return null;\n    }\n    return new ListScope(SNodeOperations.getDescendants(SLinkOperations.getTarget(thisNode, \"pattern\", true), \"jetbrains.mps.lang.pattern.structure.PatternVariableDeclaration\", false, new String[]{})) {\n      public String getName(SNode child) {\n        return SPropertyOperations.getString(SNodeOperations.cast(child, \"jetbrains.mps.lang.pattern.structure.PatternVariableDeclaration\"), \"name\");\n      }\n    };\n  }","id":40298,"modified_method":"public static Scope virtual_getScope_3734116213129936182(SNode thisNode, SNode kind, SNode child) {\n    if (SConceptOperations.isExactly(kind, \"jetbrains.mps.lang.pattern.structure.PropertyPatternVariableDeclaration\") || SConceptOperations.isExactly(kind, \"jetbrains.mps.lang.pattern.structure.LinkPatternVariableDeclaration\") || SConceptOperations.isExactly(kind, \"jetbrains.mps.lang.pattern.structure.PatternVariableDeclaration\") || SConceptOperations.isExactly(kind, \"jetbrains.mps.lang.pattern.structure.ListPattern\")) {\n      return new NamedElementsScope(SNodeOperations.getDescendants(SLinkOperations.getTarget(thisNode, \"pattern\", true), NameUtil.nodeFQName(((SNode) kind)), false, new String[]{}));\n    }\n\n    return null;\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConsequenceFunction_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DataDependency_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DataDependencyReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TransformStatement_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new MigrationScriptCycles_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new MigrationScriptVersions_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n  }","id":40299,"modified_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConsequenceFunction_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DataDependency_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DataDependencyReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_LinkPatternVariableReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NodePatternVariableReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PropertyPatternVariableReference_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TransformStatement_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new MigrationScriptCycles_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new MigrationScriptVersions_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n  }","commit_id":"4e9098224aa99febfc31eb6c7c61433d26df830f","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Adds a channel to the layout.\n   * @param newChannel the channel to add\n   * @param position either <code>before<\/code> or <code>after<\/code>\n   * @param destinationElementId the ID of the channel to insert the new channel before or append after\n   * @throws Exception\n   */\n  private final void addChannel(Element newChannel, String position, String destinationElementId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n    newChannel = (Element)(userLayout.importNode(newChannel, true));\n    String instanceId = ulStore.getNextStructChannelId(staticData.getPerson());\n    newChannel.setAttribute(\"ID\", instanceId);\n    // The following line is Xerces-specific\n    ((org.apache.xerces.dom.DocumentImpl)userLayout).putIdentifier(instanceId, newChannel);\n\n    Element destinationElement = userLayout.getElementById(destinationElementId);\n\n    // The destination element might be an empty tab or a column\n    if (isTab(destinationElement))\n    {\n      // Create a new column in this tab and move the source channel there\n      Element newColumn = createFolder(\"\");\n      Node destinationTab = userLayout.getElementById(destinationElementId);\n      UserLayoutManager.moveNode(newColumn, destinationTab, null);\n      UserLayoutManager.moveNode(newChannel, newColumn, null);\n    }\n    else if (isColumn(destinationElement))\n    {\n      // Move the source channel into the destination column\n      UserLayoutManager.moveNode(newChannel, destinationElement, null);\n    }\n    else\n    {\n      // Move the source channel before the destination channel or at the end\n      Node targetColumn = destinationElement.getParentNode();\n      Node siblingChannel = position.equals(\"before\") ? destinationElement : null;\n      UserLayoutManager.moveNode(newChannel, targetColumn, siblingChannel);\n    }\n\n    saveLayout(true);\n  }","id":40300,"modified_method":"/**\n   * Adds a channel to the layout.\n   * @param newChannel the channel to add\n   * @param position either <code>before<\/code> or <code>after<\/code>\n   * @param destinationElementId the ID of the channel to insert the new channel before or append after\n   * @throws Exception\n   */\n  private final void addChannel(Element newChannel, String position, String destinationElementId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n    newChannel = (Element)(userLayout.importNode(newChannel, true));\n    String instanceId = ulStore.generateNewChannelInstanceId(staticData.getPerson());\n    newChannel.setAttribute(\"ID\", instanceId);\n    // The following line is Xerces-specific\n    ((org.apache.xerces.dom.DocumentImpl)userLayout).putIdentifier(instanceId, newChannel);\n\n    Element destinationElement = userLayout.getElementById(destinationElementId);\n\n    // The destination element might be an empty tab or a column\n    if (isTab(destinationElement))\n    {\n      // Create a new column in this tab and move the source channel there\n      Element newColumn = createFolder(\"\");\n      Node destinationTab = userLayout.getElementById(destinationElementId);\n      UserLayoutManager.moveNode(newColumn, destinationTab, null);\n      UserLayoutManager.moveNode(newChannel, newColumn, null);\n    }\n    else if (isColumn(destinationElement))\n    {\n      // Move the source channel into the destination column\n      UserLayoutManager.moveNode(newChannel, destinationElement, null);\n    }\n    else\n    {\n      // Move the source channel before the destination channel or at the end\n      Node targetColumn = destinationElement.getParentNode();\n      Node siblingChannel = position.equals(\"before\") ? destinationElement : null;\n      UserLayoutManager.moveNode(newChannel, targetColumn, siblingChannel);\n    }\n\n    saveLayout(true);\n  }","commit_id":"dd21ade7e5265d1fcd05aea5394ca32f574ccb28","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Creates a folder element with default attributes.  This method can be used\n   * to create a tab or a column.  For tabs, pass the tab name.  For column,\n   * pass an empty String since column names aren't meaningful\n   * @param name the tab name for tabs and an empty string for columns\n   * @return the newly created tab or column\n   */\n  private final Element createFolder (String name) throws Exception\n  {\n    String ID = String.valueOf(ulStore.getNextStructFolderId(staticData.getPerson()));\n    Element layout = userLayout.getDocumentElement();\n    Document doc = layout.getOwnerDocument();\n    Element folder = doc.createElement(\"folder\");\n    folder.setAttribute(\"name\", name);\n    folder.setAttribute(\"ID\", ID);\n    folder.setAttribute(\"type\", \"regular\");\n    folder.setAttribute(\"hidden\", \"false\");\n    folder.setAttribute(\"unremovable\", \"false\");\n    folder.setAttribute(\"immutable\", \"false\");\n\n    // This is Xerces-dependent, but it is the only way to get things to work at the moment\n    // Without this line, it is not possible to access this new folder with the getElementById() method\n    ((org.apache.xerces.dom.DocumentImpl)doc).putIdentifier(ID, folder);\n\n    return folder;\n  }","id":40301,"modified_method":"/**\n   * Creates a folder element with default attributes.  This method can be used\n   * to create a tab or a column.  For tabs, pass the tab name.  For column,\n   * pass an empty String since column names aren't meaningful\n   * @param name the tab name for tabs and an empty string for columns\n   * @return the newly created tab or column\n   */\n  private final Element createFolder (String name) throws Exception\n  {\n    String ID = String.valueOf(ulStore.generateNewFolderId(staticData.getPerson()));\n    Element layout = userLayout.getDocumentElement();\n    Document doc = layout.getOwnerDocument();\n    Element folder = doc.createElement(\"folder\");\n    folder.setAttribute(\"name\", name);\n    folder.setAttribute(\"ID\", ID);\n    folder.setAttribute(\"type\", \"regular\");\n    folder.setAttribute(\"hidden\", \"false\");\n    folder.setAttribute(\"unremovable\", \"false\");\n    folder.setAttribute(\"immutable\", \"false\");\n\n    // This is Xerces-dependent, but it is the only way to get things to work at the moment\n    // Without this line, it is not possible to access this new folder with the getElementById() method\n    ((org.apache.xerces.dom.DocumentImpl)doc).putIdentifier(ID, folder);\n\n    return folder;\n  }","commit_id":"dd21ade7e5265d1fcd05aea5394ca32f574ccb28","url":"https://github.com/Jasig/uPortal"},{"original_method":"private final Document getUserLayout() throws Exception\n  {\n    IUserLayoutManager ulm = context.getUserLayoutManager();\n    // If the we are editing the current profile, get a copy of the current user layout,\n    // otherwise get it from the database or other persistant storage\n    Document userLayout = null;\n    if (modifyingCurrentProfile())\n      userLayout = ulm.getUserLayoutCopy();\n    else\n      userLayout = ulStore.getUserLayout(ulm.getPerson(), context.getCurrentUserPreferences().getProfile().getProfileId());\n\n    return userLayout;\n  }","id":40302,"modified_method":"private final Document getUserLayout() throws Exception\n  {\n    IUserLayoutManager ulm = context.getUserLayoutManager();\n    // If the we are editing the current profile, get a copy of the current user layout,\n    // otherwise get it from the database or other persistant storage\n    Document userLayout = null;\n    if (modifyingCurrentProfile())\n      userLayout = ulm.getUserLayoutCopy();\n    else\n      userLayout = ulStore.getUserLayout(ulm.getPerson(), context.getCurrentUserPreferences().getProfile());\n\n    return userLayout;\n  }","commit_id":"dd21ade7e5265d1fcd05aea5394ca32f574ccb28","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected UserPreferences getUserPreferencesFromStore(UserProfile profile) throws Exception {\n      up = ulsdb.getUserPreferences(getUserLayoutManager().getPerson(), profile);\n      up.synchronizeWithUserLayoutXML(UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(getUserLayoutManager().getPerson(), getCurrentUserPreferences().getProfile().getProfileId()));\n      return up;\n  }","id":40303,"modified_method":"protected UserPreferences getUserPreferencesFromStore(UserProfile profile) throws Exception {\n      up = ulsdb.getUserPreferences(getUserLayoutManager().getPerson(), profile);\n      up.synchronizeWithUserLayoutXML(UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(getUserLayoutManager().getPerson(), getCurrentUserPreferences().getProfile()));\n      return up;\n  }","commit_id":"5d6f4891c3e86898a50e4ed6d93153ff4f2cc48a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * put your documentation comment here\n   * @return userLayoutXML\n   * @exception PortalException\n   */\n  public Document getUserLayoutXML () throws PortalException {\n    if (userLayoutXML == null) {\n      // get the layout from the database\n      try {\n        userLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(context.getUserLayoutManager().getPerson(),\n            context.getCurrentUserPreferences().getProfile().getProfileId());\n      } catch (Exception e) {\n        LogService.instance().log(LogService.ERROR, e);\n        throw  new GeneralRenderingException(e.getMessage());\n      }\n    }\n    return  userLayoutXML;\n  }","id":40304,"modified_method":"/**\n   * put your documentation comment here\n   * @return userLayoutXML\n   * @exception PortalException\n   */\n  public Document getUserLayoutXML () throws PortalException {\n    if (userLayoutXML == null) {\n      // get the layout from the database\n      try {\n        userLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(context.getUserLayoutManager().getPerson(), context.getCurrentUserPreferences().getProfile());\n      } catch (Exception e) {\n        LogService.instance().log(LogService.ERROR, e);\n        throw  new GeneralRenderingException(e.getMessage());\n      }\n    }\n    return  userLayoutXML;\n  }","commit_id":"5d6f4891c3e86898a50e4ed6d93153ff4f2cc48a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Register arrival of a new session.\n     * Create and populate new state entry.\n     * @param req a <code>HttpServletRequest<\/code> value\n     * @exception PortalException if an error occurs\n     */\n    public void registerSession(HttpServletRequest req) throws PortalException {\n        MState newState=new MState();\n        try {\n            // load user preferences\n            // determine user profile\n            String userAgent = req.getHeader(\"User-Agent\");\n            UserProfile upl;\n            // see if the profile was cached\n            if((upl=(UserProfile)cached_profiles.get(userAgent))==null) {\n                synchronized(cached_profiles) {\n                    upl= ulsdb.getUserProfile(m_person, userAgent);\n                    if (upl == null) {\n                        upl = ulsdb.getSystemProfile(userAgent);\n                    }\n                    if(upl!=null) {\n                        cached_profiles.put(userAgent,upl);\n                    }\n                }\n            }\n\n            if(upl==null) {\n                // try guessing the profile through pattern matching\n\n                if(uaMatcher==null) {\n                    // init user agent matcher\n                    URL url = null;\n                    try {\n                        url = this.getClass().getResource(\"/properties/browser.mappings\");\n                        if (url != null) {\n                            uaMatcher = new PropsMatcher(url.openStream());\n                        }\n                    } catch (IOException ioe) {\n                        LogService.instance().log(LogService.ERROR, \"GuestUserLayoutManager::GuestUserLayoutManager() : Exception occurred while loading browser mapping file: \" + url + \". \" + ioe);\n                    }\n                }\n\n                if(uaMatcher!=null) {\n                    // try matching\n                    String profileId=uaMatcher.match(userAgent);\n                    if(profileId!=null) {\n                        // user agent has been matched\n                        LogService.instance().log(LogService.DEBUG, \"GuestUserLayoutManager::GuestUserLayoutManager() : userAgent \\\"\" + userAgent + \"\\\" has matched to a profile \" + profileId);\n                        upl=ulsdb.getSystemProfileById(Integer.parseInt(profileId));\n                    } else {\n                        LogService.instance().log(LogService.DEBUG, \"GuestUserLayoutManager::GuestUserLayoutManager() : userAgent \\\"\" + userAgent + \"\\\" has matched not matched any profile.\");\n                    }\n                }\n            }\n\n            if (upl != null) {\n                // see if the user layout xml has been cached\n                if(upl.isSystemProfile()) {\n                    newState.uLayoutXML=(Document)sp_layouts.get(new Integer(upl.getProfileId()));\n                } else {\n                    newState.uLayoutXML=(Document)up_layouts.get(new Integer(upl.getProfileId()));\n                }\n                if(newState.uLayoutXML==null) {\n                    // read uLayoutXML\n                    try {\n                        newState.uLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(m_person, upl.getProfileId());\n                        if(newState.uLayoutXML!=null) {\n                            if(upl.isSystemProfile()) {\n                                sp_layouts.put(new Integer(upl.getProfileId()),newState.uLayoutXML);\n                            } else {\n                                up_layouts.put(new Integer(upl.getProfileId()),newState.uLayoutXML);\n                            }\n                        }\n                    } catch (Exception e) {\n                        throw new PortalException(\"GuestUserLayoutManager::registerSession() : caught an exception while trying to retreive a userLayout for user=\\\"\" +m_person.getID()+ \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\",e);\n                    }\n                }\n\n                if (newState.uLayoutXML == null) {\n                    throw new PortalException(\"UserLayoutManager::UserLayoutManager() : unable to retreive userLayout for user=\\\"\" +m_person.getID()+ \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\");\n                } else {\n                    // modify the entire profile to be unremovable and immutable\n                    // mark all of the folders\n                    NodeList folderList=newState.uLayoutXML.getElementsByTagName(\"folder\");\n                    for(int i=0;i<folderList.getLength();i++) {\n                        Element e=(Element)folderList.item(i);\n                        e.setAttribute(\"immutable\",\"true\");\n                        e.setAttribute(\"unremovable\",\"true\");                        \n                    }\n                    // mark all of the channels\n                    NodeList channelList=newState.uLayoutXML.getElementsByTagName(\"channel\");\n                    for(int i=0;i<channelList.getLength();i++) {\n                        Element e=(Element)channelList.item(i);\n                        e.setAttribute(\"immutable\",\"true\");\n                        e.setAttribute(\"unremovable\",\"true\");                        \n                    }\n                }\n\n                // see if the user preferences for this profile are cached\n                UserPreferences cleanUP;\n                if(upl.isSystemProfile()) {\n                    cleanUP=(UserPreferences)sp_cleanUPs.get(new Integer(upl.getProfileId()));\n                } else {\n                    cleanUP=(UserPreferences)up_cleanUPs.get(new Integer(upl.getProfileId()));\n                }\n                if(cleanUP==null) {\n                    try {\n                        cleanUP=ulsdb.getUserPreferences(m_person, upl);\n                        if(cleanUP!=null) {\n                            if(upl.isSystemProfile()) {\n                                sp_cleanUPs.put(new Integer(upl.getProfileId()),cleanUP);\n                            } else {\n                                up_cleanUPs.put(new Integer(upl.getProfileId()),cleanUP);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LogService.instance().log(LogService.ERROR,\"GuestUserLayoutManager::registerSession() : unable to find UP for a profile \\\"\"+upl.getProfileName()+\"\\\"\");\n                        cleanUP=new UserPreferences(upl);\n                    }\n                }\n\n                if(cleanUP!=null) {\n                    newState.complete_up=new UserPreferences(cleanUP);\n                } else {\n                    LogService.instance().log(LogService.ERROR,\"GuestUserLayoutManager::registerSession() : unable to find UP for a profile \\\"\"+upl.getProfileName()+\"\\\"\");\n                    newState.complete_up=new UserPreferences(upl);\n                }\n\n                // Initialize the JNDI context for this user\n                JNDIManager.initializeSessionContext(req.getSession(),Integer.toString(m_person.getID()),Integer.toString(upl.getLayoutId()),newState.uLayoutXML);\n            } else {\n                // there is no user-defined mapping for this particular browser.\n                // user should be redirected to a browser-registration page.\n                newState.unmapped_user_agent = true;\n                throw new PortalException(\"GuestUserLayoutManager::registerSession() : unable to find a profile for user \\\"\" + m_person.getID() + \"\\\" and userAgent=\\\"\" + userAgent + \"\\\".\");\n            }\n        } catch (PortalException pe) {\n            throw pe;\n        } catch (Throwable t) {\n            LogService.instance().log(LogService.ERROR, t);\n        }\n\n        stateTable.put(req.getSession(false).getId(),newState);\n    }","id":40305,"modified_method":"/**\n     * Register arrival of a new session.\n     * Create and populate new state entry.\n     * @param req a <code>HttpServletRequest<\/code> value\n     * @exception PortalException if an error occurs\n     */\n    public void registerSession(HttpServletRequest req) throws PortalException {\n        MState newState=new MState();\n        try {\n            // load user preferences\n            // determine user profile\n            String userAgent = req.getHeader(\"User-Agent\");\n            UserProfile upl;\n            // see if the profile was cached\n            if((upl=(UserProfile)cached_profiles.get(userAgent))==null) {\n                synchronized(cached_profiles) {\n                    upl= ulsdb.getUserProfile(m_person, userAgent);\n                    if (upl == null) {\n                        upl = ulsdb.getSystemProfile(userAgent);\n                    }\n                    if(upl!=null) {\n                        cached_profiles.put(userAgent,upl);\n                    }\n                }\n            }\n\n            if(upl==null) {\n                // try guessing the profile through pattern matching\n\n                if(uaMatcher==null) {\n                    // init user agent matcher\n                    URL url = null;\n                    try {\n                        url = this.getClass().getResource(\"/properties/browser.mappings\");\n                        if (url != null) {\n                            uaMatcher = new PropsMatcher(url.openStream());\n                        }\n                    } catch (IOException ioe) {\n                        LogService.instance().log(LogService.ERROR, \"GuestUserLayoutManager::GuestUserLayoutManager() : Exception occurred while loading browser mapping file: \" + url + \". \" + ioe);\n                    }\n                }\n\n                if(uaMatcher!=null) {\n                    // try matching\n                    String profileId=uaMatcher.match(userAgent);\n                    if(profileId!=null) {\n                        // user agent has been matched\n                        LogService.instance().log(LogService.DEBUG, \"GuestUserLayoutManager::GuestUserLayoutManager() : userAgent \\\"\" + userAgent + \"\\\" has matched to a profile \" + profileId);\n                        upl=ulsdb.getSystemProfileById(Integer.parseInt(profileId));\n                    } else {\n                        LogService.instance().log(LogService.DEBUG, \"GuestUserLayoutManager::GuestUserLayoutManager() : userAgent \\\"\" + userAgent + \"\\\" has matched not matched any profile.\");\n                    }\n                }\n            }\n\n            if (upl != null) {\n                // see if the user layout xml has been cached\n                if(upl.isSystemProfile()) {\n                    newState.uLayoutXML=(Document)sp_layouts.get(new Integer(upl.getProfileId()));\n                } else {\n                    newState.uLayoutXML=(Document)up_layouts.get(new Integer(upl.getProfileId()));\n                }\n                if(newState.uLayoutXML==null) {\n                    // read uLayoutXML\n                    try {\n                        newState.uLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(m_person, upl);\n                        if(newState.uLayoutXML!=null) {\n                            if(upl.isSystemProfile()) {\n                                sp_layouts.put(new Integer(upl.getProfileId()),newState.uLayoutXML);\n                            } else {\n                                up_layouts.put(new Integer(upl.getProfileId()),newState.uLayoutXML);\n                            }\n                        }\n                    } catch (Exception e) {\n                        throw new PortalException(\"GuestUserLayoutManager::registerSession() : caught an exception while trying to retreive a userLayout for user=\\\"\" +m_person.getID()+ \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\",e);\n                    }\n                }\n\n                if (newState.uLayoutXML == null) {\n                    throw new PortalException(\"UserLayoutManager::UserLayoutManager() : unable to retreive userLayout for user=\\\"\" +m_person.getID()+ \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\");\n                } else {\n                    // modify the entire profile to be unremovable and immutable\n                    // mark all of the folders\n                    NodeList folderList=newState.uLayoutXML.getElementsByTagName(\"folder\");\n                    for(int i=0;i<folderList.getLength();i++) {\n                        Element e=(Element)folderList.item(i);\n                        e.setAttribute(\"immutable\",\"true\");\n                        e.setAttribute(\"unremovable\",\"true\");                        \n                    }\n                    // mark all of the channels\n                    NodeList channelList=newState.uLayoutXML.getElementsByTagName(\"channel\");\n                    for(int i=0;i<channelList.getLength();i++) {\n                        Element e=(Element)channelList.item(i);\n                        e.setAttribute(\"immutable\",\"true\");\n                        e.setAttribute(\"unremovable\",\"true\");                        \n                    }\n                }\n\n                // see if the user preferences for this profile are cached\n                UserPreferences cleanUP;\n                if(upl.isSystemProfile()) {\n                    cleanUP=(UserPreferences)sp_cleanUPs.get(new Integer(upl.getProfileId()));\n                } else {\n                    cleanUP=(UserPreferences)up_cleanUPs.get(new Integer(upl.getProfileId()));\n                }\n                if(cleanUP==null) {\n                    try {\n                        cleanUP=ulsdb.getUserPreferences(m_person, upl);\n                        if(cleanUP!=null) {\n                            if(upl.isSystemProfile()) {\n                                sp_cleanUPs.put(new Integer(upl.getProfileId()),cleanUP);\n                            } else {\n                                up_cleanUPs.put(new Integer(upl.getProfileId()),cleanUP);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LogService.instance().log(LogService.ERROR,\"GuestUserLayoutManager::registerSession() : unable to find UP for a profile \\\"\"+upl.getProfileName()+\"\\\"\");\n                        cleanUP=new UserPreferences(upl);\n                    }\n                }\n\n                if(cleanUP!=null) {\n                    newState.complete_up=new UserPreferences(cleanUP);\n                } else {\n                    LogService.instance().log(LogService.ERROR,\"GuestUserLayoutManager::registerSession() : unable to find UP for a profile \\\"\"+upl.getProfileName()+\"\\\"\");\n                    newState.complete_up=new UserPreferences(upl);\n                }\n\n                // Initialize the JNDI context for this user\n                JNDIManager.initializeSessionContext(req.getSession(),Integer.toString(m_person.getID()),Integer.toString(upl.getLayoutId()),newState.uLayoutXML);\n            } else {\n                // there is no user-defined mapping for this particular browser.\n                // user should be redirected to a browser-registration page.\n                newState.unmapped_user_agent = true;\n                throw new PortalException(\"GuestUserLayoutManager::registerSession() : unable to find a profile for user \\\"\" + m_person.getID() + \"\\\" and userAgent=\\\"\" + userAgent + \"\\\".\");\n            }\n        } catch (PortalException pe) {\n            throw pe;\n        } catch (Throwable t) {\n            LogService.instance().log(LogService.ERROR, t);\n        }\n\n        stateTable.put(req.getSession(false).getId(),newState);\n    }","commit_id":"b8796ad6fc34eae0ea8d5dfb71079dfa9216961b","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setNewUserLayoutAndUserPreferences (Document newLayout, UserPreferences newPreferences, boolean channelsAdded) throws PortalException {\n      try {\n        if (newPreferences != null) {\n            ulsdb.putUserPreferences(m_person, newPreferences);\n            complete_up=newPreferences;\n        }\n        synchronized(layout_write_lock) {\n            if (newLayout != null) {\n                uLayoutXML = newLayout;\n                layout_write_lock.setValue(true);\n                    ulsdb.setUserLayout(m_person, complete_up.getProfile().getProfileId(), uLayoutXML, channelsAdded);\n            }\n        }\n      } catch (Exception e) {\n        LogService.instance().log(LogService.ERROR, e);\n        throw  new GeneralRenderingException(e.getMessage());\n      }\n\n    }","id":40306,"modified_method":"public void setNewUserLayoutAndUserPreferences (Document newLayout, UserPreferences newPreferences, boolean channelsAdded) throws PortalException {\n      try {\n        if (newPreferences != null) {\n            ulsdb.putUserPreferences(m_person, newPreferences);\n            complete_up=newPreferences;\n        }\n        synchronized(layout_write_lock) {\n            if (newLayout != null) {\n                uLayoutXML = newLayout;\n                layout_write_lock.setValue(true);\n                    ulsdb.setUserLayout(m_person, complete_up.getProfile(), uLayoutXML, channelsAdded);\n            }\n        }\n      } catch (Exception e) {\n        LogService.instance().log(LogService.ERROR, e);\n        throw  new GeneralRenderingException(e.getMessage());\n      }\n\n    }","commit_id":"b8796ad6fc34eae0ea8d5dfb71079dfa9216961b","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Constructor does the following\n     *  1. Read layout.properties\n     *  2. read userLayout from the database\n     *  @param the servlet request object\n     *  @param person object\n     */\n    public UserLayoutManager (HttpServletRequest req, IPerson person) throws PortalException {\n        uLayoutXML = null;\n        try {\n            m_person = person;\n            // load user preferences\n            // Should obtain implementation in a different way!!\n            ulsdb = UserLayoutStoreFactory.getUserLayoutStoreImpl();\n            // determine user profile\n            String userAgent = req.getHeader(\"User-Agent\");\n            UserProfile upl = ulsdb.getUserProfile(m_person, userAgent);\n            if (upl == null) {\n                upl = ulsdb.getSystemProfile(userAgent);\n            }\n            if(upl==null) {\n                // try guessing the profile through pattern matching\n\n                if(uaMatcher==null) {\n                    // init user agent matcher\n                    URL url = null;\n                    try {\n                        url = this.getClass().getResource(\"/properties/browser.mappings\");\n                        if (url != null) {\n                            uaMatcher = new PropsMatcher(url.openStream());\n                        }\n                    } catch (IOException ioe) {\n                        LogService.instance().log(LogService.ERROR, \"UserLayoutManager::UserLayoutManager() : Exception occurred while loading browser mapping file: \" + url + \". \" + ioe);\n                    }\n                }\n\n                if(uaMatcher!=null) {\n                    // try matching\n                    String profileId=uaMatcher.match(userAgent);\n                    if(profileId!=null) {\n                        // user agent has been matched\n\n                        upl=ulsdb.getSystemProfileById(Integer.parseInt(profileId));\n                    }\n                }\n\n            }\n\n            if (upl != null) {\n                // read uLayoutXML\n                uLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(m_person, upl.getProfileId());\n                if (uLayoutXML == null) {\n                    throw new PortalException(\"UserLayoutManager::UserLayoutManager() : unable to retreive userLayout for user=\\\"\" + m_person.getID() + \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\");\n                }\n                try {\n                    complete_up=ulsdb.getUserPreferences(m_person, upl);\n                } catch (Exception e) {\n                    LogService.instance().log(LogService.ERROR, \"UserLayoutManager(): caught an exception trying to retreive user preferences for user=\\\"\" + m_person.getID() + \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\", e);\n                    complete_up=new UserPreferences(upl);\n                }\n\n                try {\n                    // Initialize the JNDI context for this user\n                    JNDIManager.initializeSessionContext(req.getSession(),Integer.toString(m_person.getID()),Integer.toString(upl.getLayoutId()),uLayoutXML);\n                } catch(InternalPortalException ipe) {\n                  LogService.instance().log(LogService.ERROR, \"UserLayoutManager(): Could not properly initialize user context\", ipe);\n                }\n                // set dirty flag on the layout\n                layout_write_lock.setValue(true);\n            } else {\n                // there is no user-defined mapping for this particular browser.\n                // user should be redirected to a browser-registration page.\n                unmapped_user_agent = true;\n                LogService.instance().log(LogService.DEBUG, \"UserLayoutManager::UserLayoutManager() : unable to find a profile for user \\\"\" + m_person.getID()+\"\\\" and userAgent=\\\"\"+ userAgent + \"\\\".\");\n            }\n        } catch (PortalException pe) {\n            throw pe;\n        } catch (Exception e) {\n            LogService.instance().log(LogService.ERROR, e);\n        }\n    }","id":40307,"modified_method":"/**\n     * Constructor does the following\n     *  1. Read layout.properties\n     *  2. read userLayout from the database\n     *  @param the servlet request object\n     *  @param person object\n     */\n    public UserLayoutManager (HttpServletRequest req, IPerson person) throws PortalException {\n        uLayoutXML = null;\n        try {\n            m_person = person;\n            // load user preferences\n            // Should obtain implementation in a different way!!\n            ulsdb = UserLayoutStoreFactory.getUserLayoutStoreImpl();\n            // determine user profile\n            String userAgent = req.getHeader(\"User-Agent\");\n            UserProfile upl = ulsdb.getUserProfile(m_person, userAgent);\n            if (upl == null) {\n                upl = ulsdb.getSystemProfile(userAgent);\n            }\n            if(upl==null) {\n                // try guessing the profile through pattern matching\n\n                if(uaMatcher==null) {\n                    // init user agent matcher\n                    URL url = null;\n                    try {\n                        url = this.getClass().getResource(\"/properties/browser.mappings\");\n                        if (url != null) {\n                            uaMatcher = new PropsMatcher(url.openStream());\n                        }\n                    } catch (IOException ioe) {\n                        LogService.instance().log(LogService.ERROR, \"UserLayoutManager::UserLayoutManager() : Exception occurred while loading browser mapping file: \" + url + \". \" + ioe);\n                    }\n                }\n\n                if(uaMatcher!=null) {\n                    // try matching\n                    String profileId=uaMatcher.match(userAgent);\n                    if(profileId!=null) {\n                        // user agent has been matched\n\n                        upl=ulsdb.getSystemProfileById(Integer.parseInt(profileId));\n                    }\n                }\n\n            }\n\n            if (upl != null) {\n                // read uLayoutXML\n                uLayoutXML = UserLayoutStoreFactory.getUserLayoutStoreImpl().getUserLayout(m_person, upl);\n                if (uLayoutXML == null) {\n                    throw new PortalException(\"UserLayoutManager::UserLayoutManager() : unable to retreive userLayout for user=\\\"\" + m_person.getID() + \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\");\n                }\n                try {\n                    complete_up=ulsdb.getUserPreferences(m_person, upl);\n                } catch (Exception e) {\n                    LogService.instance().log(LogService.ERROR, \"UserLayoutManager(): caught an exception trying to retreive user preferences for user=\\\"\" + m_person.getID() + \"\\\", profile=\\\"\" + upl.getProfileName() + \"\\\".\", e);\n                    complete_up=new UserPreferences(upl);\n                }\n\n                try {\n                    // Initialize the JNDI context for this user\n                    JNDIManager.initializeSessionContext(req.getSession(),Integer.toString(m_person.getID()),Integer.toString(upl.getLayoutId()),uLayoutXML);\n                } catch(InternalPortalException ipe) {\n                  LogService.instance().log(LogService.ERROR, \"UserLayoutManager(): Could not properly initialize user context\", ipe);\n                }\n                // set dirty flag on the layout\n                layout_write_lock.setValue(true);\n            } else {\n                // there is no user-defined mapping for this particular browser.\n                // user should be redirected to a browser-registration page.\n                unmapped_user_agent = true;\n                LogService.instance().log(LogService.DEBUG, \"UserLayoutManager::UserLayoutManager() : unable to find a profile for user \\\"\" + m_person.getID()+\"\\\" and userAgent=\\\"\"+ userAgent + \"\\\".\");\n            }\n        } catch (PortalException pe) {\n            throw pe;\n        } catch (Exception e) {\n            LogService.instance().log(LogService.ERROR, e);\n        }\n    }","commit_id":"b8796ad6fc34eae0ea8d5dfb71079dfa9216961b","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean removeChannel (String channelId) throws PortalException {\n        // warning .. the channel should also be removed from uLayoutXML\n        Element channel = uLayoutXML.getElementById(channelId);\n        if (channel != null) {\n            boolean rval=true;\n            synchronized(layout_write_lock) {\n                if(!this.deleteNode(channel)) {\n                    // unable to remove channel due to unremovable/immutable restrictionsn\n                    LogService.instance().log(LogService.INFO,\"UserLayoutManager::removeChannlel() : unable to remove a channel \\\"\"+channelId+\"\\\"\");\n                    rval=false;\n                } else {\n                    layout_write_lock.setValue(true);\n                    // channel has been removed from the userLayoutXML .. persist the layout ?\n                    // NOTE: this shouldn't be done every time a channel is removed. A separate portal event should initiate save\n                    // (or, alternatively, an incremental update should be done on the UserLayoutStore())\n                    try {\n                        /*\n                          The following patch has been kindly contributed by Neil Blake <nd_blake@NICKEL.LAURENTIAN.CA>.\n                        */\n                        ulsdb.setUserLayout(m_person, complete_up.getProfile().getProfileId(), uLayoutXML, false);\n                        /* end of patch */\n                    } catch (Exception e) {\n                        LogService.instance().log(LogService.ERROR,\"UserLayoutManager::removeChannle() : database operation resulted in an exception \"+e);\n                        throw new GeneralRenderingException(\"Unable to save layout changes.\");\n                    }\n                    //\t    LogService.instance().log(LogService.INFO,\"UserLayoutManager::removeChannlel() : removed a channel \\\"\"+channelId+\"\\\"\");\n                }\n            }\n            return rval;\n        } else {\n            LogService.instance().log(LogService.ERROR, \"UserLayoutManager::removeChannel() : unable to find a channel with Id=\" + channelId);\n            return false;\n        }\n    }","id":40308,"modified_method":"public boolean removeChannel (String channelId) throws PortalException {\n        // warning .. the channel should also be removed from uLayoutXML\n        Element channel = uLayoutXML.getElementById(channelId);\n        if (channel != null) {\n            boolean rval=true;\n            synchronized(layout_write_lock) {\n                if(!this.deleteNode(channel)) {\n                    // unable to remove channel due to unremovable/immutable restrictionsn\n                    LogService.instance().log(LogService.INFO,\"UserLayoutManager::removeChannlel() : unable to remove a channel \\\"\"+channelId+\"\\\"\");\n                    rval=false;\n                } else {\n                    layout_write_lock.setValue(true);\n                    // channel has been removed from the userLayoutXML .. persist the layout ?\n                    // NOTE: this shouldn't be done every time a channel is removed. A separate portal event should initiate save\n                    // (or, alternatively, an incremental update should be done on the UserLayoutStore())\n                    try {\n                        /*\n                          The following patch has been kindly contributed by Neil Blake <nd_blake@NICKEL.LAURENTIAN.CA>.\n                        */\n                        ulsdb.setUserLayout(m_person, complete_up.getProfile(), uLayoutXML, false);\n                        /* end of patch */\n                    } catch (Exception e) {\n                        LogService.instance().log(LogService.ERROR,\"UserLayoutManager::removeChannle() : database operation resulted in an exception \"+e);\n                        throw new GeneralRenderingException(\"Unable to save layout changes.\");\n                    }\n                    //\t    LogService.instance().log(LogService.INFO,\"UserLayoutManager::removeChannlel() : removed a channel \\\"\"+channelId+\"\\\"\");\n                }\n            }\n            return rval;\n        } else {\n            LogService.instance().log(LogService.ERROR, \"UserLayoutManager::removeChannel() : unable to find a channel with Id=\" + channelId);\n            return false;\n        }\n    }","commit_id":"b8796ad6fc34eae0ea8d5dfb71079dfa9216961b","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * Set all columns on a given tab to have the same width.\n\t * \n\t * @param per\n\t * @param upm\n\t * @param ulm\n\t * @param tabId\n\t * @throws PortalException\n\t */\n\tprivate void equalizeColumnWidths(IPerson per, UserPreferencesManager upm,\n\t\t\tIUserLayoutManager ulm, String tabId) throws PortalException {\n\n\t\t// get the total number of columns\n\t\tEnumeration columns = ulm.getChildIds(tabId);\n\t\tint count = 0;\n\t\twhile (columns.hasMoreElements()) {\n\t\t\tcolumns.nextElement();\n\t\t\tcount++;\n\t\t}\n\n\t\t// set the new width for each column to be equal\n\t\tint width = 100 / count;\n\t\tString widthString = width + \"%\";\n\n\t\tStructureStylesheetUserPreferences ssup = upm.getUserPreferences()\n\t\t\t\t.getStructureStylesheetUserPreferences();\n\t\tcolumns = ulm.getChildIds(tabId);\n\t\twhile (columns.hasMoreElements()) {\n\t\t\tString columnId = (String) columns.nextElement();\n\t\t\tssup.setFolderAttributeValue(columnId, \"width\", widthString);\n\t\t\tElement folder = ulm.getUserLayoutDOM().getElementById(columnId);\n\t\t\ttry {\n\t\t\t\t// This sets the column attribute in memory but doesn't persist it.  Comment says saves changes \"prior to persisting\"\n\t\t\t\tUserPrefsHandler.setUserPreference(folder, \"width\", per);\n\t\t\t\t// This is a brute force save of the new attributes.  It requires access to the layout store. -SAB\n\t\t\t\tulStore\n\t\t\t\t\t\t.setStructureStylesheetUserPreferences(per, upm\n\t\t\t\t\t\t\t\t.getUserPreferences().getProfile()\n\t\t\t\t\t\t\t\t.getProfileId(), ssup);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"Error saving new column widths\", e);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t}","id":40309,"modified_method":"/**\n\t * Set all columns on a given tab to have the same width.\n\t * \n\t * @param per\n\t * @param upm\n\t * @param ulm\n\t * @param tabId\n\t * @throws PortalException\n\t */\n\tprivate void equalizeColumnWidths(IPerson per, UserPreferencesManager upm,\n\t\t\tIUserLayoutManager ulm, String tabId) throws PortalException {\n\n\t\t// get the total number of columns\n\t\tEnumeration columns = ulm.getChildIds(tabId);\n\t\tint count = 0;\n\t\twhile (columns.hasMoreElements()) {\n\t\t\tcolumns.nextElement();\n\t\t\tcount++;\n\t\t}\n\n\t\t// set the new width for each column to be equal\n\t\tint width = 100 / count;\n\t\tString widthString = width + \"%\";\n\n\t\tStructureStylesheetUserPreferences ssup = upm.getUserPreferences().getStructureStylesheetUserPreferences();\n        UserProfile currentProfile = upm.getUserPreferences().getProfile();\n        int profileID = currentProfile.getProfileId();\n        int structID = currentProfile.getStructureStylesheetId();\n\t\tcolumns = ulm.getChildIds(tabId);\n\t\twhile (columns.hasMoreElements()) {\n\t\t\tString columnId = (String) columns.nextElement();\n\t\t\tssup.setFolderAttributeValue(columnId, \"width\", widthString);\n\t\t\tElement folder = ulm.getUserLayoutDOM().getElementById(columnId);\n\t\t\ttry {\n\t\t\t\t// This sets the column attribute in memory but doesn't persist it.  Comment says saves changes \"prior to persisting\"\n\t\t\t\tUserPrefsHandler.setUserPreference(folder, \"width\", per);\n                \n\t\t\t\tString currentTab = ssup.getParameterValue( \"activeTab\" );\n                // get the active tab number from the store so that we can preserve it\n                String defaultTab = ulStore.getStructureStylesheetUserPreferences(per, profileID, structID)\n                                          .getParameterValue( \"activeTab\" );\n                // set the active tab to previously recorded value\n                ssup.putParameterValue( \"activeTab\", defaultTab );\n\t\t\t\t// This is a brute force save of the new attributes.  It requires access to the layout store. -SAB\n\t\t\t\tulStore.setStructureStylesheetUserPreferences(per, profileID, ssup);\n                // set active tab in current preferences back to \"current\" tab\n                ssup.putParameterValue( \"activeTab\", currentTab );\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"Error saving new column widths\", e);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t}","commit_id":"118320cb47dc74e4d2cffb5417892a51c1eca134","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * Move a tab left or right.\n\t * \n\t * @param per\n\t * @param upm\n\t * @param ulm\n\t * @param request\n\t * @param response\n\t * @throws PortalException\n\t * @throws IOException\n\t */\n\tprivate void moveTab(IPerson per, UserPreferencesManager upm,\n\t\t\tIUserLayoutManager ulm, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws PortalException, IOException {\n\n\t\t// gather the parameters we need to move a channel\n\t\tString destinationId = request.getParameter(\"elementID\");\n\t\tString sourceId = request.getParameter(\"sourceID\");\n\t\tString method = request.getParameter(\"method\");\n\t\tString tabPosition = request.getParameter(\"tabPosition\");\n\n\t\t// If we're moving this element before another one, we need\n\t\t// to know what the target is. If there's no target, just\n\t\t// assume we're moving it to the very end of the list.\n\t\tString siblingId = null;\n\t\tif (method.equals(\"insertBefore\"))\n\t\t\tsiblingId = destinationId;\n\n\t\t// move the node as requested and save the layout\n\t\tulm.moveNode(sourceId, ulm.getParentId(destinationId), siblingId);\n\n\t\tStructureStylesheetUserPreferences ssup = upm.getUserPreferences()\n\t\t\t\t.getStructureStylesheetUserPreferences();\n\t\tssup.putParameterValue(\"activeTab\", \"1\");\n\n\t\ttry {\n\t\t\t// This is a brute force save of the new attributes.  It requires access to the layout store. -SAB\n\t\t\tulStore.setStructureStylesheetUserPreferences(per, upm\n\t\t\t\t\t.getUserPreferences().getProfile().getProfileId(), ssup);\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e);\n\t\t}\n\n\t\tssup.putParameterValue(\"activeTab\", tabPosition);\n\n\t\tulm.saveUserLayout();\n\n\t\tprintSuccess(response, \"Saved new tab position\", null);\n\n\t}","id":40310,"modified_method":"/**\n\t * Move a tab left or right.\n\t * \n\t * @param per\n\t * @param upm\n\t * @param ulm\n\t * @param request\n\t * @param response\n\t * @throws PortalException\n\t * @throws IOException\n\t */\n\tprivate void moveTab(IPerson per, UserPreferencesManager upm,\n\t\t\tIUserLayoutManager ulm, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws PortalException, IOException {\n\n\t\t// gather the parameters we need to move a channel\n\t\tString destinationId = request.getParameter(\"elementID\");\n\t\tString sourceId = request.getParameter(\"sourceID\");\n\t\tString method = request.getParameter(\"method\");\n\t\tString tabPosition = request.getParameter(\"tabPosition\");\n\n\t\t// If we're moving this element before another one, we need\n\t\t// to know what the target is. If there's no target, just\n\t\t// assume we're moving it to the very end of the list.\n\t\tString siblingId = null;\n\t\tif (method.equals(\"insertBefore\"))\n\t\t\tsiblingId = destinationId;\n\n\t\t// move the node as requested and save the layout\n\t\tulm.moveNode(sourceId, ulm.getParentId(destinationId), siblingId);\n\n\t\tStructureStylesheetUserPreferences ssup = upm.getUserPreferences()\n\t\t\t\t.getStructureStylesheetUserPreferences();\n\n\t\ttry {\n            String currentTab = ssup.getParameterValue(\"activeTab\");\n            UserProfile currentProfile = upm.getUserPreferences().getProfile();\n            int profileID = currentProfile.getProfileId();\n            int structID = currentProfile.getStructureStylesheetId();\n            // get the active tab number from the store so that we can preserve it\n            String defaultTab = ulStore.getStructureStylesheetUserPreferences(per, profileID, structID).getParameterValue(\"activeTab\");\n            // set the active tab to previously recorded value\n            if (defaultTab.equals(currentTab)) {\n                ssup.putParameterValue(\"activeTab\", tabPosition);\n            }\n            else {\n                ssup.putParameterValue(\"activeTab\", defaultTab);\n            }\n            // This is a brute force save of the new attributes.  It requires access to the layout store. -SAB\n            ulStore.setStructureStylesheetUserPreferences(per, profileID, ssup);\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e);\n\t\t}\n\n        // reset the active tab for viewing (not default)\n\t\tssup.putParameterValue(\"activeTab\", tabPosition);\n\n\t\tulm.saveUserLayout();\n\n\t\tprintSuccess(response, \"Saved new tab position\", null);\n\n\t}","commit_id":"118320cb47dc74e4d2cffb5417892a51c1eca134","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n  public CloseableIterator<String> readFileSource(int fileRef) {\n    File file = delegate.readFileSource(fileRef);\n    if (file == null) {\n      throw new IllegalStateException(\"Unable to find source for file #\" + fileRef + \". File does not exist: \" + file);\n    }\n\n    try {\n      final LineIterator lineIterator = IOUtils.lineIterator(FileUtils.openInputStream(file), StandardCharsets.UTF_8);\n      return new CloseableIterator<String>() {\n        @Override\n        public boolean hasNext() {\n          return lineIterator.hasNext();\n        }\n\n        @Override\n        public String next() {\n          return lineIterator.next();\n        }\n\n        @Override\n        protected String doNext() {\n          // never called anyway\n          throw new NoSuchElementException(\"Empty closeable Iterator has no element\");\n        }\n\n        @Override\n        protected void doClose() throws Exception {\n          lineIterator.close();\n        }\n      };\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Fail to traverse file: \" + file, e);\n    }\n  }","id":40311,"modified_method":"@Override\n  public CloseableIterator<String> readFileSource(int fileRef) {\n    File file = delegate.readFileSource(fileRef);\n    if (file == null) {\n      throw new IllegalStateException(\"Unable to find source for file #\" + fileRef);\n    }\n\n    try {\n      return new CloseableLineIterator(IOUtils.lineIterator(FileUtils.openInputStream(file), StandardCharsets.UTF_8));\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Fail to traverse file: \" + file, e);\n    }\n  }","commit_id":"699fab7d1d406e9f29b47f6662cc9472f2e59e2e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    public void fileIteratorTest() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            BurnOnCloseFileIterator.wrap(FileUtils.lineIterator(f));\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(f.exists());\n    }","id":40312,"modified_method":"@Test\n    public void fileIteratorTest() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            BurnOnCloseFileIterator.wrap(FileUtils.lineIterator(f, UTF_8.toString()));\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(f.exists());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void fileIteratorLineBreakTest() throws IOException {\n        Set<String> added = newHashSet(getLineBreakStrings());\n        File f = assertWrite(added.iterator(), true, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            new BurnOnCloseFileIterator<String>(FileUtils.lineIterator(f),\n                new Function<String, String>() {\n                    @Nullable @Override public String apply(@Nullable String input) {\n                        return unescapeLineBreaks(input);\n                    }\n                });\n\n        assertEquals(added, Sets.newHashSet(iterator));\n    }","id":40313,"modified_method":"@Test\n    public void fileIteratorLineBreakTest() throws IOException {\n        Set<String> added = newHashSet(getLineBreakStrings());\n        File f = assertWrite(added.iterator(), true, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            new BurnOnCloseFileIterator<String>(FileUtils.lineIterator(f, UTF_8.toString()), f,\n                new Function<String, String>() {\n                    @Nullable @Override public String apply(@Nullable String input) {\n                        return unescapeLineBreaks(input);\n                    }\n                });\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(!f.exists());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void sortCustomComparatorTest() throws IOException {\n        List<String> list = getLineBreakStrings();\n        File f = assertWrite(list.iterator(), true, list.size());\n\n        sort(f, lineBreakAwareComparator(lexComparator));\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(unescapeLineBreaks(line));\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","id":40314,"modified_method":"@Test\n    public void sortCustomComparatorTest() throws IOException {\n        List<String> list = getLineBreakStrings();\n        File f = assertWrite(list.iterator(), true, list.size());\n\n        sort(f, lineBreakAwareComparator(lexComparator));\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(unescapeLineBreaks(line));\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"static InputStream randomStream(int seed, int size) {\n        Random r = new Random(seed);\n        byte[] data = new byte[size];\n        r.nextBytes(data);\n        return new ByteArrayInputStream(data);\n    }","id":40315,"modified_method":"private static InputStream randomStream(int seed, int size) {\n        Random r = new Random(seed);\n        byte[] data = new byte[size];\n        r.nextBytes(data);\n        return new ByteArrayInputStream(data);\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void sortTest() throws IOException {\n        List<String> list = newArrayList(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(list.iterator(), false, list.size());\n\n        sort(f);\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(line);\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","id":40316,"modified_method":"@Test\n    public void sortTest() throws IOException {\n        List<String> list = newArrayList(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(list.iterator(), false, list.size());\n\n        sort(f);\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(line);\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void fileIteratorRandomizedTest() throws Exception {\n        Set<String> added = newHashSet();\n        for (int i = 0; i < 100; i++) {\n            added.add(getRandomTestString());\n        }\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            BurnOnCloseFileIterator.wrap(FileUtils.lineIterator(f, UTF_8.toString()), f);\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(!f.exists());\n    }","id":40317,"modified_method":"@Test\n    public void fileIteratorRandomizedTest() throws Exception {\n        Set<String> added = newHashSet();\n        for (int i = 0; i < 100; i++) {\n            added.add(getRandomTestString());\n        }\n        File f = assertWrite(added.iterator(), true, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            new BurnOnCloseFileIterator<String>(FileUtils.lineIterator(f, UTF_8.toString()),\n                f,\n                new Function<String, String>() {\n                    @Nullable\n                    @Override\n                    public String apply(@Nullable String input) {\n                        return unescapeLineBreaks(input);\n                    }\n                });\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(!f.exists());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void fileIteratorBurnTest() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            BurnOnCloseFileIterator.wrap(FileUtils.lineIterator(f), f);\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(!f.exists());\n    }","id":40318,"modified_method":"@Test\n    public void fileIteratorBurnTest() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        BurnOnCloseFileIterator iterator =\n            BurnOnCloseFileIterator.wrap(FileUtils.lineIterator(f, UTF_8.toString()), f);\n\n        assertEquals(added, Sets.newHashSet(iterator));\n        assertTrue(!f.exists());\n    }","commit_id":"32dc67b741739b720a4c0cf3ec9c917885ba9086","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      try {\n        myVcs.createWCClient().doSetProperty(myFile, getSelectedPropertyName(), null, true, false, null);\n      } catch (SVNException error) {\n        // show error message.\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus();\n    }","id":40319,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      try {\n        myVcs.createWCClient().doSetProperty(myFile, getSelectedPropertyName(), null, true, false, null);\n      } catch (SVNException error) {\n        // show error message.\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus(false);\n    }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SVNWCClient wcClient = new SVNWCClient(null, null);\n      SVNPropertyData propValue = null;\n      try {\n        propValue = wcClient.doGetProperty(myFile, SVNProperty.KEYWORDS, SVNRevision.UNDEFINED, SVNRevision.WORKING, false);\n      } catch (SVNException e1) {\n        // show error message\n      }\n      SetKeywordsDialog dialog = new SetKeywordsDialog(project, propValue != null ? propValue.getValue() : null);\n      dialog.show();\n      if (dialog.isOK()) {\n        String value = dialog.getKeywords();\n        try {\n          wcClient.doSetProperty(myFile, SVNProperty.KEYWORDS, value, false, false, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus();\n    }","id":40320,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SVNWCClient wcClient = new SVNWCClient(null, null);\n      SVNPropertyData propValue = null;\n      try {\n        propValue = wcClient.doGetProperty(myFile, SVNProperty.KEYWORDS, SVNRevision.UNDEFINED, SVNRevision.WORKING, false);\n      } catch (SVNException e1) {\n        // show error message\n      }\n      SetKeywordsDialog dialog = new SetKeywordsDialog(project, propValue != null ? propValue.getValue() : null);\n      dialog.show();\n      if (dialog.isOK()) {\n        String value = dialog.getKeywords();\n        try {\n          wcClient.doSetProperty(myFile, SVNProperty.KEYWORDS, value, false, false, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus(false);\n    }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SetPropertyDialog dialog = new SetPropertyDialog(project, new File[] {myFile}, getSelectedPropertyName(),\n              myFile.isDirectory());\n      dialog.show();\n      if (dialog.isOK()) {\n        String name = dialog.getPropertyName();\n        String value = dialog.getPropertyValue();\n        boolean recursive = dialog.isRecursive();\n        SVNWCClient wcClient = new SVNWCClient(null, null);\n        try {\n          wcClient.doSetProperty(myFile, name, value, false, recursive, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus();\n    }","id":40321,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SetPropertyDialog dialog = new SetPropertyDialog(project, new File[] {myFile}, getSelectedPropertyName(), myFile.isDirectory());\n      dialog.show();\n      boolean recursive = false;\n      if (dialog.isOK()) {\n        String name = dialog.getPropertyName();\n        String value = dialog.getPropertyValue();\n        recursive = dialog.isRecursive();\n        SVNWCClient wcClient = new SVNWCClient(null, null);\n        try {\n          wcClient.doSetProperty(myFile, name, value, false, recursive, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus(recursive);\n    }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SetPropertyDialog dialog = new SetPropertyDialog(project, new File[] {myFile}, null,\n              myFile.isDirectory());\n      dialog.show();\n      if (dialog.isOK()) {\n        String name = dialog.getPropertyName();\n        String value = dialog.getPropertyValue();\n        boolean recursive = dialog.isRecursive();\n        SVNWCClient wcClient = new SVNWCClient(null, null);\n        try {\n          wcClient.doSetProperty(myFile, name, value, false, recursive, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus();\n    }","id":40322,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      Project project = (Project) e.getDataContext().getData(DataConstants.PROJECT);\n      SetPropertyDialog dialog = new SetPropertyDialog(project, new File[] {myFile}, null,\n              myFile.isDirectory());\n      dialog.show();\n      boolean recursive = false;\n      if (dialog.isOK()) {\n        String name = dialog.getPropertyName();\n        String value = dialog.getPropertyValue();\n        recursive = dialog.isRecursive();\n        SVNWCClient wcClient = new SVNWCClient(null, null);\n        try {\n          wcClient.doSetProperty(myFile, name, value, false, recursive, null);\n        }\n        catch (SVNException err) {\n          // show error message\n        }\n      }\n      setFile(myVcs, myFile);\n      updateFileStatus(recursive);\n    }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      setFile(myVcs, myFile);\n      updateFileStatus();\n    }","id":40323,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      setFile(myVcs, myFile);\n      updateFileStatus(false);\n    }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateFileStatus() {\n    if (myFile != null && myVcs != null) {\n      String url = \"file://\" + myFile.getPath().replace(File.separatorChar, '/');\n      VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n      VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(file);\n    }\n  }","id":40324,"modified_method":"private void updateFileStatus(boolean recursive) {\n    if (myFile != null && myVcs != null) {\n      String url = \"file://\" + myFile.getPath().replace(File.separatorChar, '/');\n      VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n      if (file != null) {\n        if (recursive && file.isDirectory()) {\n          VcsDirtyScopeManager.getInstance(myVcs.getProject()).dirDirtyRecursively(file, true);\n        } else {\n          VcsDirtyScopeManager.getInstance(myVcs.getProject()).fileDirty(file);\n        }\n      }\n    }\n  }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void batchPerform(Project project, SvnVcs activeVcs, VirtualFile[] file, DataContext context, AbstractVcsHelper helper)\n    throws VcsException {\n    File[] ioFiles = new File[file.length];\n    for (int i = 0; i < ioFiles.length; i++) {\n      ioFiles[i] = new File(file[i].getPath());\n    }\n\n    SetPropertyDialog dialog = new SetPropertyDialog(project, ioFiles, null, true);\n    dialog.show();\n\n    if (dialog.isOK()) {\n      String name = dialog.getPropertyName();\n      String value = dialog.getPropertyValue();\n      boolean recursive = dialog.isRecursive();\n\n      SVNWCClient wcClient = new SVNWCClient(null, null);\n      for (int i = 0; i < ioFiles.length; i++) {\n        File ioFile = ioFiles[i];\n        try {\n          wcClient.doSetProperty(ioFile, name, value, false, recursive, null);\n        }\n        catch (SVNException e) {\n          throw new VcsException(e);\n        }\n      }\n    }\n  }","id":40325,"modified_method":"protected void batchPerform(Project project, SvnVcs activeVcs, VirtualFile[] file, DataContext context, AbstractVcsHelper helper)\n    throws VcsException {\n    File[] ioFiles = new File[file.length];\n    for (int i = 0; i < ioFiles.length; i++) {\n      ioFiles[i] = new File(file[i].getPath());\n    }\n\n    SetPropertyDialog dialog = new SetPropertyDialog(project, ioFiles, null, true);\n    dialog.show();\n\n    if (dialog.isOK()) {\n      String name = dialog.getPropertyName();\n      String value = dialog.getPropertyValue();\n      boolean recursive = dialog.isRecursive();\n\n      SVNWCClient wcClient = new SVNWCClient(null, null);\n      for (int i = 0; i < ioFiles.length; i++) {\n        File ioFile = ioFiles[i];\n        try {\n          wcClient.doSetProperty(ioFile, name, value, false, recursive, null);\n        }\n        catch (SVNException e) {\n          throw new VcsException(e);\n        }\n      }\n      for(int i = 0; i < file.length; i++) {\n        if (recursive && file[i].isDirectory()) {\n          VcsDirtyScopeManager.getInstance(project).dirDirtyRecursively(file[i], true);\n        } else {\n          VcsDirtyScopeManager.getInstance(project).fileDirty(file[i]);\n        }\n      }\n    }\n  }","commit_id":"f5c47429a33bec9e3340a1660d7f942cb235bc93","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void refreshFileStatusFromDocument(final VirtualFile file, final Document doc) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"refreshFileStatusFromDocument: file.getModificationStamp()=\" + file.getModificationStamp() + \", document.getModificationStamp()=\" + doc.getModificationStamp());\n    }\n    FileStatus cachedStatus = getCachedStatus(file);\n    if (cachedStatus == FileStatus.NOT_CHANGED || file.getModificationStamp() == doc.getModificationStamp()) {\n      fileStatusChanged(file);\n      final AbstractVcs vcs = myVcsManager.getVcsFor(file);\n      if (vcs == null) return;\n      ChangeProvider cp = vcs.getChangeProvider();\n      if (cp == null || !cp.isModifiedDocumentTrackingRequired()) return;\n      VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);\n    }\n  }","id":40326,"modified_method":"public void refreshFileStatusFromDocument(final VirtualFile file, final Document doc) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"refreshFileStatusFromDocument: file.getModificationStamp()=\" + file.getModificationStamp() + \", document.getModificationStamp()=\" + doc.getModificationStamp());\n    }\n    FileStatus cachedStatus = getCachedStatus(file);\n    if (cachedStatus == FileStatus.NOT_CHANGED || file.getModificationStamp() == doc.getModificationStamp()) {\n      final AbstractVcs vcs = myVcsManager.getVcsFor(file);\n      if (vcs == null) return;\n      if (cachedStatus == FileStatus.MODIFIED && file.getModificationStamp() == doc.getModificationStamp()) {\n        if (checkRollbackOnLastUndo(vcs, file)) return;\n      }\n      fileStatusChanged(file);\n      ChangeProvider cp = vcs.getChangeProvider();\n      if (cp != null && cp.isModifiedDocumentTrackingRequired()) {\n        VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);\n      }\n    }\n  }","commit_id":"046367cdece2c7a280997df72c368e0fa376bc05","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) {\n    if (status != null) {\n      FileStatus fStatus = SvnFileStatusProvider.convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath.getIOFile());\n      }\n    }\n  }","id":40327,"modified_method":"private void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) {\n    SvnFileStatusProvider.loadEntriesFile(filePath);\n    if (status != null) {\n      FileStatus fStatus = SvnFileStatusProvider.convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath.getIOFile());\n      }\n    }\n  }","commit_id":"902ac59386ad3203899a7c85bd103efcc5bcbc2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fireFileStatusesChanged(VirtualFile parent) {\n    VcsDirtyScopeManager.getInstance(myProject).fileDirty(parent);\n    /*\n    final FileStatusManager fileStatusManager = FileStatusManager.getInstance(myProject);\n    final VirtualFile[] children = parent.getChildren();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        for (int i = 0; i < children.length; i++) {\n          VirtualFile child = children[i];\n          fileStatusManager.fileStatusChanged(child);\n        }\n      }\n    }, ModalityState.NON_MMODAL);\n    */\n  }","id":40328,"modified_method":"private void fireFileStatusesChanged(VirtualFile parent) {\n    VcsDirtyScopeManager.getInstance(myProject).fileDirty(parent);\n    final VirtualFile[] children = parent.getChildren();\n    for(int i = 0; i < children.length; i++) {\n      VcsDirtyScopeManager.getInstance(myProject).fileDirty(children[i]);    \n    }\n    /*\n    final FileStatusManager fileStatusManager = FileStatusManager.getInstance(myProject);\n    final VirtualFile[] children = parent.getChildren();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        for (int i = 0; i < children.length; i++) {\n          VirtualFile child = children[i];\n          fileStatusManager.fileStatusChanged(child);\n        }\n      }\n    }, ModalityState.NON_MMODAL);\n    */\n  }","commit_id":"902ac59386ad3203899a7c85bd103efcc5bcbc2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Format numberFormatter() {\n        return new ERXNumberFormatter(formatter());\n    }","id":40329,"modified_method":"public Format numberFormatter() {\n        return ERXNumberFormatter.numberFormatterForPattern(formatter());\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected java.text.Format numberFormatter() {\n        if (_numberFormatter == null) {\n            _numberFormatter = ERXNumberFormatter.sharedInstance();\n            _numberFormatter.setPattern(formatter());\n        }\n        return (java.text.Format)_numberFormatter;\n    }","id":40330,"modified_method":"protected java.text.Format numberFormatter() {\n        if (_numberFormatter == null) {\n            _numberFormatter = ERXNumberFormatter.numberFormatterForPattern(formatter());\n        }\n        return (java.text.Format)_numberFormatter;\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXDividingNumberFormatter bytesToMegabytesFormatter() {\n        ERXDividingNumberFormatter d = new ERXDividingNumberFormatter();\n        d.setPattern(\"(1048576=)0.00\");\n        return d;\n    }","id":40331,"modified_method":"public NSNumberFormatter bytesToMegabytesFormatter() {\n    \treturn ERXNumberFormatter.numberFormatterForPattern(\"(/1048576=)0.00\");\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXMultiplyingNumberFormatter megabytesToBytesFormatter() {\n        ERXMultiplyingNumberFormatter d = new ERXMultiplyingNumberFormatter();\n        d.setPattern(\"(1048576=)0.00\");\n        return d;\n    }","id":40332,"modified_method":"public NSNumberFormatter megabytesToBytesFormatter() {\n    \treturn ERXNumberFormatter.numberFormatterForPattern(\"(*1048576=)0.00\");\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXMultiplyingNumberFormatter megabytesToKilobytesFormatter() {\n        ERXMultiplyingNumberFormatter d = new ERXMultiplyingNumberFormatter();\n        d.setPattern(\"(1024=)0.00\");\n        return d;\n    }","id":40333,"modified_method":"public NSNumberFormatter megabytesToKilobytesFormatter() {\n    \treturn ERXNumberFormatter.numberFormatterForPattern(\"(*1024=)0.00\");\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXDividingNumberFormatter bytesToKilobytesFormatter() {\n        ERXDividingNumberFormatter d = new ERXDividingNumberFormatter();\n        d.setPattern(\"(1024=)0.00\");\n        return d;\n    }","id":40334,"modified_method":"public NSNumberFormatter bytesToKilobytesFormatter() {\n    \treturn ERXNumberFormatter.numberFormatterForPattern(\"(/1024=)0.00\");\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the shared instance\n     * @return shared instance\n     */\n    public static ERXNumberFormatter sharedInstance() {\n        if (_sharedInstance == null)\n            _sharedInstance = new ERXNumberFormatter();\n        return _sharedInstance;\n    }","id":40335,"modified_method":"/**\n     * Returns the default shared instance\n     * @return shared instance\n     */\n    public static NSNumberFormatter sharedInstance() {\n         return numberFormatterForPattern(DefaultKey);\n    }","commit_id":"e6669a84d918997dc433ef9a18962bed5e7f56c0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String formatter() {\n\t\tif(_formatter == null) {\n\t\t\t_formatter = (String)valueForBinding(\"formatter\");\n\t\t\tif(_formatter == null || _formatter.length() == 0) {\n\t\t\t\t_formatter = \"MM/dd/yyyy\";\n\t\t\t}\n\t\t}\n\t\treturn _formatter;\n\t}","id":40336,"modified_method":"public String formatter() {\n\t\tif(_formatter == null) {\n\t\t\t_formatter = (String)valueForBinding(\"formatter\");\n\t\t\tif(_formatter == null || _formatter.length() == 0) {\n\t\t\t\t_formatter = ERXTimestampFormatter.DEFAULT_PATTERN;\n\t\t\t}\n \t\t}\n\t\treturn _formatter;\n\t}","commit_id":"aa7173a5d76ddc59d1e512c0ad62c95f4590e967","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String formatterStringForScript() {\n    \treturn ERXEditDateJavascript.formatterStringForScript(formatter());\n    }","id":40337,"modified_method":"public String formatterStringForScript() {\n    \treturn ERXEditDateJavascript.formatterStringForScript(localizedFormatString());\n    }","commit_id":"aa7173a5d76ddc59d1e512c0ad62c95f4590e967","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSTimestampFormatter dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = new NSTimestampFormatter(formatter());\n    \t}\n    \treturn _dateFormatter;\n    }","id":40338,"modified_method":"public Format dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = ERXLocalizer.currentLocalizer().localizedDateFormatForKey(formatter());\n            log.info(_dateFormatter);\n    \t}\n    \treturn _dateFormatter;\n    }","commit_id":"aa7173a5d76ddc59d1e512c0ad62c95f4590e967","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns a localized date formatter for the given key.\n\t * @param formatString\n\t * @return\n\t */\n\t\n    public Format localizedDateFormatForKey(String formatString) {\n    \tformatString = formatString == null ? \"%Y/%m/%d\" : formatString;\n\t\tFormat result = (Format)_dateFormatters.get(formatString);\n\t\tif(result == null) {\n\t\t\t// HACK ak\n\t\t\t// we need to sync on the localizer and hold our breath that no one else relies on Locale.getDefault()\n\t\t\t// at this time. All of this because the NSTimestampFormatter doesn't have a setLocale() method...\n\t\t\tsynchronized(ERXLocalizer.class) {\n\t\t\t\tLocale old = Locale.getDefault();\n\t\t\t\tLocale.setDefault(locale());\n\t\t\t\tNSTimestampFormatter formatter = new NSTimestampFormatter(formatString);\n\t\t\t\tresult = formatter;\n\t\t\t\t_dateFormatters.put(formatString, result);\n\t\t\t\tLocale.setDefault(old);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":40339,"modified_method":"/**\n\t * Returns a localized date formatter for the given key.\n\t * @param formatString\n\t * @return\n\t */\n\t\n    public Format localizedDateFormatForKey(String formatString) {\n        String localizedFormatString = localizedStringForKey(formatString);\n        formatString = formatString == null \n            ? ERXTimestampFormatter.DEFAULT_PATTERN \n            : localizedFormatString == null \n                ? formatString \n                : localizedFormatString;\n        Format result = (Format)_dateFormatters.get(formatString);\n\t\tif(result == null) {\n\t\t\t// HACK ak\n\t\t\t// we need to sync on the localizer and hold our breath that no one else relies on Locale.getDefault()\n\t\t\t// at this time. All of this because the NSTimestampFormatter doesn't have a setLocale() method...\n\t\t\tsynchronized(ERXLocalizer.class) {\n\t\t\t\tLocale old = Locale.getDefault();\n\t\t\t\tLocale.setDefault(locale());\n\t\t\t\tNSTimestampFormatter formatter = new NSTimestampFormatter(localizedFormatString);\n\t\t\t\tresult = formatter;\n\t\t\t\t_dateFormatters.put(formatString, result);\n\t\t\t\tLocale.setDefault(old);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"aa7173a5d76ddc59d1e512c0ad62c95f4590e967","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String formatter() {\n\t\tif(_formatter == null) {\n\t\t\t_formatter = (String)valueForBinding(\"formatter\");\n\t\t}\n\t\tif(_formatter == null || _formatter.length() == 0) {\n\t\t\t_formatter = \"%m/%d/%Y\";\n\t\t}\n\t\treturn _formatter;\n\t}","id":40340,"modified_method":"public String formatter() {\n\t\tif(_formatter == null) {\n\t\t\t_formatter = (String)valueForBinding(\"formatter\");\n\t\t}\n\t\tif(_formatter == null || _formatter.length() == 0) {\n\t\t\t_formatter = ERXTimestampFormatter.DEFAULT_PATTERN;\n\t\t}\n\t\treturn _formatter;\n\t}","commit_id":"e460f202521e1bd2f09e33fc6dec70784e3e8491","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected NSTimestampFormatter dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = new NSTimestampFormatter(formatter());\n    \t}\n    \treturn _dateFormatter;\n    }","id":40341,"modified_method":"protected NSTimestampFormatter dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = ERXTimestampFormatter.dateFormatterForPattern(formatter());\n    \t}\n    \treturn _dateFormatter;\n    }","commit_id":"e460f202521e1bd2f09e33fc6dec70784e3e8491","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Format dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = ERXLocalizer.currentLocalizer().localizedDateFormatForKey(formatter());\n            log.info(_dateFormatter);\n    \t}\n    \treturn _dateFormatter;\n    }","id":40342,"modified_method":"public Format dateFormatter() {\n    \tif(_dateFormatter == null) {\n    \t\t_dateFormatter = ERXTimestampFormatter.dateFormatterForPattern(formatter());\n    \t}\n    \treturn _dateFormatter;\n    }","commit_id":"e460f202521e1bd2f09e33fc6dec70784e3e8491","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String formatterStringForScript() {\n    \treturn ERXEditDateJavascript.formatterStringForScript(dateformat);\n    }","id":40343,"modified_method":"public String formatterStringForScript() {\n        String format = ERXLocalizer.currentLocalizer().localizedStringForKeyWithDefault(dateformat);\n        return ERXEditDateJavascript.formatterStringForScript(format);\n    }","commit_id":"e460f202521e1bd2f09e33fc6dec70784e3e8491","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void testSendTestData() throws Exception\n    {\n        final int numberOfMessages = 100;\n        MuleClient client = new MuleClient();\n\n        for (int sentPackets = 0; sentPackets < numberOfMessages; sentPackets++)\n        {\n            String msg = MESSAGE + sentPackets;\n            client.dispatch(\"serverEndpoint\", msg, null);\n        }\n\n        int broadcastMessages = numberOfMessages * 3; //3 components\n        Set receivedMessages = new HashSet(broadcastMessages);\n\n        int receivedPackets = 0;\n        for (; receivedPackets < broadcastMessages; receivedPackets++)\n        {\n            receivedMessages.add(client.receive(\"vm://foo\", 2000).getPayloadAsString());\n\n        }\n\n        assertEquals(broadcastMessages, receivedPackets);\n\n        //Check all broadcasts were received from Component1\n        checkBroadcastMessagesForComponent(receivedMessages, \"Component1\");\n\n        //Check all broadcasts were received from Component2\n        checkBroadcastMessagesForComponent(receivedMessages, \"Component2\");\n\n        //Check all broadcasts were received from Component3\n        checkBroadcastMessagesForComponent(receivedMessages, \"Component3\");\n\n        assertEquals(0, receivedMessages.size());\n    }","id":40344,"modified_method":"public void testSendTestData() throws Exception\n    {\n        final int numberOfMessages = 2;\n        MuleClient client = new MuleClient();\n\n        logger.debug(\"sending messages\");\n        for (int sentPackets = 0; sentPackets < numberOfMessages; sentPackets++)\n        {\n            String msg = MESSAGE + sentPackets;\n            client.dispatch(\"serverEndpoint\", msg, null);\n        }\n\n        int broadcastMessages = numberOfMessages * 3; //3 components\n        Set receivedMessages = new HashSet(broadcastMessages);\n\n        logger.debug(\"receiving messages\");\n        int receivedPackets = 0;\n        for (; receivedPackets < broadcastMessages; receivedPackets++)\n        {\n            UMOMessage message = client.receive(\"vm://foo\", 2000);\n            assertNotNull(message);\n            receivedMessages.add(message.getPayloadAsString());\n        }\n\n        assertEquals(broadcastMessages, receivedPackets);\n\n        //Check all broadcasts were received from Component1\n        checkBroadcastMessagesForComponent(numberOfMessages, receivedMessages, \"Component1\");\n\n        //Check all broadcasts were received from Component2\n        checkBroadcastMessagesForComponent(numberOfMessages, receivedMessages, \"Component2\");\n\n        //Check all broadcasts were received from Component3\n        checkBroadcastMessagesForComponent(numberOfMessages, receivedMessages, \"Component3\");\n\n        assertEquals(0, receivedMessages.size());\n    }","commit_id":"6d223262481a16764b9ee126803442f191417715","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void checkBroadcastMessagesForComponent(Set receivedMessages, String name)\n    {\n        //Check all broadcasts were received from Component2\n        for (int x = 0; x <100; x++)\n        {\n            String expected = MESSAGE + x + \" Received \" + name;\n\n            assertTrue(receivedMessages.contains(expected));\n            assertTrue(receivedMessages.remove(expected));\n        }\n    }","id":40345,"modified_method":"protected void checkBroadcastMessagesForComponent(int numberOfMessages,\n                                                      Set receivedMessages, String name)\n    {\n        //Check all broadcasts were received from Component2\n        for (int x = 0; x < numberOfMessages; x++)\n        {\n            String expected = MESSAGE + x + \" Received \" + name;\n\n            assertTrue(receivedMessages.contains(expected));\n            assertTrue(receivedMessages.remove(expected));\n        }\n    }","commit_id":"6d223262481a16764b9ee126803442f191417715","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testValidListener() throws Exception\n    {\n        MulticastConnector connector = new MulticastConnector();\n        MuleDescriptor d = getTestDescriptor(\"orange\", Orange.class.getName());\n        UMOComponent component = getTestComponent(d);\n        UMOEndpoint endpoint = getTestEndpoint(\"Test\", UMOEndpoint.ENDPOINT_TYPE_RECEIVER);\n        endpoint.setEndpointURI(null);\n        endpoint.setConnector(connector);\n\n        try\n        {\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register with null endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n        endpoint.setEndpointURI(null);\n        try\n        {\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register with empty endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n\n        endpoint.setEndpointURI(new MuleEndpointURI(\"multicast://228.2.3.4:10100\"));\n        connector.registerListener(component, endpoint);\n        try\n        {\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register on the same endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n        connector.dispose();\n    }","id":40346,"modified_method":"public void testValidListener() throws Exception\n    {\n        MuleDescriptor d = getTestDescriptor(\"orange\", Orange.class.getName());\n        UMOComponent component = getTestComponent(d);\n        UMOEndpoint endpoint = getTestEndpoint(\"Test\", UMOEndpoint.ENDPOINT_TYPE_RECEIVER);\n\n\n        try\n        {\n            endpoint.setEndpointURI(null);\n            endpoint.setConnector(connector);\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register with null endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n\n        try\n        {\n            endpoint.setEndpointURI(null);\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register with empty endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n\n        endpoint = new MuleEndpoint();\n        endpoint.setEndpointURI(new MuleEndpointURI(\"multicast://228.2.3.4:10100\"));\n        connector.registerListener(component, endpoint);\n        try\n        {\n            connector.registerListener(component, endpoint);\n            fail(\"cannot register on the same endpointUri\");\n        }\n        catch (Exception e)\n        { /* expected */\n        }\n        connector.dispose();\n    }","commit_id":"6d223262481a16764b9ee126803442f191417715","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testProperties() throws Exception\n    {\n        MulticastConnector c = new MulticastConnector();\n        c.initialise();\n        c.setReceiveBufferSize(1024);\n        assertEquals(1024, c.getReceiveBufferSize());\n        c.setReceiveBufferSize(0);\n        assertEquals(MulticastConnector.DEFAULT_BUFFER_SIZE, c.getReceiveBufferSize());\n\n        c.setReceiveTimeout(-1);\n        assertEquals(MulticastConnector.DEFAULT_SOCKET_TIMEOUT, c.getReceiveTimeout());\n\n        c.setLoopback(true);\n        assertTrue(c.isLoopback());\n    }","id":40347,"modified_method":"public void testProperties() throws Exception\n    {\n        MulticastConnector c = new MulticastConnector();\n        c.setReceiveBufferSize(1024);\n        assertEquals(1024, c.getReceiveBufferSize());\n        c.setReceiveBufferSize(0);\n        assertEquals(MulticastConnector.DEFAULT_BUFFER_SIZE, c.getReceiveBufferSize());\n\n        c.setReceiveTimeout(-1);\n        assertEquals(MulticastConnector.DEFAULT_SOCKET_TIMEOUT, c.getReceiveTimeout());\n\n        c.setLoopback(true);\n        assertTrue(c.isLoopback());\n    }","commit_id":"6d223262481a16764b9ee126803442f191417715","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n    {\n        while (!disposing.get())\n        {\n            if (connector.isStarted())\n            {\n\n                try\n                {\n                    DatagramPacket packet = createPacket();\n                    try\n                    {\n                        socket.receive(packet);\n\n                        if (logger.isTraceEnabled())\n                        {\n                            logger.trace(\"Received packet on: \" + uri);\n                        }\n\n                        Work work = createWork(packet);\n                        try\n                        {\n                            getWorkManager().scheduleWork(work, WorkManager.INDEFINITE, null, connector);\n                        }\n                        catch (WorkException e)\n                        {\n                            logger.error(\"Udp receiver interrupted: \" + e.getMessage(), e);\n                        }\n                    }\n                    catch (SocketTimeoutException e)\n                    {\n                        // ignore\n                    }\n\n                }\n                catch (Exception e)\n                {\n                    if (!connector.isDisposed() && !disposing.get())\n                    {\n                        logger.debug(\"Accept failed on socket: \" + e, e);\n                        handleException(e);\n                    }\n                }\n            }\n        }\n    }","id":40348,"modified_method":"public void run()\n    {\n        while (!disposing.get())\n        {\n            if (connector.isStarted())\n            {\n\n                try\n                {\n                    DatagramPacket packet = createPacket();\n                    try\n                    {\n                        if (logger.isDebugEnabled())\n                        {\n                            logger.debug(\"Receiving packet on \" + uri);\n                        }\n                        socket.receive(packet);\n\n                        if (logger.isTraceEnabled())\n                        {\n                            logger.trace(\"Received packet on: \" + uri);\n                        }\n\n                        Work work = createWork(packet);\n                        try\n                        {\n                            getWorkManager().scheduleWork(work, WorkManager.INDEFINITE, null, connector);\n                        }\n                        catch (WorkException e)\n                        {\n                            logger.error(\"Udp receiver interrupted: \" + e.getMessage(), e);\n                        }\n                    }\n                    catch (SocketTimeoutException e)\n                    {\n                        // ignore\n                    }\n\n                }\n                catch (Exception e)\n                {\n                    if (!connector.isDisposed() && !disposing.get())\n                    {\n                        logger.debug(\"Accept failed on socket: \" + e, e);\n                        handleException(e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"6d223262481a16764b9ee126803442f191417715","url":"https://github.com/mulesoft/mule"},{"original_method":"private static void configureShutdown(Tomcat tomcat, Props props) {\n    String shutdownToken = props.of(PROPERTY_SHUTDOWN_TOKEN);\n    Integer shutdownPort = props.intOf(PROPERTY_SHUTDOWN_PORT);\n    if (shutdownToken != null && !\"\".equals(shutdownToken) && shutdownPort != null) {\n      tomcat.getServer().setPort(shutdownPort);\n      tomcat.getServer().setShutdown(shutdownToken);\n    }\n  }","id":40349,"modified_method":"private static void configureShutdown(Tomcat tomcat, Props props) {\n    String shutdownToken = props.of(\"sonar.web.shutdown.token\");\n    Integer shutdownPort = props.intOf(\"sonar.web.shutdown.port\");\n    if (shutdownToken != null && !\"\".equals(shutdownToken) && shutdownPort != null) {\n      tomcat.getServer().setPort(shutdownPort);\n      tomcat.getServer().setShutdown(shutdownToken);\n      info(\"Shutdown command is enabled on port \" + shutdownPort);\n    }\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static void configure(Tomcat tomcat, Props props) {\n    tomcat.getServer().setAddress(props.of(\"sonar.web.host\", \"0.0.0.0\"));\n    configureShutdown(tomcat, props);\n\n    Connector connector = new Connector(\"HTTP/1.1\");\n    connector.setPort(props.intOf(\"sonar.web.port\", 9000));\n    connector.setURIEncoding(\"UTF-8\");\n    configurePool(props, connector);\n    configureCompression(connector);\n    tomcat.setConnector(connector);\n    tomcat.getService().addConnector(connector);\n  }","id":40350,"modified_method":"static void configure(Tomcat tomcat, Props props) {\n    tomcat.getServer().setAddress(props.of(\"sonar.web.host\", \"0.0.0.0\"));\n    configureShutdown(tomcat, props);\n    configureConnectors(tomcat, props);\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void configurePool(Props props, Connector connector) {\n    connector.setProperty(\"acceptorThreadCount\", String.valueOf(2));\n    connector.setProperty(\"minSpareThreads\", String.valueOf(props.intOf(PROPERTY_MIN_THREADS, 5)));\n    connector.setProperty(\"maxThreads\", String.valueOf(props.intOf(PROPERTY_MAX_THREADS, 50)));\n    connector.setProperty(\"acceptCount\", String.valueOf(props.intOf(PROPERTY_ACCEPT_COUNT, 25)));\n  }","id":40351,"modified_method":"private static void configurePool(Props props, Connector connector, String scheme) {\n    connector.setProperty(\"acceptorThreadCount\", String.valueOf(2));\n    connector.setProperty(\"minSpareThreads\", String.valueOf(props.intOf(\"sonar.web.\" + scheme + \".minThreads\", 5)));\n    connector.setProperty(\"maxThreads\", String.valueOf(props.intOf(\"sonar.web.\" + scheme + \".maxThreads\", 50)));\n    connector.setProperty(\"acceptCount\", String.valueOf(props.intOf(\"sonar.web.\" + scheme + \".acceptCount\", 25)));\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void disable_shutdown_port_by_default() throws Exception {\n    Props props = new Props(new Properties());\n\n    Tomcat tomcat = mock(Tomcat.class, Mockito.RETURNS_DEEP_STUBS);\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer(), never()).setPort(anyInt());\n    verify(tomcat.getServer(), never()).setShutdown(anyString());\n  }","id":40352,"modified_method":"@Test\n  public void disable_shutdown_port_by_default() throws Exception {\n    Props props = new Props(new Properties());\n\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer(), never()).setPort(anyInt());\n    verify(tomcat.getServer(), never()).setShutdown(anyString());\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void enable_shutdown_port() throws Exception {\n    Properties p = new Properties();\n    p.setProperty(Connectors.PROPERTY_SHUTDOWN_PORT, \"9010\");\n    p.setProperty(Connectors.PROPERTY_SHUTDOWN_TOKEN, \"SHUTDOWN\");\n    Props props = new Props(p);\n\n    Tomcat tomcat = mock(Tomcat.class, Mockito.RETURNS_DEEP_STUBS);\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer()).setPort(9010);\n    verify(tomcat.getServer()).setShutdown(\"SHUTDOWN\");\n  }","id":40353,"modified_method":"@Test\n  public void enable_shutdown_port() throws Exception {\n    Properties p = new Properties();\n    p.setProperty(\"sonar.web.shutdown.port\", \"9010\");\n    p.setProperty(\"sonar.web.shutdown.token\", \"SHUTDOWN\");\n    Props props = new Props(p);\n\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer()).setPort(9010);\n    verify(tomcat.getServer()).setShutdown(\"SHUTDOWN\");\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void configure_thread_pool() throws Exception {\n    Properties p = new Properties();\n    p.setProperty(Connectors.PROPERTY_MIN_THREADS, \"2\");\n    p.setProperty(Connectors.PROPERTY_MAX_THREADS, \"30\");\n    p.setProperty(Connectors.PROPERTY_ACCEPT_COUNT, \"20\");\n    Props props = new Props(p);\n\n    Tomcat tomcat = mock(Tomcat.class, Mockito.RETURNS_DEEP_STUBS);\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat).setConnector(argThat(new ArgumentMatcher<Connector>() {\n      @Override\n      public boolean matches(Object o) {\n        Connector c = (Connector)o;\n        return (Integer)c.getProperty(\"minSpareThreads\") == 2 &&\n          (Integer) c.getProperty(\"maxThreads\") == 30 &&\n          (Integer) c.getProperty(\"acceptCount\") == 20;\n      }\n    }));\n  }","id":40354,"modified_method":"@Test\n  public void configure_thread_pool() throws Exception {\n    Properties p = new Properties();\n    p.setProperty(\"sonar.web.http.minThreads\", \"2\");\n    p.setProperty(\"sonar.web.http.maxThreads\", \"30\");\n    p.setProperty(\"sonar.web.http.acceptCount\", \"20\");\n    Props props = new Props(p);\n\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat).setConnector(argThat(new PropertiesMatcher(\n      ImmutableMap.<String, Object>of(\"minSpareThreads\", 2, \"maxThreads\", 30, \"acceptCount\", 20)\n    )));\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void configure_default_thread_pool() throws Exception {\n    Props props = new Props(new Properties());\n\n    Tomcat tomcat = mock(Tomcat.class, Mockito.RETURNS_DEEP_STUBS);\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat).setConnector(argThat(new ArgumentMatcher<Connector>() {\n      @Override\n      public boolean matches(Object o) {\n        Connector c = (Connector)o;\n        return (Integer)c.getProperty(\"minSpareThreads\") == 5 &&\n          (Integer) c.getProperty(\"maxThreads\") == 50 &&\n          (Integer) c.getProperty(\"acceptCount\") == 25;\n      }\n    }));\n  }","id":40355,"modified_method":"@Test\n  public void configure_default_thread_pool() throws Exception {\n    Props props = new Props(new Properties());\n\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat).setConnector(argThat(new PropertiesMatcher(\n      ImmutableMap.<String, Object>of(\"minSpareThreads\", 5, \"maxThreads\", 50, \"acceptCount\", 25)\n    )));\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void disable_shutdown_port_if_missing_token() throws Exception {\n    Properties p = new Properties();\n    // only the port, but not the token\n    p.setProperty(Connectors.PROPERTY_SHUTDOWN_PORT, \"9010\");\n    Props props = new Props(p);\n\n    Tomcat tomcat = mock(Tomcat.class, Mockito.RETURNS_DEEP_STUBS);\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer(), never()).setPort(anyInt());\n    verify(tomcat.getServer(), never()).setShutdown(anyString());\n  }","id":40356,"modified_method":"@Test\n  public void disable_shutdown_port_if_missing_token() throws Exception {\n    Properties p = new Properties();\n    // only the port, but not the token\n    p.setProperty(\"sonar.web.shutdown.port\", \"9010\");\n    Props props = new Props(p);\n\n    Connectors.configure(tomcat, props);\n\n    verify(tomcat.getServer(), never()).setPort(anyInt());\n    verify(tomcat.getServer(), never()).setShutdown(anyString());\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"int port() {\n    return tomcat.getService().findConnectors()[0].getLocalPort();\n  }","id":40357,"modified_method":"int port() {\n    Connector[] connectors = tomcat.getService().findConnectors();\n    if (connectors.length > 0) {\n      return connectors[0].getLocalPort();\n    }\n    return -1;\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static void configure(Tomcat tomcat, Env env) {\n    tomcat.setSilent(false);\n    LogbackValve valve = new LogbackValve();\n    valve.setQuiet(true);\n    File confFile = env.file(CONF_PATH);\n    if (!confFile.exists()) {\n      throw new IllegalStateException(\"File is missing: \" + confFile.getAbsolutePath());\n    }\n    valve.setFilename(confFile.getAbsolutePath());\n    tomcat.getHost().getPipeline().addValve(valve);\n  }","id":40358,"modified_method":"static void configure(Tomcat tomcat, Env env) {\n    tomcat.setSilent(false);\n    tomcat.getService().addLifecycleListener(new StartupLogger(LoggerFactory.getLogger(Logging.class)));\n\n    LogbackValve valve = new LogbackValve();\n    valve.setQuiet(true);\n    File confFile = env.file(CONF_PATH);\n    if (!confFile.exists()) {\n      throw new IllegalStateException(\"File is missing: \" + confFile.getAbsolutePath());\n    }\n    valve.setFilename(confFile.getAbsolutePath());\n    tomcat.getHost().getPipeline().addValve(valve);\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static void configure(Tomcat tomcat, Env env, Props props) {\n    String ctx = props.of(\"sonar.web.context\", \"/\");\n    try {\n      Context context = tomcat.addWebapp(ctx, env.file(\"web\").getAbsolutePath());\n      context.setConfigFile(env.file(\"web/META-INF/context.xml\").toURI().toURL());\n      configureRailsMode(props, context);\n      context.setJarScanner(new NullJarScanner());\n\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Fail to configure webapp\", e);\n    }\n  }","id":40359,"modified_method":"static void configure(Tomcat tomcat, Env env, Props props) {\n    String ctx = getContext(props);\n    try {\n      Context context = tomcat.addWebapp(ctx, env.file(\"web\").getAbsolutePath());\n      context.setConfigFile(env.file(\"web/META-INF/context.xml\").toURI().toURL());\n      configureRailsMode(props, context);\n      context.setJarScanner(new NullJarScanner());\n\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Fail to configure webapp\", e);\n    }\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_on_error() throws Exception {\n    Env env = mock(Env.class);\n    File webDir = temp.newFolder(\"web\");\n    when(env.file(\"web\")).thenReturn(webDir);\n\n    Tomcat tomcat = mock(Tomcat.class, RETURNS_DEEP_STUBS);\n    when(tomcat.addContext(\"\", webDir.getAbsolutePath())).thenThrow(new NullPointerException());\n\n    try {\n      Webapp.configure(tomcat, env, mock(Props.class));\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"Fail to configure webapp\");\n    }\n  }","id":40360,"modified_method":"@Test\n  public void fail_on_error() throws Exception {\n    Env env = mock(Env.class);\n    File webDir = temp.newFolder(\"web\");\n    when(env.file(\"web\")).thenReturn(webDir);\n\n    Tomcat tomcat = mock(Tomcat.class, RETURNS_DEEP_STUBS);\n    when(tomcat.addContext(\"\", webDir.getAbsolutePath())).thenThrow(new NullPointerException());\n\n    try {\n      Webapp.configure(tomcat, env, new Props(new Properties()));\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"Fail to configure webapp\");\n    }\n  }","commit_id":"275da1c743917341256322a09a3172a2ccf04ef3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","id":40361,"modified_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withNonResolvableTuningFile().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","commit_id":"18af1bb559400c5c621db8e1312b62da82537e3e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        //serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","id":40362,"modified_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n        \n        System.out.println(databaseTuningPropertyFileLocation);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                log.info(\"No database tuning properties (org.neo4j.server.db.tuning.properties) found in [%s], using defaults.\", databaseTuningPropertyFileLocation);\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        // Just as a courtesy in case any modules want their config this way\n        serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        \n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","commit_id":"18af1bb559400c5c621db8e1312b62da82537e3e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","id":40363,"modified_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withNonResolvableTuningFile().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","commit_id":"887e7b1a76ec237e5194d59638d5f71e6778722a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        //serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","id":40364,"modified_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n        \n        System.out.println(databaseTuningPropertyFileLocation);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                log.info(\"No database tuning properties (org.neo4j.server.db.tuning.properties) found in [%s], using defaults.\", databaseTuningPropertyFileLocation);\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        // Just as a courtesy in case any modules want their config this way\n        serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        \n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","commit_id":"887e7b1a76ec237e5194d59638d5f71e6778722a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","id":40365,"modified_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withNonResolvableTuningFile().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","commit_id":"6534d9200715328b4874e821fb0954b981584a32","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        //serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","id":40366,"modified_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n        \n        System.out.println(databaseTuningPropertyFileLocation);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                log.info(\"No database tuning properties (org.neo4j.server.db.tuning.properties) found in [%s], using defaults.\", databaseTuningPropertyFileLocation);\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        // Just as a courtesy in case any modules want their config this way\n        serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        \n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","commit_id":"6534d9200715328b4874e821fb0954b981584a32","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","id":40367,"modified_method":"@Before\n    public void startServer() throws IOException\n    {\n        server = ServerBuilder.server().withRandomDatabaseDir().withNonResolvableTuningFile().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper( server );\n    }","commit_id":"9b1edb68c6f2e5060a265361cc6fc28341823cde","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        //serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","id":40368,"modified_method":"private void loadDatabaseTuningProperties(File configFile) throws ConfigurationException {\n        String databaseTuningPropertyFileLocation = serverConfiguration.getString(DB_TUNING_PROPERTY_FILE_KEY);\n        \n        System.out.println(databaseTuningPropertyFileLocation);\n\n        if (databaseTuningPropertyFileLocation == null) {\n            if(propertyFileDirectoryContainsDBTuningFile()) {\n                databaseTuningPropertyFileLocation = new File (propertyFileDirectory, NEO4J_PROPERTIES_FILENAME).getAbsolutePath();\n                log.info(\"No database tuning file explicitly set, defaulting to [%s]\", databaseTuningPropertyFileLocation);\n            } else {\n                log.info(\"No database tuning properties (org.neo4j.server.db.tuning.properties) found in [%s], using defaults.\", databaseTuningPropertyFileLocation);\n                return;\n            }\n        }\n\n        File databaseTuningPropertyFile = new File(databaseTuningPropertyFileLocation);\n        \n        if (!databaseTuningPropertyFile.exists()) {\n            log.warn(\"The specified file for database performance tuning properties [%s] does not exist.\", databaseTuningPropertyFileLocation);\n            return;\n        }\n        \n        // Just as a courtesy in case any modules want their config this way\n        serverConfiguration.addConfiguration(new PropertiesConfiguration(databaseTuningPropertyFile));\n        \n        databaseTuningProperties = new HashMap<String, String>();\n        PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration(databaseTuningPropertyFile);\n        Iterator keys = propertiesConfiguration.getKeys();\n        while(keys.hasNext()) {\n            String key = (String)keys.next();\n            Object value = propertiesConfiguration.getProperty((String) key);\n            databaseTuningProperties.put(key, String.valueOf(value));\n        }\n        \n    }","commit_id":"9b1edb68c6f2e5060a265361cc6fc28341823cde","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * @inheritDoc\n     * \n     *  When a new tuple is asserted into a CollectNode, do this:\n     *  \n     *  1. Select all matching objects from right memory\n     *  2. Add them to the resulting collection object\n     *  3. Apply resultConstraints and resultsBinder to the resulting collection\n     *  4. In case all of them evaluates to true do the following:\n     *  4.1. Create a new InternalFactHandle for the resulting collection and add it to the tuple\n     *  4.2. Propagate the tuple\n     *  \n     */\n    public void assertTuple(final ReteTuple leftTuple,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        memory.getTupleMemory().add( leftTuple );\n\n        final Collection result = this.collect.instantiateResultObject();\n        final Iterator it = memory.getFactHandleMemory().iterator( leftTuple );\n        this.constraints.updateFromTuple( workingMemory,\n                                          leftTuple );\n\n        for ( FactEntry entry = (FactEntry) it.next(); entry != null; entry = (FactEntry) it.next() ) {\n            final InternalFactHandle handle = entry.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( handle.getObject() ) ) {\n                result.add( handle.getObject() );\n            }\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( result,\n                                                       workingMemory ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( result ) ) {\n                final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( result );\n                memory.getCreatedHandles().put( leftTuple,\n                                                handle,\n                                                false );\n\n                this.sink.propagateAssertTuple( leftTuple,\n                                           handle,\n                                           context,\n                                           workingMemory );\n            }\n        }\n    }","id":40369,"modified_method":"/**\n     * @inheritDoc\n     * \n     *  When a new tuple is asserted into a CollectNode, do this:\n     *  \n     *  1. Select all matching objects from right memory\n     *  2. Add them to the resulting collection object\n     *  3. Apply resultConstraints and resultsBinder to the resulting collection\n     *  4. In case all of them evaluates to true do the following:\n     *  4.1. Create a new InternalFactHandle for the resulting collection and add it to the tuple\n     *  4.2. Propagate the tuple\n     *  \n     */\n    public void assertTuple(final ReteTuple leftTuple,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        memory.getTupleMemory().add( leftTuple );\n\n        final Collection result = this.collect.instantiateResultObject();\n        final InternalFactHandle resultHandle = workingMemory.getFactHandleFactory().newFactHandle( result );\n        CollectResult colresult = new CollectResult();\n        colresult.handle = resultHandle;\n        colresult.propagated = false;\n        memory.getCreatedHandles().put( leftTuple,\n                                        colresult,\n                                        false );\n\n        final Iterator it = memory.getFactHandleMemory().iterator( leftTuple );\n        this.constraints.updateFromTuple( workingMemory,\n                                          leftTuple );\n\n        for ( FactEntry entry = (FactEntry) it.next(); entry != null; entry = (FactEntry) it.next() ) {\n            final InternalFactHandle handle = entry.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( handle.getObject() ) ) {\n                result.add( handle.getObject() );\n            }\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( result,\n                                                       workingMemory ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( result ) ) {\n                colresult.propagated = true;\n                this.sink.propagateAssertTuple( leftTuple,\n                                                resultHandle,\n                                                context,\n                                                workingMemory );\n            }\n        }\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     */\n    public void retractTuple(final ReteTuple leftTuple,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getTupleMemory().remove( leftTuple );\n        final InternalFactHandle handle = (InternalFactHandle) memory.getCreatedHandles().remove( leftTuple );\n\n        // if tuple was propagated\n        if ( handle != null ) {\n\n            this.sink.propagateRetractTuple( leftTuple,\n                                             handle,\n                                             context,\n                                             workingMemory );\n\n            // Destroying the acumulate result object \n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n        }\n    }","id":40370,"modified_method":"/**\n     * @inheritDoc\n     */\n    public void retractTuple(final ReteTuple leftTuple,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getTupleMemory().remove( leftTuple );\n        CollectResult result = (CollectResult) memory.getCreatedHandles().remove( leftTuple );\n        final InternalFactHandle handle = result.handle;\n\n        // if tuple was propagated\n        if ( result.propagated ) {\n\n            this.sink.propagateRetractTuple( leftTuple,\n                                             handle,\n                                             context,\n                                             workingMemory );\n\n            // Destroying the acumulate result object \n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n        }\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     * \n     *  When a new object is asserted into a CollectNode, do this:\n     *  \n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *  \n     */\n    public void assertObject(final InternalFactHandle handle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getFactHandleMemory().add( handle );\n\n        this.constraints.updateFromFactHandle( workingMemory,\n                                               handle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.getTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            ReteTuple tuple = (ReteTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( tuple ) ) {\n                this.retractTuple( tuple,\n                                   context,\n                                   workingMemory );\n                this.assertTuple( tuple,\n                                  context,\n                                  workingMemory );\n            }\n        }\n    }","id":40371,"modified_method":"/**\n     * @inheritDoc\n     * \n     *  When a new object is asserted into a CollectNode, do this:\n     *  \n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *  \n     */\n    public void assertObject(final InternalFactHandle handle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        memory.getFactHandleMemory().add( handle );\n\n        this.constraints.updateFromFactHandle( workingMemory,\n                                               handle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.getTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            ReteTuple tuple = (ReteTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( tuple ) ) {\n                this.modifyTuple( tuple,\n                                  handle,\n                                  context,\n                                  workingMemory );\n            }\n        }\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     *  @inheritDoc\n     *  \n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractObject(final InternalFactHandle handle,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        if ( !memory.getFactHandleMemory().remove( handle ) ) {\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( workingMemory,\n                                               handle );\n        \n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.getTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            ReteTuple tuple = (ReteTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( tuple ) ) {\n                this.retractTuple( tuple,\n                                   context,\n                                   workingMemory );\n                this.assertTuple( tuple,\n                                  context,\n                                  workingMemory );\n            }\n        }\n    }","id":40372,"modified_method":"/**\n     *  @inheritDoc\n     *  \n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractObject(final InternalFactHandle handle,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n        if ( !memory.getFactHandleMemory().remove( handle ) ) {\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( workingMemory,\n                                               handle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.getTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            ReteTuple tuple = (ReteTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( tuple ) ) {\n                \n                this.modifyTuple( tuple,\n                                  handle,\n                                  context,\n                                  workingMemory );\n            }\n        }\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateSink(final TupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator it = memory.getCreatedHandles().iterator();\n\n        for ( ObjectEntry entry = (ObjectEntry) it.next(); entry != null; entry = (ObjectEntry) it.next() ) {\n            sink.assertTuple( new ReteTuple( (ReteTuple) entry.getKey(),\n                                             (InternalFactHandle) entry.getValue() ),\n                              context,\n                              workingMemory );\n        }\n    }","id":40373,"modified_method":"public void updateSink(final TupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator it = memory.getCreatedHandles().iterator();\n\n        for ( ObjectEntry entry = (ObjectEntry) it.next(); entry != null; entry = (ObjectEntry) it.next() ) {\n            CollectResult result = (CollectResult) entry.getValue();\n            sink.assertTuple( new ReteTuple( (ReteTuple) entry.getKey(),\n                                             result.handle ),\n                              context,\n                              workingMemory );\n        }\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testAssertObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             1,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 2 ))[0]).get( 1 )).getObject()).size() );\n\n    }","id":40374,"modified_method":"public void testAssertObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.contextAssert,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        this.node.assertObject( f0,\n                                this.contextAssert,\n                                this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             1,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.assertObject( f1,\n                                this.contextAssert,\n                                this.workingMemory );\n\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 2 ))[0]).get( 1 )).getObject()).size() );\n\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testUpdateNewNode() {\n        this.node.updateSink( this.sink,\n                              this.context,\n                              this.workingMemory );\n        Assert.assertEquals( \"No tuple should be propagated\",\n                             0,\n                             this.sink.getAsserted().size() );\n\n        this.node.assertTuple( new ReteTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" ) ),\n                               this.context,\n                               this.workingMemory );\n        this.node.assertTuple( new ReteTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" ) ),\n                               this.context,\n                               this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n\n        final MockTupleSink otherSink = new MockTupleSink();\n\n        this.node.addTupleSink( otherSink );\n        this.node.updateSink( otherSink,\n                              this.context,\n                              this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             otherSink.getAsserted().size() );\n    }","id":40375,"modified_method":"public void testUpdateNewNode() {\n        this.node.updateSink( this.sink,\n                              this.contextAssert,\n                              this.workingMemory );\n        Assert.assertEquals( \"No tuple should be propagated\",\n                             0,\n                             this.sink.getAsserted().size() );\n\n        this.node.assertTuple( new ReteTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" ) ),\n                               this.contextAssert,\n                               this.workingMemory );\n        this.node.assertTuple( new ReteTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" ) ),\n                               this.contextAssert,\n                               this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n\n        final MockTupleSink otherSink = new MockTupleSink();\n\n        this.node.addTupleSink( otherSink );\n        this.node.updateSink( otherSink,\n                              this.contextAssert,\n                              this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             otherSink.getAsserted().size() );\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testRetractTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        this.node.retractTuple( tuple0,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n    }","id":40376,"modified_method":"public void testRetractTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.contextAssert,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        this.node.retractTuple( tuple0,\n                                this.contextRetract,\n                                this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testRetractObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.retractObject( f1,\n                                 this.context,\n                                 this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             1,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.retractObject( f0,\n                                 this.context,\n                                 this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getRetracted().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             0,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 2 ))[0]).get( 1 )).getObject()).size() );\n\n    }","id":40377,"modified_method":"public void testRetractObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.contextAssert,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.contextAssert,\n                                this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.contextAssert,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.retractObject( f1,\n                                 this.contextRetract,\n                                 this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             1,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        this.node.retractObject( f0,\n                                 this.contextRetract,\n                                 this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getRetracted().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             0,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 2 ))[0]).get( 1 )).getObject()).size() );\n\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testAssertTupleWithObjects() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).size() );\n\n        // assert tuple, should add left memory \n        final ReteTuple tuple1 = new ReteTuple( f1 );\n        this.node.assertTuple( tuple1,\n                               this.context,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        assertTrue( this.memory.getTupleMemory().contains( tuple0 ) );\n        assertTrue( this.memory.getTupleMemory().contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","id":40378,"modified_method":"public void testAssertTupleWithObjects() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.contextAssert,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.contextAssert,\n                                this.workingMemory );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.contextAssert,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 2,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).size() );\n\n        // assert tuple, should add left memory \n        final ReteTuple tuple1 = new ReteTuple( f1 );\n        this.node.assertTuple( tuple1,\n                               this.contextAssert,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).size() );\n\n        assertTrue( this.memory.getTupleMemory().contains( tuple0 ) );\n        assertTrue( this.memory.getTupleMemory().contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testAssertTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        // assert tuple, should add left memory \n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple1 = new ReteTuple( f1 );\n        this.node.assertTuple( tuple1,\n                               this.context,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getTupleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        assertTrue( this.memory.getTupleMemory().contains( tuple0 ) );\n        assertTrue( this.memory.getTupleMemory().contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","id":40379,"modified_method":"public void testAssertTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\" );\n        final ReteTuple tuple0 = new ReteTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertTuple( tuple0,\n                               this.contextAssert,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 0 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        // assert tuple, should add left memory \n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\" );\n\n        final ReteTuple tuple1 = new ReteTuple( f1 );\n        this.node.assertTuple( tuple1,\n                               this.contextAssert,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getTupleMemory().size() );\n        Assert.assertTrue( \"An empty collection should be propagated\",\n                           ((Collection) ((DefaultFactHandle) ((Tuple) ((Object[]) this.sink.getAsserted().get( 1 ))[0]).get( 1 )).getObject()).isEmpty() );\n\n        assertTrue( this.memory.getTupleMemory().contains( tuple0 ) );\n        assertTrue( this.memory.getTupleMemory().contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        this.rule = new Rule( \"test-rule\" );\n        this.context = new PropagationContextImpl( 0,\n                                                   PropagationContext.ASSERTION,\n                                                   null,\n                                                   null );\n        this.workingMemory = new ReteooWorkingMemory( 1,\n                                                      (ReteooRuleBase) RuleBaseFactory.newRuleBase() );\n\n        this.tupleSource = new MockTupleSource( 4 );\n        this.objectSource = new MockObjectSource( 4 );\n        this.sink = new MockTupleSink();\n\n        final ObjectType srcObjType = new ClassObjectType( String.class );\n        final Pattern sourcePattern = new Pattern( 0,\n                                                srcObjType );\n        final ObjectType resultObjType = new ClassObjectType( LinkedList.class );\n        final Pattern resultPattern = new Pattern( 1,\n                                                resultObjType );\n        this.collect = new Collect( sourcePattern,\n                                    resultPattern );\n\n        this.node = new CollectNode( 15,\n                                     this.tupleSource,\n                                     this.objectSource,\n                                     this.collect );\n\n        this.node.addTupleSink( this.sink );\n\n        this.memory = (BetaMemory) this.workingMemory.getNodeMemory( this.node );\n\n        // check memories are empty\n        assertEquals( 0,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n    }","id":40380,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        this.rule = new Rule( \"test-rule\" );\n        this.contextAssert = new PropagationContextImpl( 0,\n                                                         PropagationContext.ASSERTION,\n                                                         null,\n                                                         null );\n        this.contextRetract = new PropagationContextImpl( 0,\n                                                         PropagationContext.RETRACTION,\n                                                         null,\n                                                         null );\n        this.workingMemory = new ReteooWorkingMemory( 1,\n                                                      (ReteooRuleBase) RuleBaseFactory.newRuleBase() );\n\n        this.tupleSource = new MockTupleSource( 4 );\n        this.objectSource = new MockObjectSource( 4 );\n        this.sink = new MockTupleSink();\n\n        final ObjectType srcObjType = new ClassObjectType( String.class );\n        final Pattern sourcePattern = new Pattern( 0,\n                                                srcObjType );\n        final ObjectType resultObjType = new ClassObjectType( LinkedList.class );\n        final Pattern resultPattern = new Pattern( 1,\n                                                resultObjType );\n        this.collect = new Collect( sourcePattern,\n                                    resultPattern );\n\n        this.node = new CollectNode( 15,\n                                     this.tupleSource,\n                                     this.objectSource,\n                                     this.collect );\n\n        this.node.addTupleSink( this.sink );\n\n        this.memory = (BetaMemory) this.workingMemory.getNodeMemory( this.node );\n\n        // check memories are empty\n        assertEquals( 0,\n                      this.memory.getTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getFactHandleMemory().size() );\n    }","commit_id":"aa33db40b047a66b32a4770a5f138844378d45e9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setPopupVisible(final boolean v) {\n    boolean wasVisible = isPopupVisible();\n\n    super.setPopupVisible(v);\n\n    if (v && !wasVisible && !UIUtil.isUnderNativeMacLookAndFeel()) {\n      reconfigureEditor();\n    }\n  }","id":40381,"modified_method":"@Override\n  public void setPopupVisible(boolean v) {\n    if (getModel().getSize() == 0 && v) return;\n\n    final boolean wasShown = isPopupVisible();\n    super.setPopupVisible(v);\n    if (!wasShown && v && isEditable() && !wasShown && !UIManager.getBoolean(\"ComboBox.isEnterSelectablePopup\")) {\n      final ComboBoxEditor editor = getEditor();\n      final Object item = editor.getItem();\n      final Object selectedItem = getSelectedItem();\n      if (item == null || item != selectedItem) {\n        configureEditor(editor, selectedItem);\n      }\n    }\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ComboBox(final ComboBoxModel model, final int minimumAndPreferredWidth) {\n    super(model);\n    myMinimumAndPreferredWidth = minimumAndPreferredWidth;\n    registerCancelOnEscape();\n\n    addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        if (!UIUtil.isUnderNativeMacLookAndFeel()) return;\n\n        if (!isShowing() || !isEditable() || getEditor() == null || !isPopupVisible()) return;\n\n        reconfigureEditor();\n      }\n    });\n  }","id":40382,"modified_method":"public ComboBox(final ComboBoxModel model, final int minimumAndPreferredWidth) {\n    super(model);\n    myMinimumAndPreferredWidth = minimumAndPreferredWidth;\n    registerCancelOnEscape();\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setRecents() {\n    boolean focusOwner = myEditor != null && myEditor.getEditorComponent().isFocusOwner();\n    myComboBox.removeAllItems();\n    if(getRecentsId() != null) {\n      LinkedList<TextWithImports> recents = DebuggerRecents.getInstance(getProject()).getRecents(getRecentsId());\n      ArrayList<TextWithImports> singleLine = new ArrayList<TextWithImports>();\n      for (TextWithImports evaluationText : recents) {\n        if (evaluationText.getText().indexOf('\\n') == -1) {\n          singleLine.add(evaluationText);\n        }\n      }\n      addRecents(singleLine);\n    }\n    if(focusOwner) myEditor.getEditorComponent().requestFocus();\n  }","id":40383,"modified_method":"@Nullable\n  private List<TextWithImports> getRecents() {\n    final String recentsId = getRecentsId();\n    if (recentsId != null) {\n      final List<TextWithImports> result = new ArrayList<TextWithImports>();\n      LinkedList<TextWithImports> recents = DebuggerRecents.getInstance(getProject()).getRecents(getRecentsId());\n      for (final TextWithImports evaluationText : recents) {\n        if (evaluationText.getText().indexOf('\\n') == -1) {\n          result.add(evaluationText);\n        }\n      }\n\n      return result;\n    }\n\n    return null;\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerExpressionComboBox(Project project, PsiElement context, @NonNls String recentsId, final CodeFragmentFactory factory) {\n    super(project, context, recentsId, factory);\n    myComboBox = new ComboBox(-1);\n    myComboBox.setEditable(true);\n\n    myEditor = new MyEditorComboBoxEditor(getProject(), myFactory.getFileType());\n    myComboBox.setEditor(myEditor);\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n\n    // Have to turn this off because when used in DebuggerTreeInplaceEditor, the combobox popup is hidden on every change of selection\n    // See comment to SynthComboBoxUI.FocusHandler.focusLost()\n    myComboBox.setLightWeightPopupEnabled(false);\n    setLayout(new BorderLayout(0, 0));\n    add(myComboBox);\n\n    setText(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, \"\"));\n    myItem =  createText(\"\");\n    setEnabled(true);\n  }","id":40384,"modified_method":"public DebuggerExpressionComboBox(Project project, PsiElement context, @NonNls String recentsId, final CodeFragmentFactory factory) {\n    super(project, context, recentsId, factory);\n    setLayout(new BorderLayout(0, 0));\n\n    myComboBox = new ComboBox(new MyComboboxModel(getRecents()), -1);\n\n    // Have to turn this off because when used in DebuggerTreeInplaceEditor, the combobox popup is hidden on every change of selection\n    // See comment to SynthComboBoxUI.FocusHandler.focusLost()\n    myComboBox.setLightWeightPopupEnabled(false);\n\n    myEditor = new MyEditorComboBoxEditor(getProject(), myFactory.getFileType());\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n\n    myComboBox.setEditable(true);\n    myComboBox.setEditor(myEditor);\n    add(myComboBox);\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setEnabled(boolean enabled) {\n    myComboBox.setEnabled(enabled);\n\n    if (enabled) {\n      setRecents();\n      myEditor.setItem(myItem);\n    }\n    else {\n      myItem = (TextWithImports)myComboBox.getEditor().getItem();\n      myComboBox.removeAllItems();\n      myComboBox.addItem(myItem);\n    }\n  }","id":40385,"modified_method":"@Override\n  public void setEnabled(boolean enabled) {\n    super.setEnabled(enabled);\n    myComboBox.setEnabled(enabled);\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addRecent(TextWithImports text) {\n    super.addRecent(text);\n    setRecents();\n  }","id":40386,"modified_method":"public void addRecent(TextWithImports text) {\n    if (text.getText().length() != 0) {\n      final Component editorComponent = myComboBox.getEditor().getEditorComponent();\n      final boolean focusOwner = editorComponent.isFocusOwner();\n      super.addRecent(text);\n      myComboBox.insertItemAt(text, 0);\n      myComboBox.setSelectedIndex(0);\n\n      if (focusOwner) {\n        editorComponent.requestFocus();\n      }\n    }\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if(myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n    myItem = item;\n  }","id":40387,"modified_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void editNode(final DebuggerTreeNodeImpl node) {\n    final DebuggerContextImpl context = getContext();\n    final DebuggerExpressionComboBox comboBox = new DebuggerExpressionComboBox(getProject(), PositionUtil.getContextElement(context), \"evaluation\",\n                                                                               DefaultCodeFragmentFactory.getInstance());\n    comboBox.setText(((WatchItemDescriptor)node.getDescriptor()).getEvaluationText());\n    comboBox.selectAll();\n\n    DebuggerTreeInplaceEditor editor = new DebuggerTreeInplaceEditor(node) {\n      public JComponent createInplaceEditorComponent() {\n        return comboBox;\n      }\n\n      public JComponent getPreferredFocusedComponent() {\n        return comboBox.getPreferredFocusedComponent();\n      }\n\n      public Editor getEditor() {\n        return comboBox.getEditor();\n      }\n\n      public JComponent getEditorComponent() {\n        return comboBox.getEditorComponent();\n      }\n\n      public void doOKAction() {\n        TextWithImports text = comboBox.getText();\n        WatchDebuggerTree.setWatchNodeText(node, text);\n        comboBox.addRecent(text);\n        try {\n          super.doOKAction();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n\n      public void cancelEditing() {\n        try {\n          super.cancelEditing();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n    };\n    editor.show();\n  }","id":40388,"modified_method":"public void editNode(final DebuggerTreeNodeImpl node) {\n    final DebuggerContextImpl context = getContext();\n    final DebuggerExpressionComboBox comboBox = new DebuggerExpressionComboBox(getProject(), PositionUtil.getContextElement(context), \"evaluation\",\n                                                                               DefaultCodeFragmentFactory.getInstance());\n    comboBox.setText(((WatchItemDescriptor)node.getDescriptor()).getEvaluationText());\n    comboBox.selectAll();\n\n    DebuggerTreeInplaceEditor editor = new DebuggerTreeInplaceEditor(node) {\n      public JComponent createInplaceEditorComponent() {\n        return comboBox;\n      }\n\n      public JComponent getPreferredFocusedComponent() {\n        return comboBox.getPreferredFocusedComponent();\n      }\n\n      public Editor getEditor() {\n        return comboBox.getEditor();\n      }\n\n      public JComponent getEditorComponent() {\n        return comboBox.getEditorComponent();\n      }\n\n      public void doOKAction() {\n        if (comboBox.isPopupVisible()) {\n          comboBox.selectPopupValue();\n        }\n\n        TextWithImports text = comboBox.getText();\n        WatchDebuggerTree.setWatchNodeText(node, text);\n        comboBox.addRecent(text);\n        try {\n          super.doOKAction();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n\n      public void cancelEditing() {\n        comboBox.setPopupVisible(false);\n\n        try {\n          super.cancelEditing();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n    };\n    editor.show();\n  }","commit_id":"1e6cf1a00109fe7213564a826d94ad745ae43b58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ComboBox(final ComboBoxModel model, final int minimumAndPreferredWidth) {\n    super(model);\n    myMinimumAndPreferredWidth = minimumAndPreferredWidth;\n    registerCancelOnEscape();\n\n    addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        if (!UIUtil.isUnderNativeMacLookAndFeel()) return;\n\n        if (!isShowing() || !isEditable() || getEditor() == null || !isPopupVisible()) return;\n\n        reconfigureEditor();\n      }\n    });\n  }","id":40389,"modified_method":"public ComboBox(final ComboBoxModel model, final int minimumAndPreferredWidth) {\n    super(model);\n    myMinimumAndPreferredWidth = minimumAndPreferredWidth;\n    registerCancelOnEscape();\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setPopupVisible(final boolean v) {\n    boolean wasVisible = isPopupVisible();\n\n    super.setPopupVisible(v);\n\n    if (v && !wasVisible && !UIUtil.isUnderNativeMacLookAndFeel()) {\n      reconfigureEditor();\n    }\n  }","id":40390,"modified_method":"@Override\n  public void setPopupVisible(boolean v) {\n    if (getModel().getSize() == 0 && v) return;\n\n    final boolean wasShown = isPopupVisible();\n    super.setPopupVisible(v);\n    if (!wasShown && v && isEditable() && !wasShown && !UIManager.getBoolean(\"ComboBox.isEnterSelectablePopup\")) {\n      final ComboBoxEditor editor = getEditor();\n      final Object item = editor.getItem();\n      final Object selectedItem = getSelectedItem();\n      if (item == null || item != selectedItem) {\n        configureEditor(editor, selectedItem);\n      }\n    }\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerExpressionComboBox(Project project, PsiElement context, @NonNls String recentsId, final CodeFragmentFactory factory) {\n    super(project, context, recentsId, factory);\n    myComboBox = new ComboBox(-1);\n    myComboBox.setEditable(true);\n\n    myEditor = new MyEditorComboBoxEditor(getProject(), myFactory.getFileType());\n    myComboBox.setEditor(myEditor);\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n\n    // Have to turn this off because when used in DebuggerTreeInplaceEditor, the combobox popup is hidden on every change of selection\n    // See comment to SynthComboBoxUI.FocusHandler.focusLost()\n    myComboBox.setLightWeightPopupEnabled(false);\n    setLayout(new BorderLayout(0, 0));\n    add(myComboBox);\n\n    setText(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, \"\"));\n    myItem =  createText(\"\");\n    setEnabled(true);\n  }","id":40391,"modified_method":"public DebuggerExpressionComboBox(Project project, PsiElement context, @NonNls String recentsId, final CodeFragmentFactory factory) {\n    super(project, context, recentsId, factory);\n    setLayout(new BorderLayout(0, 0));\n\n    myComboBox = new ComboBox(new MyComboboxModel(getRecents()), -1);\n\n    // Have to turn this off because when used in DebuggerTreeInplaceEditor, the combobox popup is hidden on every change of selection\n    // See comment to SynthComboBoxUI.FocusHandler.focusLost()\n    myComboBox.setLightWeightPopupEnabled(false);\n\n    myEditor = new MyEditorComboBoxEditor(getProject(), myFactory.getFileType());\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n\n    myComboBox.setEditable(true);\n    myComboBox.setEditor(myEditor);\n    add(myComboBox);\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setRecents() {\n    boolean focusOwner = myEditor != null && myEditor.getEditorComponent().isFocusOwner();\n    myComboBox.removeAllItems();\n    if(getRecentsId() != null) {\n      LinkedList<TextWithImports> recents = DebuggerRecents.getInstance(getProject()).getRecents(getRecentsId());\n      ArrayList<TextWithImports> singleLine = new ArrayList<TextWithImports>();\n      for (TextWithImports evaluationText : recents) {\n        if (evaluationText.getText().indexOf('\\n') == -1) {\n          singleLine.add(evaluationText);\n        }\n      }\n      addRecents(singleLine);\n    }\n    if(focusOwner) myEditor.getEditorComponent().requestFocus();\n  }","id":40392,"modified_method":"@Nullable\n  private List<TextWithImports> getRecents() {\n    final String recentsId = getRecentsId();\n    if (recentsId != null) {\n      final List<TextWithImports> result = new ArrayList<TextWithImports>();\n      LinkedList<TextWithImports> recents = DebuggerRecents.getInstance(getProject()).getRecents(getRecentsId());\n      for (final TextWithImports evaluationText : recents) {\n        if (evaluationText.getText().indexOf('\\n') == -1) {\n          result.add(evaluationText);\n        }\n      }\n\n      return result;\n    }\n\n    return null;\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addRecent(TextWithImports text) {\n    super.addRecent(text);\n    setRecents();\n  }","id":40393,"modified_method":"public void addRecent(TextWithImports text) {\n    if (text.getText().length() != 0) {\n      final Component editorComponent = myComboBox.getEditor().getEditorComponent();\n      final boolean focusOwner = editorComponent.isFocusOwner();\n      super.addRecent(text);\n      myComboBox.insertItemAt(text, 0);\n      myComboBox.setSelectedIndex(0);\n\n      if (focusOwner) {\n        editorComponent.requestFocus();\n      }\n    }\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setEnabled(boolean enabled) {\n    myComboBox.setEnabled(enabled);\n\n    if (enabled) {\n      setRecents();\n      myEditor.setItem(myItem);\n    }\n    else {\n      myItem = (TextWithImports)myComboBox.getEditor().getItem();\n      myComboBox.removeAllItems();\n      myComboBox.addItem(myItem);\n    }\n  }","id":40394,"modified_method":"@Override\n  public void setEnabled(boolean enabled) {\n    super.setEnabled(enabled);\n    myComboBox.setEnabled(enabled);\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if(myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n    myItem = item;\n  }","id":40395,"modified_method":"public void setText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void editNode(final DebuggerTreeNodeImpl node) {\n    final DebuggerContextImpl context = getContext();\n    final DebuggerExpressionComboBox comboBox = new DebuggerExpressionComboBox(getProject(), PositionUtil.getContextElement(context), \"evaluation\",\n                                                                               DefaultCodeFragmentFactory.getInstance());\n    comboBox.setText(((WatchItemDescriptor)node.getDescriptor()).getEvaluationText());\n    comboBox.selectAll();\n\n    DebuggerTreeInplaceEditor editor = new DebuggerTreeInplaceEditor(node) {\n      public JComponent createInplaceEditorComponent() {\n        return comboBox;\n      }\n\n      public JComponent getPreferredFocusedComponent() {\n        return comboBox.getPreferredFocusedComponent();\n      }\n\n      public Editor getEditor() {\n        return comboBox.getEditor();\n      }\n\n      public JComponent getEditorComponent() {\n        return comboBox.getEditorComponent();\n      }\n\n      public void doOKAction() {\n        TextWithImports text = comboBox.getText();\n        WatchDebuggerTree.setWatchNodeText(node, text);\n        comboBox.addRecent(text);\n        try {\n          super.doOKAction();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n\n      public void cancelEditing() {\n        try {\n          super.cancelEditing();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n    };\n    editor.show();\n  }","id":40396,"modified_method":"public void editNode(final DebuggerTreeNodeImpl node) {\n    final DebuggerContextImpl context = getContext();\n    final DebuggerExpressionComboBox comboBox = new DebuggerExpressionComboBox(getProject(), PositionUtil.getContextElement(context), \"evaluation\",\n                                                                               DefaultCodeFragmentFactory.getInstance());\n    comboBox.setText(((WatchItemDescriptor)node.getDescriptor()).getEvaluationText());\n    comboBox.selectAll();\n\n    DebuggerTreeInplaceEditor editor = new DebuggerTreeInplaceEditor(node) {\n      public JComponent createInplaceEditorComponent() {\n        return comboBox;\n      }\n\n      public JComponent getPreferredFocusedComponent() {\n        return comboBox.getPreferredFocusedComponent();\n      }\n\n      public Editor getEditor() {\n        return comboBox.getEditor();\n      }\n\n      public JComponent getEditorComponent() {\n        return comboBox.getEditorComponent();\n      }\n\n      public void doOKAction() {\n        if (comboBox.isPopupVisible()) {\n          comboBox.selectPopupValue();\n        }\n\n        TextWithImports text = comboBox.getText();\n        WatchDebuggerTree.setWatchNodeText(node, text);\n        comboBox.addRecent(text);\n        try {\n          super.doOKAction();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n\n      public void cancelEditing() {\n        comboBox.setPopupVisible(false);\n\n        try {\n          super.cancelEditing();\n        }\n        finally {\n          comboBox.dispose();\n        }\n      }\n    };\n    editor.show();\n  }","commit_id":"d164083a23ef55b6aa14fd7bee883bf5fb1eaa78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Destination getSearchWriterDestination(\n\t\tMessageBus messageBus, String searchEngineId,\n\t\tSearchEngine searchEngine) {\n\n\t\tString searchWriterDestinationName =\n\t\t\tSearchEngineUtil.getSearchWriterDestinationName(searchEngineId);\n\n\t\tDestination searchWriterDestination = messageBus.getDestination(\n\t\t\tsearchWriterDestinationName);\n\n\t\tif (searchWriterDestination == null) {\n\t\t\tParallelDestination parallelDestination = new ParallelDestination();\n\n\t\t\tparallelDestination.setName(searchWriterDestinationName);\n\n\t\t\tparallelDestination.open();\n\n\t\t\tsearchWriterDestination = parallelDestination;\n\n\t\t\tmessageBus.addDestination(searchWriterDestination);\n\t\t}\n\n\t\treturn searchWriterDestination;\n\t}","id":40397,"modified_method":"protected Destination getSearchWriterDestination(\n\t\tMessageBus messageBus, String searchEngineId,\n\t\tSearchEngine searchEngine) {\n\n\t\tString searchWriterDestinationName =\n\t\t\tSearchEngineUtil.getSearchWriterDestinationName(searchEngineId);\n\n\t\tDestination searchWriterDestination = messageBus.getDestination(\n\t\t\tsearchWriterDestinationName);\n\n\t\tif (searchWriterDestination == null) {\n\t\t\tsearchWriterDestination = createSearchWriterDestination(\n\t\t\t\tsearchWriterDestinationName);\n\n\t\t\tsearchWriterDestination.open();\n\n\t\t\tmessageBus.addDestination(searchWriterDestination);\n\t\t}\n\n\t\treturn searchWriterDestination;\n\t}","commit_id":"7f5a2d786744d823c49e1d3a9da3b34c6df62d38","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Destination getSearchReaderDestination(\n\t\tMessageBus messageBus, String searchEngineId,\n\t\tSearchEngine searchEngine) {\n\n\t\tString searchReaderDestinationName =\n\t\t\tSearchEngineUtil.getSearchReaderDestinationName(searchEngineId);\n\n\t\tDestination searchReaderDestination = messageBus.getDestination(\n\t\t\tsearchReaderDestinationName);\n\n\t\tif (searchReaderDestination == null) {\n\t\t\tSynchronousDestination synchronousDestination =\n\t\t\t\tnew SynchronousDestination();\n\n\t\t\tsynchronousDestination.setName(searchReaderDestinationName);\n\n\t\t\tsynchronousDestination.open();\n\n\t\t\tsearchReaderDestination = synchronousDestination;\n\n\t\t\tmessageBus.addDestination(searchReaderDestination);\n\t\t}\n\n\t\treturn searchReaderDestination;\n\t}","id":40398,"modified_method":"protected Destination getSearchReaderDestination(\n\t\tMessageBus messageBus, String searchEngineId,\n\t\tSearchEngine searchEngine) {\n\n\t\tString searchReaderDestinationName =\n\t\t\tSearchEngineUtil.getSearchReaderDestinationName(searchEngineId);\n\n\t\tDestination searchReaderDestination = messageBus.getDestination(\n\t\t\tsearchReaderDestinationName);\n\n\t\tif (searchReaderDestination == null) {\n\t\t\tsearchReaderDestination = createSearchReaderDestination(\n\t\t\t\tsearchReaderDestinationName);\n\n\t\t\tsearchReaderDestination.open();\n\n\t\t\tmessageBus.addDestination(searchReaderDestination);\n\t\t}\n\n\t\treturn searchReaderDestination;\n\t}","commit_id":"7f5a2d786744d823c49e1d3a9da3b34c6df62d38","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n        public void configurationUpdated(DestinationRouterConfiguration configurationObject) {\n            contextRouterConfiguration = configurationObject;\n        }","id":40399,"modified_method":"@Override\n        public void configurationUpdated(DestinationRouterConfiguration configurationObject) {\n\n            contextRouterConfiguration = configurationObject;\n\n            if (contextRouterConfiguration == null || configurationObject.getTarget() == null) {\n                LOG.warn(\"Configuration file for Destination router seems to missing or malformed.\");\n            } else {\n                target = contextRouterConfiguration.getTarget();\n\n                determineQuality();\n            }\n        }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    protected RoutingTagger buildHandler() {\n        return new RoutingTagger(contextRouterConfiguration.getTarget());\n    }","id":40400,"modified_method":"@Override\n    protected RoutingTagger buildHandler() {\n        return new RoutingTagger(target.getId(), quality);\n    }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n      final FilterDirector myDirector = new FilterDirectorImpl();\n      myDirector.setFilterAction(FilterAction.PASS);\n\n      myDirector.addDestination(target.getId(), request.getRequestURI(), quality);\n\n      return myDirector;\n   }","id":40401,"modified_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n        final FilterDirector myDirector = new FilterDirectorImpl();\n        myDirector.setFilterAction(FilterAction.PASS);\n\n        if (StringUtilities.isBlank(id)) {\n            LOG.warn(\"No Destination configured for Destination Router\");\n        } else {\n            myDirector.addDestination(id, request.getRequestURI(), quality);\n        }\n\n        return myDirector;\n    }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"public RoutingTagger(Target target) {\n      this.target = target;\n      determineQuality();\n   }","id":40402,"modified_method":"public RoutingTagger(String id, float quality) {\n        this.quality = quality;\n        this.id = id;\n    }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Before\n        public void setUp() {\n\n            powerProxy = new SystemModel();\n            serviceDomain = new ReposeCluster();\n            target = new Target();\n            domainNode = new Node();\n            domainNodeList = new NodeList();\n            destinationEndpoint = new DestinationEndpoint();\n            destinationList = new DestinationList();\n\n            domainNode.setId(\"node1\");\n            domainNode.setHostname(\"localhost\");\n            domainNode.setHttpPort(8888);\n            domainNodeList.getNode().add(domainNode);\n\n            destinationEndpoint.setHostname(\"localhost\");\n            destinationEndpoint.setId(DST);\n            destinationList.getEndpoint().add(destinationEndpoint);\n\n            serviceDomain.setId(\"repose\");\n            serviceDomain.setNodes(domainNodeList);\n            serviceDomain.setDestinations(destinationList);\n\n\n\n            httpServletRequest = mock(HttpServletRequest.class);\n            httpServletResponse = mock(HttpServletResponse.class);\n\n        }","id":40403,"modified_method":"@Before\n        public void setUp() {\n            \n            destinationRouterConfig = new DestinationRouterConfiguration();\n            factory = new DestinationRouterHandlerFactory();\n            \n            powerProxy = new SystemModel();\n            serviceDomain = new ReposeCluster();\n            target = new Target();\n            domainNode = new Node();\n            domainNodeList = new NodeList();\n            destinationEndpoint = new DestinationEndpoint();\n            destinationList = new DestinationList();\n\n            domainNode.setId(\"node1\");\n            domainNode.setHostname(\"localhost\");\n            domainNode.setHttpPort(8888);\n            domainNodeList.getNode().add(domainNode);\n\n            destinationEndpoint.setHostname(\"localhost\");\n            destinationEndpoint.setId(DST);\n            destinationList.getEndpoint().add(destinationEndpoint);\n\n            serviceDomain.setId(\"repose\");\n            serviceDomain.setNodes(domainNodeList);\n            serviceDomain.setDestinations(destinationList);\n            \n            destinationRouterConfig.setTarget(target);\n            factory.configurationUpdated(destinationRouterConfig);\n\n\n            httpServletRequest = mock(HttpServletRequest.class);\n            httpServletResponse = mock(HttpServletResponse.class);\n\n        }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n        public void shouldAddRoute() {\n            target.setId(\"dst1\");\n            routingTagger = new RoutingTagger(target);\n            FilterDirector director = new FilterDirectorImpl();\n\n            director = routingTagger.handleRequest(httpServletRequest, null);\n            assertEquals(\"Director should have the targeted destination\", director.getDestinations().get(0).getDestinationId(), DST);\n        }","id":40404,"modified_method":"@Test\n        public void shouldAddRoute() {\n            target.setId(\"dst1\");\n            routingTagger = factory.buildHandler();\n            FilterDirector director = new FilterDirectorImpl();\n\n            director = routingTagger.handleRequest(httpServletRequest, null);\n            assertEquals(\"Director should have the targeted destination\", director.getDestinations().get(0).getDestinationId(), DST);\n        }","commit_id":"f32cd112973c49c4d8ae0435d6c6759e5996a26f","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tString responseDestinationName = message.getResponseDestinationName();\n\n\t\tRunnable runnable = (Runnable)message.getPayload();\n\n\t\ttry {\n\t\t\trunnable.run();\n\t\t}\n\t\tcatch (RuntimeException re) {\n\t\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(re, re);\n\t\t\t\t}\n\t\t\t\telse if (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(re, re);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\tMessage responseMessage = MessageBusUtil.createResponseMessage(\n\t\t\t\tmessage);\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tresponseDestinationName, responseMessage);\n\t\t}\n\t}","id":40405,"modified_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tString responseDestinationName = message.getResponseDestinationName();\n\n\t\tRunnable runnable = (Runnable)message.getPayload();\n\n\t\ttry {\n\t\t\trunnable.run();\n\t\t}\n\t\tcatch (RuntimeException re) {\n\t\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(re, re);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(responseDestinationName)) {\n\t\t\tMessage responseMessage = MessageBusUtil.createResponseMessage(\n\t\t\t\tmessage);\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tresponseDestinationName, responseMessage);\n\t\t}\n\t}","commit_id":"8766e341f1f3a1c02eb48bdc0176c9bc4af84864","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void enableSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif (messageBus.hasDestination(_TARGET_ASYNC_DESTINATION_NAME)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_oldAsyncDestination = (BaseDestination)messageBus.getDestination(\n\t\t\t\tDestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(\n\t\t\t\tnew SynchronizedAsyncDestination(\n\t\t\t\t\t_TARGET_ASYNC_DESTINATION_NAME));\n\n\t\t\t_oldAsyncDestination.setName(_TARGET_ASYNC_DESTINATION_NAME);\n\n\t\t\tMessageBusUtil.addDestination(_oldAsyncDestination);\n\t\t}","id":40406,"modified_method":"public void enableSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif (messageBus.hasDestination(\n\t\t\t\t\t_ASYNC_SERVICE_TEMP_DESTINATION_NAME)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_asyncServiceDestination =\n\t\t\t\t(BaseDestination)messageBus.getDestination(\n\t\t\t\t\tDestinationNames.ASYNC_SERVICE);\n\n\t\t\tSynchronizedAsyncServiceDestination\n\t\t\t\tsynchronizedAsyncServiceDestination =\n\t\t\t\t\tnew SynchronizedAsyncServiceDestination(\n\t\t\t\t\t\t_ASYNC_SERVICE_TEMP_DESTINATION_NAME);\n\n\t\t\tsynchronizedAsyncServiceDestination.setName(\n\t\t\t\tDestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(synchronizedAsyncServiceDestination);\n\n\t\t\t_asyncServiceDestination.setName(\n\t\t\t\t_ASYNC_SERVICE_TEMP_DESTINATION_NAME);\n\n\t\t\tMessageBusUtil.addDestination(_asyncServiceDestination);\n\t\t}","commit_id":"8766e341f1f3a1c02eb48bdc0176c9bc4af84864","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void restorePreviousSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif ((_oldAsyncDestination == null) ||\n\t\t\t\t!messageBus.hasDestination(_TARGET_ASYNC_DESTINATION_NAME)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCollection<Destination> destinations = messageBus.getDestinations();\n\n\t\t\tdestinations.remove(_oldAsyncDestination);\n\n\t\t\tMessageBusUtil.removeDestination(DestinationNames.ASYNC_SERVICE);\n\n\t\t\t_oldAsyncDestination.setName(DestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(_oldAsyncDestination);\n\t\t}","id":40407,"modified_method":"public void restorePreviousSync() {\n\t\t\tif (_sync == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProxyModeThreadLocal.setForceSync(_forceSync);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tif ((_asyncServiceDestination == null) ||\n\t\t\t\t!messageBus.hasDestination(\n\t\t\t\t\t_ASYNC_SERVICE_TEMP_DESTINATION_NAME)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCollection<Destination> destinations = messageBus.getDestinations();\n\n\t\t\tdestinations.remove(_asyncServiceDestination);\n\n\t\t\tMessageBusUtil.removeDestination(DestinationNames.ASYNC_SERVICE);\n\n\t\t\t_asyncServiceDestination.setName(DestinationNames.ASYNC_SERVICE);\n\n\t\t\tMessageBusUtil.addDestination(_asyncServiceDestination);\n\t\t}","commit_id":"8766e341f1f3a1c02eb48bdc0176c9bc4af84864","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object send() throws MessageBusException {\n\t\tString destinationName = _message.getDestinationName();\n\t\tString responseDestinationName = _message.getResponseDestinationName();\n\n\t\t_messageBus.registerMessageListener(responseDestinationName, this);\n\n\t\ttry {\n\t\t\tsynchronized (this) {\n\t\t\t\t_messageBus.sendMessage(destinationName, _message);\n\n\t\t\t\twait(_timeout);\n\n\t\t\t\tif (_results == null) {\n\t\t\t\t\tthrow new MessageBusException(\n\t\t\t\t\t\t\"No reply received for message: \" + _message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_results == _NULL_RESPONSE) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn _results;\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\tthrow new MessageBusException(\n\t\t\t\t\"Message sending interrupted for: \" + _message, ie);\n\t\t}\n\t\tfinally {\n\t\t\t_messageBus.unregisterMessageListener(\n\t\t\t\tresponseDestinationName, this);\n\n\t\t\tEntityCacheUtil.clearLocalCache();\n\t\t\tFinderCacheUtil.clearLocalCache();\n\t\t\tThreadLocalCacheManager.destroy();\n\t\t}\n\t}","id":40408,"modified_method":"public Object send() throws MessageBusException {\n\t\tString destinationName = _message.getDestinationName();\n\t\tString responseDestinationName = _message.getResponseDestinationName();\n\n\t\t_messageBus.registerMessageListener(responseDestinationName, this);\n\n\t\ttry {\n\t\t\tsynchronized (this) {\n\t\t\t\t_messageBus.sendMessage(destinationName, _message);\n\n\t\t\t\twait(_timeout);\n\n\t\t\t\tif (_results == null) {\n\t\t\t\t\tthrow new MessageBusException(\n\t\t\t\t\t\t\"No reply received for message: \" + _message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_results == _NULL_RESULTS) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn _results;\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\tthrow new MessageBusException(\n\t\t\t\t\"Message sending interrupted for: \" + _message, ie);\n\t\t}\n\t\tfinally {\n\t\t\t_messageBus.unregisterMessageListener(\n\t\t\t\tresponseDestinationName, this);\n\n\t\t\tEntityCacheUtil.clearLocalCache();\n\t\t\tFinderCacheUtil.clearLocalCache();\n\t\t\tThreadLocalCacheManager.destroy();\n\t\t}\n\t}","commit_id":"8766e341f1f3a1c02eb48bdc0176c9bc4af84864","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void receive(Message message) {\n\t\tif (!message.getResponseId().equals(_responseId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tif (message.getPayload() == null) {\n\t\t\t\t_results = _NULL_RESPONSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_results = message.getPayload();\n\t\t\t}\n\n\t\t\tnotify();\n\t\t}\n\t}","id":40409,"modified_method":"@Override\n\tpublic void receive(Message message) {\n\t\tif (!message.getResponseId().equals(_responseId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tif (message.getPayload() == null) {\n\t\t\t\t_results = _NULL_RESULTS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_results = message.getPayload();\n\t\t\t}\n\n\t\t\tnotify();\n\t\t}\n\t}","commit_id":"8766e341f1f3a1c02eb48bdc0176c9bc4af84864","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(groups=\"Live\")\n    public void testPostgresScriptAndAccess() throws Exception {\n        ChefLiveTestSupport.installBrooklynChefHostedConfig(app);\n        PortRange randomPort = PortRanges.fromString(\"\"+(5420+new Random().nextInt(10))+\"+\");\n        psql = app.createAndManageChild(PostgreSqlSpecs.specChef()\n                .configure(PostgreSqlNode.CREATION_SCRIPT_CONTENTS, PostgreSqlIntegrationTest.CREATION_SCRIPT)\n                .configure(PostgreSqlNode.POSTGRESQL_PORT, randomPort)\n            );\n\n        app.start(ImmutableList.of(targetLocation));\n\n        String url = psql.getAttribute(PostgreSqlNode.DB_URL);\n        log.info(\"Trying to connect to \"+psql+\" at \"+url);\n        Assert.assertNotNull(url);\n        Assert.assertTrue(url.contains(\"542\"));\n        \n        new VogellaExampleAccess(\"org.postgresql.Driver\", url).readModifyAndRevertDataBase();\n    }","id":40410,"modified_method":"@Test(groups=\"Live\")\n    public void testPostgresScriptAndAccess() throws Exception {\n        ChefLiveTestSupport.installBrooklynChefHostedConfig(app);\n        PortRange randomPort = PortRanges.fromString(\"\"+(5420+new Random().nextInt(10))+\"+\");\n        psql = app.createAndManageChild(PostgreSqlSpecs.specChef()\n                .configure(PostgreSqlNode.CREATION_SCRIPT_CONTENTS, PostgreSqlIntegrationTest.CREATION_SCRIPT)\n                .configure(PostgreSqlNode.POSTGRESQL_PORT, randomPort)\n            );\n\n        app.start(ImmutableList.of(targetLocation));\n\n        String url = psql.getAttribute(PostgreSqlNode.DATASTORE_URL);\n        log.info(\"Trying to connect to \"+psql+\" at \"+url);\n        Assert.assertNotNull(url);\n        Assert.assertTrue(url.contains(\"542\"));\n        \n        new VogellaExampleAccess(\"org.postgresql.Driver\", url).readModifyAndRevertDataBase();\n    }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected void doTest(Location loc) throws Exception {\n        PostgreSqlNode psql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class)\n                .configure(\"creationScriptContents\", PostgreSqlIntegrationTest.CREATION_SCRIPT));\n\n        app.start(ImmutableList.of(loc));\n\n        new VogellaExampleAccess(\"org.postgresql.Driver\", psql.getAttribute(PostgreSqlNode.DB_URL)).readModifyAndRevertDataBase();\n    }","id":40411,"modified_method":"@Override\n    protected void doTest(Location loc) throws Exception {\n        PostgreSqlNode psql = app.createAndManageChild(EntitySpec.create(PostgreSqlNode.class)\n                .configure(\"creationScriptContents\", PostgreSqlIntegrationTest.CREATION_SCRIPT));\n\n        app.start(ImmutableList.of(loc));\n\n        new VogellaExampleAccess(\"org.postgresql.Driver\", psql.getAttribute(PostgreSqlNode.DATASTORE_URL)).readModifyAndRevertDataBase();\n    }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void startWithKnifeAsync() {\n            Entities.warnOnIgnoringConfig(entity(), ChefConfig.CHEF_RUN_LIST);\n            Entities.warnOnIgnoringConfig(entity(), ChefConfig.CHEF_LAUNCH_ATTRIBUTES);\n            \n            DynamicTasks.queue(\n                    ChefServerTasks\n                        .knifeConvergeRunList(\"postgresql::server\")\n                        .knifeAddAttributes(Jsonya\n                            .at(\"postgresql\", \"config\").add(\n                                \"port\", entity().getAttribute(PostgreSqlNode.POSTGRESQL_PORT), \n                                \"listen_addresses\", \"*\").getRootMap())\n                        .knifeAddAttributes(Jsonya\n                            .at(\"postgresql\", \"pg_hba\").list().map().add(\n                                \"type\", \"host\", \"db\", \"all\", \"user\", \"all\", \n                                \"addr\", \"0.0.0.0/0\", \"method\", \"md5\").getRootMap()) \n                        // no other arguments currenty supported; chef will pick a password for us\n                );\n        }","id":40412,"modified_method":"protected void startWithKnifeAsync() {\n            Entities.warnOnIgnoringConfig(entity(), ChefConfig.CHEF_RUN_LIST);\n            Entities.warnOnIgnoringConfig(entity(), ChefConfig.CHEF_LAUNCH_ATTRIBUTES);\n            \n            DynamicTasks.queue(\n                    ChefServerTasks\n                        .knifeConvergeRunList(\"postgresql::server\")\n                        .knifeAddAttributes(Jsonya\n                            .at(\"postgresql\", \"config\").add(\n                                \"port\", entity().getPostgreSqlPort(), \n                                \"listen_addresses\", \"*\").getRootMap())\n                        .knifeAddAttributes(Jsonya\n                            .at(\"postgresql\", \"pg_hba\").list().map().add(\n                                \"type\", \"host\", \"db\", \"all\", \"user\", \"all\", \n                                \"addr\", \"0.0.0.0/0\", \"method\", \"md5\").getRootMap()) \n                        // no other arguments currenty supported; chef will pick a password for us\n                );\n        }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void postStartCustom() {\n            super.postStartCustom();\n\n            // now run the creation script\n            String creationScript;\n            String creationScriptUrl = entity().getConfig(PostgreSqlNode.CREATION_SCRIPT_URL);\n            if (creationScriptUrl != null)\n                creationScript = ResourceUtils.create(entity()).getResourceAsString(creationScriptUrl);\n            else creationScript = entity().getConfig(PostgreSqlNode.CREATION_SCRIPT_CONTENTS);\n            entity().invoke(PostgreSqlNodeChefImpl.EXECUTE_SCRIPT, \n                    ConfigBag.newInstance().configure(ExecuteScriptEffectorBody.SCRIPT, creationScript).getAllConfig()).getUnchecked();\n\n            // and finally connect sensors\n            ((PostgreSqlNodeChefImpl)entity()).connectSensors();\n        }","id":40413,"modified_method":"protected void postStartCustom() {\n            super.postStartCustom();\n\n            // now run the creation script\n            String creationScript;\n            String creationScriptUrl = entity().getConfig(PostgreSqlNode.CREATION_SCRIPT_URL);\n            if (creationScriptUrl != null) {\n                creationScript = ResourceUtils.create(entity()).getResourceAsString(creationScriptUrl);\n            } else {\n                creationScript = entity().getConfig(PostgreSqlNode.CREATION_SCRIPT_CONTENTS);\n            }\n            entity().executeScript(creationScript);\n\n            // and finally connect sensors\n            entity().connectSensors();\n        }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void preStopCustom() {\n            ((PostgreSqlNodeChefImpl)entity()).disconnectSensors();\n            super.preStopCustom();\n        }","id":40414,"modified_method":"protected void preStopCustom() {\n            entity().disconnectSensors();\n            super.preStopCustom();\n        }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n        // Some OSes start postgres during package installation\n        DynamicTasks.queue(SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"/etc/init.d/postgresql stop\"))).get();\n\n        newScript(CUSTOMIZING)\n                .body.append(\n                        sudo(\"mkdir -p \" + getDataDir()),\n                        sudo(\"chown postgres:postgres \" + getDataDir()),\n                        sudo(\"chmod 700 \" + getDataDir()),\n                        sudo(\"touch \" + getLogFile()),\n                        sudo(\"chown postgres:postgres \" + getLogFile()),\n                        sudo(\"touch \" + getPidFile()),\n                        sudo(\"chown postgres:postgres \" + getPidFile()),\n                        callPgctl(\"initdb\", true))\n                .failOnNonZeroResultCode()\n                .execute();\n\n        String configUrl = getEntity().getConfig(PostgreSqlNode.CONFIGURATION_FILE_URL);\n        if (Strings.isBlank(configUrl)) {\n            DynamicTasks.queue(SshEffectorTasks.ssh(\n                    executeCommandThenAsUserTeeOutputToFile(\n                            chainGroup(\n                                    \"echo \\\"listen_addresses = '*'\\\"\",\n                                    \"echo \\\"port = \" + getPostgreSqlPort() +  \"\\\"\",\n                                    \"echo \\\"external_pid_file = \" + getRunDir() + \"/postgresql.pid\" +  \"\\\"\"),\n                            \"postgres\", getDataDir() + \"/postgresql.conf\")));\n        } else {\n            String contents = processTemplate(configUrl);\n            DynamicTasks.queue(\n                    SshEffectorTasks.put(\"/tmp/postgresql.conf\").contents(contents),\n                    SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"cp /tmp/postgresql.conf \" + getDataDir() + \"/postgresql.conf\")));\n        }\n\n        String authConfigUrl = getEntity().getConfig(PostgreSqlNode.AUTHENTICATION_CONFIGURATION_FILE_URL);\n        if (Strings.isBlank(authConfigUrl)) {\n            DynamicTasks.queue(SshEffectorTasks.ssh(\n                    // TODO give users control which hosts can connect and the authentication mechanism\n                    executeCommandThenAsUserTeeOutputToFile(\"echo \\\"host all all 0.0.0.0/0 md5\\\"\", \"postgres\", getDataDir() + \"/pg_hba.conf\")));\n        } else {\n            String contents = processTemplate(authConfigUrl);\n            DynamicTasks.queue(\n                    SshEffectorTasks.put(\"/tmp/pg_hba.conf\").contents(contents),\n                    SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"cp /tmp/pg_hba.conf \" + getDataDir() + \"/pg_hba.conf\")));\n        }\n\n        // Wait for commands to complete before running the creation script\n        DynamicTasks.waitForLast();\n\n        executeDatabaseCreationScript();\n\n        // Try establishing an external connection. If you get a \"Connection refused...accepting TCP/IP connections\n        // on port 5432?\" error then the port is probably closed. Check that the firewall allows external TCP/IP\n        // connections (netstat -nap). You can open a port with lokkit or by configuring the iptables.\n    }","id":40415,"modified_method":"@Override\n    public void customize() {\n        // Some OSes start postgres during package installation\n        DynamicTasks.queue(SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"/etc/init.d/postgresql stop\"))).get();\n\n        newScript(CUSTOMIZING)\n                .body.append(\n                        sudo(\"mkdir -p \" + getDataDir()),\n                        sudo(\"chown postgres:postgres \" + getDataDir()),\n                        sudo(\"chmod 700 \" + getDataDir()),\n                        sudo(\"touch \" + getLogFile()),\n                        sudo(\"chown postgres:postgres \" + getLogFile()),\n                        sudo(\"touch \" + getPidFile()),\n                        sudo(\"chown postgres:postgres \" + getPidFile()),\n                        callPgctl(\"initdb\", true))\n                .failOnNonZeroResultCode()\n                .execute();\n\n        String configUrl = getEntity().getConfig(PostgreSqlNode.CONFIGURATION_FILE_URL);\n        if (Strings.isBlank(configUrl)) {\n            // http://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server\n            // If the same setting is listed multiple times, the last one wins.\n            DynamicTasks.queue(SshEffectorTasks.ssh(\n                    executeCommandThenAsUserTeeOutputToFile(\n                            chainGroup(\n                                    \"echo \\\"listen_addresses = '*'\\\"\",\n                                    \"echo \\\"port = \" + getEntity().getPostgreSqlPort() +  \"\\\"\",\n                                    \"echo \\\"max_connections = \" + getEntity().getMaxConnections() +  \"\\\"\",\n                                    \"echo \\\"shared_buffers = \" + getEntity().getSharedMemory() +  \"\\\"\",\n                                    \"echo \\\"external_pid_file = \" + getRunDir() + \"/postgresql.pid\" +  \"\\\"\"),\n                            \"postgres\", getDataDir() + \"/postgresql.conf\")));\n        } else {\n            String contents = processTemplate(configUrl);\n            DynamicTasks.queue(\n                    SshEffectorTasks.put(\"/tmp/postgresql.conf\").contents(contents),\n                    SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"cp /tmp/postgresql.conf \" + getDataDir() + \"/postgresql.conf\")));\n        }\n\n        String authConfigUrl = getEntity().getConfig(PostgreSqlNode.AUTHENTICATION_CONFIGURATION_FILE_URL);\n        if (Strings.isBlank(authConfigUrl)) {\n            DynamicTasks.queue(SshEffectorTasks.ssh(\n                    // TODO give users control which hosts can connect and the authentication mechanism\n                    executeCommandThenAsUserTeeOutputToFile(\"echo \\\"host all all 0.0.0.0/0 md5\\\"\", \"postgres\", getDataDir() + \"/pg_hba.conf\")));\n        } else {\n            String contents = processTemplate(authConfigUrl);\n            DynamicTasks.queue(\n                    SshEffectorTasks.put(\"/tmp/pg_hba.conf\").contents(contents),\n                    SshEffectorTasks.ssh(sudoAsUser(\"postgres\", \"cp /tmp/pg_hba.conf \" + getDataDir() + \"/pg_hba.conf\")));\n        }\n\n        // Wait for commands to complete before running the creation script\n        DynamicTasks.waitForLast();\n\n        executeDatabaseCreationScript();\n\n        // Try establishing an external connection. If you get a \"Connection refused...accepting TCP/IP connections\n        // on port 5432?\" error then the port is probably closed. Check that the firewall allows external TCP/IP\n        // connections (netstat -nap). You can open a port with lokkit or by configuring the iptables.\n    }","commit_id":"b4d8ab48e939f4e564a1097028359c51a6ff9d88","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void stop() {\n        // TODO See comment in SoftwareProcessImpl.stop about race where we set \n        // SERVICE_UP=false while sensor-adapter threads may still be polling.\n        \n        if (getAttribute(SERVICE_STATE)==Lifecycle.STOPPED) {\n            log.warn(\"Skipping stop of software process entity \"+this+\" when already stopped\");\n            return;\n        }\n        \n        log.info(\"Stopping {} in {}\", this, getLocations());\n        setAttribute(SERVICE_STATE, Lifecycle.STOPPING);\n        setAttribute(SERVICE_UP, false);\n        \n        StartableMethods.stop(this);\n        \n        MachineLocation machine = removeFirstMachineLocation();\n        if (machine != null) {\n            stopInLocation(machine);\n        }\n        setAttribute(HOSTNAME, null);\n        setAttribute(ADDRESS, null);\n        setAttribute(SERVICE_UP, false);\n        setAttribute(SERVICE_STATE, Lifecycle.STOPPED);\n        if (log.isDebugEnabled()) log.debug(\"Stopped software process entity \"+this);\n    }","id":40416,"modified_method":"@Override\n    public void stop() {\n        LIFECYCLE_TASKS.stop();\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        checkNotNull(locations, \"locations\");\n        setAttribute(SERVICE_STATE, Lifecycle.STARTING);\n        try {\n            startInLocation(locations);\n            \n            if (getAttribute(SERVICE_STATE) == Lifecycle.STARTING) \n                setAttribute(SERVICE_STATE, Lifecycle.RUNNING);\n        } catch (Throwable t) {\n            setAttribute(SERVICE_STATE, Lifecycle.ON_FIRE);\n            throw Exceptions.propagate(t);\n        }\n    }","id":40417,"modified_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        checkNotNull(locations, \"locations\");\n        LIFECYCLE_TASKS.start(locations);\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void restart() {\n        Collection<Location> locations = getLocations();\n        stop();\n        start(locations);\n    }","id":40418,"modified_method":"@Override\n    public void restart() {\n        LIFECYCLE_TASKS.restart();\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected void preStartCustom(MachineLocation machine) {\n        entity().initDriver(machine);\n\n        // Note: must only apply config-sensors after adding to locations and creating driver; \n        // otherwise can't do things like acquire free port from location, or allowing driver to set up ports\n        super.preStartCustom(machine);\n        \n        ((SoftwareProcessImpl)entity()).preStart(); \n    }","id":40419,"modified_method":"@Override\n    protected void preStartCustom(MachineLocation machine) {\n        entity().initDriver(machine);\n\n        // Note: must only apply config-sensors after adding to locations and creating driver; \n        // otherwise can't do things like acquire free port from location, or allowing driver to set up ports\n        super.preStartCustom(machine);\n        \n        entity().preStart();\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected void preStopCustom() {\n        super.preStopCustom();\n        \n        ((SoftwareProcessImpl)entity()).preStop(); \n    }","id":40420,"modified_method":"@Override\n    protected void preStopCustom() {\n        super.preStopCustom();\n        \n        entity().preStop();\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void restart() {\n        // children are ignored during restart currently - see ChildStartableMode\n        \n        if (((SoftwareProcessImpl)entity()).getDriver() == null) { \n            log.debug(\"restart of \"+entity()+\" has no driver - doing machine-level restart\");\n            super.restart();\n            return;\n        }\n        \n        if (Strings.isEmpty(entity().getAttribute(Attributes.HOSTNAME))) {\n            log.debug(\"restart of \"+entity()+\" has no hostname - doing machine-level restart\");\n            super.restart();\n            return;\n        }\n        \n        log.debug(\"restart of \"+entity()+\" appears to have driver and hostname - doing driver-level restart\");\n        ((SoftwareProcessImpl)entity()).getDriver().restart();\n        DynamicTasks.queue(\"post-restart\", new Runnable() { public void run() {\n            postStartCustom();\n            if (entity().getAttribute(Attributes.SERVICE_STATE) == Lifecycle.STARTING) \n                entity().setAttribute(Attributes.SERVICE_STATE, Lifecycle.RUNNING);\n        }});\n    }","id":40421,"modified_method":"@Override\n    public void restart() {\n        // children are ignored during restart currently - see ChildStartableMode\n        \n        if (entity().getDriver() == null) {\n            log.debug(\"restart of \"+entity()+\" has no driver - doing machine-level restart\");\n            super.restart();\n            return;\n        }\n        \n        if (Strings.isEmpty(entity().getAttribute(Attributes.HOSTNAME))) {\n            log.debug(\"restart of \"+entity()+\" has no hostname - doing machine-level restart\");\n            super.restart();\n            return;\n        }\n        \n        log.debug(\"restart of \"+entity()+\" appears to have driver and hostname - doing driver-level restart\");\n        entity().getDriver().restart();\n        DynamicTasks.queue(\"post-restart\", new Runnable() { public void run() {\n            postStartCustom();\n            if (entity().getAttribute(Attributes.SERVICE_STATE) == Lifecycle.STARTING) \n                entity().setAttribute(Attributes.SERVICE_STATE, Lifecycle.RUNNING);\n        }});\n    }","commit_id":"0ff7118a8a137b11543d24119e0acb52cb5cf5cc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void run() {\n      if (isDisabled()) return;\n\n      if (!myVirtualFile.isValid()) {\n        log(\"installTracker() for file \" + myVirtualFile.getPath() + \" failed: virtual file not valid\");\n        reportTrackerBaseLoadFailed();\n        return;\n      }\n\n      final VcsRevisionNumber baseRevision = myStatusProvider.getBaseRevision(myVirtualFile);\n      if (baseRevision == null) {\n        log(\"installTracker() for file \" + myVirtualFile.getPath() + \" failed: null returned for base revision number\");\n        reportTrackerBaseLoadFailed();\n        return;\n      }\n      // loads are sequential (in single threaded QueueProcessor);\n      // so myLoadCounter can't take less value for greater base revision -> the only thing we want from it\n      final LineStatusTracker.RevisionPack revisionPack = new LineStatusTracker.RevisionPack(myLoadCounter, baseRevision);\n      ++myLoadCounter;\n\n      final String lastUpToDateContent = myStatusProvider.getBaseVersionContent(myVirtualFile);\n      if (lastUpToDateContent == null) {\n        log(\"installTracker() for file \" + myVirtualFile.getPath() + \" failed: no up to date content\");\n        reportTrackerBaseLoadFailed();\n        return;\n      }\n\n      final String converted = StringUtil.convertLineSeparators(lastUpToDateContent);\n      final Runnable runnable = new Runnable() {\n        public void run() {\n          synchronized (myLock) {\n            log(\"initializing tracker for file \" + myVirtualFile.getPath());\n            final LineStatusTracker tracker = myLineStatusTrackers.get(myDocument);\n            if (tracker != null) {\n              tracker.initialize(converted, revisionPack);\n            }\n          }\n        }\n      };\n      nonModalAliveInvokeLater(runnable);\n    }","id":40422,"modified_method":"@Override\n    public void run() {\n      if (isDisabled()) return;\n\n      if (!myVirtualFile.isValid()) {\n        log(\"installTracker() for file \" + myVirtualFile.getPath() + \" failed: virtual file not valid\");\n        reportTrackerBaseLoadFailed();\n        return;\n      }\n\n      final Pair<VcsRevisionNumber, String> baseRevision = myStatusProvider.getBaseRevision(myVirtualFile);\n      if (baseRevision == null) {\n        log(\"installTracker() for file \" + myVirtualFile.getPath() + \" failed: null returned for base revision number\");\n        reportTrackerBaseLoadFailed();\n        return;\n      }\n\n      // loads are sequential (in single threaded QueueProcessor);\n      // so myLoadCounter can't take less value for greater base revision -> the only thing we want from it\n      final LineStatusTracker.RevisionPack revisionPack = new LineStatusTracker.RevisionPack(myLoadCounter, baseRevision.first);\n      ++myLoadCounter;\n\n      final String converted = StringUtil.convertLineSeparators(baseRevision.second);\n      final Runnable runnable = new Runnable() {\n        public void run() {\n          synchronized (myLock) {\n            log(\"initializing tracker for file \" + myVirtualFile.getPath());\n            final LineStatusTracker tracker = myLineStatusTrackers.get(myDocument);\n            if (tracker != null) {\n              tracker.initialize(converted, revisionPack);\n            }\n          }\n        }\n      };\n      nonModalAliveInvokeLater(runnable);\n    }","commit_id":"a19892b2b85f0db79f3598c3fde8d0282bbcf357","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public VcsRevisionNumber getBaseRevision(VirtualFile file) {\n    final Change change = ChangeListManager.getInstance(myProject).getChange(file);\n    if (change != null && change.getBeforeRevision() != null && (! FileStatus.ADDED.equals(change.getFileStatus()))) {\n      return change.getBeforeRevision().getRevisionNumber();\n    }\n    return null;\n  }","id":40423,"modified_method":"@Override\n  @Nullable\n  public Pair<VcsRevisionNumber, String> getBaseRevision(@NotNull final VirtualFile file) {\n    final Change change = ChangeListManager.getInstance(myProject).getChange(file);\n    if (change != null) {\n      final ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision instanceof BinaryContentRevision) return null;\n      if (beforeRevision != null) {\n        String content;\n        try {\n          content = beforeRevision.getContent();\n        }\n        catch (VcsException ex) {\n          content = null;\n        }\n        if (content == null) {\n          myHaveEmptyContentRevisions = true;\n          return null;\n        }\n        return Pair.create(beforeRevision.getRevisionNumber(), content);\n      }\n      return null;\n    }\n\n    if (isDocumentModified(file)) {\n      String content = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        @Override\n        public String compute() {\n          return LoadTextUtil.loadText(file).toString();\n        }\n      });\n      return Pair.create(VcsRevisionNumber.NULL, content);\n    }\n\n    return null;\n  }","commit_id":"a19892b2b85f0db79f3598c3fde8d0282bbcf357","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private FilePath getLocalPath(final String path, final NotNullFunction<File, Boolean> detector) {\n    final String fullPath = myRepositoryRoot + path;\n    return myLocation.getLocalPath(fullPath, detector, myVcs);\n  }","id":40424,"modified_method":"@Nullable\n  private FilePath getLocalPath(final String path, final NotNullFunction<File, Boolean> detector) {\n    return SvnRepositoryLocation.getLocalPath(myRepositoryRoot + path, detector, myVcs);\n  }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void uploadDeletedRenamedChildren() throws SVNException {\n      // cannot insert when iterate\n      final List<Change> detailsOnly = new ArrayList<Change>();\n\n      final Set<Pair<Boolean, String>> duplicateControl = new HashSet<Pair<Boolean, String>>();\n      for (Change change : myDetailedList) {\n        if (change.getBeforeRevision() != null) {\n          duplicateControl.add(Pair.create(Boolean.TRUE, ((SvnRepositoryContentRevision)change.getBeforeRevision()).getRelativePath(\n            myRepositoryRoot)));\n        }\n        if (change.getAfterRevision() != null) {\n          duplicateControl.add(Pair.create(Boolean.FALSE, ((SvnRepositoryContentRevision) change.getAfterRevision()).getRelativePath(\n            myRepositoryRoot)));\n        }\n      }\n\n      final List<Change> preprocessed = ChangesPreprocess.preprocessChangesRemoveDeletedForDuplicateMoved(myDetailedList);\n\n      for (Change change : preprocessed) {\n        // directory statuses are already uploaded\n        if ((change.getAfterRevision() == null) && (change.getBeforeRevision().getFile().isDirectory())) {\n          final SvnRepositoryContentRevision revision = (SvnRepositoryContentRevision) change.getBeforeRevision();\n          detailsOnly.addAll(getChildrenAsChanges(revision.getRelativePath(myRepositoryRoot), true, duplicateControl));\n        } else if ((change.getBeforeRevision() == null) && (change.getAfterRevision().getFile().isDirectory())) {\n          // look for renamed folders contents\n          final SvnRepositoryContentRevision revision = (SvnRepositoryContentRevision) change.getAfterRevision();\n          if (myCopiedAddedPaths.containsKey(revision.getRelativePath(myRepositoryRoot))) {\n            detailsOnly.addAll(getChildrenAsChanges(revision.getRelativePath(myRepositoryRoot), false, duplicateControl));\n          }\n        } else if ((change.isIsReplaced() || change.isMoved() || change.isRenamed()) && change.getAfterRevision().getFile().isDirectory()) {\n          final SvnRepositoryContentRevision beforeRevision = (SvnRepositoryContentRevision) change.getBeforeRevision();\n          detailsOnly.addAll(getChildrenAsChanges(beforeRevision.getRelativePath(myRepositoryRoot), true, duplicateControl));\n\n          final SvnRepositoryContentRevision revision = (SvnRepositoryContentRevision) change.getAfterRevision();\n          detailsOnly.addAll(getChildrenAsChanges(revision.getRelativePath(myRepositoryRoot), false, duplicateControl));\n        }\n      }\n\n      myDetailedList.addAll(detailsOnly);\n    }","id":40425,"modified_method":"private void uploadDeletedRenamedChildren() throws SVNException {\n      Set<Pair<Boolean, String>> duplicates = collectDuplicates();\n      List<Change> preprocessed = ChangesPreprocess.preprocessChangesRemoveDeletedForDuplicateMoved(myDetailedList);\n\n      myDetailedList.addAll(collectDetails(preprocessed, duplicates));\n    }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Change> getDetailedList() {\n      if (myDetailedList == null) {\n        myDetailedList = new ArrayList<Change>(myList);\n\n        try {\n          myRepository = myVcs.createRepository(myRepositoryRoot);\n\n          doRemoteDetails();\n          uploadDeletedRenamedChildren();\n          // remove duplicates\n          final HashSet<Change> set = new HashSet<Change>(myDetailedList);\n          myDetailedList.clear();\n          myDetailedList.addAll(set);\n        }\n        catch (SVNException e) {\n          LOG.info(e);\n        } finally {\n          if (myRepository != null) {\n            myRepository.closeSession();\n            myRepository = null;\n          }\n        }\n      }\n      return myDetailedList;\n    }","id":40426,"modified_method":"public List<Change> getDetailedList() {\n      if (myDetailedList == null) {\n        myDetailedList = new ArrayList<Change>(myList);\n\n        try {\n          myRepository = myVcs.createRepository(myRepositoryRoot);\n\n          doRemoteDetails();\n          uploadDeletedRenamedChildren();\n          ContainerUtil.removeDuplicates(myDetailedList);\n        }\n        catch (SVNException e) {\n          LOG.info(e);\n        } finally {\n          if (myRepository != null) {\n            myRepository.closeSession();\n            myRepository = null;\n          }\n        }\n      }\n      return myDetailedList;\n    }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    private Collection<Change> getChildrenAsChanges(final String path, final boolean isBefore, final Set<Pair<Boolean, String>> duplicateControl)\n        throws SVNException {\n      final List<Change> result = new ArrayList<Change>();\n\n      final SVNLogClient client = myVcs.createLogClient();\n\n      final long revision = getRevision(isBefore);\n      client.doList(myRepository.getLocation().appendPath(path, true), SVNRevision.create(revision), SVNRevision.create(revision),\n                    true, new ISVNDirEntryHandler() {\n        public void handleDirEntry(final SVNDirEntry dirEntry) throws SVNException {\n          final String childPath = path + '/' + dirEntry.getRelativePath();\n\n          if (! duplicateControl.contains(new Pair<Boolean, String>(isBefore, childPath))) {\n            final ContentRevision contentRevision = createRevision(childPath, isBefore, SVNNodeKind.DIR.equals(dirEntry.getKind()));\n            result.add(new Change(isBefore ? contentRevision : null, isBefore ? null : contentRevision));\n          }\n        }\n      });\n\n      return result;\n    }","id":40427,"modified_method":"@NotNull\n    private Collection<Change> getChildrenAsChanges(@NotNull ContentRevision contentRevision,\n                                                    final boolean isBefore,\n                                                    @NotNull final Set<Pair<Boolean, String>> duplicates)\n      throws SVNException {\n      final List<Change> result = new ArrayList<Change>();\n\n      final String path = getRelativePath(contentRevision);\n      SVNRevision revisionNumber = SVNRevision.create(getRevision(isBefore));\n\n      final SVNLogClient client = myVcs.createLogClient();\n      client.doList(myRepository.getLocation().appendPath(path, true), revisionNumber, revisionNumber, true, new ISVNDirEntryHandler() {\n        public void handleDirEntry(final SVNDirEntry dirEntry) throws SVNException {\n          final String childPath = path + '/' + dirEntry.getRelativePath();\n\n          if (!duplicates.contains(Pair.create(isBefore, childPath))) {\n            final ContentRevision contentRevision = createRevision(childPath, isBefore, SVNNodeKind.DIR.equals(dirEntry.getKind()));\n            result.add(new Change(isBefore ? contentRevision : null, isBefore ? null : contentRevision));\n          }\n        }\n      });\n\n      return result;\n    }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private FilePath localDeletedPath(final String fullPath, final boolean isDir) {\n      final SvnFileUrlMapping urlMapping = myVcs.getSvnFileUrlMapping();\n      final String path = urlMapping.getLocalPath(fullPath);\n      if (path != null) {\n        final File file = new File(path);\n        return FilePathImpl.createForDeletedFile(file, isDir || file.isDirectory());\n      }\n\n      return null;\n    }","id":40428,"modified_method":"private FilePath localDeletedPath(final String fullPath, final boolean isDir) {\n      final SvnFileUrlMapping urlMapping = myVcs.getSvnFileUrlMapping();\n      final String path = urlMapping.getLocalPath(fullPath);\n      if (path != null) {\n        File file = new File(path);\n        return VcsUtil.getFilePathForDeletedFile(path, isDir || file.isDirectory());\n      }\n\n      return null;\n    }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void patchChange(Change change, final String path) {\n    final SVNURL becameUrl;\n    SVNURL wasUrl;\n    try {\n      becameUrl = SVNURL.parseURIEncoded(SVNPathUtil.append(myRepositoryRoot, path));\n      wasUrl = becameUrl;\n\n      if (change instanceof ExternallyRenamedChange && change.getBeforeRevision() != null) {\n        final ExternallyRenamedChange renamedChange = (ExternallyRenamedChange)change;\n        final String originUrl = renamedChange.getOriginUrl();\n        if (originUrl != null) {\n          // use another url for origin\n          wasUrl = SVNURL.parseURIEncoded(SVNPathUtil.append(myRepositoryRoot, originUrl));\n        }\n      }\n    }\n    catch (SVNException e) {\n      // nothing to do\n      LOG.info(e);\n      return;\n    }\n\n    final FilePath filePath = ChangesUtil.getFilePath(change);\n    final Change additional = new Change(change.getBeforeRevision() == null ? null :\n                                         new SvnLazyPropertyContentRevision(filePath, change.getBeforeRevision().getRevisionNumber(),\n                                                                            myVcs.getProject(), wasUrl),\n                                         change.getAfterRevision() == null ? null :\n                                         new SvnLazyPropertyContentRevision(filePath, change.getAfterRevision().getRevisionNumber(),\n                                                                            myVcs.getProject(), becameUrl));\n    change.addAdditionalLayerElement(SvnChangeProvider.PROPERTY_LAYER, additional);\n  }","id":40429,"modified_method":"private void patchChange(Change change, final String path) {\n    final SVNURL becameUrl;\n    SVNURL wasUrl;\n    try {\n      becameUrl = SVNURL.parseURIEncoded(SVNPathUtil.append(myRepositoryRoot, path));\n      wasUrl = becameUrl;\n\n      if (change instanceof ExternallyRenamedChange && change.getBeforeRevision() != null) {\n        String originUrl = ((ExternallyRenamedChange)change).getOriginUrl();\n\n        if (originUrl != null) {\n          // use another url for origin\n          wasUrl = SVNURL.parseURIEncoded(SVNPathUtil.append(myRepositoryRoot, originUrl));\n        }\n      }\n    }\n    catch (SVNException e) {\n      // nothing to do\n      LOG.info(e);\n      return;\n    }\n\n    final FilePath filePath = ChangesUtil.getFilePath(change);\n    final Change additional = new Change(createPropertyRevision(filePath, change.getBeforeRevision(), wasUrl),\n                                         createPropertyRevision(filePath, change.getAfterRevision(), becameUrl));\n    change.addAdditionalLayerElement(SvnChangeProvider.PROPERTY_LAYER, additional);\n  }","commit_id":"a66c80b16acb5d9b2d5003e7fd0970a0e04c671e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Zips changes by removing duplicates (changes in the same file) and compounding the diff.\n   * <b>NB:<\/b> changes must be given in the time-ascending order, i.e the first change in the list should be the oldest one.\n   */\n  @NotNull\n  public static List<Change> zipChanges(@NotNull List<Change> changes) {\n    final List<Change> result = new ArrayList<Change>();\n    for (Change change : changes) {\n      final ContentRevision beforeRev = change.getBeforeRevision();\n      // todo!!! further improvements needed\n      if (beforeRev == null) {\n        result.add(change);\n        continue;\n      }\n\n      Change oldChange = null;\n      final FilePath beforePath = beforeRev.getFile();\n      for (Change processedChange : result) {\n        ContentRevision rev = processedChange.getAfterRevision();\n        if (rev != null && rev.getFile().equals(beforePath)) {\n          oldChange = processedChange;\n          break;\n        }\n      }\n\n      if (oldChange == null) {\n        result.add(change);\n        continue;\n      }\n\n      result.remove(oldChange);\n      if (oldChange.getBeforeRevision() != null || change.getAfterRevision() != null) {\n        result.add(new Change(oldChange.getBeforeRevision(), change.getAfterRevision()));\n      }\n    }\n    return result;\n  }","id":40430,"modified_method":"/**\n   * Zips changes by removing duplicates (changes in the same file) and compounding the diff.\n   * <b>NB:<\/b> changes must be given in the time-ascending order, i.e the first change in the list should be the oldest one.\n   */\n  @NotNull\n  public static List<Change> zipChanges(@NotNull List<Change> changes) {\n    // TODO: further improvements needed\n    // We may want to process collisions more consistent\n\n    // Possible solution: avoid creating duplicate entries for the same FilePath. No changes in the output should have same beforePath or afterPath.\n    // We may take earliest and latest revisions for each file.\n    //\n    // The main problem would be to keep existing movements in non-conflicting cases (where input changes are taken from linear sequence of commits)\n    // case1: \"a -> b; b -> c\" - file renamed twice in the same revision (as source and as target)\n    // case2: \"a -> b\" \"b -> c\" - file renamed twice in consequent commits\n    // case3: \"a -> b; b -> a\" - files swapped vs \"a -> b\" \"b -> a\" - file rename canceled\n    // case4: \"delete a\" \"b -> a\" \"modify a\"\n    // ...\n    // but return \"good enough\" result for input with conflicting changes\n    // case1: \"new a\", \"new a\"\n    // case2: \"a -> b\", \"new b\"\n    // ...\n    //\n    // getting \"actually good\" results is impossible without knowledge of commits topology.\n\n\n    // key - after path (nullable)\n    LinkedMultiMap<FilePath, Change> map = new LinkedMultiMap<FilePath, Change>();\n\n    for (Change change : changes) {\n      ContentRevision bRev = change.getBeforeRevision();\n      ContentRevision aRev = change.getAfterRevision();\n      FilePath bPath = bRev != null ? bRev.getFile() : null;\n      FilePath aPath = aRev != null ? aRev.getFile() : null;\n\n      if (bRev == null) {\n        map.putValue(aPath, change);\n        continue;\n      }\n\n      Collection<Change> bucket = map.get(bPath);\n      if (bucket.isEmpty()) {\n        map.putValue(aPath, change);\n        continue;\n      }\n\n      Change oldChange = bucket.iterator().next();\n      bucket.remove(oldChange);\n\n      ContentRevision oldRevision = oldChange.getBeforeRevision();\n      if (oldRevision != null || aRev != null) {\n        map.putValue(aPath, new Change(oldRevision, aRev));\n      }\n    }\n\n    // put deletions into appropriate place in list\n    Collection<Change> deleted = map.remove(null);\n    if (deleted != null) {\n      for (Change change : deleted) {\n        //noinspection ConstantConditions\n        map.putValue(change.getBeforeRevision().getFile(), change);\n      }\n    }\n\n    return new ArrayList<Change>(map.values());\n  }","commit_id":"f7d03fbe5a749f45e88f7bd029f254043e51a365","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param  change \"Change\" description.\n   * @return Return true if the \"Change\" object is created for \"Rename\" operation:\n   * in this case name of files for \"before\" and \"after\" revisions must not\n   * coniside.\n   */\n  public static boolean isRenameChange( Change change )\n  {\n    boolean isRenamed = false;\n    try\n    {\n      if( change.getBeforeRevision() != null && change.getAfterRevision() != null )\n      {\n        String prevFile = change.getBeforeRevision().getFile().getPath();\n        String newFile  = change.getAfterRevision().getFile().getPath();\n        isRenamed = !prevFile.equals( newFile );\n      }\n    }\n    catch( NullPointerException e ) {\n      //  Nothing to do - valid behavior for a revision file to be null.\n    }\n    return isRenamed;\n  }","id":40431,"modified_method":"/**\n   * @param  change \"Change\" description.\n   * @return Return true if the \"Change\" object is created for \"Rename\" operation:\n   * in this case name of files for \"before\" and \"after\" revisions must not\n   * coniside.\n   */\n  public static boolean isRenameChange( Change change )\n  {\n    boolean isRenamed = false;\n    ContentRevision before = change.getBeforeRevision();\n    ContentRevision after = change.getAfterRevision();\n    if( before != null && after != null )\n    {\n      String prevFile = before.getFile().getPath();\n      String newFile  = after.getFile().getPath();\n      isRenamed = !prevFile.equals( newFile );\n    }\n    return isRenamed;\n  }","commit_id":"ba3ab9b5fc8cf61470f13a987798c02cc1c39c80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setUpdatePolicy( String updatePolicy )\n    {\n        this.updatePolicy = updatePolicy;\n    }","id":40432,"modified_method":"public void setUpdatePolicy( String updatePolicy )\n    {\n        if(updatePolicy != null) {\n        \tthis.updatePolicy = updatePolicy;\n        }\n    }","commit_id":"807bb6ddc7b95f42067fe27343aeb3a37dfd0fe1","url":"https://github.com/apache/maven"},{"original_method":"public void setChecksumPolicy( String checksumPolicy )\n    {\n        this.checksumPolicy = checksumPolicy;\n    }","id":40433,"modified_method":"public void setChecksumPolicy( String checksumPolicy )\n    {\n    \tif(checksumPolicy != null) {\n    \t\tthis.checksumPolicy = checksumPolicy;\t\n    \t}       \n    }","commit_id":"807bb6ddc7b95f42067fe27343aeb3a37dfd0fe1","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject buildFromRepository( Artifact artifact, List remoteArtifactRepositories, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        MavenProject project = hm.get( artifact.getId() );\n        \n        if ( project != null )\n        {            \n            return project;\n        }        \n        \n        File f = (artifact.getFile() != null) ? artifact.getFile() : new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) );\n        mavenTools.findModelFromRepository( artifact, remoteArtifactRepositories, localRepository );\n\n        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration().setLocalRepository( localRepository );\n\n        List<ArtifactRepository> artifactRepositories = new ArrayList<ArtifactRepository>( remoteArtifactRepositories );\n        artifactRepositories.addAll( mavenTools.buildArtifactRepositories( projectBuilder.getSuperModel() ) );\n\n        project = readModelFromLocalPath( \"unknown\", artifact.getFile(), new DefaultPomArtifactResolver( config.getLocalRepository(), artifactRepositories, artifactResolver ), config );\n        project = buildWithProfiles( project.getModel(), config, artifact.getFile(), project.getParentFile(), false );\n        artifact.setFile( f );\n        project.setVersion( artifact.getVersion() );\n\n        hm.put( artifact.getId(), project );\n        \n        return project;\n    }","id":40434,"modified_method":"public MavenProject buildFromRepository( Artifact artifact, List remoteArtifactRepositories, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        MavenProject project = hm.get( artifact.getId() );\n        \n        if ( project != null )\n        {            \n            return project;\n        }        \n        List<ArtifactRepository> artifactRepositories = new ArrayList<ArtifactRepository>( remoteArtifactRepositories );\n        artifactRepositories.addAll( mavenTools.buildArtifactRepositories( projectBuilder.getSuperModel() ) );\n        \n        File f = (artifact.getFile() != null) ? artifact.getFile() : new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) );\n        mavenTools.findModelFromRepository( artifact, artifactRepositories, localRepository );\n\n        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration().setLocalRepository( localRepository );\n\n        project = readModelFromLocalPath( \"unknown\", artifact.getFile(), new DefaultPomArtifactResolver( config.getLocalRepository(), artifactRepositories, artifactResolver ), config );\n        project = buildWithProfiles( project.getModel(), config, artifact.getFile(), project.getParentFile(), false );\n        artifact.setFile( f );\n        project.setVersion( artifact.getVersion() );\n\n        hm.put( artifact.getId(), project );\n        \n        return project;\n    }","commit_id":"807bb6ddc7b95f42067fe27343aeb3a37dfd0fe1","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject build( File projectDescriptor, ProjectBuilderConfiguration config )\n        throws ProjectBuildingException\n    {        \n        List repositories = mavenTools.buildArtifactRepositories( projectBuilder.getSuperModel() );\n        \n        MavenProject project = readModelFromLocalPath( \"unknown\", \n                                                       projectDescriptor, \n                                                       new DefaultPomArtifactResolver( config.getLocalRepository(), \n                                                                                       repositories, artifactResolver ), config );\n\n        project.setFile( projectDescriptor );\n        \n        project = buildWithProfiles( project.getModel(), config, projectDescriptor, project.getParentFile(), true );\n\n        Build build = project.getBuild();\n        // NOTE: setting this script-source root before path translation, because\n        // the plugin tools compose basedir and scriptSourceRoot into a single file.\n        project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n        project.addCompileSourceRoot( build.getSourceDirectory() );\n        project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        project.setFile( projectDescriptor );\n\n        setBuildOutputDirectoryOnParent( project );\n        return project;\n    }","id":40435,"modified_method":"public MavenProject build( File projectDescriptor, ProjectBuilderConfiguration config )\n        throws ProjectBuildingException\n    {  \n       List<ArtifactRepository> artifactRepositories = new ArrayList<ArtifactRepository>( );\n       artifactRepositories.addAll( mavenTools.buildArtifactRepositories( projectBuilder.getSuperModel() ) );\n       if(config.getRemoteRepositories() != null) \n       {\n    \t   artifactRepositories.addAll(config.getRemoteRepositories());\n       }\n        \n        MavenProject project = readModelFromLocalPath( \"unknown\", \n                                                       projectDescriptor, \n                                                       new DefaultPomArtifactResolver( config.getLocalRepository(), \n                                                                                       artifactRepositories, artifactResolver ), config );\n\n        project.setFile( projectDescriptor );\n        \n        project = buildWithProfiles( project.getModel(), config, projectDescriptor, project.getParentFile(), true );\n\n        Build build = project.getBuild();\n        // NOTE: setting this script-source root before path translation, because\n        // the plugin tools compose basedir and scriptSourceRoot into a single file.\n        project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n        project.addCompileSourceRoot( build.getSourceDirectory() );\n        project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        project.setFile( projectDescriptor );\n\n        setBuildOutputDirectoryOnParent( project );\n        return project;\n    }","commit_id":"807bb6ddc7b95f42067fe27343aeb3a37dfd0fe1","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject build( String pomLocation, Model model, ArtifactRepository localRepository,\n                                List remoteArtifactRepositories, List externalProfiles )\n        throws ProjectBuildingException\n    {\n        Model superModel = getSuperModel();\n\n        LinkedList lineage = new LinkedList();\n\n        List aggregatedRemoteWagonRepositories;\n        if ( remoteArtifactRepositories == null || remoteArtifactRepositories.isEmpty() )\n        {\n            aggregatedRemoteWagonRepositories = ProjectUtils.buildArtifactRepositories( superModel.getRepositories(),\n                                                                                        artifactRepositoryFactory,\n                                                                                        container );\n        }\n        else\n        {\n            aggregatedRemoteWagonRepositories = new ArrayList( remoteArtifactRepositories );\n        }\n\n        for ( Iterator i = externalProfiles.iterator(); i.hasNext(); )\n        {\n            Profile externalProfile = (Profile) i.next();\n\n            for ( Iterator repoIterator = externalProfile.getRepositories().iterator(); repoIterator.hasNext(); )\n            {\n                Repository mavenRepo = (Repository) repoIterator.next();\n\n                ArtifactRepository artifactRepo = ProjectUtils.buildArtifactRepository( mavenRepo,\n                                                                                        artifactRepositoryFactory,\n                                                                                        container );\n\n                if ( !aggregatedRemoteWagonRepositories.contains( artifactRepo ) )\n                {\n                    aggregatedRemoteWagonRepositories.add( artifactRepo );\n                }\n            }\n        }\n\n        MavenProject project = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n        // we don't have to force the collision exception for superModel here, it's already been done in getSuperModel()\n        Model previous = superModel;\n\n        for ( Iterator i = lineage.iterator(); i.hasNext(); )\n        {\n            MavenProject currentProject = (MavenProject) i.next();\n\n            Model current = currentProject.getModel();\n\n            modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n            previous = current;\n        }\n\n        try\n        {\n            project = processProjectLogic( pomLocation, project, aggregatedRemoteWagonRepositories, externalProfiles );\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \\'\" + pomLocation + \"\\': \" + model.getId(),\n                                                e );\n        }\n        return project;\n    }","id":40436,"modified_method":"private MavenProject build( String pomLocation, Model model, ArtifactRepository localRepository,\n                                List remoteArtifactRepositories, List externalProfiles )\n        throws ProjectBuildingException\n    {\n        Model superModel = getSuperModel();\n\n        LinkedList lineage = new LinkedList();\n\n        Set aggregatedRemoteWagonRepositories = new HashSet();\n        if ( remoteArtifactRepositories != null && !remoteArtifactRepositories.isEmpty() )\n        {\n            aggregatedRemoteWagonRepositories.addAll( remoteArtifactRepositories );\n        }\n\n        aggregatedRemoteWagonRepositories.addAll( ProjectUtils.buildArtifactRepositories( superModel.getRepositories(),\n                                                                                          artifactRepositoryFactory,\n                                                                                          container ) );\n\n        for ( Iterator i = externalProfiles.iterator(); i.hasNext(); )\n        {\n            Profile externalProfile = (Profile) i.next();\n\n            for ( Iterator repoIterator = externalProfile.getRepositories().iterator(); repoIterator.hasNext(); )\n            {\n                Repository mavenRepo = (Repository) repoIterator.next();\n\n                ArtifactRepository artifactRepo = ProjectUtils.buildArtifactRepository( mavenRepo,\n                                                                                        artifactRepositoryFactory,\n                                                                                        container );\n\n                aggregatedRemoteWagonRepositories.add( artifactRepo );\n            }\n        }\n\n        List repositories = new ArrayList( aggregatedRemoteWagonRepositories );\n\n        MavenProject project = assembleLineage( model, lineage, repositories, localRepository );\n\n        // we don't have to force the collision exception for superModel here, it's already been done in getSuperModel()\n        Model previous = superModel;\n\n        for ( Iterator i = lineage.iterator(); i.hasNext(); )\n        {\n            MavenProject currentProject = (MavenProject) i.next();\n\n            Model current = currentProject.getModel();\n\n            modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n            previous = current;\n        }\n\n        try\n        {\n            project = processProjectLogic( pomLocation, project, repositories, externalProfiles );\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \\'\" + pomLocation + \"\\': \" + model.getId(),\n                                                e );\n        }\n        return project;\n    }","commit_id":"6aa208414f277bb20647ecf55e0cf7b73a289211","url":"https://github.com/apache/maven"},{"original_method":"private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor, PlexusContainer pluginContainer,\n                                                  MavenProject project, MavenSession session )\n        throws PluginConfigurationException\n    {\n        // if the plugin's already been used once, don't re-do this step...\n        // otherwise, we have to finish resolving the plugin's classpath and start the container.\n        if ( pluginDescriptor.getArtifacts() != null && pluginDescriptor.getArtifacts().size() == 1 )\n        {\n            Artifact pluginArtifact = (Artifact) pluginDescriptor.getArtifacts().get( 0 );\n\n            try\n            {\n                MavenMetadataSource metadataSource = new MavenMetadataSource( mavenProjectBuilder, artifactFactory );\n\n                List remoteRepositories = new ArrayList();\n\n                remoteRepositories.addAll( project.getRemoteArtifactRepositories() );\n                remoteRepositories.addAll( project.getPluginArtifactRepositories() );\n\n                ArtifactRepository localRepository = session.getLocalRepository();\n\n                ResolutionGroup resolutionGroup = metadataSource.retrieve( pluginArtifact, localRepository,\n                                                                           project.getPluginArtifactRepositories() );\n\n                Set dependencies = resolutionGroup.getArtifacts();\n\n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,\n                                                                                        localRepository,\n                                                                                        remoteRepositories,\n                                                                                        metadataSource,\n                                                                                        artifactFilter );\n\n                Set resolved = result.getArtifacts();\n\n                for ( Iterator it = resolved.iterator(); it.hasNext(); )\n                {\n                    Artifact artifact = (Artifact) it.next();\n\n                    if ( !artifact.equals( pluginArtifact ) )\n                    {\n                        pluginContainer.addJarResource( artifact.getFile() );\n                    }\n                }\n\n                pluginDescriptor.setClassRealm( pluginContainer.getContainerRealm() );\n\n                List unresolved = new ArrayList( dependencies );\n\n                unresolved.removeAll( resolved );\n\n                resolveCoreArtifacts( unresolved );\n\n                List allResolved = new ArrayList( resolved.size() + unresolved.size() );\n\n                allResolved.addAll( resolved );\n                allResolved.addAll( unresolved );\n\n                pluginDescriptor.setArtifacts( allResolved );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n            catch ( PlexusContainerException e )\n            {\n                throw new PluginConfigurationException( \"Cannot start plugin container\", e );\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n        }\n    }","id":40437,"modified_method":"private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor, PlexusContainer pluginContainer,\n                                                  MavenProject project, MavenSession session )\n        throws PluginConfigurationException\n    {\n        // if the plugin's already been used once, don't re-do this step...\n        // otherwise, we have to finish resolving the plugin's classpath and start the container.\n        if ( pluginDescriptor.getArtifacts() != null && pluginDescriptor.getArtifacts().size() == 1 )\n        {\n            Artifact pluginArtifact = (Artifact) pluginDescriptor.getArtifacts().get( 0 );\n\n            try\n            {\n                MavenMetadataSource metadataSource = new MavenMetadataSource( mavenProjectBuilder, artifactFactory );\n\n                ArtifactRepository localRepository = session.getLocalRepository();\n\n                ResolutionGroup resolutionGroup = metadataSource.retrieve( pluginArtifact, localRepository,\n                                                                           project.getPluginArtifactRepositories() );\n\n                Set dependencies = resolutionGroup.getArtifacts();\n\n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,\n                                                                                        localRepository,\n                                                                                        resolutionGroup.getResolutionRepositories(),\n                                                                                        metadataSource,\n                                                                                        artifactFilter );\n\n                Set resolved = result.getArtifacts();\n\n                for ( Iterator it = resolved.iterator(); it.hasNext(); )\n                {\n                    Artifact artifact = (Artifact) it.next();\n\n                    if ( !artifact.equals( pluginArtifact ) )\n                    {\n                        pluginContainer.addJarResource( artifact.getFile() );\n                    }\n                }\n\n                pluginDescriptor.setClassRealm( pluginContainer.getContainerRealm() );\n\n                List unresolved = new ArrayList( dependencies );\n\n                unresolved.removeAll( resolved );\n\n                resolveCoreArtifacts( unresolved );\n\n                List allResolved = new ArrayList( resolved.size() + unresolved.size() );\n\n                allResolved.addAll( resolved );\n                allResolved.addAll( unresolved );\n\n                pluginDescriptor.setArtifacts( allResolved );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n            catch ( PlexusContainerException e )\n            {\n                throw new PluginConfigurationException( \"Cannot start plugin container\", e );\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n        }\n    }","commit_id":"6aa208414f277bb20647ecf55e0cf7b73a289211","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject assembleLineage( Model model, LinkedList lineage, List aggregatedRemoteWagonRepositories,\n                                          ArtifactRepository localRepository )\n        throws ProjectBuildingException, ArtifactResolutionException\n    {\n        aggregatedRemoteWagonRepositories.addAll( ProjectUtils.buildArtifactRepositories( model.getRepositories(), artifactRepositoryFactory, container ) );\n\n        MavenProject project = new MavenProject( model );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing artifactId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( \"Missing version element from parent element\" );\n            }\n\n            //!! (**)\n            // ----------------------------------------------------------------------\n            // Do we have the necessary information to actually find the parent\n            // POMs here?? I don't think so ... Say only one remote repository is\n            // specified and that is ibiblio then this model that we just read doesn't\n            // have any repository information ... I think we might have to inherit\n            // as we go in order to do this.\n            // ----------------------------------------------------------------------\n\n            Artifact artifact = artifactFactory.createArtifact( parentModel.getGroupId(), parentModel.getArtifactId(),\n                                                                parentModel.getVersion(), null, \"pom\", null );\n\n            model = findModelFromRepository( artifact, aggregatedRemoteWagonRepositories, localRepository );\n\n            MavenProject parent = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n            project.setParent( parent );\n\n            project.setParentArtifact( artifact );\n        }\n\n        return project;\n    }","id":40438,"modified_method":"private MavenProject assembleLineage( Model model, LinkedList lineage, List aggregatedRemoteWagonRepositories,\n                                          ArtifactRepository localRepository )\n        throws ProjectBuildingException, ArtifactResolutionException\n    {\n        if ( !model.getRepositories().isEmpty() )\n        {\n            List respositories = ProjectUtils.buildArtifactRepositories( model.getRepositories(), artifactRepositoryFactory, container );\n            aggregatedRemoteWagonRepositories.addAll( respositories );\n        }\n\n        MavenProject project = new MavenProject( model );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing artifactId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( \"Missing version element from parent element\" );\n            }\n\n            //!! (**)\n            // ----------------------------------------------------------------------\n            // Do we have the necessary information to actually find the parent\n            // POMs here?? I don't think so ... Say only one remote repository is\n            // specified and that is ibiblio then this model that we just read doesn't\n            // have any repository information ... I think we might have to inherit\n            // as we go in order to do this.\n            // ----------------------------------------------------------------------\n\n            Artifact artifact = artifactFactory.createArtifact( parentModel.getGroupId(), parentModel.getArtifactId(),\n                                                                parentModel.getVersion(), null, \"pom\", null );\n\n            model = findModelFromRepository( artifact, aggregatedRemoteWagonRepositories, localRepository );\n\n            MavenProject parent = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n            project.setParent( parent );\n\n            project.setParentArtifact( artifact );\n        }\n\n        return project;\n    }","commit_id":"8e5a4620357efda310e5edc09051f98baa746ed0","url":"https://github.com/apache/maven"},{"original_method":"public String id() {\n      if(_id == null) {\n          _id = (String) (canGetValueForBinding(\"id\") && valueForBinding(\"id\") != null ? (String)valueForBinding(\"id\") : scriptBaseName());\n          if(canSetValueForBinding(\"id\")) {\n              setValueForBinding(_id, \"id\");\n          }\n      }\n      return _id;\n  }","id":40439,"modified_method":"public String id() {\n      if(_id == null) {\n          _id = canGetValueForBinding(\"id\") && valueForBinding(\"id\") != null ? (String)valueForBinding(\"id\") : scriptBaseName();\n          if(canSetValueForBinding(\"id\")) {\n              setValueForBinding(_id, \"id\");\n          }\n      }\n      return _id;\n  }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected WOActionResults handleRequest(WORequest _request, WOContext _context) {\n    String droppedDraggableID = _request.stringFormValueForKey(myDraggableIDKeyName);\n    if (canSetValueForBinding(\"droppedDraggableID\")) {\n      setValueForBinding(droppedDraggableID, \"droppedDraggableID\");\n    }\n    if (canGetValueForBinding(\"action\")) {\n      WOActionResults results = (WOActionResults) valueForBinding(\"action\");\n      if (results != null) {\n        System.out.println(\"AjaxDroppable.handleRequest: Not quite sure what to do with non-null results yet ...\");\n      }\n    }\n    return null;\n  }","id":40440,"modified_method":"protected WOActionResults handleRequest(WORequest _request, WOContext _context) {\n    String droppedDraggableID = _request.stringFormValueForKey(myDraggableIDKeyName);\n    if (canSetValueForBinding(\"droppedDraggableID\")) {\n      setValueForBinding(droppedDraggableID, \"droppedDraggableID\");\n      if (canSetValueForBinding(\"droppedObject\")) {\n        WOComponent page = _context.page();\n        Object droppedObject = AjaxDraggable.draggableObjectForPage(page, droppedDraggableID);\n        setValueForBinding(droppedObject, \"droppedObject\");\n      }\n    }\n    if (canGetValueForBinding(\"action\")) {\n      WOActionResults results = (WOActionResults) valueForBinding(\"action\");\n      if (results != null) {\n        System.out.println(\"AjaxDroppable.handleRequest: Not quite sure what to do with non-null results yet ...\");\n      }\n    }\n    return null;\n  }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults droppedDraggable1() {\n        System.out.println(\"DragAndDropExample.droppedDraggableID: draggable ID '\" + droppedDraggableID\n                + \"' dropped onto 1: \" + idMap.objectForKey(droppedDraggableID));\n        return null;\n    }","id":40441,"modified_method":"public WOActionResults droppedDraggable1() {\n        System.out.println(\"DragAndDropExample.droppedDraggableID: draggable ID '\" + droppedDraggableID\n                + \"' dropped onto 1: \" + droppedDraggableID);\n        System.out.println(\"DragAndDropExample.droppedDraggable1: draggable object = \" + droppedObject);\n        return null;\n    }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String draggableExample2() {\n        String id = \"draggableExample_\" + context().elementID().replace('.', '_');\n        idMap.setObjectForKey(item, id);\n        return id;\n    }","id":40442,"modified_method":"public String draggableExample2() {\n        String id = \"draggableExample_\" + context().elementID().replace('.', '_');\n        return id;\n    }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults droppedDraggable2() {\n        System.out.println(\"DragAndDropExample.droppedDraggableID: draggable ID '\" + droppedDraggableID\n                + \"' dropped onto 2: \" + idMap.objectForKey(droppedDraggableID));\n        return null;\n    }","id":40443,"modified_method":"public WOActionResults droppedDraggable2() {\n        System.out.println(\"DragAndDropExample.droppedDraggableID: draggable ID '\" + droppedDraggableID\n                + \"' dropped onto 2: \" + droppedObject);\n        System.out.println(\"DragAndDropExample.droppedDraggable2: draggable object = \" + droppedObject);\n        return null;\n    }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"public DragAndDropExample(WOContext _context) {\n        super(_context);\n        for (int i = 1; i < 10; i++) {\n            objects.addObject(\"Object \" + i);\n        }\n        // Set the inital object, as this one will not get set in a repetition\n        // and has a prefixed ID.\n        // All other objects will get added in a loop for draggableExample2\n        idMap.setObjectForKey(o1, \"draggableExample1\");\n    }","id":40444,"modified_method":"public DragAndDropExample(WOContext _context) {\n        super(_context);\n        for (int i = 1; i < 10; i++) {\n            objects.addObject(\"Object \" + i);\n        }\n    }","commit_id":"0e0d6efaa80c662a077489e71fbe335d26802e56","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setSelections(NSArray aFormValuesArray) {\n        // ** This is where we accept the formValues.  Kind of weird.\n        NSMutableArray aSelectionsArray = new NSMutableArray();\n        if (aFormValuesArray != null && aFormValuesArray.count() > 0) {\n            Enumeration anIndexEnumerator = aFormValuesArray.objectEnumerator();\n            NSArray anItemList = (NSArray)valueForBinding(\"list\");\n            int anItemCount = anItemList.count();\n            while (anIndexEnumerator.hasMoreElements()) {\n                int anIndex = Integer.parseInt((String)anIndexEnumerator.nextElement());\n                if (anIndex < anItemCount) {\n                    Object anObject = anItemList.objectAtIndex(anIndex);\n                    aSelectionsArray.addObject(anObject);\n                } else {\n                    // ** serious problem here. Raise an exception?\n                }\n            }\n        }\n        setValueForBinding(aSelectionsArray, \"selections\");\n        _selections = null;\n    }","id":40445,"modified_method":"public void setSelections(NSArray aFormValuesArray) throws IllegalAccessException, InvocationTargetException {\n        // ** This is where we accept the formValues.  Kind of weird.\n        NSMutableArray aSelectionsArray = new NSMutableArray();\n        if (aFormValuesArray != null && aFormValuesArray.count() > 0) {\n            Enumeration anIndexEnumerator = aFormValuesArray.objectEnumerator();\n            NSArray anItemList = (NSArray)valueForBinding(\"list\");\n            int anItemCount = anItemList.count();\n            while (anIndexEnumerator.hasMoreElements()) {\n                int anIndex = Integer.parseInt((String)anIndexEnumerator.nextElement());\n                if (anIndex < anItemCount) {\n                    Object anObject = anItemList.objectAtIndex(anIndex);\n                    aSelectionsArray.addObject(anObject);\n                } else {\n                    // ** serious problem here. Raise an exception?\n                }\n            }\n        }\n        // dt: this can be used with a subset as array for the checkboxes.\n        if (getRelationshipName() != null && getRelationshipName().length() > 0 && getRelationshipOwner() != null) {\n            NSSet objectsToRemove = new NSSet(_selections).setBySubtractingSet(new NSSet(aSelectionsArray));\n            NSSet objectsToAdd = new NSSet(aSelectionsArray).setBySubtractingSet(new NSSet(_selections));\n            EOEnterpriseObject owner = getRelationshipOwner();\n            String relname = getRelationshipName();\n            for (Enumeration e = objectsToRemove.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                owner.removeObjectFromBothSidesOfRelationshipWithKey(eo, relname);\n            }\n            for (Enumeration e = objectsToAdd.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                owner.addObjectToBothSidesOfRelationshipWithKey(eo, relname);\n            }\n            \n        } else {\n            setValueForBinding(aSelectionsArray, \"selections\");\n        }\n        _selections = null;\n    }","commit_id":"d393ebcfb1bd4cf4a8ec71fabcebf6a073dbb254","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String uploadUrl() {\n\t\tString uploadUrl = context().urlWithRequestHandlerKey(AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY, \"\", null);\n\t\treturn uploadUrl;\n\t}","id":40446,"modified_method":"public String uploadUrl() {\n\t\tString uploadUrl = context().urlWithRequestHandlerKey(_requestHandlerKey, \"\", null);\n\t\treturn uploadUrl;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults startUpload() {\n\t\t_uploadStarted = true;\n\t\tsetValueForBinding(Boolean.TRUE, \"uploadStarted\");\n\t\treturn null;\n\t}","id":40447,"modified_method":"public WOActionResults startUpload() {\n\t\t_triggerUploadStart = true;\n\t\tif (_progress != null) {\n\t\t\t_progress.reset();\n\t\t}\n\t\t_progress = null;\n\t\tsetValueForBinding(null, \"uploadProgress\");\n\n\t\t_uploadStarted = true;\n\t\tsetValueForBinding(Boolean.TRUE, \"uploadStarted\");\n\t\t\n\t\tAjaxResponse response = AjaxUtils.createResponse(context().request(), context());\n\t\tAjaxUtils.appendScriptHeaderIfNecessary(context().request(), response);\n\t\tresponse.appendContentString(\"document.\" + uploadFormID() + \".submit();\");\n\t\tAjaxUtils.appendScriptFooterIfNecessary(context().request(), response);\n\t\treturn response;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isUploadStarted() {\n\t\tboolean uploadStarted;\n\t\tif (hasBinding(\"uploadStarted\")) {\n\t\t\tuploadStarted = ERXComponentUtilities.booleanValueForBinding(this, \"uploadStarted\");\n\t\t}\n\t\telse {\n\t\t\tAjaxUploadProgress progress = uploadProgress();\n\t\t\tif (progress != null && progress.shouldReset()) {\n\t\t\t\t_uploadStarted = false;\n\t\t\t}\n\t\t\tuploadStarted = _uploadStarted;\n\t\t}\n\t\treturn uploadStarted;\n\t}","id":40448,"modified_method":"public boolean isUploadStarted() {\n\t\tboolean uploadStarted;\n\t\tif (hasBinding(\"uploadStarted\")) {\n\t\t\tuploadStarted = ERXComponentUtilities.booleanValueForBinding(this, \"uploadStarted\");\n\t\t}\n\t\telse {\n\t\t\tAjaxUploadProgress progress = uploadProgress();\n\t\t\tif (progress != null && progress.shouldReset()) {\n\t\t\t\t_uploadStarted = false;\n\t\t\t\tsetValueForBinding(Boolean.FALSE, \"uploadStarted\");\n\t\t\t}\n\t\t\tuploadStarted = _uploadStarted;\n\t\t}\n\t\treturn uploadStarted;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public AjaxFileUpload(WOContext context) {\n\t\tsuper(context);\n\t\tsynchronized (AjaxFileUpload.class) {\n\t\t\tif (!_requestHandlerRegistered) {\n\t\t\t\tif (WOApplication.application().requestHandlerForKey(AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY) == null) {\n\t\t\t\t\tWOApplication.application().registerRequestHandler(new AjaxFileUploadRequestHandler(), AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY);\n\t\t\t\t}\n\t\t\t\t_requestHandlerRegistered = true;\n\t\t\t}\n\t\t}\n\t}","id":40449,"modified_method":"public AjaxFileUpload(WOContext context) {\n\t\tsuper(context);\n\t\t_requestHandlerKey = AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY;\n\t\tif (!_requestHandlerRegistered) {\n\t\t\tsynchronized (AjaxFileUpload.class) {\n\t\t\t\tif (!_requestHandlerRegistered) {\n\t\t\t\t\tif (WOApplication.application().requestHandlerForKey(AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY) == null) {\n\t\t\t\t\t\tWOApplication.application().registerRequestHandler(new AjaxFileUploadRequestHandler(), AjaxFileUploadRequestHandler.REQUEST_HANDLER_KEY);\n\t\t\t\t\t}\n\t\t\t\t\t_requestHandlerRegistered = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults uploadSucceeded() throws MalformedURLException, IOException {\n\t\tAjaxUploadProgress progress = uploadProgress();\n\t\ttry {\n\t\t\tboolean deleteFile = true;\n\t\t\tif (hasBinding(\"filePath\")) {\n\t\t\t\tsetValueForBinding(progress.fileName(), \"filePath\");\n\t\t\t}\n\t\t\t\n\t\t\tif (hasBinding(\"data\")) {\n\t\t\t\tNSData data = new NSData(progress.tempFile().toURL());\n\t\t\t\tsetValueForBinding(data, \"data\");\n\t\t\t}\n\t\t\t\n\t\t\tif (hasBinding(\"inputStream\")) {\n\t\t\t\tsetValueForBinding(new FileInputStream(progress.tempFile()), \"inputStream\");\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (hasBinding(\"outputStream\")) {\n\t\t\t\tOutputStream outputStream = (OutputStream) valueForBinding(\"outputStream\");\n\t\t\t\tif (outputStream != null) {\n\t\t\t\t\tERXFileUtilities.writeInputStreamToOutputStream(new FileInputStream(progress.tempFile()), outputStream);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (hasBinding(\"streamToFilePath\")) {\n\t\t\t\tFile streamToFile = new File((String) valueForBinding(\"streamToFilePath\"));\n\t\t\t\tboolean renamedFile;\n\t\t\t\tboolean renameFile;\n\t\t\t\tif (streamToFile.exists()) {\n\t\t\t\t\trenameFile = ERXComponentUtilities.booleanValueForBinding(this, \"overwrite\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenameFile = true;\n\t\t\t\t}\n\t\t\t\tif (renameFile) {\n\t\t\t\t\tERXFileUtilities.renameTo(progress.tempFile(), streamToFile);\n\t\t\t\t\trenamedFile = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenamedFile = false;\n\t\t\t\t}\n\t\t\t\tif (hasBinding(\"finalFilePath\")) {\n\t\t\t\t\tString finalFilePath;\n\t\t\t\t\tif (renamedFile) {\n\t\t\t\t\t\tfinalFilePath = streamToFile.getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinalFilePath = progress.tempFile().getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(finalFilePath, \"finalFilePath\");\n\t\t\t\t}\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (deleteFile) {\n\t\t\t\tprogress.dispose();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tuploadFinished();\n\t\t}\n\t\treturn (WOActionResults) valueForBinding(\"succeededAction\");\n\t}","id":40450,"modified_method":"public WOActionResults uploadSucceeded() throws MalformedURLException, IOException {\n\t\tAjaxUploadProgress progress = uploadProgress();\n\t\ttry {\n\t\t\tboolean deleteFile = true;\n\t\t\tif (hasBinding(\"filePath\")) {\n\t\t\t\tsetValueForBinding(progress.fileName(), \"filePath\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"data\")) {\n\t\t\t\tNSData data = new NSData(progress.tempFile().toURL());\n\t\t\t\tsetValueForBinding(data, \"data\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"inputStream\")) {\n\t\t\t\tsetValueForBinding(new FileInputStream(progress.tempFile()), \"inputStream\");\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (hasBinding(\"outputStream\")) {\n\t\t\t\tOutputStream outputStream = (OutputStream) valueForBinding(\"outputStream\");\n\t\t\t\tif (outputStream != null) {\n\t\t\t\t\tERXFileUtilities.writeInputStreamToOutputStream(new FileInputStream(progress.tempFile()), outputStream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasBinding(\"streamToFilePath\")) {\n\t\t\t\tFile streamToFile = new File((String) valueForBinding(\"streamToFilePath\"));\n\t\t\t\tboolean renamedFile;\n\t\t\t\tboolean renameFile;\n\t\t\t\tif (streamToFile.exists()) {\n\t\t\t\t\trenameFile = ERXComponentUtilities.booleanValueForBinding(this, \"overwrite\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenameFile = true;\n\t\t\t\t}\n\t\t\t\tif (renameFile) {\n\t\t\t\t\tERXFileUtilities.renameTo(progress.tempFile(), streamToFile);\n\t\t\t\t\trenamedFile = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenamedFile = false;\n\t\t\t\t}\n\t\t\t\tif (hasBinding(\"finalFilePath\")) {\n\t\t\t\t\tString finalFilePath;\n\t\t\t\t\tif (renamedFile) {\n\t\t\t\t\t\tfinalFilePath = streamToFile.getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinalFilePath = progress.tempFile().getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(finalFilePath, \"finalFilePath\");\n\t\t\t\t}\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (deleteFile) {\n\t\t\t\tprogress.dispose();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tuploadFinished();\n\t\t}\n\t\tWOActionResults results = (WOActionResults) valueForBinding(\"succeededAction\");\n\t\treturn results;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults uploadCanceled() {\n\t\tuploadFinished();\n\t\treturn (WOActionResults) valueForBinding(\"canceledAction\");\n\t}","id":40451,"modified_method":"public WOActionResults uploadCanceled() {\n\t\tuploadFinished();\n\t\tWOActionResults results = (WOActionResults) valueForBinding(\"canceledAction\");\n\t\treturn results;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults uploadFailed() {\n\t\tuploadFinished();\n\t\treturn (WOActionResults) valueForBinding(\"failedAction\");\n\t}","id":40452,"modified_method":"public WOActionResults uploadFailed() {\n\t\tuploadFinished();\n\t\tWOActionResults results = (WOActionResults) valueForBinding(\"failedAction\");\n\t\treturn results;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOResponse handleRequest(WORequest request) {\n\t\tWOApplication application = WOApplication.application();\n\t\tapplication.awake();\n\t\ttry {\n\t\t\tWOContext context = application.createContextForRequest(request);\n\t\t\tWOResponse response = application.createResponseInContext(context);\n\n\t\t\tString uploadIdentifier = null;\n\t\t\tString uploadFileName = null;\n\t\t\tInputStream uploadInputStream = null;\n\t\t\tint streamLength = -1;\n\n\t\t\ttry {\n\t\t\t\tString wosid = request.cookieValueForKey(\"wosid\");\n\t\t\t\tWOMultipartIterator multipartIterator = request.multipartIterator();\n\t\t\t\tif (multipartIterator == null) {\n\t\t\t\t\tresponse.appendContentString(\"Already Consumed!\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWOMultipartIterator.WOFormData formData = null;\n\t\t\t\t\twhile ((formData = multipartIterator.nextFormData()) != null) {\n\t\t\t\t\t\tString name = formData.name();\n\t\t\t\t\t\tif (\"wosid\".equals(name)) {\n\t\t\t\t\t\t\twosid = formData.formValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (\"id\".equals(name)) {\n\t\t\t\t\t\t\tuploadIdentifier = formData.formValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (formData.isFileUpload()) {\n\t\t\t\t\t\t\tuploadFileName = request.stringFormValueForKey(name + \".filename\");\n\t\t\t\t\t\t\tstreamLength = multipartIterator.contentLengthRemaining();\n\t\t\t\t\t\t\tuploadInputStream = formData.formDataInputStream();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext._setRequestSessionID(wosid);\n\t\t\t\t\tWOSession session = null;\n\t\t\t\t\tif (context._requestSessionID() != null) {\n\t\t\t\t\t\tsession = WOApplication.application().restoreSessionWithID(wosid, context);\n\t\t\t\t\t}\n\n\t\t\t\t\tFile tempFile = File.createTempFile(\"AjaxFileUpload\", \".tmp\", _tempFileFolder);\n\t\t\t\t\ttempFile.deleteOnExit();\n\t\t\t\t\tAjaxUploadProgress progress = new AjaxUploadProgress(uploadIdentifier, tempFile, uploadFileName, streamLength);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAjaxProgressBar.registerProgress(session, progress);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (context._requestSessionID() != null) {\n\t\t\t\t\t\t\tWOApplication.application().saveSessionForContext(context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tFileOutputStream fos = new FileOutputStream(progress.tempFile());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprogress.copyAndTrack(uploadInputStream, fos);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tfos.flush();\n\t\t\t\t\t\tfos.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tlog.error(t);\n\t\t\t\tresponse.appendContentString(\"Failed: \" + t.getMessage());\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\tfinally {\n\t\t\tapplication.sleep();\n\t\t}\n\t}","id":40453,"modified_method":"public WOResponse handleRequest(WORequest request) {\n\t\tWOApplication application = WOApplication.application();\n\t\tapplication.awake();\n\t\ttry {\n\t\t\tWOContext context = application.createContextForRequest(request);\n\t\t\tWOResponse response = application.createResponseInContext(context);\n\n\t\t\tString uploadIdentifier = null;\n\t\t\tString uploadFileName = null;\n\t\t\tInputStream uploadInputStream = null;\n\t\t\tint streamLength = -1;\n\n\t\t\ttry {\n\t\t\t\tString wosid = request.cookieValueForKey(\"wosid\");\n\t\t\t\tWOMultipartIterator multipartIterator = request.multipartIterator();\n\t\t\t\tif (multipartIterator == null) {\n\t\t\t\t\tresponse.appendContentString(\"Already Consumed!\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWOMultipartIterator.WOFormData formData = null;\n\t\t\t\t\twhile ((formData = multipartIterator.nextFormData()) != null) {\n\t\t\t\t\t\tString name = formData.name();\n\t\t\t\t\t\tif (\"wosid\".equals(name)) {\n\t\t\t\t\t\t\twosid = formData.formValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (\"id\".equals(name)) {\n\t\t\t\t\t\t\tuploadIdentifier = formData.formValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (formData.isFileUpload()) {\n\t\t\t\t\t\t\tuploadFileName = request.stringFormValueForKey(name + \".filename\");\n\t\t\t\t\t\t\tstreamLength = multipartIterator.contentLengthRemaining();\n\t\t\t\t\t\t\tuploadInputStream = formData.formDataInputStream();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext._setRequestSessionID(wosid);\n\t\t\t\t\tWOSession session = null;\n\t\t\t\t\tif (context._requestSessionID() != null) {\n\t\t\t\t\t\tsession = WOApplication.application().restoreSessionWithID(wosid, context);\n\t\t\t\t\t}\n\n\t\t\t\t\tFile tempFile = File.createTempFile(\"AjaxFileUpload\", \".tmp\", _tempFileFolder);\n\t\t\t\t\ttempFile.deleteOnExit();\n\t\t\t\t\tAjaxUploadProgress progress = new AjaxUploadProgress(uploadIdentifier, tempFile, uploadFileName, streamLength);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAjaxProgressBar.registerProgress(session, progress);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (context._requestSessionID() != null) {\n\t\t\t\t\t\t\tWOApplication.application().saveSessionForContext(context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileOutputStream fos = new FileOutputStream(progress.tempFile());\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprogress.copyAndTrack(uploadInputStream, fos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tfos.flush();\n\t\t\t\t\t\t\tfos.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!progress.isCanceled() && !progress.shouldReset()) {\n\t\t\t\t\t\t\tdownloadFinished(progress);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tprogress.setDone(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tlog.error(t);\n\t\t\t\tresponse.appendContentString(\"Failed: \" + t.getMessage());\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\tfinally {\n\t\t\tapplication.sleep();\n\t\t}\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns true if this procedure is done, not canceled, and not failed.\n\t * \n\t * @return true if this procedure is done, not canceled, and not failed\n\t */\n\tpublic boolean isSucceeded() {\n\t\treturn _done && !_canceled && _failure == null;\n\t}","id":40454,"modified_method":"/**\n\t * Returns true if this procedure is done, not canceled, and not failed.\n\t * \n\t * @return true if this procedure is done, not canceled, and not failed\n\t */\n\tpublic boolean isSucceeded() {\n\t\treturn _done && !_reset && !_canceled && _failure == null;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Convenience method for copying a stream and tracking it with this progress model.\n\t * \n\t * @param inputStream the inputstream to copy from\n\t * @param outputStream the outputstream to copy to\n\t * @throws IOException if there is a failure\n\t */\n\tpublic void copyAndTrack(InputStream inputStream, OutputStream outputStream) throws IOException {\n\t\tbyte[] buffer = new byte[64 * 1024];\n\t\ttry {\n\t\t\tboolean done = false;\n\t\t\tdo {\n\t\t\t\tint bytesRead = inputStream.read(buffer);\n\t\t\t\tif (bytesRead <= 0) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tincrementValue(bytesRead);\n\t\t\t\t\toutputStream.write(buffer, 0, bytesRead);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!done && !isCanceled());\n\t\t\tif (isCanceled()) {\n\t\t\t\tdispose();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tdispose();\n\t\t\tsetFailure(e);\n\t\t\tthrow e;\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\tdispose();\n\t\t\tsetFailure(e);\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsetDone(true);\n\t\t}\n\t}","id":40455,"modified_method":"/**\n\t * Convenience method for copying a stream and tracking it with this progress model.\n\t * \n\t * @param inputStream the inputstream to copy from\n\t * @param outputStream the outputstream to copy to\n\t * @throws IOException if there is a failure\n\t */\n\tpublic void copyAndTrack(InputStream inputStream, OutputStream outputStream) throws IOException {\n\t\tbyte[] buffer = new byte[64 * 1024];\n\t\ttry {\n\t\t\tboolean done = false;\n\t\t\tdo {\n\t\t\t\tint bytesRead = inputStream.read(buffer);\n\t\t\t\tif (bytesRead <= 0) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tincrementValue(bytesRead);\n\t\t\t\t\toutputStream.write(buffer, 0, bytesRead);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!done && !isCanceled() && !shouldReset());\n\t\t\tif (isCanceled() || shouldReset()) {\n\t\t\t\tdispose();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tdispose();\n\t\t\tsetFailure(e);\n\t\t\tthrow e;\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\tdispose();\n\t\t\tsetFailure(e);\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String finishedClass() {\n\t\tString finishedClass;\n\t\tString percentage = percentage();\n\t\tif (\"0\".equals(percentage)) {\n\t\t\tfinishedClass = \"percentageUnfinished\";\n\t\t}\n\t\telse {\n\t\t\tfinishedClass = \"percentageFinished\";\n\t\t}\n\t\treturn finishedClass;\n\t}","id":40456,"modified_method":"public String finishedClass() {\n\t\tString finishedClass;\n\t\tString percentage = percentage();\n\t\tif (\"0\".equals(percentage)) {\n\t\t\tfinishedClass = \"percentageUnfinished\";\n\t\t}\n\t\telse {\n\t\t\tAjaxProgress progress = progress();\n\t\t\tif (progress != null && progress.isDone()) {\n\t\t\t\tfinishedClass = \"percentageFinished done\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinishedClass = \"percentageFinished\";\n\t\t\t}\n\t\t}\n\t\treturn finishedClass;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public AjaxProgress progress() {\n\t\tif (_progress != null && _progress.shouldReset()) {\n\t\t\t_progress = null;\n\t\t\tsetValueForBinding(null, \"progress\");\n\t\t}\n\t\tif (_progress == null) {\n\t\t\t_progress = (AjaxProgress) valueForBinding(\"progress\");\n\t\t\tif (_progress != null && _progress.shouldReset()) {\n\t\t\t\t_progress = null;\n\t\t\t\tsetValueForBinding(null, \"progress\");\n\t\t\t}\n\t\t\tif (_progress == null) {\n\t\t\t\t_progress = AjaxProgressBar.progress(session(), progressID());\n\t\t\t\tif (_progress != null) {\n\t\t\t\t\tsetValueForBinding(_progress, \"progress\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _progress;\n\t}","id":40457,"modified_method":"public AjaxProgress progress() {\n\t\tif (_progress != null && _progress.shouldReset()) {\n\t\t\t_progress = null;\n\t\t\tsetValueForBinding(null, \"progress\");\n\t\t}\n\t\tif (_progress == null) {\n\t\t\t_progress = (AjaxProgress) valueForBinding(\"progress\");\n\t\t\tif (_progress != null && _progress.shouldReset()) {\n\t\t\t\t_progress = null;\n\t\t\t\tsetValueForBinding(null, \"progress\");\n\t\t\t}\n\t\t\tif (_progress == null) {\n\t\t\t\t_progress = AjaxProgressBar.progress(session(), progressID());\n\t\t\t\tif (_progress != null) {\n\t\t\t\t\tif (_progress.shouldReset()) {\n\t\t\t\t\t\tAjaxProgressBar.unregisterProgress(session(), _progress);\n\t\t\t\t\t\t_progress = null;\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(_progress, \"progress\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _progress;\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void _checkForCompletion() {\n\t\tAjaxProgress progress = progress();\n\t\tif (progress != null) {\n\t\t\tif (progress.isDone()) {\n\t\t\t\tif (!progress.completionEventsFired()) {\n\t\t\t\t\tif (progress.isCanceled()) {\n\t\t\t\t\t\tuploadCanceled();\n\t\t\t\t\t}\n\t\t\t\t\telse if (progress.isFailed()) {\n\t\t\t\t\t\tuploadFailed();\n\t\t\t\t\t}\n\t\t\t\t\telse if (progress.isSucceeded()) {\n\t\t\t\t\t\tuploadSucceeded();\n\t\t\t\t\t}\n\t\t\t\t\tprogress.setCompletionEventsFired(true);\n\t\t\t\t\t_fireJavascriptEvents = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":40458,"modified_method":"protected void _checkForCompletion() {\n\t\tAjaxProgress progress = progress();\n\t\tif (progress != null) {\n\t\t\tif (progress.isDone()) {\n\t\t\t\tif (!progress.completionEventsFired()) {\n\t\t\t\t\tif (progress.isCanceled()) {\n\t\t\t\t\t\tprogressCanceled();\n\t\t\t\t\t}\n\t\t\t\t\telse if (progress.isFailed()) {\n\t\t\t\t\t\tprogressFailed();\n\t\t\t\t\t}\n\t\t\t\t\telse if (progress.isSucceeded()) {\n\t\t\t\t\t\tprogressSucceeded();\n\t\t\t\t\t}\n\t\t\t\t\tprogress.setCompletionEventsFired(true);\n\t\t\t\t\t_fireJavascriptEvents = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"429ca76a8ea191324772d4793b46d7d583ff412a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults uploadSucceeded() {\n\t\tAjaxUploadProgress progress = uploadProgress();\n\t\ttry {\n\t\t\tboolean deleteFile = true;\n\t\t\tif (hasBinding(\"filePath\")) {\n\t\t\t\tsetValueForBinding(progress.fileName(), \"filePath\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"data\")) {\n\t\t\t\tNSData data = new NSData(progress.tempFile().toURL());\n\t\t\t\tsetValueForBinding(data, \"data\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"inputStream\")) {\n\t\t\t\tsetValueForBinding(new FileInputStream(progress.tempFile()), \"inputStream\");\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (hasBinding(\"outputStream\")) {\n\t\t\t\tOutputStream outputStream = (OutputStream) valueForBinding(\"outputStream\");\n\t\t\t\tif (outputStream != null) {\n\t\t\t\t\tERXFileUtilities.writeInputStreamToOutputStream(new FileInputStream(progress.tempFile()), outputStream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasBinding(\"streamToFilePath\")) {\n\t\t\t\tFile streamToFile = new File((String) valueForBinding(\"streamToFilePath\"));\n\t\t\t\tboolean renamedFile;\n\t\t\t\tboolean renameFile;\n\t\t\t\tif (streamToFile.exists()) {\n\t\t\t\t\tboolean overwrite = ERXComponentUtilities.booleanValueForBinding(this, \"overwrite\");\n\t\t\t\t\t\n\t\t\t\t\tif (streamToFile.isDirectory()) {\n\t\t\t\t\t\tFile parentDir = streamToFile;\n\t\t\t\t\t\tString fileName = fileNameFromBrowserSubmittedPath(progress.fileName());\n\t\t\t\t\t\tstreamToFile = new File(parentDir, fileName);\n\t\t\t\t\t\tif (!overwrite) {\n\t\t\t\t\t\t\t// try to reserve file name\n\t\t\t\t\t\t\tif (!streamToFile.createNewFile()) {\n\t\t\t\t\t\t\t\t// didn't work, so try new name consisting of\n\t\t\t\t\t\t\t\t// prefix + number + suffix\n\t\t\t\t\t\t\t\tint dotIndex = fileName.lastIndexOf('.');\n\t\t\t\t\t\t\t\tString prefix, suffix;\n\n\t\t\t\t\t\t\t\tif (dotIndex < 0) {\n\t\t\t\t\t\t\t\t\tprefix = fileName;\n\t\t\t\t\t\t\t\t\tsuffix = \"\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tprefix = fileName.substring(0, dotIndex);\n\t\t\t\t\t\t\t\t\tsuffix = fileName.substring(dotIndex);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try until we can reserve a file\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t// using System.currentTimeMillis() as number for now\n\t\t\t\t\t\t\t\t\tstreamToFile = new File(parentDir, prefix + \"-\" + System.currentTimeMillis() + suffix);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twhile (!streamToFile.createNewFile());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trenameFile = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\trenameFile = overwrite;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenameFile = true;\n\t\t\t\t}\n\n\t\t\t\tif (renameFile && !streamToFile.isDirectory()) {\n\t\t\t\t\tERXFileUtilities.renameTo(progress.tempFile(), streamToFile);\n\t\t\t\t\trenamedFile = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenamedFile = false;\n\t\t\t\t\tprogress.setFailure(new Exception (\"Could not rename file.\"));\n\t\t\t\t\treturn this.uploadFailed();\n\t\t\t\t}\n\t\t\t\tif (hasBinding(\"finalFilePath\")) {\n\t\t\t\t\tString finalFilePath;\n\t\t\t\t\tif (renamedFile) {\n\t\t\t\t\t\tfinalFilePath = streamToFile.getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinalFilePath = progress.tempFile().getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(finalFilePath, \"finalFilePath\");\n\t\t\t\t}\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (deleteFile) {\n\t\t\t\tprogress.dispose();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tprogress.setFailure(t);\n\t\t\treturn this.uploadFailed();\n\t\t}\n\t\tfinally {\n\t\t\tuploadFinished();\n\t\t}\n\t\tWOActionResults results = (WOActionResults) valueForBinding(\"succeededAction\");\n\t\treturn results;\n\t}","id":40459,"modified_method":"public WOActionResults uploadSucceeded() {\n\t\tAjaxUploadProgress progress = uploadProgress();\n\t\ttry {\n\t\t\tboolean deleteFile = true;\n\t\t\tif (hasBinding(\"filePath\")) {\n\t\t\t\tsetValueForBinding(progress.fileName(), \"filePath\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"data\")) {\n\t\t\t\tNSData data = new NSData(progress.tempFile().toURL());\n\t\t\t\tsetValueForBinding(data, \"data\");\n\t\t\t}\n\n\t\t\tif (hasBinding(\"inputStream\")) {\n\t\t\t\tsetValueForBinding(new FileInputStream(progress.tempFile()), \"inputStream\");\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\n\t\t\tif (hasBinding(\"outputStream\")) {\n\t\t\t\tOutputStream outputStream = (OutputStream) valueForBinding(\"outputStream\");\n\t\t\t\tif (outputStream != null) {\n\t\t\t\t\tERXFileUtilities.writeInputStreamToOutputStream(new FileInputStream(progress.tempFile()), outputStream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString finalFilePath = progress.tempFile().getAbsolutePath();\n\t\t\tif (hasBinding(\"streamToFilePath\")) {\n\t\t\t\tFile streamToFile = new File((String) valueForBinding(\"streamToFilePath\"));\n\t\t\t\tboolean renamedFile;\n\t\t\t\tboolean renameFile;\n\t\t\t\tif (streamToFile.exists()) {\n\t\t\t\t\tboolean overwrite = ERXComponentUtilities.booleanValueForBinding(this, \"overwrite\");\n\t\t\t\t\t\n\t\t\t\t\tif (streamToFile.isDirectory()) {\n\t\t\t\t\t\tFile parentDir = streamToFile;\n\t\t\t\t\t\tString fileName = fileNameFromBrowserSubmittedPath(progress.fileName());\n\t\t\t\t\t\tstreamToFile = new File(parentDir, fileName);\n\t\t\t\t\t\tif (!overwrite) {\n\t\t\t\t\t\t\t// try to reserve file name\n\t\t\t\t\t\t\tif (!streamToFile.createNewFile()) {\n\t\t\t\t\t\t\t\t// didn't work, so try new name consisting of\n\t\t\t\t\t\t\t\t// prefix + number + suffix\n\t\t\t\t\t\t\t\tint dotIndex = fileName.lastIndexOf('.');\n\t\t\t\t\t\t\t\tString prefix, suffix;\n\n\t\t\t\t\t\t\t\tif (dotIndex < 0) {\n\t\t\t\t\t\t\t\t\tprefix = fileName;\n\t\t\t\t\t\t\t\t\tsuffix = \"\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tprefix = fileName.substring(0, dotIndex);\n\t\t\t\t\t\t\t\t\tsuffix = fileName.substring(dotIndex);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try until we can reserve a file\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t// using System.currentTimeMillis() as number for now\n\t\t\t\t\t\t\t\t\tstreamToFile = new File(parentDir, prefix + \"-\" + System.currentTimeMillis() + suffix);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twhile (!streamToFile.createNewFile());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trenameFile = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\trenameFile = overwrite;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenameFile = true;\n\t\t\t\t}\n\n\t\t\t\tif (renameFile && !streamToFile.isDirectory()) {\n\t\t\t\t\tERXFileUtilities.renameTo(progress.tempFile(), streamToFile);\n\t\t\t\t\trenamedFile = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trenamedFile = false;\n\t\t\t\t\tprogress.setFailure(new Exception (\"Could not rename file.\"));\n\t\t\t\t\treturn this.uploadFailed();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (renamedFile) {\n\t\t\t\t\tfinalFilePath = streamToFile.getAbsolutePath();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdeleteFile = false;\n\t\t\t}\n\t\t\telse if (hasBinding(\"keepTempFile\") && deleteFile) {\n\t\t\t\tdeleteFile = ERXComponentUtilities.booleanValueForBinding(this, \"keepTempFile\");\n\t\t\t}\n\n\t\t\tif (deleteFile) {\n\t\t\t\tprogress.dispose();\n\t\t\t}\n\t\t\telse if (hasBinding(\"finalFilePath\")) {\n\t\t\t\tsetValueForBinding(finalFilePath, \"finalFilePath\");\n\t\t\t}\n\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tprogress.setFailure(t);\n\t\t\treturn this.uploadFailed();\n\t\t}\n\t\tfinally {\n\t\t\tuploadFinished();\n\t\t}\n\t\tWOActionResults results = (WOActionResults) valueForBinding(\"succeededAction\");\n\t\treturn results;\n\t}","commit_id":"fb123eb71dcf82f4c2edfad705ec2e519832d128","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean keepWhiteSpacesInsideTag(final XmlTag tag) {\n    return checkName(tag, mySettings.HTML_KEEP_WHITESPACES_INSIDE);\n  }","id":40460,"modified_method":"public boolean keepWhiteSpacesInsideTag(final XmlTag tag) {\n    return checkName(tag, mySettings.HTML_KEEP_WHITESPACES_INSIDE) || \"jsp:attribute\".equals(tag.getName());\n  }","commit_id":"1d3dbecaae1ffcbd9a0692abc6e001dfa6f45590","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isInlineTag(final XmlTag tag) {\n    return checkName(tag, mySettings.HTML_INLINE_ELEMENTS);\n  }","id":40461,"modified_method":"private boolean isInlineTag(final XmlTag tag) {\n    return checkName(tag, mySettings.HTML_INLINE_ELEMENTS) || tag.getNamespacePrefix().length() > 0;\n  }","commit_id":"1d3dbecaae1ffcbd9a0692abc6e001dfa6f45590","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    AbstractGradleDependency<?> that = (AbstractGradleDependency<?>)o;\n    return myTarget.equals(that.myTarget);\n  }","id":40462,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    AbstractGradleDependency<?> that = (AbstractGradleDependency<?>)o;\n    return myOwnerModule.equals(that.myOwnerModule) && myTarget.equals(that.myTarget);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return myTarget.hashCode();\n  }","id":40463,"modified_method":"@Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + myOwnerModule.hashCode();\n    result = 31 * result + myTarget.hashCode();\n    return result;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected AbstractGradleDependency(@NotNull T dependency) {\n    myTarget = dependency;\n    initListener();\n  }","id":40464,"modified_method":"protected AbstractGradleDependency(@NotNull GradleModule ownerModule, @NotNull T dependency) {\n    myOwnerModule = ownerModule;\n    myTarget = dependency;\n    initListener();\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void updateStep() {\n    if (myOnValidateAttempt) {\n      // We assume that this method is called when project validation triggered by end-user fails (he or she pressed 'Next'/'Finish' \n      // button at the wizard and current state is invalid). So, there is no need to rebuild the model then.\n      myOnValidateAttempt = false;\n      return;\n    }\n\n    clear();\n\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return;\n    }\n    GradleProject project = builder.getGradleProject();\n    if (project == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't init 'adjust importing settings' step. Reason: no project is defined. Context: '%s', builder: '%s'\",\n        getWizardContext(), getBuilder()\n      ));\n    }\n\n    Map<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>> entity2nodes\n      = new HashMap<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>>();\n    int counter = 0;\n    DefaultMutableTreeNode root = buildNode(project, entity2nodes, counter++);\n\n    List<GradleModule> modules = new ArrayList<GradleModule>(project.getModules());\n    Collections.sort(modules, Named.COMPARATOR);\n    List<MutableTreeNode> moduleNodes = new ArrayList<MutableTreeNode>();\n    Map<GradleModule, GradleModule> moduleMappings = new HashMap<GradleModule, GradleModule>();\n    \n    GradleEntityCloneContext cloneContext = new GradleEntityCloneContext();\n    for (GradleModule module : modules) {\n      GradleModule moduleCopy = module.clone(cloneContext);\n      moduleMappings.put(module, moduleCopy);\n      DefaultMutableTreeNode moduleNode = buildNode(module, entity2nodes, counter++);\n      moduleNodes.add(moduleNode);\n      for (GradleContentRoot contentRoot : moduleCopy.getContentRoots()) {\n        moduleNode.add(buildNode(contentRoot, entity2nodes, counter++));\n      }\n      Collection<GradleDependency> dependencies = module.getDependencies();\n      if (!dependencies.isEmpty()) {\n        DefaultMutableTreeNode dependenciesNode\n          = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.dependencies\"));\n        final List<GradleModuleDependency> moduleDependencies = new ArrayList<GradleModuleDependency>();\n        final List<GradleLibraryDependency> libraryDependencies = new ArrayList<GradleLibraryDependency>();\n        GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n          @Override\n          public void visit(@NotNull GradleModuleDependency dependency) {\n            moduleDependencies.add(dependency);\n          }\n\n          @Override\n          public void visit(@NotNull GradleLibraryDependency dependency) {\n            libraryDependencies.add(dependency);\n          }\n        };\n        for (GradleDependency dependency : dependencies) {\n          dependency.invite(visitor);\n        }\n        Collections.sort(moduleDependencies, GradleModuleDependency.COMPARATOR);\n        Collections.sort(libraryDependencies, Named.COMPARATOR);\n        for (GradleModuleDependency dependency : moduleDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        for (GradleLibraryDependency dependency : libraryDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        moduleNode.add(dependenciesNode);\n      }\n    }\n\n    myTreeModel.setRoot(root);\n    myTree.setSelectionPath(new TreePath(root));\n    \n    Collection<? extends GradleLibrary> libraries = project.getLibraries();\n    if (libraries.isEmpty()) {\n      for (MutableTreeNode node : moduleNodes) {\n        root.add(node);\n      }\n    }\n    else {\n      // Insert intermediate 'modules' and 'libraries' nodes if the project has both libraries and nodes.\n      DefaultMutableTreeNode modulesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.modules\"));\n      for (MutableTreeNode node : moduleNodes) {\n        modulesNode.add(node);\n      }\n      root.add(modulesNode);\n\n      List<GradleLibrary> sortedLibraries = new ArrayList<GradleLibrary>(libraries);\n      Collections.sort(sortedLibraries, Named.COMPARATOR);\n      DefaultMutableTreeNode librariesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.libraries\"));\n      for (GradleLibrary library : sortedLibraries) {\n        librariesNode.add(buildNode(library, entity2nodes, counter++));\n      }\n      root.add(librariesNode);\n\n      myTree.expandPath(new TreePath(modulesNode.getPath()));\n      myTree.expandPath(new TreePath(librariesNode.getPath()));\n    }\n    \n    myTree.expandPath(new TreePath(root.getPath()));\n    builder.setModuleMappings(moduleMappings);\n  }","id":40465,"modified_method":"@Override\n  public void updateStep() {\n    if (myOnValidateAttempt) {\n      // We assume that this method is called when project validation triggered by end-user fails (he or she pressed 'Next'/'Finish' \n      // button at the wizard and current state is invalid). So, there is no need to rebuild the model then.\n      myOnValidateAttempt = false;\n      return;\n    }\n\n    clear();\n\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return;\n    }\n    GradleProject project = builder.getGradleProject();\n    if (project == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't init 'adjust importing settings' step. Reason: no project is defined. Context: '%s', builder: '%s'\",\n        getWizardContext(), getBuilder()\n      ));\n    }\n\n    Map<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>> entity2nodes\n      = new HashMap<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>>();\n    int counter = 0;\n    DefaultMutableTreeNode root = buildNode(project, entity2nodes, counter++);\n\n    List<GradleModule> modules = new ArrayList<GradleModule>(project.getModules());\n    Collections.sort(modules, Named.COMPARATOR);\n    List<MutableTreeNode> moduleNodes = new ArrayList<MutableTreeNode>();\n    Map<GradleModule, GradleModule> moduleMappings = new HashMap<GradleModule, GradleModule>();\n    \n    GradleEntityCloneContext cloneContext = new GradleEntityCloneContext();\n    for (GradleModule module : modules) {\n      GradleModule moduleCopy = module.clone(cloneContext);\n      moduleMappings.put(module, moduleCopy);\n      DefaultMutableTreeNode moduleNode = buildNode(module, entity2nodes, counter++);\n      moduleNodes.add(moduleNode);\n      for (GradleContentRoot contentRoot : moduleCopy.getContentRoots()) {\n        moduleNode.add(buildNode(contentRoot, entity2nodes, counter++));\n      }\n      Collection<GradleDependency> dependencies = module.getDependencies();\n      if (!dependencies.isEmpty()) {\n        DefaultMutableTreeNode dependenciesNode\n          = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.project.structure.tree.node.dependencies\"));\n        final List<GradleModuleDependency> moduleDependencies = new ArrayList<GradleModuleDependency>();\n        final List<GradleLibraryDependency> libraryDependencies = new ArrayList<GradleLibraryDependency>();\n        GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n          @Override\n          public void visit(@NotNull GradleModuleDependency dependency) {\n            moduleDependencies.add(dependency);\n          }\n\n          @Override\n          public void visit(@NotNull GradleLibraryDependency dependency) {\n            libraryDependencies.add(dependency);\n          }\n        };\n        for (GradleDependency dependency : dependencies) {\n          dependency.invite(visitor);\n        }\n        Collections.sort(moduleDependencies, GradleModuleDependency.COMPARATOR);\n        Collections.sort(libraryDependencies, Named.COMPARATOR);\n        for (GradleModuleDependency dependency : moduleDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        for (GradleLibraryDependency dependency : libraryDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        moduleNode.add(dependenciesNode);\n      }\n    }\n\n    myTreeModel.setRoot(root);\n    myTree.setSelectionPath(new TreePath(root));\n    \n    Collection<? extends GradleLibrary> libraries = project.getLibraries();\n    if (libraries.isEmpty()) {\n      for (MutableTreeNode node : moduleNodes) {\n        root.add(node);\n      }\n    }\n    else {\n      // Insert intermediate 'modules' and 'libraries' nodes if the project has both libraries and nodes.\n      DefaultMutableTreeNode modulesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.modules\"));\n      for (MutableTreeNode node : moduleNodes) {\n        modulesNode.add(node);\n      }\n      root.add(modulesNode);\n\n      List<GradleLibrary> sortedLibraries = new ArrayList<GradleLibrary>(libraries);\n      Collections.sort(sortedLibraries, Named.COMPARATOR);\n      DefaultMutableTreeNode librariesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.libraries\"));\n      for (GradleLibrary library : sortedLibraries) {\n        librariesNode.add(buildNode(library, entity2nodes, counter++));\n      }\n      root.add(librariesNode);\n\n      myTree.expandPath(new TreePath(modulesNode.getPath()));\n      myTree.expandPath(new TreePath(librariesNode.getPath()));\n    }\n    \n    myTree.expandPath(new TreePath(root.getPath()));\n    builder.setModuleMappings(moduleMappings);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Pair<Tree, DefaultTreeModel> init() {\n    myContent.removeAll();\n    String projectName = GradleBundle.message(\"gradle.settings.color.text.sample.conflict.node.name\");\n    DefaultMutableTreeNode root = createNode(projectName, GradleIcons.PROJECT_ICON, GradleTextAttributes.GRADLE_CHANGE_CONFLICT);\n\n    String moduleName = GradleBundle.message(\"gradle.settings.color.text.sample.node.confirmed.name\");\n    DefaultMutableTreeNode module = createNode(moduleName, GradleIcons.MODULE_ICON, GradleTextAttributes.GRADLE_CONFIRMED_CONFLICT);\n\n    String gradleLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.gradle.name\");\n    DefaultMutableTreeNode gradleLibrary = createNode(\n      gradleLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.GRADLE_LOCAL_CHANGE\n    );\n\n    String intellijLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.intellij.name\",\n                                                      ApplicationNamesInfo.getInstance().getProductName());\n    DefaultMutableTreeNode intellijLibrary = createNode(\n      intellijLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.GRADLE_INTELLIJ_LOCAL_CHANGE\n    );\n    \n    String syncLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.sync.name\");\n    DefaultMutableTreeNode syncLibrary = createNode(syncLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.GRADLE_NO_CHANGE);\n    \n    module.add(gradleLibrary);\n    module.add(intellijLibrary);\n    module.add(syncLibrary);\n    root.add(module);\n    \n    mySelectedNode = root;\n    \n    DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    Tree tree = buildTree(treeModel, module);\n    \n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.fill = GridBagConstraints.BOTH;\n    constraints.weightx = constraints.weighty = 1;\n    myContent.add(new JBScrollPane(tree), constraints);\n    return new Pair<Tree, DefaultTreeModel>(tree, treeModel);\n  }","id":40466,"modified_method":"private Pair<Tree, DefaultTreeModel> init() {\n    myContent.removeAll();\n    String projectName = GradleBundle.message(\"gradle.settings.color.text.sample.conflict.node.name\");\n    DefaultMutableTreeNode root = createNode(projectName, GradleIcons.PROJECT_ICON, GradleTextAttributes.GRADLE_CHANGE_CONFLICT);\n\n    String moduleName = GradleBundle.message(\"gradle.settings.color.text.sample.node.confirmed.name\");\n    DefaultMutableTreeNode module = createNode(moduleName, GradleIcons.MODULE_ICON, GradleTextAttributes.GRADLE_CONFIRMED_CONFLICT);\n\n    String gradleLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.gradle.name\");\n    DefaultMutableTreeNode gradleLibrary = createNode(\n      gradleLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.GRADLE_LOCAL_CHANGE\n    );\n\n    String intellijLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.intellij.name\",\n                                                      ApplicationNamesInfo.getInstance().getProductName());\n    DefaultMutableTreeNode intellijLibrary = createNode(\n      intellijLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.INTELLIJ_LOCAL_CHANGE\n    );\n    \n    String syncLibraryName = GradleBundle.message(\"gradle.settings.color.text.sample.node.sync.name\");\n    DefaultMutableTreeNode syncLibrary = createNode(syncLibraryName, GradleIcons.LIB_ICON, GradleTextAttributes.GRADLE_NO_CHANGE);\n    \n    module.add(gradleLibrary);\n    module.add(intellijLibrary);\n    module.add(syncLibrary);\n    root.add(module);\n    \n    mySelectedNode = root;\n    \n    DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    Tree tree = buildTree(treeModel, module);\n    \n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.fill = GridBagConstraints.BOTH;\n    constraints.weightx = constraints.weighty = 1;\n    myContent.add(new JBScrollPane(tree), constraints);\n    return new Pair<Tree, DefaultTreeModel>(tree, treeModel);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates new <code>GradleEntityPresenceChange<\/code> project.\n   *\n   * @param gradleEntity    target entity at Gradle side. <code>null<\/code> as indication that the entity was removed at Gradle side\n   *                        or added at IntelliJ side\n   * @param intellijEntity  target entity at IntelliJ IDEA side. <code>null<\/code> as indication that the entity was removed\n   *                        at IntelliJ IDEA side or added at IntelliJ side\n   * @throws IllegalArgumentException    if both of the given entities are defined or undefined. Expecting this constructor to be\n   *                                     called with one <code>null<\/code> argument and one non-<code>null<\/code> argument\n   */\n  public GradleEntityPresenceChange(@Nullable G gradleEntity, @Nullable I intellijEntity) throws IllegalArgumentException {\n    if (gradleEntity  == null ^ intellijEntity  == null) {\n      throw new IllegalArgumentException(String.format(\n        \"Can't construct %s object. Reason: expected that only gradle or intellij entity is null, actual: gradle='%s'; intellij='%s'\",\n        getClass(), gradleEntity, intellijEntity\n      ));\n    }\n    myGradleEntity = gradleEntity;\n    myIntellijEntity = intellijEntity;\n  }","id":40467,"modified_method":"/**\n   * Creates new <code>GradleEntityPresenceChange<\/code> project.\n   *\n   * @param gradleEntity    target entity at Gradle side. <code>null<\/code> as indication that the entity was removed at Gradle side\n   *                        or added at IntelliJ side\n   * @param intellijEntity  target entity at IntelliJ IDEA side. <code>null<\/code> as indication that the entity was removed\n   *                        at IntelliJ IDEA side or added at IntelliJ side\n   * @throws IllegalArgumentException    if both of the given entities are defined or undefined. Expecting this constructor to be\n   *                                     called with one <code>null<\/code> argument and one non-<code>null<\/code> argument\n   */\n  public GradleEntityPresenceChange(@Nullable G gradleEntity, @Nullable I intellijEntity) throws IllegalArgumentException {\n    if (!(gradleEntity == null ^ intellijEntity == null)) {\n      throw new IllegalArgumentException(String.format(\n        \"Can't construct %s object. Reason: expected that only gradle or intellij entity is null, actual: gradle='%s'; intellij='%s'\",\n        getClass(), gradleEntity, intellijEntity\n      ));\n    }\n    myGradleEntity = gradleEntity;\n    myIntellijEntity = intellijEntity;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleLibraryDependency(@NotNull GradleLibrary library) {\n    super(library);\n  }","id":40468,"modified_method":"public GradleLibraryDependency(@NotNull GradleModule ownerModule, @NotNull GradleLibrary library) {\n    super(ownerModule, library);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public GradleLibraryDependency clone(@NotNull GradleEntityCloneContext context) {\n    GradleLibraryDependency result = new GradleLibraryDependency(getTarget().clone(context));\n    copyTo(result);\n    return result;\n  }","id":40469,"modified_method":"@NotNull\n  @Override\n  public GradleLibraryDependency clone(@NotNull GradleEntityCloneContext context) {\n    GradleLibraryDependency result = new GradleLibraryDependency(getOwnerModule().clone(context), getTarget().clone(context));\n    copyTo(result);\n    return result;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public GradleModuleDependency clone(@NotNull GradleEntityCloneContext context) {\n    GradleModuleDependency result = new GradleModuleDependency(getTarget().clone(context));\n    copyTo(result); \n    return result;\n  }","id":40470,"modified_method":"@NotNull\n  @Override\n  public GradleModuleDependency clone(@NotNull GradleEntityCloneContext context) {\n    GradleModuleDependency result = new GradleModuleDependency(getOwnerModule().clone(context), getTarget().clone(context));\n    copyTo(result); \n    return result;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleModuleDependency(@NotNull GradleModule module) {\n    super(module);\n  }","id":40471,"modified_method":"public GradleModuleDependency(@NotNull GradleModule ownerModule, @NotNull GradleModule module) {\n    super(ownerModule, module);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Collection<GradleProjectStructureChange> calculateDiff(@NotNull GradleModule gradleModule,\n                                                                @NotNull Module intellijModule,\n                                                                @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    //TODO den implement\n    return new HashSet<GradleProjectStructureChange>();\n  }","id":40472,"modified_method":"@NotNull\n  @Override\n  public Set<GradleProjectStructureChange> calculate(@NotNull GradleModule gradleEntity,\n                                                     @NotNull Module intellijEntity,\n                                                     @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    //TODO den process module-local settings\n    //TODO den process content roots \n    return checkDependencies(gradleEntity, intellijEntity, knownChanges);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static AbstractGradleDependency buildDependency(@NotNull IdeaSingleEntryLibraryDependency dependency, \n                                                          @NotNull GradleProject intellijProject)\n    throws IllegalStateException\n  {\n    File binaryPath = dependency.getFile();\n    if (binaryPath == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't parse external library dependency '%s'. Reason: it doesn't specify path to the binaries\", dependency\n      ));\n    }\n    \n    // Gradle API doesn't provide library name at the moment.\n    GradleLibrary library = new GradleLibrary(FileUtil.getNameWithoutExtension(binaryPath));\n    library.addPath(LibraryPathType.BINARY, binaryPath.getAbsolutePath());\n\n    File sourcePath = dependency.getSource();\n    if (sourcePath != null) {\n      library.addPath(LibraryPathType.SOURCE, sourcePath.getAbsolutePath());\n    }\n\n    File javadocPath = dependency.getJavadoc();\n    if (javadocPath != null) {\n      library.addPath(LibraryPathType.DOC, javadocPath.getAbsolutePath());\n    }\n\n    if (!intellijProject.addLibrary(library)) {\n      for (GradleLibrary registeredLibrary : intellijProject.getLibraries()) {\n        if (registeredLibrary.equals(library)) {\n          return new GradleLibraryDependency(registeredLibrary);\n        }\n      }\n    }\n    \n    return new GradleLibraryDependency(library);\n  }","id":40473,"modified_method":"@NotNull\n  private static AbstractGradleDependency buildDependency(@NotNull GradleModule ownerModule,\n                                                          @NotNull IdeaSingleEntryLibraryDependency dependency, \n                                                          @NotNull GradleProject intellijProject)\n    throws IllegalStateException\n  {\n    File binaryPath = dependency.getFile();\n    if (binaryPath == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't parse external library dependency '%s'. Reason: it doesn't specify path to the binaries\", dependency\n      ));\n    }\n    \n    // Gradle API doesn't provide library name at the moment.\n    GradleLibrary library = new GradleLibrary(FileUtil.getNameWithoutExtension(binaryPath));\n    library.addPath(LibraryPathType.BINARY, binaryPath.getAbsolutePath());\n\n    File sourcePath = dependency.getSource();\n    if (sourcePath != null) {\n      library.addPath(LibraryPathType.SOURCE, sourcePath.getAbsolutePath());\n    }\n\n    File javadocPath = dependency.getJavadoc();\n    if (javadocPath != null) {\n      library.addPath(LibraryPathType.DOC, javadocPath.getAbsolutePath());\n    }\n\n    if (!intellijProject.addLibrary(library)) {\n      for (GradleLibrary registeredLibrary : intellijProject.getLibraries()) {\n        if (registeredLibrary.equals(library)) {\n          return new GradleLibraryDependency(ownerModule, registeredLibrary);\n        }\n      }\n    }\n    \n    return new GradleLibraryDependency(ownerModule, library);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static AbstractGradleDependency buildDependency(@NotNull IdeaModuleDependency dependency, @NotNull GradleProject intellijProject)\n    throws IllegalStateException\n  {\n    IdeaModule module = dependency.getDependencyModule();\n    if (module == null) {\n      throw new IllegalStateException(\n        String.format(\"Can't parse gradle module dependency '%s'. Reason: referenced module is null\", dependency)\n      );\n    }\n\n    String moduleName = module.getName();\n    if (moduleName == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't parse gradle module dependency '%s'. Reason: referenced module name is undefined (module: '%s') \", dependency, module\n      ));\n    }\n    \n    Set<String> registeredModuleNames = new HashSet<String>();\n    for (GradleModule gradleModule : intellijProject.getModules()) {\n      registeredModuleNames.add(gradleModule.getName());\n      if (gradleModule.getName().equals(moduleName)) {\n        return new GradleModuleDependency(gradleModule);\n      }\n    }\n    throw new IllegalStateException(String.format(\n      \"Can't parse gradle module dependency '%s'. Reason: no module with such name (%s) is found. Registered modules: %s\",\n      dependency, moduleName, registeredModuleNames\n    ));\n  }","id":40474,"modified_method":"@NotNull\n  private static AbstractGradleDependency buildDependency(@NotNull GradleModule ownerModule,\n                                                          @NotNull IdeaModuleDependency dependency,\n                                                          @NotNull GradleProject intellijProject)\n    throws IllegalStateException\n  {\n    IdeaModule module = dependency.getDependencyModule();\n    if (module == null) {\n      throw new IllegalStateException(\n        String.format(\"Can't parse gradle module dependency '%s'. Reason: referenced module is null\", dependency)\n      );\n    }\n\n    String moduleName = module.getName();\n    if (moduleName == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't parse gradle module dependency '%s'. Reason: referenced module name is undefined (module: '%s') \", dependency, module\n      ));\n    }\n    \n    Set<String> registeredModuleNames = new HashSet<String>();\n    for (GradleModule gradleModule : intellijProject.getModules()) {\n      registeredModuleNames.add(gradleModule.getName());\n      if (gradleModule.getName().equals(moduleName)) {\n        return new GradleModuleDependency(ownerModule, gradleModule);\n      }\n    }\n    throw new IllegalStateException(String.format(\n      \"Can't parse gradle module dependency '%s'. Reason: no module with such name (%s) is found. Registered modules: %s\",\n      dependency, moduleName, registeredModuleNames\n    ));\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void populateDependencies(@NotNull IdeaModule gradleModule, @NotNull GradleModule intellijModule, \n                                           @NotNull GradleProject intellijProject)\n  {\n    DomainObjectSet<? extends IdeaDependency> dependencies = gradleModule.getDependencies();\n    if (dependencies == null) {\n      return;\n    }\n    for (IdeaDependency dependency : dependencies) {\n      if (dependency == null) {\n        continue;\n      }\n      AbstractGradleDependency intellijDependency = null;\n      if (dependency instanceof IdeaModuleDependency) {\n        intellijDependency = buildDependency((IdeaModuleDependency)dependency, intellijProject);\n      }\n      else if (dependency instanceof IdeaSingleEntryLibraryDependency) {\n        intellijDependency = buildDependency((IdeaSingleEntryLibraryDependency)dependency, intellijProject);\n      }\n\n      if (intellijDependency == null) {\n        continue;\n      }\n      \n      intellijDependency.setExported(dependency.getExported());\n      DependencyScope scope = parseScope(dependency.getScope());\n      if (scope != null) {\n        intellijDependency.setScope(scope);\n      }\n      intellijModule.addDependency(intellijDependency);\n    }\n  }","id":40475,"modified_method":"private static void populateDependencies(@NotNull IdeaModule gradleModule,\n                                           @NotNull GradleModule intellijModule, \n                                           @NotNull GradleProject intellijProject)\n  {\n    DomainObjectSet<? extends IdeaDependency> dependencies = gradleModule.getDependencies();\n    if (dependencies == null) {\n      return;\n    }\n    for (IdeaDependency dependency : dependencies) {\n      if (dependency == null) {\n        continue;\n      }\n      AbstractGradleDependency intellijDependency = null;\n      if (dependency instanceof IdeaModuleDependency) {\n        intellijDependency = buildDependency(intellijModule, (IdeaModuleDependency)dependency, intellijProject);\n      }\n      else if (dependency instanceof IdeaSingleEntryLibraryDependency) {\n        intellijDependency = buildDependency(intellijModule, (IdeaSingleEntryLibraryDependency)dependency, intellijProject);\n      }\n\n      if (intellijDependency == null) {\n        continue;\n      }\n      \n      intellijDependency.setExported(dependency.getExported());\n      DependencyScope scope = parseScope(dependency.getScope());\n      if (scope != null) {\n        intellijDependency.setScope(scope);\n      }\n      intellijModule.addDependency(intellijDependency);\n    }\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Collection<GradleProjectStructureChange> calculateProjectChanges(@NotNull GradleProject gradleProject,\n                                                                                  @NotNull Project intellijProject,\n                                                                                  @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    Set<GradleProjectStructureChange> result = new HashSet<GradleProjectStructureChange>();\n    checkName(gradleProject, intellijProject, result);\n    checkLanguageLevel(gradleProject, intellijProject, result);\n    return result;\n  }","id":40476,"modified_method":"@NotNull\n  private static Set<GradleProjectStructureChange> calculateProjectChanges(@NotNull GradleProject gradleProject,\n                                                                           @NotNull Project intellijProject,\n                                                                           @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    final Set<GradleProjectStructureChange> nameChanges = checkName(gradleProject, intellijProject, knownChanges);\n    final Set<GradleProjectStructureChange> levelChanges = checkLanguageLevel(gradleProject, intellijProject, knownChanges);\n    return concatenate(nameChanges, levelChanges);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Calculates difference between the given projects.\n   *\n   * @param gradleProject    target gradle project data holder\n   * @param intellijProject  IJ project data holder\n   * @param knownChanges     known changes between the given projects\n   * @return                 collection that contains differences between the given objects (if any)\n   */\n  @NotNull\n  public Collection<GradleProjectStructureChange> calculateDiff(@NotNull GradleProject gradleProject,\n                                                                @NotNull Project intellijProject,\n                                                                @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    Collection<GradleProjectStructureChange> result = calculateProjectChanges(gradleProject, intellijProject, knownChanges);\n    final Map<String, Module> intellijModulesByName = new HashMap<String, Module>();\n    for (Module module : ModuleManager.getInstance(intellijProject).getModules()) {\n      intellijModulesByName.put(module.getName(), module);\n    }\n    Set<? extends GradleModule> gradleModules = new HashSet<GradleModule>(gradleProject.getModules());\n    final Ref<Module> gradleModuleToMap = new Ref<Module>();\n    final Ref<Module> intellijModule = new Ref<Module>();\n    GradleProjectStructureChangeVisitor visitor = new GradleProjectStructureChangeVisitorAdapter() {\n      @Override\n      public void visit(@NotNull GradleRenameChange change) {\n        if (gradleModuleToMap.get().getName().equals(change.getGradleValue()) && change.getEntity() == GradleRenameChange.Entity.MODULE) {\n          intellijModule.set(intellijModulesByName.get(change.getIntellijValue()));\n        }\n      }\n    };\n    for (Iterator<? extends GradleModule> i = gradleModules.iterator(); i.hasNext(); ) {\n      GradleModule gradleModule = i.next();\n      Module module = intellijModulesByName.get(gradleModule.getName());\n      if (module == null) {\n        for (GradleProjectStructureChange change : knownChanges) {\n          change.invite(visitor);\n          if ((module = intellijModule.get()) != null) {\n            break;\n          }\n        }\n      }\n      if (module != null) {\n        i.remove();\n        intellijModulesByName.remove(module.getName());\n        result.addAll(myModuleChangesCalculator.calculateDiff(gradleModule, module, knownChanges));\n      }\n    }\n\n    for (GradleModule module : gradleModules) {\n      result.add(new GradleModulePresenceChange(module, null));\n    }\n    for (Module module : intellijModulesByName.values()) {\n      result.add(new GradleModulePresenceChange(null, module));\n    }\n    result.removeAll(knownChanges);\n    return result;\n  }","id":40477,"modified_method":"@NotNull\n  @Override\n  public Set<GradleProjectStructureChange> calculate(@NotNull GradleProject gradleEntity,\n                                                     @NotNull Project intellijEntity,\n                                                     @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    final Set<GradleProjectStructureChange> result = calculateProjectChanges(gradleEntity, intellijEntity, knownChanges);\n\n    final Set<? extends GradleModule> gradleSubEntities = gradleEntity.getModules();\n    final List<Module> intellijSubEntities = asList(ModuleManager.getInstance(intellijEntity).getModules());\n    return concatenate(result, GradleDiffUtil.calculate(myModuleChangesCalculator, gradleSubEntities, intellijSubEntities, knownChanges));\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkName(@NotNull GradleProject gradleProject,\n                                @NotNull Project intellijProject,\n                                @NotNull Collection<GradleProjectStructureChange> result)\n  {\n    String gradleName = gradleProject.getName();\n    String intellijName = intellijProject.getName();\n    if (!gradleName.equals(intellijName)) {\n      result.add(new GradleRenameChange(GradleRenameChange.Entity.PROJECT, gradleName, intellijName));\n    }\n  }","id":40478,"modified_method":"@NotNull\n  private static Set<GradleProjectStructureChange> checkName(@NotNull GradleProject gradleProject,\n                                                             @NotNull Project intellijProject,\n                                                             @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    String gradleName = gradleProject.getName();\n    String intellijName = intellijProject.getName();\n    if (gradleName.equals(intellijName)) {\n      return Collections.emptySet();\n    }\n    final GradleRenameChange change = new GradleRenameChange(GradleRenameChange.Entity.PROJECT, gradleName, intellijName);\n    return knownChanges.contains(change) ? Collections.<GradleProjectStructureChange>emptySet()\n                                         : Collections.<GradleProjectStructureChange>singleton(change);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkLanguageLevel(@NotNull GradleProject gradleProject,\n                                         @NotNull Project intellijProject,\n                                         @NotNull Collection<GradleProjectStructureChange> result)\n  {\n    LanguageLevel gradleLevel = gradleProject.getLanguageLevel();\n    LanguageLevel intellijLevel = LanguageLevelProjectExtension.getInstance(intellijProject).getLanguageLevel();\n    if (gradleLevel != intellijLevel) {\n      result.add(new GradleLanguageLevelChange(gradleLevel, intellijLevel));\n    }\n  }","id":40479,"modified_method":"@NotNull\n  private static Set<GradleProjectStructureChange> checkLanguageLevel(@NotNull GradleProject gradleProject,\n                                                                      @NotNull Project intellijProject,\n                                                                      @NotNull Set<GradleProjectStructureChange> knownChanges)\n  {\n    LanguageLevel gradleLevel = gradleProject.getLanguageLevel();\n    LanguageLevel intellijLevel = LanguageLevelProjectExtension.getInstance(intellijProject).getLanguageLevel();\n    if (gradleLevel == intellijLevel) {\n      return Collections.emptySet();\n    }\n    final GradleLanguageLevelChange change = new GradleLanguageLevelChange(gradleLevel, intellijLevel);\n    return knownChanges.contains(change) ? Collections.<GradleProjectStructureChange>emptySet()\n                                         : Collections.<GradleProjectStructureChange>singleton(change);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return collection of project structure changes registered within the current model\n   */\n  @NotNull\n  public Set<GradleProjectStructureChange> getChanges() {\n    //TODO den implement\n    return null;\n  }","id":40480,"modified_method":"/**\n   * @return collection of project structure changes registered within the current model\n   */\n  @NotNull\n  public Set<GradleProjectStructureChange> getChanges() {\n    return myChanges;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asks the model to update its state according to the given state of the target gradle project.\n   * <p/>\n   * I.e. basically the processing looks as following:\n   * <ol>\n   *  <li>This method is called;<\/li>\n   *  <li>\n   *    The model process given project state within the {@link #getChanges() registered changes} and calculates resulting difference\n   *    between Gradle and IJ projects;\n   *  <\/li>\n   *  <li>{@link #addListener(GradleProjectStructureChangeListener) Registered listeners} are notified if any new change is detected;<\/li>\n   * <\/ol>\n   *\n   * @param gradleProject  gradle project to sync with\n   */\n  public void update(@NotNull GradleProject gradleProject) {\n    //TODO den implement\n  }","id":40481,"modified_method":"/**\n   * Asks the model to update its state according to the given state of the target gradle project.\n   * <p/>\n   * I.e. basically the processing looks as following:\n   * <ol>\n   *  <li>This method is called;<\/li>\n   *  <li>\n   *    The model process given project state within the {@link #getChanges() registered changes} and calculates resulting difference\n   *    between Gradle and IJ projects;\n   *  <\/li>\n   *  <li>{@link #addListener(GradleProjectStructureChangeListener) Registered listeners} are notified if any new change is detected;<\/li>\n   * <\/ol>\n   *\n   * @param gradleProject  gradle project to sync with\n   */\n  public void update(@NotNull GradleProject gradleProject) {\n    Set<GradleProjectStructureChange> knownChanges = new HashSet<GradleProjectStructureChange>(myChanges);\n    final Set<GradleProjectStructureChange> newChanges = myChangesCalculator.calculate(gradleProject, myProject, knownChanges);\n    myChanges.addAll(newChanges);\n    for (GradleProjectStructureChangeListener listener : myListeners) {\n      listener.onChanges(newChanges);\n    }\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleProjectStructureChangesPanel(@NotNull Project project, @NotNull GradleProjectStructureChangesModel model) {\n    super(project, GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    myDataModel = model;\n    init();\n  }","id":40482,"modified_method":"public GradleProjectStructureChangesPanel(@NotNull Project project, @NotNull GradleProjectStructureChangesModel model) {\n    super(project, GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    myChangesModel = model;\n    myChangesModel.addListener(new GradleProjectStructureChangeListener() {\n      @Override\n      public void onChanges(@NotNull final Collection<GradleProjectStructureChange> changes) {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            updateTree(changes); \n          }\n        });\n      }\n    });\n    rebuildTree();\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GradleProjectStructureNodeDescriptor<Project> buildDescriptor(@NotNull Project project) {\n    return new GradleProjectStructureNodeDescriptor<Project>(project, project.getName(), GradleIcons.PROJECT_ICON);\n  }","id":40483,"modified_method":"private static GradleProjectStructureNodeDescriptor<Project> buildDescriptor(@NotNull Project project) {\n    return new GradleProjectStructureNodeDescriptor<Project>(project, project.getName(), GradleIcons.PROJECT_ICON);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init() {\n    JPanel content = new JPanel(new GridBagLayout());\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode(buildDescriptor(getProject()));\n    final Module[] modules = ModuleManager.getInstance(getProject()).getModules();\n    RootPolicy<LibraryOrderEntry> policy = new RootPolicy<LibraryOrderEntry>() {\n      @Override\n      public LibraryOrderEntry visitLibraryOrderEntry(LibraryOrderEntry libraryOrderEntry, LibraryOrderEntry value) {\n        return libraryOrderEntry;\n      }\n    };\n    for (Module module : modules) {\n      final DefaultMutableTreeNode moduleNode = new DefaultMutableTreeNode(buildDescriptor(module));\n      final ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n      for (OrderEntry orderEntry : moduleRootManager.getOrderEntries()) {\n        final LibraryOrderEntry library = orderEntry.accept(policy, null);\n        if (library != null) {\n          moduleNode.add(new DefaultMutableTreeNode(buildDescriptor(library)));\n        }\n      }\n      root.add(moduleNode);\n    }\n    DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    Tree tree = new Tree(treeModel);\n\n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.fill = GridBagConstraints.BOTH;\n    constraints.weightx = constraints.weighty = 1;\n    content.add(tree, constraints);\n    myContent = content;\n  }","id":40484,"modified_method":"@NotNull\n  private DefaultTreeModel init() {\n    myContent = new JPanel(new GridBagLayout());\n    DefaultTreeModel treeModel = new DefaultTreeModel(null);\n    Tree tree = new Tree(treeModel);\n\n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.fill = GridBagConstraints.BOTH;\n    constraints.weightx = constraints.weighty = 1;\n    myContent.add(tree, constraints);\n    return treeModel;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GradleProjectStructureNodeDescriptor<LibraryOrderEntry> buildDescriptor(@NotNull LibraryOrderEntry library) {\n    return new GradleProjectStructureNodeDescriptor<LibraryOrderEntry>(library, library.getPresentableName(), GradleIcons.LIB_ICON);\n  }","id":40485,"modified_method":"private static GradleProjectStructureNodeDescriptor<LibraryOrderEntry> buildDescriptor(@NotNull LibraryOrderEntry library) {\n    return new GradleProjectStructureNodeDescriptor<LibraryOrderEntry>(library, library.getPresentableName(), GradleIcons.LIB_ICON);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GradleProjectStructureNodeDescriptor<Module> buildDescriptor(@NotNull Module module) {\n    return new GradleProjectStructureNodeDescriptor<Module>(module, module.getName(), GradleIcons.MODULE_ICON);\n  }","id":40486,"modified_method":"private static GradleProjectStructureNodeDescriptor<Module> buildDescriptor(@NotNull Module module) {\n    return new GradleProjectStructureNodeDescriptor<Module>(module, module.getName(), GradleIcons.MODULE_ICON);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected JComponent buildContent() {\n    if (myContent == null) {\n      init();\n    }\n    return myContent;\n  }","id":40487,"modified_method":"@NotNull\n  @Override\n  protected JComponent buildContent() {\n    myTreeModel = init();\n    return myContent;\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void update(@NotNull PresentationData presentation) {\n    presentation.setForcedTextForeground(Color.RED); \n  }","id":40488,"modified_method":"@Override\n  protected void update(@NotNull PresentationData presentation) {\n    presentation.setAttributesKey(myAttributes);\n    presentation.setPresentableText(myName);\n    presentation.setOpenIcon(myOpenIcon);\n    presentation.setClosedIcon(myClosedIcon);\n  }","commit_id":"3697bd62b62318da4e0868a89699d27099221cfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private LookupItem addLookupItem(Set<LookupItem> set, CompletionVariantItem element, @NotNull Object completion, CompletionContext context){\n    LookupItem ret = LookupItemUtil.objectToLookupItem(completion);\n    if(ret == null) return null;\n\n    if(getInsertHandler() != null){\n      ret.setAttribute(LookupItem.INSERT_HANDLER_ATTR, getInsertHandler());\n      ret.setTailType(TailType.UNKNOWN);\n    }\n    else if (element.myTailType != TailType.NONE) {\n      ret.setTailType(element.myTailType);\n    }\n\n    for (final Object key : myItemProperties.keySet()) {\n      if (key == LookupItem.FORCE_SHOW_FQN_ATTR && ret.getObject() instanceof PsiClass) {\n        @NonNls String packageName = ((PsiClass)ret.getObject()).getQualifiedName();\n        if (packageName != null && packageName.lastIndexOf('.') > 0) {\n          packageName = packageName.substring(0, packageName.lastIndexOf('.'));\n        }\n        else {\n          packageName = \"\";\n        }\n        if (packageName.length() == 0) {\n          packageName = \"default package\";\n        }\n\n        ret.setAttribute(LookupItem.TAIL_TEXT_ATTR, \" (\" + packageName + \")\");\n        ret.setAttribute(LookupItem.TAIL_TEXT_SMALL_ATTR, \"\");\n      }\n      else {\n        if (completion instanceof PsiMember && key == LookupItem.FORCE_QUALIFY) {\n          final PsiMember completionElement = (PsiMember)completion;\n          final PsiClass containingClass = completionElement.getContainingClass();\n          if (containingClass != null) {\n            final String className = containingClass.getName();\n            ret.setLookupString(className + \".\" + ret.getLookupString());\n            ret.setAttribute(key, myItemProperties.get(key));\n          }\n        }\n        ret.setAttribute(key, myItemProperties.get(key));\n      }\n    }\n\n    final String lookupString = ret.getLookupString();\n    if(CompletionUtil.checkName(lookupString, context, caseInsensitive)){\n      set.add(ret);\n      return ret;\n    }\n\n    return null;\n  }","id":40489,"modified_method":"@Nullable\n  private LookupItem addLookupItem(Set<LookupItem> set, CompletionVariantItem element, @NotNull Object completion, CompletionContext context){\n    LookupItem ret = LookupItemUtil.objectToLookupItem(completion);\n    if(ret == null) return null;\n\n    if(getInsertHandler() != null && !(ret instanceof SimpleLookupItem)){\n      ret.setAttribute(LookupItem.INSERT_HANDLER_ATTR, getInsertHandler());\n      ret.setTailType(TailType.UNKNOWN);\n    }\n    else if (element.myTailType != TailType.NONE) {\n      ret.setTailType(element.myTailType);\n    }\n\n    for (final Object key : myItemProperties.keySet()) {\n      if (key == LookupItem.FORCE_SHOW_FQN_ATTR && ret.getObject() instanceof PsiClass) {\n        @NonNls String packageName = ((PsiClass)ret.getObject()).getQualifiedName();\n        if (packageName != null && packageName.lastIndexOf('.') > 0) {\n          packageName = packageName.substring(0, packageName.lastIndexOf('.'));\n        }\n        else {\n          packageName = \"\";\n        }\n        if (packageName.length() == 0) {\n          packageName = \"default package\";\n        }\n\n        ret.setAttribute(LookupItem.TAIL_TEXT_ATTR, \" (\" + packageName + \")\");\n        ret.setAttribute(LookupItem.TAIL_TEXT_SMALL_ATTR, \"\");\n      }\n      else {\n        if (completion instanceof PsiMember && key == LookupItem.FORCE_QUALIFY) {\n          final PsiMember completionElement = (PsiMember)completion;\n          final PsiClass containingClass = completionElement.getContainingClass();\n          if (containingClass != null) {\n            final String className = containingClass.getName();\n            ret.setLookupString(className + \".\" + ret.getLookupString());\n            ret.setAttribute(key, myItemProperties.get(key));\n          }\n        }\n        ret.setAttribute(key, myItemProperties.get(key));\n      }\n    }\n    final boolean itemCaseInsensitive = Boolean.TRUE.equals(ret.getAttribute(LookupItem.CASE_INSENSITIVE));\n    final String lookupString = ret.getLookupString();\n    if(CompletionUtil.checkName(lookupString, context, itemCaseInsensitive || caseInsensitive)){\n      if (itemCaseInsensitive) {\n        final String currentString = ret.getLookupString();\n        final String newString = handleCaseInsensitiveVariant(context.getPrefix(), currentString);\n        ret.setLookupString(newString);\n        if (ret.getObject() == currentString) {\n          ret.setObject(newString);\n        }\n      }\n      set.add(ret);\n      return ret;\n    }\n\n    return null;\n  }","commit_id":"6ea0080e3feed0f52165e29b02f31c93bd717132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditorInfo(String fileText) {\n    Document document = EditorFactory.getInstance().createDocument(fileText);\n\n    int caretIndex = fileText.indexOf(CARET_MARKER);\n    int selStartIndex = fileText.indexOf(SELECTION_START_MARKER);\n    int selEndIndex = fileText.indexOf(SELECTION_END_MARKER);\n\n    caretMarker = caretIndex >= 0 ? document.createRangeMarker(caretIndex, caretIndex) : null;\n    selStartMarker = selStartIndex >= 0 ? document.createRangeMarker(selStartIndex, selStartIndex) : null;\n    selEndMarker = selEndIndex >= 0 ? document.createRangeMarker(selEndIndex, selEndIndex) : null;\n\n    if (caretMarker != null) {\n      document.deleteString(caretMarker.getStartOffset(), caretMarker.getStartOffset() + CARET_MARKER.length());\n    }\n    if (selStartMarker != null) {\n      document.deleteString(selStartMarker.getStartOffset(), selStartMarker.getStartOffset() + SELECTION_START_MARKER.length());\n    }\n    if (selEndMarker != null) {\n      document.deleteString(selEndMarker.getStartOffset(), selEndMarker.getStartOffset() + SELECTION_END_MARKER.length());\n    }\n\n    newFileText = document.getText();\n  }","id":40490,"modified_method":"public EditorInfo(String fileText) {\n    updateCaretAndSelection(EditorFactory.getInstance().createDocument(fileText));\n  }","commit_id":"6ea0080e3feed0f52165e29b02f31c93bd717132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n      return getReferenceVariants(myContext, myGenericDomValue);\n    }","id":40491,"modified_method":"public Object[] getVariants() {\n      return getReferenceVariants(myContext, myGenericDomValue, getRangeInElement());\n    }","commit_id":"6ea0080e3feed0f52165e29b02f31c93bd717132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract Object[] getReferenceVariants(final ConvertContext context, GenericDomValue<T> genericDomValue);","id":40492,"modified_method":"protected abstract Object[] getReferenceVariants(final ConvertContext context, GenericDomValue<T> genericDomValue,\n                                                   final TextRange rangeInElement);","commit_id":"6ea0080e3feed0f52165e29b02f31c93bd717132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Handles 'Save As' for a sketch.\n   * <P>\n   * This basically just duplicates the current sketch folder to\n   * a new location, and then calls 'Save'. (needs to take the current\n   * state of the open files and save them to the new folder..\n   * but not save over the old versions for the old sketch..)\n   * <P>\n   * Also removes the previously-generated .class and .jar files,\n   * because they can cause trouble.\n   */\n  protected boolean saveAs() throws IOException {\n    String newParentDir = null;\n    String newName = null;\n    // TODO rewrite this to use shared version from PApplet\n    final String PROMPT = \"Save sketch folder as...\";\n    if (Preferences.getBoolean(\"chooser.files.native\")) {\n      // get new name for folder\n      FileDialog fd = new FileDialog(editor, PROMPT, FileDialog.SAVE);\n      if (isReadOnly() || isUntitled()) {\n        // default to the sketchbook folder\n        fd.setDirectory(Preferences.get(\"sketchbook.path\"));\n      } else {\n        // default to the parent folder of where this was\n        fd.setDirectory(folder.getParent());\n      }\n      String oldName = folder.getName();\n      fd.setFile(oldName);\n      fd.setVisible(true);\n      newParentDir = fd.getDirectory();\n      newName = fd.getFile();\n    } else {\n      JFileChooser fc = new JFileChooser();\n      fc.setDialogTitle(PROMPT);\n      if (isReadOnly() || isUntitled()) {\n        // default to the sketchbook folder\n        fc.setCurrentDirectory(new File(Preferences.get(\"sketchbook.path\")));\n      } else {\n        // default to the parent folder of where this was\n        fc.setCurrentDirectory(folder.getParentFile());\n      }\n      // can't do this, will try to save into itself by default\n      //fc.setSelectedFile(folder);\n      int result = fc.showSaveDialog(editor);\n      if (result == JFileChooser.APPROVE_OPTION) {\n        File selection = fc.getSelectedFile();\n        newParentDir = selection.getParent();\n        newName = selection.getName();\n      }\n    }\n\n    // user canceled selection\n    if (newName == null) return false;\n    newName = Sketch.checkName(newName);\n\n    File newFolder = new File(newParentDir, newName);\n//    String newPath = newFolder.getAbsolutePath();\n//    String oldPath = folder.getAbsolutePath();\n\n//    if (newPath.equals(oldPath)) {\n//      return false;  // Can't save a sketch over itself\n//    }\n\n    // make sure there doesn't exist a tab with that name already\n    // but ignore this situation for the first tab, since it's probably being\n    // resaved (with the same name) to another location/folder.\n    for (int i = 1; i < codeCount; i++) {\n      if (newName.equalsIgnoreCase(code[i].getPrettyName())) {\n        Base.showMessage(\"Nope\",\n                         \"You can't save the sketch as \\\"\" + newName + \"\\\"\\n\" +\n                         \"because the sketch already has a tab with that name.\");\n        return false;\n      }\n    }\n\n    // check if the paths are identical\n    if (newFolder.equals(folder)) {\n      // just use \"save\" here instead, because the user will have received a\n      // message (from the operating system) about \"do you want to replace?\"\n      return save();\n    }\n\n    // check to see if the user is trying to save this sketch inside itself\n    try {\n      String newPath = newFolder.getCanonicalPath() + File.separator;\n      String oldPath = folder.getCanonicalPath() + File.separator;\n\n      if (newPath.indexOf(oldPath) == 0) {\n        Base.showWarning(\"How very Borges of you\",\n                         \"You cannot save the sketch into a folder\\n\" +\n                         \"inside itself. This would go on forever.\", null);\n        return false;\n      }\n    } catch (IOException e) { }\n\n    // if the new folder already exists, then first remove its contents before\n    // copying everything over (user will have already been warned).\n    if (newFolder.exists()) {\n      Base.removeDir(newFolder);\n    }\n    // in fact, you can't do this on Windows because the file dialog\n    // will instead put you inside the folder, but it happens on OS X a lot.\n\n    // now make a fresh copy of the folder\n    newFolder.mkdirs();\n\n    // grab the contents of the current tab before saving\n    // first get the contents of the editor text area\n    if (current.isModified()) {\n      current.setProgram(editor.getText());\n    }\n\n    File[] copyItems = folder.listFiles(new FileFilter() {\n      public boolean accept(File file) {\n        String name = file.getName();\n        // just in case the OS likes to return these as if they're legit\n        if (name.equals(\".\") || name.equals(\"..\")) {\n          return false;\n        }\n        // list of files/folders to be ignored during \"save as\"\n        for (String ignorable : mode.getIgnorable()) {\n          if (name.equals(ignorable)) {\n            return false;\n          }\n        }\n        // ignore the extensions for code, since that'll be copied below\n        for (String ext : mode.getExtensions()) {\n          if (name.endsWith(ext)) {\n            return false;\n          }\n        }\n        // don't do screen captures, since there might be thousands. kind of\n        // a hack, but seems harmless. hm, where have i heard that before...\n        if (name.startsWith(\"screen-\")) {\n          return false;\n        }\n        return true;\n      }\n    });\n    // now copy over the items that make sense\n    for (File copyable : copyItems) {\n      if (copyable.isDirectory()) {\n        Base.copyDir(copyable, new File(newFolder, copyable.getName()));\n      } else {\n        Base.copyFile(copyable, new File(newFolder, copyable.getName()));\n      }\n    }\n\n    // save the other tabs to their new location\n    for (int i = 1; i < codeCount; i++) {\n      File newFile = new File(newFolder, code[i].getFileName());\n      code[i].saveAs(newFile);\n    }\n\n    // While the old path to the main .pde is still set, remove the entry from\n    // the Recent menu so that it's not sticking around after the rename.\n    // If untitled, it won't be in the menu, so there's no point.\n    if (!isUntitled()) {\n      editor.removeRecent();\n    }\n\n    // save the main tab with its new name\n    File newFile = new File(newFolder, newName + \".pde\");\n    code[0].saveAs(newFile);\n\n    updateInternal(newName, newFolder);\n\n    // Make sure that it's not an untitled sketch\n    setUntitled(false);\n\n    // Add this sketch back using the new name\n    editor.addRecent();\n\n    // let Editor know that the save was successful\n    return true;\n  }","id":40493,"modified_method":"/**\n   * Handles 'Save As' for a sketch.\n   * <P>\n   * This basically just duplicates the current sketch folder to\n   * a new location, and then calls 'Save'. (needs to take the current\n   * state of the open files and save them to the new folder..\n   * but not save over the old versions for the old sketch..)\n   * <P>\n   * Also removes the previously-generated .class and .jar files,\n   * because they can cause trouble.\n   */\n  protected boolean saveAs() throws IOException {\n    String newParentDir = null;\n    String newName = null;\n    // TODO rewrite this to use shared version from PApplet\n    final String PROMPT = \"Save sketch folder as...\";\n    if (Preferences.getBoolean(\"chooser.files.native\")) {\n      // get new name for folder\n      FileDialog fd = new FileDialog(editor, PROMPT, FileDialog.SAVE);\n      if (isReadOnly() || isUntitled()) {\n        // default to the sketchbook folder\n        fd.setDirectory(Preferences.get(\"sketchbook.path\"));\n      } else {\n        // default to the parent folder of where this was\n        fd.setDirectory(folder.getParent());\n      }\n      String oldName = folder.getName();\n      fd.setFile(oldName);\n      fd.setVisible(true);\n      newParentDir = fd.getDirectory();\n      newName = fd.getFile();\n    } else {\n      JFileChooser fc = new JFileChooser();\n      fc.setDialogTitle(PROMPT);\n      if (isReadOnly() || isUntitled()) {\n        // default to the sketchbook folder\n        fc.setCurrentDirectory(new File(Preferences.get(\"sketchbook.path\")));\n      } else {\n        // default to the parent folder of where this was\n        fc.setCurrentDirectory(folder.getParentFile());\n      }\n      // can't do this, will try to save into itself by default\n      //fc.setSelectedFile(folder);\n      int result = fc.showSaveDialog(editor);\n      if (result == JFileChooser.APPROVE_OPTION) {\n        File selection = fc.getSelectedFile();\n        newParentDir = selection.getParent();\n        newName = selection.getName();\n      }\n    }\n\n    // user canceled selection\n    if (newName == null) return false;\n\n    // check on the sanity of the name\n    String sanitaryName = Sketch.checkName(newName);\n    File newFolder = new File(newParentDir, sanitaryName);\n    if (!sanitaryName.equals(newName) && newFolder.exists()) {\n      Base.showMessage(\"Cannot Save\",\n                       \"A sketch with the cleaned name\\n\" +\n                       \"\u201c\" + sanitaryName + \"\u201d already exists.\");\n      return false;\n    }\n    newName = sanitaryName;\n\n//    String newPath = newFolder.getAbsolutePath();\n//    String oldPath = folder.getAbsolutePath();\n\n//    if (newPath.equals(oldPath)) {\n//      return false;  // Can't save a sketch over itself\n//    }\n\n    // make sure there doesn't exist a tab with that name already\n    // but ignore this situation for the first tab, since it's probably being\n    // resaved (with the same name) to another location/folder.\n    for (int i = 1; i < codeCount; i++) {\n      if (newName.equalsIgnoreCase(code[i].getPrettyName())) {\n        Base.showMessage(\"Nope\",\n                         \"You can't save the sketch as \\\"\" + newName + \"\\\"\\n\" +\n                         \"because the sketch already has a tab with that name.\");\n        return false;\n      }\n    }\n\n    // check if the paths are identical\n    if (newFolder.equals(folder)) {\n      // just use \"save\" here instead, because the user will have received a\n      // message (from the operating system) about \"do you want to replace?\"\n      return save();\n    }\n\n    // check to see if the user is trying to save this sketch inside itself\n    try {\n      String newPath = newFolder.getCanonicalPath() + File.separator;\n      String oldPath = folder.getCanonicalPath() + File.separator;\n\n      if (newPath.indexOf(oldPath) == 0) {\n        Base.showWarning(\"How very Borges of you\",\n                         \"You cannot save the sketch into a folder\\n\" +\n                         \"inside itself. This would go on forever.\", null);\n        return false;\n      }\n    } catch (IOException e) { }\n\n    // if the new folder already exists, then first remove its contents before\n    // copying everything over (user will have already been warned).\n    if (newFolder.exists()) {\n      Base.removeDir(newFolder);\n    }\n    // in fact, you can't do this on Windows because the file dialog\n    // will instead put you inside the folder, but it happens on OS X a lot.\n\n    // now make a fresh copy of the folder\n    newFolder.mkdirs();\n\n    // grab the contents of the current tab before saving\n    // first get the contents of the editor text area\n    if (current.isModified()) {\n      current.setProgram(editor.getText());\n    }\n\n    File[] copyItems = folder.listFiles(new FileFilter() {\n      public boolean accept(File file) {\n        String name = file.getName();\n        // just in case the OS likes to return these as if they're legit\n        if (name.equals(\".\") || name.equals(\"..\")) {\n          return false;\n        }\n        // list of files/folders to be ignored during \"save as\"\n        for (String ignorable : mode.getIgnorable()) {\n          if (name.equals(ignorable)) {\n            return false;\n          }\n        }\n        // ignore the extensions for code, since that'll be copied below\n        for (String ext : mode.getExtensions()) {\n          if (name.endsWith(ext)) {\n            return false;\n          }\n        }\n        // don't do screen captures, since there might be thousands. kind of\n        // a hack, but seems harmless. hm, where have i heard that before...\n        if (name.startsWith(\"screen-\")) {\n          return false;\n        }\n        return true;\n      }\n    });\n    // now copy over the items that make sense\n    for (File copyable : copyItems) {\n      if (copyable.isDirectory()) {\n        Base.copyDir(copyable, new File(newFolder, copyable.getName()));\n      } else {\n        Base.copyFile(copyable, new File(newFolder, copyable.getName()));\n      }\n    }\n\n    // save the other tabs to their new location\n    for (int i = 1; i < codeCount; i++) {\n      File newFile = new File(newFolder, code[i].getFileName());\n      code[i].saveAs(newFile);\n    }\n\n    // While the old path to the main .pde is still set, remove the entry from\n    // the Recent menu so that it's not sticking around after the rename.\n    // If untitled, it won't be in the menu, so there's no point.\n    if (!isUntitled()) {\n      editor.removeRecent();\n    }\n\n    // save the main tab with its new name\n    File newFile = new File(newFolder, newName + \".pde\");\n    code[0].saveAs(newFile);\n\n    updateInternal(newName, newFolder);\n\n    // Make sure that it's not an untitled sketch\n    setUntitled(false);\n\n    // Add this sketch back using the new name\n    editor.addRecent();\n\n    // let Editor know that the save was successful\n    return true;\n  }","commit_id":"592b14ad42b82a72cb02af67ff1524fc16cfd9b9","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Produce a sanitized name that fits our standards for likely to work.\n   * <p/>\n   * Java classes have a wider range of names that are technically allowed\n   * (supposedly any Unicode name) than what we support. The reason for\n   * going more narrow is to avoid situations with text encodings and\n   * converting during the process of moving files between operating\n   * systems, i.e. uploading from a Windows machine to a Linux server,\n   * or reading a FAT32 partition in OS X and using a thumb drive.\n   * <p/>\n   * This helper function replaces everything but A-Z, a-z, and 0-9 with\n   * underscores. Also disallows starting the sketch name with a digit.\n   */\n  static public String sanitizeName(String origName) {\n    char c[] = origName.toCharArray();\n    StringBuffer buffer = new StringBuffer();\n\n    // can't lead with a digit, so start with an underscore\n    if ((c[0] >= '0') && (c[0] <= '9')) {\n      buffer.append('_');\n    }\n    for (int i = 0; i < c.length; i++) {\n      if (((c[i] >= '0') && (c[i] <= '9')) ||\n          ((c[i] >= 'a') && (c[i] <= 'z')) ||\n          ((c[i] >= 'A') && (c[i] <= 'Z'))) {\n        buffer.append(c[i]);\n\n      } else {\n        buffer.append('_');\n      }\n    }\n    // let's not be ridiculous about the length of filenames.\n    // in fact, Mac OS 9 can handle 255 chars, though it can't really\n    // deal with filenames longer than 31 chars in the Finder.\n    // but limiting to that for sketches would mean setting the\n    // upper-bound on the character limit here to 25 characters\n    // (to handle the base name + \".class\")\n    if (buffer.length() > 63) {\n      buffer.setLength(63);\n    }\n    return buffer.toString();\n  }","id":40494,"modified_method":"/**\n   * Produce a sanitized name that fits our standards for likely to work.\n   * <p/>\n   * Java classes have a wider range of names that are technically allowed\n   * (supposedly any Unicode name) than what we support. The reason for\n   * going more narrow is to avoid situations with text encodings and\n   * converting during the process of moving files between operating\n   * systems, i.e. uploading from a Windows machine to a Linux server,\n   * or reading a FAT32 partition in OS X and using a thumb drive.\n   * <p/>\n   * This helper function replaces everything but A-Z, a-z, and 0-9 with\n   * underscores. Also disallows starting the sketch name with a digit\n   * or underscore.\n   */\n  static public String sanitizeName(String origName) {\n    char c[] = origName.toCharArray();\n    StringBuffer buffer = new StringBuffer();\n\n    // can't lead with a digit, so start with an underscore\n    if ((c[0] >= '0') && (c[0] <= '9')) {\n      buffer.append('_');\n    }\n    for (int i = 0; i < c.length; i++) {\n      if (((c[i] >= '0') && (c[i] <= '9')) ||\n          ((c[i] >= 'a') && (c[i] <= 'z')) ||\n          ((c[i] >= 'A') && (c[i] <= 'Z'))) {\n        buffer.append(c[i]);\n\n      } else {\n        buffer.append('_');\n      }\n    }\n    // let's not be ridiculous about the length of filenames.\n    // in fact, Mac OS 9 can handle 255 chars, though it can't really\n    // deal with filenames longer than 31 chars in the Finder.\n    // but limiting to that for sketches would mean setting the\n    // upper-bound on the character limit here to 25 characters\n    // (to handle the base name + \".class\")\n    if (buffer.length() > 63) {\n      buffer.setLength(63);\n    }\n    // Remove underscores from the beginning, these seem to be a reserved\n    // thing on Android, plus it sometimes causes trouble elsewhere.\n    int underscore = 0;\n    while (underscore < buffer.length() && buffer.charAt(underscore) == '_') {\n      underscore++;\n    }\n    if (underscore == buffer.length()) {\n      return \"bad_sketch_name_please_fix\";\n\n    } else if (underscore != 0) {\n      return buffer.substring(underscore);\n    }\n    return buffer.toString();\n  }","commit_id":"592b14ad42b82a72cb02af67ff1524fc16cfd9b9","url":"https://github.com/processing/processing"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\t// In case user want to create file at first row\r\n\t\t\t// In that case, DO NOT create file at Init\r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\tif (openNewFile()||meta.isFileNameInField())\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName());\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t\treturn false;\r\n\t}","id":40495,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\t// In case user want to create file at first row\r\n\t\t\t// In that case, DO NOT create file at Init\r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!meta.isFileNameInField()) {\r\n\t\t\t\t\t\topenNewFile(meta.getFileName());\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\tinitBinaryDataFields();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\t\r\n\t\t\t\tcatch(Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName(), e);\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t\treturn false;\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean writeHeader()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tRowMetaInterface r=data.outputRowMeta;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tString header = \"\";\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface v = r.searchValueMeta(fieldName);\r\n                    \r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\theader+=environmentSubstitute(meta.getSeparator());\r\n\t\t\t\t\t}\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=environmentSubstitute(meta.getEnclosure());\r\n                    }\r\n\t\t\t\t\theader+=fieldName;\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=environmentSubstitute(meta.getEnclosure());\r\n                    }\r\n\t\t\t\t}\r\n\t\t\t\theader+=meta.getNewline();\r\n                data.writer.write(getBinaryString(header));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (r!=null)  // Just put all field names in the header/footer\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\t\t\t\tValueMetaInterface v = r.getValueMeta(i);\r\n\t\t\t\t\t\r\n                    // Header-value contains the name of the value\r\n\t\t\t\t\tValueMetaInterface header_value = new ValueMeta(v.getName(), ValueMetaInterface.TYPE_STRING);\r\n\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n                    data.writer.write(getBinaryString(header_value.getName()));\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n                data.writer.write(getBinaryString(\"no rows selected\"+Const.CR));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tlinesOutput++;\r\n\t\treturn retval;\r\n\t}","id":40496,"modified_method":"private boolean writeHeader()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tRowMetaInterface r=data.outputRowMeta;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface v = r.searchValueMeta(fieldName);\r\n                    \r\n\t\t\t\t\tif (i>0 && data.binarySeparator.length>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\t\t\t\t}\r\n                    if (meta.isEnclosureForced() && data.binaryEnclosure.length>0 && v!=null && v.isString())\r\n                    {\r\n                    \tdata.writer.write(data.binaryEnclosure);\r\n                    }\r\n                    data.writer.write(getBinaryString(fieldName));\r\n                    if (meta.isEnclosureForced() && data.binaryEnclosure.length>0 && v!=null && v.isString())\r\n                    {\r\n                    \tdata.writer.write(data.binaryEnclosure);                    }\r\n\t\t\t\t}\r\n\t\t\t\tdata.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (r!=null)  // Just put all field names in the header/footer\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && data.binarySeparator.length>0) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tValueMetaInterface v = r.getValueMeta(i);\r\n\t\t\t\t\t\r\n                    if (meta.isEnclosureForced() && data.binaryEnclosure.length>0 && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n                    data.writer.write(getBinaryString(v.getName()));\r\n                    if (meta.isEnclosureForced() && data.binaryEnclosure.length>0 && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n                data.writer.write(getBinaryString(\"no rows selected\"+Const.CR));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tlinesOutput++;\r\n\t\treturn retval;\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\t\t\r\n\t\tif(data.oneFileOpened) closeFile();\r\n\t\t\r\n\t\ttry{\r\n\t\t\tif(data.fos!=null) data.fos.close();\r\n\t\t\t}catch (Exception e){}\r\n        super.dispose(smi, sdi);\r\n\t}","id":40497,"modified_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\t\t\r\n\t\tif(data.oneFileOpened) closeFile();\r\n\t\t\r\n\t\ttry{\r\n\t\t\tif(data.fos!=null) { \r\n\t\t\t\tdata.fos.close();\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tfor (OutputStream outputStream : data.fileWriterMap.values()) {\r\n\t\t\ttry {\r\n\t\t\t\toutputStream.close();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\t// Eat exception.\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        super.dispose(smi, sdi);\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tboolean result=true;\r\n\t\tboolean bEndedLineWrote=false;\r\n\t\tObject[] r=getRow();       // This also waits for a row to be finished.\r\n\r\n        if (r!=null && first)\r\n        {\r\n            first=false;\r\n            data.outputRowMeta = getInputRowMeta().clone();\r\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n            \r\n            //if file name in field is enabled then set field name and open file\r\n          if(meta.isFileNameInField()){\r\n            \t\r\n\t\t\t\t// get the first input row set (assume only one)\r\n\t\t\t\tRowSet zero = (RowSet)inputRowSets.get(0);\r\n\t\t\t\tRowMetaInterface inputRowMeta = zero.getRowMeta();\r\n\t\t\t\t//find and set index of file name field in input stream\r\n\t\t\t\tdata.fileNameFieldIndex = inputRowMeta.indexOfValue(meta.getFileNameField());\t\r\n\t\t\t\t//set the file name for this row\r\n\t\t\t\tString fileName = \"\";\r\n\t\t\t\tif(data.fileNameFieldIndex != -1){\r\n\t\t\t\t\tfileName = (String) r[data.fileNameFieldIndex];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t throw new KettleStepException(\"File name field [\"+meta.getFileNameField()+\"] couldn't be found in the input stream!\");\r\n\t\t\t\t}\r\n            \t\r\n            \t//open new file only if new file name\r\n            \tmeta.setFileName(fileName);\r\n            \r\n            \t// Open a new file here\r\n            \tif (openNewFile())\r\n\t\t\t\t{\r\n            \t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//mark file as previously opened\r\n\t            \tdata.previouslyOpenedFiles.add(buildFilename(true));\r\n\t\t\t\t}\r\n            \t\r\n            }\r\n          \r\n          if(meta.isDoNotOpenNewFileInit()&& !meta.isFileNameInField())\r\n          {\r\n        \t  // Open a new file here\r\n        \t  if (openNewFile())\r\n        \t  {\r\n        \t\t  data.oneFileOpened=true;\r\n        \t\t  try {\r\n        \t\t\t  setSettings();\r\n\t\t\t\r\n        \t\t  } catch (UnsupportedEncodingException e) {\r\n        \t\t\t  logError(\"Encoding problem: \"+e.toString());\r\n        \t\t\t  logError(Const.getStackTracker(e));\r\n        \t\t\t  return false;\r\n        \t\t  }\r\n        \t  }\t\r\n          }\t\r\n            \r\n            if (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n            {\r\n                if (meta.isHeaderEnabled() && data.outputRowMeta!=null)\r\n                {\r\n                    writeHeader();\r\n                }\r\n            }\r\n            \r\n            data.fieldnrs=new int[meta.getOutputFields().length];\r\n            for (int i=0;i<meta.getOutputFields().length;i++)\r\n            {\r\n                data.fieldnrs[i]=data.outputRowMeta.indexOfValue(meta.getOutputFields()[i].getName());\r\n                if (data.fieldnrs[i]<0)\r\n                {\r\n                    throw new KettleStepException(\"Field [\"+meta.getOutputFields()[i].getName()+\"] couldn't be found in the input stream!\");\r\n                }\r\n            }\r\n        }\r\n\r\n\t\tif ( ( r==null && data.outputRowMeta!=null && meta.isFooterEnabled() ) ||\r\n\t\t     ( r!=null && linesOutput>0 && meta.getSplitEvery()>0 && ((linesOutput+1)%meta.getSplitEvery())==0)\r\n\t\t   )\r\n\t\t{\r\n\t\t\tif (data.outputRowMeta!=null) \r\n\t\t\t{\r\n\t\t\t   if ( meta.isFooterEnabled() )\r\n\t\t\t   {\r\n\t\t\t      writeHeader();\r\n\t\t\t   }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r==null)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\t\t\t\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.outputRowMeta!=null) if (writeHeader()) linesOutput++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false==bEndedLineWrote)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t//first handle if file name in field\r\n\t\tif(meta.isFileNameInField()){\r\n\t\t\tString fileName = (String) r[data.fileNameFieldIndex];\r\n\t\t\t\r\n\t\t\tif (! meta.getFileName().equals(fileName)){\r\n\t\t\t\t//close current file\r\n\t\t\t\tcloseFile();\r\n\t\t\t\tmeta.setFileName(fileName);\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file \"+ fileName +\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif(!checkPreviouslyOpened(buildFilename(true))){\r\n\t\t\t\t\tdata.previouslyOpenedFiles.add(buildFilename(true));\r\n\t\t\t\t\tif (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) if (writeHeader()) linesOutput++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteRowToFile(data.outputRowMeta, r);\r\n\t\tputRow(data.outputRowMeta, r);       // in case we want it to go further...\r\n\t\t\r\n        if (checkFeedback(linesOutput)) logBasic(\"linenr \"+linesOutput);\r\n\t\t\r\n\t\treturn result;\r\n\t}","id":40498,"modified_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\r\n\t\tmeta = (TextFileOutputMeta) smi;\r\n\t\tdata = (TextFileOutputData) sdi;\r\n\r\n\t\tboolean result = true;\r\n\t\tboolean bEndedLineWrote = false;\r\n\t\tObject[] r = getRow(); // This also waits for a row to be finished.\r\n\r\n\t\tif (r != null && first) {\r\n\t\t\tfirst = false;\r\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\r\n\t\t\t// if file name in field is enabled then set field name and open file\r\n\t\t\t//\r\n\t\t\tif (meta.isFileNameInField()) {\r\n\r\n\t\t\t\t// find and set index of file name field in input stream\r\n\t\t\t\t//\r\n\t\t\t\tdata.fileNameFieldIndex = getInputRowMeta().indexOfValue(meta.getFileNameField());\r\n\r\n\t\t\t\t// set the file name for this row\r\n\t\t\t\t//\r\n\t\t\t\tif (data.fileNameFieldIndex < 0) {\r\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"TextFileOutput.Exception.FileNameFieldNotFound\", meta.getFileNameField())); // $NON-NLS-1$\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tdata.fileNameMeta = getInputRowMeta().getValueMeta(data.fileNameFieldIndex);\r\n\t\t\t\tdata.fileName = data.fileNameMeta.getString(r[data.fileNameFieldIndex]);\r\n\t\t\t\tsetDataWriterForFilename(data.fileName);\r\n\t\t\t} \r\n\t\t\telse  if (meta.isDoNotOpenNewFileInit() && !meta.isFileNameInField()) {\r\n\t\t\t\t// Open a new file here\r\n\t\t\t\t// \r\n\t\t\t\topenNewFile(meta.getFileName());\r\n\t\t\t\tdata.oneFileOpened = true;\r\n\t\t\t\tinitBinaryDataFields();\r\n\t\t\t}\r\n\r\n\t\t\tif (!meta.isFileAppended() && (meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n\t\t\t{\r\n\t\t\t\tif (!meta.isFileNameInField() && meta.isHeaderEnabled() && data.outputRowMeta != null) {\r\n\t\t\t\t\twriteHeader();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tdata.fieldnrs = new int[meta.getOutputFields().length];\r\n\t\t\tfor (int i = 0; i < meta.getOutputFields().length; i++) {\r\n\t\t\t\tdata.fieldnrs[i] = data.outputRowMeta.indexOfValue(meta.getOutputFields()[i].getName());\r\n\t\t\t\tif (data.fieldnrs[i] < 0) {\r\n\t\t\t\t\tthrow new KettleStepException(\"Field [\" + meta.getOutputFields()[i].getName() + \"] couldn't be found in the input stream!\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ((r == null && data.outputRowMeta != null && meta.isFooterEnabled()) || (r != null && linesOutput > 0 && meta.getSplitEvery() > 0 && ((linesOutput + 1) % meta.getSplitEvery()) == 0)) {\r\n\t\t\tif (data.outputRowMeta != null) {\r\n\t\t\t\tif (meta.isFooterEnabled()) {\r\n\t\t\t\t\twriteHeader();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (r == null) {\r\n\t\t\t\t// add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote = true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r != null) {\r\n\t\t\t\topenNewFile(meta.getFileName());\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.outputRowMeta != null)\r\n\t\t\t\t\tif (writeHeader())\r\n\t\t\t\t\t\tlinesOutput++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (r == null) // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false == bEndedLineWrote) {\r\n\t\t\t\t// add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote = true;\r\n\t\t\t}\r\n\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// First handle the file name in field\r\n\t\t// Write a header line as well if needed\r\n\t\t//\r\n\t\tif (meta.isFileNameInField()) {\r\n\t\t\tString baseFilename = data.fileNameMeta.getString(r[data.fileNameFieldIndex]);\r\n\t\t\tsetDataWriterForFilename(baseFilename);\r\n\t\t}\r\n\t\twriteRowToFile(data.outputRowMeta, r);\r\n\t\tputRow(data.outputRowMeta, r); // in case we want it to go further...\r\n\r\n\t\tif (checkFeedback(linesOutput))\r\n\t\t\tlogBasic(\"linenr \" + linesOutput);\r\n\r\n\t\treturn result;\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String buildFilename(boolean ziparchive)\r\n\t{\r\n\t\treturn meta.buildFilename(this, getCopy(), getPartitionID(), data.splitnr, ziparchive);\r\n\t}","id":40499,"modified_method":"public String buildFilename(String filename, boolean ziparchive)\r\n\t{\r\n\t\treturn TextFileOutputMeta.buildFilename(filename, meta.getExtension(), this, getCopy(), getPartitionID(), data.splitnr, ziparchive, meta);\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean openNewFile()\r\n\t{\r\n\t\t//No need to run if first line and File name in field is set\r\n\t\tif(first && meta.isFileNameInField()) return false;\r\n\t\t\r\n\t\tboolean retval=false;\r\n\t\tdata.writer=null;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n            if (meta.isFileAsCommand())\r\n            {\r\n            \tif(log.isDebug()) logDebug(\"Spawning external process\");\r\n            \tif (data.cmdProc != null)\r\n            \t{\r\n            \t\tlogError(\"Previous command not correctly terminated\");\r\n            \t\tsetErrors(1);\r\n            \t}\r\n            \tString cmdstr = environmentSubstitute(meta.getFileName());\r\n            \tif (Const.getOS().equals(\"Windows 95\"))\r\n                {\r\n            \t\tcmdstr = \"command.com /C \" + cmdstr;\r\n                }\r\n            \telse\r\n                {\r\n                    if (Const.getOS().startsWith(\"Windows\"))\r\n                    {\r\n                        cmdstr = \"cmd.exe /C \" + cmdstr;\r\n                    }\r\n                }\r\n            \tif(log.isDebug()) logDetailed(\"Starting: \" + cmdstr);\r\n            \tRuntime r = Runtime.getRuntime();\r\n            \tdata.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n            \tdata.writer = data.cmdProc.getOutputStream();\r\n            \tStreamLogger stdoutLogger = new StreamLogger( data.cmdProc.getInputStream(), \"(stdout)\" );\r\n            \tStreamLogger stderrLogger = new StreamLogger( data.cmdProc.getErrorStream(), \"(stderr)\" );\r\n            \tnew Thread(stdoutLogger).start();\r\n            \tnew Thread(stderrLogger).start();\r\n            \tretval = true;\r\n            }\r\n            else\r\n            {\r\n                String filename = buildFilename(true);\r\n                if(meta.isAddToResultFiles())\r\n                {\r\n\t\t\t\t\t// Add this to the result file names...\r\n\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename), getTransMeta().getName(), getStepname());\r\n\t\t\t\t\tresultFile.setComment(\"This file was created with a text file output step\");\r\n\t\t            addResultFile(resultFile);\r\n                }\r\n\t\r\n\t            OutputStream outputStream;\r\n                \r\n                if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE))\r\n                {\r\n    \t\t\t\tif (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in zipped mode\");\r\n                        \r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.zip = new ZipOutputStream(data.fos);\r\n    \t\t\t\t\tFile entry = new File(buildFilename(false));\r\n    \t\t\t\t\tZipEntry zipentry = new ZipEntry(entry.getName());\r\n    \t\t\t\t\tzipentry.setComment(\"Compressed by Kettle\");\r\n    \t\t\t\t\tdata.zip.putNextEntry(zipentry);\r\n    \t\t\t\t\toutputStream=data.zip;\r\n    \t\t\t\t}\r\n    \t\t\t\telse if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in gzipped mode\");\r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.gzip = new GZIPOutputStream(data.fos);\r\n    \t\t\t\t\toutputStream=data.gzip;\r\n    \t\t\t\t}\r\n                    else\r\n                    {\r\n                        throw new KettleFileException(\"No compression method specified!\");\r\n                    }\r\n                }\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in nocompress mode\");\r\n                    if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                    outputStream=data.fos;\r\n\t\t\t\t}\r\n                \r\n\t            if (!Const.isEmpty(meta.getEncoding()))\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in encoding: \"+meta.getEncoding());\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t            else\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in default encoding\");\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t\r\n\t            if(log.isDetailed()) logDetailed(\"Opened new file with name [\"+filename+\"]\");\r\n\t\t\t\t\r\n\t\t\t\tretval=true;\r\n            }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error opening new file : \"+e.toString());\r\n\t\t}\r\n\t\t// System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n\t\tdata.splitnr++;\r\n\r\n\t\treturn retval;\r\n\t}","id":40500,"modified_method":"public void openNewFile(String baseFilename) throws KettleException\r\n\t{\r\n\t\tdata.writer=null;\r\n\t\t\r\n\t\tResultFile resultFile = null;\r\n\t\t\r\n\t\tString filename = buildFilename(environmentSubstitute(baseFilename), true);\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n            if (meta.isFileAsCommand())\r\n            {\r\n            \tif(log.isDebug()) logDebug(\"Spawning external process\");\r\n            \tif (data.cmdProc != null)\r\n            \t{\r\n            \t\tlogError(\"Previous command not correctly terminated\");\r\n            \t\tsetErrors(1);\r\n            \t}\r\n            \tString cmdstr = environmentSubstitute(meta.getFileName());\r\n            \tif (Const.getOS().equals(\"Windows 95\"))\r\n                {\r\n            \t\tcmdstr = \"command.com /C \" + cmdstr;\r\n                }\r\n            \telse\r\n                {\r\n                    if (Const.getOS().startsWith(\"Windows\"))\r\n                    {\r\n                        cmdstr = \"cmd.exe /C \" + cmdstr;\r\n                    }\r\n                }\r\n            \tif(log.isDebug()) logDetailed(\"Starting: \" + cmdstr);\r\n            \tRuntime r = Runtime.getRuntime();\r\n            \tdata.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n            \tdata.writer = data.cmdProc.getOutputStream();\r\n            \tStreamLogger stdoutLogger = new StreamLogger( data.cmdProc.getInputStream(), \"(stdout)\" );\r\n            \tStreamLogger stderrLogger = new StreamLogger( data.cmdProc.getErrorStream(), \"(stderr)\" );\r\n            \tnew Thread(stdoutLogger).start();\r\n            \tnew Thread(stderrLogger).start();\r\n            }\r\n            else\r\n            {\r\n            \t// Add this to the result file names...\r\n\t\t\t\tresultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename), getTransMeta().getName(), getStepname());\r\n\t\t\t\tresultFile.setComment(\"This file was created with a text file output step\");\r\n\t            addResultFile(resultFile);\r\n\r\n\t            OutputStream outputStream;\r\n                \r\n                if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE))\r\n                {\r\n    \t\t\t\tif (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in zipped mode\");\r\n                        \r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.zip = new ZipOutputStream(data.fos);\r\n    \t\t\t\t\tFile entry = new File( filename );\r\n    \t\t\t\t\tZipEntry zipentry = new ZipEntry(entry.getName());\r\n    \t\t\t\t\tzipentry.setComment(\"Compressed by Kettle\");\r\n    \t\t\t\t\tdata.zip.putNextEntry(zipentry);\r\n    \t\t\t\t\toutputStream=data.zip;\r\n    \t\t\t\t}\r\n    \t\t\t\telse if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in gzipped mode\");\r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.gzip = new GZIPOutputStream(data.fos);\r\n    \t\t\t\t\toutputStream=data.gzip;\r\n    \t\t\t\t}\r\n                    else\r\n                    {\r\n                        throw new KettleFileException(\"No compression method specified!\");\r\n                    }\r\n                }\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in nocompress mode\");\r\n                    if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                    outputStream=data.fos;\r\n\t\t\t\t}\r\n                \r\n\t            if (!Const.isEmpty(meta.getEncoding()))\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in encoding: \"+meta.getEncoding());\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t            else\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in default encoding\");\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t\r\n\t            if(log.isDetailed()) logDetailed(\"Opened new file with name [\"+filename+\"]\");\r\n            }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Error opening new file : \"+e.toString());\r\n\t\t}\r\n\t\t// System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n\t\tdata.splitnr++;\r\n\r\n        if(resultFile!=null && meta.isAddToResultFiles())\r\n        {\r\n\t\t\t// Add this to the result file names...\r\n            addResultFile(resultFile);\r\n        }\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeRowToFile(RowMetaInterface rowMeta, Object[] r) throws KettleStepException\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tif (meta.getOutputFields()==null || meta.getOutputFields().length==0)\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Write all values in stream to text file.\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<rowMeta.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n                    {\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n                    }\r\n\t\t\t\t\tValueMetaInterface v=rowMeta.getValueMeta(i);\r\n                    Object valueData = r[i];\r\n                    \r\n                    // no special null value default was specified since no fields are specified at all\r\n                    // As such, we pass null\r\n                    //\r\n\t\t\t\t\twriteField(v, valueData, null); \r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Only write the fields specified!\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\r\n\t\t\t\t\tValueMetaInterface v = rowMeta.getValueMeta(data.fieldnrs[i]);\r\n\t\t\t\t\tObject valueData = r[data.fieldnrs[i]];\r\n\t\t\t\t\twriteField(v, valueData, data.binaryNullValue[i]);\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\r\n            linesOutput++;\r\n            \r\n            // flush every 4k lines\r\n            // if (linesOutput>0 && (linesOutput&0xFFF)==0) data.writer.flush();\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(\"Error writing line\", e);\r\n\t\t}\r\n\t}","id":40501,"modified_method":"private void writeRowToFile(RowMetaInterface rowMeta, Object[] r) throws KettleStepException\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tif (meta.getOutputFields()==null || meta.getOutputFields().length==0)\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Write all values in stream to text file.\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<rowMeta.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && data.binarySeparator.length>0)\r\n                    {\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n                    }\r\n\t\t\t\t\tValueMetaInterface v=rowMeta.getValueMeta(i);\r\n                    Object valueData = r[i];\r\n                    \r\n                    // no special null value default was specified since no fields are specified at all\r\n                    // As such, we pass null\r\n                    //\r\n\t\t\t\t\twriteField(v, valueData, null); \r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Only write the fields specified!\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && data.binarySeparator.length>0)\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\r\n\t\t\t\t\tValueMetaInterface v = rowMeta.getValueMeta(data.fieldnrs[i]);\r\n\t\t\t\t\tObject valueData = r[data.fieldnrs[i]];\r\n\t\t\t\t\twriteField(v, valueData, data.binaryNullValue[i]);\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\r\n            linesOutput++;\r\n            \r\n            // flush every 4k lines\r\n            // if (linesOutput>0 && (linesOutput&0xFFF)==0) data.writer.flush();\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(\"Error writing line\", e);\r\n\t\t}\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * \r\n\t */\r\n\tpublic TextFileOutputData()\r\n\t{\r\n\t\tsuper();\r\n\t\t\r\n\t\tnf = NumberFormat.getInstance();\r\n\t\tdf = (DecimalFormat)nf;\r\n\t\tdfs=new DecimalFormatSymbols();\r\n\r\n\t\tdaf = new SimpleDateFormat();\r\n\t\tdafs= new DateFormatSymbols();\r\n        \r\n        defaultDecimalFormat = (DecimalFormat)NumberFormat.getInstance();\r\n        defaultDecimalFormatSymbols =  new DecimalFormatSymbols();\r\n\r\n        defaultDateFormat = new SimpleDateFormat();\r\n        defaultDateFormatSymbols = new DateFormatSymbols();\r\n        \r\n        previouslyOpenedFiles = new ArrayList<String>();\r\n        fileNameFieldIndex = -1;\r\n\r\n        cmdProc = null;\r\n        oneFileOpened=false;\r\n\t}","id":40502,"modified_method":"/**\r\n\t * \r\n\t */\r\n\tpublic TextFileOutputData()\r\n\t{\r\n\t\tsuper();\r\n\t\t\r\n\t\tnf = NumberFormat.getInstance();\r\n\t\tdf = (DecimalFormat)nf;\r\n\t\tdfs=new DecimalFormatSymbols();\r\n\r\n\t\tdaf = new SimpleDateFormat();\r\n\t\tdafs= new DateFormatSymbols();\r\n        \r\n        defaultDecimalFormat = (DecimalFormat)NumberFormat.getInstance();\r\n        defaultDecimalFormatSymbols =  new DecimalFormatSymbols();\r\n\r\n        defaultDateFormat = new SimpleDateFormat();\r\n        defaultDateFormatSymbols = new DateFormatSymbols();\r\n        \r\n        previouslyOpenedFiles = new ArrayList<String>();\r\n        fileNameFieldIndex = -1;\r\n\r\n        cmdProc = null;\r\n        oneFileOpened=false;\r\n        \r\n        fileWriterMap = new HashMap<String,OutputStream>();\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDateTimeFormat(String date_time_format)\r\n \t{\r\n \t\tthis.date_time_format=date_time_format;\r\n \t}","id":40503,"modified_method":"public void setDateTimeFormat(String dateTimeFormat)\r\n \t{\r\n \t\tthis.dateTimeFormat=dateTimeFormat;\r\n \t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setSpecifyFormat(boolean SpecifyFormat)\r\n    {\r\n    \tthis.SpecifyFormat=SpecifyFormat;\r\n    }","id":40504,"modified_method":"public void setSpecifyingFormat(boolean specifyingFormat)\r\n    {\r\n    \tthis.specifyingFormat=specifyingFormat;\r\n    }","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getDateTimeFormat()\r\n \t{\r\n \t\treturn date_time_format;\r\n \t}","id":40505,"modified_method":"public String getDateTimeFormat()\r\n \t{\r\n \t\treturn dateTimeFormat;\r\n \t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator = XMLHandler.getTagValue(stepnode, \"separator\");\r\n\t\t\tif (separator==null) separator=\"\";\r\n\t\t\t\r\n\t\t\tenclosure=XMLHandler.getTagValue(stepnode, \"enclosure\");\r\n\t\t\tif (enclosure==null) enclosure=\"\";\r\n\r\n            enclosureForced = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"enclosure_forced\"));\r\n\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tfileFormat       = XMLHandler.getTagValue(stepnode, \"format\");\r\n\t\t\tfileCompression  = XMLHandler.getTagValue(stepnode, \"compression\");\r\n\t\t\tif (fileCompression == null) \r\n            {\r\n\t\t\t  if (\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"zipped\")))\r\n              {\r\n\t\t\t      fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n              }\r\n\t\t\t  else\r\n              {\r\n\t\t\t\t  fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n              }\r\n\t\t\t}\r\n            encoding = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\r\n            endedLine = XMLHandler.getTagValue(stepnode, \"endedLine\");\r\n\t\t\tif (endedLine==null) endedLine=\"\";\r\n\r\n\t\t\tfileName              = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tfileAsCommand         = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"is_command\"));\r\n\t\t\tdoNotOpenNewFileInit  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_new_file_init\"));\r\n\t\t\textension             = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended          = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tSpecifyFormat        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdate_time_format             = XMLHandler.getTagValue(stepnode, \"file\", \"date_time_format\");\r\n\t\t\t\r\n\t\t\tString AddToResultFiles= XMLHandler.getTagValue(stepnode, \"file\", \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames  = \"Y\".equalsIgnoreCase(AddToResultFiles);\r\n\t\t\t\r\n\t\t\tpadded       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"pad\"));\r\n\t\t\tfastDump     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"fast_dump\"));\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\r\n\t\t\tfileNameInField=\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"fileNameInField\"));\r\n\t\t\tfileNameField       = XMLHandler.getTagValue(stepnode, \"fileNameField\");\r\n\t\t\t\t\t\t\r\n\t\t\tNode fields  = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new TextFileField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t\toutputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\r\n\t\t\t\toutputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\r\n\t\t\t\toutputFields[i].setGroupingSymbol( XMLHandler.getTagValue(fnode, \"group\") );\r\n\t\t\t    outputFields[i].setTrimType( ValueMeta.getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\")) );\r\n\t\t\t\toutputFields[i].setNullString( XMLHandler.getTagValue(fnode, \"nullif\") );\r\n\t\t\t\toutputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\r\n\t\t\t\toutputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","id":40506,"modified_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator = XMLHandler.getTagValue(stepnode, \"separator\");\r\n\t\t\tif (separator==null) separator=\"\";\r\n\t\t\t\r\n\t\t\tenclosure=XMLHandler.getTagValue(stepnode, \"enclosure\");\r\n\t\t\tif (enclosure==null) enclosure=\"\";\r\n\r\n            enclosureForced = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"enclosure_forced\"));\r\n\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tfileFormat       = XMLHandler.getTagValue(stepnode, \"format\");\r\n\t\t\tfileCompression  = XMLHandler.getTagValue(stepnode, \"compression\");\r\n\t\t\tif (fileCompression == null) \r\n            {\r\n\t\t\t  if (\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"zipped\")))\r\n              {\r\n\t\t\t      fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n              }\r\n\t\t\t  else\r\n              {\r\n\t\t\t\t  fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n              }\r\n\t\t\t}\r\n            encoding = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\r\n            endedLine = XMLHandler.getTagValue(stepnode, \"endedLine\");\r\n\t\t\tif (endedLine==null) endedLine=\"\";\r\n\r\n\t\t\tfileName              = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tfileAsCommand         = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"is_command\"));\r\n\t\t\tdoNotOpenNewFileInit  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_new_file_init\"));\r\n\t\t\textension             = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended          = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tspecifyingFormat        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdateTimeFormat             = XMLHandler.getTagValue(stepnode, \"file\", \"date_time_format\");\r\n\t\t\t\r\n\t\t\tString AddToResultFiles= XMLHandler.getTagValue(stepnode, \"file\", \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames  = \"Y\".equalsIgnoreCase(AddToResultFiles);\r\n\t\t\t\r\n\t\t\tpadded       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"pad\"));\r\n\t\t\tfastDump     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"fast_dump\"));\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\r\n\t\t\tfileNameInField=\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"fileNameInField\"));\r\n\t\t\tfileNameField       = XMLHandler.getTagValue(stepnode, \"fileNameField\");\r\n\t\t\t\t\t\t\r\n\t\t\tNode fields  = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new TextFileField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t\toutputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\r\n\t\t\t\toutputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\r\n\t\t\t\toutputFields[i].setGroupingSymbol( XMLHandler.getTagValue(fnode, \"group\") );\r\n\t\t\t    outputFields[i].setTrimType( ValueMeta.getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\")) );\r\n\t\t\t\toutputFields[i].setNullString( XMLHandler.getTagValue(fnode, \"nullif\") );\r\n\t\t\t\toutputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\r\n\t\t\t\toutputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator       =      rep.getStepAttributeString (id_step, \"separator\");\r\n\t\t\tenclosure       =      rep.getStepAttributeString (id_step, \"enclosure\");\r\n            enclosureForced =      rep.getStepAttributeBoolean(id_step, \"enclosure_forced\");\r\n\t\t\theaderEnabled   =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled   =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n\t\t\tfileFormat      =      rep.getStepAttributeString (id_step, \"format\");  \r\n\t\t\tfileCompression =      rep.getStepAttributeString (id_step, \"compression\");\r\n\t\t\tfileNameInField =      rep.getStepAttributeBoolean (id_step, \"fileNameInField\");\r\n\t\t\tfileNameField\t=\t   rep.getStepAttributeString (id_step, \"fileNameField\");\r\n\t\t\tif (fileCompression == null)\r\n\t\t\t{\r\n\t\t\t\tif (rep.getStepAttributeBoolean(id_step, \"zipped\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tfileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n\t\t\t\t}\r\n                else\r\n                {\r\n                    fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n                }\r\n\t\t\t}\r\n            encoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            \r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\tfileAsCommand        =      rep.getStepAttributeBoolean (id_step, \"file_is_command\");  \r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_new_file_init\");\r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tsplitEvery      = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tSpecifyFormat        =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdate_time_format       =      rep.getStepAttributeString (id_step, \"date_time_format\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tString AddToResultFiles = rep.getStepAttributeString (id_step, \"add_to_result_filenames\");  \r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames   =      rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tpadded             =      rep.getStepAttributeBoolean(id_step, \"file_pad\");\r\n\t\t\tfastDump             =      rep.getStepAttributeBoolean(id_step, \"file_fast_dump\");\r\n\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new TextFileField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t    outputFields[i].setCurrencySymbol(\trep.getStepAttributeString (id_step, i, \"field_currency\") );\r\n\t\t\t    outputFields[i].setDecimalSymbol(\trep.getStepAttributeString (id_step, i, \"field_decimal\") );\r\n\t\t\t    outputFields[i].setGroupingSymbol(\trep.getStepAttributeString (id_step, i, \"field_group\") );\r\n\t\t\t\toutputFields[i].setTrimType(        ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\t\t\t    \r\n\t\t\t    outputFields[i].setNullString(\t\trep.getStepAttributeString (id_step, i, \"field_nullif\") );\r\n\t\t\t    outputFields[i].setLength(\t   (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\r\n\t\t\t    outputFields[i].setPrecision(  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\r\n\t\t\t}\r\n            endedLine        =      rep.getStepAttributeString (id_step, \"endedLine\");\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","id":40507,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator       =      rep.getStepAttributeString (id_step, \"separator\");\r\n\t\t\tenclosure       =      rep.getStepAttributeString (id_step, \"enclosure\");\r\n            enclosureForced =      rep.getStepAttributeBoolean(id_step, \"enclosure_forced\");\r\n\t\t\theaderEnabled   =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled   =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n\t\t\tfileFormat      =      rep.getStepAttributeString (id_step, \"format\");  \r\n\t\t\tfileCompression =      rep.getStepAttributeString (id_step, \"compression\");\r\n\t\t\tfileNameInField =      rep.getStepAttributeBoolean (id_step, \"fileNameInField\");\r\n\t\t\tfileNameField\t=\t   rep.getStepAttributeString (id_step, \"fileNameField\");\r\n\t\t\tif (fileCompression == null)\r\n\t\t\t{\r\n\t\t\t\tif (rep.getStepAttributeBoolean(id_step, \"zipped\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tfileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n\t\t\t\t}\r\n                else\r\n                {\r\n                    fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n                }\r\n\t\t\t}\r\n            encoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            \r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\tfileAsCommand        =      rep.getStepAttributeBoolean (id_step, \"file_is_command\");  \r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_new_file_init\");\r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tsplitEvery      = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tspecifyingFormat        =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdateTimeFormat       =      rep.getStepAttributeString (id_step, \"date_time_format\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tString AddToResultFiles = rep.getStepAttributeString (id_step, \"add_to_result_filenames\");  \r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames   =      rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tpadded             =      rep.getStepAttributeBoolean(id_step, \"file_pad\");\r\n\t\t\tfastDump             =      rep.getStepAttributeBoolean(id_step, \"file_fast_dump\");\r\n\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new TextFileField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t    outputFields[i].setCurrencySymbol(\trep.getStepAttributeString (id_step, i, \"field_currency\") );\r\n\t\t\t    outputFields[i].setDecimalSymbol(\trep.getStepAttributeString (id_step, i, \"field_decimal\") );\r\n\t\t\t    outputFields[i].setGroupingSymbol(\trep.getStepAttributeString (id_step, i, \"field_group\") );\r\n\t\t\t\toutputFields[i].setTrimType(        ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\t\t\t    \r\n\t\t\t    outputFields[i].setNullString(\t\trep.getStepAttributeString (id_step, i, \"field_nullif\") );\r\n\t\t\t    outputFields[i].setLength(\t   (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\r\n\t\t\t    outputFields[i].setPrecision(  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\r\n\t\t\t}\r\n            endedLine        =      rep.getStepAttributeString (id_step, \"endedLine\");\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean  isSpecifyFormat()\r\n    {\r\n    \treturn SpecifyFormat;\r\n    }","id":40508,"modified_method":"public boolean  isSpecifyingFormat()\r\n    {\r\n    \treturn specifyingFormat;\r\n    }","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\r\n\t{\r\n\t\tseparator  = \";\";\r\n\t\tenclosure  = \"\\\"\";\r\n\t\tSpecifyFormat=false;\r\n\t\tdate_time_format=null;\r\n        enclosureForced  = false;\r\n\t\theaderEnabled    = true;\r\n\t\tfooterEnabled    = false;\r\n\t\tfileFormat       = \"DOS\";\r\n\t\tfileCompression  = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n\t\tfileName         = \"file\";\r\n\t\tfileAsCommand    = false;\r\n\t\tdoNotOpenNewFileInit =false;\r\n\t\textension        = \"txt\";\r\n\t\tstepNrInFilename = false;\r\n\t\tpartNrInFilename = false;\r\n\t\tdateInFilename   = false;\r\n\t\ttimeInFilename   = false;\r\n\t\tpadded           = false;\r\n\t\tfastDump         = false;\r\n\t\taddToResultFilenames=true;\r\n\t\tsplitEvery       = 0;\r\n\r\n\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\tint i, nrfields=0;\r\n\t\t\r\n\t\tallocate(nrfields);\r\n\t\t\t\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t\toutputFields[i] = new TextFileField();\r\n\r\n\t\t\toutputFields[i].setName( \"field\"+i );\t\t\t\t\r\n\t\t\toutputFields[i].setType( \"Number\" );\r\n\t\t\toutputFields[i].setFormat( \" 0,000,000.00;-0,000,000.00\" );\r\n\t\t\toutputFields[i].setCurrencySymbol( \"\" );\r\n\t\t\toutputFields[i].setDecimalSymbol( \",\" );\r\n\t\t\toutputFields[i].setGroupingSymbol(  \".\" );\r\n\t\t\toutputFields[i].setNullString( \"\" );\r\n\t\t\toutputFields[i].setLength( -1 );\r\n\t\t\toutputFields[i].setPrecision( -1 );\r\n\t\t}\r\n\t\tfileAppended=false;\r\n\t}","id":40509,"modified_method":"public void setDefault()\r\n\t{\r\n\t\tseparator  = \";\";\r\n\t\tenclosure  = \"\\\"\";\r\n\t\tspecifyingFormat=false;\r\n\t\tdateTimeFormat=null;\r\n        enclosureForced  = false;\r\n\t\theaderEnabled    = true;\r\n\t\tfooterEnabled    = false;\r\n\t\tfileFormat       = \"DOS\";\r\n\t\tfileCompression  = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n\t\tfileName         = \"file\";\r\n\t\tfileAsCommand    = false;\r\n\t\tdoNotOpenNewFileInit =false;\r\n\t\textension        = \"txt\";\r\n\t\tstepNrInFilename = false;\r\n\t\tpartNrInFilename = false;\r\n\t\tdateInFilename   = false;\r\n\t\ttimeInFilename   = false;\r\n\t\tpadded           = false;\r\n\t\tfastDump         = false;\r\n\t\taddToResultFilenames=true;\r\n\t\tsplitEvery       = 0;\r\n\r\n\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\tint i, nrfields=0;\r\n\t\t\r\n\t\tallocate(nrfields);\r\n\t\t\t\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t\toutputFields[i] = new TextFileField();\r\n\r\n\t\t\toutputFields[i].setName( \"field\"+i );\t\t\t\t\r\n\t\t\toutputFields[i].setType( \"Number\" );\r\n\t\t\toutputFields[i].setFormat( \" 0,000,000.00;-0,000,000.00\" );\r\n\t\t\toutputFields[i].setCurrencySymbol( \"\" );\r\n\t\t\toutputFields[i].setDecimalSymbol( \",\" );\r\n\t\t\toutputFields[i].setGroupingSymbol(  \".\" );\r\n\t\t\toutputFields[i].setNullString( \"\" );\r\n\t\t\toutputFields[i].setLength( -1 );\r\n\t\t\toutputFields[i].setPrecision( -1 );\r\n\t\t}\r\n\t\tfileAppended=false;\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", separator));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure_forced\", enclosureForced));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"format\",    fileFormat));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"compression\",    fileCompression));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"endedLine\",  endedLine));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameInField\",  fileNameInField));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameField\",  fileNameField));        \r\n\r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"is_command\", fileAsCommand));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_new_file_init\", doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   SpecifyFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  date_time_format));\r\n\t\t\r\n\t\t\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pad\",        padded));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"fast_dump\",  fastDump));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\tretval.append(\"    <\/file>\").append(Const.CR);\r\n        \r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!=null && field.getName().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\",  field.getCurrencySymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\",   field.getDecimalSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\",     field.getGroupingSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\",    field.getNullString()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", field.getTrimTypeCode()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\",    field.getLength()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n\t\treturn retval.toString();\r\n\t}","id":40510,"modified_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", separator));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure_forced\", enclosureForced));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"format\",    fileFormat));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"compression\",    fileCompression));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"endedLine\",  endedLine));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameInField\",  fileNameInField));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameField\",  fileNameField));        \r\n\r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"is_command\", fileAsCommand));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_new_file_init\", doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   specifyingFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  dateTimeFormat));\r\n\t\t\r\n\t\t\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pad\",        padded));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"fast_dump\",  fastDump));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\tretval.append(\"    <\/file>\").append(Const.CR);\r\n        \r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!=null && field.getName().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\",  field.getCurrencySymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\",   field.getDecimalSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\",     field.getGroupingSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\",    field.getNullString()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", field.getTrimTypeCode()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\",    field.getLength()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n\t\treturn retval.toString();\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String buildFilename(VariableSpace space, int stepnr, String partnr, int splitnr, boolean ziparchive)\r\n\t{\r\n\t\tSimpleDateFormat daf     = new SimpleDateFormat();\r\n\r\n\t\t// Replace possible environment variables...\r\n\t\tString retval=space.environmentSubstitute( fileName );\r\n\t\tString realextension=space.environmentSubstitute( extension );\r\n\t\t\r\n\t\tif (fileAsCommand)\r\n\t\t\treturn retval;\r\n\r\n\t\tDate now = new Date();\r\n\t\t\r\n\t\tif(SpecifyFormat && !Const.isEmpty(date_time_format))\r\n\t\t{\r\n\t\t\tdaf.applyPattern(date_time_format);\r\n\t\t\tString dt = daf.format(now);\r\n\t\t\tretval+=dt;\r\n\t\t}else\r\n\t\t{\r\n\t\t\tif (dateInFilename)\r\n\t\t\t{\r\n\t\t\t\tdaf.applyPattern(\"yyyMMdd\");\r\n\t\t\t\tString d = daf.format(now);\r\n\t\t\t\tretval+=\"_\"+d;\r\n\t\t\t}\r\n\t\t\tif (timeInFilename)\r\n\t\t\t{\r\n\t\t\t\tdaf.applyPattern(\"HHmmss\");\r\n\t\t\t\tString t = daf.format(now);\r\n\t\t\t\tretval+=\"_\"+t;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (stepNrInFilename)\r\n\t\t{\r\n\t\t\tretval+=\"_\"+stepnr;\r\n\t\t}\r\n\t\tif (partNrInFilename)\r\n\t\t{\r\n\t\t\tretval+=\"_\"+partnr;\r\n\t\t}\r\n\t\tif (splitEvery>0)\r\n\t\t{\r\n\t\t\tretval+=\"_\"+splitnr;\r\n\t\t}\r\n\t\t\r\n\t\tif (fileCompression.equals(\"Zip\"))\r\n\t\t{\r\n\t\t\tif (ziparchive)\r\n\t\t\t{\r\n\t\t\t\tretval+=\".zip\";\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (realextension!=null && realextension.length()!=0) \r\n\t\t\t\t{\r\n\t\t\t\t\tretval+=\".\"+realextension;\r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (realextension!=null && realextension.length()!=0) \r\n\t\t\t{\r\n\t\t\t\tretval+=\".\"+realextension;\r\n\t\t\t}\r\n\t\t\tif (fileCompression.equals(\"GZip\"))\r\n\t\t\t{\r\n\t\t\t\tretval += \".gz\";\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn retval;\r\n\t}","id":40511,"modified_method":"public String buildFilename(VariableSpace space, int stepnr, String partnr, int splitnr, boolean ziparchive)\r\n\t{\r\n\t\treturn buildFilename(fileName, extension, space, stepnr, partnr, splitnr, ziparchive, this);\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\",        separator);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\",        enclosure);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"enclosure_forced\", enclosureForced);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"format\",           fileFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"compression\",      fileCompression);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_is_command\",  fileAsCommand);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_new_file_init\", doNotOpenNewFileInit);  \r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   date_time_format);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    SpecifyFormat);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_pad\",         padded);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_fast_dump\",   fastDump);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameInField\",   fileNameInField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameField\",   fileNameField);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    TextFileField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",  field.getCurrencySymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   field.getDecimalSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     field.getGroupingSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", field.getTrimTypeCode());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    field.getNullString());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    field.getLength());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\r\n\t\t\t}\r\n            rep.saveStepAttribute(id_transformation, id_step, \"endedLine\",         endedLine);\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","id":40512,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\",        separator);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\",        enclosure);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"enclosure_forced\", enclosureForced);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"format\",           fileFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"compression\",      fileCompression);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_is_command\",  fileAsCommand);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_new_file_init\", doNotOpenNewFileInit);  \r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   dateTimeFormat);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    specifyingFormat);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_pad\",         padded);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_fast_dump\",   fastDump);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameInField\",   fileNameInField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameField\",   fileNameField);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    TextFileField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",  field.getCurrencySymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   field.getDecimalSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     field.getGroupingSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", field.getTrimTypeCode());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    field.getNullString());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    field.getLength());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\r\n\t\t\t}\r\n            rep.saveStepAttribute(id_transformation, id_step, \"endedLine\",         endedLine);\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","commit_id":"c82ccf2f99190f4f95163b3405e36ad9fdbc9444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(AccessOutputMeta)smi;\n\t\tdata=(AccessOutputData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\ttry\n\t\t\t{\n                String realFilename = environmentSubstitute(meta.getFilename());\n                logBasic(Messages.getString(\"AccessOutput.log.WritingToFile\", realFilename));\n                FileObject fileObject = KettleVFS.getFileObject(realFilename);\n                File file = new File(KettleVFS.getFilename(fileObject));\n                \n                // First open or create the access file\n                if (!file.exists())\n                {\n                    if (meta.isFileCreated())\n                    {\n                        data.db = Database.create(file);\n                    }\n                    else\n                    {\n                        logError(Messages.getString(\"AccessOutput.InitError.FileDoesNotExist\", realFilename));\n                        return false;\n                    }\n                }\n                else\n                {\n                    data.db = Database.open(file);\n                }\n                \n                // Add the filename to the result object...\n                //\n    \t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, getTransMeta().getName(), toString());\n    \t\t\taddResultFile(resultFile);\n                \n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tlogError(\"An error occurred intialising this step: \"+e.getMessage());\n\t\t\t\tstopAll();\n\t\t\t\tsetErrors(1);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":40513,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(AccessOutputMeta)smi;\n\t\tdata=(AccessOutputData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\ttry\n\t\t\t{\n                String realFilename = environmentSubstitute(meta.getFilename());\n                logBasic(Messages.getString(\"AccessOutput.log.WritingToFile\", realFilename));\n                FileObject fileObject = KettleVFS.getFileObject(realFilename);\n                File file = new File(KettleVFS.getFilename(fileObject));\n                \n                // First open or create the access file\n                if (!file.exists())\n                {\n                    if (meta.isFileCreated())\n                    {\n                        data.db = Database.create(file);\n                    }\n                    else\n                    {\n                        logError(Messages.getString(\"AccessOutput.InitError.FileDoesNotExist\", realFilename));\n                        return false;\n                    }\n                }\n                else\n                {\n                    data.db = Database.open(file);\n                }\n                \n                // Add the filename to the result object...\n                //\r\n                if(meta.isAddToResultFiles())\r\n                {\n\t    \t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, getTransMeta().getName(), toString());\n\t    \t\t\tresultFile.setComment(\"This file was created with an access output step\");\r\n\t    \t\t\taddResultFile(resultFile);\r\n                }\n                \n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tlogError(\"An error occurred intialising this step: \"+e.getMessage());\n\t\t\t\tstopAll();\n\t\t\t\tsetErrors(1);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n        if (input.getFilename()  != null) wFilename.setText(input.getFilename());\n\t\tif (input.getTablename() != null) wTablename.setText(input.getTablename());\n\t\t\n        wCreateFile.setSelection( input.isFileCreated() );\n        wCreateTable.setSelection(input.isFileCreated() );\n        if (input.getCommitSize()>0) wCommitSize.setText( Integer.toString( input.getCommitSize() ) );\n\t\t\n\t\twStepname.selectAll();\n\t}","id":40514,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n        if (input.getFilename()  != null) wFilename.setText(input.getFilename());\n\t\tif (input.getTablename() != null) wTablename.setText(input.getTablename());\n\t\t\n        wCreateFile.setSelection( input.isFileCreated() );\n        wCreateTable.setSelection(input.isFileCreated() );\n        if (input.getCommitSize()>0) wCommitSize.setText( Integer.toString( input.getCommitSize() ) );\r\n        wAddToResult.setSelection(input.isAddToResultFiles());\n\t\t\n\t\twStepname.selectAll();\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, input);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n        SelectionAdapter lsSelMod = new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent arg0)\n            {\n                input.setChanged();\n            }\n        };\n\t\tbackupChanged = input.hasChanged();\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AccessOutputDialog.DialogTitle\"));\n\t\t\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, 0);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, margin);\n\t\tfdStepname.top  = new FormAttachment(0, 0);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n        // Filename line\n        wlFilename=new Label(shell, SWT.RIGHT);\n        wlFilename.setText(Messages.getString(\"AccessOutputDialog.Filename.Label\"));\n        props.setLook(wlFilename);\n        fdlFilename=new FormData();\n        fdlFilename.left = new FormAttachment(0, 0);\n        fdlFilename.top  = new FormAttachment(wStepname, margin);\n        fdlFilename.right= new FormAttachment(middle, 0);\n        wlFilename.setLayoutData(fdlFilename);\n\n        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbbFilename);\n        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n        fdbFilename=new FormData();\n        fdbFilename.right= new FormAttachment(100, 0);\n        fdbFilename.top  = new FormAttachment(wStepname, margin);\n        wbbFilename.setLayoutData(fdbFilename);\n\n        wFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wFilename.setToolTipText(Messages.getString(\"AccessOutputDialog.Filename.Tooltip\"));\n        props.setLook(wFilename);\n        wFilename.addModifyListener(lsMod);\n        fdFilename=new FormData();\n        fdFilename.left = new FormAttachment(middle, margin);\n        fdFilename.right= new FormAttachment(wbbFilename, -margin);\n        fdFilename.top  = new FormAttachment(wStepname, margin);\n        wFilename.setLayoutData(fdFilename);\n\n        // Create file?\n        wlCreateFile=new Label(shell, SWT.RIGHT);\n        wlCreateFile.setText(Messages.getString(\"AccessOutputDialog.CreateFile.Label\"));\n        wlCreateFile.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateFile.Tooltip\"));\n        props.setLook(wlCreateFile);\n        fdlCreateFile=new FormData();\n        fdlCreateFile.left  = new FormAttachment(0, 0);\n        fdlCreateFile.top   = new FormAttachment(wFilename, margin);\n        fdlCreateFile.right = new FormAttachment(middle, 0);\n        wlCreateFile.setLayoutData(fdlCreateFile);\n        wCreateFile=new Button(shell, SWT.CHECK);\n        wCreateFile.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateFile.Tooltip\"));\n        props.setLook(wCreateFile);\n        fdCreateFile=new FormData();\n        fdCreateFile.left  = new FormAttachment(middle, margin);\n        fdCreateFile.top   = new FormAttachment(wFilename, margin);\n        fdCreateFile.right = new FormAttachment(100, 0);\n        wCreateFile.setLayoutData(fdCreateFile);\n        wCreateFile.addSelectionListener(lsSelMod);\n\n\t\t// Table line...\n        wbbTablename=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbbTablename);\n        wbbTablename.setText(Messages.getString(\"System.Button.Browse\"));\n        fdbTablename=new FormData();\n        fdbTablename.right= new FormAttachment(100, 0);\n        fdbTablename.top  = new FormAttachment(wCreateFile, margin);\n        wbbTablename.setLayoutData(fdbTablename);\n\n        wlTablename=new Label(shell, SWT.RIGHT);\n        wlTablename.setText(Messages.getString(\"AccessOutputDialog.TargetTable.Label\"));\n        props.setLook(wlTablename);\n        fdlTablename=new FormData();\n        fdlTablename.left = new FormAttachment(0, 0);\n        fdlTablename.top  = new FormAttachment(wCreateFile, margin);\n        fdlTablename.right= new FormAttachment(middle, 0);\n        wlTablename.setLayoutData(fdlTablename);\n\n        wTablename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wTablename.setToolTipText(Messages.getString(\"AccessOutputDialog.TargetTable.Tooltip\"));\n \t\tprops.setLook(wTablename);\n\t\tfdTablename=new FormData();\n        fdTablename.left = new FormAttachment(middle, margin);\n        fdTablename.right= new FormAttachment(wbbTablename, -margin);\n        fdTablename.top  = new FormAttachment(wCreateFile, margin);\n\t\twTablename.setLayoutData(fdTablename);\n\n\t\t// Create table?\n\t\twlCreateTable=new Label(shell, SWT.RIGHT);\n\t\twlCreateTable.setText(Messages.getString(\"AccessOutputDialog.CreateTable.Label\"));\n        wlCreateTable.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateTable.Tooltip\"));\n \t\tprops.setLook(wlCreateTable);\n\t\tfdlCreateTable=new FormData();\n\t\tfdlCreateTable.left  = new FormAttachment(0, 0);\n\t\tfdlCreateTable.top   = new FormAttachment(wTablename, margin);\n\t\tfdlCreateTable.right = new FormAttachment(middle, 0);\n\t\twlCreateTable.setLayoutData(fdlCreateTable);\n\t\twCreateTable=new Button(shell, SWT.CHECK);\n        wCreateTable.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateTable.Tooltip\"));\n \t\tprops.setLook(wCreateTable);\n\t\tfdCreateTable=new FormData();\n\t\tfdCreateTable.left  = new FormAttachment(middle, margin);\n\t\tfdCreateTable.top   = new FormAttachment(wTablename, margin);\n\t\tfdCreateTable.right = new FormAttachment(100, 0);\n\t\twCreateTable.setLayoutData(fdCreateTable);\n\t\twCreateTable.addSelectionListener(lsSelMod);\n        \n        // The commit size...\n        wlCommitSize=new Label(shell, SWT.RIGHT);\n        wlCommitSize.setText(Messages.getString(\"AccessOutputDialog.CommitSize.Label\"));\n        props.setLook(wlCommitSize);\n        fdlCommitSize=new FormData();\n        fdlCommitSize.left = new FormAttachment(0, 0);\n        fdlCommitSize.top  = new FormAttachment(wCreateTable, margin);\n        fdlCommitSize.right= new FormAttachment(middle, 0);\n        wlCommitSize.setLayoutData(fdlCommitSize);\n\n        wCommitSize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wCommitSize.setToolTipText(Messages.getString(\"AccessOutputDialog.CommitSize.Tooltip\"));\n        props.setLook(wCommitSize);\n        fdCommitSize=new FormData();\n        fdCommitSize.left = new FormAttachment(middle, margin);\n        fdCommitSize.right= new FormAttachment(100, 0);\n        fdCommitSize.top  = new FormAttachment(wCreateTable, margin);\n        wCommitSize.setLayoutData(fdCommitSize);\n\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTablename.addSelectionListener( lsDef );\n\t\t\n\t\twbbTablename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n        \n        // Listen to the Browse... button\n        wbbFilename.addSelectionListener\n        (\n            new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e) \n                {\n                    FileDialog dialog = new FileDialog(shell, SWT.OPEN);\n                    dialog.setFilterExtensions(new String[] {\"*.mdb;*.MDB\", \"*\"});\n\n                    if (!Const.isEmpty(wFilename.getText()))\n                    {\n                        String fname = transMeta.environmentSubstitute(wFilename.getText());\n                        dialog.setFileName( fname );\n                    }\n                    \n                    dialog.setFilterNames(new String[] {Messages.getString(\"AccessOutputDialog.FileType.AccessFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n                    \n                    if (dialog.open()!=null)\n                    {\n                        String str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n                        wFilename.setText(str);\n                    }\n                }\n            }\n        );\n\n        \n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":40515,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, input);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n        SelectionAdapter lsSelMod = new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent arg0)\n            {\n                input.setChanged();\n            }\n        };\n\t\tbackupChanged = input.hasChanged();\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AccessOutputDialog.DialogTitle\"));\n\t\t\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, 0);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, margin);\n\t\tfdStepname.top  = new FormAttachment(0, 0);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n        // Filename line\n        wlFilename=new Label(shell, SWT.RIGHT);\n        wlFilename.setText(Messages.getString(\"AccessOutputDialog.Filename.Label\"));\n        props.setLook(wlFilename);\n        fdlFilename=new FormData();\n        fdlFilename.left = new FormAttachment(0, 0);\n        fdlFilename.top  = new FormAttachment(wStepname, margin);\n        fdlFilename.right= new FormAttachment(middle, 0);\n        wlFilename.setLayoutData(fdlFilename);\n\n        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbbFilename);\n        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n        fdbFilename=new FormData();\n        fdbFilename.right= new FormAttachment(100, 0);\n        fdbFilename.top  = new FormAttachment(wStepname, margin);\n        wbbFilename.setLayoutData(fdbFilename);\n\n        wFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wFilename.setToolTipText(Messages.getString(\"AccessOutputDialog.Filename.Tooltip\"));\n        props.setLook(wFilename);\n        wFilename.addModifyListener(lsMod);\n        fdFilename=new FormData();\n        fdFilename.left = new FormAttachment(middle, margin);\n        fdFilename.right= new FormAttachment(wbbFilename, -margin);\n        fdFilename.top  = new FormAttachment(wStepname, margin);\n        wFilename.setLayoutData(fdFilename);\n\n        // Create file?\n        wlCreateFile=new Label(shell, SWT.RIGHT);\n        wlCreateFile.setText(Messages.getString(\"AccessOutputDialog.CreateFile.Label\"));\n        wlCreateFile.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateFile.Tooltip\"));\n        props.setLook(wlCreateFile);\n        fdlCreateFile=new FormData();\n        fdlCreateFile.left  = new FormAttachment(0, 0);\n        fdlCreateFile.top   = new FormAttachment(wFilename, margin);\n        fdlCreateFile.right = new FormAttachment(middle, 0);\n        wlCreateFile.setLayoutData(fdlCreateFile);\n        wCreateFile=new Button(shell, SWT.CHECK);\n        wCreateFile.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateFile.Tooltip\"));\n        props.setLook(wCreateFile);\n        fdCreateFile=new FormData();\n        fdCreateFile.left  = new FormAttachment(middle, margin);\n        fdCreateFile.top   = new FormAttachment(wFilename, margin);\n        fdCreateFile.right = new FormAttachment(100, 0);\n        wCreateFile.setLayoutData(fdCreateFile);\n        wCreateFile.addSelectionListener(lsSelMod);\n\n\t\t// Table line...\n        wbbTablename=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbbTablename);\n        wbbTablename.setText(Messages.getString(\"System.Button.Browse\"));\n        fdbTablename=new FormData();\n        fdbTablename.right= new FormAttachment(100, 0);\n        fdbTablename.top  = new FormAttachment(wCreateFile, margin);\n        wbbTablename.setLayoutData(fdbTablename);\n\n        wlTablename=new Label(shell, SWT.RIGHT);\n        wlTablename.setText(Messages.getString(\"AccessOutputDialog.TargetTable.Label\"));\n        props.setLook(wlTablename);\n        fdlTablename=new FormData();\n        fdlTablename.left = new FormAttachment(0, 0);\n        fdlTablename.top  = new FormAttachment(wCreateFile, margin);\n        fdlTablename.right= new FormAttachment(middle, 0);\n        wlTablename.setLayoutData(fdlTablename);\n\n        wTablename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wTablename.setToolTipText(Messages.getString(\"AccessOutputDialog.TargetTable.Tooltip\"));\n \t\tprops.setLook(wTablename);\n\t\tfdTablename=new FormData();\n        fdTablename.left = new FormAttachment(middle, margin);\n        fdTablename.right= new FormAttachment(wbbTablename, -margin);\n        fdTablename.top  = new FormAttachment(wCreateFile, margin);\n\t\twTablename.setLayoutData(fdTablename);\n\n\t\t// Create table?\n\t\twlCreateTable=new Label(shell, SWT.RIGHT);\n\t\twlCreateTable.setText(Messages.getString(\"AccessOutputDialog.CreateTable.Label\"));\n        wlCreateTable.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateTable.Tooltip\"));\n \t\tprops.setLook(wlCreateTable);\n\t\tfdlCreateTable=new FormData();\n\t\tfdlCreateTable.left  = new FormAttachment(0, 0);\n\t\tfdlCreateTable.top   = new FormAttachment(wTablename, margin);\n\t\tfdlCreateTable.right = new FormAttachment(middle, 0);\n\t\twlCreateTable.setLayoutData(fdlCreateTable);\n\t\twCreateTable=new Button(shell, SWT.CHECK);\n        wCreateTable.setToolTipText(Messages.getString(\"AccessOutputDialog.CreateTable.Tooltip\"));\n \t\tprops.setLook(wCreateTable);\n\t\tfdCreateTable=new FormData();\n\t\tfdCreateTable.left  = new FormAttachment(middle, margin);\n\t\tfdCreateTable.top   = new FormAttachment(wTablename, margin);\n\t\tfdCreateTable.right = new FormAttachment(100, 0);\n\t\twCreateTable.setLayoutData(fdCreateTable);\n\t\twCreateTable.addSelectionListener(lsSelMod);\n        \n        // The commit size...\n        wlCommitSize=new Label(shell, SWT.RIGHT);\n        wlCommitSize.setText(Messages.getString(\"AccessOutputDialog.CommitSize.Label\"));\n        props.setLook(wlCommitSize);\n        fdlCommitSize=new FormData();\n        fdlCommitSize.left = new FormAttachment(0, 0);\n        fdlCommitSize.top  = new FormAttachment(wCreateTable, margin);\n        fdlCommitSize.right= new FormAttachment(middle, 0);\n        wlCommitSize.setLayoutData(fdlCommitSize);\n\n        wCommitSize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wCommitSize.setToolTipText(Messages.getString(\"AccessOutputDialog.CommitSize.Tooltip\"));\n        props.setLook(wCommitSize);\n        fdCommitSize=new FormData();\n        fdCommitSize.left = new FormAttachment(middle, margin);\n        fdCommitSize.right= new FormAttachment(100, 0);\n        fdCommitSize.top  = new FormAttachment(wCreateTable, margin);\n        wCommitSize.setLayoutData(fdCommitSize);\r\n        \r\n\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(shell, SWT.RIGHT);\r\n\t\twlAddToResult.setText(Messages.getString(\"AccessOutputMeta.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wCommitSize, 2*margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(shell, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(Messages.getString(\"AccessOutputMeta.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wCommitSize, 2*margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\n\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTablename.addSelectionListener( lsDef );\n\t\t\n\t\twbbTablename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n        \n        // Listen to the Browse... button\n        wbbFilename.addSelectionListener\n        (\n            new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e) \n                {\n                    FileDialog dialog = new FileDialog(shell, SWT.OPEN);\n                    dialog.setFilterExtensions(new String[] {\"*.mdb;*.MDB\", \"*\"});\n\n                    if (!Const.isEmpty(wFilename.getText()))\n                    {\n                        String fname = transMeta.environmentSubstitute(wFilename.getText());\n                        dialog.setFileName( fname );\n                    }\n                    \n                    dialog.setFilterNames(new String[] {Messages.getString(\"AccessOutputDialog.FileType.AccessFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n                    \n                    if (dialog.open()!=null)\n                    {\n                        String str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n                        wFilename.setText(str);\n                    }\n                }\n            }\n        );\n\n        \n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(AccessOutputMeta info)\n\t{\n        info.setFilename( wFilename.getText() );\n\t\tinfo.setTablename( wTablename.getText() );\n        info.setFileCreated( wCreateFile.getSelection() );\n\t\tinfo.setTableCreated( wCreateTable.getSelection() );\n        info.setCommitSize( Const.toInt(wCommitSize.getText(), -1) );\n\t}","id":40516,"modified_method":"private void getInfo(AccessOutputMeta info)\n\t{\n        info.setFilename( wFilename.getText() );\n\t\tinfo.setTablename( wTablename.getText() );\n        info.setFileCreated( wCreateFile.getSelection() );\n\t\tinfo.setTableCreated( wCreateTable.getSelection() );\n        info.setCommitSize( Const.toInt(wCommitSize.getText(), -1) );\r\n        info.setAddToResultFiles( wAddToResult.getSelection() );\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\n\t\ttry\n\t\t{\n            filename          =      rep.getStepAttributeString (id_step, \"filename\");\n            tablename         =      rep.getStepAttributeString (id_step, \"table\");\n\t\t\ttableTruncated    =      rep.getStepAttributeBoolean(id_step, \"truncate\"); \n            fileCreated       =      rep.getStepAttributeBoolean(id_step, \"create_file\"); \n            tableCreated      =      rep.getStepAttributeBoolean(id_step, \"create_table\"); \n            commitSize        = (int)rep.getStepAttributeInteger(id_step, \"commit_size\"); \n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":40517,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\n\t\ttry\n\t\t{\n            filename          =      rep.getStepAttributeString (id_step, \"filename\");\n            tablename         =      rep.getStepAttributeString (id_step, \"table\");\n\t\t\ttableTruncated    =      rep.getStepAttributeBoolean(id_step, \"truncate\"); \n            fileCreated       =      rep.getStepAttributeBoolean(id_step, \"create_file\"); \n            tableCreated      =      rep.getStepAttributeBoolean(id_step, \"create_table\"); \n            commitSize        = (int)rep.getStepAttributeInteger(id_step, \"commit_size\"); \r\n            addtoresultfilenames   =      rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException {\n\t\ttry\n\t\t{\n            rep.saveStepAttribute(id_transformation, id_step, \"filename\",        filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"table\",       \t tablename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"truncate\",        tableTruncated);\n            rep.saveStepAttribute(id_transformation, id_step, \"create_file\",     fileCreated);\n            rep.saveStepAttribute(id_transformation, id_step, \"create_table\",    tableCreated);\n            rep.saveStepAttribute(id_transformation, id_step, \"commit_size\",     commitSize);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\t}","id":40518,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException {\n\t\ttry\n\t\t{\n            rep.saveStepAttribute(id_transformation, id_step, \"filename\",        filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"table\",       \t tablename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"truncate\",        tableTruncated);\n            rep.saveStepAttribute(id_transformation, id_step, \"create_file\",     fileCreated);\n            rep.saveStepAttribute(id_transformation, id_step, \"create_table\",    tableCreated);\n            rep.saveStepAttribute(id_transformation, id_step, \"commit_size\",     commitSize);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addtoresultfilenames);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n\t\tStringBuffer retval=new StringBuffer(300);\n\t\t\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\",      filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"table\",         tablename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"truncate\",      tableTruncated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"create_file\",   fileCreated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"create_table\",  tableCreated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"commit_size\",   commitSize));\n\n\t\treturn retval.toString();\n\t}","id":40519,"modified_method":"public String getXML()\n\t{\n\t\tStringBuffer retval=new StringBuffer(300);\n\t\t\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\",      filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"table\",         tablename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"truncate\",      tableTruncated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"create_file\",   fileCreated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"create_table\",  tableCreated));\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"commit_size\",   commitSize));\r\n        retval.append(\"      \"+XMLHandler.addTagValue(\"add_to_result_filenames\",   addtoresultfilenames));\n\n\t\treturn retval.toString();\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n        fileCreated = true;\n        tableCreated = true;\n        tableTruncated = false;\t\n        commitSize = AccessOutput.COMMIT_SIZE;\n    }","id":40520,"modified_method":"public void setDefault()\n\t{\n        fileCreated = true;\n        tableCreated = true;\n        tableTruncated = false;\t\n        commitSize = AccessOutput.COMMIT_SIZE;\r\n        addtoresultfilenames=true;\n    }","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode, List<DatabaseMeta> databases) throws KettleXMLException {\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\ttablename     = XMLHandler.getTagValue(stepnode, \"table\");\n\t\t\ttableTruncated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"truncate\"));\n            fileCreated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"create_file\"));\n            tableCreated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"create_table\"));\n            commitSize = Const.toInt( XMLHandler.getTagValue(stepnode, \"commit_size\"), AccessOutput.COMMIT_SIZE);\n        }\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":40521,"modified_method":"private void readData(Node stepnode, List<DatabaseMeta> databases) throws KettleXMLException {\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\ttablename     = XMLHandler.getTagValue(stepnode, \"table\");\n\t\t\ttableTruncated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"truncate\"));\n            fileCreated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"create_file\"));\n            tableCreated = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"create_table\"));\n            commitSize = Const.toInt( XMLHandler.getTagValue(stepnode, \"commit_size\"), AccessOutput.COMMIT_SIZE);\r\n            addtoresultfilenames  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_to_result_filenames\"));\r\n\n        }\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"ca6cb3472cb7e795f062c554446f91fd4ca434b6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void openNewFile(String baseFilename) throws KettleException {\r\n    if (baseFilename == null) {\r\n      throw new KettleFileException(BaseMessages.getString(PKG, \"TextFileOutput.Exception.FileNameNotSet\")); //$NON-NLS-1$\r\n    }\r\n\r\n    data.writer = null;\r\n\r\n    ResultFile resultFile = null;\r\n\r\n    String filename = buildFilename(environmentSubstitute(baseFilename), true);\r\n\r\n    try {\r\n      if (meta.isServletOutput()) {\r\n        Writer writer = getTrans().getServletPrintWriter();\r\n        if (Const.isEmpty(meta.getEncoding())) {\r\n          data.writer = new WriterOutputStream(writer);\r\n        } else {\r\n          data.writer = new WriterOutputStream(writer, meta.getEncoding());\r\n        }\r\n        \r\n      } else if (meta.isFileAsCommand()) {\r\n        if (log.isDebug())\r\n          logDebug(\"Spawning external process\");\r\n        if (data.cmdProc != null) {\r\n          logError(\"Previous command not correctly terminated\");\r\n          setErrors(1);\r\n        }\r\n        String cmdstr = environmentSubstitute(meta.getFileName());\r\n        if (Const.getOS().equals(\"Windows 95\")) {\r\n          cmdstr = \"command.com /C \" + cmdstr;\r\n        } else {\r\n          if (Const.getOS().startsWith(\"Windows\")) {\r\n            cmdstr = \"cmd.exe /C \" + cmdstr;\r\n          }\r\n        }\r\n        if (isDetailed())\r\n          logDetailed(\"Starting: \" + cmdstr);\r\n        Runtime r = Runtime.getRuntime();\r\n        data.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n        data.writer = data.cmdProc.getOutputStream();\r\n        StreamLogger stdoutLogger = new StreamLogger(log, data.cmdProc.getInputStream(), \"(stdout)\");\r\n        StreamLogger stderrLogger = new StreamLogger(log, data.cmdProc.getErrorStream(), \"(stderr)\");\r\n        new Thread(stdoutLogger).start();\r\n        new Thread(stderrLogger).start();\r\n      } else {\r\n\r\n        // Check for parent folder\r\n        createParentFolder(filename);\r\n\r\n        // Add this to the result file names...\r\n        resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename, getTransMeta()), getTransMeta().getName(), getStepname());\r\n        resultFile.setComment(\"This file was created with a text file output step\");\r\n        addResultFile(resultFile);\r\n\r\n        OutputStream outputStream;\r\n\r\n        if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE)) {\r\n          if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP)) {\r\n            if (log.isDetailed())\r\n              logDetailed(\"Opening output stream in zipped mode\");\r\n\r\n            if (checkPreviouslyOpened(filename)) {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n            } else {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n            }\r\n            data.zip = new ZipOutputStream(data.fos);\r\n            File entry = new File(filename);\r\n            ZipEntry zipentry = new ZipEntry(entry.getName());\r\n            zipentry.setComment(\"Compressed by Kettle\");\r\n            data.zip.putNextEntry(zipentry);\r\n            outputStream = data.zip;\r\n          } else if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP)) {\r\n            if (log.isDetailed())\r\n              logDetailed(\"Opening output stream in gzipped mode\");\r\n            if (checkPreviouslyOpened(filename)) {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n            } else {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n            }\r\n            data.gzip = new GZIPOutputStream(data.fos);\r\n            outputStream = data.gzip;\r\n          } else {\r\n            throw new KettleFileException(\"No compression method specified!\");\r\n          }\r\n        } else {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in nocompress mode\");\r\n          if (checkPreviouslyOpened(filename)) {\r\n            data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n          } else {\r\n            data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n          }\r\n          outputStream = data.fos;\r\n        }\r\n\r\n        if (!Const.isEmpty(meta.getEncoding())) {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in encoding: \" + meta.getEncoding());\r\n          data.writer = new BufferedOutputStream(outputStream, 5000);\r\n        } else {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in default encoding\");\r\n          data.writer = new BufferedOutputStream(outputStream, 5000);\r\n        }\r\n\r\n        if (log.isDetailed())\r\n          logDetailed(\"Opened new file with name [\" + filename + \"]\");\r\n      }\r\n    } catch (Exception e) {\r\n      throw new KettleException(\"Error opening new file : \" + e.toString());\r\n    }\r\n    // System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n    data.splitnr++;\r\n\r\n    if (resultFile != null && meta.isAddToResultFiles()) {\r\n      // Add this to the result file names...\r\n      addResultFile(resultFile);\r\n    }\r\n  }","id":40522,"modified_method":"public void openNewFile(String baseFilename) throws KettleException {\r\n    if (baseFilename == null) {\r\n      throw new KettleFileException(BaseMessages.getString(PKG, \"TextFileOutput.Exception.FileNameNotSet\")); //$NON-NLS-1$\r\n    }\r\n\r\n    data.writer = null;\r\n\r\n    String filename = buildFilename(environmentSubstitute(baseFilename), true);\r\n\r\n    try {\r\n      if (meta.isServletOutput()) {\r\n        Writer writer = getTrans().getServletPrintWriter();\r\n        if (Const.isEmpty(meta.getEncoding())) {\r\n          data.writer = new WriterOutputStream(writer);\r\n        } else {\r\n          data.writer = new WriterOutputStream(writer, meta.getEncoding());\r\n        }\r\n        \r\n      } else if (meta.isFileAsCommand()) {\r\n        if (log.isDebug())\r\n          logDebug(\"Spawning external process\");\r\n        if (data.cmdProc != null) {\r\n          logError(\"Previous command not correctly terminated\");\r\n          setErrors(1);\r\n        }\r\n        String cmdstr = environmentSubstitute(meta.getFileName());\r\n        if (Const.getOS().equals(\"Windows 95\")) {\r\n          cmdstr = \"command.com /C \" + cmdstr;\r\n        } else {\r\n          if (Const.getOS().startsWith(\"Windows\")) {\r\n            cmdstr = \"cmd.exe /C \" + cmdstr;\r\n          }\r\n        }\r\n        if (isDetailed())\r\n          logDetailed(\"Starting: \" + cmdstr);\r\n        Runtime r = Runtime.getRuntime();\r\n        data.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n        data.writer = data.cmdProc.getOutputStream();\r\n        StreamLogger stdoutLogger = new StreamLogger(log, data.cmdProc.getInputStream(), \"(stdout)\");\r\n        StreamLogger stderrLogger = new StreamLogger(log, data.cmdProc.getErrorStream(), \"(stderr)\");\r\n        new Thread(stdoutLogger).start();\r\n        new Thread(stderrLogger).start();\r\n      } else {\r\n\r\n        // Check for parent folder\r\n        createParentFolder(filename);\r\n\r\n        OutputStream outputStream;\r\n\r\n        if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE)) {\r\n          if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP)) {\r\n            if (log.isDetailed())\r\n              logDetailed(\"Opening output stream in zipped mode\");\r\n\r\n            if (checkPreviouslyOpened(filename)) {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n            } else {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n            }\r\n            data.zip = new ZipOutputStream(data.fos);\r\n            File entry = new File(filename);\r\n            ZipEntry zipentry = new ZipEntry(entry.getName());\r\n            zipentry.setComment(\"Compressed by Kettle\");\r\n            data.zip.putNextEntry(zipentry);\r\n            outputStream = data.zip;\r\n          } else if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP)) {\r\n            if (log.isDetailed())\r\n              logDetailed(\"Opening output stream in gzipped mode\");\r\n            if (checkPreviouslyOpened(filename)) {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n            } else {\r\n              data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n            }\r\n            data.gzip = new GZIPOutputStream(data.fos);\r\n            outputStream = data.gzip;\r\n          } else {\r\n            throw new KettleFileException(\"No compression method specified!\");\r\n          }\r\n        } else {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in nocompress mode\");\r\n          if (checkPreviouslyOpened(filename)) {\r\n            data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), true);\r\n          } else {\r\n            data.fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n          }\r\n          outputStream = data.fos;\r\n        }\r\n\r\n        if (!Const.isEmpty(meta.getEncoding())) {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in encoding: \" + meta.getEncoding());\r\n          data.writer = new BufferedOutputStream(outputStream, 5000);\r\n        } else {\r\n          if (log.isDetailed())\r\n            logDetailed(\"Opening output stream in default encoding\");\r\n          data.writer = new BufferedOutputStream(outputStream, 5000);\r\n        }\r\n\r\n        if (log.isDetailed())\r\n          logDetailed(\"Opened new file with name [\" + filename + \"]\");\r\n      }\r\n    } catch (Exception e) {\r\n      throw new KettleException(\"Error opening new file : \" + e.toString());\r\n    }\r\n\r\n    data.splitnr++;\r\n\r\n    if (meta.isAddToResultFiles()) {\r\n      // Add this to the result file names...\r\n      ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename, getTransMeta()), getTransMeta().getName(), getStepname());\r\n      if(resultFile!=null) {\r\n    \t  resultFile.setComment(BaseMessages.getString(PKG, \"TextFileOutput.AddResultFile\"));\r\n    \t  addResultFile(resultFile);\r\n      }\r\n    }\r\n  }","commit_id":"d624afb2a3026c7fb1923071aadfc51780b61b45","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Nullable\n    protected static MemberSignature getCallableSignature(\n            @NotNull ProtoBuf.Callable proto,\n            @NotNull NameResolver nameResolver,\n            @NotNull AnnotatedCallableKind kind\n    ) {\n        SignatureDeserializer deserializer = new SignatureDeserializer(nameResolver);\n        switch (kind) {\n            case FUNCTION:\n                if (proto.hasExtension(JavaProtoBuf.methodSignature)) {\n                    return MemberSignature.fromAsmMethod(deserializer.methodSignature(proto.getExtension(JavaProtoBuf.methodSignature)));\n                }\n                break;\n            case PROPERTY_GETTER:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    return MemberSignature.fromAsmMethod(deserializer.methodSignature(proto.getExtension(JavaProtoBuf.propertySignature).getGetter()));\n                }\n                break;\n            case PROPERTY_SETTER:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    return MemberSignature.fromAsmMethod(deserializer.methodSignature(proto.getExtension(JavaProtoBuf.propertySignature).getSetter()));\n                }\n                break;\n            case PROPERTY:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    JavaProtoBuf.JavaPropertySignature propertySignature = proto.getExtension(JavaProtoBuf.propertySignature);\n\n                    if (propertySignature.hasField()) {\n                        JavaProtoBuf.JavaFieldSignature field = propertySignature.getField();\n                        String type = deserializer.typeDescriptor(field.getType());\n                        Name name = nameResolver.getName(field.getName());\n                        return MemberSignature.fromFieldNameAndDesc(name, type);\n                    }\n                    else if (propertySignature.hasSyntheticMethod()) {\n                        return MemberSignature.fromAsmMethod(deserializer.methodSignature(propertySignature.getSyntheticMethod()));\n                    }\n                }\n                break;\n        }\n        return null;\n    }","id":40523,"modified_method":"@Nullable\n    protected static MemberSignature getCallableSignature(\n            @NotNull ProtoBuf.Callable proto,\n            @NotNull NameResolver nameResolver,\n            @NotNull AnnotatedCallableKind kind\n    ) {\n        SignatureDeserializer deserializer = new SignatureDeserializer(nameResolver);\n        switch (kind) {\n            case FUNCTION:\n                if (proto.hasExtension(JavaProtoBuf.methodSignature)) {\n                    return deserializer.methodSignature(proto.getExtension(JavaProtoBuf.methodSignature));\n                }\n                break;\n            case PROPERTY_GETTER:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    return deserializer.methodSignature(proto.getExtension(JavaProtoBuf.propertySignature).getGetter());\n                }\n                break;\n            case PROPERTY_SETTER:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    return deserializer.methodSignature(proto.getExtension(JavaProtoBuf.propertySignature).getSetter());\n                }\n                break;\n            case PROPERTY:\n                if (proto.hasExtension(JavaProtoBuf.propertySignature)) {\n                    JavaProtoBuf.JavaPropertySignature propertySignature = proto.getExtension(JavaProtoBuf.propertySignature);\n\n                    if (propertySignature.hasField()) {\n                        JavaProtoBuf.JavaFieldSignature field = propertySignature.getField();\n                        String type = deserializer.typeDescriptor(field.getType());\n                        Name name = nameResolver.getName(field.getName());\n                        return MemberSignature.fromFieldNameAndDesc(name, type);\n                    }\n                    else if (propertySignature.hasSyntheticMethod()) {\n                        return deserializer.methodSignature(propertySignature.getSyntheticMethod());\n                    }\n                }\n                break;\n        }\n        return null;\n    }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        public static MemberSignature fromMethodNameAndDesc(@NotNull Name name, @NotNull String desc) {\n            return new MemberSignature(name.asString() + desc);\n        }","id":40524,"modified_method":"@NotNull\n        public static MemberSignature fromMethodNameAndDesc(@NotNull String nameAndDesc) {\n            return new MemberSignature(nameAndDesc);\n        }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private Storage loadAnnotationsAndInitializers(@NotNull KotlinJvmBinaryClass kotlinClass) throws IOException {\n        final Map<MemberSignature, List<AnnotationDescriptor>> memberAnnotations = new HashMap<MemberSignature, List<AnnotationDescriptor>>();\n        final Map<MemberSignature, CompileTimeConstant<?>> propertyConstants = new HashMap<MemberSignature, CompileTimeConstant<?>>();\n\n        kotlinClass.visitMembers(new KotlinJvmBinaryClass.MemberVisitor() {\n            @Nullable\n            @Override\n            public KotlinJvmBinaryClass.MethodAnnotationVisitor visitMethod(@NotNull Name name, @NotNull String desc) {\n                return new AnnotationVisitorForMethod(MemberSignature.fromMethodNameAndDesc(name, desc));\n            }\n\n            @Nullable\n            @Override\n            public KotlinJvmBinaryClass.AnnotationVisitor visitField(@NotNull Name name, @NotNull String desc, @Nullable Object initializer) {\n                MemberSignature signature = MemberSignature.fromFieldNameAndDesc(name, desc);\n                if (initializer != null) {\n                    propertyConstants.put(signature, ConstantsPackage.createCompileTimeConstant(\n                            initializer, /* canBeUsedInAnnotation */ true, /* isPureIntConstant */ true, /* expectedType */ null));\n                }\n                return new MemberAnnotationVisitor(signature);\n            }\n\n            class AnnotationVisitorForMethod extends MemberAnnotationVisitor implements KotlinJvmBinaryClass.MethodAnnotationVisitor {\n                public AnnotationVisitorForMethod(@NotNull MemberSignature signature) {\n                    super(signature);\n                }\n\n                @Nullable\n                @Override\n                public KotlinJvmBinaryClass.AnnotationArgumentVisitor visitParameterAnnotation(int index, @NotNull JvmClassName className) {\n                    MemberSignature paramSignature = MemberSignature.fromMethodSignatureAndParameterIndex(signature, index);\n                    List<AnnotationDescriptor> result = memberAnnotations.get(paramSignature);\n                    if (result == null) {\n                        result = new ArrayList<AnnotationDescriptor>();\n                        memberAnnotations.put(paramSignature, result);\n                    }\n                    return AnnotationDescriptorDeserializer.resolveAnnotation(className, result, classResolver);\n                }\n            }\n\n            class MemberAnnotationVisitor implements KotlinJvmBinaryClass.AnnotationVisitor {\n                private final List<AnnotationDescriptor> result = new ArrayList<AnnotationDescriptor>();\n                protected final MemberSignature signature;\n\n                public MemberAnnotationVisitor(@NotNull MemberSignature signature) {\n                    this.signature = signature;\n                }\n\n                @Nullable\n                @Override\n                public KotlinJvmBinaryClass.AnnotationArgumentVisitor visitAnnotation(@NotNull JvmClassName className) {\n                    return AnnotationDescriptorDeserializer.resolveAnnotation(className, result, classResolver);\n                }\n\n                @Override\n                public void visitEnd() {\n                    if (!result.isEmpty()) {\n                        memberAnnotations.put(signature, result);\n                    }\n                }\n            }\n        });\n\n        return new Storage(memberAnnotations, propertyConstants);\n    }","id":40525,"modified_method":"@NotNull\n    private Storage loadAnnotationsAndInitializers(@NotNull KotlinJvmBinaryClass kotlinClass) throws IOException {\n        final Map<MemberSignature, List<AnnotationDescriptor>> memberAnnotations = new HashMap<MemberSignature, List<AnnotationDescriptor>>();\n        final Map<MemberSignature, CompileTimeConstant<?>> propertyConstants = new HashMap<MemberSignature, CompileTimeConstant<?>>();\n\n        kotlinClass.visitMembers(new KotlinJvmBinaryClass.MemberVisitor() {\n            @Nullable\n            @Override\n            public KotlinJvmBinaryClass.MethodAnnotationVisitor visitMethod(@NotNull Name name, @NotNull String desc) {\n                return new AnnotationVisitorForMethod(MemberSignature.fromMethodNameAndDesc(name.asString() + desc));\n            }\n\n            @Nullable\n            @Override\n            public KotlinJvmBinaryClass.AnnotationVisitor visitField(@NotNull Name name, @NotNull String desc, @Nullable Object initializer) {\n                MemberSignature signature = MemberSignature.fromFieldNameAndDesc(name, desc);\n                if (initializer != null) {\n                    propertyConstants.put(signature, ConstantsPackage.createCompileTimeConstant(\n                            initializer, /* canBeUsedInAnnotation */ true, /* isPureIntConstant */ true, /* expectedType */ null));\n                }\n                return new MemberAnnotationVisitor(signature);\n            }\n\n            class AnnotationVisitorForMethod extends MemberAnnotationVisitor implements KotlinJvmBinaryClass.MethodAnnotationVisitor {\n                public AnnotationVisitorForMethod(@NotNull MemberSignature signature) {\n                    super(signature);\n                }\n\n                @Nullable\n                @Override\n                public KotlinJvmBinaryClass.AnnotationArgumentVisitor visitParameterAnnotation(int index, @NotNull JvmClassName className) {\n                    MemberSignature paramSignature = MemberSignature.fromMethodSignatureAndParameterIndex(signature, index);\n                    List<AnnotationDescriptor> result = memberAnnotations.get(paramSignature);\n                    if (result == null) {\n                        result = new ArrayList<AnnotationDescriptor>();\n                        memberAnnotations.put(paramSignature, result);\n                    }\n                    return AnnotationDescriptorDeserializer.resolveAnnotation(className, result, classResolver);\n                }\n            }\n\n            class MemberAnnotationVisitor implements KotlinJvmBinaryClass.AnnotationVisitor {\n                private final List<AnnotationDescriptor> result = new ArrayList<AnnotationDescriptor>();\n                protected final MemberSignature signature;\n\n                public MemberAnnotationVisitor(@NotNull MemberSignature signature) {\n                    this.signature = signature;\n                }\n\n                @Nullable\n                @Override\n                public KotlinJvmBinaryClass.AnnotationArgumentVisitor visitAnnotation(@NotNull JvmClassName className) {\n                    return AnnotationDescriptorDeserializer.resolveAnnotation(className, result, classResolver);\n                }\n\n                @Override\n                public void visitEnd() {\n                    if (!result.isEmpty()) {\n                        memberAnnotations.put(signature, result);\n                    }\n                }\n            }\n        });\n\n        return new Storage(memberAnnotations, propertyConstants);\n    }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        public JavaProtoBuf.JavaPropertySignature copyPropertySignature(\n                @NotNull JavaProtoBuf.JavaPropertySignature signature,\n                @NotNull NameResolver nameResolver\n        ) {\n            Type fieldType;\n            String fieldName;\n            boolean isStaticInOuter;\n            SignatureDeserializer signatureDeserializer = new SignatureDeserializer(nameResolver);\n            if (signature.hasField()) {\n                JavaProtoBuf.JavaFieldSignature field = signature.getField();\n                fieldType = Type.getType(signatureDeserializer.typeDescriptor(field.getType()));\n                fieldName = nameResolver.getName(field.getName()).asString();\n                isStaticInOuter = field.getIsStaticInOuter();\n            }\n            else {\n                fieldType = null;\n                fieldName = null;\n                isStaticInOuter = false;\n            }\n\n            Method syntheticMethod = signature.hasSyntheticMethod()\n                    ? signatureDeserializer.methodSignature(signature.getSyntheticMethod())\n                    : null;\n\n            Method getter = signature.hasGetter() ? signatureDeserializer.methodSignature(signature.getGetter()) : null;\n            Method setter = signature.hasSetter() ? signatureDeserializer.methodSignature(signature.getSetter()) : null;\n\n            return propertySignature(fieldType, fieldName, isStaticInOuter, syntheticMethod, getter, setter);\n        }","id":40526,"modified_method":"@NotNull\n        public JavaProtoBuf.JavaPropertySignature copyPropertySignature(\n                @NotNull JavaProtoBuf.JavaPropertySignature signature,\n                @NotNull NameResolver nameResolver\n        ) {\n            Type fieldType;\n            String fieldName;\n            boolean isStaticInOuter;\n            SignatureDeserializer signatureDeserializer = new SignatureDeserializer(nameResolver);\n            if (signature.hasField()) {\n                JavaProtoBuf.JavaFieldSignature field = signature.getField();\n                fieldType = Type.getType(signatureDeserializer.typeDescriptor(field.getType()));\n                fieldName = nameResolver.getName(field.getName()).asString();\n                isStaticInOuter = field.getIsStaticInOuter();\n            }\n            else {\n                fieldType = null;\n                fieldName = null;\n                isStaticInOuter = false;\n            }\n\n            Method syntheticMethod = signature.hasSyntheticMethod()\n                    ? getAsmMethod(signatureDeserializer.methodSignatureString(signature.getSyntheticMethod()))\n                    : null;\n\n            Method getter = signature.hasGetter() ? getAsmMethod(signatureDeserializer.methodSignatureString(signature.getGetter())) : null;\n            Method setter = signature.hasSetter() ? getAsmMethod(signatureDeserializer.methodSignatureString(signature.getSetter())) : null;\n\n            return propertySignature(fieldType, fieldName, isStaticInOuter, syntheticMethod, getter, setter);\n        }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        public JavaProtoBuf.JavaMethodSignature copyMethodSignature(\n                @NotNull JavaProtoBuf.JavaMethodSignature signature,\n                @NotNull NameResolver nameResolver\n        ) {\n            Method method = new SignatureDeserializer(nameResolver).methodSignature(signature);\n            return methodSignature(method);\n        }","id":40527,"modified_method":"@NotNull\n        public JavaProtoBuf.JavaMethodSignature copyMethodSignature(\n                @NotNull JavaProtoBuf.JavaMethodSignature signature,\n                @NotNull NameResolver nameResolver\n        ) {\n            String method = new SignatureDeserializer(nameResolver).methodSignatureString(signature);\n            return methodSignature(getAsmMethod(method));\n        }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public Method methodSignature(@NotNull JavaProtoBuf.JavaMethodSignature signature) {\n        Name name = nameResolver.getName(signature.getName());\n\n        StringBuilder sb = new StringBuilder();\n        sb.append('(');\n        for (int i = 0, length = signature.getParameterTypeCount(); i < length; i++) {\n            typeDescriptor(signature.getParameterType(i), sb);\n        }\n        sb.append(')');\n        typeDescriptor(signature.getReturnType(), sb);\n\n        return new Method(name.asString(), sb.toString());\n    }","id":40528,"modified_method":"@NotNull\n    public DescriptorDeserializersStorage.MemberSignature methodSignature(@NotNull JavaProtoBuf.JavaMethodSignature signature) {\n        return DescriptorDeserializersStorage.MemberSignature.fromMethodNameAndDesc(methodSignatureString(signature));\n    }","commit_id":"a44f0c2f2d59e799743ac4658aaed74a79126019","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\r\n     * Stop the handler instance. This method release the used EventAdmin\r\n     * service (if any).\r\n     */\r\n    // @Override\r\n    public void stop() {\r\n        info(LOG_PREFIX + \"STOPPING\");\r\n\r\n        // Unregister service\r\n        if (m_ea != null) {\r\n            m_ea = null;\r\n            m_context.ungetService(m_eaReference);\r\n            info(LOG_PREFIX + \"EventAdmin service released\");\r\n        }\r\n\r\n        info(LOG_PREFIX + \"STOPPED\");\r\n    }","id":40529,"modified_method":"/**\n     * Stop the handler instance.\n     * \n     * This method does nothing.\n     */\n    // @Override\n    public void stop() {\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Start the handler instance. This method tries to get an initial reference\r\n     * of the EventAdmin service.\r\n     */\r\n    // @Override\r\n    public void start() {\r\n        info(LOG_PREFIX + \"STARTING\");\r\n\r\n        // Look for the EventAdmin service at startup\r\n        m_context = m_manager.getContext();\r\n        m_eaReference = m_context.getServiceReference(EventAdmin.class\r\n                .getName());\r\n        if (m_eaReference != null) {\r\n            m_ea = (EventAdmin) m_context.getService(m_eaReference);\r\n            if (m_ea != null) {\r\n                info(LOG_PREFIX + \"EventAdmin service caught\");\r\n            }\r\n        }\r\n\r\n        // Update handler validity\r\n        setValidity(m_ea != null);\r\n\r\n        // Register service listener for EventAdmin services\r\n        try {\r\n            m_context.addServiceListener(this, \"(OBJECTCLASS=\"\r\n                    + EventAdmin.class.getName() + \")\");\r\n        } catch (InvalidSyntaxException e) {\r\n            error(LOG_PREFIX + \"Cannot register ServiceListener\", e);\r\n        }\r\n        info(LOG_PREFIX + \"STARTED\");\r\n    }","id":40530,"modified_method":"/**\n     * Start the handler instance.\n     * \n     * This method does nothing.\n     */\n    // @Override\n    public void start() {\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Constructor.\r\n     * \r\n     * @param metadata :\r\n     *            component type metadata\r\n     * @param conf :\r\n     *            instance configuration\r\n     * @throws ConfigurationException :\r\n     *             one event publication is not correct\r\n     * @see org.apache.felix.ipojo.Handler#configure(org.apache.felix.ipojo.InstanceManager,\r\n     *      org.apache.felix.ipojo.metadata.Element, java.util.Dictionary)\r\n     */\r\n    // @Override\r\n    public void configure(Element metadata, Dictionary conf)\r\n        throws ConfigurationException {\r\n\r\n        // Store the component manager\r\n        m_manager = getInstanceManager();\r\n\r\n        // Get Metadata publishers\r\n        Element[] publishers = metadata.getElements(\"publisher\", NAMESPACE);\r\n\r\n        if (publishers != null) {\r\n            // then check publishers are well formed and fill the publishers'\r\n            // map\r\n            for (int i = 0; i < publishers.length; i++) {\r\n\r\n                try {\r\n                    // Extract the publisher configuration\r\n                    EventAdminPublisherMetadata publisherMetadata = new EventAdminPublisherMetadata(\r\n                            publishers[i], conf);\r\n                    String name = publisherMetadata.getName();\r\n                    info(LOG_PREFIX + \"configuring publisher \" + name);\r\n\r\n                    // Create the associated Publisher\r\n                    Publisher publisher = new PublisherImpl(this,\r\n                            publisherMetadata.getTopics(), publisherMetadata\r\n                                    .isSynchronous(), publisherMetadata\r\n                                    .getDataKey(), m_manager.getInstanceName());\r\n\r\n                    // Check field existence and type\r\n                    String field = publisherMetadata.getField();\r\n                    FieldMetadata fieldMetadata = getPojoMetadata().getField(\r\n                            publisherMetadata.getField(),\r\n                            Publisher.class.getName());\r\n                    if (fieldMetadata == null) {\r\n                        throw new ConfigurationException(\r\n                                \"Field not found in the component : \"\r\n                                        + Publisher.class.getName() + \" \"\r\n                                        + field);\r\n                    }\r\n\r\n                    // Insert in the publisher tables.\r\n                    Object old;\r\n                    if ((old = m_publishersByName.put(name, publisher)) != null) {\r\n                        m_publishersByName.put(name, old);\r\n                        throw new ConfigurationException(\"The publisher \"\r\n                                + name + \"already exists\");\r\n                    }\r\n                    if ((old = m_publishersByField.put(field, publisher)) != null) {\r\n                        m_publishersByField.put(field, old);\r\n                        m_publishersByName.remove(name);\r\n                        throw new ConfigurationException(\"The field \" + field\r\n                                + \" is already associated to a publisher\");\r\n                    }\r\n\r\n                    // Register the callback that return the publisher\r\n                    // reference when the specified field is read by the\r\n                    // POJO.\r\n                    m_manager.register(fieldMetadata, this);\r\n\r\n                } catch (Exception e) {\r\n                    // Ignore invalid publishers\r\n                    warn(LOG_PREFIX\r\n                            + \"Ignoring publisher : Error in configuration\", e);\r\n                }\r\n            }\r\n        } else {\r\n            info(LOG_PREFIX + \"no publisher detected !\");\r\n        }\r\n    }","id":40531,"modified_method":"/**\n     * Constructor.\n     * \n     * @param metadata :\n     *            component type metadata\n     * @param conf :\n     *            instance configuration\n     * @throws ConfigurationException :\n     *             one event publication is not correct\n     * @see org.apache.felix.ipojo.Handler#configure(org.apache.felix.ipojo.InstanceManager,\n     *      org.apache.felix.ipojo.metadata.Element, java.util.Dictionary)\n     */\n    // @Override\n    public void configure(Element metadata, Dictionary conf)\n        throws ConfigurationException {\n\n        // Store the component manager\n        m_manager = getInstanceManager();\n\n        // Get the topics instance configuration\n        Dictionary instanceTopics = (Dictionary) conf.get(TOPICS_PROPERTY);\n\n        // Get Metadata publishers\n        Element[] publishers = metadata.getElements(\"publisher\", NAMESPACE);\n\n        if (publishers != null) {\n            // then check publishers are well formed and fill the publishers'\n            // map\n            for (int i = 0; i < publishers.length; i++) {\n\n                // Extract the publisher configuration\n                EventAdminPublisherMetadata publisherMetadata = new EventAdminPublisherMetadata(\n                        publishers[i]);\n                String name = publisherMetadata.getName();\n                info(LOG_PREFIX + \"configuring publisher \" + name);\n\n                // Get the topic instance configuration if redefined\n                String topicsString = (instanceTopics != null) ? (String) instanceTopics\n                        .get(name)\n                        : null;\n                if (topicsString != null) {\n                    publisherMetadata.setTopics(topicsString);\n                }\n\n                // Check the publisher is correctly configured\n                publisherMetadata.check();\n\n                // Create the associated Publisher and insert it in the\n                // publisher map\n                Publisher publisher = new PublisherImpl(this, publisherMetadata\n                        .getTopics(), publisherMetadata.isSynchronous(),\n                        publisherMetadata.getDataKey(), m_manager\n                                .getInstanceName());\n                m_publishersByField\n                        .put(publisherMetadata.getField(), publisher);\n\n                // Register the callback that return the publisher\n                // reference when the specified field is read by the\n                // POJO.\n                FieldMetadata fieldMetadata = getPojoMetadata()\n                        .getField(publisherMetadata.getField(),\n                                Publisher.class.getName());\n                m_manager.register(fieldMetadata, this);\n            }\n        } else {\n            info(LOG_PREFIX + \"no publisher to configure\");\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Initialize the component type.\r\n     * \r\n     * @param cd :\r\n     *            component type description to populate.\r\n     * @param metadata :\r\n     *            component type metadata.\r\n     * @throws ConfigurationException :\r\n     *             metadata are incorrect.\r\n     * @see org.apache.felix.ipojo.Handler#initializeComponentFactory(org.apache.felix.ipojo.architecture.ComponentDescription,\r\n     *      org.apache.felix.ipojo.metadata.Element)\r\n     */\r\n    // @Override\r\n    public void initializeComponentFactory(ComponentTypeDescription cd,\r\n            Element metadata)\r\n        throws ConfigurationException {\r\n\r\n        // Update the current component description\r\n        Dictionary dict = new Properties();\r\n        cd.addProperty(new PropertyDescription(TOPICS_PROPERTY,\r\n                Dictionary.class.getName(), dict.toString()));\r\n    }","id":40532,"modified_method":"/**\n     * Initialize the component type.\n     * \n     * @param cd :\n     *            component type description to populate.\n     * @param metadata :\n     *            component type metadata.\n     * @throws ConfigurationException :\n     *             metadata are incorrect.\n     * @see org.apache.felix.ipojo.Handler#initializeComponentFactory(org.apache.felix.ipojo.architecture.ComponentDescription,\n     *      org.apache.felix.ipojo.metadata.Element)\n     */\n    // @Override\n    public void initializeComponentFactory(ComponentTypeDescription cd,\n            Element metadata)\n        throws ConfigurationException {\n\n        // Update the current component description\n        Dictionary dict = new Properties();\n        cd.addProperty(new PropertyDescription(TOPICS_PROPERTY,\n                Dictionary.class.getName(), dict.toString()));\n\n        // Get Metadata publishers\n        Element[] publishers = metadata.getElements(\"publisher\", NAMESPACE);\n        if (publishers != null) {\n\n            // Maps used to check name and field are unique\n            Set nameSet = new HashSet();\n            Set fieldSet = new HashSet();\n\n            // Check all publishers are well formed\n            for (int i = 0; i < publishers.length; i++) {\n\n                // Check the publisher configuration is correct by creating an\n                // unused publisher metadata\n                EventAdminPublisherMetadata publisherMetadata = new EventAdminPublisherMetadata(\n                        publishers[i]);\n                String name = publisherMetadata.getName();\n                info(LOG_PREFIX + \"checking publisher \" + name);\n\n                // Check field existence and type\n                String field = publisherMetadata.getField();\n                FieldMetadata fieldMetadata = getPojoMetadata()\n                        .getField(publisherMetadata.getField(),\n                                Publisher.class.getName());\n                if (fieldMetadata == null) {\n                    throw new ConfigurationException(\n                            \"Field not found in the component : \"\n                                    + Publisher.class.getName() + \" \" + field);\n                }\n\n                // Check name and field are unique\n                if (nameSet.contains(name)) {\n                    throw new ConfigurationException(\n                            \"A publisher with the same name already exists : \"\n                                    + name);\n                } else if (fieldSet.contains(field)) {\n                    throw new ConfigurationException(\"The field \" + field\n                            + \" is already associated to a publisher\");\n                }\n                nameSet.add(name);\n                fieldSet.add(field);\n            }\n        } else {\n            info(LOG_PREFIX + \"no publisher to check\");\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Construct a publisher from its metadata description.\r\n     * \r\n     * @param publisher :\r\n     *            publisher metadata description.\r\n     * @param instanceConf :\r\n     *            the configuration of the component instance\r\n     * @throws ConfigurationException\r\n     *             if the configuration of the component or the instance is\r\n     *             invalid.\r\n     */\r\n    public EventAdminPublisherMetadata(Element publisher,\r\n            Dictionary instanceConf) throws ConfigurationException {\r\n\r\n        /**\r\n         * Setup required attributes\r\n         */\r\n\r\n        // NAME_ATTRIBUTE\r\n        if (publisher.containsAttribute(NAME_ATTRIBUTE)) {\r\n            m_name = publisher.getAttribute(NAME_ATTRIBUTE);\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component configuration : \"\r\n                            + NAME_ATTRIBUTE);\r\n        }\r\n\r\n        // FIELD_ATTRIBUTE\r\n        if (publisher.containsAttribute(FIELD_ATTRIBUTE)) {\r\n            m_field = publisher.getAttribute(FIELD_ATTRIBUTE);\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component configuration : \"\r\n                            + FIELD_ATTRIBUTE);\r\n        }\r\n\r\n        // TOPICS_ATTRIBUTE\r\n        String topicsString = null;\r\n        if (publisher.containsAttribute(TOPICS_ATTRIBUTE)) {\r\n            topicsString = publisher.getAttribute(TOPICS_ATTRIBUTE);\r\n        }\r\n        // Check TOPICS_PROPERTY in the instance configuration\r\n        Dictionary instanceTopics = (Dictionary) instanceConf\r\n                .get(EventAdminSubscriberHandler.TOPICS_PROPERTY);\r\n        if (instanceTopics != null) {\r\n            Enumeration e = instanceTopics.keys();\r\n            while (e.hasMoreElements()) {\r\n                String myName = (String) e.nextElement(); // name\r\n                if (m_name.equals(myName)) {\r\n                    topicsString = (String) instanceTopics.get(myName);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (topicsString != null) {\r\n            m_topics = ParseUtils.split(topicsString, \",\");\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component or instance configuration : \"\r\n                            + TOPICS_ATTRIBUTE);\r\n        }\r\n\r\n        /**\r\n         * Setup optional attributes\r\n         */\r\n        // SYNCHRONOUS_ATTRIBUTE\r\n        if (publisher.containsAttribute(SYNCHRONOUS_ATTRIBUTE)) {\r\n            m_synchronous = \"true\".equalsIgnoreCase(publisher\r\n                    .getAttribute(SYNCHRONOUS_ATTRIBUTE));\r\n        } else {\r\n            m_synchronous = DEFAULT_SYNCHRONOUS_VALUE;\r\n        }\r\n\r\n        // DATA_KEY_ATTRIBUTE\r\n        if (publisher.containsAttribute(DATA_KEY_ATTRIBUTE)) {\r\n            m_dataKey = publisher.getAttribute(DATA_KEY_ATTRIBUTE);\r\n        } else {\r\n            m_dataKey = DEFAULT_DATA_KEY_VALUE;\r\n        }\r\n    }","id":40533,"modified_method":"/**\n     * Construct a publisher from its metadata description.\n     * \n     * @param publisher :\n     *            publisher metadata description.\n     * @throws ConfigurationException\n     *             if the configuration of the component or the instance is\n     *             invalid.\n     */\n    public EventAdminPublisherMetadata(Element publisher)\n        throws ConfigurationException {\n\n        /**\n         * Setup required attributes\n         */\n\n        // NAME_ATTRIBUTE\n        if (publisher.containsAttribute(NAME_ATTRIBUTE)) {\n            m_name = publisher.getAttribute(NAME_ATTRIBUTE);\n        } else {\n            throw new ConfigurationException(\n                    \"Missing required attribute in component configuration : \"\n                            + NAME_ATTRIBUTE);\n        }\n\n        // FIELD_ATTRIBUTE\n        if (publisher.containsAttribute(FIELD_ATTRIBUTE)) {\n            m_field = publisher.getAttribute(FIELD_ATTRIBUTE);\n        } else {\n            throw new ConfigurationException(\n                    \"Missing required attribute in component configuration : \"\n                            + FIELD_ATTRIBUTE);\n        }\n\n        // TOPICS_ATTRIBUTE\n        if (publisher.containsAttribute(TOPICS_ATTRIBUTE)) {\n            m_topics = ParseUtils.split(publisher\n                    .getAttribute(TOPICS_ATTRIBUTE), \",\");\n            // Check each topic is valid\n            Dictionary empty = new Hashtable();\n            for (int i = 0; i < m_topics.length; i++) {\n                String topic = m_topics[i];\n                try {\n                    new Event(topic, empty);\n                } catch (IllegalArgumentException e) {\n                    throw new ConfigurationException(\"Malformed topic : \"\n                            + topic);\n                }\n            }\n\n        } else {\n            m_topics = null;\n            // Nothing to do if TOPICS_ATTRIBUTE is not present as it can be\n            // overridden in the instance configuration.\n        }\n\n        /**\n         * Setup optional attributes\n         */\n\n        // SYNCHRONOUS_ATTRIBUTE\n        if (publisher.containsAttribute(SYNCHRONOUS_ATTRIBUTE)) {\n            m_synchronous = \"true\".equalsIgnoreCase(publisher\n                    .getAttribute(SYNCHRONOUS_ATTRIBUTE));\n        } else {\n            m_synchronous = DEFAULT_SYNCHRONOUS_VALUE;\n        }\n\n        // DATA_KEY_ATTRIBUTE\n        if (publisher.containsAttribute(DATA_KEY_ATTRIBUTE)) {\n            m_dataKey = publisher.getAttribute(DATA_KEY_ATTRIBUTE);\n        } else {\n            m_dataKey = DEFAULT_DATA_KEY_VALUE;\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Constructor.\r\n     * \r\n     * @param metadata :\r\n     *            component type metadata\r\n     * @param conf :\r\n     *            instance configuration\r\n     * @throws ConfigurationException :\r\n     *             one event subscription is not correct\r\n     * @see org.apache.felix.ipojo.Handler#configure(org.apache.felix.ipojo.InstanceManager,\r\n     *      org.apache.felix.ipojo.metadata.Element, java.util.Dictionary)\r\n     */\r\n    // @Override\r\n    public void configure(Element metadata, Dictionary conf)\r\n        throws ConfigurationException {\r\n\r\n        // Store the component manager\r\n        m_manager = getInstanceManager();\r\n\r\n        // Get Metadata subscribers\r\n        Element[] subscribers = metadata.getElements(\"subscriber\", NAMESPACE);\r\n\r\n        if (subscribers != null) {\r\n\r\n            // then check subscribers are well formed and fill the subscriber'\r\n            // map\r\n            for (int i = 0; i < subscribers.length; i++) {\r\n\r\n                try {\r\n                    // Extract the subscriber configuration\r\n                    EventAdminSubscriberMetadata subscriberMetadata = new EventAdminSubscriberMetadata(\r\n                            m_manager, subscribers[i], conf);\r\n                    String subscriberName = subscriberMetadata.getName();\r\n                    info(LOG_PREFIX + \"configuring subscriber \"\r\n                            + subscriberName);\r\n\r\n                    // Determine the callback prototype\r\n                    PojoMetadata pojoMetadata = getFactory().getPojoMetadata();\r\n                    String callbackType;\r\n                    if (subscriberMetadata.getDataKey() == null) {\r\n                        callbackType = Event.class.getName();\r\n                    } else {\r\n                        callbackType = subscriberMetadata.getDataType()\r\n                                .getName();\r\n                    }\r\n\r\n                    // Find the specified callback\r\n                    MethodMetadata methodMetadata = pojoMetadata.getMethod(\r\n                            subscriberMetadata.getCallback(),\r\n                            new String[] { callbackType });\r\n                    if (methodMetadata == null) {\r\n                        throw new ConfigurationException(\r\n                                \"Unable to find callback \"\r\n                                        + subscriberMetadata.getCallback()\r\n                                        + \"(\" + callbackType + \")\");\r\n                    }\r\n                    Callback callback = new Callback(methodMetadata, m_manager);\r\n\r\n                    // Add the subscriber to the subscriber list and\r\n                    // register callback\r\n                    Object old;\r\n                    if ((old = m_subscribersByName.put(subscriberName,\r\n                            subscriberMetadata)) != null) {\r\n                        m_subscribersByName.put(subscriberName, old);\r\n                        throw new ConfigurationException(\"The subscriber \"\r\n                                + subscriberName + \"already exists\");\r\n                    }\r\n                    m_callbacks.put(subscriberName, callback);\r\n\r\n                } catch (Exception e) {\r\n                    // Ignore invalid subscribers\r\n                    warn(LOG_PREFIX\r\n                            + \"Ignoring subscriber : Error in configuration\", e);\r\n                }\r\n            }\r\n        } else {\r\n            info(LOG_PREFIX + \"no subscriber detected !\");\r\n        }\r\n    }","id":40534,"modified_method":"/**\n     * Constructor.\n     * \n     * @param metadata :\n     *            component type metadata\n     * @param conf :\n     *            instance configuration\n     * @throws ConfigurationException :\n     *             one event subscription is not correct\n     * @see org.apache.felix.ipojo.Handler#configure(org.apache.felix.ipojo.InstanceManager,\n     *      org.apache.felix.ipojo.metadata.Element, java.util.Dictionary)\n     */\n    // @Override\n    public void configure(Element metadata, Dictionary conf)\n        throws ConfigurationException {\n\n        // Store the component manager\n        m_manager = getInstanceManager();\n\n        // Get the topics and filter instance configuration\n        Dictionary instanceTopics = (Dictionary) conf.get(TOPICS_PROPERTY);\n        Dictionary instanceFilter = (Dictionary) conf.get(FILTER_PROPERTY);\n\n        // Get Metadata subscribers\n        Element[] subscribers = metadata.getElements(\"subscriber\", NAMESPACE);\n\n        // The topics to listen\n        Set topics = new TreeSet();\n\n        if (subscribers != null) {\n\n            // Configure all subscribers\n            for (int i = 0; i < subscribers.length; i++) {\n\n                // Extract the subscriber configuration\n                EventAdminSubscriberMetadata subscriberMetadata = new EventAdminSubscriberMetadata(\n                        m_manager.getContext(), subscribers[i]);\n                String name = subscriberMetadata.getName();\n                info(LOG_PREFIX + \"configuring subscriber \" + name);\n\n                // Get the topics instance configuration if redefined\n                String topicsString = (instanceTopics != null) ? (String) instanceTopics\n                        .get(name)\n                        : null;\n                if (topicsString != null) {\n                    subscriberMetadata.setTopics(topicsString);\n                }\n\n                // Get the filter instance configuration if redefined\n                String filterString = (instanceFilter != null) ? (String) instanceFilter\n                        .get(name)\n                        : null;\n                if (filterString != null) {\n                    subscriberMetadata.setFilter(filterString);\n                }\n\n                // Check the publisher is correctly configured\n                subscriberMetadata.check();\n\n                // Add this subscriber's topics to the global list\n                String[] subscriberTopics = subscriberMetadata.getTopics();\n                for (int j = 0; j < subscriberTopics.length; j++) {\n                    topics.add(subscriberTopics[j]);\n                }\n\n                // Determine the event callback prototype\n                PojoMetadata pojoMetadata = getPojoMetadata();\n                String callbackType;\n                if (subscriberMetadata.getDataKey() == null) {\n                    callbackType = Event.class.getName();\n                } else {\n                    callbackType = subscriberMetadata.getDataType().getName();\n                }\n\n                // Create the specified callback and register it\n                MethodMetadata methodMetadata = pojoMetadata.getMethod(\n                        subscriberMetadata.getCallback(),\n                        new String[] { callbackType });\n                Callback callback = new Callback(methodMetadata, m_manager);\n                m_callbacksByName.put(name, callback);\n\n                // Add the subscriber list gloal map\n                m_subscribersByName.put(name, subscriberMetadata);\n            }\n\n            // Construct the global topic list\n            m_topics = new String[topics.size()];\n            int i = 0;\n            for (Iterator iterator = topics.iterator(); iterator.hasNext();) {\n                String tmp = (String) iterator.next();\n                m_topics[i++] = tmp;\n            }\n\n        } else {\n            info(LOG_PREFIX + \"no subscriber to configure\");\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Initialize the component type.\r\n     * \r\n     * @param cd :\r\n     *            component type description to populate.\r\n     * @param metadata :\r\n     *            component type metadata.\r\n     * @throws ConfigurationException :\r\n     *             metadata are incorrect.\r\n     * @see org.apache.felix.ipojo.Handler#initializeComponentFactory(org.apache.felix.ipojo.architecture.ComponentDescription,\r\n     *      org.apache.felix.ipojo.metadata.Element)\r\n     */\r\n    // @Override\r\n    public void initializeComponentFactory(ComponentTypeDescription cd,\r\n            Element metadata)\r\n        throws ConfigurationException {\r\n\r\n        // Update the current component description\r\n        Dictionary dict = new Properties();\r\n        cd.addProperty(new PropertyDescription(TOPICS_PROPERTY,\r\n                Dictionary.class.getName(), dict.toString()));\r\n        dict = new Properties();\r\n        cd.addProperty(new PropertyDescription(FILTER_PROPERTY,\r\n                Dictionary.class.getName(), dict.toString()));\r\n    }","id":40535,"modified_method":"/**\n     * Initialize the component type.\n     * \n     * @param cd :\n     *            component type description to populate.\n     * @param metadata :\n     *            component type metadata.\n     * @throws ConfigurationException :\n     *             metadata are incorrect.\n     * @see org.apache.felix.ipojo.Handler#initializeComponentFactory(org.apache.felix.ipojo.architecture.ComponentDescription,\n     *      org.apache.felix.ipojo.metadata.Element)\n     */\n    // @Override\n    public void initializeComponentFactory(ComponentTypeDescription cd,\n            Element metadata)\n        throws ConfigurationException {\n\n        // Update the current component description\n        Dictionary dict = new Properties();\n        cd.addProperty(new PropertyDescription(TOPICS_PROPERTY,\n                Dictionary.class.getName(), dict.toString()));\n        dict = new Properties();\n        cd.addProperty(new PropertyDescription(FILTER_PROPERTY,\n                Dictionary.class.getName(), dict.toString()));\n\n        // Get Metadata subscribers\n        Element[] subscribers = metadata.getElements(\"subscriber\", NAMESPACE);\n        if (subscribers != null) {\n\n            // Maps used to check name and field are unique\n            Set nameSet = new HashSet();\n            Set callbackSet = new HashSet();\n\n            // Check all subscribers are well formed\n            for (int i = 0; i < subscribers.length; i++) {\n\n                // Check the subscriber configuration is correct by creating an\n                // unused subscriber metadata\n                EventAdminSubscriberMetadata subscriberMetadata = new EventAdminSubscriberMetadata(\n                        getFactory().getBundleContext(), subscribers[i]);\n\n                String name = subscriberMetadata.getName();\n                info(LOG_PREFIX + \"checking subscriber \" + name);\n\n                // Determine the event callback prototype\n                PojoMetadata pojoMetadata = getPojoMetadata();\n                String callbackType;\n                if (subscriberMetadata.getDataKey() == null) {\n                    callbackType = Event.class.getName();\n                } else {\n                    callbackType = subscriberMetadata.getDataType().getName();\n                }\n\n                // Check the event callback method is present\n                MethodMetadata methodMetadata = pojoMetadata.getMethod(\n                        subscriberMetadata.getCallback(),\n                        new String[] { callbackType });\n                String callbackSignature = subscriberMetadata.getCallback()\n                        + \"(\" + callbackType + \")\";\n                if (methodMetadata == null) {\n                    throw new ConfigurationException(\n                            \"Cannot find callback method \" + callbackSignature);\n                }\n\n                // Warn if the same callback is used by several subscribers\n                if (callbackSet.contains(callbackSignature)) {\n                    warn(\"The callback method is already used by another subscriber : \"\n                            + callbackSignature);\n                } else {\n                    callbackSet.add(callbackSignature);\n                }\n\n                // Check name is unique\n                if (nameSet.contains(name)) {\n                    throw new ConfigurationException(\n                            \"A subscriber with the same name already exists : \"\n                                    + name);\n                }\n                nameSet.add(name);\n            }\n        } else {\n            info(LOG_PREFIX + \"no subscriber to check\");\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Receive an event. The event is dispatch to attached subscribers.\r\n     * \r\n     * @param event :\r\n     *            the received event.\r\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\r\n     */\r\n    public void handleEvent(Event event) {\r\n\r\n        // Retrieve the event's topic\r\n        String topic = event.getTopic();\r\n\r\n        // For each subscribers\r\n        Collection subscribers = m_subscribersByName.values();\r\n        for (Iterator i = subscribers.iterator(); i.hasNext();) {\r\n            EventAdminSubscriberMetadata subscriberMetadata = (EventAdminSubscriberMetadata) i\r\n                    .next();\r\n\r\n            synchronized (this) {\r\n                // Check if the subscriber's topic and filter match\r\n                Filter filter = subscriberMetadata.getFilter();\r\n\r\n                if (EventUtil.matches(topic, subscriberMetadata.getTopics())\r\n                        && (filter == null || event.matches(filter))) {\r\n\r\n                    String name = subscriberMetadata.getName();\r\n                    String dataKey = subscriberMetadata.getDataKey();\r\n                    Callback callback = (Callback) m_callbacks.get(name);\r\n                    Object callbackParam;\r\n\r\n                    try {\r\n                        // Depending on the subscriber type...\r\n                        if (dataKey == null) {\r\n\r\n                            // Generic event subscriber : pass the event to the\r\n                            // registered\r\n                            // callback\r\n                            callbackParam = event;\r\n\r\n                        } else {\r\n\r\n                            // Check for a data key in the event\r\n                            boolean dataKeyPresent = false;\r\n                            String[] properties = event.getPropertyNames();\r\n                            for (int j = 0; j < properties.length\r\n                                    && !dataKeyPresent; j++) {\r\n                                if (dataKey.equals(properties[j])) {\r\n                                    dataKeyPresent = true;\r\n                                }\r\n                            }\r\n\r\n                            if (dataKeyPresent) {\r\n                                // Data event : check type compatibility and\r\n                                // pass the given object to the registered\r\n                                // callback\r\n                                Object data = event.getProperty(dataKey);\r\n                                Class dataType = subscriberMetadata\r\n                                        .getDataType();\r\n                                Class dataClazz = data.getClass();\r\n                                if (dataType.isAssignableFrom(dataClazz)) {\r\n                                    callbackParam = data;\r\n                                } else {\r\n                                    throw new ClassCastException(\r\n                                            \"Cannot convert \"\r\n                                                    + dataClazz.getName()\r\n                                                    + \" to \"\r\n                                                    + dataType.getName());\r\n                                }\r\n\r\n                            } else {\r\n                                throw new java.lang.NoSuchFieldException(\r\n                                        dataKey);\r\n                            }\r\n                        }\r\n\r\n                        // Run the callback\r\n                        callback.call(new Object[] { callbackParam });\r\n\r\n                    } catch (ClassCastException e) {\r\n                        // Ignore the data event if type doesn't match\r\n                        warn(\r\n                                LOG_PREFIX\r\n                                        + \"Ignoring data event : Bad data type\",\r\n                                e);\r\n                    } catch (NoSuchFieldException e) {\r\n                        // Ignore events without data field for data events\r\n                        // subscriber\r\n                        warn(LOG_PREFIX + \"Ignoring data event : No data\", e);\r\n                    } catch (Exception e) {\r\n                        // Unexpected exception\r\n                        error(LOG_PREFIX\r\n                                + \"Unexpected exception when calling callback\",\r\n                                e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }","id":40536,"modified_method":"/**\n     * Receive an event. The event is dispatch to attached subscribers.\n     * \n     * @param event :\n     *            the received event.\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\n     */\n    public void handleEvent(Event event) {\n\n        // Retrieve the event's topic\n        String topic = event.getTopic();\n\n        // For each subscribers\n        Collection subscribers = m_subscribersByName.values();\n        for (Iterator i = subscribers.iterator(); i.hasNext();) {\n            EventAdminSubscriberMetadata subscriberMetadata = (EventAdminSubscriberMetadata) i\n                    .next();\n\n            synchronized (this) {\n                // Check if the subscriber's topic and filter match\n                Filter filter = subscriberMetadata.getFilter();\n\n                if (EventUtil.matches(topic, subscriberMetadata.getTopics())\n                        && (filter == null || event.matches(filter))) {\n\n                    String name = subscriberMetadata.getName();\n                    String dataKey = subscriberMetadata.getDataKey();\n                    Callback callback = (Callback) m_callbacksByName.get(name);\n                    Object callbackParam;\n\n                    try {\n                        // Depending on the subscriber type...\n                        if (dataKey == null) {\n\n                            // Generic event subscriber : pass the event to the\n                            // registered\n                            // callback\n                            callbackParam = event;\n\n                        } else {\n\n                            // Check for a data key in the event\n                            boolean dataKeyPresent = false;\n                            String[] properties = event.getPropertyNames();\n                            for (int j = 0; j < properties.length\n                                    && !dataKeyPresent; j++) {\n                                if (dataKey.equals(properties[j])) {\n                                    dataKeyPresent = true;\n                                }\n                            }\n\n                            if (dataKeyPresent) {\n                                // Data event : check type compatibility and\n                                // pass the given object to the registered\n                                // callback\n                                Object data = event.getProperty(dataKey);\n                                Class dataType = subscriberMetadata\n                                        .getDataType();\n                                Class dataClazz = data.getClass();\n                                if (dataType.isAssignableFrom(dataClazz)) {\n                                    callbackParam = data;\n                                } else {\n                                    throw new ClassCastException(\n                                            \"Cannot convert \"\n                                                    + dataClazz.getName()\n                                                    + \" to \"\n                                                    + dataType.getName());\n                                }\n\n                            } else {\n                                throw new java.lang.NoSuchFieldException(\n                                        dataKey);\n                            }\n                        }\n\n                        // Run the callback (final check to avoid\n                        // NullPointerExceptions)\n                        if (m_isListening) {\n                            callback.call(new Object[] { callbackParam });\n                        }\n\n                    } catch (ClassCastException e) {\n                        // Ignore the data event if type doesn't match\n                        warn(\n                                LOG_PREFIX\n                                        + \"Ignoring data event : Bad data type\",\n                                e);\n                    } catch (NoSuchFieldException e) {\n                        // Ignore events without data field for data events\n                        // subscriber\n                        warn(LOG_PREFIX + \"Ignoring data event : No data\", e);\n                    } catch (Exception e) {\n                        // Unexpected exception\n                        error(LOG_PREFIX\n                                + \"Unexpected exception when calling callback\",\n                                e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Handler stop method.\r\n     * \r\n     * @see org.apache.felix.ipojo.Handler#stop()\r\n     */\r\n    // @Override\r\n    public void stop() {\r\n    }","id":40537,"modified_method":"/**\n     * Handler stop method.\n     * \n     * @see org.apache.felix.ipojo.Handler#stop()\n     */\n    // @Override\n    public synchronized void stop() {\n        m_isListening = false;\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Handler start method.\r\n     * \r\n     * @see org.apache.felix.ipojo.Handler#start()\r\n     */\r\n    // @Override\r\n    public void start() {\r\n\r\n        Set topics = new TreeSet();\r\n\r\n        // Build the topic to listen\r\n        // Topics is a merge of all required topics by subscribers\r\n        if (!m_subscribersByName.isEmpty()) {\r\n            Collection subscribers = m_subscribersByName.values();\r\n            for (Iterator i = subscribers.iterator(); i.hasNext();) {\r\n                String[] subTopics = ((EventAdminSubscriberMetadata) i.next())\r\n                        .getTopics();\r\n                for (int j = 0; j < subTopics.length; j++) {\r\n                    topics.add(subTopics[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        m_topics = new String[topics.size()];\r\n        int i = 0;\r\n        for (Iterator iterator = topics.iterator(); iterator.hasNext();) {\r\n            String tmp = (String) iterator.next();\r\n            m_topics[i++] = tmp;\r\n        }\r\n    }","id":40538,"modified_method":"/**\n     * Handler start method.\n     * \n     * @see org.apache.felix.ipojo.Handler#start()\n     */\n    // @Override\n    public synchronized void start() {\n        m_isListening = true;\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Constructor.\r\n     * \r\n     * @param instanceManager :\r\n     *            instance manager.\r\n     * @param subscriber :\r\n     *            subscriber metadata.\r\n     * @param instanceConf :\r\n     *            the configuration of the component instance\r\n     * @throws ConfigurationException\r\n     *             if the configuration of the component or the instance is\r\n     *             invalid.\r\n     */\r\n    public EventAdminSubscriberMetadata(InstanceManager instanceManager,\r\n            Element subscriber, Dictionary instanceConf)\r\n        throws ConfigurationException {\r\n\r\n        m_instanceManager = instanceManager;\r\n\r\n        /**\r\n         * Setup required attributes\r\n         */\r\n\r\n        // NAME_ATTRIBUTE\r\n        if (subscriber.containsAttribute(NAME_ATTRIBUTE)) {\r\n            m_name = subscriber.getAttribute(NAME_ATTRIBUTE);\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component configuration : \"\r\n                            + NAME_ATTRIBUTE);\r\n        }\r\n\r\n        // CALLBACK_ATTRIBUTE\r\n        if (subscriber.containsAttribute(CALLBACK_ATTRIBUTE)) {\r\n            m_callback = subscriber.getAttribute(CALLBACK_ATTRIBUTE);\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component configuration : \"\r\n                            + CALLBACK_ATTRIBUTE);\r\n        }\r\n\r\n        // TOPICS_ATTRIBUTE\r\n        String topicsString = null;\r\n        if (subscriber.containsAttribute(TOPICS_ATTRIBUTE)) {\r\n            topicsString = subscriber.getAttribute(TOPICS_ATTRIBUTE);\r\n        }\r\n        // Check TOPICS_PROPERTY in the instance configuration\r\n        Dictionary instanceTopics = (Dictionary) instanceConf\r\n                .get(EventAdminSubscriberHandler.TOPICS_PROPERTY);\r\n        if (instanceTopics != null) {\r\n            Enumeration e = instanceTopics.keys();\r\n            while (e.hasMoreElements()) {\r\n                String myName = (String) e.nextElement(); // name\r\n                if (m_name.equals(myName)) {\r\n                    topicsString = (String) instanceTopics.get(myName);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (topicsString != null) {\r\n            m_topics = ParseUtils.split(topicsString, \",\");\r\n        } else {\r\n            throw new ConfigurationException(\r\n                    \"Missing required attribute in component or instance configuration : \"\r\n                            + TOPICS_ATTRIBUTE);\r\n        }\r\n\r\n        /**\r\n         * Setup optional attributes\r\n         */\r\n\r\n        // DATA_KEY_ATTRIBUTE\r\n        m_dataKey = subscriber.getAttribute(DATA_KEY_ATTRIBUTE);\r\n        if (subscriber.containsAttribute(DATA_TYPE_ATTRIBUTE)) {\r\n            Class type;\r\n            try {\r\n                type = m_instanceManager.getContext().getBundle().loadClass(\r\n                        subscriber.getAttribute(DATA_TYPE_ATTRIBUTE));\r\n            } catch (ClassNotFoundException e) {\r\n                m_instanceManager\r\n                        .getFactory()\r\n                        .getLogger()\r\n                        .log(\r\n                                Logger.WARNING,\r\n                                \"Ignoring data-type (using default) : Malformed attribute in metadata\",\r\n                                e);\r\n                type = DEFAULT_DATA_TYPE_VALUE;\r\n            }\r\n            m_dataType = type;\r\n        } else {\r\n            m_dataType = DEFAULT_DATA_TYPE_VALUE;\r\n        }\r\n\r\n        // FILTER_ATTRIBUTE\r\n        String filterString = null;\r\n        if (subscriber.containsAttribute(FILTER_ATTRIBUTE)) {\r\n            filterString = subscriber.getAttribute(FILTER_ATTRIBUTE);\r\n        }\r\n        // Check FILTER_PROPERTY in the instance configuration\r\n        Dictionary instanceFilter = (Dictionary) instanceConf\r\n                .get(EventAdminSubscriberHandler.FILTER_PROPERTY);\r\n        if (instanceFilter != null) {\r\n            Enumeration e = instanceFilter.keys();\r\n            while (e.hasMoreElements()) {\r\n                String myName = (String) e.nextElement(); // name\r\n                if (m_name.equals(myName)) {\r\n                    filterString = (String) instanceFilter.get(myName);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        Filter filter;\r\n        if (filterString != null) {\r\n            try {\r\n                filter = m_instanceManager.getContext().createFilter(\r\n                        filterString);\r\n            } catch (InvalidSyntaxException e) {\r\n                // Ignore filter if malformed\r\n                m_instanceManager.getFactory().getLogger().log(Logger.WARNING,\r\n                        \"Ignoring filter : Malformed attribute in metadata\", e);\r\n                filter = null;\r\n            }\r\n        } else {\r\n            filter = null;\r\n        }\r\n        m_filter = filter;\r\n    }","id":40539,"modified_method":"/**\n     * Constructor.\n     * \n     * @param bundleContext : bundle context of the managed instance.\n     * @param subscriber : subscriber metadata.\n     * @throws ConfigurationException\n     *             if the configuration of the component or the instance is\n     *             invalid.\n     */\n    public EventAdminSubscriberMetadata(BundleContext bundleContext,\n            Element subscriber)\n        throws ConfigurationException {\n\n        m_bundleContext = bundleContext;\n\n        /**\n         * Setup required attributes\n         */\n\n        // NAME_ATTRIBUTE\n        if (subscriber.containsAttribute(NAME_ATTRIBUTE)) {\n            m_name = subscriber.getAttribute(NAME_ATTRIBUTE);\n        } else {\n            throw new ConfigurationException(\n                    \"Missing required attribute in component configuration : \"\n                            + NAME_ATTRIBUTE);\n        }\n\n        // CALLBACK_ATTRIBUTE\n        if (subscriber.containsAttribute(CALLBACK_ATTRIBUTE)) {\n            m_callback = subscriber.getAttribute(CALLBACK_ATTRIBUTE);\n        } else {\n            throw new ConfigurationException(\n                    \"Missing required attribute in component configuration : \"\n                            + CALLBACK_ATTRIBUTE);\n        }\n\n        // TOPICS_ATTRIBUTE\n        if (subscriber.containsAttribute(TOPICS_ATTRIBUTE)) {\n            m_topics = ParseUtils.split(subscriber\n                    .getAttribute(TOPICS_ATTRIBUTE), \",\");\n            // Check each topic is valid\n            Dictionary empty = new Hashtable();\n            for (int i = 0; i < m_topics.length; i++) {\n                String topic = m_topics[i];\n                try {\n                    new Event(topic, empty);\n                } catch (IllegalArgumentException e) {\n                    throw new ConfigurationException(\"Malformed topic : \"\n                            + topic);\n                }\n            }\n        } else {\n            m_topics = null;\n            // Nothing to do if TOPICS_ATTRIBUTE is not present as it can be\n            // overridden in the instance configuration.\n        }\n\n        /**\n         * Setup optional attributes\n         */\n\n        // DATA_KEY_ATTRIBUTE\n        m_dataKey = subscriber.getAttribute(DATA_KEY_ATTRIBUTE);\n        if (subscriber.containsAttribute(DATA_TYPE_ATTRIBUTE)) {\n            Class type;\n            String typeName = subscriber.getAttribute(DATA_TYPE_ATTRIBUTE);\n            try {\n                type = m_bundleContext.getBundle().loadClass(typeName);\n            } catch (ClassNotFoundException e) {\n                throw new ConfigurationException(\"Data type class not found : \"\n                        + typeName);\n            }\n            m_dataType = type;\n        } else {\n            m_dataType = DEFAULT_DATA_TYPE_VALUE;\n        }\n\n        // FILTER_ATTRIBUTE\n        if (subscriber.containsAttribute(FILTER_ATTRIBUTE)) {\n            try {\n                m_filter = m_bundleContext.createFilter(subscriber\n                        .getAttribute(FILTER_ATTRIBUTE));\n            } catch (InvalidSyntaxException e) {\n                throw new ConfigurationException(\"Invalid filter syntax\");\n            }\n        }\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n     * Construct an Publisher with given parameters.\r\n     * \r\n     * @param handler\r\n     *            the handler that will manage this publisher\r\n     * @param topics\r\n     *            the topics on which events are sent\r\n     * @param synchronous\r\n     *            the sending mode of events\r\n     * @param dataKey\r\n     *            The key, in the content of the event, where user data are\r\n     *            stored (may be {@code null})\r\n     * @param instanceName\r\n     *            the name of the instance creating this publisher.\r\n     */\r\n    public PublisherImpl(EventAdminPublisherHandler handler, String[] topics,\r\n            boolean synchronous, String dataKey, String instanceName) {\r\n\r\n        // Check parameters\r\n        if (topics.length == 0) {\r\n            throw new IllegalArgumentException(\r\n                    \"At least one topic must be specified\");\r\n        }\r\n        // Test validity of each topic\r\n        for (int i = 0; i < topics.length; i++) {\r\n            try {\r\n                new Event(topics[i], null);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new IllegalArgumentException(\"Malformed topic : \"\r\n                        + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // Initialize the publisher's fields\r\n        m_handler = handler;\r\n        m_topics = topics;\r\n        m_synchronous = synchronous;\r\n        m_dataKey = dataKey;\r\n        m_instanceName = instanceName;\r\n    }","id":40540,"modified_method":"/**\n     * Construct an Publisher with given parameters.\n     * \n     * @param handler\n     *            the handler that will manage this publisher\n     * @param topics\n     *            the topics on which events are sent\n     * @param synchronous\n     *            the sending mode of events\n     * @param dataKey\n     *            The key, in the content of the event, where user data are\n     *            stored (may be {@code null})\n     * @param instanceName\n     *            the name of the instance creating this publisher.\n     */\n    public PublisherImpl(EventAdminPublisherHandler handler, String[] topics,\n            boolean synchronous, String dataKey, String instanceName) {\n\n        // Initialize the publisher's fields\n        m_handler = handler;\n        m_topics = topics;\n        m_synchronous = synchronous;\n        m_dataKey = dataKey;\n        m_instanceName = instanceName;\n    }","commit_id":"06c0ecfc73efc04b49efe4088abaf86853937c56","url":"https://github.com/apache/felix"},{"original_method":"public CaptureStartEvent(CapturedScreen cs) {\r\n\t\tsuper(cs);\r\n\t}","id":40541,"modified_method":"public CaptureStartEvent(String room, int width, int height, int frameRate) {\r\n\t\tthis.room = room;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.frameRate = frameRate;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void setScreenCaptureHandler(ScreenCaptureMessageHandler screenCaptureHandler) {\n\t\tthis.screenCaptureHandler = screenCaptureHandler;\n\t}","id":40542,"modified_method":"public void setScreenCaptureHandler(IoHandlerAdapter screenCaptureHandler) {\n\t\tthis.screenCaptureHandler = screenCaptureHandler;\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void accept(CaptureEvent event) {\n\t\ttry {\n\t\t\tqueue.put(event);\n\t\t} catch (InterruptedException e) {\n\t\t\tlog.warn(\"InterruptedException while putting event into queue.\");\n\t\t}\n\t}","id":40543,"modified_method":"public void accept(CaptureUpdateEvent event) {\n\t\ttry {\n\t\t\tqueue.put(event);\n\t\t} catch (InterruptedException e) {\n\t\t\tlog.warn(\"InterruptedException while putting event into queue.\");\n\t\t}\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void start() {\n\t\tstartPublishing(scope);\n\t\tsetupStreams();\n\t\thandleEvent = true;\n\t\tlog.debug(\"Starting stream {}\", outStreamName);\n\t\teventHandler = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\twhile (handleEvent) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tCaptureEvent event = queue.take();\n\t\t\t\t\t\thandleCaptureEvent(event);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tlog.warn(\"InterruptedExeption while taking event.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\texec.execute(eventHandler);\n\t}","id":40544,"modified_method":"public void start() {\n\t\tstartPublishing(scope);\n\t\tsetupStreams();\n\t\thandleEvent = true;\n\t\tlog.debug(\"Starting stream {}\", outStreamName);\n\t\teventHandler = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\twhile (handleEvent) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tCaptureUpdateEvent event = queue.take();\n\t\t\t\t\t\thandleCaptureEvent(event);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tlog.warn(\"InterruptedExeption while taking event.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\texec.execute(eventHandler);\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void handleCaptureEvent(CaptureEvent event) {\n\t\tBufferedImage image = event.getCapturedScreen();\n\t\timageReceived(image);\n\t}","id":40545,"modified_method":"private void handleCaptureEvent(CaptureUpdateEvent event) {\n\t\tBufferedImage image = event.getCapturedScreen();\n\t\timageReceived(image);\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendCaptureEvent(CapturedScreen cs) {\r\n    \tstreamerGateway.onCaptureEvent(new CaptureEvent(cs));\r\n    }","id":40546,"modified_method":"private void sendCaptureEvent(CapturedScreen cs) {\r\n    \tstreamerGateway.onCaptureEvent(new CaptureUpdateEvent(cs));\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private boolean canDecodeCapturedScreen(IoSession session, IoBuffer in) {\r\n        if (in.prefixedDataAvailable(4, MAX_IMAGE_SIZE)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":40547,"modified_method":"private boolean decodeCaptureStart(IoSession session, IoBuffer in, ProtocolDecoderOutput out) {   \t\r\n    \tif (! session.containsAttribute(ROOM)) {\r\n    \t\treturn decodeRoom(session, in);\r\n    \t} else {\r\n    \t\tif (decodeVideoInfo(session, in)) {\r\n    \t\t\tsendCaptureStartMessage(session, out);\r\n    \t\t\treturn true; \r\n    \t\t}\r\n    \t}\r\n    \treturn false;\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {\r\n    \t\r\n    \tif (!session.containsAttribute(ROOM)) {\r\n    \t\treturn decodeRoom(session, in);\r\n    \t} else if (!session.containsAttribute(VIDEO_INFO)) {\r\n    \t\treturn decodeRoom(session, in);\r\n    \t} else {\r\n    \t\tif (canDecodeCapturedScreen(session, in)) {\r\n    \t        byte[] bytes = new byte[getLength(in)];\r\n    \t        log.debug(\"Reading image with length {}\", bytes.length);\r\n    \t        in.get(bytes);\r\n    \t        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n      \t        \r\n    \t        try {\r\n    \t        \tBufferedImage image = ImageIO.read(bais);;\r\n    \t        \tsession.setAttribute(CAPTURED_SCREEN, image);   \t\r\n    \t        \tsendDecodedMessage(session, out);\r\n    \t        } catch (IOException e) {\r\n    \t        \tlog.error(\"Failed to get captured screen for room {}\", (String) session.getAttribute(ROOM));\r\n    \t        }\r\n    \t        \r\n    \t\t\treset(session);\r\n    \t\t\treturn true;\r\n    \t\t}\r\n    \t}\r\n    \treturn false;\r\n    }","id":40548,"modified_method":"protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {\r\n \r\n    \tif (session.containsAttribute(MESSAGE_TYPE)) {\r\n    \t\tInteger messageType = (Integer) session.getAttribute(MESSAGE_TYPE);\r\n    \t\tswitch (messageType.intValue()) {\r\n    \t\tcase CAPTURE_START:\r\n    \t\t\treturn decodeCaptureStart(session, in, out);\r\n    \t\tcase CAPTURE_UPDATE:\r\n    \t\t\treturn decodeCaptureUpdate(session, in, out);\r\n    \t\tcase CAPTURE_END: \r\n  //  \t\t\tdecodeCaptureEnd(session, in, out);\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t} else {\r\n    \t\tif (in.remaining() < 20) return false;\r\n    \t\tint message = in.getInt();\r\n    \t\tlog.debug(\"Got message \" + message);\r\n    \t\tsession.setAttribute(MESSAGE_TYPE, new Integer(message));\r\n    \t\treturn true;\r\n\r\n    \t}\r\n    \treturn false;\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendDecodedMessage(IoSession session, ProtocolDecoderOutput out) {\r\n\t\tBufferedImage screen = (BufferedImage) session.getAttribute(CAPTURED_SCREEN);\r\n\t\tString room = (String) session.getAttribute(ROOM);\r\n\t\tString videoInfo = (String) session.getAttribute(VIDEO_INFO);\r\n\t\t\r\n\t\t//Get the screen dimensions, i.e. the resolution of the video we need to create\r\n\t\tString[] screenDimensions = videoInfo.split(\"x\");\r\n\t\tint width = Integer.parseInt(screenDimensions[0]);\r\n\t\tint height = Integer.parseInt(screenDimensions[1]);\r\n\t\tint frameRate = Integer.parseInt(screenDimensions[2]);\r\n\r\n\t\tCapturedScreen cs = new CapturedScreen(screen, room, width, height, frameRate);\r\n\t\tout.write(cs);   \t\r\n    }","id":40549,"modified_method":"private void sendCaptureStartMessage(IoSession session, ProtocolDecoderOutput out) {\r\n\t\tString room = (String) session.getAttribute(ROOM);\r\n\t\tString videoInfo = (String) session.getAttribute(VIDEO_INFO);\r\n\t\tlog.debug(\"Room \" + room + \" videoInfo \" + videoInfo);\r\n\t\t//Get the screen dimensions, i.e. the resolution of the video we need to create\r\n\t\tString[] screenDimensions = videoInfo.split(\"x\");\r\n\t\tint width = Integer.parseInt(screenDimensions[0]);\r\n\t\tint height = Integer.parseInt(screenDimensions[1]);\r\n\t\tint frameRate = Integer.parseInt(screenDimensions[2]);\r\n\t\t\r\n\t\tCaptureStartEvent cse = new CaptureStartEvent();\r\n\t\tout.write(\"CAPTURE START\");\r\n\t\tclearMessage(session);\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void parseLine(IoSession session, IoBuffer in) {\r\n    \ttry {\r\n\t\t\tString line = in.getString(Charset.forName( \"UTF-8\" ).newDecoder());\r\n\t\t\tif (!session.containsAttribute(ROOM)) {\r\n\t\t\t\tsession.setAttribute(ROOM, line.trim());\r\n\t\t\t} else {\r\n\t\t\t\tsession.setAttribute(VIDEO_INFO, line.trim());\r\n\t\t\t}\r\n\t\t} catch (CharacterCodingException e1) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n    }","id":40550,"modified_method":"private boolean decodeTile(IoSession session, IoBuffer in) {\r\n    \tif (in.remaining() < 40) return false;\r\n\r\n    \tint start = in.position();\r\n    \t\r\n    \tint tileLength = in.getInt();\r\n    \t\r\n    \tif (in.remaining() >= tileLength) {\r\n       \t \tbyte[] bytes = new byte[tileLength];\r\n\t        log.debug(\"Reading image with length {}\", bytes.length);\r\n\t        in.get(bytes);\r\n\t        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n\t        \r\n\t        try {\r\n\t        \tBufferedImage image = ImageIO.read(bais);;\r\n    \t        session.setAttribute(TILE_IMAGE, image);\r\n\t        } catch (IOException e) {\r\n\t        \tlog.error(\"Failed to get captured screen for room \");\r\n\t        }    \r\n\t        return true;\r\n    \t}\r\n    \t\r\n    \tlog.debug(\"Can't process image yet . \" + tileLength);\t\t\r\n    \tin.position(start);\r\n\t    return false;        \t\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private boolean decodeRoom(IoSession session, IoBuffer in) {\r\n    \treturn getCrLfTerminatedString(session, in);\r\n    }","id":40551,"modified_method":"private boolean decodeRoom(IoSession session, IoBuffer in) {\r\n    \tif (in.remaining() < 200) return false;\r\n    \t\r\n    \tint len = in.getInt();\r\n    \tString room = decodeString(len, in);\r\n    \tif (room != \"\") {\r\n    \t\tsession.setAttribute(ROOM, room);\r\n    \t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void reset(IoSession session) {\r\n    \tsession.removeAttribute(ROOM);\r\n    \tsession.removeAttribute(VIDEO_INFO);\r\n    \tsession.removeAttribute(CAPTURED_SCREEN);\r\n    }","id":40552,"modified_method":"private void reset(IoSession session) {\r\n    \tsession.removeAttribute(TILE_INFO);\r\n    \tsession.removeAttribute(TILE_IMAGE);\r\n    \tclearMessage(session);\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public StreamerGateway() {\r\n\t\tdsMap = new ConcurrentHashMap<String, DeskShareStream>();\r\n\t}","id":40553,"modified_method":"public StreamerGateway() {\r\n\t\tstreamsMap = new ConcurrentHashMap<String, DeskShareStream>();\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public int getRoomVideoWidth(String room){\r\n\t\tDeskShareStream ds = dsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn ds.getWidth();\r\n\t\t}\r\n\t\treturn 0;\r\n\t}","id":40554,"modified_method":"public int getRoomVideoWidth(String room){\r\n\t\tDeskShareStream ds = streamsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn ds.getWidth();\r\n\t\t}\r\n\t\treturn 0;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void onCaptureEndEvent(CaptureEndEvent event) {\r\n\t\tDeskShareStream ds = dsMap.remove(event.getRoom());\r\n\t\tif (ds != null) {\r\n\t\t\tds.stop();\r\n\t\t\tds = null;\r\n\t\t}\r\n\t}","id":40555,"modified_method":"public void onCaptureEndEvent(CaptureEndEvent event) {\r\n\t\tDeskShareStream ds = streamsMap.remove(event.getRoom());\r\n\t\tif (ds != null) {\r\n\t\t\tds.stop();\r\n\t\t\tds = null;\r\n\t\t}\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void onCaptureEvent(CaptureEvent event) {\r\n\t\tDeskShareStream ds = dsMap.get(event.getRoom());\r\n\t\tif (ds != null) {\r\n\t\t\tds.accept(event);\r\n\t\t}\r\n\t}","id":40556,"modified_method":"public void onCaptureEvent(CaptureUpdateEvent event) {\r\n\t\tDeskShareStream ds = streamsMap.get(event.getRoom());\r\n\t\tif (ds != null) {\r\n\t\t\tds.accept(event);\r\n\t\t}\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void onCaptureStartEvent(CaptureStartEvent event) {\r\n\t\tDeskShareStream stream = sf.createStream(event);\r\n\r\n\t\tdsMap.put(event.getRoom(), stream);\r\n\t\tstream.start();\r\n\t\t\t\r\n\t\t//notify the clients in the room that the stream has now started broadcasting.\r\n\t\tISharedObject deskSO = app.getSharedObject(stream.getScope(), \"deskSO\");\r\n\t\tdeskSO.sendMessage(\"appletStarted\" , new ArrayList<Object>());\r\n\r\n\t}","id":40557,"modified_method":"public void onCaptureStartEvent(CaptureStartEvent event) {\r\n\t\tDeskShareStream stream = streamFactory.createStream(event);\r\n\r\n\t\tstreamsMap.put(event.getRoom(), stream);\r\n\t\tstream.start();\r\n\t\t\t\r\n\t\t//notify the clients in the room that the stream has now started broadcasting.\r\n\t\tISharedObject deskSO = deskShareApp.getSharedObject(stream.getScope(), \"deskSO\");\r\n\t\tdeskSO.sendMessage(\"appletStarted\" , new ArrayList<Object>());\r\n\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void setDeskShareApplication(DeskShareApplication app) {\r\n\t\tthis.app = app;\r\n\t}","id":40558,"modified_method":"public void setDeskShareApplication(DeskShareApplication app) {\r\n\t\tthis.deskShareApp = app;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public int getRoomVideoHeight(String room){\r\n\t\tDeskShareStream ds = dsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn ds.getHeight();\r\n\t\t}\r\n\t\treturn 0;\r\n\t}","id":40559,"modified_method":"public int getRoomVideoHeight(String room){\r\n\t\tDeskShareStream ds = streamsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn ds.getHeight();\r\n\t\t}\r\n\t\treturn 0;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public boolean isStreaming(String room){\r\n\t\tDeskShareStream ds = dsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":40560,"modified_method":"public boolean isStreaming(String room){\r\n\t\tDeskShareStream ds = streamsMap.get(room);\r\n\t\tif (ds != null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void setStreamFactory(StreamFactory sf) {\r\n\t\tthis.sf = sf;\r\n\t}","id":40561,"modified_method":"public void setStreamFactory(StreamFactory sf) {\r\n\t\tthis.streamFactory = sf;\r\n\t}","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendCaptureEvent(CapturedScreen cs) {\r\n    \tstreamerGateway.onCaptureEvent(new CaptureEvent(cs));\r\n    }","id":40562,"modified_method":"private void sendCaptureEvent(CapturedScreen cs) {\r\n    \tstreamerGateway.onCaptureEvent(new CaptureUpdateEvent(cs));\r\n    }","commit_id":"72db86cdbc5f4ece90711bac353ea27f55283154","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public String runStartTag() throws JspException {\n\t\tdoStartTag();\n\n\t\tStringPageContext stringPageContext = (StringPageContext)pageContext;\n\n\t\treturn stringPageContext.getString();\n\t}","id":40563,"modified_method":"public void runStartTag() throws JspException {\n\t\tdoStartTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String runEndTag() throws JspException {\n\t\tdoStartTag();\n\n\t\tStringPageContext stringPageContext = (StringPageContext)pageContext;\n\n\t\treturn stringPageContext.getString();\n\t}","id":40564,"modified_method":"public void runEndTag() throws JspException {\n\t\tdoStartTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String runTag() throws JspException {\n\t\tdoStartTag();\n\t\tdoEndTag();\n\n\t\tStringPageContext stringPageContext = (StringPageContext)pageContext;\n\n\t\treturn stringPageContext.getString();\n\t}","id":40565,"modified_method":"public void runTag() throws JspException {\n\t\tdoStartTag();\n\t\tdoEndTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String processTemplate(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tHttpServletResponse response, PageContext pageContext,\n\t\t\tString portletId, String velocityTemplateId,\n\t\t\tString velocityTemplateContent)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(velocityTemplateContent)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tTemplateProcessor processor = new TemplateProcessor(\n\t\t\tservletContext, request, response, portletId);\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\tvelocityContext.put(\"processor\", processor);\n\n\t\t// Velocity variables\n\n\t\tVelocityVariables.insertVariables(velocityContext, request);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\tresponse);\n\n\t\tMethodWrapper methodWrapper = new MethodWrapper(\n\t\t\t\"com.liferay.taglib.util.VelocityTaglib\", \"init\",\n\t\t\tnew Object[] {\n\t\t\t\tservletContext, request, stringResponse, pageContext\n\t\t\t});\n\n\t\tObject velocityTaglib = MethodInvoker.invoke(methodWrapper);\n\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\ttry {\n\t\t\tVelocityEngineUtil.mergeTemplate(\n\t\t\t\tvelocityTemplateId, velocityTemplateContent, velocityContext,\n\t\t\t\tunsyncStringWriter);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow e;\n\t\t}\n\n\t\tString output = unsyncStringWriter.toString();\n\n\t\tMap<String, String> columnsMap = processor.getColumnsMap();\n\n\t\tIterator<Map.Entry<String, String>> columnsMapItr =\n\t\t\tcolumnsMap.entrySet().iterator();\n\n\t\twhile (columnsMapItr.hasNext()) {\n\t\t\tMap.Entry<String, String> entry = columnsMapItr.next();\n\n\t\t\tString key = entry.getKey();\n\t\t\tString value = entry.getValue();\n\n\t\t\toutput = StringUtil.replace(output, key, value);\n\t\t}\n\n\t\tMap<Portlet, Object[]> portletsMap = processor.getPortletsMap();\n\n\t\tMap<String, String> contentsMap = new HashMap<String, String>(\n\t\t\tportletsMap.size());\n\n\t\tfor (Map.Entry<Portlet, Object[]> entry : portletsMap.entrySet()) {\n\t\t\tPortlet portlet = entry.getKey();\n\t\t\tObject[] value = entry.getValue();\n\n\t\t\tString queryString = (String)value[0];\n\t\t\tString columnId = (String)value[1];\n\t\t\tInteger columnPos = (Integer)value[2];\n\t\t\tInteger columnCount = (Integer)value[3];\n\n\t\t\tString content = processPortlet(\n\t\t\t\tservletContext, request, response, portlet, queryString,\n\t\t\t\tcolumnId, columnPos, columnCount, null);\n\n\t\t\tcontentsMap.put(portlet.getPortletId(), content);\n\t\t}\n\n\t\treturn StringUtil.replace(\n\t\t\toutput, \"[$TEMPLATE_PORTLET_\", \"$]\", contentsMap);\n\t}","id":40566,"modified_method":"public static String processTemplate(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tHttpServletResponse response, PageContext pageContext,\n\t\t\tString portletId, String velocityTemplateId,\n\t\t\tString velocityTemplateContent)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(velocityTemplateContent)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tTemplateProcessor processor = new TemplateProcessor(\n\t\t\tservletContext, request, response, portletId);\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\tvelocityContext.put(\"processor\", processor);\n\n\t\t// Velocity variables\n\n\t\tVelocityVariables.insertVariables(velocityContext, request);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\tresponse);\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\tMethodWrapper methodWrapper = new MethodWrapper(\n\t\t\t\"com.liferay.taglib.util.VelocityTaglib\", \"init\",\n\t\t\tnew Object[] {\n\t\t\t\tservletContext, request, stringResponse, pageContext,\n\t\t\t\tunsyncStringWriter\n\t\t\t});\n\n\t\tObject velocityTaglib = MethodInvoker.invoke(methodWrapper);\n\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\n\t\ttry {\n\t\t\tVelocityEngineUtil.mergeTemplate(\n\t\t\t\tvelocityTemplateId, velocityTemplateContent, velocityContext,\n\t\t\t\tunsyncStringWriter);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow e;\n\t\t}\n\n\t\tString output = unsyncStringWriter.toString();\n\n\t\tMap<String, String> columnsMap = processor.getColumnsMap();\n\n\t\tIterator<Map.Entry<String, String>> columnsMapItr =\n\t\t\tcolumnsMap.entrySet().iterator();\n\n\t\twhile (columnsMapItr.hasNext()) {\n\t\t\tMap.Entry<String, String> entry = columnsMapItr.next();\n\n\t\t\tString key = entry.getKey();\n\t\t\tString value = entry.getValue();\n\n\t\t\toutput = StringUtil.replace(output, key, value);\n\t\t}\n\n\t\tMap<Portlet, Object[]> portletsMap = processor.getPortletsMap();\n\n\t\tMap<String, String> contentsMap = new HashMap<String, String>(\n\t\t\tportletsMap.size());\n\n\t\tfor (Map.Entry<Portlet, Object[]> entry : portletsMap.entrySet()) {\n\t\t\tPortlet portlet = entry.getKey();\n\t\t\tObject[] value = entry.getValue();\n\n\t\t\tString queryString = (String)value[0];\n\t\t\tString columnId = (String)value[1];\n\t\t\tInteger columnPos = (Integer)value[2];\n\t\t\tInteger columnCount = (Integer)value[3];\n\n\t\t\tString content = processPortlet(\n\t\t\t\tservletContext, request, response, portlet, queryString,\n\t\t\t\tcolumnId, columnPos, columnCount, null);\n\n\t\t\tcontentsMap.put(portlet.getPortletId(), content);\n\t\t}\n\n\t\treturn StringUtil.replace(\n\t\t\toutput, \"[$TEMPLATE_PORTLET_\", \"$]\", contentsMap);\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String includeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString ctxName = GetterUtil.getString(theme.getServletContextName());\n\n\t\tif (VelocityContextPool.get(ctxName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tVelocityContextPool.put(ctxName, servletContext);\n\t\t}\n\n\t\tint pos = page.lastIndexOf(StringPool.PERIOD);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(ctxName);\n\t\tsb.append(theme.getFreeMarkerTemplateLoader());\n\t\tsb.append(theme.getTemplatesPath());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(page.substring(0, pos));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(_TEMPLATE_EXTENSION_FTL);\n\n\t\tString source = sb.toString();\n\n\t\tif (!FreeMarkerEngineUtil.resourceExists(source)) {\n\t\t\t_log.error(source + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\tFreeMarkerContext freeMarkerContext =\n\t\t\tFreeMarkerEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// FreeMarker variables\n\n\t\tFreeMarkerVariables.insertVariables(freeMarkerContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = VelocityContextPool.get(ctxName);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t(HttpServletResponse)pageContext.getResponse());\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request, stringResponse, pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tfreeMarkerContext.put(\"themeServletContext\", themeServletContext);\n\t\tfreeMarkerContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tfreeMarkerContext.put(\"theme\", velocityTaglib);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTaglibFactory portalTaglib = new TaglibFactory(servletContext);\n\n\t\tfreeMarkerContext.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTaglibFactory themeTaglib = new TaglibFactory(themeServletContext);\n\n\t\tfreeMarkerContext.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\tFreeMarkerEngineUtil.mergeTemplate(\n\t\t\tsource, freeMarkerContext, unsyncStringWriter);\n\n\t\tif (write) {\n\t\t\tStringBundler unsyncStringWriterSB =\n\t\t\t\tunsyncStringWriter.getStringBundler();\n\n\t\t\tunsyncStringWriterSB.writeTo(pageContext.getOut());\n\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn unsyncStringWriter.toString();\n\t\t}\n\t}","id":40567,"modified_method":"public static String includeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString ctxName = GetterUtil.getString(theme.getServletContextName());\n\n\t\tif (VelocityContextPool.get(ctxName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tVelocityContextPool.put(ctxName, servletContext);\n\t\t}\n\n\t\tint pos = page.lastIndexOf(StringPool.PERIOD);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(ctxName);\n\t\tsb.append(theme.getFreeMarkerTemplateLoader());\n\t\tsb.append(theme.getTemplatesPath());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(page.substring(0, pos));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(_TEMPLATE_EXTENSION_FTL);\n\n\t\tString source = sb.toString();\n\n\t\tif (!FreeMarkerEngineUtil.resourceExists(source)) {\n\t\t\t_log.error(source + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\tFreeMarkerContext freeMarkerContext =\n\t\t\tFreeMarkerEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// FreeMarker variables\n\n\t\tFreeMarkerVariables.insertVariables(freeMarkerContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = VelocityContextPool.get(ctxName);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t(HttpServletResponse)pageContext.getResponse());\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request, stringResponse, pageContext,\n\t\t\tunsyncStringWriter);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tfreeMarkerContext.put(\"themeServletContext\", themeServletContext);\n\t\tfreeMarkerContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tfreeMarkerContext.put(\"theme\", velocityTaglib);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTaglibFactory portalTaglib = new TaglibFactory(servletContext);\n\n\t\tfreeMarkerContext.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTaglibFactory themeTaglib = new TaglibFactory(themeServletContext);\n\n\t\tfreeMarkerContext.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\tFreeMarkerEngineUtil.mergeTemplate(\n\t\t\tsource, freeMarkerContext, unsyncStringWriter);\n\n\t\tif (write) {\n\t\t\tStringBundler unsyncStringWriterSB =\n\t\t\t\tunsyncStringWriter.getStringBundler();\n\n\t\t\tunsyncStringWriterSB.writeTo(pageContext.getOut());\n\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn unsyncStringWriter.toString();\n\t\t}\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String includeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString ctxName = GetterUtil.getString(theme.getServletContextName());\n\n\t\tif (VelocityContextPool.get(ctxName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tVelocityContextPool.put(ctxName, servletContext);\n\t\t}\n\n\t\tint pos = page.lastIndexOf(StringPool.PERIOD);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(ctxName);\n\t\tsb.append(theme.getVelocityResourceListener());\n\t\tsb.append(theme.getTemplatesPath());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(page.substring(0, pos));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(_TEMPLATE_EXTENSION_VM);\n\n\t\tString source = sb.toString();\n\n\t\tif (!VelocityEngineUtil.resourceExists(source)) {\n\t\t\t_log.error(source + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// Velocity variables\n\n\t\tVelocityVariables.insertVariables(velocityContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = VelocityContextPool.get(ctxName);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t(HttpServletResponse)pageContext.getResponse());\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request, stringResponse, pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tvelocityContext.put(\"themeServletContext\", themeServletContext);\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\n\t\t// Merge templates\n\n\t\tVelocityEngineUtil.mergeTemplate(\n\t\t\tsource, velocityContext, unsyncStringWriter);\n\n\t\tif (write) {\n\t\t\tStringBundler unsyncStringWriterSB =\n\t\t\t\tunsyncStringWriter.getStringBundler();\n\n\t\t\tunsyncStringWriterSB.writeTo(pageContext.getOut());\n\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn unsyncStringWriter.toString();\n\t\t}\n\t}","id":40568,"modified_method":"public static String includeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString ctxName = GetterUtil.getString(theme.getServletContextName());\n\n\t\tif (VelocityContextPool.get(ctxName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tVelocityContextPool.put(ctxName, servletContext);\n\t\t}\n\n\t\tint pos = page.lastIndexOf(StringPool.PERIOD);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(ctxName);\n\t\tsb.append(theme.getVelocityResourceListener());\n\t\tsb.append(theme.getTemplatesPath());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(page.substring(0, pos));\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(_TEMPLATE_EXTENSION_VM);\n\n\t\tString source = sb.toString();\n\n\t\tif (!VelocityEngineUtil.resourceExists(source)) {\n\t\t\t_log.error(source + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(true);\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// Velocity variables\n\n\t\tVelocityVariables.insertVariables(velocityContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = VelocityContextPool.get(ctxName);\n\n\t\t// liferay:include tag library\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t(HttpServletResponse)pageContext.getResponse());\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request, stringResponse, pageContext,\n\t\t\tunsyncStringWriter);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tvelocityContext.put(\"themeServletContext\", themeServletContext);\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\n\t\t// Merge templates\n\n\t\tVelocityEngineUtil.mergeTemplate(\n\t\t\tsource, velocityContext, unsyncStringWriter);\n\n\t\tif (write) {\n\t\t\tStringBundler unsyncStringWriterSB =\n\t\t\t\tunsyncStringWriter.getStringBundler();\n\n\t\t\tunsyncStringWriterSB.writeTo(pageContext.getOut());\n\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn unsyncStringWriter.toString();\n\t\t}\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconMinimize() throws Exception {\n\t\tIconMinimizeTag iconMinimizeTag = new IconMinimizeTag();\n\n\t\tsetUp(iconMinimizeTag);\n\n\t\treturn iconMinimizeTag.runTag();\n\t}","id":40569,"modified_method":"public void iconMinimize() throws Exception {\n\t\tIconMinimizeTag iconMinimizeTag = new IconMinimizeTag();\n\n\t\tsetUp(iconMinimizeTag);\n\n\t\ticonMinimizeTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconConfiguration() throws Exception {\n\t\tIconConfigurationTag iconConfigurationTag = new IconConfigurationTag();\n\n\t\tsetUp(iconConfigurationTag);\n\n\t\treturn iconConfigurationTag.runTag();\n\t}","id":40570,"modified_method":"public void iconConfiguration() throws Exception {\n\t\tIconConfigurationTag iconConfigurationTag = new IconConfigurationTag();\n\n\t\tsetUp(iconConfigurationTag);\n\n\t\ticonConfigurationTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconPortletCss() throws Exception {\n\t\tIconPortletCssTag iconPortletCssTag = new IconPortletCssTag();\n\n\t\tsetUp(iconPortletCssTag);\n\n\t\treturn iconPortletCssTag.runTag();\n\t}","id":40571,"modified_method":"public void iconPortletCss() throws Exception {\n\t\tIconPortletCssTag iconPortletCssTag = new IconPortletCssTag();\n\n\t\tsetUp(iconPortletCssTag);\n\n\t\ticonPortletCssTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconPortlet() throws Exception {\n\t\tIconPortletTag iconPortletTag = new IconPortletTag();\n\n\t\tsetUp(iconPortletTag);\n\n\t\treturn iconPortletTag.runTag();\n\t}","id":40572,"modified_method":"public void iconPortlet() throws Exception {\n\t\tIconPortletTag iconPortletTag = new IconPortletTag();\n\n\t\tsetUp(iconPortletTag);\n\n\t\ticonPortletTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String search() throws Exception {\n\t\tSearchTag searchTag = new SearchTag();\n\n\t\tsetUp(searchTag);\n\n\t\treturn searchTag.runTag();\n\t}","id":40573,"modified_method":"public void search() throws Exception {\n\t\tSearchTag searchTag = new SearchTag();\n\n\t\tsetUp(searchTag);\n\n\t\tsearchTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconMaximize() throws Exception {\n\t\tIconMaximizeTag iconMaximizeTag = new IconMaximizeTag();\n\n\t\tsetUp(iconMaximizeTag);\n\n\t\treturn iconMaximizeTag.runTag();\n\t}","id":40574,"modified_method":"public void iconMaximize() throws Exception {\n\t\tIconMaximizeTag iconMaximizeTag = new IconMaximizeTag();\n\n\t\tsetUp(iconMaximizeTag);\n\n\t\ticonMaximizeTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String layoutIcon(Layout layout) throws Exception {\n\t\t_stringResponse.recycle();\n\n\t\tLayoutIconTag.doTag(layout, _servletContext, _request, _stringResponse);\n\n\t\treturn _stringResponse.getString();\n\t}","id":40575,"modified_method":"public void layoutIcon(Layout layout) throws Exception {\n\t\t_stringResponse.recycle();\n\n\t\tLayoutIconTag.doTag(layout, _servletContext, _request, _stringResponse);\n\n\t\t_stringResponse.getString();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public VelocityTaglib init(\n\t\tServletContext servletContext, HttpServletRequest request,\n\t\tStringServletResponse stringResponse, PageContext pageContext) {\n\n\t\t_servletContext = servletContext;\n\t\t_request = request;\n\t\t_stringResponse = stringResponse;\n\t\t_pageContext = pageContext;\n\n\t\treturn this;\n\t}","id":40576,"modified_method":"public VelocityTaglib init(\n\t\tServletContext servletContext, HttpServletRequest request,\n\t\tStringServletResponse stringResponse, PageContext pageContext,\n\t\tWriter writer) {\n\n\t\t_servletContext = servletContext;\n\t\t_request = request;\n\t\t_stringResponse = stringResponse;\n\t\t_pageContext = pageContext;\n\t\t_writer = writer;\n\n\t\treturn this;\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconBack() throws Exception {\n\t\tIconBackTag iconBackTag = new IconBackTag();\n\n\t\tsetUp(iconBackTag);\n\n\t\treturn iconBackTag.runTag();\n\t}","id":40577,"modified_method":"public void iconBack() throws Exception {\n\t\tIconBackTag iconBackTag = new IconBackTag();\n\n\t\tsetUp(iconBackTag);\n\n\t\ticonBackTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconPrint() throws Exception {\n\t\tIconPrintTag iconPrintTag = new IconPrintTag();\n\n\t\tsetUp(iconPrintTag);\n\n\t\treturn iconPrintTag.runTag();\n\t}","id":40578,"modified_method":"public void iconPrint() throws Exception {\n\t\tIconPrintTag iconPrintTag = new IconPrintTag();\n\n\t\tsetUp(iconPrintTag);\n\n\t\ticonPrintTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String metaTags() throws Exception {\n\t\t_stringResponse.recycle();\n\n\t\tMetaTagsTag.doTag(_servletContext, _request, _stringResponse);\n\n\t\treturn _stringResponse.getString();\n\t}","id":40579,"modified_method":"public void metaTags() throws Exception {\n\t\t_stringResponse.recycle();\n\n\t\tMetaTagsTag.doTag(_servletContext, _request, _stringResponse);\n\n\t\t_stringResponse.getString();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconPortlet(Portlet portlet) throws Exception {\n\t\tIconPortletTag iconPortletTag = new IconPortletTag();\n\n\t\tsetUp(iconPortletTag);\n\n\t\ticonPortletTag.setPortlet(portlet);\n\n\t\treturn iconPortletTag.runTag();\n\t}","id":40580,"modified_method":"public void iconPortlet(Portlet portlet) throws Exception {\n\t\tIconPortletTag iconPortletTag = new IconPortletTag();\n\n\t\tsetUp(iconPortletTag);\n\n\t\ticonPortletTag.setPortlet(portlet);\n\n\t\ticonPortletTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String staging() throws Exception {\n\t\tStagingTag stagingTag = new StagingTag();\n\n\t\tsetUp(stagingTag);\n\n\t\treturn stagingTag.runTag();\n\t}","id":40581,"modified_method":"public void staging() throws Exception {\n\t\tStagingTag stagingTag = new StagingTag();\n\n\t\tsetUp(stagingTag);\n\n\t\tstagingTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String language() throws Exception {\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\treturn languageTag.runTag();\n\t}","id":40582,"modified_method":"public void language() throws Exception {\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\tlanguageTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconEdit() throws Exception {\n\t\tIconEditTag iconEditTag = new IconEditTag();\n\n\t\tsetUp(iconEditTag);\n\n\t\treturn iconEditTag.runTag();\n\t}","id":40583,"modified_method":"public void iconEdit() throws Exception {\n\t\tIconEditTag iconEditTag = new IconEditTag();\n\n\t\tsetUp(iconEditTag);\n\n\t\ticonEditTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String myPlaces(int max) throws Exception {\n\t\tMyPlacesTag myPlacesTag = new MyPlacesTag();\n\n\t\tsetUp(myPlacesTag);\n\n\t\tmyPlacesTag.setMax(max);\n\n\t\treturn myPlacesTag.runTag();\n\t}","id":40584,"modified_method":"public void myPlaces(int max) throws Exception {\n\t\tMyPlacesTag myPlacesTag = new MyPlacesTag();\n\n\t\tsetUp(myPlacesTag);\n\n\t\tmyPlacesTag.setMax(max);\n\n\t\tmyPlacesTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String breadcrumb(\n\t\t\tint displayStyle, boolean showGuestGroup, boolean showParentGroups,\n\t\t\tboolean showLayout, boolean showPortletBreadcrumb)\n\t\tthrows Exception {\n\n\t\tBreadcrumbTag breadcrumbTag = new BreadcrumbTag();\n\n\t\tsetUp(breadcrumbTag);\n\n\t\tbreadcrumbTag.setDisplayStyle(displayStyle);\n\t\tbreadcrumbTag.setShowGuestGroup(showGuestGroup);\n\t\tbreadcrumbTag.setShowLayout(showLayout);\n\t\tbreadcrumbTag.setShowParentGroups(showParentGroups);\n\t\tbreadcrumbTag.setShowPortletBreadcrumb(showPortletBreadcrumb);\n\n\t\treturn breadcrumbTag.runTag();\n\t}","id":40585,"modified_method":"public void breadcrumb(\n\t\t\tint displayStyle, boolean showGuestGroup, boolean showParentGroups,\n\t\t\tboolean showLayout, boolean showPortletBreadcrumb)\n\t\tthrows Exception {\n\n\t\tBreadcrumbTag breadcrumbTag = new BreadcrumbTag();\n\n\t\tsetUp(breadcrumbTag);\n\n\t\tbreadcrumbTag.setDisplayStyle(displayStyle);\n\t\tbreadcrumbTag.setShowGuestGroup(showGuestGroup);\n\t\tbreadcrumbTag.setShowLayout(showLayout);\n\t\tbreadcrumbTag.setShowParentGroups(showParentGroups);\n\t\tbreadcrumbTag.setShowPortletBreadcrumb(showPortletBreadcrumb);\n\n\t\tbreadcrumbTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconRefresh() throws Exception {\n\t\tIconRefreshTag iconRefreshTag = new IconRefreshTag();\n\n\t\tsetUp(iconRefreshTag);\n\n\t\treturn iconRefreshTag.runTag();\n\t}","id":40586,"modified_method":"public void iconRefresh() throws Exception {\n\t\tIconRefreshTag iconRefreshTag = new IconRefreshTag();\n\n\t\tsetUp(iconRefreshTag);\n\n\t\ticonRefreshTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconHelp() throws Exception {\n\t\tIconHelpTag iconHelpTag = new IconHelpTag();\n\n\t\tsetUp(iconHelpTag);\n\n\t\treturn iconHelpTag.runTag();\n\t}","id":40587,"modified_method":"public void iconHelp() throws Exception {\n\t\tIconHelpTag iconHelpTag = new IconHelpTag();\n\n\t\tsetUp(iconHelpTag);\n\n\t\ticonHelpTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setUp(TagSupport tagSupport) {\n\t\tStringPageContext stringPageContext = new StringPageContext(\n\t\t\t_pageContext);\n\n\t\ttagSupport.setPageContext(stringPageContext);\n\t}","id":40588,"modified_method":"protected void setUp(TagSupport tagSupport) {\n\n\t\ttagSupport.setPageContext(\n\t\t\tnew PageContextAdapter(_pageContext, _writer));\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconEditDefaults() throws Exception {\n\t\tIconEditDefaultsTag iconEditDefaultsTag = new IconEditDefaultsTag();\n\n\t\tsetUp(iconEditDefaultsTag);\n\n\t\treturn iconEditDefaultsTag.runTag();\n\t}","id":40589,"modified_method":"public void iconEditDefaults() throws Exception {\n\t\tIconEditDefaultsTag iconEditDefaultsTag = new IconEditDefaultsTag();\n\n\t\tsetUp(iconEditDefaultsTag);\n\n\t\ticonEditDefaultsTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String journalContentSearch() throws Exception {\n\t\tJournalContentSearchTag journalContentSearchTag =\n\t\t\tnew JournalContentSearchTag();\n\n\t\tsetUp(journalContentSearchTag);\n\n\t\treturn journalContentSearchTag.runTag();\n\t}","id":40590,"modified_method":"public void journalContentSearch() throws Exception {\n\t\tJournalContentSearchTag journalContentSearchTag =\n\t\t\tnew JournalContentSearchTag();\n\n\t\tsetUp(journalContentSearchTag);\n\n\t\tjournalContentSearchTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String language(\n\t\t\tString formName, String formAction, String name,\n\t\t\tString[] languageIds, int displayStyle)\n\t\tthrows Exception {\n\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\tlanguageTag.setDisplayStyle(displayStyle);\n\t\tlanguageTag.setFormAction(formAction);\n\t\tlanguageTag.setFormName(formName);\n\t\tlanguageTag.setLanguageIds(languageIds);\n\t\tlanguageTag.setName(name);\n\n\t\treturn languageTag.runTag();\n\t}","id":40591,"modified_method":"public void language(\n\t\t\tString formName, String formAction, String name,\n\t\t\tString[] languageIds, int displayStyle)\n\t\tthrows Exception {\n\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\tlanguageTag.setDisplayStyle(displayStyle);\n\t\tlanguageTag.setFormAction(formAction);\n\t\tlanguageTag.setFormName(formName);\n\t\tlanguageTag.setLanguageIds(languageIds);\n\t\tlanguageTag.setName(name);\n\n\t\tlanguageTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String myPlaces() throws Exception {\n\t\tMyPlacesTag myPlacesTag = new MyPlacesTag();\n\n\t\tsetUp(myPlacesTag);\n\n\t\treturn myPlacesTag.runTag();\n\t}","id":40592,"modified_method":"public void myPlaces() throws Exception {\n\t\tMyPlacesTag myPlacesTag = new MyPlacesTag();\n\n\t\tsetUp(myPlacesTag);\n\n\t\tmyPlacesTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String breadcrumb() throws Exception {\n\t\tBreadcrumbTag breadcrumbTag = new BreadcrumbTag();\n\n\t\tsetUp(breadcrumbTag);\n\n\t\treturn breadcrumbTag.runTag();\n\t}","id":40593,"modified_method":"public void breadcrumb() throws Exception {\n\t\tBreadcrumbTag breadcrumbTag = new BreadcrumbTag();\n\n\t\tsetUp(breadcrumbTag);\n\n\t\tbreadcrumbTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconOptions() throws Exception {\n\t\tIconOptionsTag iconOptionsTag = new IconOptionsTag();\n\n\t\tsetUp(iconOptionsTag);\n\n\t\treturn iconOptionsTag.runTag();\n\t}","id":40594,"modified_method":"public void iconOptions() throws Exception {\n\t\tIconOptionsTag iconOptionsTag = new IconOptionsTag();\n\n\t\tsetUp(iconOptionsTag);\n\n\t\ticonOptionsTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconEditGuest() throws Exception {\n\t\tIconEditGuestTag iconEditGuestTag = new IconEditGuestTag();\n\n\t\tsetUp(iconEditGuestTag);\n\n\t\treturn iconEditGuestTag.runTag();\n\t}","id":40595,"modified_method":"public void iconEditGuest() throws Exception {\n\t\tIconEditGuestTag iconEditGuestTag = new IconEditGuestTag();\n\n\t\tsetUp(iconEditGuestTag);\n\n\t\ticonEditGuestTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String iconClose() throws Exception {\n\t\tIconCloseTag iconCloseTag = new IconCloseTag();\n\n\t\tsetUp(iconCloseTag);\n\n\t\treturn iconCloseTag.runTag();\n\t}","id":40596,"modified_method":"public void iconClose() throws Exception {\n\t\tIconCloseTag iconCloseTag = new IconCloseTag();\n\n\t\tsetUp(iconCloseTag);\n\n\t\ticonCloseTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String language(\n\t\t\tString formName, String formAction, String name, int displayStyle)\n\t\tthrows Exception {\n\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\tlanguageTag.setDisplayStyle(displayStyle);\n\t\tlanguageTag.setFormAction(formAction);\n\t\tlanguageTag.setFormName(formName);\n\t\tlanguageTag.setName(name);\n\n\t\treturn languageTag.runTag();\n\t}","id":40597,"modified_method":"public void language(\n\t\t\tString formName, String formAction, String name, int displayStyle)\n\t\tthrows Exception {\n\n\t\tLanguageTag languageTag = new LanguageTag();\n\n\t\tsetUp(languageTag);\n\n\t\tlanguageTag.setDisplayStyle(displayStyle);\n\t\tlanguageTag.setFormAction(formAction);\n\t\tlanguageTag.setFormName(formName);\n\t\tlanguageTag.setName(name);\n\n\t\tlanguageTag.runTag();\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public VelocityTaglib(\n\t\tServletContext servletContext, HttpServletRequest request,\n\t\tStringServletResponse stringResponse, PageContext pageContext) {\n\n\t\tinit(servletContext, request, stringResponse, pageContext);\n\t}","id":40598,"modified_method":"public VelocityTaglib(\n\t\tServletContext servletContext, HttpServletRequest request,\n\t\tStringServletResponse stringResponse, PageContext pageContext,\n\t\tWriter writer) {\n\n\t\tinit(servletContext, request, stringResponse, pageContext, writer);\n\t}","commit_id":"75d2b9778c482712a674660b353172bdc2b32efd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Module getDistributedModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        // NOTE: order is important due to dependencies between modules\n        Map<String, DatasetModule> defaultModules = Maps.newLinkedHashMap();\n        defaultModules.put(\"orderedTable-hbase\", new HBaseOrderedTableModule());\n        defaultModules.put(\"core\", new CoreDatasetsModule());\n\n        bind(new TypeLiteral<Map<String, ? extends DatasetModule>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(defaultModules);\n\n        install(new FactoryModuleBuilder()\n                  .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                  .build(DatasetDefinitionRegistryFactory.class));\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetFramework.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetFramework.class);\n        bind(MDSDatasetsRegistry.class).in(Singleton.class);\n        bind(DatasetService.class);\n        bind(DatasetService.class);\n        expose(DatasetService.class);\n\n        Named datasetUserName = Names.named(Constants.Service.DATASET_EXECUTOR);\n        Multibinder<HttpHandler> handlerBinder = Multibinder.newSetBinder(binder(), HttpHandler.class, datasetUserName);\n        handlerBinder.addBinding().to(DatasetAdminOpHTTPHandler.class);\n        handlerBinder.addBinding().to(PingHandler.class);\n\n        bind(DatasetOpExecutorService.class).in(Scopes.SINGLETON);\n        expose(DatasetOpExecutorService.class);\n\n        bind(DatasetOpExecutor.class).to(YarnDatasetOpExecutor.class);\n        expose(DatasetOpExecutor.class);\n      }\n    };\n  }","id":40599,"modified_method":"public Module getDistributedModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        // NOTE: order is important due to dependencies between modules\n        Map<String, DatasetModule> defaultModules = Maps.newLinkedHashMap();\n        defaultModules.put(\"orderedTable-hbase\", new HBaseOrderedTableModule());\n        defaultModules.put(\"core\", new CoreDatasetsModule());\n\n        bind(new TypeLiteral<Map<String, ? extends DatasetModule>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(defaultModules);\n\n        install(new FactoryModuleBuilder()\n                  .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                  .build(DatasetDefinitionRegistryFactory.class));\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetFramework.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetFramework.class);\n        bind(MDSDatasetsRegistry.class).in(Singleton.class);\n        bind(DatasetService.class);\n        expose(DatasetService.class);\n\n        Named datasetUserName = Names.named(Constants.Service.DATASET_EXECUTOR);\n        Multibinder<HttpHandler> handlerBinder = Multibinder.newSetBinder(binder(), HttpHandler.class, datasetUserName);\n        handlerBinder.addBinding().to(DatasetAdminOpHTTPHandler.class);\n        handlerBinder.addBinding().to(PingHandler.class);\n\n        bind(DatasetOpExecutorService.class).in(Scopes.SINGLETON);\n        expose(DatasetOpExecutorService.class);\n\n        bind(DatasetOpExecutor.class).to(YarnDatasetOpExecutor.class);\n        expose(DatasetOpExecutor.class);\n      }\n    };\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetAdminOpHTTPHandler(Authenticator authenticator, RemoteDatasetFramework client) {\n    super(authenticator);\n    this.client = client;\n  }","id":40600,"modified_method":"@Inject\n  public DatasetAdminOpHTTPHandler(Authenticator authenticator, RemoteDatasetFramework dsFramework) {\n    super(authenticator);\n    this.dsFramework = dsFramework;\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"private DatasetAdmin getDatasetAdmin(String instanceName) throws IOException, DatasetManagementException {\n    DatasetAdmin admin = client.getAdmin(instanceName, null);\n    if (admin == null) {\n      throw new HandlerException(HttpResponseStatus.NOT_FOUND,\n                                 \"Couldn't obtain DatasetAdmin for dataset instance \" + instanceName);\n    }\n    return admin;\n  }","id":40601,"modified_method":"private DatasetAdmin getDatasetAdmin(String instanceName) throws IOException, DatasetManagementException {\n    DatasetAdmin admin = dsFramework.getAdmin(instanceName, null);\n    if (admin == null) {\n      throw new HandlerException(HttpResponseStatus.NOT_FOUND,\n                                 \"Couldn't obtain DatasetAdmin for dataset instance \" + instanceName);\n    }\n    return admin;\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"public OrderedTable getTypeMetaTable() throws DatasetManagementException, IOException {\n    OrderedTable table = DatasetsUtil.getOrCreateDataset(framework, META_TABLE_NAME, TABLE_TYPE,\n                                                         DatasetProperties.EMPTY, null);\n    return table;\n  }","id":40602,"modified_method":"public DatasetTypeMDS getTypeMetaTable() throws DatasetManagementException, IOException {\n    return (DatasetTypeMDS) DatasetsUtil.getOrCreateDataset(framework, META_TABLE_NAME,\n                                                            DatasetTypeMDS.class.getName(),\n                                                            DatasetProperties.EMPTY, null);\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"public OrderedTable getInstanceMetaTable() throws DatasetManagementException, IOException {\n    return DatasetsUtil.getOrCreateDataset(framework, INSTANCE_TABLE_NAME, TABLE_TYPE,\n                                           DatasetProperties.EMPTY, null);\n  }","id":40603,"modified_method":"public DatasetInstanceMDS getInstanceMetaTable() throws DatasetManagementException, IOException {\n    return (DatasetInstanceMDS) DatasetsUtil.getOrCreateDataset(framework, INSTANCE_TABLE_NAME,\n                                                                DatasetInstanceMDS.class.getName(),\n                                                                DatasetProperties.EMPTY, null);\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Sets up a {@link DatasetFramework} instance for standalone usage.  NOTE: should NOT be used by applications!!!\n   */\n  public static DatasetFramework createRegisteredDatasetFramework(DatasetDefinitionRegistry registry,\n                                                                  CConfiguration cConf)\n    throws DatasetManagementException, IOException {\n    DatasetFramework mdsDatasetFramework =\n      new NamespacedDatasetFramework(new InMemoryDatasetFramework(registry),\n                                     new ReactorDatasetNamespace(cConf, DataSetAccessor.Namespace.SYSTEM));\n    mdsDatasetFramework.addModule(DatasetMetaTableUtil.TABLE_TYPE, new HBaseOrderedTableModule());\n    mdsDatasetFramework.addInstance(DatasetMetaTableUtil.TABLE_TYPE,\n                                    DatasetMetaTableUtil.META_TABLE_NAME, DatasetProperties.EMPTY);\n    mdsDatasetFramework.addInstance(DatasetMetaTableUtil.TABLE_TYPE,\n                                    DatasetMetaTableUtil.INSTANCE_TABLE_NAME, DatasetProperties.EMPTY);\n    return mdsDatasetFramework;\n\n  }","id":40604,"modified_method":"/**\n   * Sets up a {@link DatasetFramework} instance for standalone usage.  NOTE: should NOT be used by applications!!!\n   */\n  public static DatasetFramework createRegisteredDatasetFramework(DatasetDefinitionRegistry registry,\n                                                                  CConfiguration cConf)\n    throws DatasetManagementException, IOException {\n    DatasetFramework mdsDatasetFramework =\n      new NamespacedDatasetFramework(new InMemoryDatasetFramework(registry),\n                                     new ReactorDatasetNamespace(cConf, DataSetAccessor.Namespace.SYSTEM));\n    mdsDatasetFramework.addModule(\"orderedTable\", new HBaseOrderedTableModule());\n    addTypes(mdsDatasetFramework);\n    mdsDatasetFramework.addInstance(DatasetTypeMDS.class.getName(),\n                                    DatasetMetaTableUtil.META_TABLE_NAME, DatasetProperties.EMPTY);\n    mdsDatasetFramework.addInstance(DatasetInstanceMDS.class.getName(),\n                                    DatasetMetaTableUtil.INSTANCE_TABLE_NAME, DatasetProperties.EMPTY);\n    return mdsDatasetFramework;\n\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"@DELETE\n  @Path(\"/data/modules\")\n  public void deleteModules(HttpRequest request, final HttpResponder responder) {\n    try {\n      manager.deleteModules();\n    } catch (DatasetModuleConflictException e) {\n      responder.sendError(HttpResponseStatus.CONFLICT, e.getMessage());\n      return;\n    }\n    responder.sendStatus(HttpResponseStatus.OK);\n  }","id":40605,"modified_method":"@DELETE\n  @Path(\"/data/modules\")\n  public void deleteModules(HttpRequest request, final HttpResponder responder) {\n    try {\n      manager.deleteModules();\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (DatasetModuleConflictException e) {\n      responder.sendError(HttpResponseStatus.CONFLICT, e.getMessage());\n    }\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"MDSDatasets(Map<String, Dataset> datasets) {\n    super(datasets);\n  }","id":40606,"modified_method":"MDSDatasets(Map<String, ? extends Dataset> datasets) {\n    super(datasets);\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void startUp() throws Exception {\n    for (Map.Entry<String, ? extends DatasetModule> moduleEntry : defaultModules.entrySet()) {\n      dsFramework.addModule(moduleEntry.getKey(), moduleEntry.getValue());\n    }\n\n    dsFramework.addModule(\"typeMDSModule\", new SingleTypeModule(DatasetTypeMDS.class));\n    dsFramework.addModule(\"instanceMDSModule\", new SingleTypeModule(DatasetInstanceMDS.class));\n\n    DatasetsUtil.createIfNotExists(dsFramework, \"datasets.instance\",\n                                                DatasetInstanceMDS.class.getName(),\n                                                DatasetProperties.EMPTY);\n\n    DatasetsUtil.createIfNotExists(dsFramework, \"datasets.type\",\n                                              DatasetTypeMDS.class.getName(),\n                                              DatasetProperties.EMPTY);\n  }","id":40607,"modified_method":"@Override\n  public void startUp() throws Exception {\n    for (Map.Entry<String, ? extends DatasetModule> moduleEntry : defaultModules.entrySet()) {\n      dsFramework.addModule(moduleEntry.getKey(), moduleEntry.getValue());\n    }\n\n    this.util = new DatasetMetaTableUtil(dsFramework);\n    this.util.init();\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected MDSDatasets createContext() throws IOException, DatasetManagementException {\n    Map<String, Dataset> datasets = ImmutableMap.of(\n      // \"null\" for class being in system classpath, for mds it is always true\n      \"datasets.instance\", dsFramework.getDataset(\"datasets.instance\", null),\n      \"datasets.type\", dsFramework.getDataset(\"datasets.type\", null)\n    );\n\n    return new MDSDatasets(datasets);\n  }","id":40608,"modified_method":"@Override\n  protected MDSDatasets createContext() throws IOException, DatasetManagementException {\n    Map<String, ? extends Dataset> datasets = ImmutableMap.of(\n      // \"null\" for class being in system classpath, for mds it is always true\n      DatasetMetaTableUtil.INSTANCE_TABLE_NAME, util.getInstanceMetaTable(),\n      DatasetMetaTableUtil.META_TABLE_NAME, util.getTypeMetaTable()\n    );\n\n    return new MDSDatasets(datasets);\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public static final <T> ObjectResponse<T> fromJsonBody(HttpResponse response, Type typeOfObject) {\n    T object = response.getResponseBody() == null ?\n      null : (T) GSON.fromJson(new String(response.getResponseBody(), Charsets.UTF_8), typeOfObject);\n    return new ObjectResponse<T>(response, object);\n  }","id":40609,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public static <T> ObjectResponse<T> fromJsonBody(HttpResponse response, Type typeOfObject) {\n    return fromJsonBody(response, typeOfObject, GSON);\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"private void performUpgrade(Injector injector) throws Exception {\n    DataSetAccessor accessor = injector.getInstance(DataSetAccessor.class);\n    QueueAdmin queueAdmin = injector.getInstance(QueueAdmin.class);\n    StreamAdmin streamAdmin = injector.getInstance(StreamAdmin.class);\n    MetricsTableFactory metricsTableFactory = injector.getInstance(MetricsTableFactory.class);\n    MetaDataTable metaDataTable = injector.getInstance(MetaDataTable.class);\n    LogSaverTableUtil logSaverUtil = injector.getInstance(LogSaverTableUtil.class);\n    ScheduleStoreTableUtil scheduleStoreUtil = injector.getInstance(ScheduleStoreTableUtil.class);\n\n    DatasetFramework framework = getDatasetFramework(injector);\n    DatasetMetaTableUtil datasetTableUtil = new DatasetMetaTableUtil(framework);\n\n    // Upgrade all user tables.\n    Properties properties = new Properties();\n    for (Map.Entry<String, Class<?>> entry : accessor.list(DataSetAccessor.Namespace.USER).entrySet()) {\n      DataSetManager manager = accessor.getDataSetManager(entry.getValue(), DataSetAccessor.Namespace.USER);\n      manager.upgrade(entry.getKey(), properties);\n    }\n\n    // Upgrade all queue and stream tables.\n    queueAdmin.upgrade();\n    streamAdmin.upgrade();\n\n    // Upgrade the metadata table\n    metaDataTable.upgrade();\n\n    // Upgrade schedule store\n    scheduleStoreUtil.upgrade();\n\n    // Upgrade log saver meta table\n    logSaverUtil.upgrade();\n\n    // Upgrade the dataset types table\n    datasetTableUtil.upgrade();\n\n    // Upgrade metrics table\n    metricsTableFactory.upgrade();\n  }","id":40610,"modified_method":"private void performUpgrade(Injector injector) throws Exception {\n    DataSetAccessor accessor = injector.getInstance(DataSetAccessor.class);\n    QueueAdmin queueAdmin = injector.getInstance(QueueAdmin.class);\n    StreamAdmin streamAdmin = injector.getInstance(StreamAdmin.class);\n    MetricsTableFactory metricsTableFactory = injector.getInstance(MetricsTableFactory.class);\n    MetaDataTable metaDataTable = injector.getInstance(MetaDataTable.class);\n    LogSaverTableUtil logSaverUtil = injector.getInstance(LogSaverTableUtil.class);\n    ScheduleStoreTableUtil scheduleStoreUtil = injector.getInstance(ScheduleStoreTableUtil.class);\n\n    DatasetFramework framework = getDatasetFramework(injector);\n    DatasetMetaTableUtil datasetTableUtil = new DatasetMetaTableUtil(framework);\n    datasetTableUtil.init();\n\n    // Upgrade all user tables.\n    Properties properties = new Properties();\n    for (Map.Entry<String, Class<?>> entry : accessor.list(DataSetAccessor.Namespace.USER).entrySet()) {\n      DataSetManager manager = accessor.getDataSetManager(entry.getValue(), DataSetAccessor.Namespace.USER);\n      manager.upgrade(entry.getKey(), properties);\n    }\n\n    // Upgrade all queue and stream tables.\n    queueAdmin.upgrade();\n    streamAdmin.upgrade();\n\n    // Upgrade the metadata table\n    metaDataTable.upgrade();\n\n    // Upgrade schedule store\n    scheduleStoreUtil.upgrade();\n\n    // Upgrade log saver meta table\n    logSaverUtil.upgrade();\n\n    // Upgrade the dataset types table\n    datasetTableUtil.upgrade();\n\n    // Upgrade metrics table\n    metricsTableFactory.upgrade();\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"protected TxContext(Map<String, Dataset> datasets) {\n    this.datasets = datasets;\n  }","id":40611,"modified_method":"protected TxContext(Map<String, ? extends Dataset> datasets) {\n    this.datasets = datasets;\n  }","commit_id":"f923701d75c6450240eb39b91a8a6c6bdacdeb40","url":"https://github.com/caskdata/cdap"},{"original_method":"private byte[] getColumnFamily(String tableName) throws DatasetManagementException {\n    // add old table for getting dataset spec\n    getOrCreateKafkaTable(tableName, DatasetProperties.EMPTY);\n    DatasetSpecification specification =\n      dsFramework.getDatasetSpec(Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE_ID, tableName));\n    return HBaseTableAdmin.getColumnFamily(specification);\n  }","id":40612,"modified_method":"private byte[] getColumnFamily(String tableName) throws DatasetManagementException, IOException {\n    // add old table for getting dataset spec\n    MetricsTable table = getOrCreateKafkaTable(tableName);\n    try {\n      DatasetSpecification specification =\n        dsFramework.getDatasetSpec(Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE_ID, tableName));\n      return HBaseTableAdmin.getColumnFamily(specification);\n    } finally {\n      table.close();\n    }\n  }","commit_id":"b94f194e2f0c8f13cba6e136c7798cf8e3fec9db","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public MetricsKafkaUpgrader(CConfiguration cConf, Configuration hConf, LocationFactory locationFactory,\n                              HBaseTableUtil hBaseTableUtil, final DatasetFramework dsFramework) {\n    super(locationFactory);\n    this.cConf = cConf;\n    this.hConf = hConf;\n    this.hBaseTableUtil = hBaseTableUtil;\n    this.dsFramework = dsFramework;\n    this.kafkaTableName =  cConf.get(MetricsConstants.ConfigKeys.KAFKA_META_TABLE,\n                                     MetricsConstants.DEFAULT_KAFKA_META_TABLE);\n  }","id":40613,"modified_method":"@Inject\n  public MetricsKafkaUpgrader(CConfiguration cConf, Configuration hConf, LocationFactory locationFactory,\n                              HBaseTableUtil hBaseTableUtil, final DatasetFramework dsFramework) {\n    super(locationFactory);\n    this.cConf = cConf;\n    this.hConf = hConf;\n    this.hBaseTableUtil = hBaseTableUtil;\n    this.dsFramework = dsFramework;\n    this.oldKafkaMetricsTableName =  Joiner.on(\".\").join(Constants.SYSTEM_NAMESPACE, \"default\",\n                                                         cConf.get(MetricsConstants.ConfigKeys.KAFKA_META_TABLE,\n                                                                   MetricsConstants.DEFAULT_KAFKA_META_TABLE));\n  }","commit_id":"b94f194e2f0c8f13cba6e136c7798cf8e3fec9db","url":"https://github.com/caskdata/cdap"},{"original_method":"private MetricsTable getOrCreateKafkaTable(String tableName, DatasetProperties props) {\n    MetricsTable table = null;\n    // old kafka table is in the default namespace\n    Id.DatasetInstance metricsDatasetInstanceId = Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE_ID, tableName);\n    try {\n      table = DatasetsUtil.getOrCreateDataset(dsFramework, metricsDatasetInstanceId,\n                                              MetricsTable.class.getName(), props, null, null);\n    } catch (Exception e) {\n      LOG.error(\"Exception while creating table {}.\", tableName, e);\n    }\n    return table;\n  }","id":40614,"modified_method":"private MetricsTable getOrCreateKafkaTable(String tableName) {\n    // old kafka table is in the default namespace\n    Id.DatasetInstance metricsDatasetInstanceId = Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE_ID, tableName);\n    try {\n      return DatasetsUtil.getOrCreateDataset(dsFramework, metricsDatasetInstanceId,\n                                              MetricsTable.class.getName(), DatasetProperties.EMPTY, null, null);\n    } catch (Exception e) {\n      LOG.error(\"Exception while getting table {}.\", tableName, e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"b94f194e2f0c8f13cba6e136c7798cf8e3fec9db","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void upgrade() throws Exception {\n    KafkaConsumerMetaTable kafkaMetaTableDestination =\n      new DefaultMetricDatasetFactory(cConf, dsFramework).createKafkaConsumerMeta();\n    // copy kafka offset from old table to new kafka metrics tabl\n    String kafkaTableNameOld = Joiner.on(\".\").join(Constants.SYSTEM_NAMESPACE, \"default\", kafkaTableName);\n    try {\n      // assuming we are migrating from 2.6 or 2.7\n      HTable hTable = getHTable(kafkaTableNameOld);\n      byte[] columnFamily = getColumnFamily(kafkaTableNameOld);\n\n      // iterate old table and copy all rows to the new kafkaConsumerMetaTable\n      try {\n        LOG.info(\"Starting upgrade for table {}\", Bytes.toString(hTable.getTableName()));\n        Scan scan = getScan(columnFamily);\n        ResultScanner resultScanner = hTable.getScanner(scan);\n        Result result;\n        try {\n          while ((result = resultScanner.next()) != null) {\n            TopicPartition topicPartition = getTopicPartition(result.getRow());\n            if (topicPartition != null) {\n              long value  = Bytes.toLong(result.getFamilyMap(columnFamily).get(OFFSET_COLUMN));\n              kafkaMetaTableDestination.save(ImmutableMap.of(topicPartition, value));\n            } else {\n              LOG.warn(\"Invalid topic partition found {}\", Bytes.toStringBinary(result.getRow()));\n            }\n          }\n          LOG.info(\"Successfully completed upgrade for table {}\", Bytes.toString(hTable.getTableName()));\n        } finally {\n          resultScanner.close();\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception during upgrading metrics-kafka table {}\", e);\n        throw Throwables.propagate(e);\n      } finally {\n        hTable.close();\n      }\n    } catch (IOException e) {\n      LOG.info(\"Unable to find table {}\", kafkaTableNameOld);\n    }\n  }","id":40615,"modified_method":"@Override\n  public void upgrade() throws Exception {\n    // todo : close the KafkaConsumerMetaTable after it implements closeable\n    KafkaConsumerMetaTable kafkaMetaTableDestination =\n      new DefaultMetricDatasetFactory(cConf, dsFramework).createKafkaConsumerMeta();\n    // copy kafka offset from old table to new kafka metrics table\n\n    try {\n      // assuming we are migrating from 2.6\n      HTable hTable = getHTable(oldKafkaMetricsTableName);\n      // iterate old table and copy all rows to the new kafkaConsumerMetaTable\n      try {\n        byte[] columnFamily = getColumnFamily(oldKafkaMetricsTableName);\n        LOG.info(\"Starting upgrade for table {}\", Bytes.toString(hTable.getTableName()));\n        Scan scan = getScan(columnFamily);\n        ResultScanner resultScanner = hTable.getScanner(scan);\n        try {\n          Result result;\n          while ((result = resultScanner.next()) != null) {\n            TopicPartition topicPartition = getTopicPartition(result.getRow());\n            if (topicPartition != null) {\n              long value  = Bytes.toLong(result.getFamilyMap(columnFamily).get(OFFSET_COLUMN));\n              kafkaMetaTableDestination.save(ImmutableMap.of(topicPartition, value));\n            } else {\n              LOG.warn(\"Invalid topic partition found {}\", Bytes.toStringBinary(result.getRow()));\n            }\n          }\n          LOG.info(\"Successfully completed upgrade for table {}\", Bytes.toString(hTable.getTableName()));\n        } finally {\n          resultScanner.close();\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception during upgrading metrics-kafka table {}\", e);\n        throw Throwables.propagate(e);\n      } finally {\n        hTable.close();\n      }\n    } catch (IOException e) {\n      LOG.info(\"Unable to find table {}\", oldKafkaMetricsTableName);\n    }\n  }","commit_id":"b94f194e2f0c8f13cba6e136c7798cf8e3fec9db","url":"https://github.com/caskdata/cdap"},{"original_method":"private void performUpgrade() throws Exception {\n    LOG.info(\"Upgrading System and User Datasets ...\");\n    HBaseAdmin hBaseAdmin = new HBaseAdmin(hConf);\n    DatasetUpgrader dsUpgrade = injector.getInstance(DatasetUpgrader.class);\n    dsUpgrade.upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, dsUpgrade.getDatasetInstanceMDSUpgrader().getOldDatasetInstanceTableId());\n    hBaseTableUtil.dropTable(hBaseAdmin, dsUpgrade.getDatasetTypeMDSUpgrader().getOldDatasetTypeTableId());\n\n    LOG.info(\"Upgrading application metadata ...\");\n    MDSUpgrader mdsUpgrader = injector.getInstance(MDSUpgrader.class);\n    mdsUpgrader.upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, mdsUpgrader.getOldAppMetaTableId());\n\n    LOG.info(\"Upgrading archives and files ...\");\n    ArchiveUpgrader archiveUpgrader = injector.getInstance(ArchiveUpgrader.class);\n    archiveUpgrader.upgrade();\n\n    LOG.info(\"Upgrading logs meta data ...\");\n    getFileMetaDataManager().upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, getFileMetaDataManager().getOldLogMetaTableId());\n\n    LOG.info(\"Upgrading stream state store table ...\");\n    StreamStateStoreUpgrader streamStateStoreUpgrader = injector.getInstance(StreamStateStoreUpgrader.class);\n    streamStateStoreUpgrader.upgrade();\n\n    LOG.info(\"Upgrading queue.config table ...\");\n    QueueConfigUpgrader queueConfigUpgrader = injector.getInstance(QueueConfigUpgrader.class);\n    queueConfigUpgrader.upgrade();\n\n    LOG.info(\"Upgrading metrics.kafka.meta table ...\");\n    MetricsKafkaUpgrader metricsKafkaUpgrader = injector.getInstance(MetricsKafkaUpgrader.class);\n    metricsKafkaUpgrader.upgrade();\n  }","id":40616,"modified_method":"private void performUpgrade() throws Exception {\n    LOG.info(\"Upgrading System and User Datasets ...\");\n    HBaseAdmin hBaseAdmin = new HBaseAdmin(hConf);\n    DatasetUpgrader dsUpgrade = injector.getInstance(DatasetUpgrader.class);\n    dsUpgrade.upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, dsUpgrade.getDatasetInstanceMDSUpgrader().getOldDatasetInstanceTableId());\n    hBaseTableUtil.dropTable(hBaseAdmin, dsUpgrade.getDatasetTypeMDSUpgrader().getOldDatasetTypeTableId());\n\n    LOG.info(\"Upgrading application metadata ...\");\n    MDSUpgrader mdsUpgrader = injector.getInstance(MDSUpgrader.class);\n    mdsUpgrader.upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, mdsUpgrader.getOldAppMetaTableId());\n\n    LOG.info(\"Upgrading archives and files ...\");\n    ArchiveUpgrader archiveUpgrader = injector.getInstance(ArchiveUpgrader.class);\n    archiveUpgrader.upgrade();\n\n    LOG.info(\"Upgrading logs meta data ...\");\n    getFileMetaDataManager().upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, getFileMetaDataManager().getOldLogMetaTableId());\n\n    LOG.info(\"Upgrading stream state store table ...\");\n    StreamStateStoreUpgrader streamStateStoreUpgrader = injector.getInstance(StreamStateStoreUpgrader.class);\n    streamStateStoreUpgrader.upgrade();\n\n    LOG.info(\"Upgrading queue.config table ...\");\n    QueueConfigUpgrader queueConfigUpgrader = injector.getInstance(QueueConfigUpgrader.class);\n    queueConfigUpgrader.upgrade();\n\n    LOG.info(\"Upgrading metrics.kafka.meta table ...\");\n    MetricsKafkaUpgrader metricsKafkaUpgrader = injector.getInstance(MetricsKafkaUpgrader.class);\n    metricsKafkaUpgrader.upgrade();\n    hBaseTableUtil.dropTable(hBaseAdmin, metricsKafkaUpgrader.getOldKafkaMetricsTableId());\n  }","commit_id":"b94f194e2f0c8f13cba6e136c7798cf8e3fec9db","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public boolean apply(Game game, Ability ability) {\n        Player controller = game.getPlayer(ability.getControllerId());\n        MageObject sourceObject = game.getObject(ability.getSourceId());\n        if (controller != null) {\n            Set<String> chosenTypes = new HashSet<>();\n            for (UUID playerId : controller.getInRange()) {\n                Player player = game.getPlayer(playerId);\n                Choice typeChoice = new ChoiceImpl(true);\n                typeChoice.setMessage(\"Choose a creature type\");\n                typeChoice.setChoices(CardRepository.instance.getCreatureTypes());\n                while (!player.choose(Outcome.DestroyPermanent, typeChoice, game)) {\n                    if (!player.canRespond()) {\n                        break;\n                    }\n                }\n                String chosenType = typeChoice.getChoice();\n                if (chosenType != null) {\n                    game.informPlayers(sourceObject.getName() + \": \" + player.getLogName() + \" has chosen \" + chosenType);\n                    chosenTypes.add(chosenType);\n                }\n            }\n            \n            List<SubtypePredicate> predicates = new ArrayList<>();\n            for (String type : chosenTypes) {\n                predicates.add((SubtypePredicate) Predicates.not(new SubtypePredicate(type)));\n            }\n            FilterPermanent filter = new FilterCreaturePermanent(\"creatures\");\n            filter.add(Predicates.or(predicates));\n            \n            return (new DestroyAllEffect(filter, true)).apply(game, ability);\n        }\n        return false;\n    }","id":40617,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            Set<String> chosenTypes = new HashSet<>();\n            for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game) ) {\n                Player player = game.getPlayer(playerId);\n                Choice typeChoice = new ChoiceImpl(true);\n                typeChoice.setMessage(\"Choose a creature type\");\n                typeChoice.setChoices(CardRepository.instance.getCreatureTypes());\n                while (!player.choose(Outcome.DestroyPermanent, typeChoice, game)) {\n                    if (!player.canRespond()) {\n                        continue;\n                    }\n                }\n                String chosenType = typeChoice.getChoice();\n                if (chosenType != null) {\n                    game.informPlayers(sourceObject.getIdName() + \": \" + player.getLogName() + \" has chosen \" + chosenType);\n                    chosenTypes.add(chosenType);\n                }\n            }\n\n            FilterPermanent filter = new FilterCreaturePermanent(\"creatures\");\n            for (String type : chosenTypes) {\n                filter.add(Predicates.not(new SubtypePredicate(type)));\n            }\n                       \n\n            return (new DestroyAllEffect(filter, true)).apply(game, source);\n        }\n        return false;\n    }","commit_id":"9188fe20881768b829261333030b3cfb9f373655","url":"https://github.com/magefree/mage"},{"original_method":"public VerdelothTheAncient(UUID ownerId) {\r\n        super(ownerId, 220, \"Verdeloth the Ancient\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{4}{G}{G}\");\r\n        this.expansionSetCode = \"INV\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Treefolk\");\r\n\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(7);\r\n\r\n        // Kicker {X}\r\n        this.addAbility(new KickerAbility(\"{X}\"));\r\n        // Saproling creatures and other Treefolk creatures get +1/+1.\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent(\"Saproling creatures and other Treefolk creatures\");\r\n        filter.add(Predicates.or(\r\n                Predicates.and(new SubtypePredicate(\"Treefolk\"), Predicates.not(new PermanentIdPredicate(this.getId())),\r\n                new SubtypePredicate(\"Saproling\"))));\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1,1, Duration.WhileOnBattlefield, filter, false)));\r\n        // When Verdeloth the Ancient enters the battlefield, if it was kicked, put X 1/1 green Saproling creature tokens onto the battlefield.\r\n        EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new SaprolingToken(), new GetKickerXValue()), false);\r\n        this.addAbility(new ConditionalTriggeredAbility(ability, KickedCondition.getInstance(), \r\n                \"When {this} enters the battlefield, if it was kicked, put X 1/1 green Saproling creature tokens onto the battlefield.\"));\r\n    }","id":40618,"modified_method":"public VerdelothTheAncient(UUID ownerId) {\r\n        super(ownerId, 220, \"Verdeloth the Ancient\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{4}{G}{G}\");\r\n        this.expansionSetCode = \"INV\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Treefolk\");\r\n\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(7);\r\n\r\n        // Kicker {X}\r\n        this.addAbility(new KickerAbility(\"{X}\"));\r\n        \r\n        // Saproling creatures and other Treefolk creatures get +1/+1.\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent(\"Saproling creatures and other Treefolk creatures\");\r\n        filter.add(Predicates.or(\r\n                new SubtypePredicate(\"Treefolk\"),\r\n                new SubtypePredicate(\"Saproling\")));\r\n        filter.add(Predicates.not(new PermanentIdPredicate(this.getId())));\r\n                \r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1,1, Duration.WhileOnBattlefield, filter, false)));\r\n        \r\n        // When Verdeloth the Ancient enters the battlefield, if it was kicked, put X 1/1 green Saproling creature tokens onto the battlefield.\r\n        EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new SaprolingToken(), new GetKickerXValue()), false);\r\n        this.addAbility(new ConditionalTriggeredAbility(ability, KickedCondition.getInstance(), \r\n                \"When {this} enters the battlefield, if it was kicked, put X 1/1 green Saproling creature tokens onto the battlefield.\"));\r\n        \r\n    }","commit_id":"8b76e13c255546cc17696f45c338068f33433848","url":"https://github.com/magefree/mage"},{"original_method":"public String generateTopology( ) {\n    StringBuilder buf = new StringBuilder( );\n    Multimap<String, String> networks = ArrayListMultimap.create( );\n    Multimap<String, String> rules = ArrayListMultimap.create( );\n    EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      Predicate<VmInstance> filter = Predicates.not( Predicates.or( VmState.TERMINATED, VmState.STOPPED ) );\n      for ( VmInstance vm : VmInstances.list( filter ) ) {\n        for ( NetworkGroup ruleGroup : vm.getNetworkGroups( ) ) {\n          try {\n            ruleGroup = Entities.merge( ruleGroup );\n            networks.put( ruleGroup.getClusterNetworkName( ), vm.getPrivateAddress( ) );\n            if ( !rules.containsKey( ruleGroup.getNaturalId( ) ) ) {\n              for ( NetworkRule netRule : ruleGroup.getNetworkRules( ) ) {\n                try {\n                  String rule = String.format( \"-P %s -%s %d%s%d \", netRule.getProtocol( ), ( NetworkRule.Protocol.icmp.equals( netRule.getProtocol( ) )\n                    ? \"t\"\n                    : \"p\" ), netRule.getLowPort( ), ( NetworkRule.Protocol.icmp.equals( netRule.getProtocol( ) )\n                    ? \":\"\n                    : \"-\" ), netRule.getHighPort( ) );\n                  for ( NetworkPeer peer : netRule.getNetworkPeers( ) ) {\n                    String ruleString = String.format( \"%s -o %s -u %s\", rule, peer.getGroupName( ), peer.getUserQueryKey( ) );\n                    if ( !rules.get( ruleGroup.getClusterNetworkName( ) ).contains( ruleString ) ) {\n                      rules.put( ruleGroup.getClusterNetworkName( ), ruleString );\n                    }\n                  }\n                  for ( String cidr : netRule.getIpRanges( ) ) {\n                    String ruleString = String.format( \"%s -s %s\", rule, cidr );\n                    if ( !rules.get( ruleGroup.getClusterNetworkName( ) ).contains( ruleString ) ) {\n                      rules.put( ruleGroup.getClusterNetworkName( ), ruleString );\n                    }\n                  }\n                } catch ( Exception ex ) {\n                  LOG.error( ex, ex );\n                }\n              }\n            }\n          } catch ( Exception ex ) {\n            LOG.error( ex, ex );\n          }\n        }\n      }\n      buf.append( rulesToString( rules ) );\n      buf.append( groupsToString( networks ) );\n      db.rollback( );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      db.rollback( );\n    }\n    return buf.toString( );\n  }","id":40619,"modified_method":"public String generateTopology( ) {\n    StringBuilder buf = new StringBuilder( );\n    Multimap<String, String> networks = ArrayListMultimap.create( );\n    Multimap<String, String> rules = ArrayListMultimap.create( );\n    EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      Predicate<VmInstance> filter = Predicates.and( VmState.TERMINATED.not( ), VmState.STOPPED.not( ) );\n      for ( VmInstance vm : VmInstances.list( filter ) ) {\n        try {\n          for ( NetworkGroup ruleGroup : vm.getNetworkGroups( ) ) {\n            try {\n              ruleGroup = Entities.merge( ruleGroup );\n              networks.put( ruleGroup.getClusterNetworkName( ), vm.getPrivateAddress( ) );\n              if ( !rules.containsKey( ruleGroup.getNaturalId( ) ) ) {\n                for ( NetworkRule netRule : ruleGroup.getNetworkRules( ) ) {\n                  try {\n                    String rule = String.format( \"-P %s -%s %d%s%d \", netRule.getProtocol( ), ( NetworkRule.Protocol.icmp.equals( netRule.getProtocol( ) )\n                      ? \"t\"\n                      : \"p\" ), netRule.getLowPort( ), ( NetworkRule.Protocol.icmp.equals( netRule.getProtocol( ) )\n                      ? \":\"\n                      : \"-\" ), netRule.getHighPort( ) );\n                    for ( NetworkPeer peer : netRule.getNetworkPeers( ) ) {\n                      String ruleString = String.format( \"%s -o %s -u %s\", rule, peer.getGroupName( ), peer.getUserQueryKey( ) );\n                      if ( !rules.get( ruleGroup.getClusterNetworkName( ) ).contains( ruleString ) ) {\n                        rules.put( ruleGroup.getClusterNetworkName( ), ruleString );\n                      }\n                    }\n                    for ( String cidr : netRule.getIpRanges( ) ) {\n                      String ruleString = String.format( \"%s -s %s\", rule, cidr );\n                      if ( !rules.get( ruleGroup.getClusterNetworkName( ) ).contains( ruleString ) ) {\n                        rules.put( ruleGroup.getClusterNetworkName( ), ruleString );\n                      }\n                    }\n                  } catch ( Exception ex ) {\n                    LOG.error( ex, ex );\n                  }\n                }\n              }\n            } catch ( Exception ex ) {\n              LOG.error( ex, ex );\n            }\n          }\n        } catch ( Exception ex ) {\n          LOG.error( ex , ex );\n        }\n      }\n      buf.append( rulesToString( rules ) );\n      buf.append( groupsToString( networks ) );\n      db.rollback( );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      db.rollback( );\n    }\n    return buf.toString( );\n  }","commit_id":"07e813130cdf7ecb79796b4e03db8ad72a3da94f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, @NotNull final PsiElement element) throws IncorrectOperationException {\n    final PsiLocalVariable variable = PsiTreeUtil.getParentOfType(element, PsiLocalVariable.class);\n    if (variable == null) return;\n    final PsiExpression initializer = variable.getInitializer();\n    if (initializer == null) return;\n    final PsiElement declaration = variable.getParent();\n    if (!(declaration instanceof PsiDeclarationStatement)) return;\n    final PsiElement codeBlock = declaration.getParent();\n    if (!(codeBlock instanceof PsiCodeBlock)) return;\n\n    PsiElement firstStatement = declaration.getNextSibling(), lastUsage = null;\n    final Collection<PsiReference> references = ReferencesSearch.search(variable, new LocalSearchScope(codeBlock)).findAll();\n    for (PsiReference reference : references) {\n      final PsiElement statement = PsiTreeUtil.findPrevParent(codeBlock, reference.getElement());\n      if ((lastUsage == null || statement.getTextOffset() > lastUsage.getTextOffset())) {\n        lastUsage = statement;\n      }\n    }\n\n    final String text = \"try (\" + variable.getTypeElement().getText() + \" \" + variable.getName() + \" = \" + initializer.getText() + \") {}\";\n    final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n    final PsiStatement armStatement = factory.createStatementFromText(text, codeBlock);\n    final PsiElement newElement = declaration.replace(armStatement);\n\n    if (firstStatement != null && lastUsage != null) {\n      final PsiCodeBlock tryBlock = ((PsiTryStatement)newElement).getTryBlock();\n      assert tryBlock != null : newElement.getText();\n      final PsiJavaToken rBrace = tryBlock.getRBrace();\n      assert rBrace != null : newElement.getText();\n\n      tryBlock.addRangeBefore(firstStatement, lastUsage, rBrace);\n      codeBlock.deleteChildRange(firstStatement, lastUsage);\n    }\n\n    final PsiElement formattedElement = CodeStyleManager.getInstance(project).reformat(newElement);\n\n    if (lastUsage == null) {\n      final PsiCodeBlock tryBlock = ((PsiTryStatement)formattedElement).getTryBlock();\n      if (tryBlock != null) {\n        final PsiJavaToken brace = tryBlock.getLBrace();\n        if (brace != null) {\n          editor.getCaretModel().moveToOffset(brace.getTextOffset() + 1);\n        }\n      }\n    }\n  }","id":40620,"modified_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, @NotNull final PsiElement element) throws IncorrectOperationException {\n    final PsiLocalVariable variable = PsiTreeUtil.getParentOfType(element, PsiLocalVariable.class);\n    if (variable == null) return;\n    final PsiExpression initializer = variable.getInitializer();\n    if (initializer == null) return;\n    final PsiElement declaration = variable.getParent();\n    if (!(declaration instanceof PsiDeclarationStatement)) return;\n    final PsiElement codeBlock = declaration.getParent();\n    if (!(codeBlock instanceof PsiCodeBlock)) return;\n\n    final LocalSearchScope scope = new LocalSearchScope(codeBlock);\n    PsiElement last = null;\n    for (PsiReference reference : ReferencesSearch.search(variable, scope).findAll()) {\n      final PsiElement usage = PsiTreeUtil.findPrevParent(codeBlock, reference.getElement());\n      if ((last == null || usage.getTextOffset() > last.getTextOffset())) {\n        last = usage;\n      }\n    }\n\n    final String text = \"try (\" + variable.getTypeElement().getText() + \" \" + variable.getName() + \" = \" + initializer.getText() + \") {}\";\n    final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n    final PsiTryStatement armStatement = (PsiTryStatement)declaration.replace(factory.createStatementFromText(text, codeBlock));\n\n    List<PsiElement> toFormat = null;\n    if (last != null) {\n      final PsiElement first = armStatement.getNextSibling();\n      if (first != null) {\n        toFormat = moveStatements(first, last, armStatement);\n      }\n    }\n\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n    final PsiElement formattedElement = codeStyleManager.reformat(armStatement);\n    if (toFormat != null) {\n      for (PsiElement psiElement : toFormat) {\n        codeStyleManager.reformat(psiElement);\n      }\n    }\n\n    if (last == null) {\n      final PsiCodeBlock tryBlock = ((PsiTryStatement)formattedElement).getTryBlock();\n      if (tryBlock != null) {\n        final PsiJavaToken brace = tryBlock.getLBrace();\n        if (brace != null) {\n          editor.getCaretModel().moveToOffset(brace.getTextOffset() + 1);\n        }\n      }\n    }\n  }","commit_id":"eb25a5dda0402bfb1c8ce206d93d1847f696907e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest(boolean exists) {\n    myFixture.configureByFile(getTestName(true) + \"/Test.groovy\");\n    String hint = GroovyIntentionsBundle.message(\"convert.map.to.class.intention.name\");\n    final List<IntentionAction> list = myFixture.filterAvailableIntentions(hint);\n    if (!exists) {\n      assertEmpty(list);\n      return;\n    }\n    assertOneElement(list);\n    final PsiElement element = myFixture.getFile().findElementAt(myFixture.getEditor().getCaretModel().getOffset());\n    final GrListOrMap map = PsiTreeUtil.getParentOfType(element, GrListOrMap.class);\n    assertNotNull(map);\n    final GrTypeDefinition foo = ConvertMapToClassIntention.createClass(getProject(), map.getNamedArguments(), \"\", \"Foo\");\n    myFixture.addFileToProject(getTestName(true) + \"/Foo.groovy\", foo.getContainingFile().getText());\n    final PsiClass psiClass = myFixture.findClass(\"Foo\");\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        ConvertMapToClassIntention\n          .replaceMapWithClass(getProject(), map, psiClass, ConvertMapToClassIntention.checkForReturnFromMethod(map),\n                               ConvertMapToClassIntention.checkForVariableDeclaration(map),\n                               ConvertMapToClassIntention.checkForMethodParameter(map));\n      }\n    });\n\n    myFixture.checkResultByFile(getTestName(true) + \"/Foo.groovy\", getTestName(true) + \"/Expected.groovy\", true);\n    myFixture.checkResultByFile(getTestName(true) + \"/Test_after.groovy\", true);\n  }","id":40621,"modified_method":"protected void doTest(boolean exists) {\n    myFixture.configureByFile(getTestName(true) + \"/Test.groovy\");\n    String hint = GroovyIntentionsBundle.message(\"convert.map.to.class.intention.name\");\n    final List<IntentionAction> list = myFixture.filterAvailableIntentions(hint);\n    if (!exists) {\n      assertEmpty(list);\n      return;\n    }\n    assertOneElement(list);\n    final PsiElement element = myFixture.getFile().findElementAt(myFixture.getEditor().getCaretModel().getOffset());\n    final GrListOrMap map = PsiTreeUtil.getParentOfType(element, GrListOrMap.class);\n    assertNotNull(map);\n    final GrTypeDefinition foo = ConvertMapToClassIntention.createClass(getProject(), map.getNamedArguments(), \"\", \"Foo\");\n    myFixture.addFileToProject(getTestName(true) + \"/Foo.groovy\", foo.getContainingFile().getText());\n    final PsiClass psiClass = myFixture.findClass(\"Foo\");\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        ConvertMapToClassIntention\n          .replaceMapWithClass(getProject(), map, psiClass, ConvertMapToClassIntention.checkForReturnFromMethod(map),\n                               ConvertMapToClassIntention.checkForVariableDeclaration(map),\n                               ConvertMapToClassIntention.checkForMethodParameter(map));\n      }\n    });\n\n    myFixture.checkResultByFile(getTestName(true) + \"/Foo.groovy\", getTestName(true) + \"/Expected.groovy\", true);\n    myFixture.checkResultByFile(getTestName(true) + \"/Test_after.groovy\", true);\n  }","commit_id":"f23c56fdea66b3679c993aea5cde095945ce1470","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    if (element instanceof GrVariableDeclaration) {\n      GrVariable[] variables = ((GrVariableDeclaration)element).getVariables();\n      if (variables.length == 1) {\n        GrVariable var = variables[0];\n        GrExpression initializer = var.getInitializerGroovy();\n        if (initializer != null) {\n          GrExpression assignment = GroovyPsiElementFactory.getInstance(project)\n            .createExpressionFromText(var.getName() + \" = \" + initializer.getText());\n          initializer.delete();\n          element = GroovyRefactoringUtil.addBlockIntoParent(element);\n          element.getParent().addAfter(assignment, element);\n        }\n      }\n      else if (variables.length > 1) {\n        String modifiers = ((GrVariableDeclaration)element).getModifierList().getText();\n        GrStatement[] sts = new GrStatement[variables.length];\n        for (int i = 0; i < variables.length; i++) {\n          sts[i] = createVarDeclaration(project, variables[i], modifiers);\n        }\n\n        element = GroovyRefactoringUtil.addBlockIntoParent(element);\n\n        for (int i = sts.length - 1; i >= 0; i--) {\n          element.getParent().addAfter(sts[i], element);\n        }\n\n        element.delete();\n      }\n    }\n  }","id":40622,"modified_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    if (!(element instanceof GrVariableDeclaration)) return;\n\n    GrVariableDeclaration declaration = (GrVariableDeclaration)element;\n\n    GrVariable[] variables = declaration.getVariables();\n    if (variables.length == 1) {\n      processSingleVar(project, declaration, variables[0]);\n    }\n    else if (variables.length > 1) {\n      GrTupleDeclaration tuple = declaration.getTupleDeclaration();\n      if (tuple == null || tuple.getInitializerGroovy() instanceof GrListOrMap) {\n        processMultipleVars(project, declaration);\n      }\n      else {\n        processTuple(project, declaration);\n      }\n    }\n  }","commit_id":"f23c56fdea66b3679c993aea5cde095945ce1470","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GrStatement createVarDeclaration(Project project, GrVariable variable, String modifiers) {\n    StringBuilder builder = new StringBuilder();\n    builder.append(modifiers).append(' ');\n    GrTypeElement typeElement = variable.getTypeElementGroovy();\n    if (typeElement != null) {\n      builder.append(typeElement.getText()).append(' ');\n    }\n    builder.append(variable.getName());\n    GrExpression initializer = variable.getInitializerGroovy();\n    if (initializer != null) {\n      builder.append('=').append(initializer.getText());\n    }\n    return GroovyPsiElementFactory.getInstance(project).createStatementFromText(builder.toString());\n  }","id":40623,"modified_method":"private static GrStatement createVarDeclaration(Project project, GrVariable variable, String modifiers, boolean isTuple) {\n    StringBuilder builder = new StringBuilder();\n    builder.append(modifiers).append(' ');\n    GrTypeElement typeElement = variable.getTypeElementGroovy();\n    if (typeElement != null) {\n      builder.append(typeElement.getText()).append(' ');\n    }\n    builder.append(variable.getName());\n    GrExpression initializer = variable.getInitializerGroovy();\n    if (initializer != null) {\n      builder.append('=').append(initializer.getText());\n    }\n    GrVariableDeclaration var =\n      (GrVariableDeclaration)GroovyPsiElementFactory.getInstance(project).createStatementFromText(builder.toString());\n    if (isTuple && (variable.getDeclaredType() != null || var.getModifierList().getModifiers().length > 1)) {\n      ((GrVariableDeclaration)var).getModifierList().setModifierProperty(GrModifier.DEF, false);\n    }\n    return var;\n  }","commit_id":"f23c56fdea66b3679c993aea5cde095945ce1470","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected PsiElementPredicate getElementPredicate() {\n    return new PsiElementPredicate() {\n      @Override\n      public boolean satisfiedBy(PsiElement element) {\n        if (element instanceof GrVariableDeclaration) {\n          GrVariable[] variables = ((GrVariableDeclaration)element).getVariables();\n          if (variables.length > 1 && GroovyRefactoringUtil.isLocalVariable(variables[0])) {\n            myText = GroovyIntentionsBundle.message(\"split.into.separate.declaration\");\n            return true;\n          }\n          else if (variables.length == 1 &&\n                   GroovyRefactoringUtil.isLocalVariable(variables[0]) &&\n                   variables[0].getInitializerGroovy() != null) {\n            myText = GroovyIntentionsBundle.message(\"split.into.declaration.and.assignment\");\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }","id":40624,"modified_method":"@NotNull\n  @Override\n  protected PsiElementPredicate getElementPredicate() {\n    return new PsiElementPredicate() {\n      @Override\n      public boolean satisfiedBy(PsiElement element) {\n        if (element instanceof GrVariableDeclaration) {\n          GrVariable[] variables = ((GrVariableDeclaration)element).getVariables();\n          if (variables.length > 1 && GroovyRefactoringUtil.isLocalVariable(variables[0])) {\n            GrTupleDeclaration tuple = ((GrVariableDeclaration)element).getTupleDeclaration();\n            if (tuple == null || tuple.getInitializerGroovy() instanceof GrListOrMap) {\n              myText = GroovyIntentionsBundle.message(\"split.into.separate.declaration\");\n            }\n            else {\n              myText = GroovyIntentionsBundle.message(\"split.into.declaration.and.assignment\");\n            }\n            return true;\n          }\n          else if (variables.length == 1 &&\n                   GroovyRefactoringUtil.isLocalVariable(variables[0]) &&\n                   variables[0].getInitializerGroovy() != null) {\n            myText = GroovyIntentionsBundle.message(\"split.into.declaration.and.assignment\");\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }","commit_id":"f23c56fdea66b3679c993aea5cde095945ce1470","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void deleteChildInternal(@NotNull ASTNode child) {\n    final PsiElement psi = child.getPsi();\n    if (psi == getInitializerGroovy()) {\n      deleteChildInternal(findChildByType(GroovyTokenTypes.mASSIGN).getNode());\n    }\n    super.deleteChildInternal(child);\n  }","id":40625,"modified_method":"@Override\n  public void deleteChildInternal(@NotNull ASTNode child) {\n    final PsiElement psi = child.getPsi();\n    if (psi == getInitializerGroovy()) {\n      deleteChildInternal(findNotNullChildByType(GroovyTokenTypes.mASSIGN).getNode());\n    }\n    super.deleteChildInternal(child);\n  }","commit_id":"f23c56fdea66b3679c993aea5cde095945ce1470","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void parseString(String string, List<String>... outs){\n        final String[] strings = string.split(\",\");\n        for (List<String> out : outs) {\n            out.clear();\n        }\n        for (int i = 0; i < strings.length; i += outs.length) {\n            for (int j = 0; j < outs.length; j++) {\n                final List<String> out = outs[j];\n                out.add(strings[i + j]);\n            }\n        }\n    }","id":40626,"modified_method":"protected static void parseString(String string, List<String>... outs){\n        final String[] strings = string.split(\",\");\n        for (List<String> out : outs) {\n            out.clear();\n        }\n        for (int i = 0; i < strings.length; i += outs.length) {\n            for (int j = 0; j < outs.length; j++) {\n                final List<String> out = outs[j];\n                if (i + j >= strings.length) {\n                    out.add(\"\");\n                } else {\n                    out.add(strings[i + j]);\n                }\n            }\n        }\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerLoggingInspections() {\n        m_inspectionClasses.add(ClassWithMultipleLoggersInspection.class);\n        m_inspectionClasses.add(ClassWithoutLoggerInspection.class);\n        m_inspectionClasses.add(LoggingConditionDisagreesWithLogStatementInspection.class);\n        m_inspectionClasses.add(LoggerInitializedWithForeignClassInspection.class);\n        m_inspectionClasses.add(NonStaticFinalLoggerInspection.class);\n        //m_inspectionClasses.add(PublicMethodWithoutLoggingInspection.class);\n    }","id":40627,"modified_method":"private void registerLoggingInspections() {\n        m_inspectionClasses.add(ClassWithMultipleLoggersInspection.class);\n        m_inspectionClasses.add(ClassWithoutLoggerInspection.class);\n        m_inspectionClasses.add(LoggingConditionDisagreesWithLogStatementInspection.class);\n        m_inspectionClasses.add(LoggerInitializedWithForeignClassInspection.class);\n        m_inspectionClasses.add(LogStatementGuardedByLogConditionInspection.class);\n        m_inspectionClasses.add(NonStaticFinalLoggerInspection.class);\n        //m_inspectionClasses.add(PublicMethodWithoutLoggingInspection.class);\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) element.getParent();\n            final PsiStatement statement = PsiTreeUtil.getParentOfType(\n                    methodCallExpression, PsiStatement.class);\n            if (statement == null) {\n                return;\n            }\n            final List<PsiStatement> logStatements = new ArrayList();\n            logStatements.add(statement);\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String referenceName = methodExpression.getReferenceName();\n            if (referenceName == null) {\n                return;\n            }\n            PsiStatement previousStatement =\n                    PsiTreeUtil.getPrevSiblingOfType(statement,\n                            PsiStatement.class);\n            while (previousStatement != null &&\n                    isSameLogMethodCall(previousStatement, referenceName)) {\n                logStatements.add(0, previousStatement);\n                previousStatement = PsiTreeUtil.getPrevSiblingOfType(\n                        previousStatement, PsiStatement.class);\n            }\n            PsiStatement nextStatement =\n                    PsiTreeUtil.getNextSiblingOfType(statement,\n                            PsiStatement.class);\n            while (nextStatement != null &&\n                    isSameLogMethodCall(nextStatement, referenceName)) {\n                logStatements.add(nextStatement);\n                nextStatement = PsiTreeUtil.getNextSiblingOfType(\n                        nextStatement, PsiStatement.class);\n            }\n            final PsiElementFactory factory =\n                    JavaPsiFacade.getInstance(project).getElementFactory();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return;\n            }\n            final StringBuilder ifStatementText = new StringBuilder(\"if (\");\n            ifStatementText.append(qualifier.getText());\n            ifStatementText.append('.');\n            final String conditionMethodText =\n                    loggerMethodAndconditionMethodTextMap.get(referenceName);\n            ifStatementText.append(conditionMethodText);\n            ifStatementText.append(\") {}\");\n            final PsiStatement ifStatement = factory.createStatementFromText(\n                    ifStatementText.toString(), statement);\n            final PsiElement[] children = ifStatement.getChildren();\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement) children[0];\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            for (PsiStatement logStatement : logStatements) {\n                codeBlock.add(logStatement);\n            }\n            final PsiStatement firstStatement = logStatements.get(0);\n            final PsiElement parent = firstStatement.getParent();\n            parent.addBefore(ifStatement, firstStatement);\n            //for (PsiStatement logStatement : logStatements) {\n            //    logStatement.delete();\n            //}\n        }","id":40628,"modified_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) element.getParent().getParent();\n            final PsiStatement statement = PsiTreeUtil.getParentOfType(\n                    methodCallExpression, PsiStatement.class);\n            if (statement == null) {\n                return;\n            }\n            final List<PsiStatement> logStatements = new ArrayList();\n            logStatements.add(statement);\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String referenceName = methodExpression.getReferenceName();\n            if (referenceName == null) {\n                return;\n            }\n            PsiStatement previousStatement =\n                    PsiTreeUtil.getPrevSiblingOfType(statement,\n                            PsiStatement.class);\n            while (previousStatement != null &&\n                    isSameLogMethodCall(previousStatement, referenceName)) {\n                logStatements.add(0, previousStatement);\n                previousStatement = PsiTreeUtil.getPrevSiblingOfType(\n                        previousStatement, PsiStatement.class);\n            }\n            PsiStatement nextStatement =\n                    PsiTreeUtil.getNextSiblingOfType(statement,\n                            PsiStatement.class);\n            while (nextStatement != null &&\n                    isSameLogMethodCall(nextStatement, referenceName)) {\n                logStatements.add(nextStatement);\n                nextStatement = PsiTreeUtil.getNextSiblingOfType(\n                        nextStatement, PsiStatement.class);\n            }\n            final PsiElementFactory factory =\n                    JavaPsiFacade.getInstance(project).getElementFactory();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return;\n            }\n            final StringBuilder ifStatementText = new StringBuilder(\"if (\");\n            ifStatementText.append(qualifier.getText());\n            ifStatementText.append('.');\n            final int index = logMethodNameList.indexOf(referenceName);\n            final String conditionMethodText =\n                    logConditionMethodNameList.get(index);\n            ifStatementText.append(conditionMethodText);\n            ifStatementText.append(\") {}\");\n            final PsiIfStatement ifStatement =\n                    (PsiIfStatement)factory.createStatementFromText(\n                            ifStatementText.toString(), statement);\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement)ifStatement.getThenBranch();\n            if (blockStatement == null) {\n                return;\n            }\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            for (PsiStatement logStatement : logStatements) {\n                codeBlock.add(logStatement);\n            }\n            final PsiStatement firstStatement = logStatements.get(0);\n            final PsiElement parent = firstStatement.getParent();\n            final PsiElement result = parent.addBefore(ifStatement,\n                    firstStatement);\n            final JavaCodeStyleManager codeStyleManager =\n                    JavaCodeStyleManager.getInstance(project);\n            codeStyleManager.shortenClassReferences(result);\n            for (PsiStatement logStatement : logStatements) {\n                logStatement.delete();\n            }\n        }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(\n                PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final String referenceName = methodExpression.getReferenceName();\n            if (!loggerMethodAndconditionMethodTextMap.containsKey(\n                    referenceName)) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return;\n            }\n            final PsiType type = qualifier.getType();\n            if (type == null) {\n                return;\n            }\n            if (!type.equalsToText(loggerClassName)) {\n                return;\n            }\n            if (isSurroundByLogGuard(expression)) {\n                return;\n            }\n            registerMethodCallError(expression);\n        }","id":40629,"modified_method":"public void visitMethodCallExpression(\n                PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final String referenceName = methodExpression.getReferenceName();\n            if (!logMethodNameList.contains(referenceName)) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return;\n            }\n            final PsiType type = qualifier.getType();\n            if (type == null) {\n                return;\n            }\n            if (!type.equalsToText(loggerClassName)) {\n                return;\n            }\n            if (isSurroundedByLogGuard(expression)) {\n                return;\n            }\n            final PsiExpressionList argumentList = expression.getArgumentList();\n            final PsiExpression[] arguments = argumentList.getExpressions();\n            if (arguments.length == 0) {\n                return;\n            }\n            final PsiExpression firstArgument = arguments[0];\n            if (PsiUtil.isConstantExpression(firstArgument)) {\n                return;\n            }\n            registerMethodCallError(expression);\n        }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String getDisplayName() {\n        return \"Log statement not guarded by log condition\";\n        //return InspectionGadgetsBundle.message(\n        //        \"logger.initialized.with.foreign.class.display.name\");\n    }","id":40630,"modified_method":"@NotNull\n    public String getDisplayName() {\n        return InspectionGadgetsBundle.message(\n                \"log.statement.guarded.by.log.condition.display.name\");\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeSettings(Element element) throws WriteExternalException {\n        final Set<String> loggerMethodNames =\n                loggerMethodAndconditionMethodTextMap.keySet();\n        final Collection<String> conditionMethodNames =\n                loggerMethodAndconditionMethodTextMap.values();\n        //loggerMethodAndconditionMethodNames = formatString(loggerMethodNames,\n        //        conditionMethodNames);\n        super.writeSettings(element);\n    }","id":40631,"modified_method":"public void writeSettings(Element element) throws WriteExternalException {\n        loggerMethodAndconditionMethodNames = formatString(logMethodNameList,\n                logConditionMethodNameList);\n        super.writeSettings(element);\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    protected String buildErrorString(Object... infos) {\n        return \"<code>#ref()<\/code> log statement not guarded by log condition\";\n    }","id":40632,"modified_method":"@NotNull\n    protected String buildErrorString(Object... infos) {\n        return InspectionGadgetsBundle.message(\n                \"log.statement.guarded.by.log.condition.problem.descriptor\");\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readSettings(Element element) throws InvalidDataException {\n        super.readSettings(element);\n        initSettings();\n    }","id":40633,"modified_method":"public void readSettings(Element element) throws InvalidDataException {\n        super.readSettings(element);\n        parseString(loggerMethodAndconditionMethodNames, logMethodNameList,\n                logConditionMethodNameList);\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LogStatementGuardedByLogConditionInspection() {\n        initSettings();\n    }","id":40634,"modified_method":"public LogStatementGuardedByLogConditionInspection() {\n        parseString(loggerMethodAndconditionMethodNames, logMethodNameList,\n                logConditionMethodNameList);\n    }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n        public String getName() {\n            return \"Surround with log condition\";\n        }","id":40635,"modified_method":"@NotNull\n        public String getName() {\n            return InspectionGadgetsBundle.message(\n                    \"log.statement.guarded.by.log.condition.quickfix\");\n        }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isSurroundByLogGuard(\n                PsiMethodCallExpression expression) {\n            final PsiIfStatement ifStatement =\n                    PsiTreeUtil.getParentOfType(expression,\n                            PsiIfStatement.class);\n            if (ifStatement == null) {\n                return false;\n            }\n            final PsiExpression condition = ifStatement.getCondition();\n            if (!(condition instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) condition;\n            final PsiReferenceExpression reference =\n                    methodCallExpression.getMethodExpression();\n            final PsiType referenceType = reference.getType();\n            if (referenceType == null) {\n                return false;\n            }\n            return referenceType.equalsToText(loggerClassName);\n        }","id":40636,"modified_method":"private boolean isSurroundedByLogGuard(\n                PsiMethodCallExpression expression) {\n            final PsiIfStatement ifStatement =\n                    PsiTreeUtil.getParentOfType(expression,\n                            PsiIfStatement.class);\n            if (ifStatement == null) {\n                return false;\n            }\n            final PsiExpression condition = ifStatement.getCondition();\n            if (!(condition instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression) condition;\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return false;\n            }\n            final PsiType qualifierType = qualifier.getType();\n            if (qualifierType == null) {\n                return false;\n            }\n            return qualifierType.equalsToText(loggerClassName);\n        }","commit_id":"71cdec201d9412b3be8b13c573470fe57e50c5b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    int modelRow  = table.convertRowIndexToModel(row);\n\n    if (myTreeCellRenderer != null)\n      myTree.setCellRenderer(myTreeCellRenderer);\n    if (isSelected){\n      myTree.setBackground(table.getSelectionBackground());\n      myTree.setForeground(table.getSelectionForeground());\n    }\n    else{\n      myTree.setBackground(table.getBackground());\n      myTree.setForeground(table.getForeground());\n    }\n\n    //TableModel model = myTreeTable.getModel();\n    //myTree.setTreeTableTreeBorder(hasFocus && model.getColumnClass(column).equals(TreeTableModel.class) ? myDefaultBorder : null);\n    myTree.setVisibleRow(modelRow);\n\n    final Object treeObject = myTree.getPathForRow(modelRow).getLastPathComponent();\n    boolean leaf = myTree.getModel().isLeaf(treeObject);\n    final boolean expanded = myTree.isExpanded(modelRow);\n    Component component = myTree.getCellRenderer().getTreeCellRendererComponent(myTree, treeObject, isSelected, expanded, leaf, modelRow, hasFocus);\n    if (component instanceof JComponent) {\n      table.setToolTipText(((JComponent)component).getToolTipText());\n    }\n\n    //myTree.setCellFocused(false);\n\n    return myTree;\n  }","id":40637,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    int modelRow  = table.convertRowIndexToModel(row);\n    final boolean lineHasFocus = table.hasFocus();\n\n    if (myTreeCellRenderer != null)\n      myTree.setCellRenderer(myTreeCellRenderer);\n    if (isSelected){\n      myTree.setBackground(lineHasFocus ? table.getSelectionBackground() : UIUtil.getTreeUnfocusedSelectionBackground());\n      myTree.setForeground(table.getSelectionForeground());\n    }\n    else {\n      myTree.setBackground(table.getBackground());\n      myTree.setForeground(table.getForeground());\n    }\n\n    //TableModel model = myTreeTable.getModel();\n    //myTree.setTreeTableTreeBorder(hasFocus && model.getColumnClass(column).equals(TreeTableModel.class) ? myDefaultBorder : null);\n    myTree.setVisibleRow(modelRow);\n\n    final Object treeObject = myTree.getPathForRow(modelRow).getLastPathComponent();\n    boolean leaf = myTree.getModel().isLeaf(treeObject);\n    final boolean expanded = myTree.isExpanded(modelRow);\n    Component component = myTree.getCellRenderer().getTreeCellRendererComponent(myTree, treeObject, isSelected, expanded, leaf, modelRow, lineHasFocus);\n    if (component instanceof JComponent) {\n      table.setToolTipText(((JComponent)component).getToolTipText());\n    }\n\n    //myTree.setCellFocused(false);\n\n    return myTree;\n  }","commit_id":"58a549f5aae08167d39c7e97c87488e223371375","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintRow(final Graphics g,\n                          final Rectangle clipBounds,\n                          final Insets insets,\n                          final Rectangle bounds,\n                          final TreePath path,\n                          final int row,\n                          final boolean isExpanded,\n                          final boolean hasBeenExpanded,\n                          final boolean isLeaf) {\n    final int containerWidth = tree.getParent() instanceof JViewport ? tree.getParent().getWidth() : tree.getWidth();\n    final int xOffset = tree.getParent() instanceof JViewport ? ((JViewport)tree.getParent()).getViewPosition().x : 0;\n\n    if (path != null && myWideSelection) {\n      boolean selected = tree.isPathSelected(path);\n      Graphics2D rowGraphics = (Graphics2D)g.create();\n      rowGraphics.setClip(clipBounds);\n\n      final Object sourceList = tree.getClientProperty(SOURCE_LIST_CLIENT_PROPERTY);\n      Color background = tree.getBackground();\n\n      if ((row % 2) == 0 && Boolean.TRUE.equals(tree.getClientProperty(STRIPED_CLIENT_PROPERTY))) {\n        background = UIUtil.getDecoratedRowColor();\n      }\n\n      if (sourceList != null && (Boolean)sourceList) {\n        if (selected) {\n          if (tree.hasFocus()) {\n            LIST_FOCUSED_SELECTION_BACKGROUND_PAINTER.paintBorder(tree, rowGraphics, xOffset, bounds.y, containerWidth, bounds.height);\n          }\n          else {\n            LIST_SELECTION_BACKGROUND_PAINTER.paintBorder(tree, rowGraphics, xOffset, bounds.y, containerWidth, bounds.height);\n          }\n        }\n        else if (myWideSelectionCondition.value(row)) {\n          rowGraphics.setColor(background);\n          rowGraphics.fillRect(xOffset, bounds.y, containerWidth, bounds.height);\n        }\n      }\n      else {\n        if (selected && (UIUtil.isUnderAquaBasedLookAndFeel() || UIUtil.isUnderDarcula() || UIUtil.isUnderIntelliJLaF())) {\n          Color bg = UIUtil.getTreeSelectionBackground(tree.hasFocus() || Boolean.TRUE.equals(tree.getClientProperty(TREE_TABLE_TREE_KEY)));\n\n          if (myWideSelectionCondition.value(row)) {\n            rowGraphics.setColor(bg);\n            rowGraphics.fillRect(xOffset, bounds.y, containerWidth, bounds.height);\n          }\n        }\n      }\n\n      if (shouldPaintExpandControl(path, row, isExpanded, hasBeenExpanded, isLeaf)) {\n        paintExpandControl(rowGraphics, bounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n      }\n\n      super.paintRow(rowGraphics, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n      rowGraphics.dispose();\n    }\n    else {\n      super.paintRow(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n    }\n  }","id":40638,"modified_method":"@Override\n  protected void paintRow(final Graphics g,\n                          final Rectangle clipBounds,\n                          final Insets insets,\n                          final Rectangle bounds,\n                          final TreePath path,\n                          final int row,\n                          final boolean isExpanded,\n                          final boolean hasBeenExpanded,\n                          final boolean isLeaf) {\n    final int containerWidth = tree.getParent() instanceof JViewport ? tree.getParent().getWidth() : tree.getWidth();\n    final int xOffset = tree.getParent() instanceof JViewport ? ((JViewport)tree.getParent()).getViewPosition().x : 0;\n\n    if (path != null && myWideSelection) {\n      boolean selected = tree.isPathSelected(path);\n      Graphics2D rowGraphics = (Graphics2D)g.create();\n      rowGraphics.setClip(clipBounds);\n\n      final Object sourceList = tree.getClientProperty(SOURCE_LIST_CLIENT_PROPERTY);\n      Color background = tree.getBackground();\n\n      if ((row % 2) == 0 && Boolean.TRUE.equals(tree.getClientProperty(STRIPED_CLIENT_PROPERTY))) {\n        background = UIUtil.getDecoratedRowColor();\n      }\n\n      if (sourceList != null && (Boolean)sourceList) {\n        if (selected) {\n          if (tree.hasFocus()) {\n            LIST_FOCUSED_SELECTION_BACKGROUND_PAINTER.paintBorder(tree, rowGraphics, xOffset, bounds.y, containerWidth, bounds.height);\n          }\n          else {\n            LIST_SELECTION_BACKGROUND_PAINTER.paintBorder(tree, rowGraphics, xOffset, bounds.y, containerWidth, bounds.height);\n          }\n        }\n        else if (myWideSelectionCondition.value(row)) {\n          rowGraphics.setColor(background);\n          rowGraphics.fillRect(xOffset, bounds.y, containerWidth, bounds.height);\n        }\n      }\n      else {\n        if (selected && (UIUtil.isUnderAquaBasedLookAndFeel() || UIUtil.isUnderDarcula() || UIUtil.isUnderIntelliJLaF())\n            && ! Boolean.TRUE.equals(tree.getClientProperty(NO_SELECTION_PAINTING_DARK))) {\n          Color bg = UIUtil.getTreeSelectionBackground(tree.hasFocus() || Boolean.TRUE.equals(tree.getClientProperty(TREE_TABLE_TREE_KEY)));\n\n          if (myWideSelectionCondition.value(row)) {\n            rowGraphics.setColor(bg);\n            rowGraphics.fillRect(xOffset, bounds.y, containerWidth, bounds.height);\n          }\n        }\n      }\n\n      if (shouldPaintExpandControl(path, row, isExpanded, hasBeenExpanded, isLeaf)) {\n        paintExpandControl(rowGraphics, bounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n      }\n\n      super.paintRow(rowGraphics, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n      rowGraphics.dispose();\n    }\n    else {\n      super.paintRow(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n    }\n  }","commit_id":"58a549f5aae08167d39c7e97c87488e223371375","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTreeCellRendererComponent(JTree tree,\n                                                Object value,\n                                                boolean selected,\n                                                boolean expanded,\n                                                boolean leaf,\n                                                int row,\n                                                boolean hasFocus) {\n    final SimpleColoredComponent component = new SimpleColoredComponent();\n    if (!(value instanceof InspectionConfigTreeNode)) return component;\n    InspectionConfigTreeNode node = (InspectionConfigTreeNode)value;\n\n    Object object = node.getUserObject();\n\n    final Color background = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\n    UIUtil.changeBackGround(component, background);\n    Color foreground =\n      selected ? UIUtil.getTreeSelectionForeground() : node.isProperSetting() ? PlatformColors.BLUE : UIUtil.getTreeTextForeground();\n\n    @NonNls String text;\n    int style = SimpleTextAttributes.STYLE_PLAIN;\n    String hint = null;\n    if (object instanceof String) {\n      text = (String)object;\n      style = SimpleTextAttributes.STYLE_BOLD;\n    }\n    else {\n      final ToolDescriptors descriptors = node.getDescriptors();\n      assert descriptors != null;\n      final Descriptor defaultDescriptor = descriptors.getDefaultDescriptor();\n      text = defaultDescriptor.getText();\n      hint = getHint(defaultDescriptor);\n    }\n\n    if (text != null) {\n      SearchUtil.appendFragments(getFilter(), text, style, foreground, background, component);\n    }\n    if (hint != null) {\n      component.append(\" \" + hint, selected ? new SimpleTextAttributes(Font.PLAIN, foreground) : SimpleTextAttributes.GRAYED_ATTRIBUTES);\n    }\n    component.setForeground(foreground);\n    return component;\n  }","id":40639,"modified_method":"@Override\n  public Component getTreeCellRendererComponent(JTree tree,\n                                                Object value,\n                                                boolean selected,\n                                                boolean expanded,\n                                                boolean leaf,\n                                                int row,\n                                                boolean hasFocus) {\n    final SimpleColoredComponent component = new SimpleColoredComponent();\n    if (!(value instanceof InspectionConfigTreeNode)) return component;\n    InspectionConfigTreeNode node = (InspectionConfigTreeNode)value;\n\n    Object object = node.getUserObject();\n    boolean reallyHasFocus = ((TreeTableTree)tree).getTreeTable().hasFocus();\n    final Color background = selected ? (reallyHasFocus ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeUnfocusedSelectionBackground())\n                                      : UIUtil.getTreeTextBackground();\n    UIUtil.changeBackGround(component, background);\n    Color foreground =\n      selected ? UIUtil.getTreeSelectionForeground() : node.isProperSetting() ? PlatformColors.BLUE : UIUtil.getTreeTextForeground();\n\n    @NonNls String text;\n    int style = SimpleTextAttributes.STYLE_PLAIN;\n    String hint = null;\n    if (object instanceof String) {\n      text = (String)object;\n      style = SimpleTextAttributes.STYLE_BOLD;\n    }\n    else {\n      final ToolDescriptors descriptors = node.getDescriptors();\n      assert descriptors != null;\n      final Descriptor defaultDescriptor = descriptors.getDefaultDescriptor();\n      text = defaultDescriptor.getText();\n      hint = getHint(defaultDescriptor);\n    }\n\n    if (text != null) {\n      SearchUtil.appendFragments(getFilter(), text, style, foreground, background, component);\n    }\n    if (hint != null) {\n      component.append(\" \" + hint, selected ? new SimpleTextAttributes(Font.PLAIN, foreground) : SimpleTextAttributes.GRAYED_ATTRIBUTES);\n    }\n    component.setForeground(foreground);\n    return component;\n  }","commit_id":"fe65e9402d86341a6c11ce0132f2ffeaa7667ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionsConfigTreeTable(final InspectionsConfigTreeTableModel model) {\n    super(model);\n\n    final TableColumn severitiesColumn = getColumnModel().getColumn(SEVERITIES_COLUMN);\n    severitiesColumn.setMaxWidth(20);\n\n    final TableColumn isEnabledColumn = getColumnModel().getColumn(IS_ENABLED_COLUMN);\n    isEnabledColumn.setMaxWidth(20 + getAdditionalPadding());\n    isEnabledColumn.setCellRenderer(new ThreeStateCheckBoxRenderer());\n    isEnabledColumn.setCellEditor(new ThreeStateCheckBoxRenderer());\n\n    addMouseMotionListener(new MouseAdapter() {\n      @Override\n      public void mouseMoved(final MouseEvent e) {\n        final Point point = e.getPoint();\n        final int column = columnAtPoint(point);\n        if (column != SEVERITIES_COLUMN) {\n          return;\n        }\n        final int row = rowAtPoint(point);\n        final Object maybeIcon = getModel().getValueAt(row, column);\n        if (maybeIcon instanceof MultiScopeSeverityIcon) {\n          final MultiScopeSeverityIcon icon = (MultiScopeSeverityIcon)maybeIcon;\n          final LinkedHashMap<String, HighlightDisplayLevel> scopeToAverageSeverityMap =\n            icon.getScopeToAverageSeverityMap();\n          final JComponent component;\n          if (scopeToAverageSeverityMap.size() == 1 &&\n              icon.getDefaultScopeName().equals(ContainerUtil.getFirstItem(scopeToAverageSeverityMap.keySet()))) {\n            final HighlightDisplayLevel level = ContainerUtil.getFirstItem(scopeToAverageSeverityMap.values());\n            final JLabel label = new JLabel();\n            label.setIcon(level.getIcon());\n            label.setText(SingleInspectionProfilePanel.renderSeverity(level.getSeverity()));\n            component = label;\n          } else {\n            component = new ScopesAndSeveritiesHintTable(scopeToAverageSeverityMap, icon.getDefaultScopeName());\n          }\n          IdeTooltipManager.getInstance().show(\n            new IdeTooltip(InspectionsConfigTreeTable.this, point, component), false);\n        }\n      }\n    });\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent event) {\n        final TreePath path = getTree().getPathForRow(getTree().getLeadSelectionRow());\n        if (path != null) {\n          final InspectionConfigTreeNode node = (InspectionConfigTreeNode)path.getLastPathComponent();\n          if (node.isLeaf()) {\n            model.swapInspectionEnableState();\n          }\n        }\n        return true;\n      }\n    }.installOn(this);\n\n    setTransferHandler(new TransferHandler() {\n      @Nullable\n      @Override\n      protected Transferable createTransferable(JComponent c) {\n        final TreePath path = getTree().getPathForRow(getTree().getLeadSelectionRow());\n        if (path != null) {\n          return new TextTransferable(StringUtil.join(ContainerUtil.mapNotNull(path.getPath(), new NullableFunction<Object, String>() {\n            @Nullable\n            @Override\n            public String fun(Object o) {\n              return o == path.getPath()[0] ? null : o.toString();\n            }\n          }), \" | \"));\n        }\n        return null;\n      }\n\n      @Override\n      public int getSourceActions(JComponent c) {\n        return COPY;\n      }\n    });\n\n    registerKeyboardAction(new ActionListener() {\n                             public void actionPerformed(ActionEvent e) {\n                               model.swapInspectionEnableState();\n                               updateUI();\n                             }\n                           }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n\n    getEmptyText().setText(\"No enabled inspections available\");\n  }","id":40640,"modified_method":"public InspectionsConfigTreeTable(final InspectionsConfigTreeTableModel model) {\n    super(model);\n\n    final TableColumn severitiesColumn = getColumnModel().getColumn(SEVERITIES_COLUMN);\n    severitiesColumn.setCellRenderer(new IconTableCellRenderer<Icon>() {\n\n      @Override\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean focus, int row, int column) {\n        Component component = super.getTableCellRendererComponent(table, value, false, focus, row, column);\n        Color bg = selected ? ((focus || table.hasFocus()) ? table.getSelectionBackground() : UIUtil.getTreeUnfocusedSelectionBackground())\n                            : table.getBackground();\n        component.setBackground(bg);\n        return component;\n      }\n\n      @Nullable\n      @Override\n      protected Icon getIcon(@NotNull Icon value, JTable table, int row) {\n        return value;\n      }\n    });\n    severitiesColumn.setMaxWidth(20);\n\n    final TableColumn isEnabledColumn = getColumnModel().getColumn(IS_ENABLED_COLUMN);\n    isEnabledColumn.setMaxWidth(20 + getAdditionalPadding());\n    isEnabledColumn.setCellRenderer(new ThreeStateCheckBoxRenderer());\n    isEnabledColumn.setCellEditor(new ThreeStateCheckBoxRenderer());\n\n    addMouseMotionListener(new MouseAdapter() {\n      @Override\n      public void mouseMoved(final MouseEvent e) {\n        final Point point = e.getPoint();\n        final int column = columnAtPoint(point);\n        if (column != SEVERITIES_COLUMN) {\n          return;\n        }\n        final int row = rowAtPoint(point);\n        final Object maybeIcon = getModel().getValueAt(row, column);\n        if (maybeIcon instanceof MultiScopeSeverityIcon) {\n          final MultiScopeSeverityIcon icon = (MultiScopeSeverityIcon)maybeIcon;\n          final LinkedHashMap<String, HighlightDisplayLevel> scopeToAverageSeverityMap =\n            icon.getScopeToAverageSeverityMap();\n          final JComponent component;\n          if (scopeToAverageSeverityMap.size() == 1 &&\n              icon.getDefaultScopeName().equals(ContainerUtil.getFirstItem(scopeToAverageSeverityMap.keySet()))) {\n            final HighlightDisplayLevel level = ContainerUtil.getFirstItem(scopeToAverageSeverityMap.values());\n            final JLabel label = new JLabel();\n            label.setIcon(level.getIcon());\n            label.setText(SingleInspectionProfilePanel.renderSeverity(level.getSeverity()));\n            component = label;\n          } else {\n            component = new ScopesAndSeveritiesHintTable(scopeToAverageSeverityMap, icon.getDefaultScopeName());\n          }\n          IdeTooltipManager.getInstance().show(\n            new IdeTooltip(InspectionsConfigTreeTable.this, point, component), false);\n        }\n      }\n    });\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent event) {\n        final TreePath path = getTree().getPathForRow(getTree().getLeadSelectionRow());\n        if (path != null) {\n          final InspectionConfigTreeNode node = (InspectionConfigTreeNode)path.getLastPathComponent();\n          if (node.isLeaf()) {\n            model.swapInspectionEnableState();\n          }\n        }\n        return true;\n      }\n    }.installOn(this);\n\n    setTransferHandler(new TransferHandler() {\n      @Nullable\n      @Override\n      protected Transferable createTransferable(JComponent c) {\n        final TreePath path = getTree().getPathForRow(getTree().getLeadSelectionRow());\n        if (path != null) {\n          return new TextTransferable(StringUtil.join(ContainerUtil.mapNotNull(path.getPath(), new NullableFunction<Object, String>() {\n            @Nullable\n            @Override\n            public String fun(Object o) {\n              return o == path.getPath()[0] ? null : o.toString();\n            }\n          }), \" | \"));\n        }\n        return null;\n      }\n\n      @Override\n      public int getSourceActions(JComponent c) {\n        return COPY;\n      }\n    });\n\n    registerKeyboardAction(new ActionListener() {\n                             public void actionPerformed(ActionEvent e) {\n                               model.swapInspectionEnableState();\n                               updateUI();\n                             }\n                           }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n\n    getEmptyText().setText(\"No enabled inspections available\");\n  }","commit_id":"fe65e9402d86341a6c11ce0132f2ffeaa7667ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JCheckBox tune(final Object value, final boolean isSelected, final int row, final JTable table) {\n    final Color bg = UIUtil.isUnderNimbusLookAndFeel() && row % 2 == 1 ? UIUtil.TRANSPARENT_COLOR : table.getBackground();\n    final Color fg = table.getForeground();\n    final Color selBg = table.getSelectionBackground();\n    final Color selFg = table.getSelectionForeground();\n\n    setForeground(isSelected ? selFg : fg);\n    setBackground(isSelected ? selBg : bg);\n\n    if (value == null) {\n      setState(State.DONT_CARE);\n    } else {\n      setSelected((Boolean) value);\n    }\n    return this;\n  }","id":40641,"modified_method":"private JCheckBox tune(final Object value, final boolean isSelected, final int row, final JTable table, boolean hasFocus) {\n    final Color bg = UIUtil.isUnderNimbusLookAndFeel() && row % 2 == 1 ? UIUtil.TRANSPARENT_COLOR : table.getBackground();\n    final Color fg = table.getForeground();\n    final Color selBg = (hasFocus || table.hasFocus()) ? table.getSelectionBackground() : UIUtil.getTreeUnfocusedSelectionBackground();\n    final Color selFg = table.getSelectionForeground();\n\n    setForeground(isSelected ? selFg : fg);\n    setBackground(isSelected ? selBg : bg);\n\n    if (value == null) {\n      setState(State.DONT_CARE);\n    } else {\n      setSelected((Boolean) value);\n    }\n    return this;\n  }","commit_id":"fe65e9402d86341a6c11ce0132f2ffeaa7667ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean isSelected, final boolean hasFocus, final int row, final int column) {\n    return tune(value, isSelected, row, table);\n  }","id":40642,"modified_method":"@Override\n  public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean isSelected, final boolean hasFocus, final int row, final int column) {\n    return tune(value, isSelected, row, table, hasFocus);\n  }","commit_id":"fe65e9402d86341a6c11ce0132f2ffeaa7667ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTableCellEditorComponent(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {\n    return tune(value, isSelected, row, table);\n  }","id":40643,"modified_method":"@Override\n  public Component getTableCellEditorComponent(final JTable table, final Object value, final boolean isSelected, final int row, final int column) {\n    return tune(value, isSelected, row, table, false);\n  }","commit_id":"fe65e9402d86341a6c11ce0132f2ffeaa7667ef0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getListCellRendererComponent(\n    final JList list,\n    final Object value,\n    final int index,\n    final boolean selected,\n    final boolean hasFocus\n  ){\n    clear();\n\n    mySelected=selected;\n    if (UIUtil.isWinLafOnVista()) {\n      // the system draws a gradient background on the combobox selected item - don't overdraw it with our solid background\n      if (index == -1) {\n        setOpaque(false);\n        mySelected = false;\n      }\n      else {\n        setOpaque(true);\n        setBackground(selected ? list.getSelectionBackground() : null);\n      }\n    }\n    else {\n      if(selected){\n        setBackground(list.getSelectionBackground());\n      }else{\n        setBackground(null);\n      }\n    }\n\n    setPaintFocusBorder(hasFocus);\n\n    customizeCellRenderer(list, value, index, selected, hasFocus);\n\n    return this;\n  }","id":40644,"modified_method":"public Component getListCellRendererComponent(JList list,\n                                                Object value,\n                                                int index,\n                                                boolean selected,\n                                                boolean hasFocus) {\n    clear();\n\n    mySelected = selected;\n    myForeground = list.getForeground();\n    mySelectionForeground = list.getSelectionForeground();\n    if (UIUtil.isWinLafOnVista()) {\n      // the system draws a gradient background on the combobox selected item - don't overdraw it with our solid background\n      if (index == -1) {\n        setOpaque(false);\n        mySelected = false;\n      }\n      else {\n        setOpaque(true);\n        setBackground(selected ? list.getSelectionBackground() : null);\n      }\n    }\n    else {\n      setBackground(selected ? list.getSelectionBackground() : null);\n    }\n\n    setPaintFocusBorder(hasFocus);\n\n    customizeCellRenderer(list, value, index, selected, hasFocus);\n    return this;\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * When the item is selected then we use default tree's selection foreground.\n   * It guaranties readability of selected text in any LAF.\n   */\n  public final void append(@NotNull final String fragment, @NotNull final SimpleTextAttributes attributes, boolean isMainText) {\n    if(mySelected) {\n      super.append(\n        fragment,\n        new SimpleTextAttributes(\n          attributes.getStyle(), UIUtil.getListSelectionForeground()\n        ), isMainText);\n    }\n    else if (attributes.getFgColor() == null) {\n      super.append(fragment, new SimpleTextAttributes(attributes.getStyle(), UIUtil.getListForeground()), isMainText);\n    }\n    else {\n      super.append(fragment, attributes, isMainText);\n    }\n  }","id":40645,"modified_method":"/**\n   * When the item is selected then we use default tree's selection foreground.\n   * It guaranties readability of selected text in any LAF.\n   */\n  public final void append(@NotNull String fragment, @NotNull SimpleTextAttributes attributes, boolean isMainText) {\n    if (mySelected) {\n      super.append(fragment, new SimpleTextAttributes(attributes.getStyle(), mySelectionForeground), isMainText);\n    }\n    else if (attributes.getFgColor() == null) {\n      super.append(fragment, new SimpleTextAttributes(attributes.getStyle(), myForeground), isMainText);\n    }\n    else {\n      super.append(fragment, attributes, isMainText);\n    }\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Dimension getPreferredSize() {\n    // There is a bug in BasicComboPopup. It does not add renderer into CellRendererPane,\n    // so font can be null here.\n\n    final Font oldFont = getFont();\n    if(oldFont == null){\n      setFont(UIUtil.getListFont());\n    }\n    final Dimension result = super.getPreferredSize();\n    if(oldFont == null){\n      setFont(null);\n    }\n\n    return result;\n  }","id":40646,"modified_method":"public Dimension getPreferredSize() {\n    // There is a bug in BasicComboPopup. It does not add renderer into CellRendererPane,\n    // so font can be null here.\n\n    Font oldFont = getFont();\n    if (oldFont == null) {\n      setFont(UIUtil.getListFont());\n    }\n    Dimension result = super.getPreferredSize();\n    if (oldFont == null) {\n      setFont(null);\n    }\n\n    return result;\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void actionPerformed(final AnActionEvent e) {\n      final ContentChooser<String> chooser = new ContentChooser<String>(myConsole.getProject(), myConsole.getTitle(), true) {\n\n        @Override\n        protected void removeContentAt(final String content) {\n          myModel.removeFromHistory(content);\n        }\n\n        @Override\n        protected String getStringRepresentationFor(final String content) {\n          return content;\n        }\n\n        @Override\n        protected List<String> getContents() {\n          return myModel.getHistory();\n        }\n      };\n      chooser.show();\n      if (chooser.isOK()) {\n        setConsoleText(myModel.getHistory().get(chooser.getSelectedIndex()), false, true);\n      }\n    }","id":40647,"modified_method":"@Override\n    public void actionPerformed(final AnActionEvent e) {\n      final ContentChooser<String> chooser = new ContentChooser<String>(myConsole.getProject(), myConsole.getTitle() + \" History\", true) {\n\n        @Override\n        protected void removeContentAt(String content) {\n          myModel.removeFromHistory(content);\n        }\n\n        @Override\n        protected String getStringRepresentationFor(String content) {\n          return content;\n        }\n\n        @Override\n        protected List<String> getContents() {\n          List<String> history = myModel.getHistory();\n          return ContainerUtil.reverse(history);\n        }\n\n        @Override\n        protected Editor createIdeaEditor(String text) {\n          PsiFile consoleFile = myConsole.getFile();\n          Language language = consoleFile.getLanguage();\n          Project project = consoleFile.getProject();\n\n          PsiFile psiFile = PsiFileFactory.getInstance(project).createFileFromText(\n            \"a.\"+consoleFile.getFileType().getDefaultExtension(),\n            language,\n            StringUtil.convertLineSeparators(new String(text)), false, true);\n          VirtualFile virtualFile = psiFile.getViewProvider().getVirtualFile();\n          if (virtualFile instanceof LightVirtualFile) ((LightVirtualFile)virtualFile).setWritable(false);\n          Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n          EditorFactory editorFactory = EditorFactory.getInstance();\n          EditorEx editor = (EditorEx)editorFactory.createViewer(document, project);\n          editor.getSettings().setFoldingOutlineShown(false);\n          editor.getSettings().setLineMarkerAreaShown(false);\n          editor.getSettings().setIndentGuidesShown(false);\n\n          SyntaxHighlighter highlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(language, project, psiFile.getViewProvider().getVirtualFile());\n          editor.setHighlighter(new LexerEditorHighlighter(highlighter, editor.getColorsScheme()));\n          return editor;\n        }\n      };\n      chooser.setContentIcon(null);\n      chooser.setSplitterOrientation(false);\n      chooser.setSelectedIndex(Math.min(myModel.getHistorySize() - myModel.getHistoryCursor() - 1, myModel.getHistorySize() - 1));\n      chooser.show();\n      if (chooser.isOK()) {\n        setConsoleText(myModel.getHistory().get(chooser.getSelectedIndex()), false, true);\n      }\n    }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void update(final AnActionEvent e) {\n      super.update(e);\n      final boolean hasStuff = myModel.hasHistory(myNext);\n      e.getPresentation().setEnabled(hasStuff && (myMultiline || canMoveInEditor(myNext)));\n    }","id":40648,"modified_method":"@Override\n    public void update(final AnActionEvent e) {\n      super.update(e);\n      e.getPresentation().setEnabled(myMultiline || canMoveInEditor(myNext));\n    }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void cleanupOldFiles(final File dir) {\n    final long keep2weeks = 2 * 1000L * 60 * 60 * 24 * 7;\n    final long curTime = System.currentTimeMillis();\n    for (File file : dir.listFiles()) {\n      if (file.isFile() && file.getName().endsWith(\".hist.xml\") && curTime - file.lastModified() > keep2weeks) {\n        file.delete();\n      }\n    }\n  }","id":40649,"modified_method":"private static void cleanupOldFiles(final File dir) {\n    final long keep2weeks = 2 * 1000L * 60 * 60 * 24 * 7;\n    final long curTime = System.currentTimeMillis();\n    File[] files = dir.listFiles();\n    if (files != null) {\n      for (File file : files) {\n        if (file.isFile() && file.getName().endsWith(\".hist.xml\") && curTime - file.lastModified() > keep2weeks) {\n          file.delete();\n        }\n      }\n    }\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void setConsoleText(final String command, final boolean storeUserText, final boolean regularMode) {\n    final Editor editor = myConsole.getCurrentEditor();\n    final Document document = editor.getDocument();\n    new WriteCommandAction.Simple(myConsole.getProject()) {\n      @Override\n      public void run() {\n        if (storeUserText) {\n          myUserValue = document.getText();\n        }\n        if (regularMode) {\n          document.setText(StringUtil.notNullize(command));\n        }\n        else {\n          try {\n            document.putUserData(UndoConstants.DONT_RECORD_UNDO, Boolean.TRUE);\n            document.setText(StringUtil.notNullize(command));\n          }\n          finally {\n            document.putUserData(UndoConstants.DONT_RECORD_UNDO, null);\n          }\n        }\n        editor.getCaretModel().moveToOffset(regularMode? document.getTextLength() : 0);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }.execute();\n  }","id":40650,"modified_method":"protected void setConsoleText(final String command, final boolean storeUserText, final boolean regularMode) {\n    final Editor editor = myConsole.getCurrentEditor();\n    final Document document = editor.getDocument();\n    new WriteCommandAction.Simple(myConsole.getProject()) {\n      @Override\n      public void run() {\n        if (storeUserText) {\n          myUserValue = document.getText();\n        }\n        String text = StringUtil.notNullize(command);\n        int offset;\n        if (regularMode) {\n          if (myMultiline) {\n            if (text.isEmpty()) return;\n            int selectionStart = editor.getSelectionModel().getSelectionStart();\n            int selectionEnd = editor.getSelectionModel().getSelectionEnd();\n            int caretOffset = editor.getCaretModel().getOffset();\n            int line = document.getLineNumber(caretOffset);\n            int lineStartOffset = document.getLineStartOffset(line);\n            if (selectionStart == lineStartOffset) document.deleteString(selectionStart, selectionEnd);\n            String trimmedLine = document.getText(new TextRange(lineStartOffset, document.getLineEndOffset(line))).trim();\n            if (StringUtil.findFirst(trimmedLine, new CharFilter() {\n              @Override\n              public boolean accept(char ch) {\n                return ch =='\\'' || ch == '\\\"' || ch == '_' || Character.isLetterOrDigit(ch);\n              }\n            }) > -1) {\n              text += \"\\n\";\n            }\n            document.insertString(lineStartOffset, text);\n            offset = lineStartOffset;\n            editor.getSelectionModel().setSelection(lineStartOffset, lineStartOffset + text.length());\n          }\n          else {\n            document.setText(text);\n            offset = document.getTextLength();\n          }\n        }\n        else {\n          offset = 0;\n          try {\n            document.putUserData(UndoConstants.DONT_RECORD_UNDO, Boolean.TRUE);\n            document.setText(text);\n          }\n          finally {\n            document.putUserData(UndoConstants.DONT_RECORD_UNDO, null);\n          }\n        }\n        editor.getCaretModel().moveToOffset(offset);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }.execute();\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void actionPerformed(final AnActionEvent e) {\n      final String command;\n      command = myNext ? myModel.getHistoryNext() : StringUtil.notNullize(myModel.getHistoryPrev(), StringUtil.notNullize(myUserValue));\n      setConsoleText(command, myNext && myModel.getHistoryCursor() == 0, true);\n    }","id":40651,"modified_method":"@Override\n    public void actionPerformed(final AnActionEvent e) {\n      final String command;\n      command = myNext ? myModel.getHistoryNext() : StringUtil.notNullize(myModel.getHistoryPrev(), myMultiline? \"\" : StringUtil.notNullize(myUserValue));\n      setConsoleText(command, myNext && myModel.getHistoryCursor() == 0, true);\n    }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ContentChooser(Project project, String title, boolean useIdeaEditor, boolean allowMultipleSelections) {\n    super(project, true);\n    myProject = project;\n    myUseIdeaEditor = useIdeaEditor;\n    myAllowMultipleSelections = allowMultipleSelections;\n\n    setOKButtonText(CommonBundle.getOkButtonText());\n    setTitle(title);\n\n    init();\n  }","id":40652,"modified_method":"public ContentChooser(Project project, String title, boolean useIdeaEditor, boolean allowMultipleSelections) {\n    super(project, true);\n    myProject = project;\n    myUseIdeaEditor = useIdeaEditor;\n    myAllowMultipleSelections = allowMultipleSelections;\n    myUpdateAlarm = new Alarm(getDisposable());\n    mySplitter = new Splitter(true, 0.3f);\n    myList = new JBList();\n\n    setOKButtonText(CommonBundle.getOkButtonText());\n    setTitle(title);\n\n    init();\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent createCenterPanel() {\n    myList = new JBList();\n    final int selectionMode = myAllowMultipleSelections ? ListSelectionModel.MULTIPLE_INTERVAL_SELECTION \n                                                        : ListSelectionModel.SINGLE_SELECTION;\n    myList.setSelectionMode(selectionMode);\n\n    rebuildListContent();\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        close(OK_EXIT_CODE);\n        return true;\n      }\n    }.installOn(myList);\n\n\n    myList.setCellRenderer(new MyListCellRenderer());\n\n    if (myAllContents.size() > 0) {\n      myList.setSelectedIndex(0);\n    }\n\n    myList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_DELETE) {\n          int newSelectionIndex = -1;\n          for (int i : getSelectedIndices()) {\n            removeContentAt(myAllContents.get(i));\n            if (newSelectionIndex < 0) {\n              newSelectionIndex = i;\n            }\n          }\n          \n          rebuildListContent();\n          if (myAllContents.size() <= 0) {\n            close(CANCEL_EXIT_CODE);\n            return;\n          }\n          newSelectionIndex = Math.min(newSelectionIndex, myAllContents.size() - 1);\n          myList.setSelectedIndex(newSelectionIndex);\n        }\n        else if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          close(OK_EXIT_CODE);\n        }\n        else {\n          final char aChar = e.getKeyChar();\n          if (aChar >= '0' && aChar <= '9') {\n            int idx = aChar == '0' ? 9 : aChar - '1';\n            if (idx < myAllContents.size()) {\n              myList.setSelectedIndex(idx);\n            }\n          }\n        }\n      }\n    });\n\n    mySplitter = new Splitter(true);\n    mySplitter.setFirstComponent(ScrollPaneFactory.createScrollPane(myList));\n    mySplitter.setSecondComponent(new JPanel());\n    updateViewerForSelection();\n\n    myList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        updateViewerForSelection();\n      }\n    });\n\n    mySplitter.setPreferredSize(new Dimension(500, 500));\n    new ListSpeedSearch(myList);\n\n    return mySplitter;\n  }","id":40653,"modified_method":"@Override\n  protected JComponent createCenterPanel() {\n    final int selectionMode = myAllowMultipleSelections ? ListSelectionModel.MULTIPLE_INTERVAL_SELECTION\n                                                        : ListSelectionModel.SINGLE_SELECTION;\n    myList.setSelectionMode(selectionMode);\n    if (myUseIdeaEditor) {\n      EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n      myList.setFont(scheme.getFont(EditorFontType.PLAIN));\n      Color fg = ObjectUtils.chooseNotNull(scheme.getDefaultForeground(), UIUtil.getListForeground());\n      Color bg = ObjectUtils.chooseNotNull(scheme.getDefaultBackground(), UIUtil.getListBackground());\n      myList.setForeground(fg);\n      myList.setBackground(bg);\n    }\n\n    rebuildListContent();\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        close(OK_EXIT_CODE);\n        return true;\n      }\n    }.installOn(myList);\n\n\n    myList.setCellRenderer(new MyListCellRenderer());\n    myList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_DELETE) {\n          int newSelectionIndex = -1;\n          for (int i : getSelectedIndices()) {\n            removeContentAt(myAllContents.get(i));\n            if (newSelectionIndex < 0) {\n              newSelectionIndex = i;\n            }\n          }\n          \n          rebuildListContent();\n          if (myAllContents.size() <= 0) {\n            close(CANCEL_EXIT_CODE);\n            return;\n          }\n          newSelectionIndex = Math.min(newSelectionIndex, myAllContents.size() - 1);\n          myList.setSelectedIndex(newSelectionIndex);\n        }\n        else if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          close(OK_EXIT_CODE);\n        }\n        else {\n          final char aChar = e.getKeyChar();\n          if (aChar >= '0' && aChar <= '9') {\n            int idx = aChar == '0' ? 9 : aChar - '1';\n            if (idx < myAllContents.size()) {\n              myList.setSelectedIndex(idx);\n            }\n          }\n        }\n      }\n    });\n\n    mySplitter.setFirstComponent(ScrollPaneFactory.createScrollPane(myList));\n    mySplitter.setSecondComponent(new JPanel());\n\n    ListScrollingUtil.installActions(myList);\n    ListScrollingUtil.ensureSelectionExists(myList);\n    updateViewerForSelection();\n    myList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        myUpdateAlarm.cancelAllRequests();\n        myUpdateAlarm.addRequest(new Runnable() {\n          @Override\n          public void run() {\n            updateViewerForSelection();\n          }\n        }, 100);\n      }\n    });\n\n    mySplitter.setPreferredSize(new Dimension(500, 500));\n\n    SplitterProportionsData d = new SplitterProportionsDataImpl();\n    d.externalizeToDimensionService(getClass().getName());\n    d.restoreSplitterProportions(mySplitter);\n\n    new ListSpeedSearch(myList);\n\n    return mySplitter;\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateViewerForSelection() {\n    if (myAllContents.size() == 0) return;\n    String fullString = \"\";\n    for (int i : getSelectedIndices()) {\n      String s = getStringRepresentationFor(myAllContents.get(i));\n      fullString += StringUtil.convertLineSeparators(s);\n    }\n\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n    }\n\n    if (myUseIdeaEditor) {\n      Document doc = EditorFactory.getInstance().createDocument(fullString);\n      myViewer = EditorFactory.getInstance().createViewer(doc, myProject);\n      myViewer.getComponent().setPreferredSize(new Dimension(300, 500));\n      myViewer.getSettings().setFoldingOutlineShown(false);\n      myViewer.getSettings().setLineNumbersShown(false);\n      myViewer.getSettings().setLineMarkerAreaShown(false);\n      myViewer.getSettings().setIndentGuidesShown(false);\n      mySplitter.setSecondComponent(myViewer.getComponent());\n    } else {\n      final JTextArea textArea = new JTextArea(fullString);\n      textArea.setRows(3);\n      textArea.setWrapStyleWord(true);\n      textArea.setLineWrap(true);\n      textArea.setSelectionStart(0);\n      textArea.setSelectionEnd(textArea.getText().length());\n      textArea.setEditable(false);\n      mySplitter.setSecondComponent(ScrollPaneFactory.createScrollPane(textArea));\n    }\n    mySplitter.revalidate();\n  }","id":40654,"modified_method":"private void updateViewerForSelection() {\n    if (myAllContents.size() == 0) return;\n    String fullString = \"\";\n    for (int i : getSelectedIndices()) {\n      String s = getStringRepresentationFor(myAllContents.get(i));\n      fullString += StringUtil.convertLineSeparators(s);\n    }\n\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n    }\n\n    if (myUseIdeaEditor) {\n      myViewer = createIdeaEditor(fullString);\n      JComponent component = myViewer.getComponent();\n      component.setPreferredSize(new Dimension(300, 500));\n      mySplitter.setSecondComponent(component);\n    } else {\n      final JTextArea textArea = new JTextArea(fullString);\n      textArea.setRows(3);\n      textArea.setWrapStyleWord(true);\n      textArea.setLineWrap(true);\n      textArea.setSelectionStart(0);\n      textArea.setSelectionEnd(textArea.getText().length());\n      textArea.setEditable(false);\n      mySplitter.setSecondComponent(ScrollPaneFactory.createScrollPane(textArea));\n    }\n    mySplitter.revalidate();\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void dispose() {\n    super.dispose();\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n      myViewer = null;\n    }\n  }","id":40655,"modified_method":"@Override\n  public void dispose() {\n    super.dispose();\n\n    SplitterProportionsData d = new SplitterProportionsDataImpl();\n    d.externalizeToDimensionService(getClass().getName());\n    d.saveSplitterProportions(mySplitter);\n\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n      myViewer = null;\n    }\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getDimensionServiceKey() {\n    return \"#com.intellij.openapi.editor.actions.MultiplePasteAction.Chooser\";\n  }","id":40656,"modified_method":"@Override\n  protected String getDimensionServiceKey() {\n    return getClass().getName(); // store different values for multi-paste, history and commit messages\n  }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n      // Fix GTK background\n      if (UIUtil.isUnderGTKLookAndFeel()){\n        final Color background = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\n        UIUtil.changeBackGround(this, background);\n      }\n      setIcon(AllIcons.FileTypes.Text);\n      if (index <= 9) {\n        append(String.valueOf((index + 1) % 10) + \"  \", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      append((String) value, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }","id":40657,"modified_method":"@Override\n    protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n      // Fix GTK background\n      if (UIUtil.isUnderGTKLookAndFeel()){\n        final Color background = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\n        UIUtil.changeBackGround(this, background);\n      }\n      setIcon(myListEntryIcon);\n      if (myUseIdeaEditor) {\n        int max = list.getModel().getSize();\n        String indexString = String.valueOf(index + 1);\n        int count = String.valueOf(max).length() - indexString.length();\n        char[] spaces = new char[count];\n        Arrays.fill(spaces, ' ');\n        String prefix = indexString + new String(spaces) + \"  \";\n        append(prefix, SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      String text = (String)value;\n\n      FontMetrics metrics = list.getFontMetrics(list.getFont());\n      int charWidth = metrics.charWidth('m');\n      int maxLength = list.getParent().getParent().getWidth() * 3 / charWidth / 2;\n      text = StringUtil.first(text, maxLength, true); // do not paint long strings\n      append(text, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }","commit_id":"f2c1c964d944188eb952583a4633d22eb4f5a8e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @todo can this take in a model instead of a project and still be successful?\n     * @todo In fact, does project REALLY need a MavenProject as a parent? Couldn't it have just a wrapper around a\n     * model that supported parents which were also the wrapper so that inheritence was assembled. We don't really need\n     * the resolved source roots, etc for the parent - that occurs for the parent when it is constructed independently\n     * and projects are not cached or reused\n     */\n    private MavenProject processProjectLogic( String pomLocation,\n                                              MavenProject project,\n                                              ProfileManager profileMgr,\n                                              File projectDir,\n                                              boolean strict )\n        throws ProjectBuildingException, ModelInterpolationException, InvalidRepositoryException\n    {\n        Model model = project.getModel();\n\n        List explicitlyActive;\n        List explicitlyInactive;\n        \n        if ( profileMgr != null )\n        {\n            explicitlyActive = profileMgr.getExplicitlyActivatedIds();\n            explicitlyInactive = profileMgr.getExplicitlyDeactivatedIds();\n        }\n        else\n        {\n            explicitlyActive = Collections.EMPTY_LIST;\n            explicitlyInactive = Collections.EMPTY_LIST;\n        }\n        \n        List active = profileAdvisor.applyActivatedProfiles( model, projectDir, explicitlyActive, explicitlyInactive );\n        \n        LinkedHashSet activated = new LinkedHashSet();\n        \n        activated.addAll( project.getActiveProfiles() );\n        activated.addAll( active );\n        \n        List activeProfiles = new ArrayList( activated );\n        project.setActiveProfiles( activeProfiles );\n\n        // TODO: Clean this up...we're using this to 'jump' the interpolation step for model properties not expressed in XML.\n        //  [BP] - Can this above comment be explained?\n        // We don't need all the project methods that are added over those in the model, but we do need basedir\n        // mkleint - using System.getProperties() is almost definitely bad for embedding.\n        Map context = new HashMap( System.getProperties() );\n\n        if ( projectDir != null )\n        {\n            context.put( \"basedir\", projectDir.getAbsolutePath() );\n        }\n\n        // TODO: this is a hack to ensure MNG-2124 can be satisfied without triggering MNG-1927\n        //  MNG-1927 relies on the false assumption that ${project.build.*} evaluates to null, which occurs before\n        //  MNG-2124 is fixed. The null value would leave it uninterpolated, to be handled after path translation.\n        //  Until these steps are correctly sequenced, we guarantee these fields remain uninterpolated.\n        context.put( \"build.directory\", null );\n        context.put( \"build.outputDirectory\", null );\n        context.put( \"build.testOutputDirectory\", null );\n        context.put( \"build.sourceDirectory\", null );\n        context.put( \"build.testSourceDirectory\", null );\n\n        model = modelInterpolator.interpolate( model, context, strict );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        Model originalModel = project.getOriginalModel();\n        \n        Artifact parentArtifact = project.getParentArtifact();\n\n        // We will return a different project object using the new model (hence the need to return a project, not just modify the parameter)\n        project = new MavenProject( model );\n\n        project.setOriginalModel( originalModel );\n\n        project.setActiveProfiles( activeProfiles );\n\n        // TODO: maybe not strictly correct, while we should enfore that packaging has a type handler of the same id, we don't\n        Artifact projectArtifact = artifactFactory.createBuildArtifact( project.getGroupId(), project.getArtifactId(),\n                                                                        project.getVersion(), project.getPackaging() );\n        project.setArtifact( projectArtifact );\n\n        project.setPluginArtifactRepositories( mavenTools.buildArtifactRepositories( model.getPluginRepositories() ) );\n\n        DistributionManagement dm = model.getDistributionManagement();\n        if ( dm != null )\n        {\n            ArtifactRepository repo = mavenTools.buildDeploymentArtifactRepository( dm.getRepository() );\n            project.setReleaseArtifactRepository( repo );\n\n            if ( dm.getSnapshotRepository() != null )\n            {\n                repo = mavenTools.buildDeploymentArtifactRepository( dm.getSnapshotRepository() );\n                project.setSnapshotArtifactRepository( repo );\n            }\n        }\n\n        project.setParent( parentProject );\n\n        if ( parentProject != null )\n        {\n//            Artifact parentArtifact = artifactFactory.createParentArtifact( parentProject.getGroupId(),\n//                                                                            parentProject.getArtifactId(),\n//                                                                            parentProject.getVersion() );\n            // the parent artifact from the parameter passed project instance is resolved.\n            project.setParentArtifact( parentArtifact );\n        }\n\n        // Must validate before artifact construction to make sure dependencies are good\n        ModelValidationResult validationResult = validator.validate( model );\n\n        String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new InvalidProjectModelException( projectId, pomLocation, \"Failed to validate POM\",\n                                                    validationResult );\n        }\n\n        project.setRemoteArtifactRepositories(\n            mavenTools.buildArtifactRepositories( model.getRepositories() ) );\n\n        // TODO: these aren't taking active project artifacts into consideration in the reactor\n        project.setPluginArtifacts( createPluginArtifacts( projectId, project.getBuildPlugins() ) );\n\n        project.setReportArtifacts( createReportArtifacts( projectId, project.getReportPlugins() ) );\n\n        project.setExtensionArtifacts( createExtensionArtifacts( projectId, project.getBuildExtensions() ) );\n\n        return project;\n    }","id":40658,"modified_method":"/**\n     * @todo can this take in a model instead of a project and still be successful?\n     * @todo In fact, does project REALLY need a MavenProject as a parent? Couldn't it have just a wrapper around a\n     * model that supported parents which were also the wrapper so that inheritence was assembled. We don't really need\n     * the resolved source roots, etc for the parent - that occurs for the parent when it is constructed independently\n     * and projects are not cached or reused\n     */\n    private MavenProject processProjectLogic( String pomLocation,\n                                              MavenProject project,\n                                              ProfileManager profileMgr,\n                                              File projectDir,\n                                              boolean strict )\n        throws ProjectBuildingException, ModelInterpolationException, InvalidRepositoryException\n    {\n        Model model = project.getModel();\n\n        List activeProfiles = project.getActiveProfiles();\n\n        // TODO: Clean this up...we're using this to 'jump' the interpolation step for model properties not expressed in XML.\n        //  [BP] - Can this above comment be explained?\n        // We don't need all the project methods that are added over those in the model, but we do need basedir\n        // mkleint - using System.getProperties() is almost definitely bad for embedding.\n        Map context = new HashMap( System.getProperties() );\n\n        if ( projectDir != null )\n        {\n            context.put( \"basedir\", projectDir.getAbsolutePath() );\n        }\n\n        // TODO: this is a hack to ensure MNG-2124 can be satisfied without triggering MNG-1927\n        //  MNG-1927 relies on the false assumption that ${project.build.*} evaluates to null, which occurs before\n        //  MNG-2124 is fixed. The null value would leave it uninterpolated, to be handled after path translation.\n        //  Until these steps are correctly sequenced, we guarantee these fields remain uninterpolated.\n        context.put( \"build.directory\", null );\n        context.put( \"build.outputDirectory\", null );\n        context.put( \"build.testOutputDirectory\", null );\n        context.put( \"build.sourceDirectory\", null );\n        context.put( \"build.testSourceDirectory\", null );\n\n        model = modelInterpolator.interpolate( model, context, strict );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        Model originalModel = project.getOriginalModel();\n        \n        Artifact parentArtifact = project.getParentArtifact();\n\n        // We will return a different project object using the new model (hence the need to return a project, not just modify the parameter)\n        project = new MavenProject( model );\n\n        project.setOriginalModel( originalModel );\n\n        project.setActiveProfiles( activeProfiles );\n\n        // TODO: maybe not strictly correct, while we should enfore that packaging has a type handler of the same id, we don't\n        Artifact projectArtifact = artifactFactory.createBuildArtifact( project.getGroupId(), project.getArtifactId(),\n                                                                        project.getVersion(), project.getPackaging() );\n        project.setArtifact( projectArtifact );\n\n        project.setPluginArtifactRepositories( mavenTools.buildArtifactRepositories( model.getPluginRepositories() ) );\n\n        DistributionManagement dm = model.getDistributionManagement();\n        if ( dm != null )\n        {\n            ArtifactRepository repo = mavenTools.buildDeploymentArtifactRepository( dm.getRepository() );\n            project.setReleaseArtifactRepository( repo );\n\n            if ( dm.getSnapshotRepository() != null )\n            {\n                repo = mavenTools.buildDeploymentArtifactRepository( dm.getSnapshotRepository() );\n                project.setSnapshotArtifactRepository( repo );\n            }\n        }\n\n        project.setParent( parentProject );\n\n        if ( parentProject != null )\n        {\n//            Artifact parentArtifact = artifactFactory.createParentArtifact( parentProject.getGroupId(),\n//                                                                            parentProject.getArtifactId(),\n//                                                                            parentProject.getVersion() );\n            // the parent artifact from the parameter passed project instance is resolved.\n            project.setParentArtifact( parentArtifact );\n        }\n\n        // Must validate before artifact construction to make sure dependencies are good\n        ModelValidationResult validationResult = validator.validate( model );\n\n        String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new InvalidProjectModelException( projectId, pomLocation, \"Failed to validate POM\",\n                                                    validationResult );\n        }\n\n        project.setRemoteArtifactRepositories(\n            mavenTools.buildArtifactRepositories( model.getRepositories() ) );\n\n        // TODO: these aren't taking active project artifacts into consideration in the reactor\n        project.setPluginArtifacts( createPluginArtifacts( projectId, project.getBuildPlugins() ) );\n\n        project.setReportArtifacts( createReportArtifacts( projectId, project.getReportPlugins() ) );\n\n        project.setExtensionArtifacts( createExtensionArtifacts( projectId, project.getBuildExtensions() ) );\n\n        return project;\n    }","commit_id":"87226eab2eee91bce6faf44888361ad3936c86d4","url":"https://github.com/apache/maven"},{"original_method":"@Override\n\tpublic void merge(ConfigurableEnvironment parent) {\n\t\tfor (PropertySource<?> ps : parent.getPropertySources()) {\n\t\t\tif (!this.propertySources.contains(ps.getName())) {\n\t\t\t\tthis.propertySources.addLast(ps);\n\t\t\t}\n\t\t}\n\t\tfor (String profile : parent.getActiveProfiles()) {\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t\tif (parent.getDefaultProfiles().length > 0) {\n\t\t\tthis.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\n\t\t\tfor (String profile : parent.getDefaultProfiles()) {\n\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}","id":40659,"modified_method":"@Override\n\tpublic void merge(ConfigurableEnvironment parent) {\n\t\tfor (PropertySource<?> ps : parent.getPropertySources()) {\n\t\t\tif (!this.propertySources.contains(ps.getName())) {\n\t\t\t\tthis.propertySources.addLast(ps);\n\t\t\t}\n\t\t}\n\t\tString[] parentActiveProfiles = parent.getActiveProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentActiveProfiles)) {\n\t\t\tsynchronized (this.activeProfiles) {\n\t\t\t\tfor (String profile : parentActiveProfiles) {\n\t\t\t\t\tthis.activeProfiles.add(profile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString[] parentDefaultProfiles = parent.getDefaultProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\n\t\t\tsynchronized (this.defaultProfiles) {\n\t\t\t\tthis.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\n\t\t\t\tfor (String profile : parentDefaultProfiles) {\n\t\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void setActiveProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tthis.activeProfiles.clear();\n\t\tfor (String profile : profiles) {\n\t\t\tvalidateProfile(profile);\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t}","id":40660,"modified_method":"@Override\n\tpublic void setActiveProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.activeProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of the {@value #ACTIVE_PROFILES_PROPERTY_NAME}\n\t * property and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tprotected Set<String> doGetActiveProfiles() {\n\t\tif (this.activeProfiles.isEmpty()) {\n\t\t\tString profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\n\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\tsetActiveProfiles(commaDelimitedListToStringArray(trimAllWhitespace(profiles)));\n\t\t\t}\n\t\t}\n\t\treturn this.activeProfiles;\n\t}","id":40661,"modified_method":"/**\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of the {@value #ACTIVE_PROFILES_PROPERTY_NAME}\n\t * property and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tprotected Set<String> doGetActiveProfiles() {\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tif (this.activeProfiles.isEmpty()) {\n\t\t\t\tString profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetActiveProfiles(commaDelimitedListToStringArray(trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.activeProfiles;\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of the\n\t * {@value #DEFAULT_PROFILES_PROPERTY_NAME} property and assign its value (if any)\n\t * to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t * @see #getReservedDefaultProfiles()\n\t */\n\tprotected Set<String> doGetDefaultProfiles() {\n\t\tif (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\n\t\t\tString profiles = getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\n\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\tsetDefaultProfiles(commaDelimitedListToStringArray(trimAllWhitespace(profiles)));\n\t\t\t}\n\t\t}\n\t\treturn this.defaultProfiles;\n\t}","id":40662,"modified_method":"/**\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of the\n\t * {@value #DEFAULT_PROFILES_PROPERTY_NAME} property and assign its value (if any)\n\t * to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t * @see #getReservedDefaultProfiles()\n\t */\n\tprotected Set<String> doGetDefaultProfiles() {\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tif (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\n\t\t\t\tString profiles = getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetDefaultProfiles(commaDelimitedListToStringArray(trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.defaultProfiles;\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t */\n\t@Override\n\tpublic void setDefaultProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tthis.defaultProfiles.clear();\n\t\tfor (String profile : profiles) {\n\t\t\tvalidateProfile(profile);\n\t\t\tthis.defaultProfiles.add(profile);\n\t\t}\n\t}","id":40663,"modified_method":"/**\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t */\n\t@Override\n\tpublic void setDefaultProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tthis.defaultProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void addActiveProfile(String profile) {\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(format(\"Activating profile '%s'\", profile));\n\t\t}\n\t\tvalidateProfile(profile);\n\t\tdoGetActiveProfiles();\n\t\tthis.activeProfiles.add(profile);\n\t}","id":40664,"modified_method":"@Override\n\tpublic void addActiveProfile(String profile) {\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(format(\"Activating profile '%s'\", profile));\n\t\t}\n\t\tvalidateProfile(profile);\n\t\tdoGetActiveProfiles();\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean acceptsProfiles(String... profiles) {\n\t\tAssert.notEmpty(profiles, \"Must specify at least one profile\");\n\t\tfor (String profile : profiles) {\n\t\t\tif (profile != null && profile.length() > 0 && profile.charAt(0) == '!') {\n\t\t\t\tif (!isProfileActive(profile.substring(1))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isProfileActive(profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":40665,"modified_method":"@Override\n\tpublic boolean acceptsProfiles(String... profiles) {\n\t\tAssert.notEmpty(profiles, \"Must specify at least one profile\");\n\t\tfor (String profile : profiles) {\n\t\t\tif (StringUtils.hasLength(profile) && profile.charAt(0) == '!') {\n\t\t\t\tif (!isProfileActive(profile.substring(1))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isProfileActive(profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t */\n\tprotected boolean isProfileActive(String profile) {\n\t\tvalidateProfile(profile);\n\t\treturn doGetActiveProfiles().contains(profile) ||\n\t\t\t\t(doGetActiveProfiles().isEmpty() && doGetDefaultProfiles().contains(profile));\n\t}","id":40666,"modified_method":"/**\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t */\n\tprotected boolean isProfileActive(String profile) {\n\t\tvalidateProfile(profile);\n\t\tSet<String> currentActiveProfiles = doGetActiveProfiles();\n\t\treturn (currentActiveProfiles.contains(profile) ||\n\t\t\t\t(currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\n\t}","commit_id":"e393c7b1ee03321ab2afda7ea8aff775128aca94","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public RadialGradient(PShapeSVG parent, XML properties) {\n      super(parent, properties);\n\n      this.cx = getFloatWithUnit(properties, \"cx\");\n      this.cy = getFloatWithUnit(properties, \"cy\");\n      this.r  = getFloatWithUnit(properties, \"r\");\n\n      String transformStr =\n        properties.getString(\"gradientTransform\");\n\n      if (transformStr != null) {\n        float t[] = parseTransform(transformStr).get(null);\n        this.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n        Point2D t1 = transform.transform(new Point2D.Float(cx, cy), null);\n        Point2D t2 = transform.transform(new Point2D.Float(cx + r, cy), null);\n\n        this.cx = (float) t1.getX();\n        this.cy = (float) t1.getY();\n        this.r = (float) (t2.getX() - t1.getX());\n      }\n    }","id":40667,"modified_method":"public RadialGradient(PShapeSVG parent, XML properties) {\n      super(parent, properties);\n\n      this.cx = getFloatWithUnit(properties, \"cx\", svgWidth);\n      this.cy = getFloatWithUnit(properties, \"cy\", svgHeight);\n      this.r  = getFloatWithUnit(properties, \"r\", svgXYSize);\n\n      String transformStr =\n        properties.getString(\"gradientTransform\");\n\n      if (transformStr != null) {\n        float t[] = parseTransform(transformStr).get(null);\n        this.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n        Point2D t1 = transform.transform(new Point2D.Float(cx, cy), null);\n        Point2D t2 = transform.transform(new Point2D.Float(cx + r, cy), null);\n\n        this.cx = (float) t1.getX();\n        this.cy = (float) t1.getY();\n        this.r = (float) (t2.getX() - t1.getX());\n      }\n    }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Used in place of element.getFloatAttribute(a) because we can\n   * have a unit suffix (length or coordinate).\n   * @param element what to parse\n   * @param attribute name of the attribute to get\n   * @return unit-parsed version of the data\n   */\n  static protected float getFloatWithUnit(XML element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }","id":40668,"modified_method":"/**\n   * Used in place of element.getFloatAttribute(a) because we can\n   * have a unit suffix (length or coordinate).\n   * @param element what to parse\n   * @param attribute name of the attribute to get\n   * @param relativeTo (float) Used for %. When relative to viewbox, should\n   *    be svgWidth for horizontal dimentions, svgHeight for vertical, and\n   *    svgXYSize for anything else.\n   * @return unit-parsed version of the data\n   */\n  static protected float getFloatWithUnit(XML element, String attribute, float relativeTo) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val, relativeTo);\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"public LinearGradient(PShapeSVG parent, XML properties) {\n      super(parent, properties);\n\n      this.x1 = getFloatWithUnit(properties, \"x1\");\n      this.y1 = getFloatWithUnit(properties, \"y1\");\n      this.x2 = getFloatWithUnit(properties, \"x2\");\n      this.y2 = getFloatWithUnit(properties, \"y2\");\n\n      String transformStr =\n        properties.getString(\"gradientTransform\");\n\n      if (transformStr != null) {\n        float t[] = parseTransform(transformStr).get(null);\n        this.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n        Point2D t1 = transform.transform(new Point2D.Float(x1, y1), null);\n        Point2D t2 = transform.transform(new Point2D.Float(x2, y2), null);\n\n        this.x1 = (float) t1.getX();\n        this.y1 = (float) t1.getY();\n        this.x2 = (float) t2.getX();\n        this.y2 = (float) t2.getY();\n      }\n    }","id":40669,"modified_method":"public LinearGradient(PShapeSVG parent, XML properties) {\n      super(parent, properties);\n\n      this.x1 = getFloatWithUnit(properties, \"x1\", svgWidth);\n      this.y1 = getFloatWithUnit(properties, \"y1\", svgHeight);\n      this.x2 = getFloatWithUnit(properties, \"x2\", svgWidth);\n      this.y2 = getFloatWithUnit(properties, \"y2\", svgHeight);\n\n      String transformStr =\n        properties.getString(\"gradientTransform\");\n\n      if (transformStr != null) {\n        float t[] = parseTransform(transformStr).get(null);\n        this.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n        Point2D t1 = transform.transform(new Point2D.Float(x1, y1), null);\n        Point2D t2 = transform.transform(new Point2D.Float(x2, y2), null);\n\n        this.x1 = (float) t1.getX();\n        this.y1 = (float) t1.getY();\n        this.x2 = (float) t2.getX();\n        this.y2 = (float) t2.getY();\n      }\n    }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"protected PShapeSVG(PShapeSVG parent, XML properties, boolean parseKids) {\n    // Need to set this so that findChild() works.\n    // Otherwise 'parent' is null until addChild() is called later.\n    this.parent = parent;\n\n    if (parent == null) {\n      // set values to their defaults according to the SVG spec\n      stroke = false;\n      strokeColor = 0xff000000;\n      strokeWeight = 1;\n      strokeCap = PConstants.SQUARE;  // equivalent to BUTT in svg spec\n      strokeJoin = PConstants.MITER;\n      strokeGradient = null;\n      strokeGradientPaint = null;\n      strokeName = null;\n\n      fill = true;\n      fillColor = 0xff000000;\n      fillGradient = null;\n      fillGradientPaint = null;\n      fillName = null;\n\n      //hasTransform = false;\n      //transformation = null; //new float[] { 1, 0, 0, 1, 0, 0 };\n\n      strokeOpacity = 1;\n      fillOpacity = 1;\n      opacity = 1;\n\n    } else {\n      stroke = parent.stroke;\n      strokeColor = parent.strokeColor;\n      strokeWeight = parent.strokeWeight;\n      strokeCap = parent.strokeCap;\n      strokeJoin = parent.strokeJoin;\n      strokeGradient = parent.strokeGradient;\n      strokeGradientPaint = parent.strokeGradientPaint;\n      strokeName = parent.strokeName;\n\n      fill = parent.fill;\n      fillColor = parent.fillColor;\n      fillGradient = parent.fillGradient;\n      fillGradientPaint = parent.fillGradientPaint;\n      fillName = parent.fillName;\n\n      //hasTransform = parent.hasTransform;\n      //transformation = parent.transformation;\n\n      opacity = parent.opacity;\n    }\n\n    element = properties;\n    name = properties.getString(\"id\");\n    // @#$(* adobe illustrator mangles names of objects when re-saving\n    if (name != null) {\n      while (true) {\n        String[] m = PApplet.match(name, \"_x([A-Za-z0-9]{2})_\");\n        if (m == null) break;\n        char repair = (char) PApplet.unhex(m[1]);\n        name = name.replace(m[0], \"\" + repair);\n      }\n    }\n\n    String displayStr = properties.getString(\"display\", \"inline\");\n    visible = !displayStr.equals(\"none\");\n\n    String transformStr = properties.getString(\"transform\");\n    if (transformStr != null) {\n      matrix = parseTransform(transformStr);\n    }\n\n    if (parseKids) {\n      parseColors(properties);\n      parseChildren(properties);\n    }\n  }","id":40670,"modified_method":"protected PShapeSVG(PShapeSVG parent, XML properties, boolean parseKids) {\n    // Need to set this so that findChild() works.\n    // Otherwise 'parent' is null until addChild() is called later.\n    this.parent = parent;\n\n    if (parent == null) {\n      // set values to their defaults according to the SVG spec\n      stroke = false;\n      strokeColor = 0xff000000;\n      strokeWeight = 1;\n      strokeCap = PConstants.SQUARE;  // equivalent to BUTT in svg spec\n      strokeJoin = PConstants.MITER;\n      strokeGradient = null;\n      strokeGradientPaint = null;\n      strokeName = null;\n\n      fill = true;\n      fillColor = 0xff000000;\n      fillGradient = null;\n      fillGradientPaint = null;\n      fillName = null;\n\n      //hasTransform = false;\n      //transformation = null; //new float[] { 1, 0, 0, 1, 0, 0 };\n\n      // svgWidth, svgHeight, and svgXYSize done below.\n\n      strokeOpacity = 1;\n      fillOpacity = 1;\n      opacity = 1;\n\n    } else {\n      stroke = parent.stroke;\n      strokeColor = parent.strokeColor;\n      strokeWeight = parent.strokeWeight;\n      strokeCap = parent.strokeCap;\n      strokeJoin = parent.strokeJoin;\n      strokeGradient = parent.strokeGradient;\n      strokeGradientPaint = parent.strokeGradientPaint;\n      strokeName = parent.strokeName;\n\n      fill = parent.fill;\n      fillColor = parent.fillColor;\n      fillGradient = parent.fillGradient;\n      fillGradientPaint = parent.fillGradientPaint;\n      fillName = parent.fillName;\n\n      //hasTransform = parent.hasTransform;\n      //transformation = parent.transformation;\n\n      svgWidth  = parent.svgWidth;\n      svgHeight = parent.svgHeight;\n      svgXYSize = parent.svgXYSize;\n\n      opacity = parent.opacity;\n    }\n\n    // Need to get width/height in early.\n    if (properties.getName().equals(\"svg\")) {\n      String unitWidth = properties.getString(\"width\");\n      String unitHeight = properties.getString(\"height\");\n\n      // Can't handle width/height as percentages easily. I'm just going\n      // to put in 100 as a dummy value, beacuse this means that it will\n      // come out as a reasonable value.\n      if (unitWidth  != null) width  = parseUnitSize(unitWidth,  100);\n      if (unitHeight != null) height = parseUnitSize(unitHeight, 100);\n\n      String viewBoxStr = properties.getString(\"viewBox\");\n      if (viewBoxStr != null) {\n        float[] viewBox = PApplet.parseFloat(PApplet.splitTokens(viewBoxStr));\n        if (unitWidth == null || unitHeight == null) {\n          // Not proper parsing of the viewBox, but will cover us for cases where\n          // the width and height of the object is not specified.\n          width = viewBox[2];\n          height = viewBox[3];\n        } else {\n          // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n          // TODO: preserveAspectRatio.\n          if (matrix == null) matrix = new PMatrix2D();\n          matrix.scale(width/viewBox[2], height/viewBox[3]);\n          matrix.translate(-viewBox[0], -viewBox[1]);\n        }\n      }\n\n      // Negative size is illegal.\n      if (width < 0 || height < 0)\n        throw new RuntimeException(\"<svg>: width (\" + width +\n        \") and height (\" + height + \") must not be negative.\");\n\n      // It's technically valid to have width or height == 0. Not specified at\n      // all is what to test for.\n      if ((unitWidth == null || unitHeight == null) && viewBoxStr == null) {\n        //throw new RuntimeException(\"width/height not specified\");\n        PGraphics.showWarning(\"The width and/or height is not \" +\n                              \"readable in the <svg> tag of this file.\");\n        // For the spec, the default is 100% and 100%. For purposes\n        // here, insert a dummy value because this is prolly just a\n        // font or something for which the w/h doesn't matter.\n        width = 1;\n        height = 1;\n      }\n\n      svgWidth = width;\n      svgHeight = height;\n      svgXYSize = PApplet.sqrt((svgWidth*svgWidth + svgHeight*svgHeight)/2.0f);\n    }\n\n    element = properties;\n    name = properties.getString(\"id\");\n    // @#$(* adobe illustrator mangles names of objects when re-saving\n    if (name != null) {\n      while (true) {\n        String[] m = PApplet.match(name, \"_x([A-Za-z0-9]{2})_\");\n        if (m == null) break;\n        char repair = (char) PApplet.unhex(m[1]);\n        name = name.replace(m[0], \"\" + repair);\n      }\n    }\n\n    String displayStr = properties.getString(\"display\", \"inline\");\n    visible = !displayStr.equals(\"none\");\n\n    String transformStr = properties.getString(\"transform\");\n    if (transformStr != null) {\n      if (matrix == null) {\n        matrix = parseTransform(transformStr);\n      } else {\n        matrix.preApply(parseTransform(transformStr));\n      }\n    }\n\n    if (parseKids) {\n      parseColors(properties);\n      parseChildren(properties);\n    }\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Parse a polyline or polygon from an SVG file.\n   * @param close true if shape is closed (polygon), false if not (polyline)\n   */\n  protected void parsePoly(boolean close) {\n    family = PATH;\n    this.close = close;\n\n    String pointsAttr = element.getString(\"points\");\n    if (pointsAttr != null) {\n      String[] pointsBuffer = PApplet.splitTokens(pointsAttr);\n      vertexCount = pointsBuffer.length;\n      vertices = new float[vertexCount][2];\n      for (int i = 0; i < vertexCount; i++) {\n        String pb[] = PApplet.split(pointsBuffer[i], ',');\n        vertices[i][X] = Float.valueOf(pb[0]).floatValue();\n        vertices[i][Y] = Float.valueOf(pb[1]).floatValue();\n      }\n    }\n  }","id":40671,"modified_method":"/**\n   * Parse a polyline or polygon from an SVG file.\n   * Syntax defined at http://www.w3.org/TR/SVG/shapes.html#PointsBNF\n   * @param close true if shape is closed (polygon), false if not (polyline)\n   */\n  protected void parsePoly(boolean close) {\n    family = PATH;\n    this.close = close;\n\n    String pointsAttr = element.getString(\"points\");\n    if (pointsAttr != null) {\n      String[] pointsBuffer = PApplet.splitTokens(pointsAttr);\n      vertexCount = pointsBuffer.length;\n      vertices = new float[vertexCount][2];\n      for (int i = 0; i < vertexCount; i++) {\n        String pb[] = PApplet.splitTokens(pointsBuffer[i], \", \\t\\r\\n\");\n        vertices[i][X] = Float.parseFloat(pb[0]);\n        vertices[i][Y] = Float.parseFloat(pb[1]);\n      }\n    }\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"protected void parseLine() {\n    kind = LINE;\n    family = PRIMITIVE;\n    params = new float[] {\n      getFloatWithUnit(element, \"x1\"),\n      getFloatWithUnit(element, \"y1\"),\n      getFloatWithUnit(element, \"x2\"),\n      getFloatWithUnit(element, \"y2\")\n    };\n  }","id":40672,"modified_method":"protected void parseLine() {\n    kind = LINE;\n    family = PRIMITIVE;\n    params = new float[] {\n      getFloatWithUnit(element, \"x1\", svgWidth),\n      getFloatWithUnit(element, \"y1\", svgHeight),\n      getFloatWithUnit(element, \"x2\", svgWidth),\n      getFloatWithUnit(element, \"y2\", svgHeight)\n    };\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"protected void parseRect() {\n    kind = RECT;\n    family = PRIMITIVE;\n    params = new float[] {\n      getFloatWithUnit(element, \"x\"),\n      getFloatWithUnit(element, \"y\"),\n      getFloatWithUnit(element, \"width\"),\n      getFloatWithUnit(element, \"height\")\n    };\n  }","id":40673,"modified_method":"protected void parseRect() {\n    kind = RECT;\n    family = PRIMITIVE;\n    params = new float[] {\n      getFloatWithUnit(element, \"x\", svgWidth),\n      getFloatWithUnit(element, \"y\", svgHeight),\n      getFloatWithUnit(element, \"width\", svgWidth),\n      getFloatWithUnit(element, \"height\", svgHeight)\n    };\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"public Gradient(PShapeSVG parent, XML properties) {\n      super(parent, properties, true);\n\n      XML elements[] = properties.getChildren();\n      offset = new float[elements.length];\n      color = new int[elements.length];\n\n      // <stop  offset=\"0\" style=\"stop-color:#967348\"/>\n      for (int i = 0; i < elements.length; i++) {\n        XML elem = elements[i];\n        String name = elem.getName();\n        if (name.equals(\"stop\")) {\n          String offsetAttr = elem.getString(\"offset\");\n          float div = 1.0f;\n          if (offsetAttr.endsWith(\"%\")) {\n            div = 100.0f;\n            offsetAttr = offsetAttr.substring(0, offsetAttr.length() - 1);\n          }\n          offset[count] = PApplet.parseFloat(offsetAttr) / div;\n          String style = elem.getString(\"style\");\n          HashMap<String, String> styles = parseStyleAttributes(style);\n\n          String colorStr = styles.get(\"stop-color\");\n          if (colorStr == null) colorStr = \"#000000\";\n          String opacityStr = styles.get(\"stop-opacity\");\n          if (opacityStr == null) opacityStr = \"1\";\n          int tupacity = (int) (PApplet.parseFloat(opacityStr) * 255);\n          color[count] = (tupacity << 24) |\n            Integer.parseInt(colorStr.substring(1), 16);\n          count++;\n        }\n      }\n      offset = PApplet.subset(offset, 0, count);\n      color = PApplet.subset(color, 0, count);\n    }","id":40674,"modified_method":"public Gradient(PShapeSVG parent, XML properties) {\n      super(parent, properties, true);\n\n      XML elements[] = properties.getChildren();\n      offset = new float[elements.length];\n      color = new int[elements.length];\n\n      // <stop  offset=\"0\" style=\"stop-color:#967348\"/>\n      for (int i = 0; i < elements.length; i++) {\n        XML elem = elements[i];\n        String name = elem.getName();\n        if (name.equals(\"stop\")) {\n          String offsetAttr = elem.getString(\"offset\");\n          offset[count] = parseFloatOrPercent(offsetAttr);\n\n          String style = elem.getString(\"style\");\n          HashMap<String, String> styles = parseStyleAttributes(style);\n\n          String colorStr = styles.get(\"stop-color\");\n          if (colorStr == null) {\n            colorStr = elem.getString(\"stop-color\");\n            if (colorStr == null) colorStr = \"#000000\";\n          }\n          String opacityStr = styles.get(\"stop-opacity\");\n          if (opacityStr == null) {\n            opacityStr = elem.getString(\"stop-opacity\");\n            if (opacityStr == null) opacityStr = \"1\";\n          }\n          int tupacity = PApplet.constrain(\n                          (int)(PApplet.parseFloat(opacityStr) * 255), 0, 255);\n          color[count] = (tupacity << 24) | parseSimpleColor(colorStr);\n          count++;\n        }\n      }\n      offset = PApplet.subset(offset, 0, count);\n      color = PApplet.subset(color, 0, count);\n    }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"void setColor(String colorText, boolean isFill) {\n    int opacityMask = fillColor & 0xFF000000;\n    boolean visible = true;\n    int color = 0;\n    String name = \"\";\n    Gradient gradient = null;\n    Paint paint = null;\n    if (colorText.equals(\"none\")) {\n      visible = false;\n    } else if (colorText.equals(\"black\")) {\n      color = opacityMask;\n    } else if (colorText.equals(\"white\")) {\n      color = opacityMask | 0xFFFFFF;\n    } else if (colorText.startsWith(\"#\")) {\n      if (colorText.length() == 4) {\n        // Short form: #ABC, transform to long form #AABBCC\n        colorText = colorText.replaceAll(\"^#(.)(.)(.)$\", \"#$1$1$2$2$3$3\");\n      }\n      color = opacityMask |\n          (Integer.parseInt(colorText.substring(1), 16)) & 0xFFFFFF;\n      //System.out.println(\"hex for fill is \" + PApplet.hex(fillColor));\n    } else if (colorText.startsWith(\"rgb\")) {\n      color = opacityMask | parseRGB(colorText);\n    } else if (colorText.startsWith(\"url(#\")) {\n      name = colorText.substring(5, colorText.length() - 1);\n//      PApplet.println(\"looking for \" + name);\n      Object object = findChild(name);\n      //PApplet.println(\"found \" + fillObject);\n      if (object instanceof Gradient) {\n        gradient = (Gradient) object;\n        paint = calcGradientPaint(gradient); //, opacity);\n        //PApplet.println(\"got filla \" + fillObject);\n      } else {\n//        visible = false;\n        System.err.println(\"url \" + name + \" refers to unexpected data: \" + object);\n      }\n    }\n    if (isFill) {\n      fill = visible;\n      fillColor = color;\n      fillName = name;\n      fillGradient = gradient;\n      fillGradientPaint = paint;\n    } else {\n      stroke = visible;\n      strokeColor = color;\n      strokeName = name;\n      strokeGradient = gradient;\n      strokeGradientPaint = paint;\n    }\n  }","id":40675,"modified_method":"void setColor(String colorText, boolean isFill) {\n    colorText = colorText.trim();\n    int opacityMask = fillColor & 0xFF000000;\n    boolean visible = true;\n    int color = 0;\n    String name = \"\";\n    String lColorText = colorText.toLowerCase();\n    Gradient gradient = null;\n    Paint paint = null;\n    if (colorText.equals(\"none\")) {\n      visible = false;\n    } else if (colorText.startsWith(\"url(#\")) {\n      name = colorText.substring(5, colorText.length() - 1);\n      Object object = findChild(name);\n      if (object instanceof Gradient) {\n        gradient = (Gradient) object;\n        paint = calcGradientPaint(gradient); //, opacity);\n      } else {\n//        visible = false;\n        System.err.println(\"url \" + name + \" refers to unexpected data: \" + object);\n      }\n    } else {\n      // Prints errors itself.\n      color = opacityMask | parseSimpleColor(colorText);\n    }\n    if (isFill) {\n      fill = visible;\n      fillColor = color;\n      fillName = name;\n      fillGradient = gradient;\n      fillGradientPaint = paint;\n    } else {\n      stroke = visible;\n      strokeColor = color;\n      strokeName = name;\n      strokeGradient = gradient;\n      strokeGradientPaint = paint;\n    }\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"static protected int parseRGB(String what) {\n    int leftParen = what.indexOf('(') + 1;\n    int rightParen = what.indexOf(')');\n    String sub = what.substring(leftParen, rightParen);\n    int[] values = PApplet.parseInt(PApplet.splitTokens(sub, \", \"));\n    return (values[0] << 16) | (values[1] << 8) | (values[2]);\n  }","id":40676,"modified_method":"static protected int parseRGB(String what) {\n    int leftParen = what.indexOf('(') + 1;\n    int rightParen = what.indexOf(')');\n    String sub = what.substring(leftParen, rightParen);\n    String[] values = PApplet.splitTokens(sub, \", \");\n    int rgbValue = 0;\n    if (values.length == 3) {\n      // Color spec allows for rgb values to be percentages.\n      for (int i = 0; i < 3; i++) {\n        rgbValue <<= 8;\n        if (values[i].endsWith(\"%\")) {\n          rgbValue |= (int)(PApplet.constrain(255*parseFloatOrPercent(values[i]), 0, 255));\n        } else {\n          rgbValue |= PApplet.constrain(PApplet.parseInt(values[i]), 0, 255);\n        }\n      }\n    } else System.err.println(\"Could not read color \\\"\" + what + \"\\\".\");\n\n    return rgbValue;\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Initializes a new SVG Object from the given PNode.\n   */\n  public PShapeSVG(XML svg) {\n    this(null, svg, true);\n\n    if (!svg.getName().equals(\"svg\")) {\n      throw new RuntimeException(\"root is not <svg>, it's <\" + svg.getName() + \">\");\n    }\n\n    // not proper parsing of the viewBox, but will cover us for cases where\n    // the width and height of the object is not specified\n    String viewBoxStr = svg.getString(\"viewBox\");\n    if (viewBoxStr != null) {\n      int[] viewBox = PApplet.parseInt(PApplet.splitTokens(viewBoxStr));\n      width = viewBox[2];\n      height = viewBox[3];\n    }\n\n    // TODO if viewbox is not same as width/height, then use it to scale\n    // the original objects. for now, viewbox only used when width/height\n    // are empty values (which by the spec means w/h of \"100%\"\n    String unitWidth = svg.getString(\"width\");\n    String unitHeight = svg.getString(\"height\");\n    if (unitWidth != null) {\n      width = parseUnitSize(unitWidth);\n      height = parseUnitSize(unitHeight);\n    } else {\n      if ((width == 0) || (height == 0)) {\n        //throw new RuntimeException(\"width/height not specified\");\n        PGraphics.showWarning(\"The width and/or height is not \" +\n                              \"readable in the <svg> tag of this file.\");\n        // For the spec, the default is 100% and 100%. For purposes\n        // here, insert a dummy value because this is prolly just a\n        // font or something for which the w/h doesn't matter.\n        width = 1;\n        height = 1;\n      }\n    }\n\n    //root = new Group(null, svg);\n//    parseChildren(svg);  // ?\n  }","id":40677,"modified_method":"/**\n   * Initializes a new SVG Object from the given XML.\n   */\n  public PShapeSVG(XML svg) {\n    this(null, svg, true);\n\n    if (!svg.getName().equals(\"svg\")) {\n      throw new RuntimeException(\"The root node is not <svg>, it's <\" + svg.getName() + \">.\" +\n         (svg.getName().toLowerCase().equals(\"html\") ?\n         \" That means it's just a webpage. Did you download it right?\" : \"\"));\n    }\n\n\n    //root = new Group(null, svg);\n//    parseChildren(svg);  // ?\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"protected void parsePath() {\n    family = PATH;\n    kind = 0;\n\n    String pathData = element.getString(\"d\");\n    if (pathData == null || PApplet.trim(pathData).length() == 0) {\n      return;\n    }\n    char[] pathDataChars = pathData.toCharArray();\n\n    StringBuilder pathBuffer = new StringBuilder();\n    boolean lastSeparate = false;\n\n    for (int i = 0; i < pathDataChars.length; i++) {\n      char c = pathDataChars[i];\n      boolean separate = false;\n\n      if (c == 'M' || c == 'm' ||\n          c == 'L' || c == 'l' ||\n          c == 'H' || c == 'h' ||\n          c == 'V' || c == 'v' ||\n          c == 'C' || c == 'c' ||  // beziers\n          c == 'S' || c == 's' ||\n          c == 'Q' || c == 'q' ||  // quadratic beziers\n          c == 'T' || c == 't' ||\n          c == 'A' || c == 'a' ||  // elliptical arc\n          c == 'Z' || c == 'z' ||  // closepath\n          c == ',') {\n        separate = true;\n        if (i != 0) {\n          pathBuffer.append(\"|\");\n        }\n      }\n      if (c == 'Z' || c == 'z') {\n        separate = false;\n      }\n      if (c == '-' && !lastSeparate) {\n        // allow for 'e' notation in numbers, e.g. 2.10e-9\n        // http://dev.processing.org/bugs/show_bug.cgi?id=1408\n        if (i == 0 || pathDataChars[i-1] != 'e') {\n          pathBuffer.append(\"|\");\n        }\n      }\n      if (c != ',') {\n        pathBuffer.append(c); //\"\" + pathDataBuffer.charAt(i));\n      }\n      if (separate && c != ',' && c != '-') {\n        pathBuffer.append(\"|\");\n      }\n      lastSeparate = separate;\n    }\n\n    // use whitespace constant to get rid of extra spaces and CR or LF\n    String[] pathTokens =\n      PApplet.splitTokens(pathBuffer.toString(), \"|\" + WHITESPACE);\n    vertices = new float[pathTokens.length][2];\n    vertexCodes = new int[pathTokens.length];\n\n    float cx = 0;\n    float cy = 0;\n    int i = 0;\n\n    char implicitCommand = '\\0';\n//    char prevCommand = '\\0';\n    boolean prevCurve = false;\n    float ctrlX, ctrlY;\n    // store values for closepath so that relative coords work properly\n    float movetoX = 0;\n    float movetoY = 0;\n\n    while (i < pathTokens.length) {\n      char c = pathTokens[i].charAt(0);\n      if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\\0') {\n        c = implicitCommand;\n        i--;\n      } else {\n        implicitCommand = c;\n      }\n      switch (c) {\n\n      case 'M':  // M - move to (absolute)\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        cy = PApplet.parseFloat(pathTokens[i + 2]);\n        movetoX = cx;\n        movetoY = cy;\n        parsePathMoveto(cx, cy);\n        implicitCommand = 'L';\n        i += 3;\n        break;\n\n      case 'm':  // m - move to (relative)\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        cy = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        movetoX = cx;\n        movetoY = cy;\n        parsePathMoveto(cx, cy);\n        implicitCommand = 'l';\n        i += 3;\n        break;\n\n      case 'L':\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        cy = PApplet.parseFloat(pathTokens[i + 2]);\n        parsePathLineto(cx, cy);\n        i += 3;\n        break;\n\n      case 'l':\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        cy = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        parsePathLineto(cx, cy);\n        i += 3;\n        break;\n\n        // horizontal lineto absolute\n      case 'H':\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n        // horizontal lineto relative\n      case 'h':\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n      case 'V':\n        cy = PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n      case 'v':\n        cy = cy + PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n        // C - curve to (absolute)\n      case 'C': {\n        float ctrlX1 = PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY1 = PApplet.parseFloat(pathTokens[i + 2]);\n        float ctrlX2 = PApplet.parseFloat(pathTokens[i + 3]);\n        float ctrlY2 = PApplet.parseFloat(pathTokens[i + 4]);\n        float endX = PApplet.parseFloat(pathTokens[i + 5]);\n        float endY = PApplet.parseFloat(pathTokens[i + 6]);\n        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 7;\n        prevCurve = true;\n      }\n      break;\n\n        // c - curve to (relative)\n      case 'c': {\n        float ctrlX1 = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY1 = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 5]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 6]);\n        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 7;\n        prevCurve = true;\n      }\n      break;\n\n      // S - curve to shorthand (absolute)\n      // Draws a cubic Bzier curve from the current point to (x,y). The first\n      // control point is assumed to be the reflection of the second control\n      // point on the previous command relative to the current point.\n      // (x2,y2) is the second control point (i.e., the control point\n      // at the end of the curve). S (uppercase) indicates that absolute\n      // coordinates will follow; s (lowercase) indicates that relative\n      // coordinates will follow. Multiple sets of coordinates may be specified\n      // to draw a polybzier. At the end of the command, the new current point\n      // becomes the final (x,y) coordinate pair used in the polybzier.\n      case 'S': {\n        // (If there is no previous command or if the previous command was not\n        // an C, c, S or s, assume the first control point is coincident with\n        // the current point.)\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float ctrlX2 = PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY2 = PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = PApplet.parseFloat(pathTokens[i + 4]);\n        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n        // s - curve to shorthand (relative)\n      case 's': {\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // Q - quadratic curve to (absolute)\n      // Draws a quadratic Bzier curve from the current point to (x,y) using\n      // (x1,y1) as the control point. Q (uppercase) indicates that absolute\n      // coordinates will follow; q (lowercase) indicates that relative\n      // coordinates will follow. Multiple sets of coordinates may be specified\n      // to draw a polybzier. At the end of the command, the new current point\n      // becomes the final (x,y) coordinate pair used in the polybzier.\n      case 'Q': {\n        ctrlX = PApplet.parseFloat(pathTokens[i + 1]);\n        ctrlY = PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = PApplet.parseFloat(pathTokens[i + 4]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // q - quadratic curve to (relative)\n      case 'q': {\n        ctrlX = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        ctrlY = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // T - quadratic curveto shorthand (absolute)\n      // The control point is assumed to be the reflection of the control\n      // point on the previous command relative to the current point.\n      case 'T': {\n        // If there is no previous command or if the previous command was\n        // not a Q, q, T or t, assume the control point is coincident\n        // with the current point.\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float endX = PApplet.parseFloat(pathTokens[i + 1]);\n        float endY = PApplet.parseFloat(pathTokens[i + 2]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 3;\n        prevCurve = true;\n      }\n        break;\n\n        // t - quadratic curveto shorthand (relative)\n      case 't': {\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 3;\n        prevCurve = true;\n      }\n        break;\n\n      // A - elliptical arc to (absolute)\n      case 'A': {\n        float rx = PApplet.parseFloat(pathTokens[i + 1]);\n        float ry = PApplet.parseFloat(pathTokens[i + 2]);\n        float angle = PApplet.parseFloat(pathTokens[i + 3]);\n        boolean fa = PApplet.parseFloat(pathTokens[i + 4]) != 0;\n        boolean fs = PApplet.parseFloat(pathTokens[i + 5]) != 0;\n        float endX = PApplet.parseFloat(pathTokens[i + 6]);\n        float endY = PApplet.parseFloat(pathTokens[i + 7]);\n        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 8;\n        prevCurve = true;\n      }\n      break;\n\n      // a - elliptical arc to (relative)\n      case 'a': {\n        float rx = PApplet.parseFloat(pathTokens[i + 1]);\n        float ry = PApplet.parseFloat(pathTokens[i + 2]);\n        float angle = PApplet.parseFloat(pathTokens[i + 3]);\n        boolean fa = PApplet.parseFloat(pathTokens[i + 4]) != 0;\n        boolean fs = PApplet.parseFloat(pathTokens[i + 5]) != 0;\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 6]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 7]);\n        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 8;\n        prevCurve = true;\n      }\n      break;\n\n      case 'Z':\n      case 'z':\n        // since closing the path, the 'current' point needs\n        // to return back to the last moveto location.\n        // http://code.google.com/p/processing/issues/detail?id=1058\n        cx = movetoX;\n        cy = movetoY;\n        close = true;\n        i++;\n        break;\n\n      default:\n        String parsed =\n          PApplet.join(PApplet.subset(pathTokens, 0, i), \",\");\n        String unparsed =\n          PApplet.join(PApplet.subset(pathTokens, i), \",\");\n        System.err.println(\"parsed: \" + parsed);\n        System.err.println(\"unparsed: \" + unparsed);\n        if (pathTokens[i].equals(\"a\") || pathTokens[i].equals(\"A\")) {\n          String msg = \"Sorry, elliptical arc support for SVG files \" +\n            \"is not yet implemented (See issue 130 for updates)\";\n          throw new RuntimeException(msg);\n        }\n        throw new RuntimeException(\"shape command not handled: \" + pathTokens[i]);\n      }\n//      prevCommand = c;\n    }\n  }","id":40678,"modified_method":"protected void parsePath() {\n    family = PATH;\n    kind = 0;\n\n    String pathData = element.getString(\"d\");\n    if (pathData == null || PApplet.trim(pathData).length() == 0) {\n      return;\n    }\n    char[] pathDataChars = pathData.toCharArray();\n\n    StringBuilder pathBuffer = new StringBuilder();\n    boolean lastSeparate = false;\n\n    for (int i = 0; i < pathDataChars.length; i++) {\n      char c = pathDataChars[i];\n      boolean separate = false;\n\n      if (c == 'M' || c == 'm' ||\n          c == 'L' || c == 'l' ||\n          c == 'H' || c == 'h' ||\n          c == 'V' || c == 'v' ||\n          c == 'C' || c == 'c' ||  // beziers\n          c == 'S' || c == 's' ||\n          c == 'Q' || c == 'q' ||  // quadratic beziers\n          c == 'T' || c == 't' ||\n          c == 'A' || c == 'a' ||  // elliptical arc\n          c == 'Z' || c == 'z' ||  // closepath\n          c == ',') {\n        separate = true;\n        if (i != 0) {\n          pathBuffer.append(\"|\");\n        }\n      }\n      if (c == 'Z' || c == 'z') {\n        separate = false;\n      }\n      if (c == '-' && !lastSeparate) {\n        // allow for 'e' notation in numbers, e.g. 2.10e-9\n        // http://dev.processing.org/bugs/show_bug.cgi?id=1408\n        if (i == 0 || pathDataChars[i-1] != 'e') {\n          pathBuffer.append(\"|\");\n        }\n      }\n      if (c != ',') {\n        pathBuffer.append(c); //\"\" + pathDataBuffer.charAt(i));\n      }\n      if (separate && c != ',' && c != '-') {\n        pathBuffer.append(\"|\");\n      }\n      lastSeparate = separate;\n    }\n\n    // use whitespace constant to get rid of extra spaces and CR or LF\n    String[] pathTokens =\n      PApplet.splitTokens(pathBuffer.toString(), \"|\" + WHITESPACE);\n    vertices = new float[pathTokens.length][2];\n    vertexCodes = new int[pathTokens.length];\n\n    float cx = 0;\n    float cy = 0;\n    int i = 0;\n\n    char implicitCommand = '\\0';\n//    char prevCommand = '\\0';\n    boolean prevCurve = false;\n    float ctrlX, ctrlY;\n    // store values for closepath so that relative coords work properly\n    float movetoX = 0;\n    float movetoY = 0;\n\n    while (i < pathTokens.length) {\n      char c = pathTokens[i].charAt(0);\n      if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\\0') {\n        c = implicitCommand;\n        i--;\n      } else {\n        implicitCommand = c;\n      }\n      switch (c) {\n\n      case 'M':  // M - move to (absolute)\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        cy = PApplet.parseFloat(pathTokens[i + 2]);\n        movetoX = cx;\n        movetoY = cy;\n        parsePathMoveto(cx, cy);\n        implicitCommand = 'L';\n        i += 3;\n        break;\n\n      case 'm':  // m - move to (relative)\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        cy = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        movetoX = cx;\n        movetoY = cy;\n        parsePathMoveto(cx, cy);\n        implicitCommand = 'l';\n        i += 3;\n        break;\n\n      case 'L':\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        cy = PApplet.parseFloat(pathTokens[i + 2]);\n        parsePathLineto(cx, cy);\n        i += 3;\n        break;\n\n      case 'l':\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        cy = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        parsePathLineto(cx, cy);\n        i += 3;\n        break;\n\n        // horizontal lineto absolute\n      case 'H':\n        cx = PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n        // horizontal lineto relative\n      case 'h':\n        cx = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n      case 'V':\n        cy = PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n      case 'v':\n        cy = cy + PApplet.parseFloat(pathTokens[i + 1]);\n        parsePathLineto(cx, cy);\n        i += 2;\n        break;\n\n        // C - curve to (absolute)\n      case 'C': {\n        float ctrlX1 = PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY1 = PApplet.parseFloat(pathTokens[i + 2]);\n        float ctrlX2 = PApplet.parseFloat(pathTokens[i + 3]);\n        float ctrlY2 = PApplet.parseFloat(pathTokens[i + 4]);\n        float endX = PApplet.parseFloat(pathTokens[i + 5]);\n        float endY = PApplet.parseFloat(pathTokens[i + 6]);\n        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 7;\n        prevCurve = true;\n      }\n      break;\n\n        // c - curve to (relative)\n      case 'c': {\n        float ctrlX1 = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY1 = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 5]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 6]);\n        parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 7;\n        prevCurve = true;\n      }\n      break;\n\n      // S - curve to shorthand (absolute)\n      // Draws a cubic Bzier curve from the current point to (x,y). The first\n      // control point is assumed to be the reflection of the second control\n      // point on the previous command relative to the current point.\n      // (x2,y2) is the second control point (i.e., the control point\n      // at the end of the curve). S (uppercase) indicates that absolute\n      // coordinates will follow; s (lowercase) indicates that relative\n      // coordinates will follow. Multiple sets of coordinates may be specified\n      // to draw a polybzier. At the end of the command, the new current point\n      // becomes the final (x,y) coordinate pair used in the polybzier.\n      case 'S': {\n        // (If there is no previous command or if the previous command was not\n        // an C, c, S or s, assume the first control point is coincident with\n        // the current point.)\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float ctrlX2 = PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY2 = PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = PApplet.parseFloat(pathTokens[i + 4]);\n        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n        // s - curve to shorthand (relative)\n      case 's': {\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float ctrlX2 = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float ctrlY2 = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        parsePathCurveto(ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // Q - quadratic curve to (absolute)\n      // Draws a quadratic Bzier curve from the current point to (x,y) using\n      // (x1,y1) as the control point. Q (uppercase) indicates that absolute\n      // coordinates will follow; q (lowercase) indicates that relative\n      // coordinates will follow. Multiple sets of coordinates may be specified\n      // to draw a polybzier. At the end of the command, the new current point\n      // becomes the final (x,y) coordinate pair used in the polybzier.\n      case 'Q': {\n        ctrlX = PApplet.parseFloat(pathTokens[i + 1]);\n        ctrlY = PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = PApplet.parseFloat(pathTokens[i + 4]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // q - quadratic curve to (relative)\n      case 'q': {\n        ctrlX = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        ctrlY = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 3]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 4]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 5;\n        prevCurve = true;\n      }\n      break;\n\n      // T - quadratic curveto shorthand (absolute)\n      // The control point is assumed to be the reflection of the control\n      // point on the previous command relative to the current point.\n      case 'T': {\n        // If there is no previous command or if the previous command was\n        // not a Q, q, T or t, assume the control point is coincident\n        // with the current point.\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float endX = PApplet.parseFloat(pathTokens[i + 1]);\n        float endY = PApplet.parseFloat(pathTokens[i + 2]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 3;\n        prevCurve = true;\n      }\n        break;\n\n        // t - quadratic curveto shorthand (relative)\n      case 't': {\n        if (!prevCurve) {\n          ctrlX = cx;\n          ctrlY = cy;\n        } else {\n          float ppx = vertices[vertexCount-2][X];\n          float ppy = vertices[vertexCount-2][Y];\n          float px = vertices[vertexCount-1][X];\n          float py = vertices[vertexCount-1][Y];\n          ctrlX = px + (px - ppx);\n          ctrlY = py + (py - ppy);\n        }\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 1]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 2]);\n        //parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n        parsePathQuadto(ctrlX, ctrlY, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 3;\n        prevCurve = true;\n      }\n        break;\n\n      // A - elliptical arc to (absolute)\n      case 'A': {\n        float rx = PApplet.parseFloat(pathTokens[i + 1]);\n        float ry = PApplet.parseFloat(pathTokens[i + 2]);\n        float angle = PApplet.parseFloat(pathTokens[i + 3]);\n        boolean fa = PApplet.parseFloat(pathTokens[i + 4]) != 0;\n        boolean fs = PApplet.parseFloat(pathTokens[i + 5]) != 0;\n        float endX = PApplet.parseFloat(pathTokens[i + 6]);\n        float endY = PApplet.parseFloat(pathTokens[i + 7]);\n        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 8;\n        prevCurve = true;\n      }\n      break;\n\n      // a - elliptical arc to (relative)\n      case 'a': {\n        float rx = PApplet.parseFloat(pathTokens[i + 1]);\n        float ry = PApplet.parseFloat(pathTokens[i + 2]);\n        float angle = PApplet.parseFloat(pathTokens[i + 3]);\n        boolean fa = PApplet.parseFloat(pathTokens[i + 4]) != 0;\n        boolean fs = PApplet.parseFloat(pathTokens[i + 5]) != 0;\n        float endX = cx + PApplet.parseFloat(pathTokens[i + 6]);\n        float endY = cy + PApplet.parseFloat(pathTokens[i + 7]);\n        parsePathArcto(cx, cy, rx, ry, angle, fa, fs, endX, endY);\n        cx = endX;\n        cy = endY;\n        i += 8;\n        prevCurve = true;\n      }\n      break;\n\n      case 'Z':\n      case 'z':\n        // since closing the path, the 'current' point needs\n        // to return back to the last moveto location.\n        // http://code.google.com/p/processing/issues/detail?id=1058\n        cx = movetoX;\n        cy = movetoY;\n        close = true;\n        i++;\n        break;\n\n      default:\n        String parsed =\n          PApplet.join(PApplet.subset(pathTokens, 0, i), \",\");\n        String unparsed =\n          PApplet.join(PApplet.subset(pathTokens, i), \",\");\n        System.err.println(\"parsed: \" + parsed);\n        System.err.println(\"unparsed: \" + unparsed);\n        throw new RuntimeException(\"shape command not handled: \" + pathTokens[i]);\n      }\n//      prevCommand = c;\n    }\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Parse a child XML element.\n   * Override this method to add parsing for more SVG elements.\n   */\n  protected PShape parseChild(XML elem) {\n//    System.err.println(\"parsing child in pshape \" + elem.getName());\n    String name = elem.getName();\n    PShapeSVG shape = null;\n\n    if (name == null) {\n      // just some whitespace that can be ignored (hopefully)\n\n    } else if (name.equals(\"g\")) {\n      //return new BaseObject(this, elem);\n      shape = new PShapeSVG(this, elem, true);\n\n    } else if (name.equals(\"defs\")) {\n      // generally this will contain gradient info, so may\n      // as well just throw it into a group element for parsing\n      //return new BaseObject(this, elem);\n      shape = new PShapeSVG(this, elem, true);\n\n    } else if (name.equals(\"line\")) {\n      //return new Line(this, elem);\n      //return new BaseObject(this, elem, LINE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseLine();\n\n    } else if (name.equals(\"circle\")) {\n      //return new BaseObject(this, elem, ELLIPSE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseEllipse(true);\n\n    } else if (name.equals(\"ellipse\")) {\n      //return new BaseObject(this, elem, ELLIPSE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseEllipse(false);\n\n    } else if (name.equals(\"rect\")) {\n      //return new BaseObject(this, elem, RECT);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseRect();\n\n    } else if (name.equals(\"polygon\")) {\n      //return new BaseObject(this, elem, POLYGON);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePoly(true);\n\n    } else if (name.equals(\"polyline\")) {\n      //return new BaseObject(this, elem, POLYGON);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePoly(false);\n\n    } else if (name.equals(\"path\")) {\n      //return new BaseObject(this, elem, PATH);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePath();\n\n    } else if (name.equals(\"radialGradient\")) {\n      return new RadialGradient(this, elem);\n\n    } else if (name.equals(\"linearGradient\")) {\n      return new LinearGradient(this, elem);\n\n    } else if (name.equals(\"font\")) {\n      return new Font(this, elem);\n\n//    } else if (name.equals(\"font-face\")) {\n//      return new FontFace(this, elem);\n\n//    } else if (name.equals(\"glyph\") || name.equals(\"missing-glyph\")) {\n//      return new FontGlyph(this, elem);\n\n    } else if (name.equals(\"metadata\")) {\n      // fontforge just stuffs this in as a comment\n      return null;\n\n    } else if (name.equals(\"text\")) {  // || name.equals(\"font\")) {\n      PGraphics.showWarning(\"Text and fonts in SVG files \" +\n                                  \"are not currently supported, \" +\n                            \"convert text to outlines instead.\");\n\n    } else if (name.equals(\"filter\")) {\n      PGraphics.showWarning(\"Filters are not supported.\");\n\n    } else if (name.equals(\"mask\")) {\n      PGraphics.showWarning(\"Masks are not supported.\");\n\n    } else if (name.equals(\"pattern\")) {\n      PGraphics.showWarning(\"Patterns are not supported.\");\n\n    } else if (name.equals(\"stop\")) {\n      // stop tag is handled by gradient parser, so don't warn about it\n\n    } else if (name.equals(\"sodipodi:namedview\")) {\n      // these are always in Inkscape files, the warnings get tedious\n\n    } else if (name.equals(\"title\")) {\n      // harmless\n\n    } else if (!name.startsWith(\"#\")) {\n      PGraphics.showWarning(\"Ignoring <\" + name + \"> tag.\");\n//      new Exception().printStackTrace();\n    }\n    return shape;\n  }","id":40679,"modified_method":"/**\n   * Parse a child XML element.\n   * Override this method to add parsing for more SVG elements.\n   */\n  protected PShape parseChild(XML elem) {\n//    System.err.println(\"parsing child in pshape \" + elem.getName());\n    String name = elem.getName();\n    PShapeSVG shape = null;\n\n\n    if (name == null) {\n      // just some whitespace that can be ignored (hopefully)\n\n    } else if (name.equals(\"g\")) {\n      //return new BaseObject(this, elem);\n      shape = new PShapeSVG(this, elem, true);\n\n    } else if (name.equals(\"defs\")) {\n      // generally this will contain gradient info, so may\n      // as well just throw it into a group element for parsing\n      //return new BaseObject(this, elem);\n      shape = new PShapeSVG(this, elem, true);\n\n    } else if (name.equals(\"line\")) {\n      //return new Line(this, elem);\n      //return new BaseObject(this, elem, LINE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseLine();\n\n    } else if (name.equals(\"circle\")) {\n      //return new BaseObject(this, elem, ELLIPSE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseEllipse(true);\n\n    } else if (name.equals(\"ellipse\")) {\n      //return new BaseObject(this, elem, ELLIPSE);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseEllipse(false);\n\n    } else if (name.equals(\"rect\")) {\n      //return new BaseObject(this, elem, RECT);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parseRect();\n\n    } else if (name.equals(\"polygon\")) {\n      //return new BaseObject(this, elem, POLYGON);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePoly(true);\n\n    } else if (name.equals(\"polyline\")) {\n      //return new BaseObject(this, elem, POLYGON);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePoly(false);\n\n    } else if (name.equals(\"path\")) {\n      //return new BaseObject(this, elem, PATH);\n      shape = new PShapeSVG(this, elem, true);\n      shape.parsePath();\n\n    } else if (name.equals(\"radialGradient\")) {\n      return new RadialGradient(this, elem);\n\n    } else if (name.equals(\"linearGradient\")) {\n      return new LinearGradient(this, elem);\n\n    } else if (name.equals(\"font\")) {\n      return new Font(this, elem);\n\n//    } else if (name.equals(\"font-face\")) {\n//      return new FontFace(this, elem);\n\n//    } else if (name.equals(\"glyph\") || name.equals(\"missing-glyph\")) {\n//      return new FontGlyph(this, elem);\n\n    } else if (name.equals(\"text\")) {  // || name.equals(\"font\")) {\n      PGraphics.showWarning(\"Text and fonts in SVG files are \" +\n        \"not currently supported, convert text to outlines instead.\");\n\n    } else if (name.equals(\"filter\")) {\n      PGraphics.showWarning(\"Filters are not supported.\");\n\n    } else if (name.equals(\"mask\")) {\n      PGraphics.showWarning(\"Masks are not supported.\");\n\n    } else if (name.equals(\"pattern\")) {\n      PGraphics.showWarning(\"Patterns are not supported.\");\n\n    } else if (name.equals(\"stop\")) {\n      // stop tag is handled by gradient parser, so don't warn about it\n\n    } else if (name.equals(\"sodipodi:namedview\")) {\n      // these are always in Inkscape files, the warnings get tedious\n\n    } else if (name.equals(\"metadata\")\n        || name.equals(\"title\") || name.equals(\"desc\")) {\n      // fontforge just stuffs <metadata> in as a comment.\n      // All harmless stuff, irrelevant to rendering.\n      return null;\n\n    } else if (!name.startsWith(\"#\")) {\n      PGraphics.showWarning(\"Ignoring <\" + name + \"> tag.\");\n//      new Exception().printStackTrace();\n    }\n    return shape;\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Parse a size that may have a suffix for its units.\n   * Ignoring cases where this could also be a percentage.\n   * The <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units<\/A> spec:\n   * <UL>\n   * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n   * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n   * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n   * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n   * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n   * <\/UL>\n   */\n  static protected float parseUnitSize(String text) {\n    int len = text.length() - 2;\n\n    if (text.endsWith(\"pt\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 1.25f;\n    } else if (text.endsWith(\"pc\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 15;\n    } else if (text.endsWith(\"mm\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 3.543307f;\n    } else if (text.endsWith(\"cm\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 35.43307f;\n    } else if (text.endsWith(\"in\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 90;\n    } else if (text.endsWith(\"px\")) {\n      return PApplet.parseFloat(text.substring(0, len));\n    } else {\n      return PApplet.parseFloat(text);\n    }\n  }","id":40680,"modified_method":"/**\n   * Parse a size that may have a suffix for its units.\n   * This assumes 90dpi, which implies, as given in the\n   * <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units<\/A> spec:\n   * <UL>\n   * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n   * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n   * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n   * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n   * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n   * <\/UL>\n   * @param relativeTo (float) Used for %. When relative to viewbox, should\n   *    be svgWidth for horizontal dimentions, svgHeight for vertical, and\n   *    svgXYSize for anything else.\n   */\n  static protected float parseUnitSize(String text, float relativeTo) {\n    int len = text.length() - 2;\n\n    if (text.endsWith(\"pt\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 1.25f;\n    } else if (text.endsWith(\"pc\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 15;\n    } else if (text.endsWith(\"mm\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 3.543307f;\n    } else if (text.endsWith(\"cm\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 35.43307f;\n    } else if (text.endsWith(\"in\")) {\n      return PApplet.parseFloat(text.substring(0, len)) * 90;\n    } else if (text.endsWith(\"px\")) {\n      return PApplet.parseFloat(text.substring(0, len));\n    } else if (text.endsWith(\"%\")) {\n      return relativeTo * parseFloatOrPercent(text);\n    } else {\n      return PApplet.parseFloat(text);\n    }\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"void setStrokeWeight(String lineweight) {\n    strokeWeight = parseUnitSize(lineweight);\n  }","id":40681,"modified_method":"void setStrokeWeight(String lineweight) {\n    strokeWeight = parseUnitSize(lineweight, svgXYSize);\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Handles parsing ellipse and circle tags.\n   * @param circle true if this is a circle and not an ellipse\n   */\n  protected void parseEllipse(boolean circle) {\n    kind = ELLIPSE;\n    family = PRIMITIVE;\n    params = new float[4];\n\n    params[0] = getFloatWithUnit(element, \"cx\");\n    params[1] = getFloatWithUnit(element, \"cy\");\n\n    float rx, ry;\n    if (circle) {\n      rx = ry = getFloatWithUnit(element, \"r\");\n    } else {\n      rx = getFloatWithUnit(element, \"rx\");\n      ry = getFloatWithUnit(element, \"ry\");\n    }\n    params[0] -= rx;\n    params[1] -= ry;\n\n    params[2] = rx*2;\n    params[3] = ry*2;\n  }","id":40682,"modified_method":"/**\n   * Handles parsing ellipse and circle tags.\n   * @param circle true if this is a circle and not an ellipse\n   */\n  protected void parseEllipse(boolean circle) {\n    kind = ELLIPSE;\n    family = PRIMITIVE;\n    params = new float[4];\n\n    params[0] = getFloatWithUnit(element, \"cx\", svgWidth);\n    params[1] = getFloatWithUnit(element, \"cy\", svgHeight);\n\n    float rx, ry;\n    if (circle) {\n      rx = ry = getFloatWithUnit(element, \"r\", svgXYSize);\n    } else {\n      rx = getFloatWithUnit(element, \"rx\", svgWidth);\n      ry = getFloatWithUnit(element, \"ry\", svgHeight);\n    }\n    params[0] -= rx;\n    params[1] -= ry;\n\n    params[2] = rx*2;\n    params[3] = ry*2;\n\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"static protected HashMap<String, String> parseStyleAttributes(String style) {\n    HashMap<String, String> table = new HashMap<String, String>();\n    String[] pieces = style.split(\";\");\n    for (int i = 0; i < pieces.length; i++) {\n      String[] parts = pieces[i].split(\":\");\n      table.put(parts[0], parts[1]);\n    }\n    return table;\n  }","id":40683,"modified_method":"static protected HashMap<String, String> parseStyleAttributes(String style) {\n    HashMap<String, String> table = new HashMap<String, String>();\n    if (style == null) return table;\n\n    String[] pieces = style.split(\";\");\n    for (int i = 0; i < pieces.length; i++) {\n      String[] parts = pieces[i].split(\":\");\n      table.put(parts[0], parts[1]);\n    }\n    return table;\n  }","commit_id":"bc1f173f25e1d1ad2f28961f245c4de99d81f178","url":"https://github.com/processing/processing"},{"original_method":"protected SignatureHashBuilder appendMemberSignatures(JvmDeclaredType type) {\n\t\t\tfor (JvmMember member : sortedMembers(type.getMembers())) {\n\t\t\t\tif (member.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\t\tif (member instanceof JvmOperation) {\n\t\t\t\t\t\tappendSignature((JvmOperation) member);\n\t\t\t\t\t} else if (member instanceof JvmConstructor) {\n\t\t\t\t\t\tappendSignature((JvmConstructor) member);\n\t\t\t\t\t} else if (member instanceof JvmField) {\n\t\t\t\t\t\tappendSignature((JvmField) member);\n\t\t\t\t\t}\n\t\t\t\t\tappend(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}","id":40684,"modified_method":"protected SignatureHashBuilder appendMemberSignatures(JvmDeclaredType type, boolean innerTypesOnly) {\n\t\t\tIterable<? extends JvmMember> members = type.getMembers();\n\t\t\tif(innerTypesOnly)\n\t\t\t\tmembers = filter(members, JvmDeclaredType.class);\n\t\t\tfor (JvmMember member : sortedMembers(members)) {\n\t\t\t\tif (member.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\t\tif (member instanceof JvmOperation) \n\t\t\t\t\t\tappendSignature((JvmOperation) member);\n\t\t\t\t\telse if (member instanceof JvmConstructor) \n\t\t\t\t\t\tappendSignature((JvmConstructor) member);\n\t\t\t\t\telse if (member instanceof JvmField) \n\t\t\t\t\t\tappendSignature((JvmField) member);\n\t\t\t\t\telse if (member instanceof JvmDeclaredType) {\n\t\t\t\t\t\tappend(member.getQualifiedName());\n\t\t\t\t\t\tappendMemberSignatures((JvmDeclaredType) member, true);\n\t\t\t\t\t}\n\t\t\t\t\tappend(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}","commit_id":"07d7d938019b8e49cac77e25a031150db56c9483","url":"https://github.com/eclipse/xtext"},{"original_method":"protected SortedSet<JvmMember> sortedMembers(Iterable<JvmMember> elements) {\n\t\t\treturn ImmutableSortedSet.copyOf(new Comparator<JvmIdentifiableElement>() {\n\t\t\t\tpublic int compare(JvmIdentifiableElement o1, JvmIdentifiableElement o2) {\n\t\t\t\t\treturn o1.getSimpleName().compareTo(o2.getSimpleName());\n\t\t\t\t}\n\t\t\t}, filter(elements, new Predicate<JvmIdentifiableElement>() {\n\t\t\t\tpublic boolean apply(JvmIdentifiableElement input) {\n\t\t\t\t\treturn !isEmpty(input.getSimpleName());\n\t\t\t\t}\n\t\t\t}));\n\t\t}","id":40685,"modified_method":"protected SortedSet<JvmMember> sortedMembers(Iterable<? extends JvmMember> elements) {\n\t\t\treturn ImmutableSortedSet.copyOf(new Comparator<JvmIdentifiableElement>() {\n\t\t\t\tpublic int compare(JvmIdentifiableElement o1, JvmIdentifiableElement o2) {\n\t\t\t\t\treturn o1.getSimpleName().compareTo(o2.getSimpleName());\n\t\t\t\t}\n\t\t\t}, filter(elements, new Predicate<JvmIdentifiableElement>() {\n\t\t\t\tpublic boolean apply(JvmIdentifiableElement input) {\n\t\t\t\t\treturn !isEmpty(input.getSimpleName());\n\t\t\t\t}\n\t\t\t}));\n\t\t}","commit_id":"07d7d938019b8e49cac77e25a031150db56c9483","url":"https://github.com/eclipse/xtext"},{"original_method":"public SignatureHashBuilder appendSignature(JvmDeclaredType type) {\n\t\t\tif (type.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\tappendVisibility(type.getVisibility()).append(\" \");\n\t\t\t\tif (type.isAbstract())\n\t\t\t\t\tappend(\"abstract \");\n\t\t\t\tif (type.isStatic())\n\t\t\t\t\tappend(\"static \");\n\t\t\t\tif (type.isFinal())\n\t\t\t\t\tappend(\"final \");\n\t\t\t\tappend(\"class \").append(type.getIdentifier());\n\t\t\t\tif (type instanceof JvmTypeParameterDeclarator)\n\t\t\t\t\tappendTypeParameters((JvmTypeParameterDeclarator) type);\n\t\t\t\tappend(\"\\n\").appendSuperTypeSignatures(type).appendMemberSignatures(type);\n\t\t\t}\n\t\t\treturn this;\n\t\t}","id":40686,"modified_method":"public SignatureHashBuilder appendSignature(JvmDeclaredType type) {\n\t\t\tif (type.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\tappendVisibility(type.getVisibility()).append(\" \");\n\t\t\t\tif (type.isAbstract())\n\t\t\t\t\tappend(\"abstract \");\n\t\t\t\tif (type.isStatic())\n\t\t\t\t\tappend(\"static \");\n\t\t\t\tif (type.isFinal())\n\t\t\t\t\tappend(\"final \");\n\t\t\t\tappend(\"class \").append(type.getIdentifier());\n\t\t\t\tif (type instanceof JvmTypeParameterDeclarator)\n\t\t\t\t\tappendTypeParameters((JvmTypeParameterDeclarator) type);\n\t\t\t\tappend(\"\\n\").appendSuperTypeSignatures(type).appendMemberSignatures(type, false);\n\t\t\t}\n\t\t\treturn this;\n\t\t}","commit_id":"07d7d938019b8e49cac77e25a031150db56c9483","url":"https://github.com/eclipse/xtext"},{"original_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        handler =\n                SeamAutowire\n                        .instance()\n                        .reset()\n                        .use(\"securityServiceImpl\", securityServiceImpl)\n                        .use(\"textFlowTargetDAO\", textFlowTargetDAO)\n                        .use(JpaIdentityStore.AUTHENTICATED_USER,\n                                authenticatedAccount)\n                        .use(\"transUnitTransformer\", transUnitTransformer)\n                        .use(\"localeServiceImpl\", localeService)\n                        .use(\"translationWorkspaceManager\",\n                                translationWorkspaceManager)\n                        .use(\"identity\", identity)\n                        .autowire(AddReviewCommentHandler.class);\n    }","id":40687,"modified_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        handler =\n                SeamAutowire\n                        .instance()\n                        .reset()\n                        .use(\"securityServiceImpl\", securityServiceImpl)\n                        .use(\"textFlowTargetDAO\", textFlowTargetDAO)\n                        .use(JpaIdentityStore.AUTHENTICATED_USER,\n                                authenticatedAccount)\n                        .use(\"localeServiceImpl\", localeService)\n                        .use(\"translationWorkspaceManager\",\n                                translationWorkspaceManager)\n                        .use(\"identity\", identity)\n                        .autowire(AddReviewCommentHandler.class);\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testExecute() throws Exception {\n        // Given: we want to add comment to trans unit id 2 and locale id DE\n        String commentContent = \"new comment\";\n        TransUnitId transUnitId = new TransUnitId(2L);\n        HLocale hLocale = new HLocale(LocaleId.DE);\n        AddReviewCommentAction action =\n                new AddReviewCommentAction(transUnitId, commentContent,\n                        documentId);\n        action.setWorkspaceId(TestFixture.workspaceId(LocaleId.DE));\n        when(authenticatedAccount.getPerson()).thenReturn(hPerson);\n        when(securityServiceImpl.checkWorkspaceStatus(action.getWorkspaceId()))\n                .thenReturn(hProject);\n        when(\n                translationWorkspaceManager.getOrRegisterWorkspace(action\n                        .getWorkspaceId())).thenReturn(workspace);\n        when(localeService.getByLocaleId(action.getWorkspaceId().getLocaleId()))\n                .thenReturn(hLocale);\n        when(\n                textFlowTargetDAO.getTextFlowTarget(transUnitId.getValue(),\n                        hLocale.getLocaleId())).thenReturn(hTextFlowTarget);\n        when(hTextFlowTarget.getState()).thenReturn(ContentState.Rejected);\n        when(hTextFlowTarget.getTextFlow()).thenReturn(hTextFlow);\n        when(\n                transUnitTransformer.transform(hTextFlow, hTextFlowTarget,\n                        hLocale)).thenReturn(\n                TestFixture.makeTransUnit(transUnitId.getId()));\n        when(hTextFlowTarget.addReviewComment(commentContent, hPerson))\n                .thenReturn(hReviewComment);\n        when(hReviewComment.getId()).thenReturn(1L);\n\n        // When:\n        AddReviewCommentResult result = handler.execute(action, null);\n\n        // Then:\n        InOrder inOrder =\n                Mockito.inOrder(textFlowTargetDAO, hTextFlowTarget, workspace,\n                        securityServiceImpl, identity);\n        inOrder.verify(securityServiceImpl).checkWorkspaceStatus(\n                action.getWorkspaceId());\n        inOrder.verify(textFlowTargetDAO).getTextFlowTarget(\n                transUnitId.getValue(), hLocale.getLocaleId());\n        inOrder.verify(identity).checkPermission(\"review-comment\", hLocale,\n                hProject);\n        inOrder.verify(hTextFlowTarget).addReviewComment(commentContent,\n                hPerson);\n        inOrder.verify(textFlowTargetDAO).makePersistent(hTextFlowTarget);\n        inOrder.verify(textFlowTargetDAO).flush();\n        inOrder.verify(workspace).publish(isA(AddReviewComment.class));\n\n        assertThat(result.getComment().getId(),\n                Matchers.equalTo(new ReviewCommentId(1L)));\n    }","id":40688,"modified_method":"@Test\n    public void testExecute() throws Exception {\n        // Given: we want to add comment to trans unit id 2 and locale id DE\n        String commentContent = \"new comment\";\n        TransUnitId transUnitId = new TransUnitId(2L);\n        HLocale hLocale = new HLocale(LocaleId.DE);\n        AddReviewCommentAction action =\n                new AddReviewCommentAction(transUnitId, commentContent,\n                        documentId);\n        action.setWorkspaceId(TestFixture.workspaceId(LocaleId.DE));\n        when(authenticatedAccount.getPerson()).thenReturn(hPerson);\n        when(securityServiceImpl.checkWorkspaceStatus(action.getWorkspaceId()))\n                .thenReturn(hProject);\n        when(\n                translationWorkspaceManager.getOrRegisterWorkspace(action\n                        .getWorkspaceId())).thenReturn(workspace);\n        when(localeService.getByLocaleId(action.getWorkspaceId().getLocaleId()))\n                .thenReturn(hLocale);\n        when(\n                textFlowTargetDAO.getTextFlowTarget(transUnitId.getValue(),\n                        hLocale.getLocaleId())).thenReturn(hTextFlowTarget);\n        when(hTextFlowTarget.getState()).thenReturn(ContentState.Rejected);\n        when(hTextFlowTarget.getTextFlow()).thenReturn(hTextFlow);\n        when(hTextFlowTarget.addReviewComment(commentContent, hPerson))\n                .thenReturn(hReviewComment);\n        when(hReviewComment.getId()).thenReturn(1L);\n\n        // When:\n        AddReviewCommentResult result = handler.execute(action, null);\n\n        // Then:\n        InOrder inOrder =\n                Mockito.inOrder(textFlowTargetDAO, hTextFlowTarget, workspace,\n                        securityServiceImpl, identity);\n        inOrder.verify(securityServiceImpl).checkWorkspaceStatus(\n                action.getWorkspaceId());\n        inOrder.verify(textFlowTargetDAO).getTextFlowTarget(\n                transUnitId.getValue(), hLocale.getLocaleId());\n        inOrder.verify(identity).checkPermission(\"review-comment\", hLocale,\n                hProject);\n        inOrder.verify(hTextFlowTarget).addReviewComment(commentContent,\n                hPerson);\n        inOrder.verify(textFlowTargetDAO).makePersistent(hTextFlowTarget);\n        inOrder.verify(textFlowTargetDAO).flush();\n        inOrder.verify(workspace).publish(isA(AddReviewComment.class));\n\n        assertThat(result.getComment().getId(),\n                Matchers.equalTo(new ReviewCommentId(1L)));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public void integrate(Configuration configuration,\n            SessionFactoryImplementor sessionFactory,\n            SessionFactoryServiceRegistry serviceRegistry) {\n        // As you might expect, an EventListenerRegistry is the thing with which\n        // event listeners are registered It is a\n        // service so we look it up using the service registry\n\n        final EventListenerRegistry eventListenerRegistry =\n                serviceRegistry.getService(EventListenerRegistry.class);\n\n\n        TranslationUpdateListener updateListener =\n                (TranslationUpdateListener) Component\n                        .getInstance(TranslationUpdateListener.class);\n        log.info(\"register event listener: {}\", updateListener);\n        eventListenerRegistry.appendListeners(EventType.POST_UPDATE,\n                updateListener);\n        eventListenerRegistry.appendListeners(EventType.POST_INSERT,\n                updateListener);\n    }","id":40689,"modified_method":"@Override\n    public void integrate(Configuration configuration,\n            SessionFactoryImplementor sessionFactory,\n            SessionFactoryServiceRegistry serviceRegistry) {\n        if (Contexts.isApplicationContextActive()) {\n            final EventListenerRegistry eventListenerRegistry =\n                    serviceRegistry.getService(EventListenerRegistry.class);\n            TranslationUpdateListener updateListener =\n                    (TranslationUpdateListener) Component\n                            .getInstance(TranslationUpdateListener.class);\n            log.info(\"register event listener: {}\", updateListener);\n            eventListenerRegistry.appendListeners(EventType.POST_UPDATE,\n                    updateListener);\n            eventListenerRegistry.appendListeners(EventType.POST_INSERT,\n                    updateListener);\n        }\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testExecute() throws Exception {\n        List<TransUnitUpdateInfo> updatesToRevert =\n                Lists.newArrayList(new TransUnitUpdateInfo(true, true,\n                        new DocumentId(new Long(1), \"\"), TestFixture\n                                .makeTransUnit(1), 0, 0, ContentState.Approved));\n        RevertTransUnitUpdates action =\n                new RevertTransUnitUpdates(updatesToRevert);\n        when(\n                securityServiceImpl.checkPermission(action,\n                        SecurityService.TranslationAction.MODIFY)).thenReturn(\n                checkResult);\n        when(checkResult.getLocale()).thenReturn(new HLocale(LocaleId.EN_US));\n        when(checkResult.getWorkspace()).thenReturn(translationWorkspace);\n        TranslationService.TranslationResult translationResult =\n                mockTranslationResult(ContentState.NeedReview, 0);\n        when(\n                translationServiceImpl.revertTranslations(LocaleId.EN_US,\n                        action.getUpdatesToRevert())).thenReturn(\n                Lists.newArrayList(translationResult));\n\n        UpdateTransUnitResult result = handler.execute(action, null);\n\n        assertThat(result.getUpdateInfoList(), Matchers.hasSize(1));\n        assertThat(result.getUpdateInfoList().get(0).getPreviousState(),\n                Matchers.equalTo(ContentState.NeedReview));\n        verify(translationWorkspace).publish(updatedCaptor.capture());\n        TransUnitUpdated transUnitUpdated = updatedCaptor.getValue();\n        TransUnitUpdateInfo updateInfo = transUnitUpdated.getUpdateInfo();\n        assertThat(updateInfo.getPreviousState(),\n                Matchers.equalTo(ContentState.NeedReview));\n        assertThat(updateInfo.getPreviousVersionNum(), Matchers.equalTo(0));\n        assertThat(transUnitUpdated.getUpdateType(),\n                Matchers.equalTo(TransUnitUpdated.UpdateType.WebEditorSave));\n    }","id":40690,"modified_method":"@Test\n    public void testExecute() throws Exception {\n        List<TransUnitUpdateInfo> updatesToRevert =\n                Lists.newArrayList(new TransUnitUpdateInfo(true, true,\n                        new DocumentId(new Long(1), \"\"), TestFixture\n                                .makeTransUnit(1), 0, 0, ContentState.Approved));\n        RevertTransUnitUpdates action =\n                new RevertTransUnitUpdates(updatesToRevert);\n        when(\n                securityServiceImpl.checkPermission(action,\n                        SecurityService.TranslationAction.MODIFY)).thenReturn(\n                checkResult);\n        when(checkResult.getLocale()).thenReturn(new HLocale(LocaleId.EN_US));\n        when(checkResult.getWorkspace()).thenReturn(translationWorkspace);\n        TranslationService.TranslationResult translationResult =\n                mockTranslationResult(ContentState.NeedReview, 0);\n        when(\n                translationServiceImpl.revertTranslations(LocaleId.EN_US,\n                        action.getUpdatesToRevert())).thenReturn(\n                Lists.newArrayList(translationResult));\n\n        UpdateTransUnitResult result = handler.execute(action, null);\n\n        assertThat(result.getUpdateInfoList(), Matchers.hasSize(1));\n        assertThat(result.getUpdateInfoList().get(0).getPreviousState(),\n                Matchers.equalTo(ContentState.NeedReview));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public UpdateTransUnitResult execute(TransMemoryMerge action,\n            ExecutionContext context) throws ActionException {\n        SecurityService.SecurityCheckResult securityCheckResult =\n                securityServiceImpl.checkPermission(action, MODIFY);\n        HLocale hLocale = securityCheckResult.getLocale();\n        TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n        Map<Long, TransUnitUpdateRequest> requestMap =\n                transformToMap(action.getUpdateRequests());\n        List<HTextFlow> hTextFlows =\n                textFlowDAO\n                        .findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n        TransMemoryAboveThresholdPredicate predicate =\n                new TransMemoryAboveThresholdPredicate(\n                        action.getThresholdPercent());\n\n        List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n        for (HTextFlow hTextFlow : hTextFlows) {\n            HTextFlowTarget hTextFlowTarget =\n                    hTextFlow.getTargets().get(hLocale.getId());\n            HLocale sourceLocale = hTextFlow.getDocument().getLocale();\n\n            // TODO rhbz953734 - TM merge won't override Translated to Approved\n            // yet. May or may not want this feature.\n            if (hTextFlowTarget != null\n                    && hTextFlowTarget.getState().isTranslated()) {\n                log.warn(\"Text flow id {} is translated. Ignored.\",\n                        hTextFlow.getId());\n                continue;\n            }\n            ArrayList<TransMemoryResultItem> tmResults =\n                    getTransMemoryHandler.searchTransMemory(hLocale,\n                            new TransMemoryQuery(hTextFlow.getContents(),\n                                    SearchType.FUZZY_PLURAL), sourceLocale\n                                    .getLocaleId());\n            TransMemoryResultItem tmResult =\n                    findTMAboveThreshold(tmResults, predicate, hTextFlow,\n                            action.getThresholdPercent());\n            TransUnitUpdateRequest request =\n                    createRequest(action, hLocale, requestMap, hTextFlow,\n                            tmResult, hTextFlowTarget);\n            if (request != null) {\n                updateRequests.add(request);\n            }\n        }\n\n        if (updateRequests.isEmpty()) {\n            return new UpdateTransUnitResult();\n        }\n        return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(),\n                workspace, updateRequests, action.getEditorClientId(),\n                TransUnitUpdated.UpdateType.NonEditorSave);\n    }","id":40691,"modified_method":"@Override\n    public UpdateTransUnitResult execute(TransMemoryMerge action,\n            ExecutionContext context) throws ActionException {\n        SecurityService.SecurityCheckResult securityCheckResult =\n                securityServiceImpl.checkPermission(action, MODIFY);\n        HLocale hLocale = securityCheckResult.getLocale();\n        TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n        Map<Long, TransUnitUpdateRequest> requestMap =\n                transformToMap(action.getUpdateRequests());\n        List<HTextFlow> hTextFlows =\n                textFlowDAO\n                        .findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n        TransMemoryAboveThresholdPredicate predicate =\n                new TransMemoryAboveThresholdPredicate(\n                        action.getThresholdPercent());\n\n        List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n        for (HTextFlow hTextFlow : hTextFlows) {\n            HTextFlowTarget hTextFlowTarget =\n                    hTextFlow.getTargets().get(hLocale.getId());\n            HLocale sourceLocale = hTextFlow.getDocument().getLocale();\n\n            // TODO rhbz953734 - TM merge won't override Translated to Approved\n            // yet. May or may not want this feature.\n            if (hTextFlowTarget != null\n                    && hTextFlowTarget.getState().isTranslated()) {\n                log.warn(\"Text flow id {} is translated. Ignored.\",\n                        hTextFlow.getId());\n                continue;\n            }\n            ArrayList<TransMemoryResultItem> tmResults =\n                    getTransMemoryHandler.searchTransMemory(hLocale,\n                            new TransMemoryQuery(hTextFlow.getContents(),\n                                    SearchType.FUZZY_PLURAL), sourceLocale\n                                    .getLocaleId());\n            TransMemoryResultItem tmResult =\n                    findTMAboveThreshold(tmResults, predicate, hTextFlow,\n                            action.getThresholdPercent());\n            TransUnitUpdateRequest request =\n                    createRequest(action, hLocale, requestMap, hTextFlow,\n                            tmResult, hTextFlowTarget);\n            if (request != null) {\n                updateRequests.add(request);\n            }\n        }\n\n        if (updateRequests.isEmpty()) {\n            return new UpdateTransUnitResult();\n        }\n        return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(),\n                updateRequests, action.getEditorClientId(),\n                TransUnitUpdated.UpdateType.NonEditorSave);\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void canHandleMultipleTextFlows() throws ActionException {\n        // Given: an action with threshold 90% and trans unit id is 1, 2, 3, 4\n        final long idWith100MatchTM = 1L;\n        final long idWithoutTM = 2L;\n        final long idWith80MatchTM = 3L;\n        final long idWith90MatchTM = 4L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(90, idWith100MatchTM,\n                        idWithoutTM, idWith80MatchTM, idWith90MatchTM);\n\n        HTextFlow textFlow100TM =\n                TestFixture.makeHTextFlow(idWith100MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFlowNoTM =\n                TestFixture.makeHTextFlow(idWithoutTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFlow80TM =\n                TestFixture.makeHTextFlow(idWith80MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFLow90TM =\n                TestFixture.makeHTextFlow(idWith90MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n\n        when(\n                textFlowDAO.findByIdList(newArrayList(idWith100MatchTM,\n                        idWithoutTM, idWith80MatchTM, idWith90MatchTM)))\n                .thenReturn(\n                        newArrayList(textFlow100TM, textFlowNoTM, textFlow80TM,\n                                textFLow90TM));\n        // Given: TM results\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryResultItem tm100 = tmResult(tmResultSource.getId(), 100);\n        TransMemoryResultItem tm90 = tmResult(tmResultSource.getId(), 90);\n        TransMemoryResultItem tm80 = tmResult(tmResultSource.getId(), 80);\n\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlow100TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm100));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFLow90TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm90));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlow80TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm80));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlowNoTM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(Lists.<TransMemoryResultItem> newArrayList());\n\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()), same(workspace),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(2));\n        assertThat(updateRequest.get(0).getNewContents(),\n                Matchers.equalTo(tm100.getTargetContents()));\n        assertThat(updateRequest.get(1).getNewContents(),\n                Matchers.equalTo(tm90.getTargetContents()));\n    }","id":40692,"modified_method":"@Test\n    public void canHandleMultipleTextFlows() throws ActionException {\n        // Given: an action with threshold 90% and trans unit id is 1, 2, 3, 4\n        final long idWith100MatchTM = 1L;\n        final long idWithoutTM = 2L;\n        final long idWith80MatchTM = 3L;\n        final long idWith90MatchTM = 4L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(90, idWith100MatchTM,\n                        idWithoutTM, idWith80MatchTM, idWith90MatchTM);\n\n        HTextFlow textFlow100TM =\n                TestFixture.makeHTextFlow(idWith100MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFlowNoTM =\n                TestFixture.makeHTextFlow(idWithoutTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFlow80TM =\n                TestFixture.makeHTextFlow(idWith80MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        HTextFlow textFLow90TM =\n                TestFixture.makeHTextFlow(idWith90MatchTM, hLocale,\n                        ContentState.New, \"pot/a.po\");\n\n        when(\n                textFlowDAO.findByIdList(newArrayList(idWith100MatchTM,\n                        idWithoutTM, idWith80MatchTM, idWith90MatchTM)))\n                .thenReturn(\n                        newArrayList(textFlow100TM, textFlowNoTM, textFlow80TM,\n                                textFLow90TM));\n        // Given: TM results\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryResultItem tm100 = tmResult(tmResultSource.getId(), 100);\n        TransMemoryResultItem tm90 = tmResult(tmResultSource.getId(), 90);\n        TransMemoryResultItem tm80 = tmResult(tmResultSource.getId(), 80);\n\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlow100TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm100));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFLow90TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm90));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlow80TM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(newArrayList(tm80));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale,\n                        new TransMemoryQuery(textFlowNoTM.getContents(),\n                                FUZZY_PLURAL), sourceLocale.getLocaleId()))\n                .thenReturn(Lists.<TransMemoryResultItem> newArrayList());\n\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(2));\n        assertThat(updateRequest.get(0).getNewContents(),\n                Matchers.equalTo(tm100.getTargetContents()));\n        assertThat(updateRequest.get(1).getNewContents(),\n                Matchers.equalTo(tm90.getTargetContents()));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException {\n        // Given: an action with threshold 80% and trans unit id is 1\n        final long transUnitId = 1L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        // Given: there are three TM results returned for text flow id 1, and\n        // the most matched one is text flow id 11\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryResultItem mostSimilarTM =\n                tmResult(tmResultSource.getId(), 100);\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(mostSimilarTM, tmResult(12L, 90),\n                        tmResult(13L, 80)));\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()), same(workspace),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n        assertThat(transUnitUpdateRequest.getNewContents(),\n                Matchers.equalTo(mostSimilarTM.getTargetContents()));\n        assertThat(\n                transUnitUpdateRequest.getTargetComment(),\n                Matchers.equalTo(\"auto translated by TM merge from project: project a, version: master, DocId: pot/msg.pot\"));\n    }","id":40693,"modified_method":"@Test\n    public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException {\n        // Given: an action with threshold 80% and trans unit id is 1\n        final long transUnitId = 1L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        // Given: there are three TM results returned for text flow id 1, and\n        // the most matched one is text flow id 11\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryResultItem mostSimilarTM =\n                tmResult(tmResultSource.getId(), 100);\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(mostSimilarTM, tmResult(12L, 90),\n                        tmResult(13L, 80)));\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n        assertThat(transUnitUpdateRequest.getNewContents(),\n                Matchers.equalTo(mostSimilarTM.getTargetContents()));\n        assertThat(\n                transUnitUpdateRequest.getTargetComment(),\n                Matchers.equalTo(\"auto translated by TM merge from project: project a, version: master, DocId: pot/msg.pot\"));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void willTranslateIfTargetIsNull() throws ActionException {\n        // Given: text flow id 1 is not untranslated\n        final long transUnitId = 1L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        hTextFlow.getTargets().put(hLocale.getId(), null); // make sure target\n                                                           // is null\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        // Given: there is TM results returned for text flow id 1\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n        TransMemoryResultItem tmResult = tmResult(tmResultSource.getId(), 100);\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(tmResult));\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have translation auto filled\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()), same(workspace),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        assertThat(updateRequest.get(0).getNewContents(),\n                Matchers.equalTo(tmResult.getTargetContents()));\n    }","id":40694,"modified_method":"@Test\n    public void willTranslateIfTargetIsNull() throws ActionException {\n        // Given: text flow id 1 is not untranslated\n        final long transUnitId = 1L;\n        TransMemoryMerge action =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n        hTextFlow.getTargets().put(hLocale.getId(), null); // make sure target\n                                                           // is null\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        // Given: there is TM results returned for text flow id 1\n        HTextFlow tmResultSource =\n                TestFixture.makeApprovedHTextFlow(11L, hLocale);\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n        TransMemoryResultItem tmResult = tmResult(tmResultSource.getId(), 100);\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(tmResult));\n        when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(\n                tmResultSource);\n        // Given: tm detail of text flow id 11\n        when(\n                getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale,\n                        tmResultSource)).thenReturn(tmDetail());\n\n        // When: execute the action\n        handler.execute(action, null);\n\n        // Then: we should have translation auto filled\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()),\n                updateRequestCaptor.capture(),\n                same(action.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        assertThat(updateRequest.get(0).getNewContents(),\n                Matchers.equalTo(tmResult.getTargetContents()));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void canAutoTranslateImportedTMResults() throws Exception {\n        // Given:\n        // an action with threshold 80% and trans unit id\n        final long transUnitId = 1L;\n        TransMemoryMerge mergeAction =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        // A Text Flow to be translated\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n\n        // A matching imported Translation Unit\n        TransMemoryUnit tuResultSource =\n                TestFixture.makeTransMemoryUnit(10L, hLocale);\n\n        // and an associated result item\n        TransMemoryResultItem mostSimilarTM =\n                importedTmResult(tuResultSource.getId(), 100);\n\n        // A Translation memory query\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n\n        // Expectations:\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(mostSimilarTM, tmResult(12L, 90),\n                        tmResult(13L, 80)));\n        when(transMemoryUnitDAO.findById(tuResultSource.getId())).thenReturn(\n                tuResultSource);\n\n        // When: execute the action\n        handler.execute(mergeAction, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()), same(workspace),\n                updateRequestCaptor.capture(),\n                same(mergeAction.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n        assertThat(transUnitUpdateRequest.getNewContents(),\n                Matchers.equalTo(mostSimilarTM.getTargetContents()));\n        assertThat(\n                transUnitUpdateRequest.getTargetComment(),\n                Matchers.equalTo(\"auto translated by TM merge from translation memory: test-tm, unique id: uid10\"));\n    }","id":40695,"modified_method":"@Test\n    public void canAutoTranslateImportedTMResults() throws Exception {\n        // Given:\n        // an action with threshold 80% and trans unit id\n        final long transUnitId = 1L;\n        TransMemoryMerge mergeAction =\n                prepareActionAndMockSecurityService(80, transUnitId);\n\n        // A Text Flow to be translated\n        HTextFlow hTextFlow =\n                TestFixture.makeHTextFlow(transUnitId, hLocale,\n                        ContentState.New, \"pot/a.po\");\n\n        // A matching imported Translation Unit\n        TransMemoryUnit tuResultSource =\n                TestFixture.makeTransMemoryUnit(10L, hLocale);\n\n        // and an associated result item\n        TransMemoryResultItem mostSimilarTM =\n                importedTmResult(tuResultSource.getId(), 100);\n\n        // A Translation memory query\n        TransMemoryQuery tmQuery =\n                new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n\n        // Expectations:\n        when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(\n                newArrayList(hTextFlow));\n        when(\n                getTransMemoryHandler.searchTransMemory(hLocale, tmQuery,\n                        sourceLocale.getLocaleId())).thenReturn(\n                newArrayList(mostSimilarTM, tmResult(12L, 90),\n                        tmResult(13L, 80)));\n        when(transMemoryUnitDAO.findById(tuResultSource.getId())).thenReturn(\n                tuResultSource);\n\n        // When: execute the action\n        handler.execute(mergeAction, null);\n\n        // Then: we should have text flow auto translated by using the most\n        // similar TM\n        verify(updateTransUnitHandler).doTranslation(\n                same(hLocale.getLocaleId()),\n                updateRequestCaptor.capture(),\n                same(mergeAction.getEditorClientId()),\n                eq(TransUnitUpdated.UpdateType.NonEditorSave));\n        List<TransUnitUpdateRequest> updateRequest =\n                updateRequestCaptor.getValue();\n        assertThat(updateRequest, Matchers.hasSize(1));\n        TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n        assertThat(transUnitUpdateRequest.getNewContents(),\n                Matchers.equalTo(mostSimilarTM.getTargetContents()));\n        assertThat(\n                transUnitUpdateRequest.getTargetComment(),\n                Matchers.equalTo(\"auto translated by TM merge from translation memory: test-tm, unique id: uid10\"));\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"public UpdateTransUnitResult generateUpdateTransUnitResult(\n            List<TranslationService.TranslationResult> translationResults) {\n        UpdateTransUnitResult result = new UpdateTransUnitResult();\n\n        for (TranslationService.TranslationResult translationResult : translationResults) {\n            // All these information is gathered in TranslationUpdateListener.\n            HTextFlowTarget newTarget =\n                    translationResult.getTranslatedTextFlowTarget();\n            HTextFlow hTextFlow = newTarget.getTextFlow();\n            int wordCount = hTextFlow.getWordCount().intValue();\n            TransUnit tu =\n                    transUnitTransformer.transform(hTextFlow,\n                            newTarget.getLocale());\n            TransUnitUpdateInfo updateInfo =\n                    build(translationResult, new DocumentId(hTextFlow\n                            .getDocument().getId(), hTextFlow.getDocument()\n                            .getDocId()), tu, wordCount);\n\n            result.addUpdateResult(updateInfo);\n        }\n        return result;\n    }","id":40696,"modified_method":"public UpdateTransUnitResult generateUpdateTransUnitResult(\n            List<TranslationService.TranslationResult> translationResults) {\n        UpdateTransUnitResult result = new UpdateTransUnitResult();\n\n        for (TranslationService.TranslationResult translationResult : translationResults) {\n            translationResult.getTranslatedTextFlowTarget().getId();\n            HTextFlowTarget newTarget =\n                    translationResult.getTranslatedTextFlowTarget();\n            TransUnitUpdateInfo transUnitUpdateInfo =\n                    cache.getIfPresent(new CacheKey(newTarget.getId(),\n                            newTarget.getVersionNum()));\n            if (transUnitUpdateInfo != null) {\n                // All these information is gathered in\n                // TranslationUpdateListener.\n                result.addUpdateResult(transUnitUpdateInfo);\n            } else {\n                HTextFlow hTextFlow = newTarget.getTextFlow();\n                int wordCount = hTextFlow.getWordCount().intValue();\n                TransUnit tu =\n                        transUnitTransformer.transform(hTextFlow,\n                                newTarget.getLocale());\n                TransUnitUpdateInfo updateInfo =\n                        build(translationResult, new DocumentId(hTextFlow\n                                .getDocument().getId(), hTextFlow.getDocument()\n                                .getDocId()), tu, wordCount);\n\n                result.addUpdateResult(updateInfo);\n            }\n        }\n        return result;\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void publishTransUnitUpdatedEvent(int previousVersionNum,\n            ContentState previousState, HTextFlowTarget target) {\n        LocaleId localeId = target.getLocaleId();\n        HTextFlow textFlow = target.getTextFlow();\n        HDocument document = textFlow.getDocument();\n        HProjectIteration projectIteration = document.getProjectIteration();\n        String iterationSlug = projectIteration.getSlug();\n        String projectSlug = projectIteration.getProject().getSlug();\n        ProjectType projectType = projectIteration.getProjectType();\n\n        WorkspaceId workspaceId =\n                new WorkspaceId(new ProjectIterationId(projectSlug,\n                        iterationSlug, projectType), localeId);\n        Optional<TranslationWorkspace> workspaceOptional =\n                translationWorkspaceManager.tryGetWorkspace(workspaceId);\n        if (!workspaceOptional.isPresent()) {\n            return;\n        }\n\n        TransUnit transUnit =\n                transUnitTransformer.transform(textFlow, target,\n                        target.getLocale());\n\n        DocumentId documentId =\n                new DocumentId(document.getId(), document.getDocId());\n        int wordCount = textFlow.getWordCount().intValue();\n\n        TransUnitUpdateInfo updateInfo =\n                createTransUnitUpdateInfo(transUnit, documentId, wordCount,\n                        previousVersionNum, previousState);\n\n        CacheValue context =\n                updateContext.getIfPresent(new CacheKey(transUnit.getId(),\n                        transUnit.getLocaleId()));\n        TransUnitUpdated updated;\n        if (context != null) {\n            EditorClientId editorClientId = context.editorClientId;\n            TransUnitUpdated.UpdateType updateType = context.updateType;\n            updated =\n                    new TransUnitUpdated(updateInfo, editorClientId, updateType);\n            log.debug(\"about to publish trans unit updated event {}\", updated);\n        } else if (ServletContexts.instance().getRequest() != null) {\n\n            String sessionId = ServletContexts.instance().getRequest().getSession()\n                    .getId();\n            EditorClientId editorClientId = new EditorClientId(sessionId, -1);\n            updated = new TransUnitUpdated(updateInfo, editorClientId,\n                            TransUnitUpdated.UpdateType.NonEditorSave);\n        } else {\n            updated = new TransUnitUpdated(updateInfo, new EditorClientId(\"unknown\", -1),\n                    TransUnitUpdated.UpdateType.NonEditorSave);\n        }\n        workspaceOptional.get().publish(updated);\n    }","id":40697,"modified_method":"private void publishTransUnitUpdatedEvent(int previousVersionNum,\n            ContentState previousState, HTextFlowTarget target) {\n        LocaleId localeId = target.getLocaleId();\n        HTextFlow textFlow = target.getTextFlow();\n        HDocument document = textFlow.getDocument();\n        HProjectIteration projectIteration = document.getProjectIteration();\n        String iterationSlug = projectIteration.getSlug();\n        String projectSlug = projectIteration.getProject().getSlug();\n        ProjectType projectType = projectIteration.getProjectType();\n\n        WorkspaceId workspaceId =\n                new WorkspaceId(new ProjectIterationId(projectSlug,\n                        iterationSlug, projectType), localeId);\n        Optional<TranslationWorkspace> workspaceOptional =\n                translationWorkspaceManager.tryGetWorkspace(workspaceId);\n        if (!workspaceOptional.isPresent()) {\n            return;\n        }\n\n        TransUnit transUnit =\n                transUnitTransformer.transform(textFlow, target,\n                        target.getLocale());\n\n        DocumentId documentId =\n                new DocumentId(document.getId(), document.getDocId());\n        int wordCount = textFlow.getWordCount().intValue();\n\n        TransUnitUpdateInfo updateInfo =\n                createTransUnitUpdateInfo(transUnit, documentId, wordCount,\n                        previousVersionNum, previousState);\n\n        CacheValue context =\n                updateContext.getIfPresent(new CacheKey(transUnit.getId(),\n                        transUnit.getLocaleId()));\n        TransUnitUpdated updated;\n        if (context != null) {\n            EditorClientId editorClientId = context.editorClientId;\n            TransUnitUpdated.UpdateType updateType = context.updateType;\n            updated =\n                    new TransUnitUpdated(updateInfo, editorClientId, updateType);\n            log.debug(\"about to publish trans unit updated event {}\", updated);\n        } else if (ServletContexts.instance().getRequest() != null) {\n\n            String sessionId = ServletContexts.instance().getRequest().getSession()\n                    .getId();\n            EditorClientId editorClientId = new EditorClientId(sessionId, -1);\n            updated = new TransUnitUpdated(updateInfo, editorClientId,\n                            TransUnitUpdated.UpdateType.NonEditorSave);\n        } else {\n            updated = new TransUnitUpdated(updateInfo, new EditorClientId(\"unknown\", -1),\n                    TransUnitUpdated.UpdateType.NonEditorSave);\n        }\n        if (Events.exists()) {\n            Events.instance().raiseTransactionSuccessEvent(\n                    TextFlowTargetUpdatedEvent.EVENT_NAME, new TextFlowTargetUpdatedEvent(workspaceOptional.get(), target.getId(), updated));\n        }\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected UpdateTransUnitResult doTranslation(LocaleId localeId,\n            TranslationWorkspace workspace,\n            List<TransUnitUpdateRequest> updateRequests,\n            EditorClientId editorClientId,\n            TransUnitUpdated.UpdateType updateType) {\n        if (Events.exists()) {\n            for (TransUnitUpdateRequest updateRequest : updateRequests) {\n                Events.instance().raiseEvent(\n                        TextFlowTargetUpdateContextEvent.EVENT_NAME,\n                        new TextFlowTargetUpdateContextEvent(updateRequest\n                                .getTransUnitId(), localeId, editorClientId,\n                                updateType));\n            }\n        }\n\n        List<TranslationResult> translationResults =\n                translationServiceImpl.translate(localeId, updateRequests);\n        return transUnitUpdateHelper.generateUpdateTransUnitResult(\n                translationResults);\n    }","id":40698,"modified_method":"protected UpdateTransUnitResult doTranslation(LocaleId localeId,\n            List<TransUnitUpdateRequest> updateRequests,\n            EditorClientId editorClientId,\n            TransUnitUpdated.UpdateType updateType) {\n        if (Events.exists()) {\n            for (TransUnitUpdateRequest updateRequest : updateRequests) {\n                Events.instance().raiseEvent(\n                        TextFlowTargetUpdateContextEvent.EVENT_NAME,\n                        new TextFlowTargetUpdateContextEvent(updateRequest\n                                .getTransUnitId(), localeId, editorClientId,\n                                updateType));\n            }\n        }\n\n        List<TranslationResult> translationResults =\n                translationServiceImpl.translate(localeId, updateRequests);\n        return transUnitUpdateHelper.generateUpdateTransUnitResult(\n                translationResults);\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public UpdateTransUnitResult execute(UpdateTransUnit action,\n            ExecutionContext context) throws ActionException {\n        SecurityService.SecurityCheckResult securityCheckResult;\n\n        Optional<TransUnitUpdateRequest> hasReviewUpdate =\n                Iterables.tryFind(action.getUpdateRequests(),\n                        new Predicate<TransUnitUpdateRequest>() {\n                            @Override\n                            public boolean apply(TransUnitUpdateRequest input) {\n                                return input.getNewContentState().isReviewed();\n                            }\n                        });\n        if (hasReviewUpdate.isPresent()) {\n            securityCheckResult =\n                    securityServiceImpl.checkPermission(action,\n                            SecurityService.TranslationAction.REVIEW);\n        } else {\n            securityCheckResult =\n                    securityServiceImpl.checkPermission(action,\n                            SecurityService.TranslationAction.MODIFY);\n        }\n\n        HLocale hLocale = securityCheckResult.getLocale();\n        TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n        return doTranslation(hLocale.getLocaleId(), workspace,\n                action.getUpdateRequests(), action.getEditorClientId(),\n                action.getUpdateType());\n    }","id":40699,"modified_method":"@Override\n    public UpdateTransUnitResult execute(UpdateTransUnit action,\n            ExecutionContext context) throws ActionException {\n\n        Optional<TransUnitUpdateRequest> hasReviewUpdate =\n                Iterables.tryFind(action.getUpdateRequests(),\n                        new Predicate<TransUnitUpdateRequest>() {\n                            @Override\n                            public boolean apply(TransUnitUpdateRequest input) {\n                                return input.getNewContentState().isReviewed();\n                            }\n                        });\n        if (hasReviewUpdate.isPresent()) {\n            securityServiceImpl.checkPermission(action,\n                    SecurityService.TranslationAction.REVIEW);\n        } else {\n            securityServiceImpl.checkPermission(action,\n                    SecurityService.TranslationAction.MODIFY);\n        }\n\n        return doTranslation(action.getWorkspaceId().getLocaleId(),\n                action.getUpdateRequests(), action.getEditorClientId(),\n                action.getUpdateType());\n    }","commit_id":"4f413a0071e2ba61da5c829386132b5abae7b55b","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n\t * Updates the look and feel of the layout.\n\t *\n\t * @param  groupId the primary key of the group\n\t * @param  privateLayout whether the layout is private to the group\n\t * @param  layoutId the primary key of the layout\n\t * @param  themeId the primary key of the layout's new theme\n\t * @param  colorSchemeId the primary key of the layout's new color scheme\n\t * @param  css the layout's new CSS\n\t * @param  wapTheme whether the theme is for WAP browsers\n\t * @return the updated layout\n\t * @throws PortalException if a matching layout could not be found, or if\n\t *         the user did not have permission to update the layout and\n\t *         permission to apply the theme\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Layout updateLookAndFeel(\n\t\t\tlong groupId, boolean privateLayout, long layoutId, String themeId,\n\t\t\tString colorSchemeId, String css, boolean wapTheme)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutPermissionUtil.check(\n\t\t\tgetPermissionChecker(), groupId, privateLayout, layoutId,\n\t\t\tActionKeys.UPDATE);\n\n\t\tpluginSettingLocalService.checkPermission(\n\t\t\tgetUserId(), themeId, Plugin.TYPE_THEME);\n\n\t\treturn layoutLocalService.updateLookAndFeel(\n\t\t\tgroupId, privateLayout, layoutId, themeId, colorSchemeId, css,\n\t\t\twapTheme);\n\t}","id":40700,"modified_method":"/**\n\t * Updates the look and feel of the layout.\n\t *\n\t * @param  groupId the primary key of the group\n\t * @param  privateLayout whether the layout is private to the group\n\t * @param  layoutId the primary key of the layout\n\t * @param  themeId the primary key of the layout's new theme\n\t * @param  colorSchemeId the primary key of the layout's new color scheme\n\t * @param  css the layout's new CSS\n\t * @param  wapTheme whether the theme is for WAP browsers\n\t * @return the updated layout\n\t * @throws PortalException if a matching layout could not be found, or if\n\t *         the user did not have permission to update the layout and\n\t *         permission to apply the theme\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Layout updateLookAndFeel(\n\t\t\tlong groupId, boolean privateLayout, long layoutId, String themeId,\n\t\t\tString colorSchemeId, String css, boolean wapTheme)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutPermissionUtil.check(\n\t\t\tgetPermissionChecker(), groupId, privateLayout, layoutId,\n\t\t\tActionKeys.UPDATE);\n\n\t\tif (Validator.isNotNull(themeId)) {\n\t\t\tpluginSettingLocalService.checkPermission(\n\t\t\t\tgetUserId(), themeId, Plugin.TYPE_THEME);\n\t\t}\n\n\t\treturn layoutLocalService.updateLookAndFeel(\n\t\t\tgroupId, privateLayout, layoutId, themeId, colorSchemeId, css,\n\t\t\twapTheme);\n\t}","commit_id":"36c45c2323d5fffe13273682974ec17a43e980b6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public synchronized HttpResponse doSubmitDescription(\n            @QueryParameter String description) throws IOException,\n            ServletException {\n        if (getOwner() == null) {\n            LOGGER.severe(\"getOwner() is null, can't save description.\");\n        }\n        if (getOwner() != null) {\n            getOwner().checkPermission(Item.BUILD);\n        }\n\n        setDescription(description);\n        if (getOwner() != null) {\n            getOwner().save();\n        }\n\n        return new HttpRedirect(\".\");\n    }","id":40701,"modified_method":"public synchronized HttpResponse doSubmitDescription(\n            @QueryParameter String description) throws IOException,\n            ServletException {\n        if (getOwner() == null) {\n            LOGGER.severe(\"getOwner() is null, can't save description.\");\n        } else {\n            getOwner().checkPermission(Run.UPDATE);\n            setDescription(description);\n            getOwner().save();\n        }\n\n        return new HttpRedirect(\".\");\n    }","commit_id":"cd8376e9b407bf72f41a90eae677f213e137ce93","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n   * Returns the file id for a given path. If the given path does not exist in Alluxio, the method\n   * attempts to load it from UFS.\n   * Needs {@link FileSystemAction#READ} permission on the path.\n   *\n   * @param path the path to get the file id for\n   * @return the file id for a given path, or -1 if there is no file at that path\n   * @throws AccessControlException if permission checking fails\n   */\n  public long getFileId(AlluxioURI path) throws AccessControlException {\n    synchronized (mInodeTree) {\n      Inode inode;\n      try {\n        checkPermission(FileSystemAction.READ, path, false);\n        inode = mInodeTree.getInodeByPath(path);\n      } catch (InvalidPathException e) {\n        try {\n          return loadMetadata(path, true);\n        } catch (Exception e2) {\n          return IdUtils.INVALID_FILE_ID;\n        }\n      }\n      return inode.getId();\n    }\n  }","id":40702,"modified_method":"/**\n   * Returns the file id for a given path. If the given path does not exist in Alluxio, the method\n   * attempts to load it from UFS.\n   * Needs {@link FileSystemAction#READ} permission on the path.\n   *\n   * @param path the path to get the file id for\n   * @return the file id for a given path, or -1 if there is no file at that path\n   * @throws AccessControlException if permission checking fails\n   */\n  public long getFileId(AlluxioURI path) throws AccessControlException {\n    synchronized (mInodeTree) {\n      Inode inode;\n      checkPermission(FileSystemAction.READ, path, false);\n      if (!mInodeTree.inodePathExists(path)) {\n        try {\n          return loadMetadata(path, true);\n        } catch (Exception e) {\n          return IdUtils.INVALID_FILE_ID;\n        }\n      }\n      try {\n        inode = mInodeTree.getInodeByPath(path);\n      } catch (InvalidPathException e2) {\n        throw new AccessControlException(e2.getMessage());\n      }\n      return inode.getId();\n    }\n  }","commit_id":"136c3b3eb6ea5705c95b53d352077328f7268d87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Implements file deletion.\n   *\n   * NOTE: {@link #mInodeTree} should already be locked before calling this method.\n   *\n   * @param fileId the file id\n   * @param recursive if the file id identifies a directory, this flag specifies whether the\n   *        directory content should be deleted recursively\n   * @param replayed whether the operation is a result of replaying the journal\n   * @param opTimeMs the time of the operation\n   * @return true if the file is successfully deleted\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws IOException if an I/O error is encountered\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   */\n  boolean deleteFileInternal(long fileId, boolean recursive, boolean replayed, long opTimeMs)\n      throws FileDoesNotExistException, IOException, DirectoryNotEmptyException {\n    // TODO(jiri): A crash after any UFS object is deleted and before the delete operation is\n    // journaled will result in an inconsistency between Alluxio and UFS.\n    Inode inode = mInodeTree.getInodeById(fileId);\n    if (inode == null) {\n      return true;\n    }\n    if (inode.isDirectory() && !recursive && ((InodeDirectory) inode).getNumberOfChildren() > 0) {\n      // inode is nonempty, and we don't want to delete a nonempty directory unless recursive is\n      // true\n      throw new DirectoryNotEmptyException(ExceptionMessage.DELETE_NONEMPTY_DIRECTORY_NONRECURSIVE,\n          inode.getName());\n    }\n    if (mInodeTree.isRootId(inode.getId())) {\n      // The root cannot be deleted.\n      return false;\n    }\n\n    List<Inode> delInodes = new ArrayList<Inode>();\n    delInodes.add(inode);\n    if (inode.isDirectory()) {\n      delInodes.addAll(mInodeTree.getInodeChildrenRecursive((InodeDirectory) inode));\n    }\n\n    // We go through each inode, removing it from it's parent set and from mDelInodes. If it's a\n    // file, we deal with the checkpoints and blocks as well.\n    for (int i = delInodes.size() - 1; i >= 0; i--) {\n      Inode delInode = delInodes.get(i);\n\n      // TODO(jiri): What should the Alluxio behavior be when a UFS delete operation fails?\n      // Currently, it will result in an inconsistency between Alluxio and UFS.\n      if (!replayed && delInode.isPersisted()) {\n        // Delete the file in the under file system.\n        try {\n          String ufsPath = mMountTable.resolve(mInodeTree.getPath(delInode)).toString();\n          UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n          if (!ufs.exists(ufsPath)) {\n            LOG.warn(\"File does not exist the underfs: {}\", ufsPath);\n          } else if (!ufs.delete(ufsPath, true)) {\n            LOG.error(\"Failed to delete {}\", ufsPath);\n            return false;\n          }\n        } catch (InvalidPathException e) {\n          LOG.warn(e.getMessage());\n        }\n      }\n\n      if (delInode.isFile()) {\n        // Remove corresponding blocks from workers and delete metadata in master.\n        mBlockMaster.removeBlocks(((InodeFile) delInode).getBlockIds(), true /* delete */);\n      }\n\n      mInodeTree.deleteInode(delInode, opTimeMs);\n    }\n    MasterContext.getMasterSource().incPathsDeleted(delInodes.size());\n    return true;\n  }","id":40703,"modified_method":"/**\n   * Implements file deletion.\n   *\n   * NOTE: {@link #mInodeTree} should already be locked before calling this method.\n   *\n   * @param fileId the file id\n   * @param recursive if the file id identifies a directory, this flag specifies whether the\n   *        directory content should be deleted recursively\n   * @param replayed whether the operation is a result of replaying the journal\n   * @param opTimeMs the time of the operation\n   * @return true if the file is successfully deleted\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws IOException if an I/O error is encountered\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   */\n  boolean deleteFileInternal(long fileId, boolean recursive, boolean replayed, long opTimeMs)\n      throws FileDoesNotExistException, IOException, DirectoryNotEmptyException {\n    // TODO(jiri): A crash after any UFS object is deleted and before the delete operation is\n    // journaled will result in an inconsistency between Alluxio and UFS.\n    if (!mInodeTree.inodeIdExists(fileId)) {\n      return true;\n    }\n    Inode inode = mInodeTree.getInodeById(fileId);\n    if (inode.isDirectory() && !recursive && ((InodeDirectory) inode).getNumberOfChildren() > 0) {\n      // inode is nonempty, and we don't want to delete a nonempty directory unless recursive is\n      // true\n      throw new DirectoryNotEmptyException(ExceptionMessage.DELETE_NONEMPTY_DIRECTORY_NONRECURSIVE,\n          inode.getName());\n    }\n    if (mInodeTree.isRootId(inode.getId())) {\n      // The root cannot be deleted.\n      return false;\n    }\n\n    List<Inode> delInodes = new ArrayList<Inode>();\n    delInodes.add(inode);\n    if (inode.isDirectory()) {\n      delInodes.addAll(mInodeTree.getInodeChildrenRecursive((InodeDirectory) inode));\n    }\n\n    // We go through each inode, removing it from it's parent set and from mDelInodes. If it's a\n    // file, we deal with the checkpoints and blocks as well.\n    for (int i = delInodes.size() - 1; i >= 0; i--) {\n      Inode delInode = delInodes.get(i);\n\n      // TODO(jiri): What should the Alluxio behavior be when a UFS delete operation fails?\n      // Currently, it will result in an inconsistency between Alluxio and UFS.\n      if (!replayed && delInode.isPersisted()) {\n        // Delete the file in the under file system.\n        try {\n          String ufsPath = mMountTable.resolve(mInodeTree.getPath(delInode)).toString();\n          UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n          if (!ufs.exists(ufsPath)) {\n            LOG.warn(\"File does not exist the underfs: {}\", ufsPath);\n          } else if (!ufs.delete(ufsPath, true)) {\n            LOG.error(\"Failed to delete {}\", ufsPath);\n            return false;\n          }\n        } catch (InvalidPathException e) {\n          LOG.warn(e.getMessage());\n        }\n      }\n\n      if (delInode.isFile()) {\n        // Remove corresponding blocks from workers and delete metadata in master.\n        mBlockMaster.removeBlocks(((InodeFile) delInode).getBlockIds(), true /* delete */);\n      }\n\n      mInodeTree.deleteInode(delInode, opTimeMs);\n    }\n    MasterContext.getMasterSource().incPathsDeleted(delInodes.size());\n    return true;\n  }","commit_id":"136c3b3eb6ea5705c95b53d352077328f7268d87","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Whether the filesystem contains a directory with the id.\n   *\n   * @param id id of the directory\n   * @return true if there is a directory with the id, false otherwise\n   */\n  public boolean isDirectory(long id) {\n    synchronized (mInodeTree) {\n      Inode inode;\n      try {\n        inode = mInodeTree.getInodeById(id);\n      } catch (FileDoesNotExistException e) {\n        return false;\n      }\n      return inode.isDirectory();\n    }\n  }","id":40704,"modified_method":"/**\n   * Whether the filesystem contains a directory with the id.\n   *\n   * @param id id of the directory\n   * @return true if there is a directory with the id, false otherwise\n   */\n  public boolean isDirectory(long id) {\n    synchronized (mInodeTree) {\n      Inode inode;\n      if (!mInodeTree.inodeIdExists(id)) {\n        return false;\n      }\n      try {\n        inode = mInodeTree.getInodeById(id);\n      } catch (FileDoesNotExistException e) {\n        return false;\n      }\n      return inode.isDirectory();\n    }\n  }","commit_id":"136c3b3eb6ea5705c95b53d352077328f7268d87","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean hasProjectPermissionByUuid(String permission, String projectUuid) {\n    return hasPermission(permission) || (projectPermissionsCheckedByUuid.contains(permission) && projectUuidByPermission.get(permission).contains(projectUuid));\n  }","id":40705,"modified_method":"private boolean hasProjectPermissionByUuid(String permission, String projectUuid) {\n    return projectPermissionsCheckedByUuid.contains(permission) && projectUuidByPermission.get(permission).contains(projectUuid);\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public boolean hasComponentUuidPermission(String permission, String componentUuid) {\n    String projectUuid = projectUuidByComponentUuid.get(componentUuid);\n    return projectUuid != null && hasProjectPermissionByUuid(permission, projectUuid);\n  }","id":40706,"modified_method":"@Override\n  public boolean hasComponentUuidPermission(String permission, String componentUuid) {\n    String projectUuid = projectUuidByComponentUuid.get(componentUuid);\n    return hasPermission(permission) || (projectUuid != null && hasProjectPermissionByUuid(permission, projectUuid));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public boolean hasComponentPermission(String permission, String componentKey) {\n    String projectKey = projectKeyByComponentKey.get(componentKey);\n    return projectKey != null && hasProjectPermission(permission, projectKey);\n  }","id":40707,"modified_method":"@Override\n  public boolean hasComponentPermission(String permission, String componentKey) {\n    String projectKey = projectKeyByComponentKey.get(componentKey);\n    return hasPermission(permission) || (projectKey != null && hasProjectPermission(permission, projectKey));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private boolean hasProjectPermission(String permission, String projectKey) {\n    return hasPermission(permission) || (projectPermissionsCheckedByKey.contains(permission) && projectKeyByPermission.get(permission).contains(projectKey));\n  }","id":40708,"modified_method":"private boolean hasProjectPermission(String permission, String projectKey) {\n    return projectPermissionsCheckedByKey.contains(permission) && projectKeyByPermission.get(permission).contains(projectKey);\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkPermission(boolean preview) {\n    boolean hasScanPerm = userSession.hasPermission(GlobalPermissions.SCAN_EXECUTION);\n    boolean hasPreviewPerm = userSession.hasPermission(GlobalPermissions.PREVIEW_EXECUTION);\n    if (!hasPreviewPerm && !hasScanPerm) {\n      throw new ForbiddenException(Messages.NO_PERMISSION);\n    }\n    if (!preview && !hasScanPerm) {\n      throw new ForbiddenException(\"You're only authorized to execute a local (preview) SonarQube analysis without pushing the results to the SonarQube server. \" +\n        \"Please contact your SonarQube administrator.\");\n    }\n    if (preview && !hasPreviewPerm) {\n      throw new ForbiddenException(\"You're not authorized to execute a preview analysis. Please contact your SonarQube administrator.\");\n    }\n  }","id":40709,"modified_method":"private void checkPermission(boolean preview, boolean hasScanPerm, boolean hasPreviewPerm) {\n    if (!hasPreviewPerm && !hasScanPerm) {\n      throw new ForbiddenException(Messages.NO_PERMISSION);\n    }\n    if (!preview && !hasScanPerm) {\n      throw new ForbiddenException(\"You're only authorized to execute a local (preview) SonarQube analysis without pushing the results to the SonarQube server. \" +\n        \"Please contact your SonarQube administrator.\");\n    }\n    if (preview && !hasPreviewPerm) {\n      throw new ForbiddenException(\"You're not authorized to execute a preview analysis. Please contact your SonarQube administrator.\");\n    }\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ProjectRepositories load(ProjectDataQuery query) {\n    boolean hasScanPerm = userSession.hasPermission(GlobalPermissions.SCAN_EXECUTION);\n    checkPermission(query.isIssuesMode());\n\n    DbSession session = dbClient.openSession(false);\n    try {\n      ProjectRepositories data = new ProjectRepositories();\n      ComponentDto module = checkFoundWithOptional(dbClient.componentDao().selectByKey(session, query.getModuleKey()),\n        \"Project or module with key '%s' is not found\", query.getModuleKey());\n\n      // Scan permission is enough to analyze all projects but preview permission is limited to projects user can access\n      if (query.isIssuesMode() && !userSession.hasComponentUuidPermission(UserRole.USER, module.projectUuid())) {\n        throw new ForbiddenException(\"You're not authorized to access to project '\" + module.name() + \"', please contact your SonarQube administrator.\");\n      }\n\n      ComponentDto project = getProject(module, session);\n      if (!project.key().equals(module.key())) {\n        addSettings(data, module.getKey(), getSettingsFromParents(module, hasScanPerm, session));\n      }\n\n      List<ComponentDto> modulesTree = dbClient.componentDao().selectEnabledDescendantModules(session, module.uuid());\n      Map<String, String> moduleUuidsByKey = moduleUuidsByKey(modulesTree);\n      Map<String, Long> moduleIdsByKey = moduleIdsByKey(modulesTree);\n\n      List<PropertyDto> modulesTreeSettings = dbClient.propertiesDao().selectEnabledDescendantModuleProperties(module.uuid(), session);\n      TreeModuleSettings treeModuleSettings = new TreeModuleSettings(moduleUuidsByKey, moduleIdsByKey, modulesTree, modulesTreeSettings);\n\n      addSettingsToChildrenModules(data, query.getModuleKey(), Maps.<String, String>newHashMap(), treeModuleSettings, hasScanPerm);\n      List<FilePathWithHashDto> files = searchFilesWithHashAndRevision(session, module);\n      addFileData(data, modulesTree, files);\n\n      // FIXME need real value but actually only used to know if there is a previous analysis in local issue tracking mode so any value is\n      // ok\n      data.setLastAnalysisDate(new Date());\n\n      return data;\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":40710,"modified_method":"public ProjectRepositories load(ProjectDataQuery query) {\n    DbSession session = dbClient.openSession(false);\n    try {\n      ProjectRepositories data = new ProjectRepositories();\n      ComponentDto module = checkFoundWithOptional(dbClient.componentDao().selectByKey(session, query.getModuleKey()),\n        \"Project or module with key '%s' is not found\", query.getModuleKey());\n\n      boolean hasScanPerm = userSession.hasComponentUuidPermission(SCAN_EXECUTION, module.projectUuid());\n      boolean hasPreviewPerm = userSession.hasPermission(PREVIEW_EXECUTION);\n      checkPermission(query.isIssuesMode(), hasScanPerm, hasPreviewPerm);\n\n      // Scan permission is enough to analyze all projects but preview permission is limited to projects user can access\n      if (query.isIssuesMode() && !userSession.hasComponentUuidPermission(UserRole.USER, module.projectUuid())) {\n        throw new ForbiddenException(\"You're not authorized to access to project '\" + module.name() + \"', please contact your SonarQube administrator.\");\n      }\n\n      ComponentDto project = getProject(module, session);\n      if (!project.key().equals(module.key())) {\n        addSettings(data, module.getKey(), getSettingsFromParents(module, hasScanPerm, session));\n      }\n\n      List<ComponentDto> modulesTree = dbClient.componentDao().selectEnabledDescendantModules(session, module.uuid());\n      Map<String, String> moduleUuidsByKey = moduleUuidsByKey(modulesTree);\n      Map<String, Long> moduleIdsByKey = moduleIdsByKey(modulesTree);\n\n      List<PropertyDto> modulesTreeSettings = dbClient.propertiesDao().selectEnabledDescendantModuleProperties(module.uuid(), session);\n      TreeModuleSettings treeModuleSettings = new TreeModuleSettings(moduleUuidsByKey, moduleIdsByKey, modulesTree, modulesTreeSettings);\n\n      addSettingsToChildrenModules(data, query.getModuleKey(), Maps.<String, String>newHashMap(), treeModuleSettings, hasScanPerm);\n      List<FilePathWithHashDto> files = searchFilesWithHashAndRevision(session, module);\n      addFileData(data, modulesTree, files);\n\n      // FIXME need real value but actually only used to know if there is a previous analysis in local issue tracking mode so any value is\n      // ok\n      data.setLastAnalysisDate(new Date());\n\n      return data;\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_file_data_from_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // File on project\n    ComponentDto projectFile = ComponentTesting.newFileDto(project, \"projectFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, projectFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(projectFile).setSrcHash(\"123456\").setRevision(\"987654321\"));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // File on module\n    ComponentDto moduleFile = ComponentTesting.newFileDto(module, \"moduleFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, moduleFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(moduleFile).setSrcHash(\"789456\").setRevision(\"123456789\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(module.key()));\n    assertThat(ref.fileData(module.key(), moduleFile.path()).hash()).isEqualTo(\"789456\");\n    assertThat(ref.fileData(module.key(), moduleFile.path()).revision()).isEqualTo(\"123456789\");\n    assertThat(ref.fileData(project.key(), projectFile.path())).isNull();\n  }","id":40711,"modified_method":"@Test\n  public void return_file_data_from_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // File on project\n    ComponentDto projectFile = ComponentTesting.newFileDto(project, \"projectFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, projectFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(projectFile).setSrcHash(\"123456\").setRevision(\"987654321\"));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // File on module\n    ComponentDto moduleFile = ComponentTesting.newFileDto(module, \"moduleFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, moduleFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(moduleFile).setSrcHash(\"789456\").setRevision(\"123456789\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(module.key()));\n    assertThat(ref.fileData(module.key(), moduleFile.path()).hash()).isEqualTo(\"789456\");\n    assertThat(ref.fileData(module.key(), moduleFile.path()).revision()).isEqualTo(\"123456789\");\n    assertThat(ref.fileData(project.key(), projectFile.path())).isNull();\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_file_data_from_multi_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // File on project\n    ComponentDto projectFile = ComponentTesting.newFileDto(project, \"projectFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, projectFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(projectFile).setSrcHash(\"123456\"));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // File on module\n    ComponentDto moduleFile = ComponentTesting.newFileDto(module, \"moduleFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, moduleFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(moduleFile).setSrcHash(\"789456\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.fileData(project.key(), projectFile.path()).hash()).isEqualTo(\"123456\");\n    assertThat(ref.fileData(module.key(), moduleFile.path()).hash()).isEqualTo(\"789456\");\n  }","id":40712,"modified_method":"@Test\n  public void return_file_data_from_multi_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // File on project\n    ComponentDto projectFile = ComponentTesting.newFileDto(project, \"projectFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, projectFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(projectFile).setSrcHash(\"123456\"));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // File on module\n    ComponentDto moduleFile = ComponentTesting.newFileDto(module, \"moduleFile\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, moduleFile);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(moduleFile).setSrcHash(\"789456\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.fileData(project.key(), projectFile.path()).hash()).isEqualTo(\"123456\");\n    assertThat(ref.fileData(module.key(), moduleFile.path()).hash()).isEqualTo(\"789456\");\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_project_with_two_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module1 = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module1);\n\n    // Module 1 properties\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module1.getId()));\n    // This property should not be found on the other module\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module1.getId()));\n\n    ComponentDto module2 = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module2);\n\n    // Module 2 property\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-APPLICATION\").setResourceId(module2.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module1.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n    assertThat(ref.settings(module2.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-APPLICATION\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","id":40713,"modified_method":"@Test\n  public void return_project_with_two_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module1 = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module1);\n\n    // Module 1 properties\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module1.getId()));\n    // This property should not be found on the other module\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module1.getId()));\n\n    ComponentDto module2 = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module2);\n\n    // Module 2 property\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-APPLICATION\").setResourceId(module2.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module1.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n    assertThat(ref.settings(module2.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-APPLICATION\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_project_with_module_settings() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40714,"modified_method":"@Test\n  public void return_project_with_module_settings() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_returned_secured_settings_with_only_preview_permission() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addProjectUuidPermissions(UserRole.USER, project.uuid());\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()).setIssuesMode(true));\n    Map<String, String> projectSettings = ref.settings(project.key());\n    assertThat(projectSettings).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\"));\n  }","id":40715,"modified_method":"@Test\n  public void not_returned_secured_settings_with_only_preview_permission() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(PREVIEW_EXECUTION).addProjectUuidPermissions(UserRole.USER, project.uuid());\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()).setIssuesMode(true));\n    Map<String, String> projectSettings = ref.settings(project.key());\n    assertThat(projectSettings).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_file_data_from_single_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    ComponentDto file = ComponentTesting.newFileDto(project, \"file\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, file);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(file).setSrcHash(\"123456\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.fileDataByPath(project.key())).hasSize(1);\n    FileData fileData = ref.fileData(project.key(), file.path());\n    assertThat(fileData.hash()).isEqualTo(\"123456\");\n  }","id":40716,"modified_method":"@Test\n  public void return_file_data_from_single_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    ComponentDto file = ComponentTesting.newFileDto(project, \"file\");\n    tester.get(DbClient.class).componentDao().insert(dbSession, file);\n    tester.get(FileSourceDao.class).insert(newFileSourceDto(file).setSrcHash(\"123456\"));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.fileDataByPath(project.key())).hasSize(1);\n    FileData fileData = ref.fileData(project.key(), file.path());\n    assertThat(fileData.hash()).isEqualTo(\"123456\");\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_project_settings() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n\n    Map<String, String> projectSettings = ref.settings(project.key());\n    assertThat(projectSettings).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","id":40717,"modified_method":"@Test\n  public void return_project_settings_with_project_scan_permission() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").addProjectUuidPermissions(SCAN_EXECUTION, project.projectUuid());\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n\n    Map<String, String> projectSettings = ref.settings(project.key());\n    assertThat(projectSettings).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_sub_module_settings_including_settings_from_parent_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40718,"modified_method":"@Test\n  public void return_sub_module_settings_including_settings_from_parent_modules() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_sub_module_settings_inherited_from_project_and_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n    // No sub module property\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40719,"modified_method":"@Test\n  public void return_sub_module_settings_inherited_from_project_and_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module property\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n    // No sub module property\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_when_not_preview_and_only_dry_run_permission() {\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION);\n\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    dbSession.commit();\n\n    try {\n      underTest.load(ProjectDataQuery.create().setModuleKey(project.key()).setIssuesMode(false));\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(ForbiddenException.class).hasMessage(\n        \"You're only authorized to execute a local (preview) SonarQube analysis without pushing the results to the SonarQube server. \" +\n          \"Please contact your SonarQube administrator.\");\n    }\n  }","id":40720,"modified_method":"@Test\n  public void fail_when_not_preview_and_only_dry_run_permission() {\n    userSessionRule.login(\"john\").setGlobalPermissions(PREVIEW_EXECUTION);\n\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    dbSession.commit();\n\n    try {\n      underTest.load(ProjectDataQuery.create().setModuleKey(project.key()).setIssuesMode(false));\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(ForbiddenException.class).hasMessage(\n        \"You're only authorized to execute a local (preview) SonarQube analysis without pushing the results to the SonarQube server. \" +\n          \"Please contact your SonarQube administrator.\");\n    }\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_provisioned_project_settings() {\n    // No snapshot attached on the project -> provisioned project\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","id":40721,"modified_method":"@Test\n  public void return_provisioned_project_settings() {\n    // No snapshot attached on the project -> provisioned project\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_sub_module_settings_only_inherited_from_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n    // No module property\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n    // No sub module property\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40722,"modified_method":"@Test\n  public void return_sub_module_settings_only_inherited_from_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n    // No module property\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n    // No sub module property\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_project_with_module_settings_inherited_from_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // No property on module -> should have the same as project\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","id":40723,"modified_method":"@Test\n  public void return_project_with_module_settings_inherited_from_project() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // No property on module -> should have the same as project\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_project_with_module_with_sub_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER-DAO\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER-DAO\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40724,"modified_method":"@Test\n  public void return_project_with_module_with_sub_module() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n\n    // Project properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(project.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(project.getId()));\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n\n    // Module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER\").setResourceId(module.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(module.getId()));\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(\n      dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR-SERVER-DAO\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(project.key()));\n    assertThat(ref.settings(project.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\"));\n    assertThat(ref.settings(module.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR-SERVER-DAO\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_sub_module_settings() {\n\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n    // No project properties\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n    // No module properties\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(subModule.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(subModule.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","id":40725,"modified_method":"@Test\n  public void return_sub_module_settings() {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    tester.get(DbClient.class).componentDao().insert(dbSession, project);\n    addDefaultProfile();\n    // No project properties\n\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    tester.get(DbClient.class).componentDao().insert(dbSession, module);\n    // No module properties\n\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    userSessionRule.login(\"john\").setGlobalPermissions(SCAN_EXECUTION);\n    tester.get(DbClient.class).componentDao().insert(dbSession, subModule);\n\n    // Sub module properties\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.project.key\").setValue(\"SONAR\").setResourceId(subModule.getId()));\n    tester.get(DbClient.class).propertiesDao().insertProperty(dbSession, new PropertyDto().setKey(\"sonar.jira.login.secured\").setValue(\"john\").setResourceId(subModule.getId()));\n    tester.get(DbClient.class).propertiesDao()\n      .insertProperty(dbSession, new PropertyDto().setKey(\"sonar.coverage.exclusions\").setValue(\"**/*.java\").setResourceId(subModule.getId()));\n\n    dbSession.commit();\n\n    ProjectRepositories ref = underTest.load(ProjectDataQuery.create().setModuleKey(subModule.key()));\n    assertThat(ref.settings(project.key())).isEmpty();\n    assertThat(ref.settings(module.key())).isEmpty();\n    assertThat(ref.settings(subModule.key())).isEqualTo(ImmutableMap.of(\n      \"sonar.jira.project.key\", \"SONAR\",\n      \"sonar.jira.login.secured\", \"john\",\n      \"sonar.coverage.exclusions\", \"**/*.java\"));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public CeTask submit(String projectKey, @Nullable String projectBranch, @Nullable String projectName, InputStream reportInput) {\n    userSession.checkPermission(GlobalPermissions.SCAN_EXECUTION);\n\n    String effectiveProjectKey = ComponentKeys.createKey(projectKey, projectBranch);\n    ComponentDto project = componentService.getNullableByKey(effectiveProjectKey);\n    if (project == null) {\n      // the project does not exist -> requires to provision it\n      NewComponent newProject = new NewComponent(projectKey, StringUtils.defaultIfBlank(projectName, projectKey));\n      newProject.setBranch(projectBranch);\n      newProject.setQualifier(Qualifiers.PROJECT);\n      // no need to verify the permission \"provisioning\" as it's already handled by componentService\n      project = componentService.create(newProject);\n      permissionService.applyDefaultPermissionTemplate(project.getKey());\n    }\n\n    // the report file must be saved before submitting the task\n    CeTaskSubmit.Builder submit = queue.prepareSubmit();\n    reportFiles.save(submit.getUuid(), reportInput);\n\n    submit.setType(CeTaskTypes.REPORT);\n    submit.setComponentUuid(project.uuid());\n    submit.setSubmitterLogin(userSession.getLogin());\n    return queue.submit(submit.build());\n  }","id":40726,"modified_method":"public CeTask submit(String projectKey, @Nullable String projectBranch, @Nullable String projectName, InputStream reportInput) {\n    String effectiveProjectKey = ComponentKeys.createKey(projectKey, projectBranch);\n    ComponentDto project = componentService.getNullableByKey(effectiveProjectKey);\n    if (project == null) {\n      // the project does not exist -> require global permission\n      userSession.checkPermission(SCAN_EXECUTION);\n\n      // the project does not exist -> requires to provision it\n      NewComponent newProject = new NewComponent(projectKey, StringUtils.defaultIfBlank(projectName, projectKey));\n      newProject.setBranch(projectBranch);\n      newProject.setQualifier(Qualifiers.PROJECT);\n      // no need to verify the permission \"provisioning\" as it's already handled by componentService\n      project = componentService.create(newProject);\n      permissionService.applyDefaultPermissionTemplate(project.getKey());\n    } else {\n      // the project exists -> require global or project permission\n      userSession.checkComponentPermission(SCAN_EXECUTION, projectKey);\n    }\n\n    // the report file must be saved before submitting the task\n    CeTaskSubmit.Builder submit = queue.prepareSubmit();\n    reportFiles.save(submit.getUuid(), reportInput);\n\n    submit.setType(CeTaskTypes.REPORT);\n    submit.setComponentUuid(project.uuid());\n    submit.setSubmitterLogin(userSession.getLogin());\n    return queue.submit(submit.build());\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void provision_project_if_does_not_exist() throws Exception {\n    when(queue.prepareSubmit()).thenReturn(new CeTaskSubmit.Builder(\"TASK_1\"));\n    userSession.setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION, GlobalPermissions.PROVISIONING);\n    when(componentService.getNullableByKey(\"MY_PROJECT\")).thenReturn(null);\n    when(componentService.create(any(NewComponent.class))).thenReturn(new ComponentDto().setUuid(\"P1\").setKey(\"MY_PROJECT\"));\n\n    underTest.submit(\"MY_PROJECT\", null, \"My Project\", IOUtils.toInputStream(\"{binary}\"));\n\n    verify(permissionService).applyDefaultPermissionTemplate(\"MY_PROJECT\");\n    verify(queue).submit(argThat(new TypeSafeMatcher<CeTaskSubmit>() {\n      @Override\n      protected boolean matchesSafely(CeTaskSubmit submit) {\n        return submit.getType().equals(CeTaskTypes.REPORT) && submit.getComponentUuid().equals(\"P1\") &&\n          submit.getUuid().equals(\"TASK_1\");\n      }\n\n      @Override\n      public void describeTo(Description description) {\n\n      }\n    }));\n\n  }","id":40727,"modified_method":"@Test\n  public void provision_project_if_does_not_exist() throws Exception {\n    userSession.setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION, GlobalPermissions.PROVISIONING);\n\n    when(queue.prepareSubmit()).thenReturn(new CeTaskSubmit.Builder(TASK_UUID));\n    when(componentService.getNullableByKey(PROJECT_KEY)).thenReturn(null);\n    when(componentService.create(any(NewComponent.class))).thenReturn(new ComponentDto().setUuid(PROJECT_UUID).setKey(PROJECT_KEY));\n\n    underTest.submit(PROJECT_KEY, null, PROJECT_NAME, IOUtils.toInputStream(\"{binary}\"));\n\n    verify(permissionService).applyDefaultPermissionTemplate(PROJECT_KEY);\n    verify(queue).submit(argThat(new TypeSafeMatcher<CeTaskSubmit>() {\n      @Override\n      protected boolean matchesSafely(CeTaskSubmit submit) {\n        return submit.getType().equals(CeTaskTypes.REPORT) && submit.getComponentUuid().equals(PROJECT_UUID) &&\n          submit.getUuid().equals(TASK_UUID);\n      }\n\n      @Override\n      public void describeTo(Description description) {\n\n      }\n    }));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void submit_a_report_on_existing_project() {\n    when(queue.prepareSubmit()).thenReturn(new CeTaskSubmit.Builder(\"TASK_1\"));\n    userSession.setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    when(componentService.getNullableByKey(\"MY_PROJECT\")).thenReturn(new ComponentDto().setUuid(\"P1\"));\n\n    underTest.submit(\"MY_PROJECT\", null, \"My Project\", IOUtils.toInputStream(\"{binary}\"));\n\n    verifyZeroInteractions(permissionService);\n    verify(queue).submit(argThat(new TypeSafeMatcher<CeTaskSubmit>() {\n      @Override\n      protected boolean matchesSafely(CeTaskSubmit submit) {\n        return submit.getType().equals(CeTaskTypes.REPORT) && submit.getComponentUuid().equals(\"P1\") &&\n          submit.getUuid().equals(\"TASK_1\");\n      }\n\n      @Override\n      public void describeTo(Description description) {\n\n      }\n    }));\n  }","id":40728,"modified_method":"@Test\n  public void submit_a_report_on_existing_project() {\n    userSession.setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n\n    when(queue.prepareSubmit()).thenReturn(new CeTaskSubmit.Builder(TASK_UUID));\n    when(componentService.getNullableByKey(PROJECT_KEY)).thenReturn(new ComponentDto().setUuid(PROJECT_UUID));\n\n    underTest.submit(PROJECT_KEY, null, PROJECT_NAME, IOUtils.toInputStream(\"{binary}\"));\n\n    verifyZeroInteractions(permissionService);\n    verify(queue).submit(argThat(new TypeSafeMatcher<CeTaskSubmit>() {\n      @Override\n      protected boolean matchesSafely(CeTaskSubmit submit) {\n        return submit.getType().equals(CeTaskTypes.REPORT) && submit.getComponentUuid().equals(PROJECT_UUID) &&\n          submit.getUuid().equals(TASK_UUID);\n      }\n\n      @Override\n      public void describeTo(Description description) {\n\n      }\n    }));\n  }","commit_id":"2b99549791a3487f87547f1293804959b8c9c2e2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SecurityThreadGroup(String name, Set<String> allowedPackages)\n    {\n        super(name);\n        this.allowedPackages = allowedPackages;\n    }","id":40729,"modified_method":"public SecurityThreadGroup(String name, Set<String> allowedPackages, ThreadInitializer threadInitializer)\n    {\n        super(name);\n        this.allowedPackages = allowedPackages;\n        this.threadInitializer = threadInitializer;\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"public void checkAccess(Thread t)\n    {\n        // need to override since the default implementation is kind of ...\n\n        if (isSecuredThread())\n            throw new AccessControlException(\"access denied: \" + SecurityConstants.MODIFY_THREAD_PERMISSION, SecurityConstants.MODIFY_THREAD_PERMISSION);\n        super.checkAccess(t);\n    }","id":40730,"modified_method":"public void checkAccess(Thread t)\n    {\n        // need to override since the default implementation only checks the permission if the current thread's\n        // in the root-thread-group\n\n        if (isSecuredThread())\n            throw new AccessControlException(\"access denied: \" + MODIFY_THREAD_PERMISSION, MODIFY_THREAD_PERMISSION);\n        super.checkAccess(t);\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"private static boolean isSecuredThread()\n    {\n        return Thread.currentThread().getThreadGroup() instanceof SecurityThreadGroup;\n    }","id":40731,"modified_method":"private static boolean isSecuredThread()\n    {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        if (!(tg instanceof SecurityThreadGroup))\n            return false;\n        Boolean threadInitialized = initializedThread.get();\n        if (threadInitialized == null)\n        {\n            initializedThread.set(false);\n            ((SecurityThreadGroup) tg).initializeThread();\n            initializedThread.set(true);\n            threadInitialized = true;\n        }\n        return threadInitialized;\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"public void checkPermission(Permission perm)\n    {\n        if (isSecuredThread())\n            super.checkPermission(perm);\n    }","id":40732,"modified_method":"public void checkPermission(Permission perm)\n    {\n        if (!isSecuredThread())\n            return;\n\n        // required by JavaDriver 2.2.0-rc3 and 3.0.0-a2 or newer\n        // code in com.datastax.driver.core.CodecUtils uses Guava stuff, which in turns requires this permission\n        if (CHECK_MEMBER_ACCESS_PERMISSION.equals(perm))\n            return;\n\n        super.checkPermission(perm);\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"public void checkPackageAccess(String pkg)\n    {\n        ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();\n        if (threadGroup instanceof SecurityThreadGroup)\n        {\n            Set<String> allowedPackages = ((SecurityThreadGroup) threadGroup).getAllowedPackages();\n            if (allowedPackages != null && !allowedPackages.contains(pkg))\n                throw new AccessControlException(\"access denied: \" + new RuntimePermission(\"accessClassInPackage.\" + pkg), new RuntimePermission(\"accessClassInPackage.\" + pkg));\n            super.checkPackageAccess(pkg);\n        }\n    }","id":40733,"modified_method":"public void checkPackageAccess(String pkg)\n    {\n        if (!isSecuredThread())\n            return;\n\n        if (!((SecurityThreadGroup) Thread.currentThread().getThreadGroup()).isPackageAllowed(pkg))\n        {\n            RuntimePermission perm = new RuntimePermission(\"accessClassInPackage.\" + pkg);\n            throw new AccessControlException(\"access denied: \" + perm, perm);\n        }\n\n        super.checkPackageAccess(pkg);\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"public void checkAccess(ThreadGroup g)\n    {\n        // need to override since the default implementation is kind of ...\n\n        if (isSecuredThread())\n            throw new AccessControlException(\"access denied: \" + SecurityConstants.MODIFY_THREADGROUP_PERMISSION, SecurityConstants.MODIFY_THREADGROUP_PERMISSION);\n        super.checkAccess(g);\n    }","id":40734,"modified_method":"public void checkAccess(ThreadGroup g)\n    {\n        // need to override since the default implementation only checks the permission if the current thread's\n        // in the root-thread-group\n\n        if (isSecuredThread())\n            throw new AccessControlException(\"access denied: \" + MODIFY_THREADGROUP_PERMISSION, MODIFY_THREADGROUP_PERMISSION);\n        super.checkAccess(g);\n    }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"ThreadIdAndCpuTime()\n        {\n            // Looks weird?\n            // This call \"just\" links this class to java.lang.management - otherwise UDFs (script UDFs) might fail due to\n            //      java.security.AccessControlException: access denied: (\"java.lang.RuntimePermission\" \"accessClassInPackage.java.lang.management\")\n            // because class loading would be deferred until setup() is executed - but setup() is called with\n            // limited privileges.\n            threadMXBean.getCurrentThreadCpuTime();\n            //\n            // Get the TypeCodec stuff in Java Driver initialized.\n            UDHelper.codecRegistry.codecFor(DataType.inet()).format(InetAddress.getLoopbackAddress());\n            UDHelper.codecRegistry.codecFor(DataType.ascii()).format(\"\");\n        }","id":40735,"modified_method":"ThreadIdAndCpuTime()\n        {\n            // Looks weird?\n            // This call \"just\" links this class to java.lang.management - otherwise UDFs (script UDFs) might fail due to\n            //      java.security.AccessControlException: access denied: (\"java.lang.RuntimePermission\" \"accessClassInPackage.java.lang.management\")\n            // because class loading would be deferred until setup() is executed - but setup() is called with\n            // limited privileges.\n            threadMXBean.getCurrentThreadCpuTime();\n        }","commit_id":"3ae01ddcc0c11a77f34eb48d334e7d3746a26381","url":"https://github.com/apache/cassandra"},{"original_method":"public ObjectInDataStoreManagerImpl() {\n        stateMachines = new StateMachine2<State, Event, DataObjectInStore>();\n        stateMachines.addTransition(State.Allocated, Event.CreateOnlyRequested,\n                State.Creating);\n        stateMachines.addTransition(State.Creating, Event.OperationFailed,\n                State.Allocated);\n        stateMachines.addTransition(State.Creating, Event.OperationSuccessed,\n                State.Ready);\n        stateMachines.addTransition(State.Ready, Event.CopyingRequested,\n                State.Copying);\n        stateMachines.addTransition(State.Copying, Event.OperationSuccessed,\n                State.Ready);\n        stateMachines.addTransition(State.Copying, Event.OperationFailed,\n                State.Ready);\n    }","id":40736,"modified_method":"public ObjectInDataStoreManagerImpl() {\n        stateMachines = new StateMachine2<State, Event, DataObjectInStore>();\n        stateMachines.addTransition(State.Allocated, Event.CreateOnlyRequested,\n                State.Creating);\n        stateMachines.addTransition(State.Creating, Event.OperationFailed,\n                State.Allocated);\n        stateMachines.addTransition(State.Creating, Event.OperationSuccessed,\n                State.Ready);\n        stateMachines.addTransition(State.Ready, Event.CopyingRequested,\n                State.Copying);\n        stateMachines.addTransition(State.Copying, Event.OperationSuccessed,\n                State.Ready);\n        stateMachines.addTransition(State.Copying, Event.OperationFailed,\n                State.Ready);\n        stateMachines.addTransition(State.Ready, Event.DestroyRequested,\n                State.Destroying);\n        stateMachines.addTransition(State.Destroying, Event.DestroyRequested,\n                State.Destroying);\n        stateMachines.addTransition(State.Destroying, Event.OperationSuccessed,\n                State.Destroyed);\n        stateMachines.addTransition(State.Destroying, Event.OperationFailed,\n                State.Destroying);\n    }","commit_id":"8984e430cebb36a93494e7ebc5a51420b48ddc6b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AsyncCallFuture<TemplateApiResult> deleteTemplateAsync(\n            TemplateInfo template) {\n        TemplateObject to = (TemplateObject) template;\n        // update template_store_ref status\n        to.processEvent(ObjectInDataStoreStateMachine.Event.DestroyRequested);\n        AsyncCallFuture<TemplateApiResult> future = new AsyncCallFuture<TemplateApiResult>();\n\n        TemplateOpContext<TemplateApiResult> context = new TemplateOpContext<TemplateApiResult>(null, to, future);\n        AsyncCallbackDispatcher<TemplateServiceImpl, CommandResult> caller = AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().deleteTemplateCallback(null, null)).setContext(context);\n        to.getDataStore().getDriver().deleteAsync(to, caller);\n        return future;\n    }","id":40737,"modified_method":"@Override\n    public AsyncCallFuture<TemplateApiResult> deleteTemplateAsync(\n            TemplateInfo template) {\n        TemplateObject to = (TemplateObject) template;\n        // update template_store_ref status\n        to.processEvent(ObjectInDataStoreStateMachine.Event.DestroyRequested);\n        try {\n            to.stateTransit(TemplateEvent.DestroyRequested);\n        } catch (NoTransitionException e) {\n            s_logger.debug(\"Failed to transit state\", e);\n            //TODO: not fatal right now, still continue\n        }\n\n\n        AsyncCallFuture<TemplateApiResult> future = new AsyncCallFuture<TemplateApiResult>();\n\n        TemplateOpContext<TemplateApiResult> context = new TemplateOpContext<TemplateApiResult>(null, to, future);\n        AsyncCallbackDispatcher<TemplateServiceImpl, CommandResult> caller = AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().deleteTemplateCallback(null, null)).setContext(context);\n        to.getDataStore().getDriver().deleteAsync(to, caller);\n        return future;\n    }","commit_id":"8984e430cebb36a93494e7ebc5a51420b48ddc6b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void createTemplateAsync(\n            TemplateInfo template, DataStore store, AsyncCompletionCallback<TemplateApiResult> callback) {\n        // persist template_store_ref entry\n        DataObject templateOnStore = store.create(template);\n        // update template_store_ref state\n        templateOnStore.processEvent(ObjectInDataStoreStateMachine.Event.CreateOnlyRequested);\n\n        TemplateOpContext<TemplateApiResult> context = new TemplateOpContext<TemplateApiResult>(callback,\n                (TemplateObject)templateOnStore, null);\n\n        AsyncCallbackDispatcher<TemplateServiceImpl, CreateCmdResult> caller = AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().createTemplateCallback(null, null)).setContext(context);\n        store.getDriver().createAsync(templateOnStore, caller);\n    }","id":40738,"modified_method":"@Override\n    public void createTemplateAsync(\n            TemplateInfo template, DataStore store, AsyncCompletionCallback<TemplateApiResult> callback) {\n        // persist template_store_ref entry\n        TemplateObject templateOnStore = (TemplateObject)store.create(template);\n        // update template_store_ref and template state\n        try {\n            templateOnStore.processEvent(ObjectInDataStoreStateMachine.Event.CreateOnlyRequested);\n            templateOnStore.stateTransit(TemplateEvent.CreateRequested);\n        } catch (NoTransitionException e) {\n            s_logger.debug(\"Failed to transit state\", e);\n            TemplateApiResult result = new TemplateApiResult(templateOnStore);\n            result.setResult(e.toString());\n            result.setSucess(false);\n            if ( callback != null ){\n                callback.complete(result);\n            }\n            return;\n        }\n\n        TemplateOpContext<TemplateApiResult> context = new TemplateOpContext<TemplateApiResult>(callback,\n                (TemplateObject)templateOnStore, null);\n\n        AsyncCallbackDispatcher<TemplateServiceImpl, CreateCmdResult> caller = AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().createTemplateCallback(null, null)).setContext(context);\n        store.getDriver().createAsync(templateOnStore, caller);\n    }","commit_id":"8984e430cebb36a93494e7ebc5a51420b48ddc6b","url":"https://github.com/apache/cloudstack"},{"original_method":"protected boolean processEvent(Event event) {\n        if ( this.scheduler != null ) {\n            final Map<String, Serializable> config = new HashMap<String, Serializable>();\n            try {\n                // if the event contains a timed event id or a job id we'll use that as the name\n                String jobName = (String)event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_ID);\n                if ( jobName == null && event.getProperty(EventUtil.PROPERTY_JOB_ID) != null ) {\n                    jobName = \"Timed job \" + event.getProperty(EventUtil.PROPERTY_JOB_ID);\n                }\n\n                // let's see if a schedule information is specified or if the job should be stopped\n                final String expression = (String) event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_SCHEDULE);\n                final Long period = (Long) event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_PERIOD);\n                final Date date = (Date) event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_DATE);\n                int count = 0;\n                if ( expression != null) {\n                    count++;\n                }\n                if ( period != null ) {\n                    count++;\n                }\n                if ( date != null ) {\n                    count++;\n                }\n                if ( count > 1 ) {\n                    this.logger.error(\"Only one configuration property from \" + EventUtil.PROPERTY_TIMED_EVENT_SCHEDULE +\n                                      \", \" + EventUtil.PROPERTY_TIMED_EVENT_PERIOD +\n                                      \", or \" + EventUtil.PROPERTY_TIMED_EVENT_DATE + \" should be used.\");\n                    return true;\n                }\n                if ( count == 0 ) {\n                    // let's stop the event\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Stopping timed event \" + config.get(\"topic\") + \"(\" + jobName + \")\");\n                    }\n                    if ( jobName == null ) {\n                        this.logger.error(\"Unable to stop timed event without proper job name.\");\n                    } else {\n                        this.scheduler.removeJob(jobName);\n                    }\n                    return true;\n                } else {\n                    // copy properties\n                    final Hashtable properties = new Hashtable();\n                    config.put(\"topic\", (String)event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC));\n                    final String[] names = event.getPropertyNames();\n                    if ( names != null ) {\n                        for(int i=0; i<names.length; i++) {\n                            properties.put(names[i], event.getProperty(names[i]));\n                        }\n                    }\n                    config.put(\"config\", properties);\n                    if ( expression != null ) {\n                        if ( this.logger.isDebugEnabled() ) {\n                            this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + jobName + \")\" + \" with cron expression \" + expression);\n                        }\n                        this.scheduler.addJob(jobName, this, config, expression, false);\n                    } else if ( period != null ) {\n                        if ( this.logger.isDebugEnabled() ) {\n                            this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + jobName + \")\" + \" with period \" + period);\n                        }\n                        this.scheduler.addPeriodicJob(jobName, this, config, period, false);\n                    } else {\n                        // then it must be date\n                        if ( this.logger.isDebugEnabled() ) {\n                            this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + jobName + \")\" + \" with date \" + date);\n                        }\n                        this.scheduler.fireJobAt(jobName, this, config, date);\n                    }\n                }\n            } catch (Exception e) {\n                this.ignoreException(e);\n            }\n        } else {\n            this.logger.error(\"No scheduler available to start timed event \" + event);\n        }\n        return false;\n    }","id":40739,"modified_method":"/**\n     * Process the event.\n     * If a scheduler is available, a job is scheduled or stopped.\n     * @param event The incomming event.\n     * @return\n     */\n    protected boolean processEvent(final Event event, final ScheduleInfo scheduleInfo) {\n        if ( this.scheduler != null ) {\n            // is this a stop event?\n            if ( scheduleInfo.isStopEvent() ) {\n                if ( this.logger.isDebugEnabled() ) {\n                    this.logger.debug(\"Stopping timed event \" + event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC) + \"(\" + scheduleInfo.getJobId() + \")\");\n                }\n                try {\n                    this.scheduler.removeJob(scheduleInfo.getJobId());\n                } catch (NoSuchElementException nsee) {\n                    // this can happen if the job is scheduled on another node\n                    // so we can just ignore this\n                }\n                return true;\n            }\n            // we ignore remote job events\n            if ( EventUtil.isLocal(event) ) {\n                return true;\n            }\n\n            // Create configuration for scheduled job\n            final Map<String, Serializable> config = new HashMap<String, Serializable>();\n            // copy properties\n            final Hashtable<String, Object> properties = new Hashtable<String, Object>();\n            config.put(\"topic\", (String)event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC));\n            final String[] names = event.getPropertyNames();\n            if ( names != null ) {\n                for(int i=0; i<names.length; i++) {\n                    properties.put(names[i], event.getProperty(names[i]));\n                }\n            }\n            config.put(\"config\", properties);\n\n            try {\n                if ( scheduleInfo.expression != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + scheduleInfo.getJobId() + \")\" + \" with cron expression \" + scheduleInfo.expression);\n                    }\n                    this.scheduler.addJob(scheduleInfo.getJobId(), this, config, scheduleInfo.expression, false);\n                } else if ( scheduleInfo.period != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + scheduleInfo.getJobId() + \")\" + \" with period \" + scheduleInfo.period);\n                    }\n                    this.scheduler.addPeriodicJob(scheduleInfo.getJobId(), this, config, scheduleInfo.period, false);\n                } else {\n                    // then it must be date\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(\"topic\") + \"(\" + scheduleInfo.getJobId() + \")\" + \" with date \" + scheduleInfo.date);\n                    }\n                    this.scheduler.fireJobAt(scheduleInfo.getJobId(), this, config, scheduleInfo.date);\n                }\n                return true;\n            } catch (Exception e) {\n                this.ignoreException(e);\n            }\n        } else {\n            this.logger.error(\"No scheduler available to start timed event \" + event);\n        }\n        return false;\n    }","commit_id":"d41744f0f14524063e766a8f28cb923d53359f8f","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.event.impl.AbstractRepositoryEventHandler#runInBackground()\n     */\n    protected void runInBackground() {\n        while ( this.running ) {\n            // so let's wait/get the next info from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( info != null && this.running ) {\n                try {\n                    if ( info.nodePath == null ) {\n                        this.processEvent(info.event);\n                    } else {\n                        this.session.refresh(true);\n                        final Node eventNode = (Node) this.session.getItem(info.nodePath);\n                        if ( !eventNode.isLocked() ) {\n                            // lock node\n                            Lock lock = null;\n                            try {\n                                lock = eventNode.lock(false, true);\n                            } catch (RepositoryException re) {\n                                // lock failed which means that the node is locked by someone else, so we don't have to requeue\n                            }\n                            if ( lock != null ) {\n                                this.processEvent(info.event);\n                            }\n                        }\n                    }\n                } catch (RepositoryException e) {\n                    // ignore\n                    this.ignoreException(e);\n                }\n            }\n        }\n    }","id":40740,"modified_method":"/**\n     * @see org.apache.sling.event.impl.AbstractRepositoryEventHandler#runInBackground()\n     */\n    protected void runInBackground() {\n        while ( this.running ) {\n            // so let's wait/get the next info from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( info != null && this.running ) {\n                ScheduleInfo scheduleInfo = null;\n                try {\n                    scheduleInfo = new ScheduleInfo(info.event);\n                } catch (IllegalArgumentException iae) {\n                    this.logger.error(iae.getMessage());\n                }\n                if ( scheduleInfo != null ) {\n                    try {\n                        // if the node path is null, this is a new event\n                        if ( info.nodePath == null ) {\n                            // write event and update path\n                            // if something went wrong we get the node path and reschedule\n                            info.nodePath = this.persistEvent(info.event, scheduleInfo);\n                            if ( info.nodePath != null ) {\n                                try {\n                                    this.queue.put(info);\n                                } catch (InterruptedException e) {\n                                    // this should never happen, so we ignore it\n                                    this.ignoreException(e);\n                                }\n                            }\n                        } else {\n                            this.session.refresh(true);\n                            final Node eventNode = (Node) this.session.getItem(info.nodePath);\n                            if ( !eventNode.isLocked() ) {\n                                // lock node\n                                Lock lock = null;\n                                try {\n                                    lock = eventNode.lock(false, true);\n                                } catch (RepositoryException re) {\n                                    // lock failed which means that the node is locked by someone else, so we don't have to requeue\n                                }\n                                if ( lock != null ) {\n                                    // if something went wrong, we reschedule\n                                    if ( !this.processEvent(info.event, scheduleInfo) ) {\n                                        try {\n                                            this.queue.put(info);\n                                        } catch (InterruptedException e) {\n                                            // this should never happen, so we ignore it\n                                            this.ignoreException(e);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (RepositoryException e) {\n                        // ignore\n                        this.ignoreException(e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"d41744f0f14524063e766a8f28cb923d53359f8f","url":"https://github.com/apache/sling"},{"original_method":"private static void waitEDT() {\n    ModelAccess.instance().flushEventQueue();\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      @Override\n      public void run() {\n      }\n    });\n  }","id":40741,"modified_method":"private static void waitEDT() {\n    ModelAccess.instance().flushEventQueue();\n    ApplicationManager.getApplication().invokeAndWait(new Runnable() {\n      public void run() {\n        return;\n      }\n    }, ModalityState.NON_MODAL);\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        return;\n      }\n    });\n  }","commit_id":"39b5bfbeef1f077e9eb4a383ad49bc4309630c00","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showClassUsages(String fqName) throws RemoteException {\n    Classifier cls = SModelUtil_new.findNodeByFQName(fqName, Classifier.class, myProject.getScope());\n    if (cls == null) return;\n    FrameUtil.activateFrame(getMainFrame());\n    getProjectWindow().findUsages(cls.getNode(), new ProjectOperationContext(myProject));\n  }","id":40742,"modified_method":"public void showClassUsages(final String fqName) throws RemoteException {\n    CommandProcessor.instance().executeLightweightCommand(new Runnable() {\n      public void run() {\n        Classifier cls = SModelUtil_new.findNodeByFQName(fqName, Classifier.class, GlobalScope.getInstance());\n        if (cls == null) {\n          LOG.error(\"Can't find a class \" + fqName);\n          return;\n        }\n        FrameUtil.activateFrame(getMainFrame());\n        getProjectWindow().findUsages(cls.getNode(), GlobalScope.getInstance());\n      }\n    });\n  }","commit_id":"534135da4a137879ce8a2f469800164e2824de61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showAspectMethodUsages(String namespace, final String name) throws RemoteException {\n    List<SModelDescriptor> modelDescriptors = myProject.getScope().getModelDescriptors(namespace);\n    final List<SModel> applicableModelDescriptors = new ArrayList<SModel>();\n    for (final SModelDescriptor descriptor : modelDescriptors) {\n      if (!descriptor.getStereotype().equals(SModelStereotype.JAVA_STUB)) {\n        applicableModelDescriptors.add(descriptor.getSModel());\n      }\n    }\n    new Thread() {\n      public void run() {\n        SearchQuery searchQuery = new SearchQuery(new SNodePointer((SNode) null), myProject.getScope());\n        IResultProvider resultProvider = TreeBuilder.forFinder(new AspectMethodsFinder(applicableModelDescriptors, name));\n        getProjectWindow().getUsagesView().findUsages(resultProvider, searchQuery, false, true, true);\n      }\n    }.start();\n  }","id":40743,"modified_method":"public void showAspectMethodUsages(final String namespace, final String name) throws RemoteException {\n    CommandProcessor.instance().executeLightweightCommand(new Runnable() {\n      public void run() {\n        List<SModelDescriptor> modelDescriptors = GlobalScope.getInstance().getModelDescriptors(namespace);\n        final List<SModel> applicableModelDescriptors = new ArrayList<SModel>();\n        for (final SModelDescriptor descriptor : modelDescriptors) {\n          if (!descriptor.getStereotype().equals(SModelStereotype.JAVA_STUB)) {\n            applicableModelDescriptors.add(descriptor.getSModel());\n          }\n        }\n        new Thread() {\n          public void run() {\n            SearchQuery searchQuery = new SearchQuery(new SNodePointer((SNode) null), GlobalScope.getInstance());\n            IResultProvider resultProvider = TreeBuilder.forFinder(new AspectMethodsFinder(applicableModelDescriptors, name));\n            getProjectWindow().getUsagesView().findUsages(resultProvider, searchQuery, false, true, true);\n          }\n        }.start();\n      }\n    });\n  }","commit_id":"534135da4a137879ce8a2f469800164e2824de61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showNode(final String namespace, final String id) throws RemoteException {\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        List<SModelDescriptor> modelDescriptors = myProject.getScope().getModelDescriptors(namespace);\n        for (SModelDescriptor descriptor : modelDescriptors) {\n          if (descriptor.getStereotype().equals(SModelStereotype.JAVA_STUB)) continue;\n\n          SNode node = descriptor.getSModel().getNodeById(id);\n          if (node != null) {\n            IDEProjectFrame frame = getProjectWindow();\n            ModuleContext operationContext = ModuleContext.create(node, getProjectWindow());\n            EditorsPane pane = frame.getEditorsPane();\n            IEditor editor = pane.openEditor(node, operationContext);\n            NavigationActionProcessor.executeNavigationAction(new EditorNavigationCommand(node, editor, pane), operationContext.getProject());\n          }\n        }\n\n        FrameUtil.activateFrame(getMainFrame());\n      }\n    });\n  }","id":40744,"modified_method":"public void showNode(final String namespace, final String id) throws RemoteException {\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        CommandProcessor.instance().executeLightweightCommand(new Runnable() {\n          public void run() {\n            List<SModelDescriptor> modelDescriptors = GlobalScope.getInstance().getModelDescriptors(namespace);\n            for (SModelDescriptor descriptor : modelDescriptors) {\n              if (descriptor.getStereotype().equals(SModelStereotype.JAVA_STUB)) continue;\n\n              SNode node = descriptor.getSModel().getNodeById(id);\n              if (node != null) {\n                IDEProjectFrame frame = getProjectWindow();\n                ModuleContext operationContext = ModuleContext.create(node, getProjectWindow());\n                EditorsPane pane = frame.getEditorsPane();\n                IEditor editor = pane.openEditor(node, operationContext);\n                NavigationActionProcessor.executeNavigationAction(new EditorNavigationCommand(node, editor, pane), operationContext.getProject());\n              }\n            }\n\n            FrameUtil.activateFrame(getMainFrame());\n          }\n        });\n      }\n    });\n  }","commit_id":"534135da4a137879ce8a2f469800164e2824de61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showConceptNode(String fqName) throws RemoteException {\n    ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(fqName, myProject.getScope());\n    IDEProjectFrame projectWindow = getProjectWindow();\n    projectWindow.getEditorsPane().openEditor(concept.getNode(), new ProjectOperationContext(projectWindow.getProject()));\n    FrameUtil.activateFrame(getMainFrame());\n  }","id":40745,"modified_method":"public void showConceptNode(final String fqName) throws RemoteException {\n    CommandProcessor.instance().executeLightweightCommand(new Runnable() {\n      public void run() {\n        ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(fqName, GlobalScope.getInstance());\n        IDEProjectFrame projectWindow = getProjectWindow();\n        projectWindow.getEditorsPane().openEditor(concept.getNode(), new ProjectOperationContext(projectWindow.getProject()));\n        FrameUtil.activateFrame(getMainFrame());\n      }\n    });\n  }","commit_id":"534135da4a137879ce8a2f469800164e2824de61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showMethodUsages(String classFqName, String methodName, int parameterCount) throws RemoteException {\n    Classifier cls = SModelUtil_new.findNodeByFQName(classFqName, Classifier.class, myProject.getScope());\n    if (cls == null) return;\n    BaseMethodDeclaration m = null;\n    for (BaseMethodDeclaration method : cls.getChildren(BaseMethodDeclaration.class)) {\n      if (methodName.equals(method.getName()) && method.getParametersCount() == parameterCount) {\n        m = method;\n        break;\n      }\n    }\n    if (m == null) return;\n    FrameUtil.activateFrame(getMainFrame());\n    getProjectWindow().findUsages(m.getNode(), new ProjectOperationContext(myProject));\n  }","id":40746,"modified_method":"public void showMethodUsages(final String classFqName, final String methodName, final int parameterCount) throws RemoteException {\n    CommandProcessor.instance().executeLightweightCommand(new Runnable() {\n      public void run() {\n        Classifier cls = SModelUtil_new.findNodeByFQName(classFqName, Classifier.class, GlobalScope.getInstance());\n        if (cls == null) {\n          LOG.error(\"Can't find a class \" + classFqName);\n          return;\n        }\n        BaseMethodDeclaration m = null;\n        for (BaseMethodDeclaration method : cls.getChildren(BaseMethodDeclaration.class)) {\n          if (methodName.equals(method.getName()) && method.getParametersCount() == parameterCount) {\n            m = method;\n            break;\n          }\n        }\n        if (m == null) {\n          LOG.error(\"Can't find a method \" + classFqName + \".\" + methodName);\n          return;\n        }\n        FrameUtil.activateFrame(getMainFrame());\n\n        getProjectWindow().findUsages(m.getNode(), GlobalScope.getInstance());\n      }\n    });\n  }","commit_id":"534135da4a137879ce8a2f469800164e2824de61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean generate() {\n    myLogger.clear();\n    long startJobTime = System.currentTimeMillis();\n\n    myGenerationHandler.startGeneration(myLogger);\n    initMaps();\n    long totalJob = estimateGenerationTime();\n    ITaskProgressHelper progressHelper = new TaskProgressHelper(myProgress, totalJob, startJobTime);\n    try {\n      boolean generationOK = true;\n      try {\n        for (Pair<IModule, List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {\n          boolean result = generateModelsInModule(moduleAndDescriptors.o1, moduleAndDescriptors.o2, progressHelper);\n          generationOK = generationOK && result;\n        }\n      } finally {\n        if (myParallelTaskPool != null) {\n          myParallelTaskPool.dispose();\n          myParallelTaskPool = null;\n        }\n      }\n      if (generationOK) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"generation completed successfully in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n        }\n      } else {\n        myLogger.error(\"generation completed with errors in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n      }\n      generationOK = compile(progressHelper, generationOK);\n\n      fireModelsGenerated(generationOK);\n      return generationOK;\n    } catch (GenerationCanceledException gce) {\n      myLogger.warning(\"generation canceled\");\n      return false;\n    } catch (GenerationFailureException e) {\n      myLogger.error(e.getMessage());\n      return false;\n    } catch (Throwable t) {\n      myLogger.handleException(t);\n      return false;\n    } finally {\n      myGenerationHandler.finishGeneration(progressHelper);\n    }\n  }","id":40747,"modified_method":"public boolean generate() {\n    myLogger.clear();\n    long startJobTime = System.currentTimeMillis();\n\n    myGenerationHandler.startGeneration(myLogger);\n    initMaps();\n    long totalJob = estimateGenerationTime();\n    ITaskProgressHelper progressHelper = new TaskProgressHelper(myProgress, totalJob, startJobTime);\n    try {\n      boolean generationOK = true;\n      try {\n        for (Pair<IModule, List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {\n          boolean result = generateModelsInModule(moduleAndDescriptors.o1, moduleAndDescriptors.o2, progressHelper);\n          generationOK = generationOK && result;\n        }\n      } finally {\n        if (myParallelTaskPool != null) {\n          myParallelTaskPool.dispose();\n          myParallelTaskPool = null;\n        }\n      }\n      if (generationOK) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"generation completed successfully in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n        }\n      } else {\n        myLogger.error(\"generation completed with errors in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n      }\n      generationOK = compile(progressHelper, generationOK);\n\n      fireModelsGenerated(generationOK);\n      return generationOK;\n    } catch (GenerationCanceledException gce) {\n      myLogger.warning(\"generation canceled\");\n      return false;\n    } catch (GenerationFailureException e) {\n      myLogger.error(e.getMessage());\n      return false;\n    } catch (Exception t) {\n      myLogger.handleException(t);\n      return false;\n    } finally {\n      myGenerationHandler.finishGeneration(progressHelper);\n    }\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationStatus generateModel() throws GenerationCanceledException {\n    if (myMajorStep != 0) {\n      throw new GenerationCanceledException();\n    }\n\n    // create a plan\n    ttrace.push(\"analyzing dependencies\", false);\n    myGenerationPlan = new GenerationPlan(myOriginalInputModel.getSModel());\n    if (!checkGenerationPlan(myGenerationPlan)) {\n      // throw new GenerationCanceledException();\n    }\n\n    GenerationFilter filter = new GenerationFilter(myOriginalInputModel, myInvocationContext, myGenerationOptions, myGenerationPlan.getSignature());\n    myDependenciesBuilder = filter.createDependenciesBuilder();\n\n    if (filter.canOptimize()) {\n      int ignored = filter.getIgnoredRoots().size();\n      int total = filter.getRootsCount();\n      myLogger.info((!filter.canIgnoreConditionals() ? \"\" : \"descriptors and \") + ignored + \" of \" + total + \" roots are unchanged\");\n\n      if (total > 0 && ignored == total && filter.canIgnoreConditionals()) {\n        myLogger.info(\"generated files are up-to-date\");\n        ttrace.pop();\n        return new GenerationStatus(myOriginalInputModel.getSModel(), null,\n          myDependenciesBuilder.getResult(myInvocationContext, myGenerationOptions.getIncrementalStrategy()), false, false, false);\n      }\n\n      if (!filter.getRequiredRoots().isEmpty() || filter.requireConditionals()) {\n        myLogger.info((!filter.requireConditionals() ? \"\" : \"descriptors and \") + filter.getRequiredRoots().size() + \" roots can be used from cache\");\n      }\n\n      if (myGenerationOptions.getTracingMode() != GenerationOptions.TRACE_OFF) {\n        myLogger.info(\"Processing:\");\n        for (SNode node : myOriginalInputModel.getSModel().roots()) {\n          if (filter.getRequiredRoots().contains(node)) {\n            myLogger.info(node.getName() + \" (cache)\");\n          } else if (!filter.getIgnoredRoots().contains(node)) {\n            myLogger.info(node.getName());\n          }\n        }\n      }\n    }\n\n    boolean success = false;\n\n    myNewCache = filter.createNewCache();\n    ttrace.pop();\n    try {\n      SModel currInputModel = myOriginalInputModel.getSModel();\n      SModel currOutput = null;\n\n      ttrace.push(\"steps\", false);\n      for (myMajorStep = 0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"executing step \" + (myMajorStep + 1));\n        }\n        //ttrace.push(\"step \" + (myMajorStep + 1), false);\n        currOutput = executeMajorStep(currInputModel);\n        //ttrace.pop();\n        if (currOutput == null || myLogger.getErrorCount() > 0) {\n          break;\n        }\n        if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {\n          break;\n        }\n        currInputModel = currOutput;\n      }\n      ttrace.pop();\n\n      // we need this in order to prevent memory leaks from nodes which are reported to message view\n      // since session objects might include objects with disposed class loaders\n      if (mySessionContext != null) {\n        mySessionContext.clearTransientObjects();\n      }\n\n      GenerationStatus generationStatus = new GenerationStatus(myOriginalInputModel.getSModel(), currOutput,\n        myDependenciesBuilder.getResult(myInvocationContext, myGenerationOptions.getIncrementalStrategy()), myLogger.getErrorCount() > 0,\n        myLogger.getWarningCount() > 0, false);\n      success = generationStatus.isOk();\n      return generationStatus;\n    } catch (GenerationCanceledException gce) {\n      throw gce;\n    } catch (GenerationFailureException gfe) {\n      // FIXME\n      myLogger.error(gfe.getMessage());\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelReference().getSModelFqName() + \"\\\" generation failed : \" + gfe);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } catch (Throwable e) {\n      myLogger.handleException(e);\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelReference().getSModelFqName() + \"\\\" generation failed : \" + e);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } finally {\n      if (myNewCache != null) {\n        if (success) {\n          myNewCache.store();\n        } else {\n          myNewCache.remove();\n        }\n        myLogger.info(\"time spent saving cache: \" + myNewCache.getTimeSpent());\n      }\n    }\n  }","id":40748,"modified_method":"public GenerationStatus generateModel() throws GenerationCanceledException {\n    if (myMajorStep != 0) {\n      throw new GenerationCanceledException();\n    }\n\n    // create a plan\n    ttrace.push(\"analyzing dependencies\", false);\n    myGenerationPlan = new GenerationPlan(myOriginalInputModel.getSModel());\n    if (!checkGenerationPlan(myGenerationPlan)) {\n      // throw new GenerationCanceledException();\n    }\n\n    GenerationFilter filter = new GenerationFilter(myOriginalInputModel, myInvocationContext, myGenerationOptions, myGenerationPlan.getSignature());\n    myDependenciesBuilder = filter.createDependenciesBuilder();\n\n    if (filter.canOptimize()) {\n      int ignored = filter.getIgnoredRoots().size();\n      int total = filter.getRootsCount();\n      myLogger.info((!filter.canIgnoreConditionals() ? \"\" : \"descriptors and \") + ignored + \" of \" + total + \" roots are unchanged\");\n\n      if (total > 0 && ignored == total && filter.canIgnoreConditionals()) {\n        myLogger.info(\"generated files are up-to-date\");\n        ttrace.pop();\n        return new GenerationStatus(myOriginalInputModel.getSModel(), null,\n          myDependenciesBuilder.getResult(myInvocationContext, myGenerationOptions.getIncrementalStrategy()), false, false, false);\n      }\n\n      if (!filter.getRequiredRoots().isEmpty() || filter.requireConditionals()) {\n        myLogger.info((!filter.requireConditionals() ? \"\" : \"descriptors and \") + filter.getRequiredRoots().size() + \" roots can be used from cache\");\n      }\n\n      if (myGenerationOptions.getTracingMode() != GenerationOptions.TRACE_OFF) {\n        myLogger.info(\"Processing:\");\n        for (SNode node : myOriginalInputModel.getSModel().roots()) {\n          if (filter.getRequiredRoots().contains(node)) {\n            myLogger.info(node.getName() + \" (cache)\");\n          } else if (!filter.getIgnoredRoots().contains(node)) {\n            myLogger.info(node.getName());\n          }\n        }\n      }\n    }\n\n    boolean success = false;\n\n    myNewCache = filter.createNewCache();\n    ttrace.pop();\n    try {\n      SModel currInputModel = myOriginalInputModel.getSModel();\n      SModel currOutput = null;\n\n      ttrace.push(\"steps\", false);\n      for (myMajorStep = 0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"executing step \" + (myMajorStep + 1));\n        }\n        //ttrace.push(\"step \" + (myMajorStep + 1), false);\n        currOutput = executeMajorStep(currInputModel);\n        //ttrace.pop();\n        if (currOutput == null || myLogger.getErrorCount() > 0) {\n          break;\n        }\n        if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {\n          break;\n        }\n        currInputModel = currOutput;\n      }\n      ttrace.pop();\n\n      // we need this in order to prevent memory leaks from nodes which are reported to message view\n      // since session objects might include objects with disposed class loaders\n      if (mySessionContext != null) {\n        mySessionContext.clearTransientObjects();\n      }\n\n      GenerationStatus generationStatus = new GenerationStatus(myOriginalInputModel.getSModel(), currOutput,\n        myDependenciesBuilder.getResult(myInvocationContext, myGenerationOptions.getIncrementalStrategy()), myLogger.getErrorCount() > 0,\n        myLogger.getWarningCount() > 0, false);\n      success = generationStatus.isOk();\n      return generationStatus;\n    } catch (GenerationCanceledException gce) {\n      throw gce;\n    } catch (GenerationFailureException gfe) {\n      // FIXME\n      myLogger.error(gfe.getMessage());\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelReference().getSModelFqName() + \"\\\" generation failed : \" + gfe);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } catch (Exception e) {\n      myLogger.handleException(e);\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelReference().getSModelFqName() + \"\\\" generation failed : \" + e);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } finally {\n      if (myNewCache != null) {\n        if (success) {\n          myNewCache.store();\n        } else {\n          myNewCache.remove();\n        }\n        myLogger.info(\"time spent saving cache: \" + myNewCache.getTimeSpent());\n      }\n    }\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n    if(generatorCaches.exists()) {\n      Assert.assertTrue(FileUtil.delete(generatorCaches));\n    }\n    Assert.assertTrue(generatorCaches.mkdir());\n\n    final MyIncrementalGenerationStrategy incrementalStrategy = new MyIncrementalGenerationStrategy(descr, new FileBasedGenerationCacheContainer(generatorCaches));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        incrementalStrategy.buildHash();\n      }\n    });\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    // Stage 2. Modify model\n    Map<String, String> incrementalGenerationResults = null;\n    List<Long> time = new ArrayList<Long>();\n    Assert.assertTrue(changeModel.length > 0);\n    for(final Runnable r : changeModel) {\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n        }\n      });\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          incrementalStrategy.buildHash();\n        }\n      });\n      Assert.assertNotNull(generationHandler.getLastDependencies());\n      incrementalStrategy.setDependencies(generationHandler.getLastDependencies());\n\n      // Stage 3. Generate incrementally\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      generationHandler.checkIncremental();\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      incrementalGenerationResults = generationHandler.getGeneratedContent();\n      assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n    }\n\n    // Stage 4. Regenerate. Check incremental results.\n\n    incrementalStrategy.setDependencies(null);\n    options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n    generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n    long start = System.nanoTime();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n    time.add(System.nanoTime() - start);\n\n    assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n    PerformanceMessenger.getInstance().reportPercent(\"incrementalGeneration\", (time.get(time.size() - 2))/1000000, (time.get(time.size() - 1))/1000000);\n\n    if(DEBUG) {\n      long regen = time.remove(time.size() - 1);\n      System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n      for(long l : time) {\n        System.out.print(\", incremental: \" + l/1000000/1000.);\n      }\n      System.out.println();\n    }\n  }","id":40749,"modified_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor originalModel, final ModelChangeRunnable... changeModel) throws IOException {\n    String randomName = \"testxw\" + Math.abs(UUID.randomUUID().getLeastSignificantBits()) + \".\" + originalModel.getModule().getModuleFqName();\n    String randomId = UUID.randomUUID().toString();\n    final TestModule tm = new TestModule(randomName, randomId, originalModel.getModule());\n    final SModelDescriptor[] descr1 = new SModelDescriptor[] { null };\n    try {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          descr1[0] = tm.createModel(originalModel);\n          tm.publish(descr1[0]);\n        }\n      });\n      final SModelDescriptor descr = descr1[0];\n\n      GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n      File generatorCaches = new File(PathManager.getSystemPath(), \"mps-generator-test\");\n      if (generatorCaches.exists()) {\n        Assert.assertTrue(FileUtil.delete(generatorCaches));\n      }\n      Assert.assertTrue(\"cannot create caches folder\", generatorCaches.mkdir());\n\n      final MyIncrementalGenerationStrategy incrementalStrategy = new MyIncrementalGenerationStrategy(descr, new FileBasedGenerationCacheContainer(generatorCaches));\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          incrementalStrategy.buildHash();\n        }\n      });\n\n      // Stage 1. Regenerate\n\n      GenerationOptions options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n      Map<String,String> generated = replaceInContent(generationHandler.getGeneratedContent(), new String[] { randomName, originalModel.getModule().getModuleFqName() }, new String[] { randomId, originalModel.getModule().getModuleReference().getModuleId().toString() });\n      assertNoDiff(generationHandler.getExistingContent(), generated);\n\n      // Stage 2. Modify model\n\n      Map<String, String> incrementalGenerationResults = generationHandler.getGeneratedContent();\n      List<Long> time = new ArrayList<Long>();\n      Assert.assertTrue(changeModel.length > 0);\n      for (final ModelChangeRunnable r : changeModel) {\n\n        ThreadUtils.runInUIThreadAndWait(new Runnable() {\n          @Override\n          public void run() {\n            ModelAccess.instance().runWriteActionInCommand(new Runnable(){\n              @Override\n              public void run() {\n                r.run(descr);\n              }\n            }, p.getProject());\n          }\n        });\n\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            incrementalStrategy.buildHash();\n          }\n        });\n        Assert.assertNotNull(generationHandler.getLastDependencies());\n        incrementalStrategy.setDependencies(generationHandler.getLastDependencies());\n\n        // Stage 3. Generate incrementally\n\n        options = GenerationOptions.getDefaults()\n          .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n        generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n        generationHandler.checkIncremental();\n        long start = System.nanoTime();\n        gm.generateModels(\n          Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n          generationHandler,\n          new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n        time.add(System.nanoTime() - start);\n\n        incrementalGenerationResults = generationHandler.getGeneratedContent();\n        assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults,1);\n      }\n\n      // Stage 4. Regenerate. Check incremental results.\n\n      incrementalStrategy.setDependencies(null);\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(incrementalStrategy).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      assertNoDiff(incrementalGenerationResults, generationHandler.getGeneratedContent());\n\n      PerformanceMessenger.getInstance().reportPercent(\"incrementalGeneration\", (time.get(time.size() - 2)) / 1000000, (time.get(time.size() - 1)) / 1000000);\n\n      if (DEBUG) {\n        long regen = time.remove(time.size() - 1);\n        System.out.print(\"Full cycle: \" + regen / 1000000 / 1000.);\n        for (long l : time) {\n          System.out.print(\", incremental: \" + l / 1000000 / 1000.);\n        }\n        System.out.println();\n      }\n    } finally {\n      tm.dispose();\n    }\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Ignore\n  public void testPluginStructure() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/core/languageDesign/plugin/plugin.mpr\"));\n    final SModelDescriptor descr = findModel(p, \"jetbrains.mps.lang.plugin.structure\");\n\n    doTestIncrementalGeneration(p, descr,\n      new Runnable() {\n        public void run() {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"ActionGroupDeclaration\");\n          Assert.assertNotNull(\"No root in model\", root);\n          root.setName(\"ActionGroupRedeclaration\");\n        }\n      });\n\n    cleanup(p);\n  }","id":40750,"modified_method":"@Test\n  public void testPluginStructure() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/core/languageDesign/plugin/plugin.mpr\"));\n    SModelDescriptor descr = findModel(p, \"jetbrains.mps.lang.plugin.structure\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        public void run(SModelDescriptor descr) {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"ActionGroupDeclaration\");\n          Assert.assertNotNull(\"No root in model\", root);\n          root.setName(\"ActionGroupRedeclaration\");\n        }\n      });\n\n    cleanup(p);\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Ignore\n  public void testBaseLanguageEditor() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/core/baseLanguage/baseLanguage/baseLanguage.mpr\"));\n    final SModelDescriptor descr = findModel(p, \"jetbrains.mps.baseLanguage.editor\");\n\n    doTestIncrementalGeneration(p, descr,\n      new Runnable() {\n        public void run() {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"StatementList_Editor\");\n          Assert.assertNotNull(\"No root in model\", root);\n          descr.getSModel().removeRoot(root);\n        }\n      });\n\n    cleanup(p);\n  }","id":40751,"modified_method":"@Test\n  public void testBaseLanguageEditor() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/core/baseLanguage/baseLanguage/baseLanguage.mpr\"));\n    SModelDescriptor descr = findModel(p, \"jetbrains.mps.baseLanguage.editor\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        public void run(SModelDescriptor descr) {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"StatementList_Editor\");\n          Assert.assertNotNull(\"No root in model\", root);\n          descr.getSModel().removeRoot(root);\n        }\n      });\n\n    cleanup(p);\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Ignore\n  public void testIdeActions() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/workbench/workbench.mpr\"));\n    final SModelDescriptor descr = findModel(p, \"jetbrains.mps.ide.actions\");\n\n    doTestIncrementalGeneration(p, descr,\n      new Runnable() {\n        public void run() {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"Generate\");\n          Assert.assertNotNull(\"No root in model\", root);\n          root.setName(\"GenerateIt\");\n        }\n      });\n\n    cleanup(p);\n  }","id":40752,"modified_method":"@Test\n  public void testIdeActions() throws IOException {\n    final MPSProject p = TestMain.loadProject(new File(System.getProperty(\"user.dir\") + \"/workbench/workbench.mpr\"));\n    SModelDescriptor descr = findModel(p, \"jetbrains.mps.ide.actions\");\n\n    doTestIncrementalGeneration(p, descr,\n      new ModelChangeRunnable() {\n        public void run(SModelDescriptor descr) {\n          SModel model = descr.getSModel();\n          SNode root = SModelOperations.getRootByName(model,\"Generate\");\n          Assert.assertNotNull(\"No root in model\", root);\n          root.setName(\"GenerateIt\");\n        }\n      });\n\n    cleanup(p);\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean canHandle(SModelDescriptor inputModel) {\n    return SModelStereotype.isUserModel(inputModel);\n  }","id":40753,"modified_method":"@Override\n  public boolean canHandle(SModelDescriptor inputModel) {\n    return true;\n  }","commit_id":"47337838743bd59438cbd0bac91a8b6fbf05fb0b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void disposeMPS() {\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      @Override\n      public void run() {\n        IdeaTestApplication.getInstance(null).dispose();\n      }\n    });\n  }","id":40754,"modified_method":"public static void disposeMPS() {\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            IdeaTestApplication.getInstance(null).dispose();\n          }\n        });\n      }\n    });\n  }","commit_id":"aa4e28b1b0413689642d73072b2a40a882aff59e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void setComponent(RadComponent component) {\n    myComponent = (RadViewComponent)component;\n  }","id":40755,"modified_method":"@Override\n  public void setComponent(RadComponent component) {\n    myComponent = (RadViewComponent)component;\n    myMargins = getMargins(myComponent);\n  }","commit_id":"c49459b0c06400d957de7845c2ecfcffd31b3505","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void execute() throws Exception {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        XmlTag tag = myComponent.getTag();\n\n        XmlAttribute margin = tag.getAttribute(\"android:layout_margin\");\n        if (margin != null) {\n          String value = margin.getValue();\n          margin.delete();\n\n          if (!StringUtil.isEmpty(value)) {\n            tag.setAttribute(\"android:layout_marginLeft\", value);\n            tag.setAttribute(\"android:layout_marginRight\", value);\n            tag.setAttribute(\"android:layout_marginTop\", value);\n            tag.setAttribute(\"android:layout_marginBottom\", value);\n          }\n        }\n\n        Point moveDelta = myContext.getMoveDelta();\n        Dimension sizeDelta = myContext.getSizeDelta();\n        int direction = myContext.getResizeDirection();\n\n        if (direction == Position.WEST) { // left\n          setValue(tag, \"android:layout_marginLeft\", -moveDelta.x);\n        }\n        else if (direction == Position.EAST) { // right\n          setValue(tag, \"android:layout_marginRight\", sizeDelta.width);\n        }\n        else if (direction == Position.NORTH) { // top\n          setValue(tag, \"android:layout_marginTop\", -moveDelta.y);\n        }\n        else if (direction == Position.SOUTH) { // bottom\n          setValue(tag, \"android:layout_marginBottom\", sizeDelta.height);\n        }\n      }\n    });\n  }","id":40756,"modified_method":"@Override\n  public void execute() throws Exception {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        XmlTag tag = myComponent.getTag();\n\n        XmlAttribute margin = tag.getAttribute(\"android:layout_margin\");\n        if (margin != null) {\n          String value = margin.getValue();\n          margin.delete();\n\n          if (!StringUtil.isEmpty(value)) {\n            tag.setAttribute(\"android:layout_marginLeft\", value);\n            tag.setAttribute(\"android:layout_marginRight\", value);\n            tag.setAttribute(\"android:layout_marginTop\", value);\n            tag.setAttribute(\"android:layout_marginBottom\", value);\n          }\n        }\n\n        Point moveDelta = myContext.getMoveDelta();\n        Dimension sizeDelta = myContext.getSizeDelta();\n        int direction = myContext.getResizeDirection();\n\n        if (direction == Position.WEST) { // left\n          setValue(tag, \"android:layout_marginLeft\", myMargins.x - moveDelta.x);\n        }\n        else if (direction == Position.EAST) { // right\n          setValue(tag, \"android:layout_marginRight\", myMargins.width + sizeDelta.width);\n        }\n        else if (direction == Position.NORTH) { // top\n          setValue(tag, \"android:layout_marginTop\", myMargins.y - moveDelta.y);\n        }\n        else if (direction == Position.SOUTH) { // bottom\n          setValue(tag, \"android:layout_marginBottom\", myMargins.height + sizeDelta.height);\n        }\n      }\n    });\n  }","commit_id":"c49459b0c06400d957de7845c2ecfcffd31b3505","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void points(ResizeSelectionDecorator decorator) {\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.WEST, TYPE)); // left\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.EAST, TYPE).move(1, 0.25)); // right\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.NORTH, TYPE)); // top\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.SOUTH, TYPE).move(0.25, 1)); // bottom\n  }","id":40757,"modified_method":"public static void points(ResizeSelectionDecorator decorator) {\n    decorator.addPoint(new ResizePoint() {\n      private final BasicStroke myStroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1, DASHES, 0);\n\n      @Override\n      protected void paint(DecorationLayer layer, Graphics2D g, RadComponent component) {\n        Rectangle bounds = component.getBounds(layer);\n        applyMargins(bounds, getMargins(component));\n\n        g.setStroke(myStroke);\n        g.setColor(Color.red);\n        g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n      }\n\n      @Override\n      public InputTool findTargetTool(DecorationLayer layer, RadComponent component, int x, int y) {\n        return null;\n      }\n\n      @Override\n      public Object getType() {\n        return null;\n      }\n\n      @Override\n      protected InputTool createTool(RadComponent component) {\n        return null;\n      }\n\n      @Override\n      protected Point getLocation(DecorationLayer layer, RadComponent component) {\n        return null;\n      }\n    });\n\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.WEST, FrameLayoutMarginOperation.TYPE) { // left\n      @Override\n      protected Point getLocation(DecorationLayer layer, RadComponent component) {\n        Point location = super.getLocation(layer, component);\n        location.x -= getMargin(component, \"leftMargin\");\n        return location;\n      }\n    });\n\n    decorator\n      .addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.EAST, FrameLayoutMarginOperation.TYPE) { // right\n        @Override\n        protected Point getLocation(DecorationLayer layer, RadComponent component) {\n          Point location = super.getLocation(layer, component);\n          location.x += getMargin(component, \"rightMargin\");\n          return location;\n        }\n      }.move(1, 0.25));\n\n    decorator.addPoint(new DirectionResizePoint(Color.orange, Color.black, Position.NORTH, FrameLayoutMarginOperation.TYPE) { // top\n      @Override\n      protected Point getLocation(DecorationLayer layer, RadComponent component) {\n        Point location = super.getLocation(layer, component);\n        location.y -= getMargin(component, \"topMargin\");\n        return location;\n      }\n    });\n\n    decorator.addPoint(\n      new DirectionResizePoint(Color.orange, Color.black, Position.SOUTH, FrameLayoutMarginOperation.TYPE) { // bottom\n        @Override\n        protected Point getLocation(DecorationLayer layer, RadComponent component) {\n          Point location = super.getLocation(layer, component);\n          location.y += getMargin(component, \"bottomMargin\");\n          return location;\n        }\n      }.move(0.25, 1));\n  }","commit_id":"c49459b0c06400d957de7845c2ecfcffd31b3505","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void showFeedback() {\n    createFeedback();\n\n    myFeedback.setBounds(myContext.getTransformedRectangle(myComponent.getBounds(myContext.getArea().getFeedbackLayer())));\n\n    Point moveDelta = myContext.getMoveDelta();\n    Dimension sizeDelta = myContext.getSizeDelta();\n    int direction = myContext.getResizeDirection();\n\n    myTextFeedback.clear();\n\n    if (direction == Position.WEST) { // left\n      myTextFeedback.append(Integer.toString(-moveDelta.x));\n    }\n    else if (direction == Position.EAST) { // right\n      myTextFeedback.append(Integer.toString(sizeDelta.width));\n    }\n    else if (direction == Position.NORTH) { // top\n      myTextFeedback.append(Integer.toString(-moveDelta.y));\n    }\n    else if (direction == Position.SOUTH) { // bottom\n      myTextFeedback.append(Integer.toString(sizeDelta.height));\n    }\n\n    myTextFeedback.dimension(\"dp\");\n    myTextFeedback.locationTo(myContext.getLocation(), 15);\n  }","id":40758,"modified_method":"@Override\n  public void showFeedback() {\n    createFeedback();\n\n    Rectangle bounds = myContext.getTransformedRectangle(myComponent.getBounds(myContext.getArea().getFeedbackLayer()));\n    applyMargins(bounds, myMargins);\n    myFeedback.setBounds(bounds);\n\n    Point moveDelta = myContext.getMoveDelta();\n    Dimension sizeDelta = myContext.getSizeDelta();\n    int direction = myContext.getResizeDirection();\n\n    myTextFeedback.clear();\n\n    if (direction == Position.WEST) { // left\n      myTextFeedback.append(Integer.toString(myMargins.x - moveDelta.x));\n    }\n    else if (direction == Position.EAST) { // right\n\n      myTextFeedback.append(Integer.toString(myMargins.width + sizeDelta.width));\n    }\n    else if (direction == Position.NORTH) { // top\n      myTextFeedback.append(Integer.toString(myMargins.y - moveDelta.y));\n    }\n    else if (direction == Position.SOUTH) { // bottom\n      myTextFeedback.append(Integer.toString(myMargins.height + sizeDelta.height));\n    }\n\n    myTextFeedback.dimension(\"dp\");\n    myTextFeedback.locationTo(myContext.getLocation(), 15);\n  }","commit_id":"c49459b0c06400d957de7845c2ecfcffd31b3505","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    ResizeSelectionDecorator decorator = new ResizeSelectionDecorator(Color.red, 1) {\n      @Override\n      protected boolean visible(RadComponent component, ResizePoint point) {\n        if (point.getType() == FrameLayoutMarginOperation.TYPE) {\n          return FrameLayoutMarginOperation.visible(component, (DirectionResizePoint)point);\n        }\n        return true;\n      }\n    };\n    ResizeOperation.points(decorator);\n    if (selection.size() == 1) {\n      FrameLayoutMarginOperation.points(decorator);\n    }\n    return decorator;\n  }","id":40759,"modified_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    ResizeSelectionDecorator decorator = new ResizeSelectionDecorator(Color.red, 1) {\n      @Override\n      protected boolean visible(RadComponent component, ResizePoint point) {\n        if (point.getType() == FrameLayoutMarginOperation.TYPE) {\n          return FrameLayoutMarginOperation.visible(component, (DirectionResizePoint)point);\n        }\n        return true;\n      }\n    };\n    if (selection.size() == 1) {\n      FrameLayoutMarginOperation.points(decorator);\n    }\n    ResizeOperation.points(decorator);\n    return decorator;\n  }","commit_id":"c49459b0c06400d957de7845c2ecfcffd31b3505","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int run(String[] args) throws Exception {\n    if (args.length < 2) {\n      usage(\"Wrong number of arguments: \" + args.length);\n      return -1;\n    }\n\n    // When MAPPER_CONF_KEY is null, the user wants to use the provided TsvImporterMapper, so\n    // perform validation on these additional args. When it's not null, user has provided their\n    // own mapper, thus these validation are not relevant.\n    // TODO: validation for TsvImporterMapper, not this tool. Move elsewhere.\n    if (null == getConf().get(MAPPER_CONF_KEY)) {\n      // Make sure columns are specified\n      String[] columns = getConf().getStrings(COLUMNS_CONF_KEY);\n      if (columns == null) {\n        usage(\"No columns specified. Please specify with -D\" +\n            COLUMNS_CONF_KEY+\"=...\");\n        return -1;\n      }\n\n      // Make sure they specify exactly one column as the row key\n      int rowkeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.ROWKEY_COLUMN_SPEC)) rowkeysFound++;\n      }\n      if (rowkeysFound != 1) {\n        usage(\"Must specify exactly one column as \" + TsvParser.ROWKEY_COLUMN_SPEC);\n        return -1;\n      }\n\n      // Make sure we have at most one column as the timestamp key\n      int tskeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.TIMESTAMPKEY_COLUMN_SPEC))\n          tskeysFound++;\n      }\n      if (tskeysFound > 1) {\n        usage(\"Must specify at most one column as \"\n            + TsvParser.TIMESTAMPKEY_COLUMN_SPEC);\n        return -1;\n      }\n\n      int attrKeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.ATTRIBUTES_COLUMN_SPEC))\n          attrKeysFound++;\n      }\n      if (attrKeysFound > 1) {\n        usage(\"Must specify at most one column as \"\n            + TsvParser.ATTRIBUTES_COLUMN_SPEC);\n        return -1;\n      }\n\n      // Make sure one or more columns are specified excluding rowkey and\n      // timestamp key\n      if (columns.length - (rowkeysFound + tskeysFound + attrKeysFound) < 1) {\n        usage(\"One or more columns in addition to the row key and timestamp(optional) are required\");\n        return -1;\n      }\n    }\n\n    // If timestamp option is not specified, use current system time.\n    long timstamp = getConf().getLong(TIMESTAMP_CONF_KEY, System.currentTimeMillis());\n\n    // Set it back to replace invalid timestamp (non-numeric) with current\n    // system time\n    getConf().setLong(TIMESTAMP_CONF_KEY, timstamp);\n\n    Job job = createSubmittableJob(getConf(), args);\n    return job.waitForCompletion(true) ? 0 : 1;\n  }","id":40760,"modified_method":"@Override\n  public int run(String[] args) throws Exception {\n    if (args.length < 2) {\n      usage(\"Wrong number of arguments: \" + args.length);\n      return -1;\n    }\n\n    // When MAPPER_CONF_KEY is null, the user wants to use the provided TsvImporterMapper, so\n    // perform validation on these additional args. When it's not null, user has provided their\n    // own mapper, thus these validation are not relevant.\n    // TODO: validation for TsvImporterMapper, not this tool. Move elsewhere.\n    if (null == getConf().get(MAPPER_CONF_KEY)) {\n      // Make sure columns are specified\n      String[] columns = getConf().getStrings(COLUMNS_CONF_KEY);\n      if (columns == null) {\n        usage(\"No columns specified. Please specify with -D\" +\n            COLUMNS_CONF_KEY+\"=...\");\n        return -1;\n      }\n\n      // Make sure they specify exactly one column as the row key\n      int rowkeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.ROWKEY_COLUMN_SPEC)) rowkeysFound++;\n      }\n      if (rowkeysFound != 1) {\n        usage(\"Must specify exactly one column as \" + TsvParser.ROWKEY_COLUMN_SPEC);\n        return -1;\n      }\n\n      // Make sure we have at most one column as the timestamp key\n      int tskeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.TIMESTAMPKEY_COLUMN_SPEC))\n          tskeysFound++;\n      }\n      if (tskeysFound > 1) {\n        usage(\"Must specify at most one column as \"\n            + TsvParser.TIMESTAMPKEY_COLUMN_SPEC);\n        return -1;\n      }\n\n      int attrKeysFound = 0;\n      for (String col : columns) {\n        if (col.equals(TsvParser.ATTRIBUTES_COLUMN_SPEC))\n          attrKeysFound++;\n      }\n      if (attrKeysFound > 1) {\n        usage(\"Must specify at most one column as \"\n            + TsvParser.ATTRIBUTES_COLUMN_SPEC);\n        return -1;\n      }\n\n      // Make sure one or more columns are specified excluding rowkey and\n      // timestamp key\n      if (columns.length - (rowkeysFound + tskeysFound + attrKeysFound) < 1) {\n        usage(\"One or more columns in addition to the row key and timestamp(optional) are required\");\n        return -1;\n      }\n    }\n\n    // If timestamp option is not specified, use current system time.\n    long timstamp = getConf().getLong(TIMESTAMP_CONF_KEY, System.currentTimeMillis());\n\n    // Set it back to replace invalid timestamp (non-numeric) with current\n    // system time\n    getConf().setLong(TIMESTAMP_CONF_KEY, timstamp);\n\n    dryRunTableCreated = false;\n    Job job = createSubmittableJob(getConf(), args);\n    boolean success = job.waitForCompletion(true);\n    if (dryRunTableCreated) {\n      deleteTable(getConf(), args);\n    }\n    return success ? 0 : 1;\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    String usage =\n      \"Usage: \" + NAME + \" -D\"+ COLUMNS_CONF_KEY + \"=a,b,c <tablename> <inputdir>\\n\" +\n      \"\\n\" +\n      \"Imports the given input directory of TSV data into the specified table.\\n\" +\n      \"\\n\" +\n      \"The column names of the TSV data must be specified using the -D\" + COLUMNS_CONF_KEY + \"\\n\" +\n      \"option. This option takes the form of comma-separated column names, where each\\n\" +\n      \"column name is either a simple column family, or a columnfamily:qualifier. The special\\n\" +\n      \"column name \" + TsvParser.ROWKEY_COLUMN_SPEC + \" is used to designate that this column should be used\\n\" +\n      \"as the row key for each imported record. You must specify exactly one column\\n\" +\n      \"to be the row key, and you must specify a column name for every column that exists in the\\n\" +\n      \"input data. Another special column\" + TsvParser.TIMESTAMPKEY_COLUMN_SPEC +\n      \" designates that this column should be\\n\" +\n      \"used as timestamp for each record. Unlike \" + TsvParser.ROWKEY_COLUMN_SPEC + \", \" +\n      TsvParser.TIMESTAMPKEY_COLUMN_SPEC + \" is optional.\\n\" +\n      \"You must specify at most one column as timestamp key for each imported record.\\n\" +\n      \"Record with invalid timestamps (blank, non-numeric) will be treated as bad record.\\n\" +\n      \"Note: if you use this option, then '\" + TIMESTAMP_CONF_KEY + \"' option will be ignored.\\n\" +\n      \"\\n\" +\n      TsvParser.ATTRIBUTES_COLUMN_SPEC+\" can be used to specify Operation Attributes per record.\\n\"+\n      \" Should be specified as key=>value where \"+TsvParser.DEFAULT_ATTRIBUTES_COLUMN_INDEX+ \" is used \\n\"+\n      \" as the seperator.  Note that more than one OperationAttributes can be specified.\\n\"+\n      \"By default importtsv will load data directly into HBase. To instead generate\\n\" +\n      \"HFiles of data to prepare for a bulk data load, pass the option:\\n\" +\n      \"  -D\" + BULK_OUTPUT_CONF_KEY + \"=/path/for/output\\n\" +\n      \"  Note: if you do not use this option, then the target table must already exist in HBase\\n\" +\n      \"\\n\" +\n      \"Other options that may be specified with -D include:\\n\" +\n      \"  -D\" + SKIP_LINES_CONF_KEY + \"=false - fail if encountering an invalid line\\n\" +\n      \"  '-D\" + SEPARATOR_CONF_KEY + \"=|' - eg separate on pipes instead of tabs\\n\" +\n      \"  -D\" + TIMESTAMP_CONF_KEY + \"=currentTimeAsLong - use the specified timestamp for the import\\n\" +\n      \"  -D\" + MAPPER_CONF_KEY + \"=my.Mapper - A user-defined Mapper to use instead of \" +\n      DEFAULT_MAPPER.getName() + \"\\n\" +\n      \"  -D\" + JOB_NAME_CONF_KEY + \"=jobName - use the specified mapreduce job name for the import\\n\" +\n      \"  -D\" + CREATE_TABLE_CONF_KEY + \"=no - can be used to avoid creation of table by this tool\\n\" +\n      \"  Note: if you set this to 'no', then the target table must already exist in HBase\\n\" +\n      \"  -D\" + NO_STRICT_COL_FAMILY + \"=true - ignore column family check in hbase table. \" +\n      \"Default is false\\n\\n\" +\n      \"For performance consider the following options:\\n\" +\n      \"  -Dmapreduce.map.speculative=false\\n\" +\n      \"  -Dmapreduce.reduce.speculative=false\";\n\n    System.err.println(usage);\n  }","id":40761,"modified_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    String usage =\n      \"Usage: \" + NAME + \" -D\"+ COLUMNS_CONF_KEY + \"=a,b,c <tablename> <inputdir>\\n\" +\n      \"\\n\" +\n      \"Imports the given input directory of TSV data into the specified table.\\n\" +\n      \"\\n\" +\n      \"The column names of the TSV data must be specified using the -D\" + COLUMNS_CONF_KEY + \"\\n\" +\n      \"option. This option takes the form of comma-separated column names, where each\\n\" +\n      \"column name is either a simple column family, or a columnfamily:qualifier. The special\\n\" +\n      \"column name \" + TsvParser.ROWKEY_COLUMN_SPEC + \" is used to designate that this column should be used\\n\" +\n      \"as the row key for each imported record. You must specify exactly one column\\n\" +\n      \"to be the row key, and you must specify a column name for every column that exists in the\\n\" +\n      \"input data. Another special column\" + TsvParser.TIMESTAMPKEY_COLUMN_SPEC +\n      \" designates that this column should be\\n\" +\n      \"used as timestamp for each record. Unlike \" + TsvParser.ROWKEY_COLUMN_SPEC + \", \" +\n      TsvParser.TIMESTAMPKEY_COLUMN_SPEC + \" is optional.\\n\" +\n      \"You must specify at most one column as timestamp key for each imported record.\\n\" +\n      \"Record with invalid timestamps (blank, non-numeric) will be treated as bad record.\\n\" +\n      \"Note: if you use this option, then '\" + TIMESTAMP_CONF_KEY + \"' option will be ignored.\\n\" +\n      \"\\n\" +\n      TsvParser.ATTRIBUTES_COLUMN_SPEC+\" can be used to specify Operation Attributes per record.\\n\"+\n      \" Should be specified as key=>value where \"+TsvParser.DEFAULT_ATTRIBUTES_COLUMN_INDEX+ \" is used \\n\"+\n      \" as the seperator.  Note that more than one OperationAttributes can be specified.\\n\"+\n      \"By default importtsv will load data directly into HBase. To instead generate\\n\" +\n      \"HFiles of data to prepare for a bulk data load, pass the option:\\n\" +\n      \"  -D\" + BULK_OUTPUT_CONF_KEY + \"=/path/for/output\\n\" +\n      \"  Note: if you do not use this option, then the target table must already exist in HBase\\n\" +\n      \"\\n\" +\n      \"Other options that may be specified with -D include:\\n\" +\n      \"  -D\" + DRY_RUN_CONF_KEY + \"=true - Dry run mode. Data is not actually populated into\" +\n      \" table. If table does not exist, it is created but deleted in the end.\\n\" +\n      \"  -D\" + SKIP_LINES_CONF_KEY + \"=false - fail if encountering an invalid line\\n\" +\n      \"  -D\" + LOG_BAD_LINES_CONF_KEY + \"=true - logs invalid lines to stderr\\n\" +\n      \"  '-D\" + SEPARATOR_CONF_KEY + \"=|' - eg separate on pipes instead of tabs\\n\" +\n      \"  -D\" + TIMESTAMP_CONF_KEY + \"=currentTimeAsLong - use the specified timestamp for the import\\n\" +\n      \"  -D\" + MAPPER_CONF_KEY + \"=my.Mapper - A user-defined Mapper to use instead of \" +\n      DEFAULT_MAPPER.getName() + \"\\n\" +\n      \"  -D\" + JOB_NAME_CONF_KEY + \"=jobName - use the specified mapreduce job name for the import\\n\" +\n      \"  -D\" + CREATE_TABLE_CONF_KEY + \"=no - can be used to avoid creation of table by this tool\\n\" +\n      \"  Note: if you set this to 'no', then the target table must already exist in HBase\\n\" +\n      \"  -D\" + NO_STRICT_COL_FAMILY + \"=true - ignore column family check in hbase table. \" +\n      \"Default is false\\n\\n\" +\n      \"For performance consider the following options:\\n\" +\n      \"  -Dmapreduce.map.speculative=false\\n\" +\n      \"  -Dmapreduce.reduce.speculative=false\";\n\n    System.err.println(usage);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n      throws IOException, ClassNotFoundException {\n    Job job = null;\n    try (Connection connection = ConnectionFactory.createConnection(conf)) {\n      try (Admin admin = connection.getAdmin()) {\n        // Support non-XML supported characters\n        // by re-encoding the passed separator as a Base64 string.\n        String actualSeparator = conf.get(SEPARATOR_CONF_KEY);\n        if (actualSeparator != null) {\n          conf.set(SEPARATOR_CONF_KEY,\n              Base64.encodeBytes(actualSeparator.getBytes()));\n        }\n\n        // See if a non-default Mapper was set\n        String mapperClassName = conf.get(MAPPER_CONF_KEY);\n        Class mapperClass =\n          mapperClassName != null ? Class.forName(mapperClassName) : DEFAULT_MAPPER;\n\n          TableName tableName = TableName.valueOf(args[0]);\n          Path inputDir = new Path(args[1]);\n          String jobName = conf.get(JOB_NAME_CONF_KEY,NAME + \"_\" + tableName.getNameAsString());\n          job = Job.getInstance(conf, jobName);\n          job.setJarByClass(mapperClass);\n          FileInputFormat.setInputPaths(job, inputDir);\n          job.setInputFormatClass(TextInputFormat.class);\n          job.setMapperClass(mapperClass);\n          String hfileOutPath = conf.get(BULK_OUTPUT_CONF_KEY);\n          String[] columns = conf.getStrings(COLUMNS_CONF_KEY);\n          if(StringUtils.isNotEmpty(conf.get(CREDENTIALS_LOCATION))) {\n            String fileLoc = conf.get(CREDENTIALS_LOCATION);\n            Credentials cred = Credentials.readTokenStorageFile(new File(fileLoc), conf);\n            job.getCredentials().addAll(cred);\n          }\n\n          if (hfileOutPath != null) {\n            if (!admin.tableExists(tableName)) {\n              String errorMsg = format(\"Table '%s' does not exist.\", tableName);\n              if (\"yes\".equalsIgnoreCase(conf.get(CREATE_TABLE_CONF_KEY, \"yes\"))) {\n                LOG.warn(errorMsg);\n                // TODO: this is backwards. Instead of depending on the existence of a table,\n                // create a sane splits file for HFileOutputFormat based on data sampling.\n                createTable(admin, tableName, columns);\n              } else {\n                LOG.error(errorMsg);\n                throw new TableNotFoundException(errorMsg);\n              }\n            }\n            try (Table table = connection.getTable(tableName);\n                RegionLocator regionLocator = connection.getRegionLocator(tableName)) {\n              boolean noStrict = conf.getBoolean(NO_STRICT_COL_FAMILY, false);\n              // if no.strict is false then check column family\n              if(!noStrict) {\n                ArrayList<String> unmatchedFamilies = new ArrayList<String>();\n                Set<String> cfSet = getColumnFamilies(columns);\n                HTableDescriptor tDesc = table.getTableDescriptor();\n                for (String cf : cfSet) {\n                  if(tDesc.getFamily(Bytes.toBytes(cf)) == null) {\n                    unmatchedFamilies.add(cf);\n                  }\n                }\n                if(unmatchedFamilies.size() > 0) {\n                  ArrayList<String> familyNames = new ArrayList<String>();\n                  for (HColumnDescriptor family : table.getTableDescriptor().getFamilies()) {\n                    familyNames.add(family.getNameAsString());\n                  }\n                  String msg =\n                      \"Column Families \" + unmatchedFamilies + \" specified in \" + COLUMNS_CONF_KEY\n                      + \" does not match with any of the table \" + tableName\n                      + \" column families \" + familyNames + \".\\n\"\n                      + \"To disable column family check, use -D\" + NO_STRICT_COL_FAMILY\n                      + \"=true.\\n\";\n                  usage(msg);\n                  System.exit(-1);\n                } \n              }\n              job.setReducerClass(PutSortReducer.class);\n              Path outputDir = new Path(hfileOutPath);\n              FileOutputFormat.setOutputPath(job, outputDir);\n              job.setMapOutputKeyClass(ImmutableBytesWritable.class);\n              if (mapperClass.equals(TsvImporterTextMapper.class)) {\n                job.setMapOutputValueClass(Text.class);\n                job.setReducerClass(TextSortReducer.class);\n              } else {\n                job.setMapOutputValueClass(Put.class);\n                job.setCombinerClass(PutCombiner.class);\n              }\n              HFileOutputFormat2.configureIncrementalLoad(job, table.getTableDescriptor(),\n                  regionLocator);\n            }\n          } else {\n            if (!admin.tableExists(tableName)) {\n              String errorMsg = format(\"Table '%s' does not exist.\", tableName);\n              LOG.error(errorMsg);\n              throw new TableNotFoundException(errorMsg);\n            }\n            if (mapperClass.equals(TsvImporterTextMapper.class)) {\n              usage(TsvImporterTextMapper.class.toString()\n                  + \" should not be used for non bulkloading case. use \"\n                  + TsvImporterMapper.class.toString()\n                  + \" or custom mapper whose value type is Put.\");\n              System.exit(-1);\n            }\n            // No reducers. Just write straight to table. Call initTableReducerJob\n            // to set up the TableOutputFormat.\n            TableMapReduceUtil.initTableReducerJob(tableName.getNameAsString(), null,\n                job);\n            job.setNumReduceTasks(0);\n          }\n\n          TableMapReduceUtil.addDependencyJars(job);\n          TableMapReduceUtil.addDependencyJars(job.getConfiguration(),\n              com.google.common.base.Function.class /* Guava used by TsvParser */);\n      }\n    }\n    return job;\n  }","id":40762,"modified_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  protected static Job createSubmittableJob(Configuration conf, String[] args)\n      throws IOException, ClassNotFoundException {\n    Job job = null;\n    boolean isDryRun = conf.getBoolean(DRY_RUN_CONF_KEY, false);\n    try (Connection connection = ConnectionFactory.createConnection(conf)) {\n      try (Admin admin = connection.getAdmin()) {\n        // Support non-XML supported characters\n        // by re-encoding the passed separator as a Base64 string.\n        String actualSeparator = conf.get(SEPARATOR_CONF_KEY);\n        if (actualSeparator != null) {\n          conf.set(SEPARATOR_CONF_KEY,\n              Base64.encodeBytes(actualSeparator.getBytes()));\n        }\n\n        // See if a non-default Mapper was set\n        String mapperClassName = conf.get(MAPPER_CONF_KEY);\n        Class mapperClass =\n          mapperClassName != null ? Class.forName(mapperClassName) : DEFAULT_MAPPER;\n\n          TableName tableName = TableName.valueOf(args[0]);\n          Path inputDir = new Path(args[1]);\n          String jobName = conf.get(JOB_NAME_CONF_KEY,NAME + \"_\" + tableName.getNameAsString());\n          job = Job.getInstance(conf, jobName);\n          job.setJarByClass(mapperClass);\n          FileInputFormat.setInputPaths(job, inputDir);\n          job.setInputFormatClass(TextInputFormat.class);\n          job.setMapperClass(mapperClass);\n          job.setMapOutputKeyClass(ImmutableBytesWritable.class);\n          String hfileOutPath = conf.get(BULK_OUTPUT_CONF_KEY);\n          String[] columns = conf.getStrings(COLUMNS_CONF_KEY);\n          if(StringUtils.isNotEmpty(conf.get(CREDENTIALS_LOCATION))) {\n            String fileLoc = conf.get(CREDENTIALS_LOCATION);\n            Credentials cred = Credentials.readTokenStorageFile(new File(fileLoc), conf);\n            job.getCredentials().addAll(cred);\n          }\n\n          if (hfileOutPath != null) {\n            if (!admin.tableExists(tableName)) {\n              LOG.warn(format(\"Table '%s' does not exist.\", tableName));\n              if (\"yes\".equalsIgnoreCase(conf.get(CREATE_TABLE_CONF_KEY, \"yes\"))) {\n                // TODO: this is backwards. Instead of depending on the existence of a table,\n                // create a sane splits file for HFileOutputFormat based on data sampling.\n                createTable(admin, tableName, columns);\n                if (isDryRun) {\n                  LOG.warn(\"Dry run: Table will be deleted at end of dry run.\");\n                  dryRunTableCreated = true;\n                }\n              } else {\n                String errorMsg =\n                    format(\"Table '%s' does not exist and '%s' is set to no.\", tableName,\n                        CREATE_TABLE_CONF_KEY);\n                LOG.error(errorMsg);\n                throw new TableNotFoundException(errorMsg);\n              }\n            }\n            try (Table table = connection.getTable(tableName);\n                RegionLocator regionLocator = connection.getRegionLocator(tableName)) {\n              boolean noStrict = conf.getBoolean(NO_STRICT_COL_FAMILY, false);\n              // if no.strict is false then check column family\n              if(!noStrict) {\n                ArrayList<String> unmatchedFamilies = new ArrayList<String>();\n                Set<String> cfSet = getColumnFamilies(columns);\n                HTableDescriptor tDesc = table.getTableDescriptor();\n                for (String cf : cfSet) {\n                  if(tDesc.getFamily(Bytes.toBytes(cf)) == null) {\n                    unmatchedFamilies.add(cf);\n                  }\n                }\n                if(unmatchedFamilies.size() > 0) {\n                  ArrayList<String> familyNames = new ArrayList<String>();\n                  for (HColumnDescriptor family : table.getTableDescriptor().getFamilies()) {\n                    familyNames.add(family.getNameAsString());\n                  }\n                  String msg =\n                      \"Column Families \" + unmatchedFamilies + \" specified in \" + COLUMNS_CONF_KEY\n                      + \" does not match with any of the table \" + tableName\n                      + \" column families \" + familyNames + \".\\n\"\n                      + \"To disable column family check, use -D\" + NO_STRICT_COL_FAMILY\n                      + \"=true.\\n\";\n                  usage(msg);\n                  System.exit(-1);\n                }\n              }\n              if (mapperClass.equals(TsvImporterTextMapper.class)) {\n                job.setMapOutputValueClass(Text.class);\n                job.setReducerClass(TextSortReducer.class);\n              } else {\n                job.setMapOutputValueClass(Put.class);\n                job.setCombinerClass(PutCombiner.class);\n                job.setReducerClass(PutSortReducer.class);\n              }\n              if (!isDryRun) {\n                Path outputDir = new Path(hfileOutPath);\n                FileOutputFormat.setOutputPath(job, outputDir);\n                HFileOutputFormat2.configureIncrementalLoad(job, table.getTableDescriptor(),\n                    regionLocator);\n              }\n            }\n          } else {\n            if (!admin.tableExists(tableName)) {\n              String errorMsg = format(\"Table '%s' does not exist.\", tableName);\n              LOG.error(errorMsg);\n              throw new TableNotFoundException(errorMsg);\n            }\n            if (mapperClass.equals(TsvImporterTextMapper.class)) {\n              usage(TsvImporterTextMapper.class.toString()\n                  + \" should not be used for non bulkloading case. use \"\n                  + TsvImporterMapper.class.toString()\n                  + \" or custom mapper whose value type is Put.\");\n              System.exit(-1);\n            }\n            if (!isDryRun) {\n              // No reducers. Just write straight to table. Call initTableReducerJob\n              // to set up the TableOutputFormat.\n              TableMapReduceUtil.initTableReducerJob(tableName.getNameAsString(), null, job);\n            }\n            job.setNumReduceTasks(0);\n          }\n          if (isDryRun) {\n            job.setOutputFormatClass(NullOutputFormat.class);\n            job.getConfiguration().setStrings(\"io.serializations\",\n                job.getConfiguration().get(\"io.serializations\"),\n                MutationSerialization.class.getName(), ResultSerialization.class.getName(),\n                KeyValueSerialization.class.getName());\n          }\n          TableMapReduceUtil.addDependencyJars(job);\n          TableMapReduceUtil.addDependencyJars(job.getConfiguration(),\n              com.google.common.base.Function.class /* Guava used by TsvParser */);\n      }\n    }\n    return job;\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testGenerateAndLoad() throws Exception {\n    LOG.info(\"Running test testGenerateAndLoad.\");\n    TableName table = TableName.valueOf(NAME + \"-\" + UUID.randomUUID());\n    String cf = \"d\";\n    Path hfiles = new Path(\n        util.getDataTestDirOnTestFS(table.getNameAsString()), \"hfiles\");\n\n    String[] args = {\n        format(\"-D%s=%s\", ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles),\n        format(\"-D%s=HBASE_ROW_KEY,HBASE_TS_KEY,%s:c1,%s:c2\",\n          ImportTsv.COLUMNS_CONF_KEY, cf, cf),\n        // configure the test harness to NOT delete the HFiles after they're\n        // generated. We need those for doLoadIncrementalHFiles\n        format(\"-D%s=false\", TestImportTsv.DELETE_AFTER_LOAD_CONF),\n        table.getNameAsString()\n    };\n\n    // run the job, complete the load.\n    util.createTable(table, new String[]{cf});\n    Tool t = TestImportTsv.doMROnTableTest(util, cf, simple_tsv, args);\n    doLoadIncrementalHFiles(hfiles, table);\n\n    // validate post-conditions\n    validateDeletedPartitionsFile(t.getConf());\n\n    // clean up after ourselves.\n    util.deleteTable(table);\n    util.cleanupDataTestDirOnTestFS(table.getNameAsString());\n    LOG.info(\"testGenerateAndLoad completed successfully.\");\n  }","id":40763,"modified_method":"@Test\n  public void testGenerateAndLoad() throws Exception {\n    LOG.info(\"Running test testGenerateAndLoad.\");\n    TableName table = TableName.valueOf(NAME + \"-\" + UUID.randomUUID());\n    String cf = \"d\";\n    Path hfiles = new Path(\n        util.getDataTestDirOnTestFS(table.getNameAsString()), \"hfiles\");\n\n\n    Map<String, String> args = new HashMap<String, String>();\n    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());\n    args.put(ImportTsv.COLUMNS_CONF_KEY,\n        format(\"HBASE_ROW_KEY,HBASE_TS_KEY,%s:c1,%s:c2\", cf, cf));\n    // configure the test harness to NOT delete the HFiles after they're\n    // generated. We need those for doLoadIncrementalHFiles\n    args.put(TestImportTsv.DELETE_AFTER_LOAD_CONF, \"false\");\n\n    // run the job, complete the load.\n    util.createTable(table, new String[]{cf});\n    Tool t = TestImportTsv.doMROnTableTest(util, table.getNameAsString(), cf, simple_tsv, args);\n    doLoadIncrementalHFiles(hfiles, table);\n\n    // validate post-conditions\n    validateDeletedPartitionsFile(t.getConf());\n\n    // clean up after ourselves.\n    util.deleteTable(table);\n    util.cleanupDataTestDirOnTestFS(table.getNameAsString());\n    LOG.info(\"testGenerateAndLoad completed successfully.\");\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"protected static Tool doMROnTableTest(HBaseTestingUtility util, String family,\n      String data, String[] args) throws Exception {\n    return doMROnTableTest(util, family, data, args, 1);\n  }","id":40764,"modified_method":"protected static Tool doMROnTableTest(HBaseTestingUtility util, String table,\n      String family, String data, Map<String, String> args) throws Exception {\n    return doMROnTableTest(util, table, family, data, args, 1);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Run an ImportTsv job and perform basic validation on the results.\n   * Returns the ImportTsv <code>Tool<\/code> instance so that other tests can\n   * inspect it for further validation as necessary. This method is static to\n   * insure non-reliance on instance's util/conf facilities.\n   * @param args Any arguments to pass BEFORE inputFile path is appended.\n   * @return The Tool instance used to run the test.\n   */\n  protected static Tool doMROnTableTest(HBaseTestingUtility util, String family,\n      String data, String[] args, int valueMultiplier)\n  throws Exception {\n    String table = args[args.length - 1];\n    Configuration conf = new Configuration(util.getConfiguration());\n\n    // populate input file\n    FileSystem fs = FileSystem.get(conf);\n    Path inputPath = fs.makeQualified(new Path(util.getDataTestDirOnTestFS(table), \"input.dat\"));\n    FSDataOutputStream op = fs.create(inputPath, true);\n    if (data == null) {\n      data = \"KEY\\u001bVALUE1\\u001bVALUE2\\n\";\n    }\n    op.write(Bytes.toBytes(data));\n    op.close();\n    LOG.debug(String.format(\"Wrote test data to file: %s\", inputPath));\n\n    if (conf.getBoolean(FORCE_COMBINER_CONF, true)) {\n      LOG.debug(\"Forcing combiner.\");\n      conf.setInt(\"mapreduce.map.combine.minspills\", 1);\n    }\n\n    // run the import\n    List<String> argv = new ArrayList<String>(Arrays.asList(args));\n    argv.add(inputPath.toString());\n    Tool tool = new ImportTsv();\n    LOG.debug(\"Running ImportTsv with arguments: \" + argv);\n    assertEquals(0, ToolRunner.run(conf, tool, argv.toArray(args)));\n\n    // Perform basic validation. If the input args did not include\n    // ImportTsv.BULK_OUTPUT_CONF_KEY then validate data in the table.\n    // Otherwise, validate presence of hfiles.\n    boolean createdHFiles = false;\n    String outputPath = null;\n    for (String arg : argv) {\n      if (arg.contains(ImportTsv.BULK_OUTPUT_CONF_KEY)) {\n        createdHFiles = true;\n        // split '-Dfoo=bar' on '=' and keep 'bar'\n        outputPath = arg.split(\"=\")[1];\n        break;\n      }\n    }\n\n    if (createdHFiles)\n      validateHFiles(fs, outputPath, family);\n    else\n      validateTable(conf, TableName.valueOf(table), family, valueMultiplier);\n\n    if (conf.getBoolean(DELETE_AFTER_LOAD_CONF, true)) {\n      LOG.debug(\"Deleting test subdirectory\");\n      util.cleanupDataTestDirOnTestFS(table);\n    }\n    return tool;\n  }","id":40765,"modified_method":"/**\n   * Run an ImportTsv job and perform basic validation on the results.\n   * Returns the ImportTsv <code>Tool<\/code> instance so that other tests can\n   * inspect it for further validation as necessary. This method is static to\n   * insure non-reliance on instance's util/conf facilities.\n   * @param args Any arguments to pass BEFORE inputFile path is appended.\n   * @return The Tool instance used to run the test.\n   */\n  protected static Tool doMROnTableTest(HBaseTestingUtility util, String table,\n      String family, String data, Map<String, String> args, int valueMultiplier)\n  throws Exception {\n    Configuration conf = new Configuration(util.getConfiguration());\n\n    // populate input file\n    FileSystem fs = FileSystem.get(conf);\n    Path inputPath = fs.makeQualified(new Path(util.getDataTestDirOnTestFS(table), \"input.dat\"));\n    FSDataOutputStream op = fs.create(inputPath, true);\n    if (data == null) {\n      data = \"KEY\\u001bVALUE1\\u001bVALUE2\\n\";\n    }\n    op.write(Bytes.toBytes(data));\n    op.close();\n    LOG.debug(String.format(\"Wrote test data to file: %s\", inputPath));\n\n    if (conf.getBoolean(FORCE_COMBINER_CONF, true)) {\n      LOG.debug(\"Forcing combiner.\");\n      conf.setInt(\"mapreduce.map.combine.minspills\", 1);\n    }\n\n    // Build args array.\n    String[] argsArray = new String[args.size() + 2];\n    Iterator it = args.entrySet().iterator();\n    int i = 0;\n    while (it.hasNext()) {\n      Map.Entry pair = (Map.Entry) it.next();\n      argsArray[i] = \"-D\" + pair.getKey() + \"=\" + pair.getValue();\n      i++;\n    }\n    argsArray[i] = table;\n    argsArray[i + 1] = inputPath.toString();\n\n    // run the import\n    Tool tool = new ImportTsv();\n    LOG.debug(\"Running ImportTsv with arguments: \" + argsArray);\n    assertEquals(0, ToolRunner.run(conf, tool, argsArray));\n\n    // Perform basic validation. If the input args did not include\n    // ImportTsv.BULK_OUTPUT_CONF_KEY then validate data in the table.\n    // Otherwise, validate presence of hfiles.\n    boolean isDryRun = args.containsKey(ImportTsv.DRY_RUN_CONF_KEY) &&\n        \"true\".equalsIgnoreCase(args.get(ImportTsv.DRY_RUN_CONF_KEY));\n    if (args.containsKey(ImportTsv.BULK_OUTPUT_CONF_KEY)) {\n      if (isDryRun) {\n        assertFalse(String.format(\"Dry run mode, %s should not have been created.\",\n                 ImportTsv.BULK_OUTPUT_CONF_KEY),\n            fs.exists(new Path(ImportTsv.BULK_OUTPUT_CONF_KEY)));\n      } else {\n        validateHFiles(fs, args.get(ImportTsv.BULK_OUTPUT_CONF_KEY), family);\n      }\n    } else {\n      validateTable(conf, TableName.valueOf(table), family, valueMultiplier, isDryRun);\n    }\n\n    if (conf.getBoolean(DELETE_AFTER_LOAD_CONF, true)) {\n      LOG.debug(\"Deleting test subdirectory\");\n      util.cleanupDataTestDirOnTestFS(table);\n    }\n    return tool;\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testBulkOutputWithAnExistingTableNoStrictTrue() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.COLUMNS_CONF_KEY + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n        \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=\\u001b\",\n        \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + hfiles.toString(),\n        \"-D\" + ImportTsv.NO_STRICT_COL_FAMILY + \"=true\",\n        table\n    };\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(util, FAMILY, null, args, 3);\n    util.deleteTable(table);\n  }","id":40766,"modified_method":"@Test\n  public void testBulkOutputWithAnExistingTableNoStrictTrue() throws Exception {\n    util.createTable(TableName.valueOf(table), FAMILY);\n\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());\n    args.put(ImportTsv.NO_STRICT_COL_FAMILY, \"true\");\n    doMROnTableTest(null, 3);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Confirm ImportTsv via HFiles on fs.\n   */\n  private static void validateHFiles(FileSystem fs, String outputPath, String family)\n      throws IOException {\n\n    // validate number and content of output columns\n    LOG.debug(\"Validating HFiles.\");\n    Set<String> configFamilies = new HashSet<String>();\n    configFamilies.add(family);\n    Set<String> foundFamilies = new HashSet<String>();\n    for (FileStatus cfStatus : fs.listStatus(new Path(outputPath), new OutputFilesFilter())) {\n      String[] elements = cfStatus.getPath().toString().split(Path.SEPARATOR);\n      String cf = elements[elements.length - 1];\n      foundFamilies.add(cf);\n      assertTrue(\n        String.format(\n          \"HFile ouput contains a column family (%s) not present in input families (%s)\",\n          cf, configFamilies),\n          configFamilies.contains(cf));\n      for (FileStatus hfile : fs.listStatus(cfStatus.getPath())) {\n        assertTrue(\n          String.format(\"HFile %s appears to contain no data.\", hfile.getPath()),\n          hfile.getLen() > 0);\n      }\n    }\n  }","id":40767,"modified_method":"/**\n   * Confirm ImportTsv via HFiles on fs.\n   */\n  private static void validateHFiles(FileSystem fs, String outputPath, String family)\n      throws IOException {\n    // validate number and content of output columns\n    LOG.debug(\"Validating HFiles.\");\n    Set<String> configFamilies = new HashSet<String>();\n    configFamilies.add(family);\n    Set<String> foundFamilies = new HashSet<String>();\n    for (FileStatus cfStatus : fs.listStatus(new Path(outputPath), new OutputFilesFilter())) {\n      String[] elements = cfStatus.getPath().toString().split(Path.SEPARATOR);\n      String cf = elements[elements.length - 1];\n      foundFamilies.add(cf);\n      assertTrue(\n        String.format(\n          \"HFile output contains a column family (%s) not present in input families (%s)\",\n          cf, configFamilies),\n          configFamilies.contains(cf));\n      for (FileStatus hfile : fs.listStatus(cfStatus.getPath())) {\n        assertTrue(\n          String.format(\"HFile %s appears to contain no data.\", hfile.getPath()),\n          hfile.getLen() > 0);\n      }\n    }\n    assertTrue(String.format(\"HFile output does not contain the input family '%s'.\", family),\n        foundFamilies.contains(family));\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testBulkOutputWithoutAnExistingTable() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.COLUMNS_CONF_KEY + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n        \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=\\u001b\",\n        \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + hfiles.toString(),\n        table\n    };\n\n    doMROnTableTest(util, FAMILY, null, args, 3);\n    util.deleteTable(table);\n  }","id":40768,"modified_method":"@Test\n  public void testBulkOutputWithoutAnExistingTable() throws Exception {\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());\n\n    doMROnTableTest(null, 3);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testMROnTable() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n\n    // Prepare the arguments required for the test.\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.COLUMNS_CONF_KEY + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n        \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=\\u001b\",\n        table\n    };\n\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(util, FAMILY, null, args, 1);\n    util.deleteTable(table);\n  }","id":40769,"modified_method":"@Test\n  public void testMROnTable() throws Exception {\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(null, 1);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Confirm ImportTsv via data in online table.\n   */\n  private static void validateTable(Configuration conf, TableName tableName,\n      String family, int valueMultiplier) throws IOException {\n\n    LOG.debug(\"Validating table.\");\n    Connection connection = ConnectionFactory.createConnection(conf);\n    Table table = connection.getTable(tableName);\n    boolean verified = false;\n    long pause = conf.getLong(\"hbase.client.pause\", 5 * 1000);\n    int numRetries = conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 5);\n    for (int i = 0; i < numRetries; i++) {\n      try {\n        Scan scan = new Scan();\n        // Scan entire family.\n        scan.addFamily(Bytes.toBytes(family));\n        ResultScanner resScanner = table.getScanner(scan);\n        for (Result res : resScanner) {\n          assertTrue(res.size() == 2);\n          List<Cell> kvs = res.listCells();\n          assertTrue(CellUtil.matchingRow(kvs.get(0), Bytes.toBytes(\"KEY\")));\n          assertTrue(CellUtil.matchingRow(kvs.get(1), Bytes.toBytes(\"KEY\")));\n          assertTrue(CellUtil.matchingValue(kvs.get(0), Bytes.toBytes(\"VALUE\" + valueMultiplier)));\n          assertTrue(CellUtil.matchingValue(kvs.get(1), Bytes.toBytes(\"VALUE\" + 2 * valueMultiplier)));\n          // Only one result set is expected, so let it loop.\n        }\n        verified = true;\n        break;\n      } catch (NullPointerException e) {\n        // If here, a cell was empty. Presume its because updates came in\n        // after the scanner had been opened. Wait a while and retry.\n      }\n      try {\n        Thread.sleep(pause);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    table.close();\n    connection.close();\n    assertTrue(verified);\n  }","id":40770,"modified_method":"/**\n   * Confirm ImportTsv via data in online table.\n   */\n  private static void validateTable(Configuration conf, TableName tableName,\n      String family, int valueMultiplier, boolean isDryRun) throws IOException {\n\n    LOG.debug(\"Validating table.\");\n    Connection connection = ConnectionFactory.createConnection(conf);\n    Table table = connection.getTable(tableName);\n    boolean verified = false;\n    long pause = conf.getLong(\"hbase.client.pause\", 5 * 1000);\n    int numRetries = conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 5);\n    for (int i = 0; i < numRetries; i++) {\n      try {\n        Scan scan = new Scan();\n        // Scan entire family.\n        scan.addFamily(Bytes.toBytes(family));\n        ResultScanner resScanner = table.getScanner(scan);\n        int numRows = 0;\n        for (Result res : resScanner) {\n          numRows++;\n          assertEquals(2, res.size());\n          List<Cell> kvs = res.listCells();\n          assertTrue(CellUtil.matchingRow(kvs.get(0), Bytes.toBytes(\"KEY\")));\n          assertTrue(CellUtil.matchingRow(kvs.get(1), Bytes.toBytes(\"KEY\")));\n          assertTrue(CellUtil.matchingValue(kvs.get(0), Bytes.toBytes(\"VALUE\" + valueMultiplier)));\n          assertTrue(CellUtil.matchingValue(kvs.get(1), Bytes.toBytes(\"VALUE\" + 2 * valueMultiplier)));\n          // Only one result set is expected, so let it loop.\n        }\n        if (isDryRun) {\n          assertEquals(0, numRows);\n        } else {\n          assertEquals(1, numRows);\n        }\n        verified = true;\n        break;\n      } catch (NullPointerException e) {\n        // If here, a cell was empty. Presume its because updates came in\n        // after the scanner had been opened. Wait a while and retry.\n      }\n      try {\n        Thread.sleep(pause);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    table.close();\n    connection.close();\n    assertTrue(verified);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test(expected = TableNotFoundException.class)\n  public void testWithoutAnExistingTableAndCreateTableSetToNo() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n    String[] args =\n        new String[] { table, \"/inputFile\" };\n\n    Configuration conf = new Configuration(util.getConfiguration());\n    conf.set(ImportTsv.COLUMNS_CONF_KEY, \"HBASE_ROW_KEY,FAM:A\");\n    conf.set(ImportTsv.BULK_OUTPUT_CONF_KEY, \"/output\");\n    conf.set(ImportTsv.CREATE_TABLE_CONF_KEY, \"no\");\n    ImportTsv.createSubmittableJob(conf, args);\n  }","id":40771,"modified_method":"@Test\n  public void testWithoutAnExistingTableAndCreateTableSetToNo() throws Exception {\n    String[] args = new String[] { table, \"/inputFile\" };\n\n    Configuration conf = new Configuration(util.getConfiguration());\n    conf.set(ImportTsv.COLUMNS_CONF_KEY, \"HBASE_ROW_KEY,FAM:A\");\n    conf.set(ImportTsv.BULK_OUTPUT_CONF_KEY, \"/output\");\n    conf.set(ImportTsv.CREATE_TABLE_CONF_KEY, \"no\");\n    exception.expect(TableNotFoundException.class);\n    assertEquals(\"running test job configuration failed.\", 0,\n        ToolRunner.run(new Configuration(util.getConfiguration()), new ImportTsv() {\n              @Override public int run(String[] args) throws Exception {\n                createSubmittableJob(getConf(), args);\n                return 0;\n              }\n            }, args));\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testMROnTableWithTimestamp() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n\n    // Prepare the arguments required for the test.\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.COLUMNS_CONF_KEY\n            + \"=HBASE_ROW_KEY,HBASE_TS_KEY,FAM:A,FAM:B\",\n        \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=,\",\n        table\n    };\n    String data = \"KEY,1234,VALUE1,VALUE2\\n\";\n\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(util, FAMILY, data, args, 1);\n    util.deleteTable(table);\n  }","id":40772,"modified_method":"@Test\n  public void testMROnTableWithTimestamp() throws Exception {\n    util.createTable(TableName.valueOf(table), FAMILY);\n    args.put(ImportTsv.COLUMNS_CONF_KEY, \"HBASE_ROW_KEY,HBASE_TS_KEY,FAM:A,FAM:B\");\n    args.put(ImportTsv.SEPARATOR_CONF_KEY, \",\");\n    String data = \"KEY,1234,VALUE1,VALUE2\\n\";\n\n    doMROnTableTest(data, 1);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testMROnTableWithCustomMapper()\n  throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n\n    // Prepare the arguments required for the test.\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.MAPPER_CONF_KEY + \"=org.apache.hadoop.hbase.mapreduce.TsvImporterCustomTestMapper\",\n        table\n    };\n\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(util, FAMILY, null, args, 3);\n    util.deleteTable(table);\n  }","id":40773,"modified_method":"@Test\n  public void testMROnTableWithCustomMapper()\n  throws Exception {\n    util.createTable(TableName.valueOf(table), FAMILY);\n    args.put(ImportTsv.MAPPER_CONF_KEY,\n        \"org.apache.hadoop.hbase.mapreduce.TsvImporterCustomTestMapper\");\n\n    doMROnTableTest(null, 3);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testJobConfigurationsWithTsvImporterTextMapper() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n    Path bulkOutputPath = new Path(util.getDataTestDirOnTestFS(table),\"hfiles\");\n    String INPUT_FILE = \"InputFile1.csv\";\n    // Prepare the arguments required for the test.\n    String[] args =\n        new String[] {\n            \"-D\" + ImportTsv.MAPPER_CONF_KEY\n                + \"=org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper\",\n            \"-D\" + ImportTsv.COLUMNS_CONF_KEY\n                + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n            \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=,\",\n            \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + bulkOutputPath.toString(), table,\n            INPUT_FILE\n            };\n    assertEquals(\"running test job configuration failed.\", 0, ToolRunner.run(\n        new Configuration(util.getConfiguration()),\n        new ImportTsv() {\n          @Override\n          public int run(String[] args) throws Exception {\n            Job job = createSubmittableJob(getConf(), args);\n            assertTrue(job.getMapperClass().equals(TsvImporterTextMapper.class));\n            assertTrue(job.getReducerClass().equals(TextSortReducer.class));\n            assertTrue(job.getMapOutputValueClass().equals(Text.class));\n            return 0;\n          }\n        }, args));\n  }","id":40774,"modified_method":"@Test\n  public void testJobConfigurationsWithTsvImporterTextMapper() throws Exception {\n    Path bulkOutputPath = new Path(util.getDataTestDirOnTestFS(table),\"hfiles\");\n    String INPUT_FILE = \"InputFile1.csv\";\n    // Prepare the arguments required for the test.\n    String[] args =\n        new String[] {\n            \"-D\" + ImportTsv.MAPPER_CONF_KEY\n                + \"=org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper\",\n            \"-D\" + ImportTsv.COLUMNS_CONF_KEY\n                + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n            \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=,\",\n            \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + bulkOutputPath.toString(), table,\n            INPUT_FILE\n            };\n    assertEquals(\"running test job configuration failed.\", 0, ToolRunner.run(\n        new Configuration(util.getConfiguration()),\n        new ImportTsv() {\n          @Override\n          public int run(String[] args) throws Exception {\n            Job job = createSubmittableJob(getConf(), args);\n            assertTrue(job.getMapperClass().equals(TsvImporterTextMapper.class));\n            assertTrue(job.getReducerClass().equals(TextSortReducer.class));\n            assertTrue(job.getMapOutputValueClass().equals(Text.class));\n            return 0;\n          }\n        }, args));\n    // Delete table created by createSubmittableJob.\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testBulkOutputWithAnExistingTable() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    String[] args = new String[] {\n        \"-D\" + ImportTsv.COLUMNS_CONF_KEY + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n        \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=\\u001b\",\n        \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + hfiles.toString(),\n        table\n    };\n\n    util.createTable(TableName.valueOf(table), FAMILY);\n    doMROnTableTest(util, FAMILY, null, args, 3);\n    util.deleteTable(table);\n  }","id":40775,"modified_method":"@Test\n  public void testBulkOutputWithAnExistingTable() throws Exception {\n    util.createTable(TableName.valueOf(table), FAMILY);\n\n    // Prepare the arguments required for the test.\n    Path hfiles = new Path(util.getDataTestDirOnTestFS(table), \"hfiles\");\n    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, hfiles.toString());\n\n    doMROnTableTest(null, 3);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test(expected = TableNotFoundException.class)\n  public void testMRWithoutAnExistingTable() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n    String[] args =\n        new String[] { table, \"/inputFile\" };\n\n    Configuration conf = new Configuration(util.getConfiguration());\n    ImportTsv.createSubmittableJob(conf, args);\n  }","id":40776,"modified_method":"@Test\n  public void testMRWithoutAnExistingTable() throws Exception {\n    String[] args =\n        new String[] { table, \"/inputFile\" };\n\n    exception.expect(TableNotFoundException.class);\n    assertEquals(\"running test job configuration failed.\", 0, ToolRunner.run(\n        new Configuration(util.getConfiguration()),\n        new ImportTsv() {\n          @Override\n          public int run(String[] args) throws Exception {\n            createSubmittableJob(getConf(), args);\n            return 0;\n          }\n        }, args));\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testBulkOutputWithTsvImporterTextMapper() throws Exception {\n    String table = \"test-\" + UUID.randomUUID();\n    String FAMILY = \"FAM\";\n    Path bulkOutputPath = new Path(util.getDataTestDirOnTestFS(table),\"hfiles\");\n    // Prepare the arguments required for the test.\n    String[] args =\n        new String[] {\n            \"-D\" + ImportTsv.MAPPER_CONF_KEY\n                + \"=org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper\",\n            \"-D\" + ImportTsv.COLUMNS_CONF_KEY\n                + \"=HBASE_ROW_KEY,FAM:A,FAM:B\",\n            \"-D\" + ImportTsv.SEPARATOR_CONF_KEY + \"=\\u001b\",\n            \"-D\" + ImportTsv.BULK_OUTPUT_CONF_KEY + \"=\" + bulkOutputPath.toString(), table \n            };\n    String data = \"KEY\\u001bVALUE4\\u001bVALUE8\\n\";\n    doMROnTableTest(util, FAMILY, data, args, 4);\n  }","id":40777,"modified_method":"@Test\n  public void testBulkOutputWithTsvImporterTextMapper() throws Exception {\n    Path bulkOutputPath = new Path(util.getDataTestDirOnTestFS(table),\"hfiles\");\n    args.put(ImportTsv.MAPPER_CONF_KEY, \"org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper\");\n    args.put(ImportTsv.BULK_OUTPUT_CONF_KEY, bulkOutputPath.toString());\n    String data = \"KEY\\u001bVALUE4\\u001bVALUE8\\n\";\n    doMROnTableTest(data, 4);\n    util.deleteTable(table);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Convert a line of TSV text into an HBase table row.\n   */\n  @Override\n  public void map(LongWritable offset, Text value,\n    Context context)\n  throws IOException {\n    byte[] lineBytes = value.getBytes();\n\n    try {\n      ImportTsv.TsvParser.ParsedLine parsed = parser.parse(\n          lineBytes, value.getLength());\n      ImmutableBytesWritable rowKey =\n        new ImmutableBytesWritable(lineBytes,\n            parsed.getRowKeyOffset(),\n            parsed.getRowKeyLength());\n      // Retrieve timestamp if exists\n      ts = parsed.getTimestamp(ts);\n      cellVisibilityExpr = parsed.getCellVisibility();\n      ttl = parsed.getCellTTL();\n\n      Put put = new Put(rowKey.copyBytes());\n      for (int i = 0; i < parsed.getColumnCount(); i++) {\n        if (i == parser.getRowKeyColumnIndex() || i == parser.getTimestampKeyColumnIndex()\n            || i == parser.getAttributesKeyColumnIndex() || i == parser.getCellVisibilityColumnIndex()\n            || i == parser.getCellTTLColumnIndex()) {\n          continue;\n        }\n        populatePut(lineBytes, parsed, put, i);\n      }\n      context.write(rowKey, put);\n    } catch (ImportTsv.TsvParser.BadTsvLineException badLine) {\n      if (skipBadLines) {\n        System.err.println(\n            \"Bad line at offset: \" + offset.get() + \":\\n\" +\n            badLine.getMessage());\n        incrementBadLineCount(1);\n        return;\n      } else {\n        throw new IOException(badLine);\n      }\n    } catch (IllegalArgumentException e) {\n      if (skipBadLines) {\n        System.err.println(\n            \"Bad line at offset: \" + offset.get() + \":\\n\" +\n            e.getMessage());\n        incrementBadLineCount(1);\n        return;\n      } else {\n        throw new IOException(e);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","id":40778,"modified_method":"/**\n   * Convert a line of TSV text into an HBase table row.\n   */\n  @Override\n  public void map(LongWritable offset, Text value,\n    Context context)\n  throws IOException {\n    byte[] lineBytes = value.getBytes();\n\n    try {\n      ImportTsv.TsvParser.ParsedLine parsed = parser.parse(\n          lineBytes, value.getLength());\n      ImmutableBytesWritable rowKey =\n        new ImmutableBytesWritable(lineBytes,\n            parsed.getRowKeyOffset(),\n            parsed.getRowKeyLength());\n      // Retrieve timestamp if exists\n      ts = parsed.getTimestamp(ts);\n      cellVisibilityExpr = parsed.getCellVisibility();\n      ttl = parsed.getCellTTL();\n\n      Put put = new Put(rowKey.copyBytes());\n      for (int i = 0; i < parsed.getColumnCount(); i++) {\n        if (i == parser.getRowKeyColumnIndex() || i == parser.getTimestampKeyColumnIndex()\n            || i == parser.getAttributesKeyColumnIndex() || i == parser.getCellVisibilityColumnIndex()\n            || i == parser.getCellTTLColumnIndex()) {\n          continue;\n        }\n        populatePut(lineBytes, parsed, put, i);\n      }\n      context.write(rowKey, put);\n    } catch (ImportTsv.TsvParser.BadTsvLineException|IllegalArgumentException badLine) {\n      if (logBadLines) {\n        System.err.println(value);\n      }\n      System.err.println(\"Bad line at offset: \" + offset.get() + \":\\n\" + badLine.getMessage());\n      if (skipBadLines) {\n        incrementBadLineCount(1);\n        return;\n      }\n      throw new IOException(badLine);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Handles common parameter initialization that a subclass might want to leverage.\n   * @param context\n   */\n  protected void doSetup(Context context) {\n    Configuration conf = context.getConfiguration();\n\n    // If a custom separator has been used,\n    // decode it back from Base64 encoding.\n    separator = conf.get(ImportTsv.SEPARATOR_CONF_KEY);\n    if (separator == null) {\n      separator = ImportTsv.DEFAULT_SEPARATOR;\n    } else {\n      separator = new String(Base64.decode(separator));\n    }\n    // Should never get 0 as we are setting this to a valid value in job\n    // configuration.\n    ts = conf.getLong(ImportTsv.TIMESTAMP_CONF_KEY, 0);\n\n    skipBadLines = context.getConfiguration().getBoolean(\n        ImportTsv.SKIP_LINES_CONF_KEY, true);\n    badLineCount = context.getCounter(\"ImportTsv\", \"Bad Lines\");\n    hfileOutPath = conf.get(ImportTsv.BULK_OUTPUT_CONF_KEY);\n  }","id":40779,"modified_method":"/**\n   * Handles common parameter initialization that a subclass might want to leverage.\n   * @param context\n   */\n  protected void doSetup(Context context) {\n    Configuration conf = context.getConfiguration();\n\n    // If a custom separator has been used,\n    // decode it back from Base64 encoding.\n    separator = conf.get(ImportTsv.SEPARATOR_CONF_KEY);\n    if (separator == null) {\n      separator = ImportTsv.DEFAULT_SEPARATOR;\n    } else {\n      separator = new String(Base64.decode(separator));\n    }\n    // Should never get 0 as we are setting this to a valid value in job\n    // configuration.\n    ts = conf.getLong(ImportTsv.TIMESTAMP_CONF_KEY, 0);\n\n    skipBadLines = context.getConfiguration().getBoolean(\n        ImportTsv.SKIP_LINES_CONF_KEY, true);\n    badLineCount = context.getCounter(\"ImportTsv\", \"Bad Lines\");\n    logBadLines = context.getConfiguration().getBoolean(ImportTsv.LOG_BAD_LINES_CONF_KEY, false);\n    hfileOutPath = conf.get(ImportTsv.BULK_OUTPUT_CONF_KEY);\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Convert a line of TSV text into an HBase table row.\n   */\n  @Override\n  public void map(LongWritable offset, Text value, Context context) throws IOException {\n    try {\n      Pair<Integer,Integer> rowKeyOffests = parser.parseRowKey(value.getBytes(), value.getLength());\n      ImmutableBytesWritable rowKey = new ImmutableBytesWritable(\n          value.getBytes(), rowKeyOffests.getFirst(), rowKeyOffests.getSecond());\n      context.write(rowKey, value);\n    } catch (ImportTsv.TsvParser.BadTsvLineException badLine) {\n      if (skipBadLines) {\n        System.err.println(\"Bad line at offset: \" + offset.get() + \":\\n\" + badLine.getMessage());\n        incrementBadLineCount(1);\n        return;\n      } \n      throw new IOException(badLine);\n    } catch (IllegalArgumentException e) {\n      if (skipBadLines) {\n        System.err.println(\"Bad line at offset: \" + offset.get() + \":\\n\" + e.getMessage());\n        incrementBadLineCount(1);\n        return;\n      } else {\n        throw new IOException(e);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n      Thread.currentThread().interrupt();\n    } \n  }","id":40780,"modified_method":"/**\n   * Convert a line of TSV text into an HBase table row.\n   */\n  @Override\n  public void map(LongWritable offset, Text value, Context context) throws IOException {\n    try {\n      Pair<Integer,Integer> rowKeyOffests = parser.parseRowKey(value.getBytes(), value.getLength());\n      ImmutableBytesWritable rowKey = new ImmutableBytesWritable(\n          value.getBytes(), rowKeyOffests.getFirst(), rowKeyOffests.getSecond());\n      context.write(rowKey, value);\n    } catch (ImportTsv.TsvParser.BadTsvLineException|IllegalArgumentException badLine) {\n      if (logBadLines) {\n        System.err.println(value);\n      }\n      System.err.println(\"Bad line at offset: \" + offset.get() + \":\\n\" + badLine.getMessage());\n      if (skipBadLines) {\n        incrementBadLineCount(1);\n        return;\n      } \n      throw new IOException(badLine);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n      Thread.currentThread().interrupt();\n    } \n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Handles common parameter initialization that a subclass might want to leverage.\n   * @param context\n   */\n  protected void doSetup(Context context) {\n    Configuration conf = context.getConfiguration();\n\n    // If a custom separator has been used,\n    // decode it back from Base64 encoding.\n    separator = conf.get(ImportTsv.SEPARATOR_CONF_KEY);\n    if (separator == null) {\n      separator = ImportTsv.DEFAULT_SEPARATOR;\n    } else {\n      separator = new String(Base64.decode(separator));\n    }\n\n    skipBadLines = context.getConfiguration().getBoolean(ImportTsv.SKIP_LINES_CONF_KEY, true);\n    badLineCount = context.getCounter(\"ImportTsv\", \"Bad Lines\");\n  }","id":40781,"modified_method":"/**\n   * Handles common parameter initialization that a subclass might want to leverage.\n   * @param context\n   */\n  protected void doSetup(Context context) {\n    Configuration conf = context.getConfiguration();\n\n    // If a custom separator has been used,\n    // decode it back from Base64 encoding.\n    separator = conf.get(ImportTsv.SEPARATOR_CONF_KEY);\n    if (separator == null) {\n      separator = ImportTsv.DEFAULT_SEPARATOR;\n    } else {\n      separator = new String(Base64.decode(separator));\n    }\n\n    skipBadLines = context.getConfiguration().getBoolean(ImportTsv.SKIP_LINES_CONF_KEY, true);\n    logBadLines = context.getConfiguration().getBoolean(ImportTsv.LOG_BAD_LINES_CONF_KEY, false);\n    badLineCount = context.getCounter(\"ImportTsv\", \"Bad Lines\");\n  }","commit_id":"e6ed79219966ce0dac3bc748261fce9478aa7550","url":"https://github.com/apache/hbase"},{"original_method":"protected Integer getPortIncrement() {\n        return (Integer) entity.getAttribute(JBoss7Server.PORT_INCREMENT);\n    }","id":40782,"modified_method":"protected Integer getPortIncrement() {\n        return entity.getAttribute(JBoss7Server.PORT_INCREMENT);\n    }","commit_id":"f78ce49c9bb7e123a5d2b1086ab511d5e6592887","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Integer getManagementPort() {\n        return entity.getAttribute(JBoss7Server.MANAGEMENT_PORT);\n    }","id":40783,"modified_method":"/**\n     * @deprecated since 0.5; use getManagementHttpPort() instead\n     */\n    protected Integer getManagementPort() {\n        return getManagementHttpPort();\n    }","commit_id":"f78ce49c9bb7e123a5d2b1086ab511d5e6592887","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * AS7 config notes and TODOs:\n     * We're using the http management interface on port managementPort\n     * We're not using any JMX.\n     * - AS 7 simply doesn't boot with Sun JMX enabled (https://issues.jboss.org/browse/JBAS-7427)\n     * - 7.1 onwards uses Remoting 3, which we haven't configured\n     * We're completely disabling security on the management interface.\n     * - In the future we probably want to use the as7/bin/add-user.sh script using config keys for user and password\n     * - Or we could create our own security realm and use that.\n     * We disable the root welcome page, since we can't deploy our own root otherwise\n     * We bind all interfaces to entity.hostname, rather than 127.0.0.1.\n     */\n    @Override\n    public void customize() {\n        Map ports = MutableMap.of(\"httpPort\", getHttpPort(), \"managementPort\", getManagementPort(), \"managementNativePort\",\n                getManagementNativePort());\n\n        NetworkUtils.checkPortsValid(ports);\n        String hostname = entity.getAttribute(SoftwareProcessEntity.HOSTNAME);\n        Preconditions.checkNotNull(hostname, \"AS 7 entity must set hostname otherwise server will only be visible on localhost\");\n        newScript(CUSTOMIZING).\n                body.append(\n                format(\"cp -r %s/jboss-as-%s/%s . || exit $!\", getInstallDir(), getVersion(), SERVER_TYPE),\n                format(\"cd %s/%s/configuration/\", getRunDir(), SERVER_TYPE),\n                format(\"cp standalone.xml %s\", CONFIG_FILE),\n                format(\"sed -i.bk 's/8080/%s/' %s\", getHttpPort(), CONFIG_FILE),\n                format(\"sed -i.bk 's/9990/%s/' %s\", getManagementPort(), CONFIG_FILE),\n                format(\"sed -i.bk 's/9999/%s/' %s\", getManagementNativePort(), CONFIG_FILE),\n                format(\"sed -i.bk 's/port-offset:0/port-offset:%s/' %s\", getPortIncrement(), CONFIG_FILE),\n                format(\"sed -i.bk 's/enable-welcome-root=\\\"true\\\"/enable-welcome-root=\\\"false\\\"/' %s\", CONFIG_FILE),\n\n                // Disable Management security (!) by deleting the security-realm attribute\n                format(\"sed -i.bk 's/http-interface security-realm=\\\"ManagementRealm\\\"/http-interface/' %s\", CONFIG_FILE),\n\n                // Increase deployment timeout to ten minutes\n                format(\"sed -i.bk 's/\\\\(path=\\\"deployments\\\"\\\\)/\\\\1 deployment-timeout=\\\"600\\\"/' %s\", CONFIG_FILE),\n\n                // Bind interfaces -- to all (does this work?)\n                format(\"sed -i.bk 's/\\\\(inet-address value=.*\\\\)127.0.0.1/\\\\1%s/' %s\", entity.getConfig(JBoss7Server.BIND_ADDRESS), CONFIG_FILE)\n        ).execute();\n        ((JBoss7Server) entity).deployInitialWars();\n    }","id":40784,"modified_method":"/**\n     * AS7 config notes and TODOs:\n     * We're using the http management interface on port managementPort\n     * We're not using any JMX.\n     * - AS 7 simply doesn't boot with Sun JMX enabled (https://issues.jboss.org/browse/JBAS-7427)\n     * - 7.1 onwards uses Remoting 3, which we haven't configured\n     * - We have generic support for jmxmp, which one could configure\n     * We're completely disabling security on the management interface.\n     * - In the future we probably want to use the as7/bin/add-user.sh script using config keys for user and password\n     * - Or we could create our own security realm and use that.\n     * We disable the root welcome page, since we can't deploy our own root otherwise\n     * We bind all interfaces to entity.hostname, rather than 127.0.0.1.\n     */\n    @Override\n    public void customize() {\n        // Check that ports are all configured\n        Map<String,Integer> ports = MutableMap.<String,Integer>builder()\n                .put(\"managementHttpPort\", getManagementHttpPort()) \n                .put(\"managementHttpsPort\", getManagementHttpsPort())\n                .put(\"managementNativePort\", getManagementNativePort())\n                .build();\n        if (isProtocolEnabled(\"HTTP\")) {\n            ports.put(\"httpPort\", getHttpPort());\n        }\n        if (isProtocolEnabled(\"HTTPS\")) {\n            ports.put(\"httpsPort\", getHttpsPort());\n        }\n        NetworkUtils.checkPortsValid(ports);\n\n        // Check hostname is defined\n        String hostname = entity.getAttribute(SoftwareProcessEntity.HOSTNAME);\n        Preconditions.checkNotNull(hostname, \"AS 7 entity must set hostname otherwise server will only be visible on localhost\");\n        \n        // Copy the install files to the run-dir\n        newScript(CUSTOMIZING)\n                .body.append(format(\"cp -r %s/jboss-as-%s/%s . || exit $!\", getInstallDir(), getVersion(), SERVER_TYPE))\n                .execute();\n\n        // Copy the keystore across, if there is one\n        String destinationKeystorePath = getRunDir()+\"/\"+\".keystore\";\n        if (isProtocolEnabled(\"HTTPS\")) {\n            String keystoreUrl = getSslKeystoreUrl();\n            if (keystoreUrl == null) {\n                throw new NullPointerException(\"keystore URL must be specified if using HTTPS for \"+entity);\n            }\n            InputStream keystoreStream = new ResourceUtils(this).getResourceFromUrl(keystoreUrl);\n            getMachine().copyTo(keystoreStream, destinationKeystorePath);\n        }\n\n        // Copy the configuration file across\n        String configFileContents = getConfigFileContents(getTemplateConfigurationUrl(), destinationKeystorePath);\n        String destinationConfigFile = format(\"%s/%s/configuration/%s\", getRunDir(), SERVER_TYPE, CONFIG_FILE);\n        getMachine().copyTo(new ByteArrayInputStream(configFileContents.getBytes()), destinationConfigFile);\n        \n        // Copy the initial wars to the deploys directory\n        ((JBoss7Server) entity).deployInitialWars();\n    }","commit_id":"f78ce49c9bb7e123a5d2b1086ab511d5e6592887","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n  public void testSmallSet() {\n    String content = \"name,surname,id\";\n    for (int i = 0; i < names.length; ++i)\n      content += \"\\n\" + names[i] + \",\" + surnames[i] + \",\" + i;\n    getProcessor(\"{source: { content: { value: '\" + content + \"' } }, extractor : { row: {} }, transformers: [{ csv: {} }], loader: { test: {} } }\").execute();\n\n    assertEquals(getResult().size(), names.length);\n\n    int i = 0;\n    for (ODocument doc : getResult()) {\n      assertEquals(3, doc.fields());\n      assertEquals(names[i], doc.field(\"name\"));\n      assertEquals(surnames[i], doc.field(\"surname\"));\n      assertEquals(i, doc.field(\"id\"));\n      i++;\n    }\n  }","id":40785,"modified_method":"@Test\n  public void testSmallSet() {\n    String content = \"name,surname,id\";\n    for (int i = 0; i < names.length; ++i)\n      content += \"\\n\" + names[i] + \",\" + surnames[i] + \",\" + i;\n    process(\"{source: { content: { value: '\" + content + \"' } }, extractor : { row: {} }, transformers: [{ csv: {} }], loader: { test: {} } }\");\n\n    assertEquals(getResult().size(), names.length);\n\n    int i = 0;\n    for (ODocument doc : getResult()) {\n      assertEquals(3, doc.fields());\n      assertEquals(names[i], doc.field(\"name\"));\n      assertEquals(surnames[i], doc.field(\"surname\"));\n      assertEquals(i, doc.field(\"id\"));\n      i++;\n    }\n  }","commit_id":"c6555ef08c91d7bd53118da1b5ccf768214188c8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testOneObject() {\n    getProcessor(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }], loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(2, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n  }","id":40786,"modified_method":"@Test\n  public void testOneObject() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }], loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(2, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n  }","commit_id":"c6555ef08c91d7bd53118da1b5ccf768214188c8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testEmpty() {\n    getProcessor(\"{source: { content: { value: '' }  }, extractor : { json: {} }, loader: { test: {} } }\").execute();\n    assertEquals(0, getResult().size());\n  }","id":40787,"modified_method":"@Test\n  public void testEmpty() {\n    String cfgJson = \"{source: { content: { value: '' }  }, extractor : { json: {} }, loader: { test: {} } }\";\n    process(cfgJson);\n    assertEquals(0, getResult().size());\n  }","commit_id":"c6555ef08c91d7bd53118da1b5ccf768214188c8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testNotLightweightEdge() {\n    getProcessor(\n        \"{source: { content: { value: 'name,surname,friend\\nJay,Miner,Luca' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'V1'}}, {edge:{class:'Friend',joinFieldName:'friend',lookup:'V2.name'}},\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\")\n        .execute();\n\n    assertEquals(1, graph.countVertices(\"V1\"));\n    assertEquals(1, graph.countVertices(\"V2\"));\n    assertEquals(1, graph.countEdges(\"Friend\"));\n  }","id":40788,"modified_method":"@Test\n  public void testNotLightweightEdge() {\n    process(\"{source: { content: { value: 'name,surname,friend\\nJay,Miner,Luca' } }, extractor : { row: {} },\"\n        + \" transformers: [{csv: {}}, {vertex: {class:'V1'}}, {edge:{class:'Friend',joinFieldName:'friend',lookup:'V2.name'}},\"\n        + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\");\n\n    assertEquals(1, graph.countVertices(\"V1\"));\n    assertEquals(1, graph.countVertices(\"V2\"));\n    assertEquals(1, graph.countEdges(\"Friend\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testValue() {\n    getProcessor(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'test', value: 33}}], loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(3, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n    assertEquals(33, doc.field(\"test\"));\n  }","id":40789,"modified_method":"@Test\n  public void testValue() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'test', value: 33}}], loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(3, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n    assertEquals(33, doc.field(\"test\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testRemove() {\n    getProcessor(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'surname', operation: 'remove'}}], loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(1, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n  }","id":40790,"modified_method":"@Test\n  public void testRemove() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'surname', operation: 'remove'}}], loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(1, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testSave() {\n    getProcessor(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field:{fieldName:'@class', value:'Test'}}, {field:{ fieldName:'test', value: 33, save: true}}], loader: { orientdb: { dbURL: 'memory:ETLBaseTest' } } }\").execute();\n    assertEquals(1, graph.countVertices(\"Test\"));\n  }","id":40791,"modified_method":"@Test\n  public void testSave() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field:{fieldName:'@class', value:'Test'}}, {field:{ fieldName:'test', value: 33, save: true}}], loader: { orientdb: { dbURL: 'memory:ETLBaseTest' } } }\");\n    assertEquals(1, graph.countVertices(\"Test\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testExpression() {\n    getProcessor(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'test', expression: 'surname'}}], loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(3, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n    assertEquals(\"Miner\", doc.field(\"test\"));\n  }","id":40792,"modified_method":"@Test\n  public void testExpression() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner' } }, extractor : { row: {} }, transformers: [{ csv: {} }, {field: {fieldName:'test', expression: 'surname'}}], loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n\n    ODocument doc = getResult().get(0);\n    assertEquals(3, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n    assertEquals(\"Miner\", doc.field(\"test\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testSkipNever() {\n    getProcessor(\n        \"{source: { content: { value: 'name,surname\\nJay,Miner\\nTest,Test' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'V'}}, {flow:{operation:'skip',if: 'name = \\'Jay\\''}},{field:{fieldName:'name', value:'3'}}\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph'} } }\").execute();\n\n    assertEquals(2, graph.countVertices(\"V\"));\n\n    Iterator<Vertex> it = graph.getVertices().iterator();\n\n    Vertex v1 = it.next();\n    Object value1 = v1.getProperty(\"name\");\n    assertEquals(\"Jay\", value1);\n\n    Vertex v2 = it.next();\n    Object value2 = v2.getProperty(\"name\");\n    assertEquals(\"3\", value2);\n\n    graph.command(new OCommandSQL(\"delete vertex V\")).execute();\n  }","id":40793,"modified_method":"@Test\n  public void testSkipNever() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner\\nTest,Test' } }, extractor : { row: {} },\"\n        + \" transformers: [{csv: {}}, {vertex: {class:'V'}}, {flow:{operation:'skip',if: 'name = \\'Jay\\''}},{field:{fieldName:'name', value:'3'}}\"\n        + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph'} } }\");\n\n    assertEquals(2, graph.countVertices(\"V\"));\n\n    Iterator<Vertex> it = graph.getVertices().iterator();\n\n    Vertex v1 = it.next();\n    Object value1 = v1.getProperty(\"name\");\n    assertEquals(\"Jay\", value1);\n\n    Vertex v2 = it.next();\n    Object value2 = v2.getProperty(\"name\");\n    assertEquals(\"3\", value2);\n\n    graph.command(new OCommandSQL(\"delete vertex V\")).execute();\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testSkip() {\n    getProcessor(\n        \"{source: { content: { value: 'name,surname\\nJay,Miner\\nJay,Test' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'V'}}, {flow:{operation:'skip',if: 'name <> \\'Jay\\''}},{field:{fieldName:'name', value:'3'}}\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph' } } }\").execute();\n\n    assertEquals(2, graph.countVertices(\"V\"));\n\n    Iterator<Vertex> it = graph.getVertices().iterator();\n\n    Vertex v1 = it.next();\n    Object value1 = v1.getProperty(\"name\");\n    assertEquals(\"3\", value1);\n\n    Vertex v2 = it.next();\n    Object value2 = v2.getProperty(\"name\");\n    assertEquals(\"3\", value2);\n\n    graph.command(new OCommandSQL(\"delete vertex V\")).execute();\n  }","id":40794,"modified_method":"@Test\n  public void testSkip() {\n    process(\"{source: { content: { value: 'name,surname\\nJay,Miner\\nJay,Test' } }, extractor : { row: {} },\"\n        + \" transformers: [{csv: {}}, {vertex: {class:'V'}}, {flow:{operation:'skip',if: 'name <> \\'Jay\\''}},{field:{fieldName:'name', value:'3'}}\"\n        + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph' } } }\");\n\n    assertEquals(2, graph.countVertices(\"V\"));\n\n    Iterator<Vertex> it = graph.getVertices().iterator();\n\n    Vertex v1 = it.next();\n    Object value1 = v1.getProperty(\"name\");\n    assertEquals(\"3\", value1);\n\n    Vertex v2 = it.next();\n    Object value2 = v2.getProperty(\"name\");\n    assertEquals(\"3\", value2);\n\n    graph.command(new OCommandSQL(\"delete vertex V\")).execute();\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testEmptyCollection() {\n    getProcessor(\"{source: { content: { value: [] }  }, extractor : { json: {} }, loader: { test: {} } }\").execute();\n    assertEquals(0, getResult().size());\n  }","id":40795,"modified_method":"@Test\n  public void testEmptyCollection() {\n    process(\"{source: { content: { value: [] }  }, extractor : { json: {} }, loader: { test: {} } }\");\n    assertEquals(0, getResult().size());\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testOneObject() {\n    getProcessor(\"{source: { content: { value: { name: 'Jay', surname: 'Miner' } } }, extractor : { json: {} }, loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(2, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n  }","id":40796,"modified_method":"@Test\n  public void testOneObject() {\n    process(\"{source: { content: { value: { name: 'Jay', surname: 'Miner' } } }, extractor : { json: {} }, loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(2, doc.fields());\n    assertEquals(\"Jay\", doc.field(\"name\"));\n    assertEquals(\"Miner\", doc.field(\"surname\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testEmptyObject() {\n    getProcessor(\"{source: { content: { value: {} }  }, extractor : { json: {} }, loader: { test: {} } }\").execute();\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(0, doc.fields());\n  }","id":40797,"modified_method":"@Test\n  public void testEmptyObject() {\n    process(\"{source: { content: { value: {} }  }, extractor : { json: {} }, loader: { test: {} } }\");\n    assertEquals(1, getResult().size());\n    ODocument doc = getResult().get(0);\n    assertEquals(0, doc.fields());\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testSmallSet() {\n    String content = \"\";\n    for (int i = 0; i < names.length; ++i) {\n      if (i > 0)\n        content += \",\";\n      content += \"{name:'\" + names[i] + \"',surname:'\" + surnames[i] + \"',id:\" + i + \"}\";\n    }\n\n    getProcessor(\"{source: { content: { value: [\" + content + \"] } }, extractor : { json: {} }, loader: { test: {} } }\").execute();\n\n    assertEquals(getResult().size(), names.length);\n\n    int i = 0;\n    for (ODocument doc : getResult()) {\n      assertEquals(3, doc.fields());\n      assertEquals(names[i], doc.field(\"name\"));\n      assertEquals(surnames[i], doc.field(\"surname\"));\n      assertEquals(i, doc.field(\"id\"));\n      i++;\n    }\n  }","id":40798,"modified_method":"@Test\n  public void testSmallSet() {\n    String content = \"\";\n    for (int i = 0; i < names.length; ++i) {\n      if (i > 0)\n        content += \",\";\n      content += \"{name:'\" + names[i] + \"',surname:'\" + surnames[i] + \"',id:\" + i + \"}\";\n    }\n\n    process(\"{source: { content: { value: [\" + content + \"] } }, extractor : { json: {} }, loader: { test: {} } }\");\n\n    assertEquals(getResult().size(), names.length);\n\n    int i = 0;\n    for (ODocument doc : getResult()) {\n      assertEquals(3, doc.fields());\n      assertEquals(names[i], doc.field(\"name\"));\n      assertEquals(surnames[i], doc.field(\"surname\"));\n      assertEquals(i, doc.field(\"id\"));\n      i++;\n    }\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testErrorOnDuplicateVertex() {\n    getProcessor(\n            \"{source: { content: { value: 'name,\\nGregor\\nGregor\\nHans' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:false}},\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\")\n            .execute();\n    assertEquals(1, graph.countVertices(\"Person\"));\n  }","id":40799,"modified_method":"@Test\n  public void testErrorOnDuplicateVertex() {\n    process(\"{source: { content: { value: 'name,\\nGregor\\nGregor\\nHans' } }, extractor : { row: {} },\"\n    + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:false}},\"\n    + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\");\n    assertEquals(1, graph.countVertices(\"Person\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testCreateVertex() {\n    getProcessor(\n            \"{source: { content: { value: 'name,\\nGregor' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:false}},\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\")\n            .execute();\n    assertEquals(1, graph.countVertices(\"Person\"));\n  }","id":40800,"modified_method":"@Test\n  public void testCreateVertex() {\n    process(\"{source: { content: { value: 'name,\\nGregor' } }, extractor : { row: {} },\"\n    + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:false}},\"\n    + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\");\n    assertEquals(1, graph.countVertices(\"Person\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void testSkipDuplicateVertex() {\n    getProcessor(\n            \"{source: { content: { value: 'name,\\nGregor\\nGregor\\nHans' } }, extractor : { row: {} },\"\n            + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:true}},\"\n            + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\")\n            .execute();\n    assertEquals(2, graph.countVertices(\"Person\"));\n  }","id":40801,"modified_method":"@Test\n  public void testSkipDuplicateVertex() {\n    process(\"{source: { content: { value: 'name,\\nGregor\\nGregor\\nHans' } }, extractor : { row: {} },\"\n    + \" transformers: [{csv: {}}, {vertex: {class:'Person', skipDuplicates:true}},\"\n    + \"], loader: { orientdb: { dbURL: 'memory:ETLBaseTest', dbType:'graph', useLightweightEdges:false } } }\");\n    assertEquals(2, graph.countVertices(\"Person\"));\n  }","commit_id":"ae4d85ee47eb4058789f97db2afe2f2b9b120a9b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public <C> void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, C context, Callback<C> callback)\n    {        \n        // info==null content==null lastContent==false          should not happen\n        // info==null content==null lastContent==true           signals no more content - complete\n        // info==null content!=null lastContent==false          send data on committed response\n        // info==null content!=null lastContent==true           send last data on committed response - complete\n        // info!=null content==null lastContent==false          commit\n        // info!=null content==null lastContent==true           commit and complete\n        // info!=null content!=null lastContent==false          commit with content\n        // info!=null content!=null lastContent==true           commit with content and complete\n        \n        boolean hasContent = BufferUtil.hasContent(content);\n        \n        if (info!=null)\n        {\n            short version = stream.getSession().getVersion();\n            Fields headers = new Fields();\n\n            HttpVersion httpVersion = HttpVersion.HTTP_1_1;\n            headers.put(HTTPSPDYHeader.VERSION.name(version), httpVersion.asString());\n\n            int status = info.getStatus();\n            StringBuilder httpStatus = new StringBuilder().append(status);\n            String reason = info.getReason();\n            if (reason == null)\n                reason = HttpStatus.getMessage(status);\n            if (reason != null)\n                httpStatus.append(\" \").append(reason);\n            headers.put(HTTPSPDYHeader.STATUS.name(version), httpStatus.toString());\n            LOG.debug(\"HTTP < {} {}\", httpVersion, httpStatus);\n\n            // TODO merge the two Field classes into one\n            HttpFields fields = info.getHttpFields();\n            if (fields != null)\n            {\n                for (int i = 0; i < fields.size(); ++i)\n                {\n                    HttpFields.Field field = fields.getField(i);\n                    String name = field.getName();\n                    String value = field.getValue();\n                    headers.put(name, value);\n                    LOG.debug(\"HTTP < {}: {}\", name, value);\n                }\n            }\n\n            boolean close = !hasContent && lastContent;\n            reply(stream, new ReplyInfo(headers, close));\n        }\n        \n        if (stream.isClosed())\n        {\n            callback.failed(context,new EofException());\n        }\n        else if (hasContent)\n        {\n            stream.data(new ByteBufferDataInfo(content, lastContent),endPoint.getIdleTimeout(),TimeUnit.MILLISECONDS,context,callback);\n        }\n        else if (lastContent)\n        {\n            stream.data(new ByteBufferDataInfo(BufferUtil.EMPTY_BUFFER, lastContent),endPoint.getIdleTimeout(),TimeUnit.MILLISECONDS,context,callback);\n        }\n        else\n            callback.completed(context);\n    }","id":40802,"modified_method":"@Override\n    public <C> void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, C context, Callback<C> callback)\n    {\n        // info==null content==null lastContent==false          should not happen\n        // info==null content==null lastContent==true           signals no more content - complete\n        // info==null content!=null lastContent==false          send data on committed response\n        // info==null content!=null lastContent==true           send last data on committed response - complete\n        // info!=null content==null lastContent==false          commit\n        // info!=null content==null lastContent==true           commit and complete\n        // info!=null content!=null lastContent==false          commit with content\n        // info!=null content!=null lastContent==true           commit with content and complete\n        \n        boolean hasContent = BufferUtil.hasContent(content);\n        \n        if (info!=null)\n        {\n            short version = stream.getSession().getVersion();\n            Fields headers = new Fields();\n\n            HttpVersion httpVersion = HttpVersion.HTTP_1_1;\n            headers.put(HTTPSPDYHeader.VERSION.name(version), httpVersion.asString());\n\n            int status = info.getStatus();\n            StringBuilder httpStatus = new StringBuilder().append(status);\n            String reason = info.getReason();\n            if (reason == null)\n                reason = HttpStatus.getMessage(status);\n            if (reason != null)\n                httpStatus.append(\" \").append(reason);\n            headers.put(HTTPSPDYHeader.STATUS.name(version), httpStatus.toString());\n            LOG.debug(\"HTTP < {} {}\", httpVersion, httpStatus);\n\n            // TODO merge the two Field classes into one\n            HttpFields fields = info.getHttpFields();\n            if (fields != null)\n            {\n                for (int i = 0; i < fields.size(); ++i)\n                {\n                    HttpFields.Field field = fields.getField(i);\n                    String name = field.getName();\n                    String value = field.getValue();\n                    headers.put(name, value);\n                    LOG.debug(\"HTTP < {}: {}\", name, value);\n                }\n            }\n\n            boolean close = !hasContent && lastContent;\n            reply(stream, new ReplyInfo(headers, close));\n        }\n\n        \n        if ((hasContent || lastContent ) && !stream.isClosed() )\n        {\n            if (content==null)\n                content=BufferUtil.EMPTY_BUFFER;\n            stream.data(new ByteBufferDataInfo(content, lastContent),endPoint.getIdleTimeout(),TimeUnit.MILLISECONDS,context,callback);\n        }\n        else\n            callback.completed(context);\n\n    }","commit_id":"62e033fcd0b4bda6eaa845c2d31bbf6808d32c9c","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public synchronized SSLEngineResult unwrap(final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {\n        // Check to make sure the engine has not been closed\n        if (destroyed != 0) {\n            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);\n        }\n\n        // Throw requried runtime exceptions\n        if (src == null) {\n            throw new IllegalArgumentException(sm.getString(\"engine.nullBuffer\"));\n        }\n        if (dsts == null) {\n            throw new IllegalArgumentException(sm.getString(\"engine.nullBuffer\"));\n        }\n        if (offset >= dsts.length || offset + length > dsts.length) {\n            throw new IndexOutOfBoundsException(sm.getString(\"engine.invalidBufferArray\",\n                    Integer.toString(offset), Integer.toString(length),\n                    Integer.toString(dsts.length)));\n        }\n\n        int capacity = 0;\n        final int endOffset = offset + length;\n        for (int i = offset; i < endOffset; i++) {\n            ByteBuffer dst = dsts[i];\n            if (dst == null) {\n                throw new IllegalArgumentException(sm.getString(\"engine.nullBufferInArray\"));\n            }\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        // Prepare OpenSSL to work in server mode and receive handshake\n        if (accepted == 0) {\n            beginHandshakeImplicitly();\n        }\n\n        // In handshake or close_notify stages, check if call to unwrap was made\n        // without regard to the handshake status.\n        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();\n        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);\n        }\n\n        int len = src.remaining();\n\n        // protect against protocol overflow attack vector\n        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {\n            isInboundDone = true;\n            isOutboundDone = true;\n            engineClosed = true;\n            shutdown();\n            throw ENCRYPTED_PACKET_OVERSIZED;\n        }\n\n        // Write encrypted data to network BIO\n        int bytesConsumed = -1;\n        try {\n            int written = writeEncryptedData(src);\n            if (written >= 0) {\n                if (bytesConsumed == -1) {\n                    bytesConsumed = written;\n                } else {\n                    bytesConsumed += written;\n                }\n            }\n        } catch (Exception e) {\n            throw new SSLException(e);\n        }\n        if (bytesConsumed >= 0) {\n            primingSSLRead();\n        } else {\n            // Reset to 0 as -1 is used to signal that nothing was written and no priming read needs to be done\n            bytesConsumed = 0;\n        }\n\n        // There won't be any application data until we're done handshaking\n        //\n        // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible.\n        int pendingApp = (handshakeFinished || SSL.isInInit(ssl) == 0) ? SSL.pendingReadableBytesInSSL(ssl) : 0;\n        int bytesProduced = 0;\n        int idx = offset;\n\n        while (pendingApp > 0) {\n            // Do we have enough room in dsts to write decrypted data?\n            if (capacity < pendingApp) {\n                return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, 0);\n            }\n\n            // Write decrypted data to dsts buffers\n            while (idx < endOffset) {\n                ByteBuffer dst = dsts[idx];\n                if (!dst.hasRemaining()) {\n                    idx++;\n                    continue;\n                }\n\n                if (pendingApp <= 0) {\n                    break;\n                }\n\n                int bytesRead;\n                try {\n                    bytesRead = readPlaintextData(dst);\n                } catch (Exception e) {\n                    throw new SSLException(e);\n                }\n\n                if (bytesRead == 0) {\n                    break;\n                }\n\n                bytesProduced += bytesRead;\n                pendingApp -= bytesRead;\n                capacity -= bytesRead;\n\n                if (!dst.hasRemaining()) {\n                    idx++;\n                }\n            }\n            if (pendingApp == 0) {\n                primingSSLRead();\n                pendingApp = SSL.pendingReadableBytesInSSL(ssl);\n            }\n        }\n\n        // Check to see if we received a close_notify message from the peer\n        if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n            receivedShutdown = true;\n            closeOutbound();\n            closeInbound();\n        }\n        if (bytesProduced == 0 && bytesConsumed == 0) {\n            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_UNDERFLOW, getHandshakeStatus(), bytesConsumed, bytesProduced);\n        } else {\n            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);\n        }\n    }","id":40803,"modified_method":"@Override\n    public synchronized SSLEngineResult unwrap(final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {\n        // Check to make sure the engine has not been closed\n        if (destroyed != 0) {\n            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);\n        }\n\n        // Throw requried runtime exceptions\n        if (src == null) {\n            throw new IllegalArgumentException(sm.getString(\"engine.nullBuffer\"));\n        }\n        if (dsts == null) {\n            throw new IllegalArgumentException(sm.getString(\"engine.nullBuffer\"));\n        }\n        if (offset >= dsts.length || offset + length > dsts.length) {\n            throw new IndexOutOfBoundsException(sm.getString(\"engine.invalidBufferArray\",\n                    Integer.toString(offset), Integer.toString(length),\n                    Integer.toString(dsts.length)));\n        }\n\n        int capacity = 0;\n        final int endOffset = offset + length;\n        for (int i = offset; i < endOffset; i++) {\n            ByteBuffer dst = dsts[i];\n            if (dst == null) {\n                throw new IllegalArgumentException(sm.getString(\"engine.nullBufferInArray\"));\n            }\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        // Prepare OpenSSL to work in server mode and receive handshake\n        if (accepted == 0) {\n            beginHandshakeImplicitly();\n        }\n\n        // In handshake or close_notify stages, check if call to unwrap was made\n        // without regard to the handshake status.\n        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();\n        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);\n        }\n\n        int len = src.remaining();\n\n        // protect against protocol overflow attack vector\n        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {\n            isInboundDone = true;\n            isOutboundDone = true;\n            engineClosed = true;\n            shutdown();\n            throw ENCRYPTED_PACKET_OVERSIZED;\n        }\n\n        // Write encrypted data to network BIO\n        int bytesConsumed = -1;\n        try {\n            int written = writeEncryptedData(src);\n            if (written >= 0) {\n                if (bytesConsumed == -1) {\n                    bytesConsumed = written;\n                } else {\n                    bytesConsumed += written;\n                }\n            }\n        } catch (Exception e) {\n            throw new SSLException(e);\n        }\n        if (bytesConsumed >= 0) {\n            primingSSLRead();\n        } else {\n            // Reset to 0 as -1 is used to signal that nothing was written and no priming read needs to be done\n            bytesConsumed = 0;\n        }\n\n        // There won't be any application data until we're done handshaking\n        //\n        // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible.\n        int pendingApp = (handshakeFinished || SSL.isInInit(ssl) == 0) ? SSL.pendingReadableBytesInSSL(ssl) : 0;\n        int bytesProduced = 0;\n        int idx = offset;\n        // Do we have enough room in dsts to write decrypted data?\n        if (capacity < pendingApp) {\n            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, 0);\n        }\n\n        while (pendingApp > 0) {\n            // Write decrypted data to dsts buffers\n            while (idx < endOffset) {\n                ByteBuffer dst = dsts[idx];\n                if (!dst.hasRemaining()) {\n                    idx++;\n                    continue;\n                }\n\n                if (pendingApp <= 0) {\n                    break;\n                }\n\n                int bytesRead;\n                try {\n                    bytesRead = readPlaintextData(dst);\n                } catch (Exception e) {\n                    throw new SSLException(e);\n                }\n\n                if (bytesRead == 0) {\n                    break;\n                }\n\n                bytesProduced += bytesRead;\n                pendingApp -= bytesRead;\n                capacity -= bytesRead;\n\n                if (!dst.hasRemaining()) {\n                    idx++;\n                }\n            }\n            if (pendingApp == 0) {\n                primingSSLRead();\n                pendingApp = SSL.pendingReadableBytesInSSL(ssl);\n            } else if (capacity == 0) {\n                break;\n            }\n        }\n\n        // Check to see if we received a close_notify message from the peer\n        if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n            receivedShutdown = true;\n            closeOutbound();\n            closeInbound();\n        }\n        if (bytesProduced == 0 && bytesConsumed == 0) {\n            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_UNDERFLOW, getHandshakeStatus(), bytesConsumed, bytesProduced);\n        } else {\n            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);\n        }\n    }","commit_id":"59d02008c33e0fa5cedd0182db2a98989e8754dc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public <A> void read(final ByteBuffer dst,\n            long timeout, TimeUnit unit, final A attachment,\n            CompletionHandler<Integer, ? super A> handler) {\n        // Check state\n        if (closing || closed) {\n            handler.completed(Integer.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        int read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dst);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        // continue to unwrap as long as the input buffer has stuff\n                        } while (netInBuffer.position() != 0);\n                        // If everything is OK, so complete\n                        handler.completed(Integer.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }","id":40804,"modified_method":"@Override\n    public <A> void read(final ByteBuffer dst,\n            long timeout, TimeUnit unit, final A attachment,\n            CompletionHandler<Integer, ? super A> handler) {\n        // Check state\n        if (closing || closed) {\n            handler.completed(Integer.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        int read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dst);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        // continue to unwrap as long as the input buffer has stuff\n                        } while (netInBuffer.position() != 0);\n                        // If everything is OK, so complete\n                        handler.completed(Integer.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n    }","commit_id":"59d02008c33e0fa5cedd0182db2a98989e8754dc","url":"https://github.com/apache/tomcat"},{"original_method":"private FutureRead(ByteBuffer dst) {\n            this.dst = dst;\n            if (netInBuffer.position() > 0) {\n                this.integer = null;\n            } else {\n                this.integer = sc.read(netInBuffer);\n            }\n        }","id":40805,"modified_method":"private FutureRead(ByteBuffer dst) {\n            this.dst = dst;\n        }","commit_id":"59d02008c33e0fa5cedd0182db2a98989e8754dc","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testAsyncTimeoutInDataFrames() throws Exception\n    {\n        final long timeout = 1000;\n        final TimeUnit unit = TimeUnit.MILLISECONDS;\n\n        Executor threadPool = Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        Generator generator = new Generator(new StandardCompressionFactory.StandardCompressor());\n        Session session = new StandardSession(SPDY.V2, threadPool, scheduler, new TestController(), new TestIdleListener(), 1, null, generator)\n        {\n            private final AtomicInteger flushes = new AtomicInteger();\n\n            @Override\n            public void flush()\n            {\n                try\n                {\n                    int flushes = this.flushes.incrementAndGet();\n                    if (flushes == 3)\n                        unit.sleep(2 * timeout);\n                    super.flush();\n                }\n                catch (InterruptedException x)\n                {\n                    throw new SPDYException(x);\n                }\n            }\n        };\n\n        Stream stream = session.syn(new SynInfo(false), null).get(5, TimeUnit.SECONDS);\n        final CountDownLatch failedLatch = new CountDownLatch(1);\n        stream.data(new StringDataInfo(\"data\", true), timeout, unit, new Handler<Void>()\n        {\n            @Override\n            public void completed(Void context)\n            {\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                failedLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(failedLatch.await(2 * timeout, unit));\n    }","id":40806,"modified_method":"@Test\n    public void testAsyncTimeoutInDataFrames() throws Exception\n    {\n        final long timeout = 1000;\n        final TimeUnit unit = TimeUnit.MILLISECONDS;\n\n        Executor threadPool = Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        Generator generator = new Generator(new StandardCompressionFactory.StandardCompressor());\n        Session session = new StandardSession(SPDY.V2, threadPool, scheduler, new TestController(), null, 1, null, generator)\n        {\n            private final AtomicInteger flushes = new AtomicInteger();\n\n            @Override\n            public void flush()\n            {\n                try\n                {\n                    int flushes = this.flushes.incrementAndGet();\n                    if (flushes == 3)\n                        unit.sleep(2 * timeout);\n                    super.flush();\n                }\n                catch (InterruptedException x)\n                {\n                    throw new SPDYException(x);\n                }\n            }\n        };\n\n        Stream stream = session.syn(new SynInfo(false), null).get(5, TimeUnit.SECONDS);\n        final CountDownLatch failedLatch = new CountDownLatch(1);\n        stream.data(new StringDataInfo(\"data\", true), timeout, unit, new Handler<Void>()\n        {\n            @Override\n            public void completed(Void context)\n            {\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                failedLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(failedLatch.await(2 * timeout, unit));\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAsyncTimeoutInControlFrames() throws Exception\n    {\n        final long timeout = 1000;\n        final TimeUnit unit = TimeUnit.MILLISECONDS;\n\n        Executor threadPool = Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        Generator generator = new Generator(new StandardCompressionFactory.StandardCompressor());\n        Session session = new StandardSession(SPDY.V2, threadPool, scheduler, new TestController(), new TestIdleListener(), 1, null, generator)\n        {\n            @Override\n            public void flush()\n            {\n                try\n                {\n                    unit.sleep(2 * timeout);\n                    super.flush();\n                }\n                catch (InterruptedException x)\n                {\n                    throw new SPDYException(x);\n                }\n            }\n        };\n\n        final CountDownLatch failedLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(true), null, timeout, unit, new Handler<Stream>()\n        {\n            @Override\n            public void completed(Stream stream)\n            {\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                failedLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(failedLatch.await(2 * timeout, unit));\n    }","id":40807,"modified_method":"@Test\n    public void testAsyncTimeoutInControlFrames() throws Exception\n    {\n        final long timeout = 1000;\n        final TimeUnit unit = TimeUnit.MILLISECONDS;\n\n        Executor threadPool = Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        Generator generator = new Generator(new StandardCompressionFactory.StandardCompressor());\n        Session session = new StandardSession(SPDY.V2, threadPool, scheduler, new TestController(), null, 1, null, generator)\n        {\n            @Override\n            public void flush()\n            {\n                try\n                {\n                    unit.sleep(2 * timeout);\n                    super.flush();\n                }\n                catch (InterruptedException x)\n                {\n                    throw new SPDYException(x);\n                }\n            }\n        };\n\n        final CountDownLatch failedLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(true), null, timeout, unit, new Handler<Stream>()\n        {\n            @Override\n            public void completed(Stream stream)\n            {\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                failedLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(failedLatch.await(2 * timeout, unit));\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSlowStreamDoesNotBlockOtherStreams() throws Exception\n    {\n        final CountDownLatch slowServerLatch = new CountDownLatch(1);\n        final CountDownLatch fastServerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                try\n                {\n                    request.setHandled(true);\n                    switch (target)\n                    {\n                        case \"/slow\":\n                            fastServerLatch.await(500, TimeUnit.SECONDS);\n                            slowServerLatch.countDown();\n                            break;\n                        case \"/fast\":\n                            fastServerLatch.countDown();\n                            break;\n                        default:\n                            Assert.fail();\n                            break;\n                    }\n                }\n                catch (InterruptedException x)\n                {\n                    throw new ServletException(x);\n                }\n            }\n        }), null);\n\n        // Perform slow request. This will wait on server side until the fast request wakes it up\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"/slow\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"host\", \"localhost:\" + connector.getLocalPort());\n        final CountDownLatch slowClientLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(headers, true), new StreamFrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                slowClientLatch.countDown();\n            }\n        });\n\n        // Perform the fast request. This will wake up the slow request\n        headers.clear();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"/fast\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"host\", \"localhost:\" + connector.getLocalPort());\n        final CountDownLatch fastClientLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(headers, true), new StreamFrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                fastClientLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(fastServerLatch.await(500, TimeUnit.SECONDS));\n        Assert.assertTrue(slowServerLatch.await(500, TimeUnit.SECONDS));\n        Assert.assertTrue(fastClientLatch.await(500, TimeUnit.SECONDS));\n        Assert.assertTrue(slowClientLatch.await(500, TimeUnit.SECONDS));\n    }","id":40808,"modified_method":"@Test\n    public void testSlowStreamDoesNotBlockOtherStreams() throws Exception\n    {\n        final CountDownLatch slowServerLatch = new CountDownLatch(1);\n        final CountDownLatch fastServerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                try\n                {\n                    request.setHandled(true);\n                    switch (target)\n                    {\n                        case \"/slow\":\n                            Assert.assertTrue(fastServerLatch.await(10, TimeUnit.SECONDS));\n                            slowServerLatch.countDown();\n                            break;\n                        case \"/fast\":\n                            fastServerLatch.countDown();\n                            break;\n                        default:\n                            Assert.fail();\n                            break;\n                    }\n                }\n                catch (InterruptedException x)\n                {\n                    throw new ServletException(x);\n                }\n            }\n        }), null);\n\n        // Perform slow request. This will wait on server side until the fast request wakes it up\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"/slow\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"host\", \"localhost:\" + connector.getLocalPort());\n        final CountDownLatch slowClientLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(headers, true), new StreamFrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                slowClientLatch.countDown();\n            }\n        });\n\n        // Perform the fast request. This will wake up the slow request\n        headers.clear();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"/fast\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"host\", \"localhost:\" + connector.getLocalPort());\n        final CountDownLatch fastClientLatch = new CountDownLatch(1);\n        session.syn(new SynInfo(headers, true), new StreamFrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                fastClientLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(fastServerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(slowServerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(fastClientLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(slowClientLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onRst(final RstStreamFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        execute(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                // TODO: implement logic to clean up unidirectional streams associated with this stream\n\n                if (stream != null)\n                    stream.handle(frame);\n\n                RstInfo rstInfo = new RstInfo(frame.getStreamId(), StreamStatus.from(frame.getVersion(), frame.getStatusCode()));\n                notifyOnRst(rstInfo);\n                flush();\n\n                if (stream != null)\n                    removeStream(stream);\n            }\n        });\n    }","id":40809,"modified_method":"private void onRst(final RstStreamFrame frame)\n    {\n        // TODO: implement logic to clean up unidirectional streams associated with this stream\n\n        final IStream stream = streams.get(frame.getStreamId());\n\n        if (stream != null)\n            stream.process(frame);\n\n        RstInfo rstInfo = new RstInfo(frame.getStreamId(), StreamStatus.from(frame.getVersion(), frame.getStatusCode()));\n        notifyOnRst(listener, rstInfo);\n        flush();\n\n        if (stream != null)\n            removeStream(stream);\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onGoAway(final GoAwayFrame frame)\n    {\n        if (goAwayReceived.compareAndSet(false, true))\n        {\n            execute(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    GoAwayInfo goAwayInfo = new GoAwayInfo(frame.getLastStreamId(), SessionStatus.from(frame.getStatusCode()));\n                    notifyOnGoAway(goAwayInfo);\n                    flush();\n                    // SPDY does not require to send back a response to a GO_AWAY.\n                    // We notified the application of the last good stream id,\n                    // tried our best to flush remaining data, and close.\n                    close();\n                }\n            });\n        }\n    }","id":40810,"modified_method":"private void onGoAway(final GoAwayFrame frame)\n    {\n        if (goAwayReceived.compareAndSet(false, true))\n        {\n            GoAwayInfo goAwayInfo = new GoAwayInfo(frame.getLastStreamId(), SessionStatus.from(frame.getStatusCode()));\n            notifyOnGoAway(listener, goAwayInfo);\n            flush();\n            // SPDY does not require to send back a response to a GO_AWAY.\n            // We notified the application of the last good stream id,\n            // tried our best to flush remaining data, and close.\n            close();\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onWindowUpdate(WindowUpdateFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        IStream stream = streams.get(streamId);\n        if (stream != null)\n            stream.handle(frame);\n    }","id":40811,"modified_method":"private void onWindowUpdate(WindowUpdateFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        IStream stream = streams.get(streamId);\n        if (stream != null)\n            stream.process(frame);\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void fail(final Throwable x)\n        {\n            execute(new Runnable()\n            {\n                public void run()\n                {\n                    notifyHandlerFailed(handler, x);\n                }\n            });\n        }","id":40812,"modified_method":"protected void fail(final Throwable x)\n        {\n            notifyHandlerFailed(handler, x);\n        }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void control(IStream stream, ControlFrame frame, long timeout, TimeUnit unit, final Handler<C> handler, C context)\n    {\n        try\n        {\n            if (stream != null)\n                updateLastStreamId(stream);\n\n            // Synchronization is necessary, since we may have concurrent replies\n            // and those needs to be generated and enqueued atomically in order\n            // to maintain a correct compression context\n            synchronized (this)\n            {\n                ByteBuffer buffer = generator.control(frame);\n                logger.debug(\"Queuing {} on {}\", frame, stream);\n                ControlFrameBytes<C> frameBytes = new ControlFrameBytes<>(handler, context, frame, buffer);\n                if (timeout > 0)\n                    frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n                enqueueLast(frameBytes);\n            }\n\n            flush();\n        }\n        catch (final Throwable x)\n        {\n            execute(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    notifyHandlerFailed(handler, x);\n                }\n            });\n        }\n    }","id":40813,"modified_method":"@Override\n    public <C> void control(IStream stream, ControlFrame frame, long timeout, TimeUnit unit, final Handler<C> handler, C context)\n    {\n        try\n        {\n            if (stream != null)\n                updateLastStreamId(stream);\n\n            // Synchronization is necessary, since we may have concurrent replies\n            // and those needs to be generated and enqueued atomically in order\n            // to maintain a correct compression context\n            synchronized (this)\n            {\n                ByteBuffer buffer = generator.control(frame);\n                logger.debug(\"Queuing {} on {}\", frame, stream);\n                ControlFrameBytes<C> frameBytes = new ControlFrameBytes<>(handler, context, frame, buffer);\n                if (timeout > 0)\n                    frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n                enqueueLast(frameBytes);\n            }\n\n            flush();\n        }\n        catch (final Throwable x)\n        {\n            notifyHandlerFailed(handler, x);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onReply(final SynReplyFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        if (stream == null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n            logger.debug(\"Unknown stream {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            stream.post(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    stream.handle(frame);\n                    if (stream.isClosed())\n                        removeStream(stream);\n                }\n            });\n        }\n    }","id":40814,"modified_method":"private void onReply(final SynReplyFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        if (stream == null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n            logger.debug(\"Unknown stream {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            processReply(stream, frame);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void complete()\n        {\n            ScheduledFuture<?> task = this.task;\n            if (task != null)\n                task.cancel(false);\n\n            // We call back the application, which may block or may perform more writes.\n            // If it blocks, we're blocking the whole write path, which is not good.\n            // If it writes more, we may go in StackOverflowError, not good either.\n            // Therefore we invoke the application in another thread.\n            execute(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    notifyHandlerCompleted(handler, context);\n\n                    // The application may have written more, so we flush\n                    flush();\n                }\n            });\n        }","id":40815,"modified_method":"@Override\n        public void complete()\n        {\n            ScheduledFuture<?> task = this.task;\n            if (task != null)\n                task.cancel(false);\n            StandardSession.this.complete(handler, context);\n        }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onSyn(final SynStreamFrame frame)\n    {\n        final IStream stream = new StandardStream(this, frame);\n        logger.debug(\"Opening {}\", stream);\n        int streamId = frame.getStreamId();\n        IStream existing = streams.putIfAbsent(streamId, stream);\n        if (existing != null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.PROTOCOL_ERROR);\n            logger.debug(\"Duplicate stream, {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            stream.post(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    stream.handle(frame);\n                    SynInfo synInfo = new SynInfo(frame.getHeaders(), frame.isClose(),\n                            frame.isUnidirectional(), frame.getAssociatedStreamId(), frame.getPriority());\n                    StreamFrameListener listener = notifyOnSyn(stream, synInfo);\n                    stream.setStreamFrameListener(listener);\n                    flush();\n                    // The onSyn() listener may have sent a frame that closed the stream\n                    if (stream.isClosed())\n                        removeStream(stream);\n                }\n            });\n        }\n    }","id":40816,"modified_method":"private void onSyn(final SynStreamFrame frame)\n    {\n        final IStream stream = new StandardStream(this, frame);\n        logger.debug(\"Opening {}\", stream);\n        int streamId = frame.getStreamId();\n        IStream existing = streams.putIfAbsent(streamId, stream);\n        if (existing != null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.PROTOCOL_ERROR);\n            logger.debug(\"Duplicate stream, {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            processSyn(listener, stream, frame);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private StreamFrameListener notifyOnSyn(Stream stream, SynInfo synInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", synInfo, listener);\n                return listener.onSyn(stream, synInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n        return null;\n    }","id":40817,"modified_method":"private StreamFrameListener notifyOnSyn(SessionFrameListener listener, Stream stream, SynInfo synInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", synInfo, listener);\n                return listener.onSyn(stream, synInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n        return null;\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void run()\n        {\n            close();\n            notifyHandlerFailed(handler, new InterruptedByTimeoutException());\n        }","id":40818,"modified_method":"@Override\n        public void run()\n        {\n            close();\n            fail(new InterruptedByTimeoutException());\n        }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onPing(final PingFrame frame)\n    {\n        int pingId = frame.getPingId();\n        if (pingId % 2 == pingIds.get() % 2)\n        {\n            execute(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    PingInfo pingInfo = new PingInfo(frame.getPingId());\n                    notifyOnPing(pingInfo);\n                    flush();\n                }\n            });\n        }\n        else\n        {\n            control(null, frame, 0, TimeUnit.MILLISECONDS, new Promise<>(), null);\n        }\n    }","id":40819,"modified_method":"private void onPing(final PingFrame frame)\n    {\n        int pingId = frame.getPingId();\n        if (pingId % 2 == pingIds.get() % 2)\n        {\n            PingInfo pingInfo = new PingInfo(frame.getPingId());\n            notifyOnPing(listener, pingInfo);\n            flush();\n        }\n        else\n        {\n            control(null, frame, 0, TimeUnit.MILLISECONDS, null, null);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onSettings(final SettingsFrame frame)\n    {\n        Settings.Setting windowSizeSetting = frame.getSettings().get(Settings.ID.INITIAL_WINDOW_SIZE);\n        if (windowSizeSetting != null)\n        {\n            windowSize = windowSizeSetting.value();\n            logger.debug(\"Updated window size to {}\", windowSize);\n        }\n        execute(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                SettingsInfo settingsInfo = new SettingsInfo(frame.getSettings(), frame.isClearPersisted());\n                notifyOnSettings(settingsInfo);\n                flush();\n            }\n        });\n    }","id":40820,"modified_method":"private void onSettings(final SettingsFrame frame)\n    {\n        Settings.Setting windowSizeSetting = frame.getSettings().get(Settings.ID.INITIAL_WINDOW_SIZE);\n        if (windowSizeSetting != null)\n        {\n            windowSize = windowSizeSetting.value();\n            logger.debug(\"Updated window size to {}\", windowSize);\n        }\n\n        SettingsInfo settingsInfo = new SettingsInfo(frame.getSettings(), frame.isClearPersisted());\n        notifyOnSettings(listener, settingsInfo);\n        flush();\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void onHeaders(final HeadersFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        if (stream == null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n            logger.debug(\"Unknown stream, {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            stream.post(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    stream.handle(frame);\n                    if (stream.isClosed())\n                        removeStream(stream);\n                }\n            });\n        }\n    }","id":40821,"modified_method":"private void onHeaders(final HeadersFrame frame)\n    {\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        if (stream == null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n            logger.debug(\"Unknown stream, {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            processHeaders(stream, frame);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void goAway(long timeout, TimeUnit unit, Handler<Void> handler)\n    {\n        if (goAwaySent.compareAndSet(false, true))\n        {\n            if (!goAwayReceived.get())\n            {\n                GoAwayFrame frame = new GoAwayFrame(version, lastStreamId.get(), SessionStatus.OK.getCode());\n                control(null, frame, timeout, unit, handler, null);\n                return;\n            }\n        }\n        notifyHandlerCompleted(handler, null);\n    }","id":40822,"modified_method":"@Override\n    public void goAway(long timeout, TimeUnit unit, Handler<Void> handler)\n    {\n        if (goAwaySent.compareAndSet(false, true))\n        {\n            if (!goAwayReceived.get())\n            {\n                GoAwayFrame frame = new GoAwayFrame(version, lastStreamId.get(), SessionStatus.OK.getCode());\n                control(null, frame, timeout, unit, handler, null);\n                return;\n            }\n        }\n        complete(handler, null);\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void notifyOnGoAway(GoAwayInfo goAwayInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", goAwayInfo, listener);\n                listener.onGoAway(this, goAwayInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","id":40823,"modified_method":"private void notifyOnGoAway(SessionFrameListener listener, GoAwayInfo goAwayInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", goAwayInfo, listener);\n                listener.onGoAway(this, goAwayInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void rst(RstInfo rstInfo, long timeout, TimeUnit unit, Handler<Void> handler)\n    {\n        // SPEC v3, 2.2.2\n        if (goAwaySent.get())\n        {\n            notifyHandlerCompleted(handler, null);\n        }\n        else\n        {\n            RstStreamFrame frame = new RstStreamFrame(version, rstInfo.getStreamId(), rstInfo.getStreamStatus().getCode(version));\n            control(null, frame, timeout, unit, handler, null);\n        }\n    }","id":40824,"modified_method":"@Override\n    public void rst(RstInfo rstInfo, long timeout, TimeUnit unit, Handler<Void> handler)\n    {\n        // SPEC v3, 2.2.2\n        if (goAwaySent.get())\n        {\n            complete(handler, null);\n        }\n        else\n        {\n            RstStreamFrame frame = new RstStreamFrame(version, rstInfo.getStreamId(), rstInfo.getStreamStatus().getCode(version));\n            control(null, frame, timeout, unit, handler, null);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onControlFrame(ControlFrame frame)\n    {\n        logger.debug(\"Processing {}\", frame);\n\n        if (goAwaySent.get())\n        {\n            logger.debug(\"Skipped processing of {}\", frame);\n            return;\n        }\n\n        switch (frame.getType())\n        {\n            case SYN_STREAM:\n            {\n                onSyn((SynStreamFrame)frame);\n                break;\n            }\n            case SYN_REPLY:\n            {\n                onReply((SynReplyFrame)frame);\n                break;\n            }\n            case RST_STREAM:\n            {\n                onRst((RstStreamFrame)frame);\n                break;\n            }\n            case SETTINGS:\n            {\n                onSettings((SettingsFrame)frame);\n                break;\n            }\n            case NOOP:\n            {\n                // Just ignore it\n                break;\n            }\n            case PING:\n            {\n                onPing((PingFrame)frame);\n                break;\n            }\n            case GO_AWAY:\n            {\n                onGoAway((GoAwayFrame)frame);\n                break;\n            }\n            case HEADERS:\n            {\n                onHeaders((HeadersFrame)frame);\n                break;\n            }\n            case WINDOW_UPDATE:\n            {\n                onWindowUpdate((WindowUpdateFrame)frame);\n                break;\n            }\n            default:\n            {\n                throw new IllegalStateException();\n            }\n        }\n    }","id":40825,"modified_method":"@Override\n    public void onControlFrame(ControlFrame frame)\n    {\n        notifyIdle(idleListener, false);\n        try\n        {\n            logger.debug(\"Processing {}\", frame);\n\n            if (goAwaySent.get())\n            {\n                logger.debug(\"Skipped processing of {}\", frame);\n                return;\n            }\n\n            switch (frame.getType())\n            {\n                case SYN_STREAM:\n                {\n                    onSyn((SynStreamFrame)frame);\n                    break;\n                }\n                case SYN_REPLY:\n                {\n                    onReply((SynReplyFrame)frame);\n                    break;\n                }\n                case RST_STREAM:\n                {\n                    onRst((RstStreamFrame)frame);\n                    break;\n                }\n                case SETTINGS:\n                {\n                    onSettings((SettingsFrame)frame);\n                    break;\n                }\n                case NOOP:\n                {\n                    // Just ignore it\n                    break;\n                }\n                case PING:\n                {\n                    onPing((PingFrame)frame);\n                    break;\n                }\n                case GO_AWAY:\n                {\n                    onGoAway((GoAwayFrame)frame);\n                    break;\n                }\n                case HEADERS:\n                {\n                    onHeaders((HeadersFrame)frame);\n                    break;\n                }\n                case WINDOW_UPDATE:\n                {\n                    onWindowUpdate((WindowUpdateFrame)frame);\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        finally\n        {\n            notifyIdle(idleListener, true);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void execute(final Runnable task)\n    {\n        idleListener.onIdle(false);\n        threadPool.execute(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    task.run();\n                }\n                finally\n                {\n                    idleListener.onIdle(true);\n                }\n            }\n        });\n    }","id":40826,"modified_method":"private void execute(final Runnable task)\n    {\n        threadPool.execute(task);\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private <C> void notifyHandlerCompleted(Handler<C> handler, C context)\n    {\n        try\n        {\n            if (handler != null)\n                handler.completed(context);\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying handler \" + handler, x);\n        }\n    }","id":40827,"modified_method":"private <C> void notifyHandlerCompleted(Handler<C> handler, C context)\n    {\n        try\n        {\n            handler.completed(context);\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying handler \" + handler, x);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void notifyOnSettings(SettingsInfo settingsInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", settingsInfo, listener);\n                listener.onSettings(this, settingsInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","id":40828,"modified_method":"private void notifyOnSettings(SessionFrameListener listener, SettingsInfo settingsInfo)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                logger.debug(\"Invoking callback with {} on listener {}\", settingsInfo, listener);\n                listener.onSettings(this, settingsInfo);\n            }\n        }\n        catch (Exception x)\n        {\n            logger.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onDataFrame(final DataFrame frame, final ByteBuffer data)\n    {\n        logger.debug(\"Processing {}, {} data bytes\", frame, data.remaining());\n\n        if (goAwaySent.get())\n        {\n            logger.debug(\"Skipped processing of {}\", frame);\n            return;\n        }\n\n        int streamId = frame.getStreamId();\n        final IStream stream = streams.get(streamId);\n        if (stream == null)\n        {\n            RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n            logger.debug(\"Unknown stream {}\", rstInfo);\n            rst(rstInfo);\n        }\n        else\n        {\n            stream.post(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    stream.handle(frame, data);\n                    updateLastStreamId(stream);\n                    if (stream.isClosed())\n                        removeStream(stream);\n                }\n            });\n        }\n    }","id":40829,"modified_method":"@Override\n    public void onDataFrame(final DataFrame frame, final ByteBuffer data)\n    {\n        notifyIdle(idleListener, false);\n        try\n        {\n            logger.debug(\"Processing {}, {} data bytes\", frame, data.remaining());\n\n            if (goAwaySent.get())\n            {\n                logger.debug(\"Skipped processing of {}\", frame);\n                return;\n            }\n\n            int streamId = frame.getStreamId();\n            final IStream stream = streams.get(streamId);\n            if (stream == null)\n            {\n                RstInfo rstInfo = new RstInfo(streamId, StreamStatus.INVALID_STREAM);\n                logger.debug(\"Unknown stream {}\", rstInfo);\n                rst(rstInfo);\n            }\n            else\n            {\n                processData(stream, frame, data);\n            }\n        }\n        finally\n        {\n            notifyIdle(idleListener, true);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void windowUpdate(int delta)\n    {\n        if (delta > 0)\n        {\n            WindowUpdateFrame windowUpdateFrame = new WindowUpdateFrame(session.getVersion(), getId(), delta);\n            session.control(this, windowUpdateFrame, 0, TimeUnit.MILLISECONDS, new Promise<>(), null);\n        }\n    }","id":40830,"modified_method":"private void windowUpdate(int delta)\n    {\n        if (delta > 0)\n        {\n            WindowUpdateFrame windowUpdateFrame = new WindowUpdateFrame(session.getVersion(), getId(), delta);\n            session.control(this, windowUpdateFrame, 0, TimeUnit.MILLISECONDS, null, null);\n        }\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void handle(ControlFrame frame)\n    {\n        switch (frame.getType())\n        {\n            case SYN_STREAM:\n            {\n                opened = true;\n                break;\n            }\n            case SYN_REPLY:\n            {\n                opened = true;\n                SynReplyFrame synReply = (SynReplyFrame)frame;\n                updateCloseState(synReply.isClose());\n                ReplyInfo replyInfo = new ReplyInfo(synReply.getHeaders(), synReply.isClose());\n                notifyOnReply(replyInfo);\n                break;\n            }\n            case HEADERS:\n            {\n                HeadersFrame headers = (HeadersFrame)frame;\n                updateCloseState(headers.isClose());\n                HeadersInfo headersInfo = new HeadersInfo(headers.getHeaders(), headers.isClose(), headers.isResetCompression());\n                notifyOnHeaders(headersInfo);\n                break;\n            }\n            case WINDOW_UPDATE:\n            {\n                WindowUpdateFrame windowUpdate = (WindowUpdateFrame)frame;\n                updateWindowSize(windowUpdate.getWindowDelta());\n                break;\n            }\n            case RST_STREAM:\n            {\n                // TODO:\n                break;\n            }\n            default:\n            {\n                throw new IllegalStateException();\n            }\n        }\n        session.flush();\n    }","id":40831,"modified_method":"@Override\n    public void process(ControlFrame frame)\n    {\n        switch (frame.getType())\n        {\n            case SYN_STREAM:\n            {\n                opened = true;\n                break;\n            }\n            case SYN_REPLY:\n            {\n                opened = true;\n                SynReplyFrame synReply = (SynReplyFrame)frame;\n                updateCloseState(synReply.isClose());\n                ReplyInfo replyInfo = new ReplyInfo(synReply.getHeaders(), synReply.isClose());\n                notifyOnReply(replyInfo);\n                break;\n            }\n            case HEADERS:\n            {\n                HeadersFrame headers = (HeadersFrame)frame;\n                updateCloseState(headers.isClose());\n                HeadersInfo headersInfo = new HeadersInfo(headers.getHeaders(), headers.isClose(), headers.isResetCompression());\n                notifyOnHeaders(headersInfo);\n                break;\n            }\n            case WINDOW_UPDATE:\n            {\n                WindowUpdateFrame windowUpdate = (WindowUpdateFrame)frame;\n                updateWindowSize(windowUpdate.getWindowDelta());\n                break;\n            }\n            case RST_STREAM:\n            {\n                // TODO:\n                break;\n            }\n            default:\n            {\n                throw new IllegalStateException();\n            }\n        }\n        session.flush();\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void handle(DataFrame dataFrame, ByteBuffer data)\n    {\n        if (!opened)\n        {\n            session.rst(new RstInfo(getId(), StreamStatus.PROTOCOL_ERROR));\n            return;\n        }\n\n        updateCloseState(dataFrame.isClose());\n\n        ByteBufferDataInfo dataInfo = new ByteBufferDataInfo(data, dataFrame.isClose(), dataFrame.isCompress())\n        {\n            @Override\n            public void consume(int delta)\n            {\n                super.consume(delta);\n\n                // This is the algorithm for flow control.\n                // This method may be called multiple times with delta=1, but we only send a window\n                // update when the whole dataInfo has been consumed.\n                // Other policies may be to send window updates when consumed() is greater than\n                // a certain threshold, etc. but for now the policy is not pluggable for simplicity.\n                // Note that the frequency of window updates depends on the read buffer, that\n                // should not be too smaller than the window size to avoid frequent window updates.\n                // Therefore, a pluggable policy should be able to modify the read buffer capacity.\n                if (consumed() == length() && !isClosed())\n                    windowUpdate(length());\n            }\n        };\n        notifyOnData(dataInfo);\n        session.flush();\n    }","id":40832,"modified_method":"@Override\n    public void process(DataFrame frame, ByteBuffer data)\n    {\n        if (!opened)\n        {\n            session.rst(new RstInfo(getId(), StreamStatus.PROTOCOL_ERROR));\n            return;\n        }\n\n        updateCloseState(frame.isClose());\n\n        ByteBufferDataInfo dataInfo = new ByteBufferDataInfo(data, frame.isClose(), frame.isCompress())\n        {\n            @Override\n            public void consume(int delta)\n            {\n                super.consume(delta);\n\n                // This is the algorithm for flow control.\n                // This method may be called multiple times with delta=1, but we only send a window\n                // update when the whole dataInfo has been consumed.\n                // Other policies may be to send window updates when consumed() is greater than\n                // a certain threshold, etc. but for now the policy is not pluggable for simplicity.\n                // Note that the frequency of window updates depends on the read buffer, that\n                // should not be too smaller than the window size to avoid frequent window updates.\n                // Therefore, a pluggable policy should be able to modify the read buffer capacity.\n                if (consumed() == length() && !isClosed())\n                    windowUpdate(length());\n            }\n        };\n        notifyOnData(dataInfo);\n        session.flush();\n    }","commit_id":"142a1058ba4ed0a309a952b1a0830eb18a179c96","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Nullable\n  protected StepSequence createSteps(final WizardContext context, @NotNull final ModulesProvider modulesProvider) {\n    ModuleBuilder[] builders = context.getAllBuilders();\n    for (ModuleBuilder builder : builders) {\n      myBuildersMap.put(builder.getBuilderId(), builder);\n    }\n    myBuildersMap.put(ModuleType.EMPTY.getId(), new EmptyModuleBuilder());\n\n    StepSequence sequence = new StepSequence();\n    for (ModuleBuilder builder : builders) {\n      sequence.addStepsForBuilder(builder, context, modulesProvider);\n    }\n    return sequence;\n  }","id":40833,"modified_method":"@Nullable\n  protected StepSequence createSteps(final WizardContext context, @NotNull final ModulesProvider modulesProvider) {\n    List<ModuleBuilder> builders = ModuleBuilder.getAllBuilders();\n    for (ModuleBuilder builder : builders) {\n      myBuildersMap.put(builder.getBuilderId(), builder);\n    }\n    myBuildersMap.put(ModuleType.EMPTY.getId(), new EmptyModuleBuilder());\n\n    StepSequence sequence = new StepSequence();\n    for (ModuleBuilder builder : builders) {\n      sequence.addStepsForBuilder(builder, context, modulesProvider);\n    }\n    return sequence;\n  }","commit_id":"5ed63b1758663a8046ab2f775c1bb3ff0efb34a4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public ProjectTemplate[] createTemplates(final String group, WizardContext context) {\n    if (OTHER_GROUP.equals(group)) {\n      if (!context.isCreatingNewProject()) {\n        return ProjectTemplate.EMPTY_ARRAY;\n      }\n      return new ProjectTemplate[]{new BuilderBasedTemplate(new EmptyModuleBuilder() {\n        @Override\n        public String getPresentableName() {\n          return \"Empty Project\";\n        }\n\n        @Override\n        public String getDescription() {\n          return \"Empty project without modules. Use it to create free-style module structure.\";\n        }\n      })};\n    }\n    ModuleBuilder[] builders = context.getAllBuilders();\n    return ContainerUtil.mapNotNull(builders, new NullableFunction<ModuleBuilder, ProjectTemplate>() {\n      @Nullable\n      @Override\n      public ProjectTemplate fun(ModuleBuilder builder) {\n        return builder.getGroupName().equals(group) ? new BuilderBasedTemplate(builder) : null;\n      }\n    }, ProjectTemplate.EMPTY_ARRAY);\n  }","id":40834,"modified_method":"@NotNull\n  @Override\n  public ProjectTemplate[] createTemplates(final String group, WizardContext context) {\n    if (OTHER_GROUP.equals(group)) {\n      if (!context.isCreatingNewProject()) {\n        return ProjectTemplate.EMPTY_ARRAY;\n      }\n      return new ProjectTemplate[]{new BuilderBasedTemplate(new EmptyModuleBuilder() {\n        @Override\n        public String getPresentableName() {\n          return \"Empty Project\";\n        }\n\n        @Override\n        public String getDescription() {\n          return \"Empty project without modules. Use it to create free-style module structure.\";\n        }\n      })};\n    }\n    List<ModuleBuilder> builders = ModuleBuilder.getAllBuilders();\n    List<ProjectTemplate> templates = ContainerUtil.mapNotNull(builders, new NullableFunction<ModuleBuilder, ProjectTemplate>() {\n      @Nullable\n      @Override\n      public ProjectTemplate fun(ModuleBuilder builder) {\n        return builder.getGroupName().equals(group) ? new BuilderBasedTemplate(builder) : null;\n      }\n    });\n    return templates.toArray(new ProjectTemplate[templates.size()]);\n  }","commit_id":"5ed63b1758663a8046ab2f775c1bb3ff0efb34a4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private static JetScope getMemberScope(@Nullable DeclarationDescriptor parent) {\n        if (parent instanceof ClassDescriptor) {\n            return ((ClassDescriptor) parent).getDefaultType().getMemberScope();\n        }\n        else if (parent instanceof NamespaceDescriptor) {\n            return ((NamespaceDescriptor)parent).getMemberScope();\n        }\n        else {\n            return null;\n        }\n    }","id":40835,"modified_method":"@Nullable\n    private static JetScope getMemberScope(@Nullable DeclarationDescriptor parent) {\n        if (parent instanceof ClassDescriptor) {\n            return ((ClassDescriptor) parent).getDefaultType().getMemberScope();\n        }\n        else if (parent instanceof PackageFragmentDescriptor) {\n            return ((PackageFragmentDescriptor) parent).getMemberScope();\n        }\n        else {\n            return null;\n        }\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private List<JetFile> getJetBuiltInsFiles() {\n        URL url = LightClassUtil.getBuiltInsDirUrl();\n        VirtualFile vf = VfsUtil.findFileByURL(url);\n        assert vf != null : \"Virtual file not found by URL: \" + url;\n\n        // Refreshing VFS: in case the plugin jar was updated, the caches may hold the old value\n        if (vf instanceof NewVirtualFile) {\n            NewVirtualFile newVirtualFile = (NewVirtualFile) vf;\n            newVirtualFile.markDirtyRecursively(); // This doesn't happen in a JARFS entry, unless we do it manually here\n        }\n        vf.getChildren();\n        vf.refresh(false, true);\n\n        PsiDirectory psiDirectory = PsiManager.getInstance(myProject).findDirectory(vf);\n        assert psiDirectory != null : \"No PsiDirectory for \" + vf;\n        return ContainerUtil.mapNotNull(psiDirectory.getFiles(), new Function<PsiFile, JetFile>() {\n            @Override\n            public JetFile fun(PsiFile file) {\n                return file instanceof JetFile ? (JetFile) file : null;\n            }\n        });\n    }","id":40836,"modified_method":"private Set<JetFile> getJetBuiltInsFiles() {\n        URL url = LightClassUtil.getBuiltInsDirUrl();\n        VirtualFile vf = VfsUtil.findFileByURL(url);\n        assert vf != null : \"Virtual file not found by URL: \" + url;\n\n        // Refreshing VFS: in case the plugin jar was updated, the caches may hold the old value\n        if (vf instanceof NewVirtualFile) {\n            NewVirtualFile newVirtualFile = (NewVirtualFile) vf;\n            newVirtualFile.markDirtyRecursively(); // This doesn't happen in a JARFS entry, unless we do it manually here\n        }\n        vf.getChildren();\n        vf.refresh(false, true);\n\n        PsiDirectory psiDirectory = PsiManager.getInstance(myProject).findDirectory(vf);\n        assert psiDirectory != null : \"No PsiDirectory for \" + vf;\n        return new HashSet<JetFile>(ContainerUtil.mapNotNull(psiDirectory.getFiles(), new Function<PsiFile, JetFile>() {\n            @Override\n            public JetFile fun(PsiFile file) {\n                return file instanceof JetFile ? (JetFile) file : null;\n            }\n        }));\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void initialize() {\n        assert bindingContext == null : \"Attempt to initialize twice\";\n\n        final List<JetFile> jetBuiltInsFiles = getJetBuiltInsFiles();\n\n        final Runnable initializeRunnable = new Runnable() {\n            @Override\n            public void run() {\n                BindingTraceContext context = new BindingTraceContext();\n                FakeJetNamespaceDescriptor jetNamespace = new FakeJetNamespaceDescriptor();\n                context.record(BindingContext.FQNAME_TO_NAMESPACE_DESCRIPTOR, KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME, jetNamespace);\n\n                WritableScopeImpl scope = new WritableScopeImpl(JetScope.EMPTY, jetNamespace, RedeclarationHandler.THROW_EXCEPTION,\n                                                                \"Builtin classes scope\");\n                scope.changeLockLevel(WritableScope.LockLevel.BOTH);\n                jetNamespace.setMemberScope(scope);\n\n                TopDownAnalyzer.processStandardLibraryNamespace(myProject, context, scope, jetNamespace, jetBuiltInsFiles);\n\n                builtInsSources = Sets.newHashSet(jetBuiltInsFiles);\n                bindingContext = context.getBindingContext();\n            }\n        };\n\n        if (ApplicationManager.getApplication().isUnitTestMode()) {\n            initializeRunnable.run();\n        }\n        else {\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    ApplicationManager.getApplication().runReadAction(initializeRunnable);\n                }\n            });\n        }\n    }","id":40837,"modified_method":"private void initialize() {\n        assert bindingContext == null : \"Attempt to initialize twice\";\n\n        final Set<JetFile> jetBuiltInsFiles = getJetBuiltInsFiles();\n\n        final Runnable initializeRunnable = new Runnable() {\n            @Override\n            public void run() {\n                TopDownAnalysisParameters topDownAnalysisParameters = new TopDownAnalysisParameters(\n                        Predicates.<PsiFile>alwaysFalse(), true, false, Collections.<AnalyzerScriptParameter>emptyList());\n                ModuleDescriptorImpl module = new ModuleDescriptorImpl(\n                        Name.special(\"<fake_module>\"), Collections.<ImportPath>emptyList(), PlatformToKotlinClassMap.EMPTY);\n                InjectorForTopDownAnalyzerBasic injector = new InjectorForTopDownAnalyzerBasic(\n                        myProject, topDownAnalysisParameters, new BindingTraceContext(), module, PlatformToKotlinClassMap.EMPTY);\n\n                TopDownAnalyzer analyzer = injector.getTopDownAnalyzer();\n                analyzer.analyzeFiles(jetBuiltInsFiles, Collections.<AnalyzerScriptParameter>emptyList());\n\n                builtinsPackageFragment = analyzer.getPackageFragmentProvider().getOrCreateFragment(KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME);\n                builtInsSources = Sets.newHashSet(jetBuiltInsFiles);\n                bindingContext = injector.getBindingTrace().getBindingContext();\n            }\n        };\n\n        if (ApplicationManager.getApplication().isUnitTestMode()) {\n            initializeRunnable.run();\n        }\n        else {\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    ApplicationManager.getApplication().runReadAction(initializeRunnable);\n                }\n            });\n        }\n\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private DeclarationDescriptor findCurrentDescriptor(@NotNull DeclarationDescriptor originalDescriptor) {\n        if (originalDescriptor instanceof ClassDescriptor) {\n            return findCurrentDescriptorForClass((ClassDescriptor) originalDescriptor);\n        }\n        else if (originalDescriptor instanceof NamespaceDescriptor) {\n            return bindingContext.get(BindingContext.FQNAME_TO_NAMESPACE_DESCRIPTOR,\n                                      DescriptorUtils.getFQName(originalDescriptor).toSafe());\n        }\n        else if (originalDescriptor instanceof MemberDescriptor) {\n            return findCurrentDescriptorForMember((MemberDescriptor) originalDescriptor);\n        }\n        else {\n            return null;\n        }\n    }","id":40838,"modified_method":"@Nullable\n    private DeclarationDescriptor findCurrentDescriptor(@NotNull DeclarationDescriptor originalDescriptor) {\n        if (originalDescriptor instanceof ClassDescriptor) {\n            return findCurrentDescriptorForClass((ClassDescriptor) originalDescriptor);\n        }\n        else if (originalDescriptor instanceof PackageFragmentDescriptor) {\n            return KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME.equals(((PackageFragmentDescriptor) originalDescriptor).getFqName())\n                   ? builtinsPackageFragment\n                   : null;\n        }\n        else if (originalDescriptor instanceof MemberDescriptor) {\n            return findCurrentDescriptorForMember((MemberDescriptor) originalDescriptor);\n        }\n        else {\n            return null;\n        }\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testAllReferencesResolved() {\n        BuiltInsReferenceResolver referenceResolver = getProject().getComponent(BuiltInsReferenceResolver.class);\n        for (DeclarationDescriptor descriptor : getAllStandardDescriptors(KotlinBuiltIns.getInstance().getBuiltInsPackageFragment())) {\n            if (descriptor instanceof NamespaceDescriptor && \"jet\".equals(descriptor.getName().asString())) continue;\n            assertNotNull(\"Can't resolve \" + descriptor, referenceResolver.resolveBuiltInSymbol(descriptor));\n        }\n    }","id":40839,"modified_method":"public void testAllReferencesResolved() {\n        BuiltInsReferenceResolver referenceResolver = getProject().getComponent(BuiltInsReferenceResolver.class);\n        for (DeclarationDescriptor descriptor : getAllStandardDescriptors()) {\n            assertNotNull(\"Can't resolve \" + descriptor, referenceResolver.resolveBuiltInSymbol(descriptor));\n        }\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static Collection<DeclarationDescriptor> getAllStandardDescriptors(DeclarationDescriptor baseDescriptor) {\n        final ArrayList<DeclarationDescriptor> descriptors = new ArrayList<DeclarationDescriptor>();\n        baseDescriptor.acceptVoid(new DeclarationDescriptorVisitorEmptyBodies<Void, Void>() {\n            private Void visitDescriptors(Collection<? extends DeclarationDescriptor> descriptors) {\n                for (DeclarationDescriptor descriptor : descriptors) {\n                    descriptor.acceptVoid(this);\n                }\n                return null;\n            }\n\n            @Override\n            public Void visitClassDescriptor(ClassDescriptor descriptor, Void data) {\n                descriptors.add(descriptor);\n                return visitDescriptors(descriptor.getDefaultType().getMemberScope().getAllDescriptors());\n            }\n\n            @Override\n            public Void visitPackageViewDescriptor(PackageViewDescriptor descriptor, Void data) {\n                descriptors.add(descriptor);\n                return visitDescriptors(descriptor.getMemberScope().getAllDescriptors());\n            }\n\n            @Override\n            public Void visitDeclarationDescriptor(DeclarationDescriptor descriptor, Void data) {\n                descriptors.add(descriptor);\n                return null;\n            }\n        });\n        return descriptors;\n    }","id":40840,"modified_method":"private static Collection<DeclarationDescriptor> getAllStandardDescriptors() {\n        final List<DeclarationDescriptor> descriptors = new ArrayList<DeclarationDescriptor>();\n\n        PackageFragmentDescriptor builtinsPackageFragment = KotlinBuiltIns.getInstance().getBuiltInsPackageFragment();\n\n        for (DeclarationDescriptor packageMember : builtinsPackageFragment.getMemberScope().getAllDescriptors()) {\n            packageMember.acceptVoid(new DeclarationDescriptorVisitorEmptyBodies<Void, Void>() {\n                @Override\n                public Void visitClassDescriptor(ClassDescriptor descriptor, Void data) {\n                    descriptors.add(descriptor);\n                    for (DeclarationDescriptor classMember : descriptor.getDefaultType().getMemberScope().getAllDescriptors()) {\n                        classMember.acceptVoid(this);\n                    }\n                    return null;\n                }\n\n                @Override\n                public Void visitDeclarationDescriptor(DeclarationDescriptor descriptor, Void data) {\n                    descriptors.add(descriptor);\n                    return null;\n                }\n            });\n        }\n\n        return descriptors;\n    }","commit_id":"303f2b8c4c461cc171fd95eb15ecf5499d46c3df","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  public static List<PsiClassType> getUnhandledExceptions(PsiElement[] elements) {\n    final List<PsiClassType> array = ContainerUtil.newArrayList();\n    final PsiElementVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitCallExpression(PsiCallExpression expression) {\n        addExceptions(array, getUnhandledExceptions(expression, null));\n        visitElement(expression);\n      }\n\n      @Override\n      public void visitThrowStatement(PsiThrowStatement statement) {\n        addExceptions(array, getUnhandledExceptions(statement, null));\n        visitElement(statement);\n      }\n\n      @Override\n      public void visitMethodReferenceExpression(PsiMethodReferenceExpression expression) {\n        addExceptions(array, getUnhandledExceptions(expression, null));\n        visitElement(expression);\n      }\n\n      @Override\n      public void visitResourceVariable(PsiResourceVariable resourceVariable) {\n        addExceptions(array, getUnhandledCloserExceptions(resourceVariable, null));\n        visitElement(resourceVariable);\n      }\n    };\n\n    for (PsiElement element : elements) {\n      element.accept(visitor);\n    }\n\n    return array;\n  }","id":40841,"modified_method":"@NotNull\n  public static List<PsiClassType> getUnhandledExceptions(@NotNull PsiElement[] elements) {\n    final List<PsiClassType> array = ContainerUtil.newArrayList();\n    final PsiElementVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitCallExpression(@NotNull PsiCallExpression expression) {\n        addExceptions(array, getUnhandledExceptions(expression, null));\n        visitElement(expression);\n      }\n\n      @Override\n      public void visitThrowStatement(@NotNull PsiThrowStatement statement) {\n        addExceptions(array, getUnhandledExceptions(statement, null));\n        visitElement(statement);\n      }\n\n      @Override\n      public void visitMethodReferenceExpression(@NotNull PsiMethodReferenceExpression expression) {\n        addExceptions(array, getUnhandledExceptions(expression, null));\n        visitElement(expression);\n      }\n\n      @Override\n      public void visitResourceVariable(@NotNull PsiResourceVariable resourceVariable) {\n        addExceptions(array, getUnhandledCloserExceptions(resourceVariable, null));\n        visitElement(resourceVariable);\n      }\n    };\n\n    for (PsiElement element : elements) {\n      element.accept(visitor);\n    }\n\n    return array;\n  }","commit_id":"c0e9048f558c9daf31b19ac4d83404ccbc74b3b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static List<PsiClassType> getThrownExceptions(@NotNull PsiElement element) {\n    if (element instanceof PsiClass) {\n      if (element instanceof PsiAnonymousClass) {\n        final PsiExpressionList argumentList = ((PsiAnonymousClass)element).getArgumentList();\n        if (argumentList != null){\n          return getThrownExceptions(argumentList);\n        }\n      }\n      // filter class declaration in code\n      return Collections.emptyList();\n    }\n    else if (element instanceof PsiMethodCallExpression) {\n      PsiReferenceExpression methodRef = ((PsiMethodCallExpression)element).getMethodExpression();\n      JavaResolveResult result = methodRef.advancedResolve(false);\n      return getExceptionsByMethodAndChildren(element, result);\n    }\n    else if (element instanceof PsiNewExpression) {\n      JavaResolveResult result = ((PsiNewExpression)element).resolveMethodGenerics();\n      return getExceptionsByMethodAndChildren(element, result);\n    }\n    else if (element instanceof PsiThrowStatement) {\n      final PsiExpression expr = ((PsiThrowStatement)element).getException();\n      if (expr == null) return Collections.emptyList();\n      final List<PsiType> types = getPreciseThrowTypes(expr);\n      final List<PsiClassType> classTypes = ContainerUtil.mapNotNull(types, new NullableFunction<PsiType, PsiClassType>() {\n        @Override public PsiClassType fun(PsiType type) { return type instanceof PsiClassType ? (PsiClassType)type : null; }\n      });\n      addExceptions(classTypes, getThrownExceptions(expr));\n      return classTypes;\n    }\n    else if (element instanceof PsiTryStatement) {\n      return getTryExceptions((PsiTryStatement)element);\n    }\n    else if (element instanceof PsiResourceVariable) {\n      final PsiResourceVariable variable = (PsiResourceVariable)element;\n      final List<PsiClassType> types = ContainerUtil.newArrayList();\n      addExceptions(types, getCloserExceptions(variable));\n      final PsiExpression initializer = variable.getInitializer();\n      if (initializer != null) addExceptions(types, getThrownExceptions(initializer));\n      return types;\n    }\n    return getThrownExceptions(element.getChildren());\n  }","id":40842,"modified_method":"@NotNull\n  public static List<PsiClassType> getThrownExceptions(@NotNull PsiElement element) {\n    if (element instanceof PsiClass) {\n      if (element instanceof PsiAnonymousClass) {\n        final PsiExpressionList argumentList = ((PsiAnonymousClass)element).getArgumentList();\n        if (argumentList != null){\n          return getThrownExceptions(argumentList);\n        }\n      }\n      // filter class declaration in code\n      return Collections.emptyList();\n    }\n    else if (element instanceof PsiMethodCallExpression) {\n      PsiReferenceExpression methodRef = ((PsiMethodCallExpression)element).getMethodExpression();\n      JavaResolveResult result = methodRef.advancedResolve(false);\n      return getExceptionsByMethodAndChildren(element, result);\n    }\n    else if (element instanceof PsiNewExpression) {\n      JavaResolveResult result = ((PsiNewExpression)element).resolveMethodGenerics();\n      return getExceptionsByMethodAndChildren(element, result);\n    }\n    else if (element instanceof PsiThrowStatement) {\n      final PsiExpression expr = ((PsiThrowStatement)element).getException();\n      if (expr == null) return Collections.emptyList();\n      final List<PsiType> types = getPreciseThrowTypes(expr);\n      List<PsiClassType> classTypes =\n        new ArrayList<PsiClassType>(ContainerUtil.mapNotNull(types, new NullableFunction<PsiType, PsiClassType>() {\n          @Override\n          public PsiClassType fun(PsiType type) {\n            return type instanceof PsiClassType ? (PsiClassType)type : null;\n          }\n        }));\n      addExceptions(classTypes, getThrownExceptions(expr));\n      return classTypes;\n    }\n    else if (element instanceof PsiTryStatement) {\n      return getTryExceptions((PsiTryStatement)element);\n    }\n    else if (element instanceof PsiResourceVariable) {\n      final PsiResourceVariable variable = (PsiResourceVariable)element;\n      final List<PsiClassType> types = ContainerUtil.newArrayList();\n      addExceptions(types, getCloserExceptions(variable));\n      final PsiExpression initializer = variable.getInitializer();\n      if (initializer != null) addExceptions(types, getThrownExceptions(initializer));\n      return types;\n    }\n    return getThrownExceptions(element.getChildren());\n  }","commit_id":"c0e9048f558c9daf31b19ac4d83404ccbc74b3b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t    result.setEntryNr( nr );\n\n        LogWriter logwriter = log;\n        \n        Log4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), \"Unable to open file appender for file [\"+getLogFilename()+\"] : \"+e.toString());\n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n\n            logwriter = LogWriter.getInstance(environmentSubstitute(getLogFilename()), true, loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobJob.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\n        try\n        {\n            // First load the job, outside of the loop...\n        \tif ( parentJob.getJobMeta() != null )\n        \t{\n        \t\t// reset the internal variables again.\n        \t\t// Maybe we should split up the variables even more like in UNIX shells.\n        \t\t// The internal variables need to be reset to be able use them properly in 2 sequential sub jobs.\n        \t\tparentJob.getJobMeta().setInternalKettleVariables();\n        \t}\n\n            JobMeta jobMeta = null;\n            boolean fromRepository = rep!=null && !Const.isEmpty(jobname) && directory!=null;\n            boolean fromXMLFile = !Const.isEmpty(filename);\n            if (fromRepository) // load from the repository...\n            {\n                if(log.isDetailed()) log.logDetailed(toString(), \"Loading job from repository : [\"+directory+\" : \"+environmentSubstitute(jobname)+\"]\");\n                jobMeta = new JobMeta(logwriter, rep, environmentSubstitute(jobname), rep.getDirectoryTree().findDirectory(environmentSubstitute(directory)));\n                jobMeta.setParentVariableSpace(parentJob);\n            }\n            else // Get it from the XML file\n            if (fromXMLFile)\n            {\n            \tif(log.isDetailed()) log.logDetailed(toString(), \"Loading job from XML file : [\"+environmentSubstitute(filename)+\"]\");\n                jobMeta = new JobMeta(logwriter, environmentSubstitute(filename), rep, null);\n                jobMeta.setParentVariableSpace(parentJob);\n            }\n\n            if (jobMeta==null)\n            {\n                throw new KettleException(\"Unable to load the job: please specify the name and repository directory OR a filename\");\n            }\n            \n            verifyRecursiveExecution(parentJob, jobMeta);\n    \t\t\n            // Tell logging what job entry we are launching...\n            if (fromRepository)\n            {\n                if(log.isBasic()) log.logBasic(toString(), \"Starting job, loaded from repository : [\"+directory+\" : \"+environmentSubstitute(jobname)+\"]\");\n            }\n            else\n            if (fromXMLFile)\n            {\n            \tif(log.isDetailed()) log.logDetailed(toString(), \"Starting job, loaded from XML file : [\"+environmentSubstitute(filename)+\"]\");\n            }\n\n            int iteration = 0;\n            String args1[] = arguments;\n            if (args1==null || args1.length==0) // no arguments?  Check the parent jobs arguments\n            {\n                args1 = parentJob.getJobMeta().getArguments();\n            }\n\n            copyVariablesFrom(parentJob);\n            setParentVariableSpace(parentJob);\r\n\n            //\n            // For the moment only do variable translation at the start of a job, not\n            // for every input row (if that would be switched on)\n            //\n            String args[] = null;\n            if ( args1 != null )\n            {\n                args = new String[args1.length];\n                for ( int idx = 0; idx < args1.length; idx++ )\n                {\n                \targs[idx] = environmentSubstitute(args1[idx]);\n                }\n            }\r\n            \r\n            NamedParams namedParam = new NamedParamsDefault();\r\n            if ( parameters != null )  {\r\n            \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                {\r\n            \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n            \t\t\t\r\n            \t\t\t// We have a parameter            \t\t\t\r\n            \t\t\ttry {\r\n\t\t\t\t\t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n\t\t\t\t\t\t} catch (DuplicateParamException e) {\r\n\t\t\t\t\t\t\tlog.logError(toString(), \"Duplicate parameter definition for \" + parameters[idx]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n            \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n            \t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n\t\t\t\t                     Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n            \t\t\t}            \t\t\t\t            \t\t\r\n            \t\t\telse  {\r\n            \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n            \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n            \t\t\t}\r\n            \t\t}                                \r\n                }\r\n            }\r\n\n            RowMetaAndData resultRow = null;\n            boolean first = true;\n            List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n\n            while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) )\n            {\r\n            \tif (execPerRow)\r\n            \t{\r\n            \t\tresult.getRows().clear();\r\n            \t}\n                first=false;\n                if (rows!=null && execPerRow)\n                {\n                \tresultRow = (RowMetaAndData) rows.get(iteration);\n                }\n                else\n                {\n                \tresultRow = null;\n                }\n                \n                Result oneResult = new Result();\n            \t\n            \tList<RowMetaAndData> sourceRows = null;\n                \n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n                        sourceRows = newList;\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \t\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n                    \t\t\t\t\t\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\t                     Const.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Keep it as it was...\n                        sourceRows = result.getRows();\n                    }\r\n                    \r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \t\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n                    \t\t\t\t\t\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\t                     Const.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n\n                if (remoteSlaveServer==null)\n                {\n                \t// Local execution...\n                \t//\n                \t\n\t                // Create a new job\n\t                Job job = new Job(logwriter, StepLoader.getInstance(), rep, jobMeta);\n\t\n\t                job.shareVariablesWith(this);\r\n\t                job.setInternalKettleVariables(this);\r\n\t                job.copyParametersFrom(jobMeta);\r\n\t                \r\n\t                // Set the parameters calculated above on this instance.\r\n\t                job.clearParameters();\r\n\t                String[] parameterNames = job.listParameters();\r\n\t                for (int idx = 0; idx < parameterNames.length; idx++)  {\r\n\t                    String thisValue = namedParam.getParameterValue(parameterNames[idx]);\r\n\t                    job.setParameterValue(parameterNames[idx], thisValue);\r\n\t                }\r\n\t                job.activateParameters();\r\n\t                \n\t                // Set the source rows we calculated above...\n\t                //\n\t                job.setSourceRows(sourceRows);\n\t\n\t                // Don't forget the logging...\n\t                job.beginProcessing();\n\t\n\t                // Link the job with the sub-job\n\t                parentJob.getJobTracker().addJobTracker(job.getJobTracker());\n\t\n\t                // Link both ways!\n\t                job.getJobTracker().setParentJobTracker(parentJob.getJobTracker());\n\t\n\t                // Tell this sub-job about its parent...\n\t                job.setParentJob(parentJob);\n\t\n\t                if (parentJob.getJobMeta().isBatchIdPassed())\n\t                {\n\t                    job.setPassedBatchId(parentJob.getBatchId());\n\t                }\n\t\n\t\n\t                job.getJobMeta().setArguments( args );\t               \n\t\n\t                JobEntryJobRunner runner = new JobEntryJobRunner( job, result, nr);\n\t    \t\t\tThread jobRunnerThread = new Thread(runner);\n\t                jobRunnerThread.setName( Const.NVL(job.getJobMeta().getName(), job.getJobMeta().getFilename()) );\n\t                jobRunnerThread.start();\n\t\n\t                try\n\t                {\n\t        \t\t\twhile (!runner.isFinished() && !parentJob.isStopped())\n\t        \t\t\t{\n\t        \t\t\t\ttry { Thread.sleep(0,1);}\n\t        \t\t\t\tcatch(InterruptedException e) { }\n\t        \t\t\t}\n\t\n\t        \t\t\t// if the parent-job was stopped, stop the sub-job too...\n\t        \t\t\tif (parentJob.isStopped())\n\t        \t\t\t{\n\t        \t\t\t\tjob.stopAll();\n\t        \t\t\t\trunner.waitUntilFinished(); // Wait until finished!\n\t        \t\t\t\tjob.endProcessing(\"stop\", new Result()); // dummy result\n\t        \t\t\t}\n\t        \t\t\telse\n\t        \t\t\t{\n\t        \t\t\t\tjob.endProcessing(Database.LOG_STATUS_END, runner.getResult()); // the result of the execution to be stored in the log file.\n\t        \t\t\t}\n\t                }\n\t        \t\tcatch(KettleException je)\n\t        \t\t{\n\t        \t\t\tlog.logError(toString(), \"Unable to open job entry job with name [\"+getName()+\"] : \"+Const.CR+je.toString());\n\t        \t\t\tresult.setNrErrors(1);\n\t        \t\t}\n\t        \t\t\n\t        \t\toneResult = runner.getResult();\n                }\n                else\n                {\n                \t// Remote execution...\n                \t//\n                \tJobExecutionConfiguration jobExecutionConfiguration = new JobExecutionConfiguration();\n                \tjobExecutionConfiguration.setPreviousResult(result.clone());\n                \tjobExecutionConfiguration.getPreviousResult().setRows(sourceRows);\n                \tjobExecutionConfiguration.setArgumentStrings(args);\n                \tjobExecutionConfiguration.setVariables(this);\n                \tjobExecutionConfiguration.setRemoteServer(remoteSlaveServer);\n                \tjobExecutionConfiguration.setRepository(rep);\n                \tjobExecutionConfiguration.setLogLevel(log.getLogLevel());\r\n\n                \t// Send the XML over to the slave server\n                \t// Also start the job over there...\n                \t//\r\n                \ttry {\n                \t\tJob.sendXMLToSlaveServer(jobMeta, jobExecutionConfiguration);\r\n                \t} catch(KettleException e) {\r\n                \t\t// Perhaps the job exists on the remote server, carte is down, etc.\r\n                \t\t// This is an abort situation, stop the parent job...\r\n                \t\t// We want this in case we are running in parallel.  The other job entries can stop running now.\r\n                \t\t// \r\n                \t\tparentJob.stopAll();\r\n                \t\t\r\n                \t\t// Pass the exception along\r\n                \t\t// \r\n                \t\tthrow e;\r\n                \t}\r\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerJobStatus jobStatus=null;\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\tjobStatus = remoteSlaveServer.getJobStatus(jobMeta.getName());\n\t\t\t\t\t\t\tif (jobStatus.getResult()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The job is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\toneResult = jobStatus.getResult();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\n\t\t\t\t\t\t\tlog.logError(toString(), \"Unable to contact slave server [\"+remoteSlaveServer+\"] to verify the status of job [\"+jobMeta.getName()+\"]\");\n\t\t\t\t\t\t\toneResult.setNrErrors(1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(10000); } catch(InterruptedException e) {} ; // sleep for 10 seconds\n                \t}\r\n                \t\r\n                \tif (!waitingToFinish) {\r\n                \t\t// Since the job was posted successfully, the result is true...\r\n                \t\t//\r\n                \t\toneResult = new Result();\r\n                \t\toneResult.setResult(true);\r\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\ttry \r\n                \t\t{\r\n\t                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n\t                \t\t// \r\n\t                \t\tif (jobStatus==null || jobStatus.isRunning()) {\r\n\t                \t\t\t// Try a remote abort ...\r\n\t                \t\t\t//\r\n\t                \t\t\tremoteSlaveServer.stopJob(jobMeta.getName());\r\n\t                \t\t}\r\n                \t\t}\r\n                \t\tcatch (Exception e1) {\r\n\t\t\t\t\t\t\tlog.logError(toString(), \"Unable to contact slave server [\"+remoteSlaveServer+\"] to stop job [\"+jobMeta.getName()+\"]\");\r\n\t\t\t\t\t\t\toneResult.setNrErrors(1L);\r\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\r\n\t\t\t\t\t\t}\r\n                \t}\r\n\n                }\n                \n                if (iteration==0)\n                {\n                    result.clear();\n                }\n                \n                result.add(oneResult);\n                if (oneResult.getResult()==false) // if one of them fails, set the number of errors\n                {\n                    result.setNrErrors(result.getNrErrors()+1);\n                }\n\n                iteration++;\n            }\n\n        }\n        catch(KettleException ke)\n        {\n            log.logError(toString(), \"Error running job entry 'job' : \"+ke.toString());\n            log.logError(toString(), Const.getStackTracker(ke));\n\n            result.setResult(false);\n            result.setNrErrors(1L);\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n\n        }\n\n        if (result.getNrErrors() > 0)\n        {\n            result.setResult( false );\n        }\n        else\n        {\n            result.setResult( true );\n        }\n\n        return result;\n\t}","id":40843,"modified_method":"public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t    result.setEntryNr( nr );\n\n        LogWriter logwriter = log;\n        \n        Log4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), \"Unable to open file appender for file [\"+getLogFilename()+\"] : \"+e.toString());\n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n\n            logwriter = LogWriter.getInstance(environmentSubstitute(getLogFilename()), true, loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobJob.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\n        try\n        {\n            // First load the job, outside of the loop...\n        \tif ( parentJob.getJobMeta() != null )\n        \t{\n        \t\t// reset the internal variables again.\n        \t\t// Maybe we should split up the variables even more like in UNIX shells.\n        \t\t// The internal variables need to be reset to be able use them properly in 2 sequential sub jobs.\n        \t\tparentJob.getJobMeta().setInternalKettleVariables();\n        \t}\n\n            JobMeta jobMeta = null;\n            boolean fromRepository = rep!=null && !Const.isEmpty(jobname) && directory!=null;\n            boolean fromXMLFile = !Const.isEmpty(filename);\n            if (fromRepository) // load from the repository...\n            {\n                if(log.isDetailed()) log.logDetailed(toString(), \"Loading job from repository : [\"+directory+\" : \"+environmentSubstitute(jobname)+\"]\");\n                jobMeta = new JobMeta(logwriter, rep, environmentSubstitute(jobname), rep.getDirectoryTree().findDirectory(environmentSubstitute(directory)));\n                jobMeta.setParentVariableSpace(parentJob);\n            }\n            else // Get it from the XML file\n            if (fromXMLFile)\n            {\n            \tif(log.isDetailed()) log.logDetailed(toString(), \"Loading job from XML file : [\"+environmentSubstitute(filename)+\"]\");\n                jobMeta = new JobMeta(logwriter, environmentSubstitute(filename), rep, null);\n                jobMeta.setParentVariableSpace(parentJob);\n            }\n\n            if (jobMeta==null)\n            {\n                throw new KettleException(\"Unable to load the job: please specify the name and repository directory OR a filename\");\n            }\n            \n            verifyRecursiveExecution(parentJob, jobMeta);\n    \t\t\n            // Tell logging what job entry we are launching...\n            if (fromRepository)\n            {\n                if(log.isBasic()) log.logBasic(toString(), \"Starting job, loaded from repository : [\"+directory+\" : \"+environmentSubstitute(jobname)+\"]\");\n            }\n            else\n            if (fromXMLFile)\n            {\n            \tif(log.isDetailed()) log.logDetailed(toString(), \"Starting job, loaded from XML file : [\"+environmentSubstitute(filename)+\"]\");\n            }\n\n            int iteration = 0;\n            String args1[] = arguments;\n            if (args1==null || args1.length==0) // no arguments?  Check the parent jobs arguments\n            {\n                args1 = parentJob.getJobMeta().getArguments();\n            }\n\n            copyVariablesFrom(parentJob);\n            setParentVariableSpace(parentJob);\r\n\n            //\n            // For the moment only do variable translation at the start of a job, not\n            // for every input row (if that would be switched on)\n            //\n            String args[] = null;\n            if ( args1 != null )\n            {\n                args = new String[args1.length];\n                for ( int idx = 0; idx < args1.length; idx++ )\n                {\n                \targs[idx] = environmentSubstitute(args1[idx]);\n                }\n            }\r\n            \r\n            NamedParams namedParam = new NamedParamsDefault();\r\n            if ( parameters != null )  {\r\n            \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                {\r\n            \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n            \t\t\t\r\n            \t\t\t// We have a parameter            \t\t\t\r\n            \t\t\ttry {\r\n\t\t\t\t\t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n\t\t\t\t\t\t} catch (DuplicateParamException e) {\r\n\t\t\t\t\t\t\tlog.logError(toString(), \"Duplicate parameter definition for \" + parameters[idx]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n            \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n            \t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n\t\t\t\t                     Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n            \t\t\t}            \t\t\t\t            \t\t\r\n            \t\t\telse  {\r\n            \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n            \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n            \t\t\t}\r\n            \t\t}                                \r\n                }\r\n            }\r\n\n            RowMetaAndData resultRow = null;\n            boolean first = true;\n            List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n\n            while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) )\n            {\r\n            \tif (execPerRow)\r\n            \t{\r\n            \t\tresult.getRows().clear();\r\n            \t}\n                first=false;\n                if (rows!=null && execPerRow)\n                {\n                \tresultRow = (RowMetaAndData) rows.get(iteration);\n                }\n                else\n                {\n                \tresultRow = null;\n                }\n                \n                Result oneResult = new Result();\n            \t\n            \tList<RowMetaAndData> sourceRows = null;\n                \n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n                        sourceRows = newList;\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \t\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n                    \t\t\t\t\t\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\t                     Const.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Keep it as it was...\n                        sourceRows = result.getRows();\n                    }\r\n                    \r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \t\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n                    \t\t\t\t\t\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\t                     Const.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n\n                if (remoteSlaveServer==null)\n                {\n                \t// Local execution...\n                \t//\n                \t\n\t                // Create a new job\n\t                Job job = new Job(logwriter, StepLoader.getInstance(), rep, jobMeta);\n\t\n\t                job.shareVariablesWith(this);\r\n\t                job.setInternalKettleVariables(this);\r\n\t                job.copyParametersFrom(jobMeta);\r\n\t                \r\n\t                // Set the parameters calculated above on this instance.\r\n\t                //\r\n\t                job.clearParameters();\r\n\t                String[] parameterNames = job.listParameters();\r\n\t                for (int idx = 0; idx < parameterNames.length; idx++)  {\r\n\t                \t// Grab the parameter value set in the job entry\r\n\t                \t//\r\n\t                    String thisValue = namedParam.getParameterValue(parameterNames[idx]);\r\n\t                    if (!Const.isEmpty(thisValue)) {\r\n\t                    \t// Set the value as specified by the user in the job entry\r\n\t                    \t//\r\n\t                    \tjob.setParameterValue(parameterNames[idx], thisValue);\r\n\t                    } else {\r\n\t                    \t// See if the parameter had a value set in the parent job...\r\n\t                    \t// This value should pass down to the sub-job...\r\n\t                    \t//\r\n\t                    \tString parentValue = parentJob.getParameterValue(parameterNames[idx]);\r\n\t                    \tif (!Const.isEmpty(parentValue)) {\r\n\t                    \t\tjob.setParameterValue(parameterNames[idx], parentValue);\r\n\t                    \t}\r\n\t                    }\r\n\t                }\r\n\t                job.activateParameters();\r\n\t                \n\t                // Set the source rows we calculated above...\n\t                //\n\t                job.setSourceRows(sourceRows);\n\t\n\t                // Don't forget the logging...\n\t                job.beginProcessing();\n\t\n\t                // Link the job with the sub-job\n\t                parentJob.getJobTracker().addJobTracker(job.getJobTracker());\n\t\n\t                // Link both ways!\n\t                job.getJobTracker().setParentJobTracker(parentJob.getJobTracker());\n\t\n\t                // Tell this sub-job about its parent...\n\t                job.setParentJob(parentJob);\n\t\n\t                if (parentJob.getJobMeta().isBatchIdPassed())\n\t                {\n\t                    job.setPassedBatchId(parentJob.getBatchId());\n\t                }\n\t\n\t\n\t                job.getJobMeta().setArguments( args );\t               \n\t\n\t                JobEntryJobRunner runner = new JobEntryJobRunner( job, result, nr);\n\t    \t\t\tThread jobRunnerThread = new Thread(runner);\n\t                jobRunnerThread.setName( Const.NVL(job.getJobMeta().getName(), job.getJobMeta().getFilename()) );\n\t                jobRunnerThread.start();\n\t\n\t                try\n\t                {\n\t        \t\t\twhile (!runner.isFinished() && !parentJob.isStopped())\n\t        \t\t\t{\n\t        \t\t\t\ttry { Thread.sleep(0,1);}\n\t        \t\t\t\tcatch(InterruptedException e) { }\n\t        \t\t\t}\n\t\n\t        \t\t\t// if the parent-job was stopped, stop the sub-job too...\n\t        \t\t\tif (parentJob.isStopped())\n\t        \t\t\t{\n\t        \t\t\t\tjob.stopAll();\n\t        \t\t\t\trunner.waitUntilFinished(); // Wait until finished!\n\t        \t\t\t\tjob.endProcessing(\"stop\", new Result()); // dummy result\n\t        \t\t\t}\n\t        \t\t\telse\n\t        \t\t\t{\n\t        \t\t\t\tjob.endProcessing(Database.LOG_STATUS_END, runner.getResult()); // the result of the execution to be stored in the log file.\n\t        \t\t\t}\n\t                }\n\t        \t\tcatch(KettleException je)\n\t        \t\t{\n\t        \t\t\tlog.logError(toString(), \"Unable to open job entry job with name [\"+getName()+\"] : \"+Const.CR+je.toString());\n\t        \t\t\tresult.setNrErrors(1);\n\t        \t\t}\n\t        \t\t\n\t        \t\toneResult = runner.getResult();\n                }\n                else\n                {\n                \t// Remote execution...\n                \t//\n                \tJobExecutionConfiguration jobExecutionConfiguration = new JobExecutionConfiguration();\n                \tjobExecutionConfiguration.setPreviousResult(result.clone());\n                \tjobExecutionConfiguration.getPreviousResult().setRows(sourceRows);\n                \tjobExecutionConfiguration.setArgumentStrings(args);\n                \tjobExecutionConfiguration.setVariables(this);\n                \tjobExecutionConfiguration.setRemoteServer(remoteSlaveServer);\n                \tjobExecutionConfiguration.setRepository(rep);\n                \tjobExecutionConfiguration.setLogLevel(log.getLogLevel());\r\n\n                \t// Send the XML over to the slave server\n                \t// Also start the job over there...\n                \t//\r\n                \ttry {\n                \t\tJob.sendXMLToSlaveServer(jobMeta, jobExecutionConfiguration);\r\n                \t} catch(KettleException e) {\r\n                \t\t// Perhaps the job exists on the remote server, carte is down, etc.\r\n                \t\t// This is an abort situation, stop the parent job...\r\n                \t\t// We want this in case we are running in parallel.  The other job entries can stop running now.\r\n                \t\t// \r\n                \t\tparentJob.stopAll();\r\n                \t\t\r\n                \t\t// Pass the exception along\r\n                \t\t// \r\n                \t\tthrow e;\r\n                \t}\r\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerJobStatus jobStatus=null;\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\tjobStatus = remoteSlaveServer.getJobStatus(jobMeta.getName());\n\t\t\t\t\t\t\tif (jobStatus.getResult()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The job is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\toneResult = jobStatus.getResult();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\n\t\t\t\t\t\t\tlog.logError(toString(), \"Unable to contact slave server [\"+remoteSlaveServer+\"] to verify the status of job [\"+jobMeta.getName()+\"]\");\n\t\t\t\t\t\t\toneResult.setNrErrors(1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(10000); } catch(InterruptedException e) {} ; // sleep for 10 seconds\n                \t}\r\n                \t\r\n                \tif (!waitingToFinish) {\r\n                \t\t// Since the job was posted successfully, the result is true...\r\n                \t\t//\r\n                \t\toneResult = new Result();\r\n                \t\toneResult.setResult(true);\r\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\ttry \r\n                \t\t{\r\n\t                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n\t                \t\t// \r\n\t                \t\tif (jobStatus==null || jobStatus.isRunning()) {\r\n\t                \t\t\t// Try a remote abort ...\r\n\t                \t\t\t//\r\n\t                \t\t\tremoteSlaveServer.stopJob(jobMeta.getName());\r\n\t                \t\t}\r\n                \t\t}\r\n                \t\tcatch (Exception e1) {\r\n\t\t\t\t\t\t\tlog.logError(toString(), \"Unable to contact slave server [\"+remoteSlaveServer+\"] to stop job [\"+jobMeta.getName()+\"]\");\r\n\t\t\t\t\t\t\toneResult.setNrErrors(1L);\r\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\r\n\t\t\t\t\t\t}\r\n                \t}\r\n\n                }\n                \n                if (iteration==0)\n                {\n                    result.clear();\n                }\n                \n                result.add(oneResult);\n                if (oneResult.getResult()==false) // if one of them fails, set the number of errors\n                {\n                    result.setNrErrors(result.getNrErrors()+1);\n                }\n\n                iteration++;\n            }\n\n        }\n        catch(KettleException ke)\n        {\n            log.logError(toString(), \"Error running job entry 'job' : \"+ke.toString());\n            log.logError(toString(), Const.getStackTracker(ke));\n\n            result.setResult(false);\n            result.setNrErrors(1L);\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n\n        }\n\n        if (result.getNrErrors() > 0)\n        {\n            result.setResult( false );\n        }\n        else\n        {\n            result.setResult( true );\n        }\n\n        return result;\n\t}","commit_id":"dba43415356a6820a9728f4905d68cab49220e3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Execute this job entry and return the result.\n     * In this case it means, just set the result boolean in the Result class.\n     * @param result The result of the previous execution\n     * @param nr the job entry number\n     * @param rep the repository connection to use\n     * @param parentJob the parent job\n     * @return The Result of the execution.\n     */\n    public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t\tLogWriter log       = LogWriter.getInstance();\n\t\tresult.setEntryNr( nr );\n\n\t\tLog4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\r\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), Messages.getString(\"JobTrans.Error.UnableOpenAppender\",getLogFilename(),e.toString()));\r\n                \n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobTrans.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\r\n        \n\t\t// Open the transformation...\n\t\t// Default directory for now...\n        // XXX: This seems a bit odd here.  These three log messages all work off of getFilename().  Why are there three?\n        if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningFile\",environmentSubstitute(getFilename())));\r\n        if (!Const.isEmpty(getFilename()))\n        {\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTrans\",environmentSubstitute(getFilename())));\n        }\n        else\n        {\r\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTransInDirec\",environmentSubstitute(getFilename()),environmentSubstitute(directory)));\n        }\n\n        // Load the transformation only once for the complete loop!\r\n    \t// Throws an exception if it was not possible to load the transformation.  For example, the XML file doesn't exist or the repository is down.\r\n    \t// Log the stack trace and return an error condition from this\r\n        //\r\n        TransMeta transMeta = getTransMeta(rep);\r\n\n        int iteration = 0;\n        String args1[] = arguments;\n        if (args1==null || args1.length==0) // No arguments set, look at the parent job.\n        {\n            args1 = parentJob.getJobMeta().getArguments();\n        }\n        //initializeVariablesFrom(parentJob);\n\n        //\n        // For the moment only do variable translation at the start of a job, not\n        // for every input row (if that would be switched on). This is for safety,\n        // the real argument setting is later on.\n        //\n        String args[] = null;\n        if ( args1 != null )\n        {\n            args = new String[args1.length];\n            for ( int idx = 0; idx < args1.length; idx++ )\n            {\n            \targs[idx] = environmentSubstitute(args1[idx]);\n            }\n        }\n\r\n        NamedParams namedParam = new NamedParamsDefault();\r\n        if ( parameters != null )  {\r\n        \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n            {\r\n        \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n        \t\t\t// We have a parameter\r\n        \t\t\t\r\n        \t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n        \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n\t\t\t                     Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n        \t\t\t}            \t\t\t\t            \t\t\r\n        \t\t\telse  {\r\n        \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n        \t\t\t}\r\n        \t\t}                                \r\n            }\r\n        }\r\n                \n        RowMetaAndData resultRow = null;\n        boolean first = true;\n        List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n        while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) && !parentJob.isStopped() )\n        {\r\n            if (execPerRow)\r\n            {\r\n            \tresult.getRows().clear(); // Otherwise we double the amount of rows every iteration in the simple cases.\r\n            }\r\n            \n            first=false;\n            if (rows!=null && execPerRow)\n            {\n            \tresultRow = rows.get(iteration);\n            }\n            else\n            {\n            \tresultRow = null;\n            }\n\n    \t\ttry\n    \t\t{\n                if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.StartingTrans\",getFilename(),getName(),getDescription()));\n\n                // Set the result rows for the next one...\n                transMeta.setPreviousResult(result);\n\n                if (clearResultRows)\n                {\n                    transMeta.getPreviousResult().setRows(new ArrayList<RowMetaAndData>());\n                }\n\n                if (clearResultFiles)\n                {\n                    transMeta.getPreviousResult().getResultFiles().clear();\n                }\n\n                /*\n                 * Set one or more \"result\" rows on the transformation...\n                 */\n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n\n                        // This previous result rows list can be either empty or not.\n                        // Depending on the checkbox \"clear result rows\"\n                        // In this case, it would execute the transformation with one extra row each time\n                        // Can't figure out a real use-case for it, but hey, who am I to decide that, right?\n                        // :-)\n                        //\n                        transMeta.getPreviousResult().getRows().addAll(newList);\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                    \t// do nothing\n                    }\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n\n                // Execute this transformation across a cluster of servers\n                //\n                if (clustering)\n                {\n                    TransExecutionConfiguration executionConfiguration = new TransExecutionConfiguration();\n                    executionConfiguration.setClusterPosting(true);\n                    executionConfiguration.setClusterPreparing(true);\n                    executionConfiguration.setClusterStarting(true);\n                    executionConfiguration.setClusterShowingTransformation(false);\n                    executionConfiguration.setSafeModeEnabled(false);\n                    executionConfiguration.setRepository(rep);\r\n                    \r\n                    // Also pass the variables from the transformation into the execution configuration\r\n                    // That way it can go over the HTTP connection to the slave server.\r\n                    //\r\n                    executionConfiguration.setVariables(transMeta);\r\n                    \r\n                    // Also set the arguments...\r\n                    //\r\n                    executionConfiguration.setArgumentStrings(args);\n                    \n                    TransSplitter transSplitter = Trans.executeClustered(transMeta, executionConfiguration );\n                    \n                    // Monitor the running transformations, wait until they are done.\n                    // Also kill them all if anything goes bad\n                    // Also clean up afterwards...\n                    //\n                    long errors = Trans.monitorClusteredTransformation(toString(), transSplitter, parentJob);\n                    \n                    Result clusterResult = Trans.getClusteredTransformationResult(toString(), transSplitter, parentJob); \n                    result.clear();\n                    result.add(clusterResult);\n                    \n                    result.setNrErrors(result.getNrErrors()+errors);\n\n                }\n                // Execute this transformation remotely\n                //\n                else if (remoteSlaveServer!=null)\n                {\n                \t// Remote execution...\n                \t//\n                \tTransExecutionConfiguration transExecutionConfiguration = new TransExecutionConfiguration();\n                \ttransExecutionConfiguration.setPreviousResult(transMeta.getPreviousResult().clone());\n                \ttransExecutionConfiguration.setArgumentStrings(args);\n                \ttransExecutionConfiguration.setVariables(this);\n                \ttransExecutionConfiguration.setRemoteServer(remoteSlaveServer);\r\n                \ttransExecutionConfiguration.setLogLevel(log.getLogLevel());\n                \t\n                \t// Send the XML over to the slave server\n                \t// Also start the transformation over there...\n                \t//\n                \tTrans.sendXMLToSlaveServer(transMeta, transExecutionConfiguration);\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerTransStatus transStatus=null;\r\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\ttransStatus = remoteSlaveServer.getTransStatus(transMeta.getName());\n\t\t\t\t\t\t\tif (!transStatus.isRunning())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The transformation is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tResult remoteResult = transStatus.getResult(); \n\t\t\t                    result.clear();\n\t\t\t                    result.add(remoteResult);\r\n\t\t\t                    \r\n\t\t\t                    // In case you manually stop the remote trans (browser etc), make sure it's marked as an error\r\n\t\t\t                    //\r\n\t\t\t                    if (remoteResult.isStopped()) {\r\n\t\t\t                    \tresult.setNrErrors(result.getNrErrors()+1); //\r\n\t\t\t                    }\r\n\t\t\t                    \r\n\t\t\t                    // Make sure to clean up : write a log record etc, close any left-over sockets etc.\r\n\t\t\t                    //\r\n\t\t\t                    remoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n\t\t\t                    \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\r\n                \t\t\t\n\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.Error.UnableContactSlaveServer\",\"\"+remoteSlaveServer,transMeta.getName()));\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(2000); } catch(InterruptedException e) {} ; // sleep for 2 seconds\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n                \t\t// \r\n                \t\tif (transStatus==null || transStatus.isRunning()) {\r\n                \t\t\t// Try a remote abort ...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.stopTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// And a cleanup...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// Set an error state!\r\n                \t\t\t//\r\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\r\n                \t\t}\r\n                \t}\n                }\n                // Execute this transformation on the local machine\n                //\n                else // Local execution...\n                {\r\n                \ttransMeta.copyParametersFrom(namedParam);\r\n                \t\n                    // Create the transformation from meta-data\n                    Trans trans = new Trans(transMeta);\n\n                    if (parentJob.getJobMeta().isBatchIdPassed())\n                    {\n                        trans.setPassedBatchId(parentJob.getPassedBatchId());\n                    }\n                    \n                    // set the parent job on the transformation, variables are taken from here...\n                    trans.setParentJob(parentJob);\n                    trans.setParentVariableSpace(parentJob);                    \n\n                    // First get the root job\n                    //\n                    Job rootJob = parentJob;\n                    while (rootJob.getParentJob()!=null) rootJob=rootJob.getParentJob();\n                    \n                    // Get the start and end-date from the root job...\n                    //\n                    trans.setJobStartDate( rootJob.getStartDate() );\n                    trans.setJobEndDate( rootJob.getEndDate() );\n                    \n                    try {\n            \t\t\t// Start execution...\n                    \t//\n                    \ttrans.execute(args);\n\n                    \t// Wait until we're done with it...\n                    \t//\n        \t\t\t\twhile (!trans.isFinished() && !parentJob.isStopped() && trans.getErrors() == 0)\n        \t\t\t\t{\n        \t\t\t\t\ttry { Thread.sleep(0,500);}\n        \t\t\t\t\tcatch(InterruptedException e) { }\n        \t\t\t\t}\n\n        \t\t\t\tif (parentJob.isStopped() || trans.getErrors() != 0)\n        \t\t\t\t{\n        \t\t\t\t\ttrans.stopAll();\n        \t\t\t\t\ttrans.waitUntilFinished();\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_STOP);\n                            result.setNrErrors(1);\n        \t\t\t\t}\n        \t\t\t\telse\n        \t\t\t\t{\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n        \t\t\t\t}\n        \t\t\t\tResult newResult = trans.getResult();\n\n                        result.clear(); // clear only the numbers, NOT the files or rows.\n                        result.add(newResult);\n\n                        // Set the result rows too...\n                        result.setRows(newResult.getRows());\n\n                        if (setLogfile)\n                        {\n                        \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, KettleVFS.getFileObject(getLogFilename()), parentJob.getJobname(), toString());\n                            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n        \t\t\t\t}\n                    }\n                    catch (KettleException e) {\r\n                    \t\n                        log.logError(toString(), Messages.getString(\"JobTrans.Error.UnablePrepareExec\"), e);\n        \t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t}\n                }\n    \t\t}\n    \t\tcatch(Exception e)\n    \t\t{\r\n    \t\t\t\n    \t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.ErrorUnableOpenTrans\",e.getMessage()));\n                log.logError(toString(), Const.getStackTracker(e));\n    \t\t\tresult.setNrErrors(1);\n    \t\t}\n            iteration++;\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n        }\n\n\t\tif (result.getNrErrors()==0)\n\t\t{\n\t\t\tresult.setResult( true );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t}\n\n\t\t// Hint the VM to release handles.\n\t\tSystem.gc();\n\t\t\n\t\treturn result;\n\t}","id":40844,"modified_method":"/**\n     * Execute this job entry and return the result.\n     * In this case it means, just set the result boolean in the Result class.\n     * @param result The result of the previous execution\n     * @param nr the job entry number\n     * @param rep the repository connection to use\n     * @param parentJob the parent job\n     * @return The Result of the execution.\n     */\n    public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t\tLogWriter log       = LogWriter.getInstance();\n\t\tresult.setEntryNr( nr );\n\n\t\tLog4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\r\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), Messages.getString(\"JobTrans.Error.UnableOpenAppender\",getLogFilename(),e.toString()));\r\n                \n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobTrans.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\r\n        \n\t\t// Open the transformation...\n\t\t// Default directory for now...\n        // XXX: This seems a bit odd here.  These three log messages all work off of getFilename().  Why are there three?\n        if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningFile\",environmentSubstitute(getFilename())));\r\n        if (!Const.isEmpty(getFilename()))\n        {\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTrans\",environmentSubstitute(getFilename())));\n        }\n        else\n        {\r\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTransInDirec\",environmentSubstitute(getFilename()),environmentSubstitute(directory)));\n        }\n\n        // Load the transformation only once for the complete loop!\r\n    \t// Throws an exception if it was not possible to load the transformation.  For example, the XML file doesn't exist or the repository is down.\r\n    \t// Log the stack trace and return an error condition from this\r\n        //\r\n        TransMeta transMeta = getTransMeta(rep);\r\n\n        int iteration = 0;\n        String args1[] = arguments;\n        if (args1==null || args1.length==0) // No arguments set, look at the parent job.\n        {\n            args1 = parentJob.getJobMeta().getArguments();\n        }\n        //initializeVariablesFrom(parentJob);\n\n        //\n        // For the moment only do variable translation at the start of a job, not\n        // for every input row (if that would be switched on). This is for safety,\n        // the real argument setting is later on.\n        //\n        String args[] = null;\n        if ( args1 != null )\n        {\n            args = new String[args1.length];\n            for ( int idx = 0; idx < args1.length; idx++ )\n            {\n            \targs[idx] = environmentSubstitute(args1[idx]);\n            }\n        }\n\r\n        NamedParams namedParam = new NamedParamsDefault();\r\n        if ( parameters != null )  {\r\n        \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n            {\r\n        \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n        \t\t\t// We have a parameter\r\n        \t\t\t\r\n        \t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n        \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n\t\t\t                     Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n        \t\t\t}            \t\t\t\t            \t\t\r\n        \t\t\telse  {\r\n        \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n        \t\t\t}\r\n        \t\t}                                \r\n            }\r\n        }\r\n                \n        RowMetaAndData resultRow = null;\n        boolean first = true;\n        List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n        while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) && !parentJob.isStopped() )\n        {\r\n            if (execPerRow)\r\n            {\r\n            \tresult.getRows().clear(); // Otherwise we double the amount of rows every iteration in the simple cases.\r\n            }\r\n            \n            first=false;\n            if (rows!=null && execPerRow)\n            {\n            \tresultRow = rows.get(iteration);\n            }\n            else\n            {\n            \tresultRow = null;\n            }\n\n    \t\ttry\n    \t\t{\n                if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.StartingTrans\",getFilename(),getName(),getDescription()));\n\n                // Set the result rows for the next one...\n                transMeta.setPreviousResult(result);\n\n                if (clearResultRows)\n                {\n                    transMeta.getPreviousResult().setRows(new ArrayList<RowMetaAndData>());\n                }\n\n                if (clearResultFiles)\n                {\n                    transMeta.getPreviousResult().getResultFiles().clear();\n                }\n\n                /*\n                 * Set one or more \"result\" rows on the transformation...\n                 */\n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n\n                        // This previous result rows list can be either empty or not.\n                        // Depending on the checkbox \"clear result rows\"\n                        // In this case, it would execute the transformation with one extra row each time\n                        // Can't figure out a real use-case for it, but hey, who am I to decide that, right?\n                        // :-)\n                        //\n                        transMeta.getPreviousResult().getRows().addAll(newList);\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                    \t// do nothing\n                    }\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n\n                // Execute this transformation across a cluster of servers\n                //\n                if (clustering)\n                {\n                    TransExecutionConfiguration executionConfiguration = new TransExecutionConfiguration();\n                    executionConfiguration.setClusterPosting(true);\n                    executionConfiguration.setClusterPreparing(true);\n                    executionConfiguration.setClusterStarting(true);\n                    executionConfiguration.setClusterShowingTransformation(false);\n                    executionConfiguration.setSafeModeEnabled(false);\n                    executionConfiguration.setRepository(rep);\r\n                    \r\n                    // Also pass the variables from the transformation into the execution configuration\r\n                    // That way it can go over the HTTP connection to the slave server.\r\n                    //\r\n                    executionConfiguration.setVariables(transMeta);\r\n                    \r\n                    // Also set the arguments...\r\n                    //\r\n                    executionConfiguration.setArgumentStrings(args);\n                    \n                    TransSplitter transSplitter = Trans.executeClustered(transMeta, executionConfiguration );\n                    \n                    // Monitor the running transformations, wait until they are done.\n                    // Also kill them all if anything goes bad\n                    // Also clean up afterwards...\n                    //\n                    long errors = Trans.monitorClusteredTransformation(toString(), transSplitter, parentJob);\n                    \n                    Result clusterResult = Trans.getClusteredTransformationResult(toString(), transSplitter, parentJob); \n                    result.clear();\n                    result.add(clusterResult);\n                    \n                    result.setNrErrors(result.getNrErrors()+errors);\n\n                }\n                // Execute this transformation remotely\n                //\n                else if (remoteSlaveServer!=null)\n                {\n                \t// Remote execution...\n                \t//\n                \tTransExecutionConfiguration transExecutionConfiguration = new TransExecutionConfiguration();\n                \ttransExecutionConfiguration.setPreviousResult(transMeta.getPreviousResult().clone());\n                \ttransExecutionConfiguration.setArgumentStrings(args);\n                \ttransExecutionConfiguration.setVariables(this);\n                \ttransExecutionConfiguration.setRemoteServer(remoteSlaveServer);\r\n                \ttransExecutionConfiguration.setLogLevel(log.getLogLevel());\n                \t\n                \t// Send the XML over to the slave server\n                \t// Also start the transformation over there...\n                \t//\n                \tTrans.sendXMLToSlaveServer(transMeta, transExecutionConfiguration);\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerTransStatus transStatus=null;\r\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\ttransStatus = remoteSlaveServer.getTransStatus(transMeta.getName());\n\t\t\t\t\t\t\tif (!transStatus.isRunning())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The transformation is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tResult remoteResult = transStatus.getResult(); \n\t\t\t                    result.clear();\n\t\t\t                    result.add(remoteResult);\r\n\t\t\t                    \r\n\t\t\t                    // In case you manually stop the remote trans (browser etc), make sure it's marked as an error\r\n\t\t\t                    //\r\n\t\t\t                    if (remoteResult.isStopped()) {\r\n\t\t\t                    \tresult.setNrErrors(result.getNrErrors()+1); //\r\n\t\t\t                    }\r\n\t\t\t                    \r\n\t\t\t                    // Make sure to clean up : write a log record etc, close any left-over sockets etc.\r\n\t\t\t                    //\r\n\t\t\t                    remoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n\t\t\t                    \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\r\n                \t\t\t\n\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.Error.UnableContactSlaveServer\",\"\"+remoteSlaveServer,transMeta.getName()));\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(2000); } catch(InterruptedException e) {} ; // sleep for 2 seconds\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n                \t\t// \r\n                \t\tif (transStatus==null || transStatus.isRunning()) {\r\n                \t\t\t// Try a remote abort ...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.stopTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// And a cleanup...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// Set an error state!\r\n                \t\t\t//\r\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\r\n                \t\t}\r\n                \t}\n                }\n                // Execute this transformation on the local machine\n                //\n                else // Local execution...\n                {\r\n                \t// transMeta.copyParametersFrom(namedParam);\r\n                \t\r\n\t                transMeta.clearParameters();\r\n\t                String[] parameterNames = transMeta.listParameters();\r\n\t                for (int idx = 0; idx < parameterNames.length; idx++)  {\r\n\t                \t// Grab the parameter value set in the Trans job entry\r\n\t                \t//\r\n\t                    String thisValue = namedParam.getParameterValue(parameterNames[idx]);\r\n\t                    if (!Const.isEmpty(thisValue)) {\r\n\t                    \t// Set the value as specified by the user in the job entry\r\n\t                    \t//\r\n\t                    \ttransMeta.setParameterValue(parameterNames[idx], thisValue);\r\n\t                    } else {\r\n\t                    \t// See if the parameter had a value set in the parent job...\r\n\t                    \t//\r\n\t                    \tString parentValue = parentJob.getParameterValue(parameterNames[idx]);\r\n\t                    \tif (!Const.isEmpty(parentValue)) {\r\n\t                    \t\ttransMeta.setParameterValue(parameterNames[idx], parentValue);\r\n\t                    \t}\r\n\t                    }\r\n\t                }\r\n                \t\n                    // Create the transformation from meta-data\n                    Trans trans = new Trans(transMeta);\n\n                    if (parentJob.getJobMeta().isBatchIdPassed())\n                    {\n                        trans.setPassedBatchId(parentJob.getPassedBatchId());\n                    }\n                    \n                    // set the parent job on the transformation, variables are taken from here...\n                    trans.setParentJob(parentJob);\n                    trans.setParentVariableSpace(parentJob);                    \n\n                    // First get the root job\n                    //\n                    Job rootJob = parentJob;\n                    while (rootJob.getParentJob()!=null) rootJob=rootJob.getParentJob();\n                    \n                    // Get the start and end-date from the root job...\n                    //\n                    trans.setJobStartDate( rootJob.getStartDate() );\n                    trans.setJobEndDate( rootJob.getEndDate() );\n                    \n                    try {\n            \t\t\t// Start execution...\n                    \t//\n                    \ttrans.execute(args);\n\n                    \t// Wait until we're done with it...\n                    \t//\n        \t\t\t\twhile (!trans.isFinished() && !parentJob.isStopped() && trans.getErrors() == 0)\n        \t\t\t\t{\n        \t\t\t\t\ttry { Thread.sleep(0,500);}\n        \t\t\t\t\tcatch(InterruptedException e) { }\n        \t\t\t\t}\n\n        \t\t\t\tif (parentJob.isStopped() || trans.getErrors() != 0)\n        \t\t\t\t{\n        \t\t\t\t\ttrans.stopAll();\n        \t\t\t\t\ttrans.waitUntilFinished();\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_STOP);\n                            result.setNrErrors(1);\n        \t\t\t\t}\n        \t\t\t\telse\n        \t\t\t\t{\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n        \t\t\t\t}\n        \t\t\t\tResult newResult = trans.getResult();\n\n                        result.clear(); // clear only the numbers, NOT the files or rows.\n                        result.add(newResult);\n\n                        // Set the result rows too...\n                        result.setRows(newResult.getRows());\n\n                        if (setLogfile)\n                        {\n                        \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, KettleVFS.getFileObject(getLogFilename()), parentJob.getJobname(), toString());\n                            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n        \t\t\t\t}\n                    }\n                    catch (KettleException e) {\r\n                    \t\n                        log.logError(toString(), Messages.getString(\"JobTrans.Error.UnablePrepareExec\"), e);\n        \t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t}\n                }\n    \t\t}\n    \t\tcatch(Exception e)\n    \t\t{\r\n    \t\t\t\n    \t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.ErrorUnableOpenTrans\",e.getMessage()));\n                log.logError(toString(), Const.getStackTracker(e));\n    \t\t\tresult.setNrErrors(1);\n    \t\t}\n            iteration++;\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n        }\n\n\t\tif (result.getNrErrors()==0)\n\t\t{\n\t\t\tresult.setResult( true );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t}\n\n\t\t// Hint the VM to release handles.\n\t\tSystem.gc();\n\t\t\n\t\treturn result;\n\t}","commit_id":"dba43415356a6820a9728f4905d68cab49220e3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\r\n\t\tJndiUtil.initJNDI();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++)\n\t    {\n\t        if (a[i].length()>0) args.add(a[i]);\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tJob            job      = null;\n\t\t\n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionJobname, optionDirname, optionFilename, optionLoglevel;\n        StringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListjobs, optionListrep, optionNorep, optionVersion, optionListParam;\r\n        NamedParams optionParams = new NamedParamsDefault();\n\n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", Messages.getString(\"Kitchen.CmdLine.RepName\"), optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", Messages.getString(\"Kitchen.CmdLine.RepUsername\"), optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", Messages.getString(\"Kitchen.CmdLine.RepPassword\"), optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"job\", Messages.getString(\"Kitchen.CmdLine.RepJobName\") , optionJobname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", Messages.getString(\"Kitchen.CmdLine.RepDir\"), optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", Messages.getString(\"Kitchen.CmdLine.XMLJob\"), optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", Messages.getString(\"Kitchen.CmdLine.LogLevel\"), optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", Messages.getString(\"Kitchen.CmdLine.LogFile\"), optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", Messages.getString(\"Kitchen.CmdLine.LogFileOld\"), optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", Messages.getString(\"Kitchen.CmdLine.ListDir\"), optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listjobs\", Messages.getString(\"Kitchen.CmdLine.ListJobsDir\"), optionListjobs=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", Messages.getString(\"Kitchen.CmdLine.ListAvailableReps\"), optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", Messages.getString(\"Kitchen.CmdLine.NoRep\"), optionNorep=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", Messages.getString(\"Kitchen.CmdLine.Version\") , optionVersion=new StringBuffer(), true, false),\r\n                new CommandLineOption(\"param\", Messages.getString(\"Pan.ComdLine.Param\") , optionParams, true),\n\t\t        new CommandLineOption(\"listparam\", Messages.getString(\"Pan.ComdLine.ListParam\"), optionListParam=new StringBuffer(), true, false),\r\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t    CommandLineOption.printUsage(options);\n\t\t    exitJVM(9);\n\t\t}\n        \n        LogWriter log = LogWriter.getInstance(LogWriter.LOG_LEVEL_BASIC);\n        \n        CommandLineOption.parseArguments(args, options, log);\n\n        String kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (!Const.isEmpty(kettleRepname )) optionRepname  = new StringBuffer(kettleRepname );\n        if (!Const.isEmpty(kettleUsername)) optionUsername = new StringBuffer(kettleUsername);\n        if (!Const.isEmpty(kettlePassword)) optionPassword = new StringBuffer(kettlePassword);\n        \n        LogWriter.setConsoleAppenderDebug();\n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n        }\n        else\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.LogLevel\",log.getLogLevelLongDesc()));\n        } \n\t\t\n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Kitchen\", Messages.getString(\"Kitchen.Log.KettleVersion\", buildVersion.getVersion(), buildVersion.getRevision(), buildVersion.getBuildDate()));\n            if (a.length==1) exitJVM(6);\n        }\n        \n        // Start the action...\n        //\n        if (!Const.isEmpty(optionRepname) && !Const.isEmpty(optionUsername)) \t\r\n        {\r\n        \tif(log.isDetailed()) log.logDetailed(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.RepUsernameSupplied\"));\r\n        }\n\n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Starting\"));\r\n\t\t\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.LoadingSteps\"), e);\r\n\t\t\t\n\t\t\texitJVM(8);\n\t\t}\n\t\tStepLoader stepLoader = StepLoader.getInstance();\n        \n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.LoadingJobEntries\"), e);\r\n            \n            return;\n        }\n\n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\t\t\t\t\n\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.AllocateNewJob\"));\r\n\t\t\r\n\t\t\n\t\tJobMeta jobMeta = new JobMeta(log);\n        \n        // In case we use a repository...\n        Repository repository = null;\n\n\t\ttry\n\t\t{\n\t\t\t// Read kettle job specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.ParsingCommandLine\"));\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.LoadingRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.FindingRep\",\"\"+optionRepname));\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Alocate&ConnectRep\"));\r\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\trepository = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (repository.connect(\"Kitchen commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = repository.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = repository.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.CheckUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(repository, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    // Load a job\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionJobname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN,Messages.getString(\"Kitchen.Log.LoadingJobInfo\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tjobMeta =  new JobMeta(log, repository, optionJobname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.AllocateJob\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tjob = new Job(log, stepLoader, repository, jobMeta);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the jobs in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListjobs.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.GettingLostJobsInDirectory\",\"\"+directory));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tString jobnames[] = repository.getJobNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<jobnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(jobnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = repository.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotVerifyUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotFindSuppliedDirectory\",optionDirname+\"\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotConnectRep\"));\r\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.NoRepProvided\"));\r\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.NoRepDefinied\"));\r\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n                // Try to load if from file anyway.\n\t\t\t\tif (!Const.isEmpty(optionFilename) && job==null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta = new JobMeta(log, optionFilename.toString(), null, null);\n\t\t\t\t\tjob = new Job(log, stepLoader, null, jobMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Log.ListRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.UnableToReadXMLFile\"));\r\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tjob=null;\n\t\t\tjobMeta=null;\n\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.StopProcess\",e.getMessage()));\r\n\t\t\t\n\t\t}\n\n\t\tif (job==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListjobs.toString()) &&  \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListrep.toString()) \n\t\t\t    )\n\t\t\t{\n\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.canNotLoadJob\"));\t\t\t    \n\t\t\t}\n\n\t\t\texitJVM(7);\n\t\t}\r\n\t\t\r\n\t\tResult result = null;\n\n        int returnCode=0;\n        \n\t\ttry\n\t\t{\n            // Set the arguments on the job metadata as well...\n            if ( args.size() == 0 )\n            {\n                job.getJobMeta().setArguments(null);\n            }\n            else\n            {\n                job.getJobMeta().setArguments((String[]) args.toArray(new String[args.size()]));\n            }\n            job.initializeVariablesFrom(null);\n            job.getJobMeta().setInternalKettleVariables(job);\r\n            job.copyParametersFrom(job.getJobMeta());\r\n            \r\n    \t\t// List the parameters defined in this job \r\n    \t\t// Then simply exit...\r\n    \t\t//\r\n    \t\tif (\"Y\".equalsIgnoreCase(optionListParam.toString())) {\r\n    \t\t\tfor (String parameterName : job.listParameters()) {\r\n    \t\t\t\tString deft = job.getParameterDefault(parameterName);\r\n    \t\t\t\tString desc = job.getParameterDescription(parameterName);\r\n    \t\t\t\tif ( deft != null )  {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\" ( default=[\"+deft+\"]) : \"+Const.NVL(desc, \"\"));\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\" : \"+Const.NVL(desc, \"\"));\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\t// stop right here...\r\n    \t\t\t//\r\n    \t\t\texitJVM(7); // same as the other list options\r\n    \t\t}\r\n    \t\t            \r\n\t\t\t// Map the command line named parameters to the actual named parameters. Skip for\r\n\t\t\t// the moment any extra command line parameter not known in the job.\r\n\t\t\tString[] jobParams = job.listParameters();\r\n\t\t\tfor ( String param : jobParams )  {\r\n\t\t\t\tString value = optionParams.getParameterValue(param);\r\n\t\t\t\tif ( value != null )  {\r\n\t\t\t\t\tjob.setParameterValue(param, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Put the parameters over the already defined variable space. Parameters\r\n\t\t\t// get priority.\r\n\t\t\tjob.activateParameters();            \r\n                       \n\t\t\tresult = job.execute(); // Execute the selected job.\t\t\n\t\t\tjob.endProcessing(Database.LOG_STATUS_END, result);  // The bookkeeping...\n\t\t}\n\t\tcatch(KettleJobException je)\n\t\t{\r\n            if (result==null)\n            {\n                result = new Result();\n            }\n            result.setNrErrors(1L);\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tjob.endProcessing(\"error\", result);\n\t\t\t}\n\t\t\tcatch(KettleJobException je2)\n\t\t\t{\n\t\t\t\tlog.logError(job.getJobname(), Messages.getString(\"Kitchen.Error.SeriousError\",je2.getMessage()));\r\n                log.logError(job.getJobname(), Messages.getString(\"Kitchen.Error.SeriousError\",je.getMessage()));\r\n\t\t\t\t\n                returnCode = 2;\n\t\t\t}\n\t\t}\n        finally\n        {\n            if (repository!=null) repository.disconnect();\n        }\n        \n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Finished\"));\r\n\t\t\n\t\t\n\t\tif (result!=null && result.getNrErrors()!=0)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.FinishedWithErrors\"));\n            returnCode = 1;\n\t\t}\n\t\tcal=Calendar.getInstance();\n\t\tstop=cal.getTime();\n\t\tString begin=df.format(start).toString();\n\t\tString end  =df.format(stop).toString();\n\n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.StartStop\",begin,end));\r\n\t\t\n\t\tlong seconds = (stop.getTime() - start.getTime()) / 1000;\r\n\t\tif (seconds <= 60) {\n\t\t    log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfter\", String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse if (seconds <= 60 * 60) {\r\n\t\t    int min = (int)(seconds / 60);\r\n\t\t    int rem = (int)(seconds % 60);\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLong\", String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse if (seconds <= 60 * 60 * 24) {\r\n\t\t    int rem;\r\n            int hour = (int)(seconds / (60 * 60));\r\n            rem = (int)(seconds % (60 * 60)); \r\n            int min = rem / 60;\r\n            rem = rem % 60;\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLonger\", String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse {\r\n            int rem;\r\n            int days = (int)(seconds / (60 * 60 * 24));\r\n            rem = (int)(seconds % (60 * 60 * 24));\r\n            int hour = rem / (60 * 60);\r\n            rem = rem % (60 * 60); \r\n            int min = rem / 60;\r\n            rem = rem % 60;\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLongest\", String.valueOf(days), String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\t        \n        exitJVM(returnCode);\n\n\t}","id":40845,"modified_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\r\n\t\tJndiUtil.initJNDI();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++)\n\t    {\n\t        if (a[i].length()>0) args.add(a[i]);\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tJob            job      = null;\n\t\t\n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionJobname, optionDirname, optionFilename, optionLoglevel;\n        StringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListjobs, optionListrep, optionNorep, optionVersion, optionListParam;\r\n        NamedParams optionParams = new NamedParamsDefault();\n\n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", Messages.getString(\"Kitchen.CmdLine.RepName\"), optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", Messages.getString(\"Kitchen.CmdLine.RepUsername\"), optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", Messages.getString(\"Kitchen.CmdLine.RepPassword\"), optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"job\", Messages.getString(\"Kitchen.CmdLine.RepJobName\") , optionJobname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", Messages.getString(\"Kitchen.CmdLine.RepDir\"), optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", Messages.getString(\"Kitchen.CmdLine.XMLJob\"), optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", Messages.getString(\"Kitchen.CmdLine.LogLevel\"), optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", Messages.getString(\"Kitchen.CmdLine.LogFile\"), optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", Messages.getString(\"Kitchen.CmdLine.LogFileOld\"), optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", Messages.getString(\"Kitchen.CmdLine.ListDir\"), optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listjobs\", Messages.getString(\"Kitchen.CmdLine.ListJobsDir\"), optionListjobs=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", Messages.getString(\"Kitchen.CmdLine.ListAvailableReps\"), optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", Messages.getString(\"Kitchen.CmdLine.NoRep\"), optionNorep=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", Messages.getString(\"Kitchen.CmdLine.Version\") , optionVersion=new StringBuffer(), true, false),\r\n                new CommandLineOption(\"param\", Messages.getString(\"Pan.ComdLine.Param\") , optionParams, true),\n\t\t        new CommandLineOption(\"listparam\", Messages.getString(\"Pan.ComdLine.ListParam\"), optionListParam=new StringBuffer(), true, false),\r\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t    CommandLineOption.printUsage(options);\n\t\t    exitJVM(9);\n\t\t}\n        \n        LogWriter log = LogWriter.getInstance(LogWriter.LOG_LEVEL_BASIC);\n        \n        CommandLineOption.parseArguments(args, options, log);\n\n        String kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (!Const.isEmpty(kettleRepname )) optionRepname  = new StringBuffer(kettleRepname );\n        if (!Const.isEmpty(kettleUsername)) optionUsername = new StringBuffer(kettleUsername);\n        if (!Const.isEmpty(kettlePassword)) optionPassword = new StringBuffer(kettlePassword);\n        \n        LogWriter.setConsoleAppenderDebug();\n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n        }\n        else\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.LogLevel\",log.getLogLevelLongDesc()));\n        } \n\t\t\n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Kitchen\", Messages.getString(\"Kitchen.Log.KettleVersion\", buildVersion.getVersion(), buildVersion.getRevision(), buildVersion.getBuildDate()));\n            if (a.length==1) exitJVM(6);\n        }\n        \n        // Start the action...\n        //\n        if (!Const.isEmpty(optionRepname) && !Const.isEmpty(optionUsername)) \t\r\n        {\r\n        \tif(log.isDetailed()) log.logDetailed(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.RepUsernameSupplied\"));\r\n        }\n\n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Starting\"));\r\n\t\t\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.LoadingSteps\"), e);\r\n\t\t\t\n\t\t\texitJVM(8);\n\t\t}\n\t\tStepLoader stepLoader = StepLoader.getInstance();\n        \n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.LoadingJobEntries\"), e);\r\n            \n            return;\n        }\n\n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\t\t\t\t\n\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.AllocateNewJob\"));\r\n\t\t\r\n\t\t\n\t\tJobMeta jobMeta = new JobMeta(log);\n        \n        // In case we use a repository...\n        Repository repository = null;\n\n\t\ttry\n\t\t{\n\t\t\t// Read kettle job specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.ParsingCommandLine\"));\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.LoadingRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.FindingRep\",\"\"+optionRepname));\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Alocate&ConnectRep\"));\r\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\trepository = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (repository.connect(\"Kitchen commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = repository.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = repository.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.CheckUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(repository, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    // Load a job\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionJobname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN,Messages.getString(\"Kitchen.Log.LoadingJobInfo\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tjobMeta =  new JobMeta(log, repository, optionJobname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.AllocateJob\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tjob = new Job(log, stepLoader, repository, jobMeta);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the jobs in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListjobs.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug())log.logDebug(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.GettingLostJobsInDirectory\",\"\"+directory));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tString jobnames[] = repository.getJobNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<jobnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(jobnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = repository.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotVerifyUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotFindSuppliedDirectory\",optionDirname+\"\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.CanNotConnectRep\"));\r\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.NoRepProvided\"));\r\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.NoRepDefinied\"));\r\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n                // Try to load if from file anyway.\n\t\t\t\tif (!Const.isEmpty(optionFilename) && job==null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta = new JobMeta(log, optionFilename.toString(), null, null);\n\t\t\t\t\tjob = new Job(log, stepLoader, null, jobMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Log.ListRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.UnableToReadXMLFile\"));\r\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tjob=null;\n\t\t\tjobMeta=null;\n\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.StopProcess\",e.getMessage()));\r\n\t\t\t\n\t\t}\n\n\t\tif (job==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListjobs.toString()) &&  \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n\t\t\t\t!\"Y\".equalsIgnoreCase(optionListrep.toString()) \n\t\t\t    )\n\t\t\t{\n\t\t\t\tSystem.out.println(Messages.getString(\"Kitchen.Error.canNotLoadJob\"));\t\t\t    \n\t\t\t}\n\n\t\t\texitJVM(7);\n\t\t}\r\n\t\t\r\n\t\tResult result = null;\n\n        int returnCode=0;\n        \n\t\ttry\n\t\t{\n            // Set the arguments on the job metadata as well...\n            if ( args.size() == 0 )\n            {\n                job.getJobMeta().setArguments(null);\n            }\n            else\n            {\n                job.getJobMeta().setArguments((String[]) args.toArray(new String[args.size()]));\n            }\n            job.initializeVariablesFrom(null);\n            job.getJobMeta().setInternalKettleVariables(job);\r\n            job.copyParametersFrom(job.getJobMeta());\r\n            \r\n\t\t\t// Map the command line named parameters to the actual named parameters. Skip for\r\n\t\t\t// the moment any extra command line parameter not known in the job.\r\n\t\t\tString[] jobParams = job.listParameters();\r\n\t\t\tfor ( String param : jobParams )  {\r\n\t\t\t\tString value = optionParams.getParameterValue(param);\r\n\t\t\t\tif ( value != null )  {\r\n\t\t\t\t\tjob.setParameterValue(param, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Put the parameters over the already defined variable space. Parameters get priority.\r\n\t\t\t//\r\n\t\t\tjob.activateParameters();\r\n\t\t\t\r\n    \t\t// List the parameters defined in this job \r\n    \t\t// Then simply exit...\r\n    \t\t//\r\n    \t\tif (\"Y\".equalsIgnoreCase(optionListParam.toString())) {\r\n    \t\t\tfor (String parameterName : job.listParameters()) {\r\n    \t\t\t\tString value = job.getParameterValue(parameterName);\r\n    \t\t\t\tString deflt = job.getParameterDefault(parameterName);\r\n    \t\t\t\tString descr = job.getParameterDescription(parameterName);\r\n    \t\t\t\t\r\n    \t\t\t\tif ( deflt != null )  {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\"=\"+Const.NVL(value, \"\")+\", default=\"+deflt+\" : \"+Const.NVL(descr, \"\"));\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\"=\"+Const.NVL(value, \"\")+\" : \"+Const.NVL(descr, \"\"));\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\t// stop right here...\r\n    \t\t\t//\r\n    \t\t\texitJVM(7); // same as the other list options\r\n    \t\t}\r\n                       \n\t\t\tresult = job.execute(); // Execute the selected job.\t\t\n\t\t\tjob.endProcessing(Database.LOG_STATUS_END, result);  // The bookkeeping...\n\t\t}\n\t\tcatch(KettleJobException je)\n\t\t{\r\n            if (result==null)\n            {\n                result = new Result();\n            }\n            result.setNrErrors(1L);\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tjob.endProcessing(\"error\", result);\n\t\t\t}\n\t\t\tcatch(KettleJobException je2)\n\t\t\t{\n\t\t\t\tlog.logError(job.getJobname(), Messages.getString(\"Kitchen.Error.SeriousError\",je2.getMessage()));\r\n                log.logError(job.getJobname(), Messages.getString(\"Kitchen.Error.SeriousError\",je.getMessage()));\r\n\t\t\t\t\n                returnCode = 2;\n\t\t\t}\n\t\t}\n        finally\n        {\n            if (repository!=null) repository.disconnect();\n        }\n        \n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.Finished\"));\r\n\t\t\n\t\t\n\t\tif (result!=null && result.getNrErrors()!=0)\n\t\t{\n\t\t\tlog.logError(STRING_KITCHEN, Messages.getString(\"Kitchen.Error.FinishedWithErrors\"));\n            returnCode = 1;\n\t\t}\n\t\tcal=Calendar.getInstance();\n\t\tstop=cal.getTime();\n\t\tString begin=df.format(start).toString();\n\t\tString end  =df.format(stop).toString();\n\n\t\tlog.logMinimal(STRING_KITCHEN, Messages.getString(\"Kitchen.Log.StartStop\",begin,end));\r\n\t\t\n\t\tlong seconds = (stop.getTime() - start.getTime()) / 1000;\r\n\t\tif (seconds <= 60) {\n\t\t    log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfter\", String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse if (seconds <= 60 * 60) {\r\n\t\t    int min = (int)(seconds / 60);\r\n\t\t    int rem = (int)(seconds % 60);\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLong\", String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse if (seconds <= 60 * 60 * 24) {\r\n\t\t    int rem;\r\n            int hour = (int)(seconds / (60 * 60));\r\n            rem = (int)(seconds % (60 * 60)); \r\n            int min = rem / 60;\r\n            rem = rem % 60;\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLonger\", String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\telse {\r\n            int rem;\r\n            int days = (int)(seconds / (60 * 60 * 24));\r\n            rem = (int)(seconds % (60 * 60 * 24));\r\n            int hour = rem / (60 * 60);\r\n            rem = rem % (60 * 60); \r\n            int min = rem / 60;\r\n            rem = rem % 60;\r\n            log.logMinimal(STRING_KITCHEN,  Messages.getString(\"Kitchen.Log.ProcessEndAfterLongest\", String.valueOf(days), String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t\t}\r\n\t\t        \n        exitJVM(returnCode);\n\n\t}","commit_id":"dba43415356a6820a9728f4905d68cab49220e3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\tJndiUtil.initJNDI();\r\n\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename, optionListParam;\r\n\t\tNamedParams optionParams = new NamedParamsDefault();\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", Messages.getString(\"Pan.ComdLine.RepName\"), optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", Messages.getString(\"Pan.ComdLine.RepUsername\"), optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", Messages.getString(\"Pan.ComdLine.RepPassword\"), optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", Messages.getString(\"Pan.ComdLine.TransName\"), optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", Messages.getString(\"Pan.ComdLine.RepDir\"), optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", Messages.getString(\"Pan.ComdLine.XMLTransFile\"), optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", Messages.getString(\"Pan.ComdLine.LogLevel\"), optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", Messages.getString(\"Pan.ComdLine.LogFile\"), optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\",  Messages.getString(\"Pan.ComdLine.LogOldFile\"), optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", Messages.getString(\"Pan.ComdLine.ListDirRep\") , optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", Messages.getString(\"Pan.ComdLine.ListTransDir\"), optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", Messages.getString(\"Pan.ComdLine.ListReps\"), optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", Messages.getString(\"Pan.ComdLine.ExpObjectsXML\"), optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", Messages.getString(\"Pan.ComdLine.NoRep\"), optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", Messages.getString(\"Pan.ComdLine.SafeMode\"), optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", Messages.getString(\"Pan.ComdLine.Version\"), optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", Messages.getString(\"Pan.ComdLine.JarFile\") , optionJarFilename=new StringBuffer(), false, true),\r\n                new CommandLineOption(\"param\", Messages.getString(\"Pan.ComdLine.Param\") , optionParams, true),\n\t\t        new CommandLineOption(\"listparam\", Messages.getString(\"Pan.ComdLine.ListParam\"), optionListParam=new StringBuffer(), true, false),\r\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n\t\t\texitJVM(9);\n\t\t}\n\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        // start with the default logger until we find out otherwise\n        log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n\n\t\t// Parse the options...\n\t\tif( !CommandLineOption.parseArguments(args, options, log) ) {\n            log.logError(\"Pan\",  Messages.getString(\"Pan.Error.CommandLineError\"));\r\n           \n            exitJVM(8);\n\t\t}\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (!Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.Loglevel\",log.getLogLevelLongDesc()));\r\n           \n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            if(log.isBasic()) log.logBasic(\"Pan\", Messages.getString(\"Pan.Log.KettleVersion\", buildVersion.getVersion(), buildVersion.getRevision(), buildVersion.getBuildDate()));\n            \r\n            if (a.length==1) exitJVM(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        //\r\n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartingToRun\"));       \n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingStepsHaltPan\"));\r\n\t\t\t\n\t\t\texitJVM(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingJobEntriesHaltPan\"), e);\r\n            \n            exitJVM(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tif(log.isDebug()) log.logDebug(\"Pan\",Messages.getString(\"Pan.Log.AllocatteNewTrans\"));\r\n\t\t\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tif(log.isDebug()) log.logDebug(\"Pan\",Messages.getString(\"Pan.Log.StartingToLookOptions\"));\r\n\t\t\t\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.ParsingCommandline\"));\r\n\t\t\t\t\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.LoadingAvailableRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.FindingRep\",\"\"+optionRepname));\r\n\t\t\t\t\t\t\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.Allocate&ConnectRep\"));\r\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.CheckSuppliedUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.LoadTransInfo\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.AllocateTrans\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(transMeta);\r\n\t\t\t\t\t\t\t\t\t\t\ttrans.setRepository(rep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.GettingListTransDirectory\",\"\"+directory));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(Messages.getString(\"Pan.Log.ExportingObjectsRepToFile\",\"\"+optionExprep));\r\n                                            \n                                            rep.exportAllObjects(null, optionExprep.toString(), directory,\"all\");\r\n                                            System.out.println(Messages.getString(\"Pan.Log.FinishedExportObjectsRepToFile\",\"\"+optionExprep));\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoTransNameSupplied\"));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotVerifyUserPass\"));\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotFindSpecifiedDirectory\",\"\"+optionDirname));\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotConnectRep\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoRepProvided\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoRepsDefined\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some fail-over mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Pan\", Messages.getString(\"Pan.Log.LoadingTransXML\",\"\"+optionFilename));\r\n\t\t\t\t\t\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                    \tif(log.isDetailed())  log.logDetailed(\"Pan\", Messages.getString(\"Pan.Log.LoadingTransJar\",\"\"+optionJarFilename));\n                    \t\r\n                    \tInputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"), null);\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(Messages.getString(\"Pan.Error.ReadingJar\",e.toString()));\r\n                        \n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.GettingListReps\"));\r\n\t\t\t\t\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.ListReps\"));\r\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.RepNameDesc\",\"\"+(i+1),rinfo.getName(),rinfo.getDescription()));\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.UnableReadXML\"));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.ProcessStopError\",e.getMessage()));\r\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\texitJVM(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(Messages.getString(\"Pan.Error.CanNotLoadTrans\"));\r\n                \n                exitJVM(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\texitJVM(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\r\n\t\t\t\r\n    \t\t// List the parameters defined in this transformation \r\n    \t\t// Then simply exit...\r\n    \t\t//\r\n    \t\tif (\"Y\".equalsIgnoreCase(optionListParam.toString())) {\r\n    \t\t\tfor (String parameterName : trans.listParameters()) {\r\n    \t\t\t\tString deft = trans.getParameterDefault(parameterName);\r\n    \t\t\t\tString desc = trans.getParameterDescription(parameterName);\r\n    \t\t\t\tif ( deft != null )  {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\" ( default=[\"+deft+\"]) : \"+Const.NVL(desc, \"\"));\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\" : \"+Const.NVL(desc, \"\"));\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\t// stop right here...\r\n    \t\t\t//\r\n    \t\t\texitJVM(7); // same as the other list options\r\n    \t\t}\r\n\t\t\t\r\n\t\t\t// Map the command line named parameters to the actual named parameters. Skip for\r\n\t\t\t// the moment any extra command line parameter not known in the transformation.\r\n\t\t\tString[] transParams = trans.listParameters();\r\n\t\t\tfor ( String param : transParams )  {\r\n\t\t\t\tString value = optionParams.getParameterValue(param);\r\n\t\t\t\tif ( value != null )  {\r\n\t\t\t\t\ttrans.setParameterValue(param, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Put the parameters over the already defined variable space. Parameters\r\n\t\t\t// get priority.\r\n\t\t\ttrans.activateParameters();\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\t\t\t\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute((String[])args.toArray(new String[args.size()]));\n\t\t\t}\n\t\t\tcatch(KettleException e) {\n                System.out.println( Messages.getString(\"Pan.Error.UnablePrepareInitTrans\"));\r\n               \n                exitJVM(3);\n\t\t\t}\n\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n\n\t\t\tlog.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.Finished\"));\r\n\t\t\t \n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartStop\",begin,end));\r\n\t\t\t\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t        long seconds = millis / 1000;\r\n\t        if (seconds <= 60) {\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfter\", String.valueOf(seconds)));\r\n\t        }\r\n\t        else if (seconds <= 60 * 60) {\r\n\t            int min = (int)(seconds / 60);\r\n\t            int rem = (int)(seconds % 60);\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLong\", String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t        else if (seconds <= 60 * 60 * 24) {\r\n\t            int rem;\r\n\t            int hour = (int)(seconds / (60 * 60));\r\n\t            rem = (int)(seconds % (60 * 60)); \r\n\t            int min = rem / 60;\r\n\t            rem = rem % 60;\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLonger\", String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t        else {\r\n\t            int rem;\r\n\t            int days = (int)(seconds / (60 * 60 * 24));\r\n\t            rem = (int)(seconds % (60 * 60 * 24));\r\n\t            int hour = rem / (60 * 60);\r\n\t            rem = rem % (60 * 60); \r\n\t            int min = rem / 60;\r\n\t            rem = rem % 60;\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLongest\", String.valueOf(days), String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t\t\t\r\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n\t\t\t\texitJVM(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\texitJVM(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.ErrorOccurred\",\"\"+ke.getMessage()));\r\n\t\t\t\n            log.logError(\"Pan\", Messages.getString(\"Pan.Log.UnexpectedErrorOccurred\",\"\"+ke.getMessage()));\r\n            \r\n\t\t\t// Close the file appender if any...\r\n\t\t\t//\r\n\t\t\tLogWriter.closeAndRemoveFileAppender();\r\n\t\t\t\n            exitJVM(2);\n\t\t}\n\n\t}","id":40846,"modified_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\tJndiUtil.initJNDI();\r\n\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename, optionListParam;\r\n\t\tNamedParams optionParams = new NamedParamsDefault();\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", Messages.getString(\"Pan.ComdLine.RepName\"), optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", Messages.getString(\"Pan.ComdLine.RepUsername\"), optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", Messages.getString(\"Pan.ComdLine.RepPassword\"), optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", Messages.getString(\"Pan.ComdLine.TransName\"), optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", Messages.getString(\"Pan.ComdLine.RepDir\"), optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", Messages.getString(\"Pan.ComdLine.XMLTransFile\"), optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", Messages.getString(\"Pan.ComdLine.LogLevel\"), optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", Messages.getString(\"Pan.ComdLine.LogFile\"), optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\",  Messages.getString(\"Pan.ComdLine.LogOldFile\"), optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", Messages.getString(\"Pan.ComdLine.ListDirRep\") , optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", Messages.getString(\"Pan.ComdLine.ListTransDir\"), optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", Messages.getString(\"Pan.ComdLine.ListReps\"), optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", Messages.getString(\"Pan.ComdLine.ExpObjectsXML\"), optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", Messages.getString(\"Pan.ComdLine.NoRep\"), optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", Messages.getString(\"Pan.ComdLine.SafeMode\"), optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", Messages.getString(\"Pan.ComdLine.Version\"), optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", Messages.getString(\"Pan.ComdLine.JarFile\") , optionJarFilename=new StringBuffer(), false, true),\r\n                new CommandLineOption(\"param\", Messages.getString(\"Pan.ComdLine.Param\") , optionParams, true),\n\t\t        new CommandLineOption(\"listparam\", Messages.getString(\"Pan.ComdLine.ListParam\"), optionListParam=new StringBuffer(), true, false),\r\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n\t\t\texitJVM(9);\n\t\t}\n\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        // start with the default logger until we find out otherwise\n        log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n\n\t\t// Parse the options...\n\t\tif( !CommandLineOption.parseArguments(args, options, log) ) {\n            log.logError(\"Pan\",  Messages.getString(\"Pan.Error.CommandLineError\"));\r\n           \n            exitJVM(8);\n\t\t}\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (!Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.Loglevel\",log.getLogLevelLongDesc()));\r\n           \n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            if(log.isBasic()) log.logBasic(\"Pan\", Messages.getString(\"Pan.Log.KettleVersion\", buildVersion.getVersion(), buildVersion.getRevision(), buildVersion.getBuildDate()));\n            \r\n            if (a.length==1) exitJVM(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        //\r\n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartingToRun\"));       \n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingStepsHaltPan\"));\r\n\t\t\t\n\t\t\texitJVM(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingJobEntriesHaltPan\"), e);\r\n            \n            exitJVM(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tif(log.isDebug()) log.logDebug(\"Pan\",Messages.getString(\"Pan.Log.AllocatteNewTrans\"));\r\n\t\t\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tif(log.isDebug()) log.logDebug(\"Pan\",Messages.getString(\"Pan.Log.StartingToLookOptions\"));\r\n\t\t\t\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.ParsingCommandline\"));\r\n\t\t\t\t\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.LoadingAvailableRep\"));\r\n\t\t\t\t\t\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.FindingRep\",\"\"+optionRepname));\r\n\t\t\t\t\t\t\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.Allocate&ConnectRep\"));\r\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.CheckSuppliedUserPass\"));\r\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.LoadTransInfo\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.AllocateTrans\"));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(transMeta);\r\n\t\t\t\t\t\t\t\t\t\t\ttrans.setRepository(rep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.GettingListTransDirectory\",\"\"+directory));\r\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(Messages.getString(\"Pan.Log.ExportingObjectsRepToFile\",\"\"+optionExprep));\r\n                                            \n                                            rep.exportAllObjects(null, optionExprep.toString(), directory,\"all\");\r\n                                            System.out.println(Messages.getString(\"Pan.Log.FinishedExportObjectsRepToFile\",\"\"+optionExprep));\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoTransNameSupplied\"));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotVerifyUserPass\"));\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotFindSpecifiedDirectory\",\"\"+optionDirname));\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.CanNotConnectRep\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoRepProvided\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.NoRepsDefined\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some fail-over mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Pan\", Messages.getString(\"Pan.Log.LoadingTransXML\",\"\"+optionFilename));\r\n\t\t\t\t\t\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                    \tif(log.isDetailed())  log.logDetailed(\"Pan\", Messages.getString(\"Pan.Log.LoadingTransJar\",\"\"+optionJarFilename));\n                    \t\r\n                    \tInputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"), null);\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(Messages.getString(\"Pan.Error.ReadingJar\",e.toString()));\r\n                        \n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", Messages.getString(\"Pan.Log.GettingListReps\"));\r\n\t\t\t\t\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.ListReps\"));\r\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.RepNameDesc\",\"\"+(i+1),rinfo.getName(),rinfo.getDescription()));\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.UnableReadXML\"));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(Messages.getString(\"Pan.Error.ProcessStopError\",e.getMessage()));\r\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\texitJVM(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(Messages.getString(\"Pan.Error.CanNotLoadTrans\"));\r\n                \n                exitJVM(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\texitJVM(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\r\n\t\t\t\r\n\t\t\t// Map the command line named parameters to the actual named parameters. Skip for\r\n\t\t\t// the moment any extra command line parameter not known in the transformation.\r\n\t\t\tString[] transParams = trans.listParameters();\r\n\t\t\tfor ( String param : transParams )  {\r\n\t\t\t\tString value = optionParams.getParameterValue(param);\r\n\t\t\t\tif ( value != null )  {\r\n\t\t\t\t\ttrans.setParameterValue(param, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Put the parameters over the already defined variable space. Parameters\r\n\t\t\t// get priority.\r\n\t\t\ttrans.activateParameters();\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\r\n    \t\t// List the parameters defined in this transformation \r\n    \t\t// Then simply exit...\r\n    \t\t//\r\n    \t\tif (\"Y\".equalsIgnoreCase(optionListParam.toString())) {\r\n    \t\t\tfor (String parameterName : trans.listParameters()) {\r\n    \t\t\t\tString value = trans.getParameterValue(parameterName);\r\n    \t\t\t\tString deflt = trans.getParameterDefault(parameterName);\r\n    \t\t\t\tString descr = trans.getParameterDescription(parameterName);\r\n    \t\t\t\t\r\n    \t\t\t\tif ( deflt != null )  {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\"=\"+Const.NVL(value, \"\")+\", default=\"+deflt+\" : \"+Const.NVL(descr, \"\"));\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tSystem.out.println(\"Parameter: \"+parameterName+\"=\"+Const.NVL(value, \"\")+\" : \"+Const.NVL(descr, \"\"));\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\t// stop right here...\r\n    \t\t\t//\r\n    \t\t\texitJVM(7); // same as the other list options\r\n    \t\t}\r\n\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute((String[])args.toArray(new String[args.size()]));\n\t\t\t}\n\t\t\tcatch(KettleException e) {\n                System.out.println( Messages.getString(\"Pan.Error.UnablePrepareInitTrans\"));\r\n               \n                exitJVM(3);\n\t\t\t}\n\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n\n\t\t\tlog.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.Finished\"));\r\n\t\t\t \n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartStop\",begin,end));\r\n\t\t\t\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t        long seconds = millis / 1000;\r\n\t        if (seconds <= 60) {\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfter\", String.valueOf(seconds)));\r\n\t        }\r\n\t        else if (seconds <= 60 * 60) {\r\n\t            int min = (int)(seconds / 60);\r\n\t            int rem = (int)(seconds % 60);\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLong\", String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t        else if (seconds <= 60 * 60 * 24) {\r\n\t            int rem;\r\n\t            int hour = (int)(seconds / (60 * 60));\r\n\t            rem = (int)(seconds % (60 * 60)); \r\n\t            int min = rem / 60;\r\n\t            rem = rem % 60;\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLonger\", String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t        else {\r\n\t            int rem;\r\n\t            int days = (int)(seconds / (60 * 60 * 24));\r\n\t            rem = (int)(seconds % (60 * 60 * 24));\r\n\t            int hour = rem / (60 * 60);\r\n\t            rem = rem % (60 * 60); \r\n\t            int min = rem / 60;\r\n\t            rem = rem % 60;\r\n\t            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.ProcessingEndAfterLongest\", String.valueOf(days), String.valueOf(hour), String.valueOf(min), String.valueOf(rem), String.valueOf(seconds)));\r\n\t        }\r\n\t\t\t\r\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n\t\t\t\texitJVM(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\texitJVM(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(Messages.getString(\"Pan.Log.ErrorOccurred\",\"\"+ke.getMessage()));\r\n\t\t\t\n            log.logError(\"Pan\", Messages.getString(\"Pan.Log.UnexpectedErrorOccurred\",\"\"+ke.getMessage()));\r\n            \r\n\t\t\t// Close the file appender if any...\r\n\t\t\t//\r\n\t\t\tLogWriter.closeAndRemoveFileAppender();\r\n\t\t\t\n            exitJVM(2);\n\t\t}\n\n\t}","commit_id":"dba43415356a6820a9728f4905d68cab49220e3f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void setMappingParameters() throws KettleException {\n\t\tMappingParameters mappingParameters = meta.getMappingParameters();\n\t\tif (mappingParameters!=null) {\r\n\t\t\t\r\n\t\t\t// See if we need to pass all variables from the parent or not...\r\n\t\t\t//\r\n\t\t\tif (mappingParameters.isInheritingAllVariables()) {\r\n\t\t\t\tdata.mappingTransMeta.copyVariablesFrom(getTransMeta());\r\n\t\t\t}\r\n\t\t\t\n\t\t\t// Just set the variables in the transformation statically.\n\t\t\t// This just means: set a number of variables:\n\t\t\t//\r\n\t\t\tfor (int i=0;i<mappingParameters.getVariable().length;i++) {\n\t\t\t\tString name = mappingParameters.getVariable()[i];\n\t\t\t\tString value = environmentSubstitute(mappingParameters.getInputField()[i]);\n\t\t\t\tif (!Const.isEmpty(name) && !Const.isEmpty(value)) {\r\n\r\n\t\t\t\t\t// if the parameters are defined as such in the subtrans, set them\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdata.mappingTransMeta.setParameterValue(name, value);\r\n\t\t\t\t\t\tif (data.mappingTrans != null) {\r\n\t\t\t\t\t\t\tdata.mappingTrans.setParameterValue(name, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(UnknownParamException e){\r\n\t\t\t\t\t\t// eat up\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\n\t\t\t\t\tdata.mappingTransMeta.setVariable(name, value);\r\n\t\t\t\t\tif (data.mappingTrans != null) {\r\n\t\t\t\t\t\tdata.mappingTrans.setVariable(name, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\n\t\t}\n\t}","id":40847,"modified_method":"private void setMappingParameters() throws KettleException {\n\t\tMappingParameters mappingParameters = meta.getMappingParameters();\n\t\tif (mappingParameters!=null) {\r\n\t\t\t\r\n\t    String[] parameters;\r\n\t    String[] parameterValues;\r\n\t    \r\n\t    if (mappingParameters.isInheritingAllVariables()) {\r\n\t      // We pass the values for all the parameters from the parent transformation\r\n\t      //\r\n\t      parameters = data.mappingTransMeta.listParameters();\r\n\t      parameterValues = new String[parameters.length];\r\n\t      for (int i=0;i<parameters.length;i++) {\r\n\t        parameterValues[i] = getVariable(parameters[i]);\r\n\t      }\r\n\t    } else {\r\n\t      // We pass down the listed variables with the specified values...\r\n\t      //\r\n\t      parameters = mappingParameters.getVariable();\r\n\t      parameterValues = new String[parameters.length];\r\n\t      for (int i=0;i<parameters.length;i++) {\r\n\t        parameterValues[i] = environmentSubstitute(mappingParameters.getInputField()[i]);\r\n\t      }\r\n\t    }\r\n\t    \r\n\t    for (int i=0;i<parameters.length;i++) {\r\n\t      String value = Const.NVL(parameterValues[i], \"\");\r\n\t      \r\n\t      data.mappingTrans.setParameterValue(parameters[i], value);\r\n\t    }\r\n\t    \r\n\t    data.mappingTrans.activateParameters();\r\n\t\t}\n\t}","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void prepareMappingExecution() throws KettleException {\n        // Create the transformation from meta-data...\n\t\t//\n        data.mappingTrans = new Trans(data.mappingTransMeta, getTrans());\r\n        \r\n        if (data.mappingTransMeta.getTransformationType()!=TransformationType.Normal) {\r\n        \tdata.mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);\r\n        }\r\n        \r\n        // Leave a path up so that we can set variables in sub-transformations...\r\n        //\r\n        data.mappingTrans.setParentTrans(getTrans());\r\n        \n        // Pass down the safe mode flag to the mapping...\n        //\n        data.mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());\r\n        \r\n        // Also set the name of this step in the mapping transformation for logging purposes\r\n        //\r\n        data.mappingTrans.setMappingStepName(getStepname());\r\n\r\n        // We launch the transformation in the processRow when the first row is received.\r\n        // This will allow the correct variables to be passed.\r\n        // Otherwise the parent is the init() thread which will be gone once the init is done.\r\n        //\r\n        try {\r\n          data.mappingTrans.prepareExecution(getTransMeta().getArguments());\r\n        }\r\n        catch(KettleException e) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"Mapping.Exception.UnableToPrepareExecutionOfMapping\"), e);\r\n        }\r\n\r\n        // Extra optional work to do for alternative execution engines...\r\n        //\r\n        switch (data.mappingTransMeta.getTransformationType()) {\r\n        case Normal:\r\n        case SerialSingleThreaded:\r\n          break;\r\n        \r\n        case SingleThreaded:\r\n          data.singleThreadedTransExcecutor = new SingleThreadedTransExecutor(data.mappingTrans);\r\n          if (!data.singleThreadedTransExcecutor.init()) {\r\n            throw new KettleException(BaseMessages.getString(PKG, \"Mapping.Exception.UnableToInitSingleThreadedTransformation\"));\r\n          }\r\n          break;\r\n        }\r\n        \r\n        setMappingParameters();\r\n        \r\n\t\t// If there is no read/write logging step set, we can insert the data from the first mapping input/output step...\r\n\t\t//\r\n\t\tMappingInput[] mappingInputs = data.mappingTrans.findMappingInput();\r\n\t\tLogTableField readField = data.mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_READ);\r\n\t\tif (readField.getSubject()==null && mappingInputs!=null && mappingInputs.length>=1) {\r\n\t\t\treadField.setSubject(mappingInputs[0].getStepMeta());\r\n\t\t}\r\n\t\tMappingOutput[] mappingOutputs = data.mappingTrans.findMappingOutput();\r\n\t\tLogTableField writeField = data.mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_WRITTEN);\r\n\t\tif (writeField.getSubject()==null && mappingOutputs!=null && mappingOutputs.length>=1) {\r\n\t\t\twriteField.setSubject(mappingOutputs[0].getStepMeta());\r\n\t\t}\r\n        \n        // Before we add rowsets and all, we should note that the mapping step did not receive ANY input and output rowsets.\n        // This is an exception to the general rule, built into Trans.prepareExecution()\n        //\n        // A Mapping Input step is supposed to read directly from the previous steps.\n        // A Mapping Output step is supposed to write directly to the next steps.\n        \n        // OK, check the input mapping definitions and look up the steps to read from.\n        // \n        StepInterface[] sourceSteps;\n        for (MappingIODefinition inputDefinition : meta.getInputMappings()) {\n        \t// If we have a single step to read from, we use this\n        \t//\n        \tif (!Const.isEmpty(inputDefinition.getInputStepname())) {\n        \t\tStepInterface sourceStep = (StepInterface) getTrans().findRunThread(inputDefinition.getInputStepname());\n            \tif (sourceStep==null) {\n            \t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", inputDefinition.getInputStepname()));\n            \t}\n            \tsourceSteps = new StepInterface[] { sourceStep, };\n        \t} \n        \telse {\n        \t\t// We have no defined source step.\n        \t\t// That means that we're reading from all input steps that this mapping step has.\n        \t\t//\n    \t        List<StepMeta> prevSteps = getTransMeta().findPreviousSteps(getStepMeta());\r\n\r\n    \t        // TODO: Handle remote steps from: getStepMeta().getRemoteInputSteps()\r\n    \t        //\r\n    \t        \n    \t\t\t// Let's read data from all the previous steps we find...\n    \t\t\t// The origin is the previous step\n    \t\t\t// The target is the Mapping Input step.\n    \t\t\t//\n    \t\t\tsourceSteps=new StepInterface[prevSteps.size()];\n    \t\t\tfor (int s=0;s<sourceSteps.length;s++) {\n    \t\t\t\tsourceSteps[s] = (StepInterface) getTrans().findRunThread(prevSteps.get(s).getName());\n    \t\t\t}\n        \t}\n        \t\n        \t// What step are we writing to?\n        \tMappingInput mappingInputTarget=null;\n    \t\tMappingInput[] mappingInputSteps = data.mappingTrans.findMappingInput();\n        \tif (Const.isEmpty(inputDefinition.getOutputStepname())) {\n        \t\t// No target was specifically specified.\n        \t\t// That means we only expect one \"mapping input\" step in the mapping...\n        \t\t\n        \t\tif (mappingInputSteps.length==0) {\n        \t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OneMappingInputStepRequired\"));\n        \t\t}\n        \t\tif (mappingInputSteps.length>1) {\n        \t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OnlyOneMappingInputStepAllowed\", \"\"+mappingInputSteps.length));\n        \t\t}\n        \t\t\n        \t\tmappingInputTarget = mappingInputSteps[0];\n        \t}\n        \telse {\n        \t\t// A target step was specified.  See if we can find it...\n        \t\tfor (int s=0;s<mappingInputSteps.length && mappingInputTarget==null;s++) {\n        \t\t\tif (mappingInputSteps[s].getStepname().equals(inputDefinition.getOutputStepname())) {\n        \t\t\t\tmappingInputTarget = mappingInputSteps[s];\n        \t\t\t}\n        \t\t}\n        \t\t// If we still didn't find it it's a drag.\n        \t\tif (mappingInputTarget==null) {\n            \t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", inputDefinition.getOutputStepname()));\n        \t\t}\n        \t}\n        \t\n        \t// Before we pass the field renames to the mapping input step, let's add functionality to rename it back on ALL\n        \t// mapping output steps.\n        \t// To do this, we need a list of values that changed so we can revert that in the metadata before the rows come back.\n        \t// \n        \tif (inputDefinition.isRenamingOnOutput()) addInputRenames(data.inputRenameList, inputDefinition.getValueRenames());\n        \t\r\n        \tmappingInputTarget.setConnectorSteps(sourceSteps, inputDefinition.getValueRenames(), getStepname());\n        }\n        \n        // Now we have a List of connector threads.\n        // If we start all these we'll be starting to pump data into the mapping\n        // If we don't have any threads to start, nothings going in there...\n        // However, before we send anything over, let's first explain to the mapping output steps where the data needs to go...\n        //\n        for (MappingIODefinition outputDefinition : meta.getOutputMappings()) {\n        \t// OK, what is the source (input) step in the mapping: it's the mapping output step...\n        \t// What step are we reading from here?\n        \t//\n        \tMappingOutput mappingOutputSource = (MappingOutput) data.mappingTrans.findRunThread(outputDefinition.getInputStepname());\n        \tif (mappingOutputSource==null) {\n        \t\t// No source step was specified: we're reading from a single Mapping Output step.\n        \t\t// We should verify this if this is really the case...\n        \t\t//\n        \t\tMappingOutput[] mappingOutputSteps = data.mappingTrans.findMappingOutput();\n        \t\t\n        \t\tif (mappingOutputSteps.length==0) {\n        \t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OneMappingOutputStepRequired\"));\n        \t\t}\n        \t\tif (mappingOutputSteps.length>1) {\n        \t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OnlyOneMappingOutputStepAllowed\", \"\"+mappingOutputSteps.length));\n        \t\t}\n        \t\t\n        \t\tmappingOutputSource = mappingOutputSteps[0];\n        \t}\n        \t\n        \t// To what step in this transformation are we writing to?\n        \t//\n        \tStepInterface[] targetSteps;\n        \tif (!Const.isEmpty(outputDefinition.getOutputStepname())) {\n        \t\t// If we have a target step specification for the output of the mapping, we need to send it over there...\n        \t\t//\n            \tStepInterface target = (StepInterface) getTrans().findRunThread(outputDefinition.getOutputStepname());\n            \tif (target==null) {\n            \t\tthrow new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", outputDefinition.getOutputStepname()));\n            \t}\n            \ttargetSteps = new StepInterface[] { target, };\n        \t}\n        \telse {\n        \t\t// No target step is specified.\n        \t\t// See if we can find the next steps in the transformation..\n        \t\t// \n        \t\tList<StepMeta> nextSteps = getTransMeta().findNextSteps(getStepMeta());\r\n        \t\t\n    \t\t\t// Let's send the data to all the next steps we find...\n    \t\t\t// The origin is the mapping output step\n    \t\t\t// The target is all the next steps after this mapping step.\n    \t\t\t//\n    \t\t\ttargetSteps=new StepInterface[nextSteps.size()];\n    \t\t\tfor (int s=0;s<targetSteps.length;s++) {\n    \t\t\t\ttargetSteps[s] = (StepInterface) getTrans().findRunThread(nextSteps.get(s).getName());\n    \t\t\t}\n        \t}\n        \t\n        \t// Now tell the mapping output step where to look...\n        \t// Also explain the mapping output steps how to rename the values back...\n        \t//\n        \tmappingOutputSource.setConnectorSteps(targetSteps, data.inputRenameList, outputDefinition.getValueRenames());\n        \t\n        \t// Is this mapping copying or distributing?\n        \t// Make sure the mapping output step mimics this behavior:\n        \t//\n        \tmappingOutputSource.setDistributed(isDistributed());        \t\n        }\r\n        \r\n        // Finally, add the mapping transformation to the active sub-transformations map in the parent transformation\r\n        //\r\n        getTrans().getActiveSubtransformations().put(getStepname(), data.mappingTrans);\n\t}","id":40848,"modified_method":"public void prepareMappingExecution() throws KettleException {\r\n    // Create the transformation from meta-data...\r\n    //\r\n    data.mappingTrans = new Trans(data.mappingTransMeta, getTrans());\r\n\r\n    // Set the parameters values in the mapping.\r\n    //\r\n    setMappingParameters();\r\n\r\n    if (data.mappingTransMeta.getTransformationType() != TransformationType.Normal) {\r\n      data.mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);\r\n    }\r\n\r\n    // Leave a path up so that we can set variables in sub-transformations...\r\n    //\r\n    data.mappingTrans.setParentTrans(getTrans());\r\n\r\n    // Pass down the safe mode flag to the mapping...\r\n    //\r\n    data.mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());\r\n\r\n    // Also set the name of this step in the mapping transformation for logging\r\n    // purposes\r\n    //\r\n    data.mappingTrans.setMappingStepName(getStepname());\r\n\r\n    // We launch the transformation in the processRow when the first row is\r\n    // received.\r\n    // This will allow the correct variables to be passed.\r\n    // Otherwise the parent is the init() thread which will be gone once the\r\n    // init is done.\r\n    //\r\n    try {\r\n      data.mappingTrans.prepareExecution(getTransMeta().getArguments());\r\n    } catch (KettleException e) {\r\n      throw new KettleException(BaseMessages.getString(PKG, \"Mapping.Exception.UnableToPrepareExecutionOfMapping\"), e);\r\n    }\r\n\r\n    // Extra optional work to do for alternative execution engines...\r\n    //\r\n    switch (data.mappingTransMeta.getTransformationType()) {\r\n    case Normal:\r\n    case SerialSingleThreaded:\r\n      break;\r\n\r\n    case SingleThreaded:\r\n      data.singleThreadedTransExcecutor = new SingleThreadedTransExecutor(data.mappingTrans);\r\n      if (!data.singleThreadedTransExcecutor.init()) {\r\n        throw new KettleException(BaseMessages.getString(PKG, \"Mapping.Exception.UnableToInitSingleThreadedTransformation\"));\r\n      }\r\n      break;\r\n    }\r\n\r\n    // If there is no read/write logging step set, we can insert the data from\r\n    // the first mapping input/output step...\r\n    //\r\n    MappingInput[] mappingInputs = data.mappingTrans.findMappingInput();\r\n    LogTableField readField = data.mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_READ);\r\n    if (readField.getSubject() == null && mappingInputs != null && mappingInputs.length >= 1) {\r\n      readField.setSubject(mappingInputs[0].getStepMeta());\r\n    }\r\n    MappingOutput[] mappingOutputs = data.mappingTrans.findMappingOutput();\r\n    LogTableField writeField = data.mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_WRITTEN);\r\n    if (writeField.getSubject() == null && mappingOutputs != null && mappingOutputs.length >= 1) {\r\n      writeField.setSubject(mappingOutputs[0].getStepMeta());\r\n    }\r\n\r\n    // Before we add rowsets and all, we should note that the mapping step did\r\n    // not receive ANY input and output rowsets.\r\n    // This is an exception to the general rule, built into\r\n    // Trans.prepareExecution()\r\n    //\r\n    // A Mapping Input step is supposed to read directly from the previous\r\n    // steps.\r\n    // A Mapping Output step is supposed to write directly to the next steps.\r\n\r\n    // OK, check the input mapping definitions and look up the steps to read\r\n    // from.\r\n    //\r\n    StepInterface[] sourceSteps;\r\n    for (MappingIODefinition inputDefinition : meta.getInputMappings()) {\r\n      // If we have a single step to read from, we use this\r\n      //\r\n      if (!Const.isEmpty(inputDefinition.getInputStepname())) {\r\n        StepInterface sourceStep = (StepInterface) getTrans().findRunThread(inputDefinition.getInputStepname());\r\n        if (sourceStep == null) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", inputDefinition.getInputStepname()));\r\n        }\r\n        sourceSteps = new StepInterface[] { sourceStep, };\r\n      } else {\r\n        // We have no defined source step.\r\n        // That means that we're reading from all input steps that this mapping\r\n        // step has.\r\n        //\r\n        List<StepMeta> prevSteps = getTransMeta().findPreviousSteps(getStepMeta());\r\n\r\n        // TODO: Handle remote steps from: getStepMeta().getRemoteInputSteps()\r\n        //\r\n\r\n        // Let's read data from all the previous steps we find...\r\n        // The origin is the previous step\r\n        // The target is the Mapping Input step.\r\n        //\r\n        sourceSteps = new StepInterface[prevSteps.size()];\r\n        for (int s = 0; s < sourceSteps.length; s++) {\r\n          sourceSteps[s] = (StepInterface) getTrans().findRunThread(prevSteps.get(s).getName());\r\n        }\r\n      }\r\n\r\n      // What step are we writing to?\r\n      MappingInput mappingInputTarget = null;\r\n      MappingInput[] mappingInputSteps = data.mappingTrans.findMappingInput();\r\n      if (Const.isEmpty(inputDefinition.getOutputStepname())) {\r\n        // No target was specifically specified.\r\n        // That means we only expect one \"mapping input\" step in the mapping...\r\n\r\n        if (mappingInputSteps.length == 0) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OneMappingInputStepRequired\"));\r\n        }\r\n        if (mappingInputSteps.length > 1) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OnlyOneMappingInputStepAllowed\", \"\" + mappingInputSteps.length));\r\n        }\r\n\r\n        mappingInputTarget = mappingInputSteps[0];\r\n      } else {\r\n        // A target step was specified. See if we can find it...\r\n        for (int s = 0; s < mappingInputSteps.length && mappingInputTarget == null; s++) {\r\n          if (mappingInputSteps[s].getStepname().equals(inputDefinition.getOutputStepname())) {\r\n            mappingInputTarget = mappingInputSteps[s];\r\n          }\r\n        }\r\n        // If we still didn't find it it's a drag.\r\n        if (mappingInputTarget == null) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", inputDefinition.getOutputStepname()));\r\n        }\r\n      }\r\n\r\n      // Before we pass the field renames to the mapping input step, let's add\r\n      // functionality to rename it back on ALL\r\n      // mapping output steps.\r\n      // To do this, we need a list of values that changed so we can revert that\r\n      // in the metadata before the rows come back.\r\n      //\r\n      if (inputDefinition.isRenamingOnOutput())\r\n        addInputRenames(data.inputRenameList, inputDefinition.getValueRenames());\r\n\r\n      mappingInputTarget.setConnectorSteps(sourceSteps, inputDefinition.getValueRenames(), getStepname());\r\n    }\r\n\r\n    // Now we have a List of connector threads.\r\n    // If we start all these we'll be starting to pump data into the mapping\r\n    // If we don't have any threads to start, nothings going in there...\r\n    // However, before we send anything over, let's first explain to the mapping\r\n    // output steps where the data needs to go...\r\n    //\r\n    for (MappingIODefinition outputDefinition : meta.getOutputMappings()) {\r\n      // OK, what is the source (input) step in the mapping: it's the mapping\r\n      // output step...\r\n      // What step are we reading from here?\r\n      //\r\n      MappingOutput mappingOutputSource = (MappingOutput) data.mappingTrans.findRunThread(outputDefinition.getInputStepname());\r\n      if (mappingOutputSource == null) {\r\n        // No source step was specified: we're reading from a single Mapping\r\n        // Output step.\r\n        // We should verify this if this is really the case...\r\n        //\r\n        MappingOutput[] mappingOutputSteps = data.mappingTrans.findMappingOutput();\r\n\r\n        if (mappingOutputSteps.length == 0) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OneMappingOutputStepRequired\"));\r\n        }\r\n        if (mappingOutputSteps.length > 1) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.OnlyOneMappingOutputStepAllowed\", \"\" + mappingOutputSteps.length));\r\n        }\r\n\r\n        mappingOutputSource = mappingOutputSteps[0];\r\n      }\r\n\r\n      // To what step in this transformation are we writing to?\r\n      //\r\n      StepInterface[] targetSteps;\r\n      if (!Const.isEmpty(outputDefinition.getOutputStepname())) {\r\n        // If we have a target step specification for the output of the mapping,\r\n        // we need to send it over there...\r\n        //\r\n        StepInterface target = (StepInterface) getTrans().findRunThread(outputDefinition.getOutputStepname());\r\n        if (target == null) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"MappingDialog.Exception.StepNameNotFound\", outputDefinition.getOutputStepname()));\r\n        }\r\n        targetSteps = new StepInterface[] { target, };\r\n      } else {\r\n        // No target step is specified.\r\n        // See if we can find the next steps in the transformation..\r\n        //\r\n        List<StepMeta> nextSteps = getTransMeta().findNextSteps(getStepMeta());\r\n\r\n        // Let's send the data to all the next steps we find...\r\n        // The origin is the mapping output step\r\n        // The target is all the next steps after this mapping step.\r\n        //\r\n        targetSteps = new StepInterface[nextSteps.size()];\r\n        for (int s = 0; s < targetSteps.length; s++) {\r\n          targetSteps[s] = (StepInterface) getTrans().findRunThread(nextSteps.get(s).getName());\r\n        }\r\n      }\r\n\r\n      // Now tell the mapping output step where to look...\r\n      // Also explain the mapping output steps how to rename the values back...\r\n      //\r\n      mappingOutputSource.setConnectorSteps(targetSteps, data.inputRenameList, outputDefinition.getValueRenames());\r\n\r\n      // Is this mapping copying or distributing?\r\n      // Make sure the mapping output step mimics this behavior:\r\n      //\r\n      mappingOutputSource.setDistributed(isDistributed());\r\n    }\r\n\r\n    // Finally, add the mapping transformation to the active sub-transformations\r\n    // map in the parent transformation\r\n    //\r\n    getTrans().getActiveSubtransformations().put(getStepname(), data.mappingTrans);\r\n  }","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Process a single row.  In our case, we send one row of data to a piece of transformation.\n     * In the transformation, we look up the MappingInput step to send our rows to it.\n     * As a consequence, for the time being, there can only be one MappingInput and one MappingOutput step in the Mapping.\n     */\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\r\n\t\ttry\r\n\t\t{\n\t\t\tmeta=(MappingMeta)smi;\n\t\t\tdata=(MappingData)sdi;\r\n\r\n\t\t\tMappingInput[] mappingInputs = data.mappingTrans.findMappingInput();\r\n\t\t\tMappingOutput[] mappingOutputs = data.mappingTrans.findMappingOutput();\r\n      \r\n\t\t\tswitch(data.mappingTransMeta.getTransformationType()) {\n\t\t\t  case Normal:\r\n\t      case SerialSingleThreaded:\r\n\t\t\t\r\n        // Before we start, let's see if there are loose ends to tie up...\r\n        //\r\n        if (!getInputRowSets().isEmpty()) {\r\n          for (RowSet rowSet : new ArrayList<RowSet>(getInputRowSets())) {\r\n            // Pass this rowset down to a mapping input step in the\r\n            // sub-transformation...\r\n            //\r\n            if (mappingInputs.length == 1) {\r\n              // Simple case: only one input mapping. Move the RowSet over\r\n              //\r\n              mappingInputs[0].getInputRowSets().add(rowSet);\r\n            } else {\r\n              // Difficult to see what's going on here.\r\n              // TODO: figure out where this RowSet needs to go and where it\r\n              // comes from.\r\n              //\r\n              throw new KettleException(\"Unsupported situation detected where more than one Mapping Input step needs to be handled.  To solve it, insert a dummy step before the mapping step.\");\r\n            }\r\n          }\r\n          getInputRowSets().clear();\r\n        }\r\n\r\n        // Do the same thing for remote input steps...\r\n        //\r\n        if (!getRemoteInputSteps().isEmpty()) {\r\n          // The remote server is likely a master or a slave server sending data\r\n          // over remotely to this mapping.\r\n          // However, the data needs to end up at a Mapping Input step of the\r\n          // sub-transformation, not in this step.\r\n          // We can move over the remote steps to the Mapping Input step as long\r\n          // as the threads haven't started yet.\r\n          //\r\n          for (RemoteStep remoteStep : getRemoteInputSteps()) {\r\n            // Pass this rowset down to a mapping input step in the\r\n            // sub-transformation...\r\n            //\r\n            if (mappingInputs.length == 1) {\r\n              // Simple case: only one input mapping. Move the remote step over\r\n              //\r\n              mappingInputs[0].getRemoteInputSteps().add(remoteStep);\r\n            } else {\r\n              // TODO: figure out where this remote step needs to go and where\r\n              // it comes from.\r\n              //\r\n              throw new KettleException(\"Unsupported situation detected where a remote input step is expecting data to end up in a particular Mapping Input step of a sub-transformation.  To solve it, insert a dummy step before the mapping.\");\r\n            }\r\n          }\r\n          getRemoteInputSteps().clear();\r\n        }\r\n\r\n        // Re-populate with variables and parameters if necessary\r\n        //\r\n        setMappingParameters();\r\n\r\n        // Start the mapping/sub-transformation threads\r\n        //\r\n        data.mappingTrans.startThreads();\r\n\r\n        // The transformation still runs in the background and might have some\r\n        // more work to do.\r\n        // Since everything is running in the MappingThreads we don't have to do\r\n        // anything else here but wait...\r\n        //\r\n        if (getTransMeta().getTransformationType() == TransformationType.Normal) {\r\n          data.mappingTrans.waitUntilFinished();\r\n\r\n          // Set some statistics from the mapping...\r\n          // This will show up in Spoon, etc.\r\n          //\r\n          Result result = data.mappingTrans.getResult();\r\n          setErrors(result.getNrErrors());\r\n          setLinesRead(result.getNrLinesRead());\r\n          setLinesWritten(result.getNrLinesWritten());\r\n          setLinesInput(result.getNrLinesInput());\r\n          setLinesOutput(result.getNrLinesOutput());\r\n          setLinesUpdated(result.getNrLinesUpdated());\r\n          setLinesRejected(result.getNrLinesRejected());\r\n        }\r\n        return false;    \t\t    \t\r\n    \t\t\r\n\t\t\tcase SingleThreaded:\r\n\t\t\t  \r\n\t\t\t  if (mappingInputs.length>1 || mappingOutputs.length>1) {\r\n\t\t\t    throw new KettleException(\"Multiple input or output steps are not supported for a single threaded mapping.\");\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  // Object[] row = getRow();\r\n\t\t\t  // RowMetaInterface rowMeta = getInputRowMeta();\r\n\t\t\t  \r\n\t\t\t  // for (int count=0;count<(data.mappingTransMeta.getSizeRowset()/2) && row!=null;count++) {\r\n\t\t\t  //   // Pass each row over to the mapping input step, fill the buffer...\r\n\t\t\t  //\r\n\t\t\t  //  mappingInputs[0].getInputRowSets().get(0).putRow(rowMeta, row);\r\n\t\t\t  //  \r\n\t      //  row = getRow();\r\n\t\t\t  // }\r\n\t\t\t  \r\n\t\t\t  \r\n\t\t\t  System.out.println(\"# of input buffers: \"+mappingInputs[0].getInputRowSets().size());\r\n        if (mappingInputs[0].getInputRowSets().size()>0) {\r\n          System.out.println(\"Input buffer 0 size: \"+mappingInputs[0].getInputRowSets().get(0).size());\r\n        }\r\n        \r\n\t\t\t  // Now execute one batch...\r\n\t\t\t  //\r\n\t\t\t  boolean result = data.singleThreadedTransExcecutor.oneIteration();\r\n\t\t\t  if (!result) {\r\n\t\t\t    data.singleThreadedTransExcecutor.dispose();\r\n\t\t\t    setOutputDone();\r\n\t\t\t    return false;\r\n\t\t\t  }\r\n\t\t\t  return true;\r\n\t\t\t  \r\n\t\t\tdefault:\r\n\t\t\t  throw new KettleException(\"Transformation type '\"+data.mappingTransMeta.getTransformationType().getDescription()+\"' is an unsupported transformation type for a mapping\");\r\n\t\t\t}\n    }\r\n    catch(Throwable t)\r\n    {\r\n      // Some unexpected situation occurred.\r\n      // Better to stop the mapping transformation.\r\n      //\r\n      if (data.mappingTrans!=null) data.mappingTrans.stopAll();\r\n      \r\n      // Forward the exception...\r\n      //\r\n      throw new KettleException(t);\r\n    }\r\n\t}","id":40849,"modified_method":"/**\n     * Process a single row.  In our case, we send one row of data to a piece of transformation.\n     * In the transformation, we look up the MappingInput step to send our rows to it.\n     * As a consequence, for the time being, there can only be one MappingInput and one MappingOutput step in the Mapping.\n     */\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\r\n\t\ttry\r\n\t\t{\n\t\t\tmeta=(MappingMeta)smi;\n\t\t\tdata=(MappingData)sdi;\r\n\r\n\t\t\tMappingInput[] mappingInputs = data.mappingTrans.findMappingInput();\r\n\t\t\tMappingOutput[] mappingOutputs = data.mappingTrans.findMappingOutput();\r\n      \r\n\t\t\tswitch(data.mappingTransMeta.getTransformationType()) {\n\t\t\t  case Normal:\r\n\t      case SerialSingleThreaded:\r\n\t\t\t\r\n        // Before we start, let's see if there are loose ends to tie up...\r\n        //\r\n        if (!getInputRowSets().isEmpty()) {\r\n          for (RowSet rowSet : new ArrayList<RowSet>(getInputRowSets())) {\r\n            // Pass this rowset down to a mapping input step in the\r\n            // sub-transformation...\r\n            //\r\n            if (mappingInputs.length == 1) {\r\n              // Simple case: only one input mapping. Move the RowSet over\r\n              //\r\n              mappingInputs[0].getInputRowSets().add(rowSet);\r\n            } else {\r\n              // Difficult to see what's going on here.\r\n              // TODO: figure out where this RowSet needs to go and where it\r\n              // comes from.\r\n              //\r\n              throw new KettleException(\"Unsupported situation detected where more than one Mapping Input step needs to be handled.  To solve it, insert a dummy step before the mapping step.\");\r\n            }\r\n          }\r\n          getInputRowSets().clear();\r\n        }\r\n\r\n        // Do the same thing for remote input steps...\r\n        //\r\n        if (!getRemoteInputSteps().isEmpty()) {\r\n          // The remote server is likely a master or a slave server sending data\r\n          // over remotely to this mapping.\r\n          // However, the data needs to end up at a Mapping Input step of the\r\n          // sub-transformation, not in this step.\r\n          // We can move over the remote steps to the Mapping Input step as long\r\n          // as the threads haven't started yet.\r\n          //\r\n          for (RemoteStep remoteStep : getRemoteInputSteps()) {\r\n            // Pass this rowset down to a mapping input step in the\r\n            // sub-transformation...\r\n            //\r\n            if (mappingInputs.length == 1) {\r\n              // Simple case: only one input mapping. Move the remote step over\r\n              //\r\n              mappingInputs[0].getRemoteInputSteps().add(remoteStep);\r\n            } else {\r\n              // TODO: figure out where this remote step needs to go and where\r\n              // it comes from.\r\n              //\r\n              throw new KettleException(\"Unsupported situation detected where a remote input step is expecting data to end up in a particular Mapping Input step of a sub-transformation.  To solve it, insert a dummy step before the mapping.\");\r\n            }\r\n          }\r\n          getRemoteInputSteps().clear();\r\n        }\r\n\r\n        // Start the mapping/sub-transformation threads\r\n        //\r\n        data.mappingTrans.startThreads();\r\n\r\n        // The transformation still runs in the background and might have some\r\n        // more work to do.\r\n        // Since everything is running in the MappingThreads we don't have to do\r\n        // anything else here but wait...\r\n        //\r\n        if (getTransMeta().getTransformationType() == TransformationType.Normal) {\r\n          data.mappingTrans.waitUntilFinished();\r\n\r\n          // Set some statistics from the mapping...\r\n          // This will show up in Spoon, etc.\r\n          //\r\n          Result result = data.mappingTrans.getResult();\r\n          setErrors(result.getNrErrors());\r\n          setLinesRead(result.getNrLinesRead());\r\n          setLinesWritten(result.getNrLinesWritten());\r\n          setLinesInput(result.getNrLinesInput());\r\n          setLinesOutput(result.getNrLinesOutput());\r\n          setLinesUpdated(result.getNrLinesUpdated());\r\n          setLinesRejected(result.getNrLinesRejected());\r\n        }\r\n        return false;    \t\t    \t\r\n    \t\t\r\n\t\t\tcase SingleThreaded:\r\n\t\t\t  \r\n\t\t\t  if (mappingInputs.length>1 || mappingOutputs.length>1) {\r\n\t\t\t    throw new KettleException(\"Multiple input or output steps are not supported for a single threaded mapping.\");\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  // Object[] row = getRow();\r\n\t\t\t  // RowMetaInterface rowMeta = getInputRowMeta();\r\n\t\t\t  \r\n\t\t\t  // for (int count=0;count<(data.mappingTransMeta.getSizeRowset()/2) && row!=null;count++) {\r\n\t\t\t  //   // Pass each row over to the mapping input step, fill the buffer...\r\n\t\t\t  //\r\n\t\t\t  //  mappingInputs[0].getInputRowSets().get(0).putRow(rowMeta, row);\r\n\t\t\t  //  \r\n\t      //  row = getRow();\r\n\t\t\t  // }\r\n\t\t\t  \r\n\t\t\t  \r\n\t\t\t  System.out.println(\"# of input buffers: \"+mappingInputs[0].getInputRowSets().size());\r\n        if (mappingInputs[0].getInputRowSets().size()>0) {\r\n          System.out.println(\"Input buffer 0 size: \"+mappingInputs[0].getInputRowSets().get(0).size());\r\n        }\r\n        \r\n\t\t\t  // Now execute one batch...\r\n\t\t\t  //\r\n\t\t\t  boolean result = data.singleThreadedTransExcecutor.oneIteration();\r\n\t\t\t  if (!result) {\r\n\t\t\t    data.singleThreadedTransExcecutor.dispose();\r\n\t\t\t    setOutputDone();\r\n\t\t\t    return false;\r\n\t\t\t  }\r\n\t\t\t  return true;\r\n\t\t\t  \r\n\t\t\tdefault:\r\n\t\t\t  throw new KettleException(\"Transformation type '\"+data.mappingTransMeta.getTransformationType().getDescription()+\"' is an unsupported transformation type for a mapping\");\r\n\t\t\t}\n    }\r\n    catch(Throwable t)\r\n    {\r\n      // Some unexpected situation occurred.\r\n      // Better to stop the mapping transformation.\r\n      //\r\n      if (data.mappingTrans!=null) data.mappingTrans.stopAll();\r\n      \r\n      // Forward the exception...\r\n      //\r\n      throw new KettleException(t);\r\n    }\r\n\t}","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi) {\r\n    meta = (MappingMeta) smi;\r\n    data = (MappingData) sdi;\r\n\r\n    if (super.init(smi, sdi)) {\r\n      // First we need to load the mapping (transformation)\r\n      try {\r\n        // Pass the repository down to the metadata object...\r\n        //\r\n        meta.setRepository(getTransMeta().getRepository());\r\n\r\n        data.mappingTransMeta = MappingMeta.loadMappingMeta(meta, meta.getRepository(), this);\r\n        if (data.mappingTransMeta != null) // Do we have a mapping at all?\r\n        {\r\n\r\n          // Set the parameters statically or dynamically\r\n          //\r\n          setMappingParameters();\r\n\r\n          // OK, now prepare the execution of the mapping.\r\n          // This includes the allocation of RowSet buffers, the creation of the\r\n          // sub-transformation threads, etc.\r\n          //\r\n          prepareMappingExecution();\r\n          \r\n          lookupStatusStepNumbers();\r\n          // That's all for now...\r\n          return true;\r\n        } else {\r\n          logError(\"No valid mapping was specified!\");\r\n          return false;\r\n        }\r\n      } catch (Exception e) {\r\n        logError(\"Unable to load the mapping transformation because of an error : \" + e.toString());\r\n        logError(Const.getStackTracker(e));\r\n      }\r\n\r\n    }\r\n    return false;\r\n  }","id":40850,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi) {\r\n    meta = (MappingMeta) smi;\r\n    data = (MappingData) sdi;\r\n\r\n    if (super.init(smi, sdi)) {\r\n      // First we need to load the mapping (transformation)\r\n      try {\r\n        // Pass the repository down to the metadata object...\r\n        //\r\n        meta.setRepository(getTransMeta().getRepository());\r\n\r\n        data.mappingTransMeta = MappingMeta.loadMappingMeta(meta, meta.getRepository(), this);\r\n        if (data.mappingTransMeta != null) // Do we have a mapping at all?\r\n        {\r\n\r\n          // OK, now prepare the execution of the mapping.\r\n          // This includes the allocation of RowSet buffers, the creation of the\r\n          // sub-transformation threads, etc.\r\n          //\r\n          prepareMappingExecution();\r\n          \r\n          lookupStatusStepNumbers();\r\n          // That's all for now...\r\n          return true;\r\n        } else {\r\n          logError(\"No valid mapping was specified!\");\r\n          return false;\r\n        }\r\n      } catch (Exception e) {\r\n        logError(\"Unable to load the mapping transformation because of an error : \" + e.toString());\r\n        logError(Const.getStackTracker(e));\r\n      }\r\n\r\n    }\r\n    return false;\r\n  }","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void prepareMappingExecution() throws KettleException {\r\n\t      // Set the type to single threaded in case the user forgot...\r\n\t      //\r\n\t      data.mappingTransMeta.setTransformationType(TransformationType.SingleThreaded);\r\n\t  \r\n\t      // Pass the parameters down to the sub-transformation.\r\n\t      //\r\n\t      passParameters();\r\n\t      \n        // Create the transformation from meta-data...\n\t\t    //\n        data.mappingTrans = new Trans(data.mappingTransMeta, getTrans());\r\n        \r\n        // Disable thread priority managment as it will slow things down needlessly.\r\n        // The single threaded engine doesn't use threads and doesn't need row locking.\r\n        //\r\n        data.mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);\r\n        \r\n        // Leave a path up so that we can set variables in sub-transformations...\r\n        //\r\n        data.mappingTrans.setParentTrans(getTrans());\r\n        \n        // Pass down the safe mode flag to the mapping...\n        //\n        data.mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());\r\n        \r\n        // Also set the name of this step in the mapping transformation for logging purposes\r\n        //\r\n        data.mappingTrans.setMappingStepName(getStepname());\r\n        \r\n        // Pass the servlet print writer\r\n        //\r\n        data.mappingTrans.setServletPrintWriter(getTrans().getServletPrintWriter());\r\n        \r\n        // prepare the execution \r\n        //\r\n        data.mappingTrans.prepareExecution(null);\r\n        \r\n        // If the inject step is a mapping input step, tell it all is OK...\r\n        //\r\n        if (data.injectStepMeta.isMappingInput()) {\r\n          MappingInputData mappingInputData = (MappingInputData) data.mappingTrans.findDataInterface(data.injectStepMeta.getName());\r\n          mappingInputData.sourceSteps=new StepInterface[0];\r\n          mappingInputData.valueRenames = new ArrayList<MappingValueRename>();\r\n        }\r\n        \r\n        // Add row producer & row listener\r\n        //\r\n        data.rowProducer = data.mappingTrans.addRowProducer(meta.getInjectStep(), 0);\r\n        \r\n        StepInterface retrieveStep = data.mappingTrans.getStepInterface(meta.getRetrieveStep(), 0);\r\n        retrieveStep.addRowListener(new RowAdapter() {\r\n          @Override\r\n          public void rowWrittenEvent(RowMetaInterface rowMeta, Object[] row) throws KettleStepException {\r\n            // Simply pass it along to the next steps after the SingleThreader\r\n            //\r\n            SingleThreader.this.putRow(rowMeta, row);\r\n          }\r\n        });\r\n        \r\n        data.mappingTrans.startThreads();\r\n        \r\n        // Create the executor...\r\n        //\r\n        data.executor = new SingleThreadedTransExecutor(data.mappingTrans);\r\n        \r\n        // We launch the transformation in the processRow when the first row is received.\r\n        // This will allow the correct variables to be passed.\r\n        // Otherwise the parent is the init() thread which will be gone once the init is done.\r\n        //\r\n        try {\r\n          boolean ok = data.executor.init();\r\n          if (!ok) {\r\n            throw new KettleException(BaseMessages.getString(PKG, \"SingleThreader.Exception.UnableToInitSingleThreadedTransformation\"));\r\n          }\r\n        }\r\n        catch(KettleException e) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"SingleThreader.Exception.UnableToPrepareExecutionOfMapping\"), e);\r\n        }\r\n        \r\n        // Add the mapping transformation to the active sub-transformations map in the parent transformation\r\n        //\r\n        getTrans().getActiveSubtransformations().put(getStepname(), data.mappingTrans);\n\t}","id":40851,"modified_method":"public void prepareMappingExecution() throws KettleException {\r\n\t      // Set the type to single threaded in case the user forgot...\r\n\t      //\r\n\t      data.mappingTransMeta.setTransformationType(TransformationType.SingleThreaded);\r\n\t  \r\n        // Create the transformation from meta-data...\n\t\t    //\n        data.mappingTrans = new Trans(data.mappingTransMeta, getTrans());\r\n        \r\n        // Pass the parameters down to the sub-transformation.\r\n        //\r\n        passParameters();\r\n        \r\n        // Disable thread priority managment as it will slow things down needlessly.\r\n        // The single threaded engine doesn't use threads and doesn't need row locking.\r\n        //\r\n        data.mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);\r\n        \r\n        // Leave a path up so that we can set variables in sub-transformations...\r\n        //\r\n        data.mappingTrans.setParentTrans(getTrans());\r\n        \n        // Pass down the safe mode flag to the mapping...\n        //\n        data.mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());\r\n        \r\n        // Also set the name of this step in the mapping transformation for logging purposes\r\n        //\r\n        data.mappingTrans.setMappingStepName(getStepname());\r\n        \r\n        // Pass the servlet print writer\r\n        //\r\n        data.mappingTrans.setServletPrintWriter(getTrans().getServletPrintWriter());\r\n        \r\n        // prepare the execution \r\n        //\r\n        data.mappingTrans.prepareExecution(null);\r\n        \r\n        // If the inject step is a mapping input step, tell it all is OK...\r\n        //\r\n        if (data.injectStepMeta.isMappingInput()) {\r\n          MappingInputData mappingInputData = (MappingInputData) data.mappingTrans.findDataInterface(data.injectStepMeta.getName());\r\n          mappingInputData.sourceSteps=new StepInterface[0];\r\n          mappingInputData.valueRenames = new ArrayList<MappingValueRename>();\r\n        }\r\n        \r\n        // Add row producer & row listener\r\n        //\r\n        data.rowProducer = data.mappingTrans.addRowProducer(meta.getInjectStep(), 0);\r\n        \r\n        StepInterface retrieveStep = data.mappingTrans.getStepInterface(meta.getRetrieveStep(), 0);\r\n        retrieveStep.addRowListener(new RowAdapter() {\r\n          @Override\r\n          public void rowWrittenEvent(RowMetaInterface rowMeta, Object[] row) throws KettleStepException {\r\n            // Simply pass it along to the next steps after the SingleThreader\r\n            //\r\n            SingleThreader.this.putRow(rowMeta, row);\r\n          }\r\n        });\r\n        \r\n        data.mappingTrans.startThreads();\r\n        \r\n        // Create the executor...\r\n        //\r\n        data.executor = new SingleThreadedTransExecutor(data.mappingTrans);\r\n        \r\n        // We launch the transformation in the processRow when the first row is received.\r\n        // This will allow the correct variables to be passed.\r\n        // Otherwise the parent is the init() thread which will be gone once the init is done.\r\n        //\r\n        try {\r\n          boolean ok = data.executor.init();\r\n          if (!ok) {\r\n            throw new KettleException(BaseMessages.getString(PKG, \"SingleThreader.Exception.UnableToInitSingleThreadedTransformation\"));\r\n          }\r\n        }\r\n        catch(KettleException e) {\r\n          throw new KettleException(BaseMessages.getString(PKG, \"SingleThreader.Exception.UnableToPrepareExecutionOfMapping\"), e);\r\n        }\r\n        \r\n        // Add the mapping transformation to the active sub-transformations map in the parent transformation\r\n        //\r\n        getTrans().getActiveSubtransformations().put(getStepname(), data.mappingTrans);\n\t}","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void passParameters() throws KettleException {\r\n\t  \r\n\t  String[] parameters;\r\n\t  String[] parameterValues;\r\n\t  \r\n\t  if (meta.isPassingAllParameters()) {\r\n\t    // We pass the values for all the parameters from the parent transformation\r\n\t    //\r\n\t    parameters = data.mappingTransMeta.listParameters();\r\n\t    parameterValues = new String[parameters.length];\r\n\t    for (int i=0;i<parameters.length;i++) {\r\n\t      parameterValues[i] = environmentSubstitute(parameters[i]);\r\n\t    }\r\n\t  } else {\r\n\t    // We pass down the listed variables with the specified values...\r\n\t    //\r\n\t    parameters = meta.getParameters();\r\n\t    parameterValues = new String[parameters.length];\r\n      for (int i=0;i<parameters.length;i++) {\r\n        parameterValues[i] = environmentSubstitute(meta.getParameterValues()[i]);\r\n      }\r\n\t  }\r\n\t  \r\n\t  for (int i=0;i<parameters.length;i++) {\r\n\t    String value = Const.NVL(parameterValues[i], \"\");\r\n\t    \r\n      data.mappingTransMeta.setParameterValue(parameters[i], value);\r\n\t  }\r\n  }","id":40852,"modified_method":"private void passParameters() throws KettleException {\r\n\t  \r\n\t  String[] parameters;\r\n\t  String[] parameterValues;\r\n\t  \r\n\t  if (meta.isPassingAllParameters()) {\r\n\t    // We pass the values for all the parameters from the parent transformation\r\n\t    //\r\n\t    parameters = data.mappingTransMeta.listParameters();\r\n\t    parameterValues = new String[parameters.length];\r\n\t    for (int i=0;i<parameters.length;i++) {\r\n\t      parameterValues[i] = getVariable(parameters[i]);\r\n\t    }\r\n\t  } else {\r\n\t    // We pass down the listed variables with the specified values...\r\n\t    //\r\n\t    parameters = meta.getParameters();\r\n\t    parameterValues = new String[parameters.length];\r\n      for (int i=0;i<parameters.length;i++) {\r\n        parameterValues[i] = environmentSubstitute(meta.getParameterValues()[i]);\r\n      }\r\n\t  }\r\n\t  \r\n\t  for (int i=0;i<parameters.length;i++) {\r\n\t    String value = Const.NVL(parameterValues[i], \"\");\r\n\t    \r\n      data.mappingTrans.setParameterValue(parameters[i], value);\r\n\t  }\r\n\t  \r\n\t  data.mappingTrans.activateParameters();\r\n  }","commit_id":"147ad53489be2bfb92e7f800a60279b29cbeb1c3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Execute this job entry and return the result.\n     * In this case it means, just set the result boolean in the Result class.\n     * @param result The result of the previous execution\n     * @param nr the job entry number\n     * @param rep the repository connection to use\n     * @param parentJob the parent job\n     * @return The Result of the execution.\n     */\n    public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t\tLogWriter log       = LogWriter.getInstance();\n\t\tresult.setEntryNr( nr );\n\n\t\tLog4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\r\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), Messages.getString(\"JobTrans.Error.UnableOpenAppender\",getLogFilename(),e.toString()));\r\n                \n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobTrans.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\r\n        \n\t\t// Open the transformation...\n\t\t// Default directory for now...\n        // XXX: This seems a bit odd here.  These three log messages all work off of getFilename().  Why are there three?\n        if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningFile\",environmentSubstitute(getFilename())));\r\n        if (!Const.isEmpty(getFilename()))\n        {\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTrans\",environmentSubstitute(getFilename())));\n        }\n        else\n        {\r\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTransInDirec\",environmentSubstitute(getFilename()),environmentSubstitute(directory)));\n        }\n\n        // Load the transformation only once for the complete loop!\r\n    \t// Throws an exception if it was not possible to load the transformation.  For example, the XML file doesn't exist or the repository is down.\r\n    \t// Log the stack trace and return an error condition from this\r\n        //\r\n        TransMeta transMeta = getTransMeta(rep);\r\n\n        int iteration = 0;\n        String args1[] = arguments;\n        if (args1==null || args1.length==0) // No arguments set, look at the parent job.\n        {\n            args1 = parentJob.getJobMeta().getArguments();\n        }\n        //initializeVariablesFrom(parentJob);\n\n        //\n        // For the moment only do variable translation at the start of a job, not\n        // for every input row (if that would be switched on). This is for safety,\n        // the real argument setting is later on.\n        //\n        String args[] = null;\n        if ( args1 != null )\n        {\n            args = new String[args1.length];\n            for ( int idx = 0; idx < args1.length; idx++ )\n            {\n            \targs[idx] = environmentSubstitute(args1[idx]);\n            }\n        }\n\r\n        NamedParams namedParam = new NamedParamsDefault();\r\n        if ( parameters != null )  {\r\n        \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n            {\r\n        \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n        \t\t\t// We have a parameter\r\n        \t\t\t\r\n        \t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n        \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n\t\t\t                     Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n        \t\t\t}            \t\t\t\t            \t\t\r\n        \t\t\telse  {\r\n        \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n        \t\t\t}\r\n        \t\t}                                \r\n            }\r\n        }\r\n                \n        RowMetaAndData resultRow = null;\n        boolean first = true;\n        List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n        while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) && !parentJob.isStopped() )\n        {\r\n            if (execPerRow)\r\n            {\r\n            \tresult.getRows().clear(); // Otherwise we double the amount of rows every iteration in the simple cases.\r\n            }\r\n            \n            first=false;\n            if (rows!=null && execPerRow)\n            {\n            \tresultRow = rows.get(iteration);\n            }\n            else\n            {\n            \tresultRow = null;\n            }\n\n    \t\ttry\n    \t\t{\n                if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.StartingTrans\",getFilename(),getName(),getDescription()));\n\n                // Set the result rows for the next one...\n                transMeta.setPreviousResult(result);\n\n                if (clearResultRows)\n                {\n                    transMeta.getPreviousResult().setRows(new ArrayList<RowMetaAndData>());\n                }\n\n                if (clearResultFiles)\n                {\n                    transMeta.getPreviousResult().getResultFiles().clear();\n                }\n\n                /*\n                 * Set one or more \"result\" rows on the transformation...\n                 */\n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n\n                        // This previous result rows list can be either empty or not.\n                        // Depending on the checkbox \"clear result rows\"\n                        // In this case, it would execute the transformation with one extra row each time\n                        // Can't figure out a real use-case for it, but hey, who am I to decide that, right?\n                        // :-)\n                        //\n                        transMeta.getPreviousResult().getRows().addAll(newList);\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                    \t// do nothing\n                    }\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n\n                // Execute this transformation across a cluster of servers\n                //\n                if (clustering)\n                {\n                    TransExecutionConfiguration executionConfiguration = new TransExecutionConfiguration();\n                    executionConfiguration.setClusterPosting(true);\n                    executionConfiguration.setClusterPreparing(true);\n                    executionConfiguration.setClusterStarting(true);\n                    executionConfiguration.setClusterShowingTransformation(false);\n                    executionConfiguration.setSafeModeEnabled(false);\n                    executionConfiguration.setRepository(rep);\r\n                    executionConfiguration.setLogLevel(log.getLogLevel());\r\n                    \r\n                    // Also pass the variables from the transformation into the execution configuration\r\n                    // That way it can go over the HTTP connection to the slave server.\r\n                    //\r\n                    executionConfiguration.setVariables(transMeta);\r\n                    \r\n                    // Also set the arguments...\r\n                    //\r\n                    executionConfiguration.setArgumentStrings(args);\n                    \n                    TransSplitter transSplitter = Trans.executeClustered(transMeta, executionConfiguration );\n                    \n                    // Monitor the running transformations, wait until they are done.\n                    // Also kill them all if anything goes bad\n                    // Also clean up afterwards...\n                    //\n                    long errors = Trans.monitorClusteredTransformation(toString(), transSplitter, parentJob);\n                    \n                    Result clusterResult = Trans.getClusteredTransformationResult(toString(), transSplitter, parentJob); \n                    result.clear();\n                    result.add(clusterResult);\n                    \n                    result.setNrErrors(result.getNrErrors()+errors);\n\n                }\n                // Execute this transformation remotely\n                //\n                else if (remoteSlaveServer!=null)\n                {\n                \t// Remote execution...\n                \t//\n                \tTransExecutionConfiguration transExecutionConfiguration = new TransExecutionConfiguration();\n                \ttransExecutionConfiguration.setPreviousResult(transMeta.getPreviousResult().clone());\n                \ttransExecutionConfiguration.setArgumentStrings(args);\n                \ttransExecutionConfiguration.setVariables(this);\n                \ttransExecutionConfiguration.setRemoteServer(remoteSlaveServer);\r\n                \ttransExecutionConfiguration.setLogLevel(log.getLogLevel());\n                \t\n                \t// Send the XML over to the slave server\n                \t// Also start the transformation over there...\n                \t//\n                \tTrans.sendXMLToSlaveServer(transMeta, transExecutionConfiguration);\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerTransStatus transStatus=null;\r\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\ttransStatus = remoteSlaveServer.getTransStatus(transMeta.getName());\n\t\t\t\t\t\t\tif (!transStatus.isRunning())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The transformation is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tResult remoteResult = transStatus.getResult(); \n\t\t\t                    result.clear();\n\t\t\t                    result.add(remoteResult);\r\n\t\t\t                    \r\n\t\t\t                    // In case you manually stop the remote trans (browser etc), make sure it's marked as an error\r\n\t\t\t                    //\r\n\t\t\t                    if (remoteResult.isStopped()) {\r\n\t\t\t                    \tresult.setNrErrors(result.getNrErrors()+1); //\r\n\t\t\t                    }\r\n\t\t\t                    \r\n\t\t\t                    // Make sure to clean up : write a log record etc, close any left-over sockets etc.\r\n\t\t\t                    //\r\n\t\t\t                    remoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n\t\t\t                    \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\r\n                \t\t\t\n\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.Error.UnableContactSlaveServer\",\"\"+remoteSlaveServer,transMeta.getName()));\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(2000); } catch(InterruptedException e) {} ; // sleep for 2 seconds\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n                \t\t// \r\n                \t\tif (transStatus==null || transStatus.isRunning()) {\r\n                \t\t\t// Try a remote abort ...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.stopTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// And a cleanup...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// Set an error state!\r\n                \t\t\t//\r\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\r\n                \t\t}\r\n                \t}\n                }\n                // Execute this transformation on the local machine\n                //\n                else // Local execution...\n                {\r\n                \t// transMeta.copyParametersFrom(namedParam);\r\n                \t\r\n\t                transMeta.clearParameters();\r\n\t                String[] parameterNames = transMeta.listParameters();\r\n\t                for (int idx = 0; idx < parameterNames.length; idx++)  {\r\n\t                \t// Grab the parameter value set in the Trans job entry\r\n\t                \t//\r\n\t                    String thisValue = namedParam.getParameterValue(parameterNames[idx]);\r\n\t                    if (!Const.isEmpty(thisValue)) {\r\n\t                    \t// Set the value as specified by the user in the job entry\r\n\t                    \t//\r\n\t                    \ttransMeta.setParameterValue(parameterNames[idx], thisValue);\r\n\t                    } else {\r\n\t                    \t// See if the parameter had a value set in the parent job...\r\n\t                    \t// This value should pass down to the transformation if that's what we opted to do.\r\n\t                    \t//\r\n\t                    \tif (isPassingAllParameters()) {\r\n\t\t                    \tString parentValue = parentJob.getParameterValue(parameterNames[idx]);\r\n\t\t                    \tif (!Const.isEmpty(parentValue)) {\r\n\t\t                    \t\ttransMeta.setParameterValue(parameterNames[idx], parentValue);\r\n\t\t                    \t}\r\n\t                    \t}\r\n\t                    }\r\n\t                }\r\n                \t\n                    // Create the transformation from meta-data\r\n\t                //\n                    Trans trans = new Trans(transMeta);\n\r\n                    // Pass the socket repository as early as possible...\r\n                    //\r\n                    trans.setSocketRepository(parentJob.getSocketRepository());\r\n                    \n                    if (parentJob.getJobMeta().isBatchIdPassed())\n                    {\n                        trans.setPassedBatchId(parentJob.getPassedBatchId());\n                    }\n                    \n                    // set the parent job on the transformation, variables are taken from here...\n                    trans.setParentJob(parentJob);\n                    trans.setParentVariableSpace(parentJob);                    \n\n                    // First get the root job\n                    //\n                    Job rootJob = parentJob;\n                    while (rootJob.getParentJob()!=null) rootJob=rootJob.getParentJob();\n                    \n                    // Get the start and end-date from the root job...\n                    //\n                    trans.setJobStartDate( rootJob.getStartDate() );\n                    trans.setJobEndDate( rootJob.getEndDate() );\n                    \n                    try {\n            \t\t\t// Start execution...\n                    \t//\n                    \ttrans.execute(args);\n\n                    \t// Wait until we're done with it...\n                    \t//\n        \t\t\t\twhile (!trans.isFinished() && !parentJob.isStopped() && trans.getErrors() == 0)\n        \t\t\t\t{\n        \t\t\t\t\ttry { Thread.sleep(0,500);}\n        \t\t\t\t\tcatch(InterruptedException e) { }\n        \t\t\t\t}\n\n        \t\t\t\tif (parentJob.isStopped() || trans.getErrors() != 0)\n        \t\t\t\t{\n        \t\t\t\t\ttrans.stopAll();\n        \t\t\t\t\ttrans.waitUntilFinished();\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_STOP);\n                            result.setNrErrors(1);\n        \t\t\t\t}\n        \t\t\t\telse\n        \t\t\t\t{\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n        \t\t\t\t}\n        \t\t\t\tResult newResult = trans.getResult();\n\n                        result.clear(); // clear only the numbers, NOT the files or rows.\n                        result.add(newResult);\n\n                        // Set the result rows too...\n                        result.setRows(newResult.getRows());\n\n                        if (setLogfile)\n                        {\n                        \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, KettleVFS.getFileObject(getLogFilename()), parentJob.getJobname(), toString());\n                            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n        \t\t\t\t}\n                    }\n                    catch (KettleException e) {\r\n                    \t\n                        log.logError(toString(), Messages.getString(\"JobTrans.Error.UnablePrepareExec\"), e);\n        \t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t}\n                }\n    \t\t}\n    \t\tcatch(Exception e)\n    \t\t{\r\n    \t\t\t\n    \t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.ErrorUnableOpenTrans\",e.getMessage()));\n                log.logError(toString(), Const.getStackTracker(e));\n    \t\t\tresult.setNrErrors(1);\n    \t\t}\n            iteration++;\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n        }\n\n\t\tif (result.getNrErrors()==0)\n\t\t{\n\t\t\tresult.setResult( true );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t}\n\n\t\t// Hint the VM to release handles.\n\t\tSystem.gc();\n\t\t\n\t\treturn result;\n\t}","id":40853,"modified_method":"/**\n     * Execute this job entry and return the result.\n     * In this case it means, just set the result boolean in the Result class.\n     * @param result The result of the previous execution\n     * @param nr the job entry number\n     * @param rep the repository connection to use\n     * @param parentJob the parent job\n     * @return The Result of the execution.\n     */\n    public Result execute(Result result, int nr, Repository rep, Job parentJob) throws KettleException\n\t{\n\t\tLogWriter log       = LogWriter.getInstance();\n\t\tresult.setEntryNr( nr );\n\n\t\tLog4jFileAppender appender = null;\n        int backupLogLevel = log.getLogLevel();\n        if (setLogfile)\n        {\n            try\n            {\r\n                appender = LogWriter.createFileAppender(environmentSubstitute(getLogFilename()), true,setAppendLogfile);\n            }\n            catch(KettleException e)\n            {\n                log.logError(toString(), Messages.getString(\"JobTrans.Error.UnableOpenAppender\",getLogFilename(),e.toString()));\r\n                \n                log.logError(toString(), Const.getStackTracker(e));\n                result.setNrErrors(1);\n                result.setResult(false);\n                return result;\n            }\n            log.addAppender(appender);\n            log.setLogLevel(loglevel);\n        }\n\r\n        // Figure out the remote slave server...\r\n        //\r\n        SlaveServer remoteSlaveServer = null;\r\n        if (!Const.isEmpty(remoteSlaveServerName)) {\r\n        \tString realRemoteSlaveServerName = environmentSubstitute(remoteSlaveServerName);\r\n        \tremoteSlaveServer = parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);\r\n        \tif (remoteSlaveServer==null) {\r\n        \t\tthrow new KettleException(Messages.getString(\"JobTrans.Exception.UnableToFindRemoteSlaveServer\",realRemoteSlaveServerName));\r\n        \t}\r\n        }\r\n        \n\t\t// Open the transformation...\n\t\t// Default directory for now...\n        // XXX: This seems a bit odd here.  These three log messages all work off of getFilename().  Why are there three?\n        if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningFile\",environmentSubstitute(getFilename())));\r\n        if (!Const.isEmpty(getFilename()))\n        {\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTrans\",environmentSubstitute(getFilename())));\n        }\n        else\n        {\r\n            if (log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.Log.OpeningTransInDirec\",environmentSubstitute(getFilename()),environmentSubstitute(directory)));\n        }\n\n        // Load the transformation only once for the complete loop!\r\n    \t// Throws an exception if it was not possible to load the transformation.  For example, the XML file doesn't exist or the repository is down.\r\n    \t// Log the stack trace and return an error condition from this\r\n        //\r\n        TransMeta transMeta = getTransMeta(rep);\r\n\n        int iteration = 0;\n        String args1[] = arguments;\n        if (args1==null || args1.length==0) // No arguments set, look at the parent job.\n        {\n            args1 = parentJob.getJobMeta().getArguments();\n        }\n        //initializeVariablesFrom(parentJob);\n\n        //\n        // For the moment only do variable translation at the start of a job, not\n        // for every input row (if that would be switched on). This is for safety,\n        // the real argument setting is later on.\n        //\n        String args[] = null;\n        if ( args1 != null )\n        {\n            args = new String[args1.length];\n            for ( int idx = 0; idx < args1.length; idx++ )\n            {\n            \targs[idx] = environmentSubstitute(args1[idx]);\n            }\n        }\n\r\n        NamedParams namedParam = new NamedParamsDefault();\r\n        if ( parameters != null )  {\r\n        \tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n            {\r\n        \t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n        \t\t\t// We have a parameter\r\n        \t\t\t//\r\n        \t\t\tnamedParam.addParameterDefinition(parameters[idx], \"\", \"Job entry runtime\");\r\n        \t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n        \t\t\t\t// There is no field name specified.\r\n        \t\t\t\t//\r\n        \t\t\t\tString value = Const.NVL(environmentSubstitute(parameterValues[idx]), \"\"); \r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], value);            \t\t\t\t\r\n        \t\t\t}            \t\t\t\t            \t\t\r\n        \t\t\telse  {\r\n        \t\t\t\t// something filled in, in the field column but we have no incoming stream. yet.\r\n        \t\t\t\t//\r\n        \t\t\t\tnamedParam.setParameterValue(parameters[idx], \"\");\r\n        \t\t\t}\r\n        \t\t}                                \r\n            }\r\n        }\r\n                \n        RowMetaAndData resultRow = null;\n        boolean first = true;\n        List<RowMetaAndData> rows = new ArrayList<RowMetaAndData>(result.getRows());\n        while( ( first && !execPerRow ) || ( execPerRow && rows!=null && iteration<rows.size() && result.getNrErrors()==0 ) && !parentJob.isStopped() )\n        {\r\n            if (execPerRow)\r\n            {\r\n            \tresult.getRows().clear(); // Otherwise we double the amount of rows every iteration in the simple cases.\r\n            }\r\n            \n            first=false;\n            if (rows!=null && execPerRow)\n            {\n            \tresultRow = rows.get(iteration);\n            }\n            else\n            {\n            \tresultRow = null;\n            }\n\n    \t\ttry\n    \t\t{\n                if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobTrans.StartingTrans\",getFilename(),getName(),getDescription()));\n\n                // Set the result rows for the next one...\n                transMeta.setPreviousResult(result);\n\n                if (clearResultRows)\n                {\n                    transMeta.getPreviousResult().setRows(new ArrayList<RowMetaAndData>());\n                }\n\n                if (clearResultFiles)\n                {\n                    transMeta.getPreviousResult().getResultFiles().clear();\n                }\n\n                /*\n                 * Set one or more \"result\" rows on the transformation...\n                 */\n                if (execPerRow) // Execute for each input row\n                {\n                    if (argFromPrevious) // Copy the input row to the (command line) arguments\n                    {\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Just pass a single row\n                        List<RowMetaAndData> newList = new ArrayList<RowMetaAndData>();\n                        newList.add(resultRow);\n\n                        // This previous result rows list can be either empty or not.\n                        // Depending on the checkbox \"clear result rows\"\n                        // In this case, it would execute the transformation with one extra row each time\n                        // Can't figure out a real use-case for it, but hey, who am I to decide that, right?\n                        // :-)\n                        //\n                        transMeta.getPreviousResult().getRows().addAll(newList);\n                    }\r\n\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\n                else\n                {\n                    if (argFromPrevious)\n                    {\n                        // Only put the first Row on the arguments\n                        args = null;\n                        if (resultRow!=null)\n                        {\n                            args = new String[resultRow.size()];\n                            for (int i=0;i<resultRow.size();i++)\n                            {\n                                args[i] = resultRow.getString(i, null);\n                            }\n                        }\n                    }\n                    else\n                    {\n                    \t// do nothing\n                    }\r\n                    if ( paramsFromPrevious )  { // Copy the input the parameters\r\n                    \tif ( parameters != null )  {\r\n                    \t\tfor ( int idx = 0; idx < parameters.length; idx++ )\r\n                    \t\t{\r\n                    \t\t\tif ( !Const.isEmpty(parameters[idx]) )  {\r\n                    \t\t\t\t// We have a parameter\r\n                    \t\t\t\tif ( Const.isEmpty(Const.trim(parameterFieldNames[idx])) )  {\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(environmentSubstitute(parameterValues[idx]), \"\"));            \t\t\t\t\r\n                    \t\t\t\t}            \t\t\t\t            \t\t\r\n                    \t\t\t\telse  {\r\n                    \t\t\t\t\tString fieldValue = \"\";\r\n\r\n                    \t\t\t\t\tif (resultRow!=null)  {\r\n                    \t\t\t\t\t\tfieldValue = resultRow.getString(parameterFieldNames[idx], \"\");\r\n                    \t\t\t\t\t}\r\n                    \t\t\t\t\t// Get the value from the input stream\r\n                    \t\t\t\t\tnamedParam.setParameterValue(parameters[idx], \r\n                    \t\t\t\t\t\t\tConst.NVL(fieldValue, \"\"));\r\n                    \t\t\t\t}\r\n                    \t\t\t}                                    \t\r\n                    \t\t}\r\n                    \t}\r\n                    }\n                }\r\n                \r\n                // Handle the parameters...\r\n                //\r\n                transMeta.clearParameters();\r\n                String[] parameterNames = transMeta.listParameters();\r\n                for (int idx = 0; idx < parameterNames.length; idx++)  {\r\n                \t// Grab the parameter value set in the Trans job entry\r\n                \t//\r\n                    String thisValue = namedParam.getParameterValue(parameterNames[idx]);\r\n                    if (!Const.isEmpty(thisValue)) {\r\n                    \t// Set the value as specified by the user in the job entry\r\n                    \t//\r\n                    \ttransMeta.setParameterValue(parameterNames[idx], thisValue);\r\n                    } else {\r\n                    \t// See if the parameter had a value set in the parent job...\r\n                    \t// This value should pass down to the transformation if that's what we opted to do.\r\n                    \t//\r\n                    \tif (isPassingAllParameters()) {\r\n\t                    \tString parentValue = parentJob.getParameterValue(parameterNames[idx]);\r\n\t                    \tif (!Const.isEmpty(parentValue)) {\r\n\t                    \t\ttransMeta.setParameterValue(parameterNames[idx], parentValue);\r\n\t                    \t}\r\n                    \t}\r\n                    }\r\n                }\n\n                // Execute this transformation across a cluster of servers\n                //\n                if (clustering)\n                {\n                    TransExecutionConfiguration executionConfiguration = new TransExecutionConfiguration();\n                    executionConfiguration.setClusterPosting(true);\n                    executionConfiguration.setClusterPreparing(true);\n                    executionConfiguration.setClusterStarting(true);\n                    executionConfiguration.setClusterShowingTransformation(false);\n                    executionConfiguration.setSafeModeEnabled(false);\n                    executionConfiguration.setRepository(rep);\r\n                    executionConfiguration.setLogLevel(log.getLogLevel());\r\n                    \r\n                    // Also pass the variables from the transformation into the execution configuration\r\n                    // That way it can go over the HTTP connection to the slave server.\r\n                    //\r\n                    executionConfiguration.setVariables(transMeta);\r\n                    \r\n                    // Also set the arguments...\r\n                    //\r\n                    executionConfiguration.setArgumentStrings(args);\n                    \n                    TransSplitter transSplitter = Trans.executeClustered(transMeta, executionConfiguration );\n                    \n                    // Monitor the running transformations, wait until they are done.\n                    // Also kill them all if anything goes bad\n                    // Also clean up afterwards...\n                    //\n                    long errors = Trans.monitorClusteredTransformation(toString(), transSplitter, parentJob);\n                    \n                    Result clusterResult = Trans.getClusteredTransformationResult(toString(), transSplitter, parentJob); \n                    result.clear();\n                    result.add(clusterResult);\n                    \n                    result.setNrErrors(result.getNrErrors()+errors);\n\n                }\n                // Execute this transformation remotely\n                //\n                else if (remoteSlaveServer!=null)\n                {\n                \t// Remote execution...\n                \t//\n                \tTransExecutionConfiguration transExecutionConfiguration = new TransExecutionConfiguration();\n                \ttransExecutionConfiguration.setPreviousResult(transMeta.getPreviousResult().clone());\n                \ttransExecutionConfiguration.setArgumentStrings(args);\n                \ttransExecutionConfiguration.setVariables(this);\n                \ttransExecutionConfiguration.setRemoteServer(remoteSlaveServer);\r\n                \ttransExecutionConfiguration.setLogLevel(log.getLogLevel());\n                \t\n                \t// Send the XML over to the slave server\n                \t// Also start the transformation over there...\n                \t//\n                \tTrans.sendXMLToSlaveServer(transMeta, transExecutionConfiguration);\n                \t\n                \t// Now start the monitoring...\n                \t//\r\n                \tSlaveServerTransStatus transStatus=null;\r\n                \twhile (!parentJob.isStopped() && waitingToFinish)\n                \t{\n                \t\ttry \n                \t\t{\n\t\t\t\t\t\t\ttransStatus = remoteSlaveServer.getTransStatus(transMeta.getName());\n\t\t\t\t\t\t\tif (!transStatus.isRunning())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// The transformation is finished, get the result...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tResult remoteResult = transStatus.getResult(); \n\t\t\t                    result.clear();\n\t\t\t                    result.add(remoteResult);\r\n\t\t\t                    \r\n\t\t\t                    // In case you manually stop the remote trans (browser etc), make sure it's marked as an error\r\n\t\t\t                    //\r\n\t\t\t                    if (remoteResult.isStopped()) {\r\n\t\t\t                    \tresult.setNrErrors(result.getNrErrors()+1); //\r\n\t\t\t                    }\r\n\t\t\t                    \r\n\t\t\t                    // Make sure to clean up : write a log record etc, close any left-over sockets etc.\r\n\t\t\t                    //\r\n\t\t\t                    remoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n\t\t\t                    \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n                \t\tcatch (Exception e1) {\r\n                \t\t\t\n\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.Error.UnableContactSlaveServer\",\"\"+remoteSlaveServer,transMeta.getName()));\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\n\t\t\t\t\t\t\tbreak; // Stop looking too, chances are too low the server will come back on-line\n\t\t\t\t\t\t}\n                \t\t\n                \t\ttry { Thread.sleep(2000); } catch(InterruptedException e) {} ; // sleep for 2 seconds\n                \t}\r\n                \t\r\n                \tif (parentJob.isStopped()) {\r\n                \t\t// See if we have a status and if we need to stop the remote execution here...\r\n                \t\t// \r\n                \t\tif (transStatus==null || transStatus.isRunning()) {\r\n                \t\t\t// Try a remote abort ...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.stopTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// And a cleanup...\r\n                \t\t\t//\r\n                \t\t\tremoteSlaveServer.cleanupTransformation(transMeta.getName());\r\n                \t\t\t\r\n                \t\t\t// Set an error state!\r\n                \t\t\t//\r\n\t\t\t\t\t\t\tresult.setNrErrors(result.getNrErrors()+1L);\r\n                \t\t}\r\n                \t}\n                }\n                // Execute this transformation on the local machine\n                //\n                else // Local execution...\n                {\r\n                \t// Create the transformation from meta-data\r\n\t                //\n                    Trans trans = new Trans(transMeta);\n\r\n                    // Pass the socket repository as early as possible...\r\n                    //\r\n                    trans.setSocketRepository(parentJob.getSocketRepository());\r\n                    \n                    if (parentJob.getJobMeta().isBatchIdPassed())\n                    {\n                        trans.setPassedBatchId(parentJob.getPassedBatchId());\n                    }\n                    \n                    // set the parent job on the transformation, variables are taken from here...\n                    trans.setParentJob(parentJob);\n                    trans.setParentVariableSpace(parentJob);                    \n\n                    // First get the root job\n                    //\n                    Job rootJob = parentJob;\n                    while (rootJob.getParentJob()!=null) rootJob=rootJob.getParentJob();\n                    \n                    // Get the start and end-date from the root job...\n                    //\n                    trans.setJobStartDate( rootJob.getStartDate() );\n                    trans.setJobEndDate( rootJob.getEndDate() );\n                    \n                    try {\n            \t\t\t// Start execution...\n                    \t//\n                    \ttrans.execute(args);\n\n                    \t// Wait until we're done with it...\n                    \t//\n        \t\t\t\twhile (!trans.isFinished() && !parentJob.isStopped() && trans.getErrors() == 0)\n        \t\t\t\t{\n        \t\t\t\t\ttry { Thread.sleep(0,500);}\n        \t\t\t\t\tcatch(InterruptedException e) { }\n        \t\t\t\t}\n\n        \t\t\t\tif (parentJob.isStopped() || trans.getErrors() != 0)\n        \t\t\t\t{\n        \t\t\t\t\ttrans.stopAll();\n        \t\t\t\t\ttrans.waitUntilFinished();\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_STOP);\n                            result.setNrErrors(1);\n        \t\t\t\t}\n        \t\t\t\telse\n        \t\t\t\t{\n        \t\t\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n        \t\t\t\t}\n        \t\t\t\tResult newResult = trans.getResult();\n\n                        result.clear(); // clear only the numbers, NOT the files or rows.\n                        result.add(newResult);\n\n                        // Set the result rows too...\n                        result.setRows(newResult.getRows());\n\n                        if (setLogfile)\n                        {\n                        \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, KettleVFS.getFileObject(getLogFilename()), parentJob.getJobname(), toString());\n                            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n        \t\t\t\t}\n                    }\n                    catch (KettleException e) {\r\n                    \t\n                        log.logError(toString(), Messages.getString(\"JobTrans.Error.UnablePrepareExec\"), e);\n        \t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t}\n                }\n    \t\t}\n    \t\tcatch(Exception e)\n    \t\t{\r\n    \t\t\t\n    \t\t\tlog.logError(toString(), Messages.getString(\"JobTrans.ErrorUnableOpenTrans\",e.getMessage()));\n                log.logError(toString(), Const.getStackTracker(e));\n    \t\t\tresult.setNrErrors(1);\n    \t\t}\n            iteration++;\n        }\n\n        if (setLogfile)\n        {\n            if (appender!=null)\n            {\n                log.removeAppender(appender);\n                appender.close();\n\n                ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_LOG, appender.getFile(), parentJob.getJobname(), getName());\n                result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n            }\n            log.setLogLevel(backupLogLevel);\n        }\n\n\t\tif (result.getNrErrors()==0)\n\t\t{\n\t\t\tresult.setResult( true );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t}\n\n\t\t// Hint the VM to release handles.\n\t\tSystem.gc();\n\t\t\n\t\treturn result;\n\t}","commit_id":"288a8fe84175b77239ea5426440fb9d13ed13222","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean last() throws XQException {\r\n    final SeqIter seq = sequence();\r\n    return cursor(seq, seq.size - 1);\r\n  }","id":40854,"modified_method":"public boolean last() throws XQException {\r\n    final SeqIter seq = sequence();\r\n    return cursor(seq, seq.size() - 1);\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean absolute(final int p) throws XQException {\r\n    final SeqIter seq = sequence();\r\n    cursor(seq, p >= 0 ? p - 1 : seq.size + p);\r\n    return pos > 0;\r\n  }","id":40855,"modified_method":"public boolean absolute(final int p) throws XQException {\r\n    final SeqIter seq = sequence();\r\n    cursor(seq, p >= 0 ? p - 1 : seq.size() + p);\r\n    return pos > 0;\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean isLast() throws XQException {\r\n    return pos == sequence().size;\r\n  }","id":40856,"modified_method":"public boolean isLast() throws XQException {\r\n    return pos == sequence().size();\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"public int getPosition() throws XQException {\r\n    final SeqIter iter = sequence();\r\n    return pos != -1 ? pos : iter.size + 1;\r\n  }","id":40857,"modified_method":"public int getPosition() throws XQException {\r\n    final SeqIter iter = sequence();\r\n    return pos != -1 ? pos : iter.size() + 1;\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean isBeforeFirst() throws XQException {\r\n    sequence();\r\n    return pos == 0 && pos < sequence().size;\r\n  }","id":40858,"modified_method":"public boolean isBeforeFirst() throws XQException {\r\n    sequence();\r\n    return pos == 0 && pos < sequence().size();\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"public int count() throws XQException {\r\n    return sequence().size;\r\n  }","id":40859,"modified_method":"public int count() throws XQException {\r\n    return sequence().size();\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Sets the cursor to the specified position.\r\n   * @param seq iterator sequence\r\n   * @param p cursor position\r\n   * @return result of check\r\n   * @throws XQException xquery exception\r\n   */\r\n  private boolean cursor(final SeqIter seq, final int p) throws XQException {\r\n    pos = p < 0 ? 0 : p >= seq.size ? -1 : p;\r\n    seq.pos = pos - 1;\r\n    return p < 0 ? false : next();\r\n  }","id":40860,"modified_method":"/**\r\n   * Sets the cursor to the specified position.\r\n   * @param seq iterator sequence\r\n   * @param p cursor position\r\n   * @return result of check\r\n   * @throws XQException xquery exception\r\n   */\r\n  private boolean cursor(final SeqIter seq, final int p) throws XQException {\r\n    pos = p < 0 ? 0 : p >= seq.size() ? -1 : p;\r\n    seq.pos(pos - 1);\r\n    return p < 0 ? false : next();\r\n  }","commit_id":"9782b02a8a8f8e2b036c5ea5223e5cf39f6f1a6f","url":"https://github.com/BaseXdb/basex"},{"original_method":"void onSuccess(FetchResult result, ClientGetter state, File tempBlobFile, int fetchedVersion) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(this) {\n\t\t\tif(fetchedVersion <= this.fetchedVersion) {\n\t\t\t\ttempBlobFile.delete();\n\t\t\t\tresult.asBucket().free();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(result == null || result.asBucket() == null || result.asBucket().size() == 0) {\n\t\t\t\ttempBlobFile.delete();\n\t\t\t\tLogger.error(this, \"Cannot update: result either null or empty for \"+availableVersion);\n\t\t\t\tSystem.err.println(\"Cannot update: result either null or empty for \"+availableVersion);\n\t\t\t\t// Try again\n\t\t\t\tif(result == null || result.asBucket() == null || availableVersion > fetchedVersion) {\n\t\t\t\t\tnode.ps.queueTimedJob(new Runnable() {\n\t\t\t\t\t\tpublic void run() { maybeUpdate(); }\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFile blobFile = getBlobFile(fetchedVersion);\n\t\t\tif(!tempBlobFile.renameTo(blobFile)) {\n\t\t\t\tblobFile.delete();\n\t\t\t\tif(!tempBlobFile.renameTo(blobFile)) {\n\t\t\t\t\tif(blobFile.exists() && tempBlobFile.exists() &&\n\t\t\t\t\t\t\tblobFile.length() == tempBlobFile.length())\n\t\t\t\t\t\tLogger.minor(this, \"Can't rename \"+tempBlobFile+\" over \"+blobFile+\" for \"+fetchedVersion+\" - probably not a big deal though as the files are the same size\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.error(this, \"Not able to rename binary blob for node updater: \"+tempBlobFile+\" -> \"+blobFile+\" - may not be able to tell other peers about this build\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.fetchedVersion = fetchedVersion;\n\t\t\tSystem.out.println(\"Found \"+fetchedVersion);\n\t\t\tif(fetchedVersion > currentVersion) {\n\t\t\t\tLogger.normal(this, \"Found version \" + fetchedVersion + \", setting up a new UpdatedVersionAvailableUserAlert\");\n\t\t\t}\n\t\t\tthis.cg = null;\n\t\t\tif(this.result != null) this.result.asBucket().free();\n\t\t\tthis.result = result;\n\t\t}\n\t\tmanager.onDownloadedNewJar(extUpdate);\n\t}","id":40861,"modified_method":"void onSuccess(FetchResult result, ClientGetter state, File tempBlobFile, int fetchedVersion) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(this) {\n\t\t\tif(fetchedVersion <= this.fetchedVersion) {\n\t\t\t\ttempBlobFile.delete();\n\t\t\t\tif(result != null) {\n\t\t\t\t\tBucket toFree = result.asBucket();\n\t\t\t\t\tif(toFree != null)\n\t\t\t\t\t\ttoFree.free();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(result == null || result.asBucket() == null || result.asBucket().size() == 0) {\n\t\t\t\ttempBlobFile.delete();\n\t\t\t\tLogger.error(this, \"Cannot update: result either null or empty for \"+availableVersion);\n\t\t\t\tSystem.err.println(\"Cannot update: result either null or empty for \"+availableVersion);\n\t\t\t\t// Try again\n\t\t\t\tif(result == null || result.asBucket() == null || availableVersion > fetchedVersion) {\n\t\t\t\t\tnode.ps.queueTimedJob(new Runnable() {\n\t\t\t\t\t\tpublic void run() { maybeUpdate(); }\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFile blobFile = getBlobFile(fetchedVersion);\n\t\t\tif(!tempBlobFile.renameTo(blobFile)) {\n\t\t\t\tblobFile.delete();\n\t\t\t\tif(!tempBlobFile.renameTo(blobFile)) {\n\t\t\t\t\tif(blobFile.exists() && tempBlobFile.exists() &&\n\t\t\t\t\t\t\tblobFile.length() == tempBlobFile.length())\n\t\t\t\t\t\tLogger.minor(this, \"Can't rename \"+tempBlobFile+\" over \"+blobFile+\" for \"+fetchedVersion+\" - probably not a big deal though as the files are the same size\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.error(this, \"Not able to rename binary blob for node updater: \"+tempBlobFile+\" -> \"+blobFile+\" - may not be able to tell other peers about this build\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.fetchedVersion = fetchedVersion;\n\t\t\tSystem.out.println(\"Found \"+fetchedVersion);\n\t\t\tif(fetchedVersion > currentVersion) {\n\t\t\t\tLogger.normal(this, \"Found version \" + fetchedVersion + \", setting up a new UpdatedVersionAvailableUserAlert\");\n\t\t\t}\n\t\t\tthis.cg = null;\n\t\t\tif(this.result != null) this.result.asBucket().free();\n\t\t\tthis.result = result;\n\t\t}\n\t\tmanager.onDownloadedNewJar(extUpdate);\n\t}","commit_id":"d3bf921353797221cb49b04a69b7085503b8736b","url":"https://github.com/freenet/fred"},{"original_method":"public void start(ClientContext context) throws FetchException {\n\t\ttry {\n\t\t\t\n\t\t\t// Fproxy uses lookupInstant() with mustCopy = false. I.e. it can reuse stuff unsafely. If the user frees it it's their fault.\n\t\t\tCacheFetchResult result = context.downloadCache == null ? null : context.downloadCache.lookupInstant(uri, !fctx.filterData, false, null);\n\t\t\tif(result != null) {\n\t\t\t\tif(fctx.filterData == result.alreadyFiltered) {\n\t\t\t\t\tonSuccess(result, null, null);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tBucket data = result.asBucket();\n\t\t\t\tString mimeType = result.getMimeType();\n\t\t\t\tString fullMimeType = mimeType;\n\t\t\t\tif(mimeType == null || mimeType.equals(\"\")) mimeType = DefaultMIMETypes.DEFAULT_MIME_TYPE;\n\t\t\t\tmimeType = ContentFilter.stripMIMEType(mimeType);\n\t\t\t\tMIMEType type = ContentFilter.getMIMEType(mimeType);\n\t\t\t\tif(type == null || ((!type.safeToRead) && type.readFilter == null)) {\n\t\t\t\t\tUnknownContentTypeException e = new UnknownContentTypeException(mimeType);\n\t\t\t\t\tdata.free();\n\t\t\t\t\tonFailure(new FetchException(e.getFetchErrorCode(), data.size(), e, mimeType), null, null);\n\t\t\t\t\treturn;\n\t\t\t\t} else if(type.safeToRead) {\n\t\t\t\t\tonSuccess(result, null, null);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t// Try to filter it.\n\t\t\t\t\tBucket output = null;\n\t\t\t\t\tInputStream is = null;\n\t\t\t\t\tOutputStream os = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutput = context.tempBucketFactory.makeBucket(-1);\n\t\t\t\t\t\tis = data.getInputStream();\n\t\t\t\t\t\tos = output.getOutputStream();\n\t\t\t\t\t\tContentFilter.filter(is, os, fullMimeType, fctx.charset, null);\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t\tis = null;\n\t\t\t\t\t\tos.close();\n\t\t\t\t\t\tos = null;\n\t\t\t\t\t\tthis.onSuccess(new FetchResult(new ClientMetadata(fullMimeType), output), null, null);\n\t\t\t\t\t\toutput = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Failed filtering coalesced data in fproxy\");\n\t\t\t\t\t\t// Failed. :|\n\t\t\t\t\t\t// Let it run normally.\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tCloser.close(is);\n\t\t\t\t\t\tCloser.close(os);\n\t\t\t\t\t\tCloser.close(output);\n\t\t\t\t\t\tCloser.close(data);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcontext.start(getter);\n\t\t} catch (FetchException e) {\n\t\t\tsynchronized(this) {\n\t\t\t\tthis.failed = e;\n\t\t\t\tthis.finished = true;\n\t\t\t}\n\t\t} catch (DatabaseDisabledException e) {\n\t\t\t// Impossible\n\t\t\tLogger.error(this, \"Failed to start: \"+e);\n\t\t\tsynchronized(this) {\n\t\t\t\tthis.failed = new FetchException(FetchException.INTERNAL_ERROR, e);\n\t\t\t\tthis.finished = true;\n\t\t\t}\n\t\t}\n\t}","id":40862,"modified_method":"public void start(ClientContext context) throws FetchException {\n\t\ttry {\n\t\t\t\n\t\t\t// Fproxy uses lookupInstant() with mustCopy = false. I.e. it can reuse stuff unsafely. If the user frees it it's their fault.\n\t\t\tCacheFetchResult result = context.downloadCache == null ? null : context.downloadCache.lookupInstant(uri, !fctx.filterData, false, null);\n\t\t\tBucket data = null;\n\t\t\tString mimeType = null;\n\t\t\tif(result != null) {\n\t\t\t\tif(fctx.filterData == result.alreadyFiltered) {\n\t\t\t\t\tonSuccess(result, null, null);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdata = result.asBucket();\n\t\t\t\tmimeType = result.getMimeType();\n\t\t\t\tif(mimeType == null || mimeType.equals(\"\")) mimeType = DefaultMIMETypes.DEFAULT_MIME_TYPE;\n\t\t\t\tif(fctx.overrideMIME != null && !result.alreadyFiltered)\n\t\t\t\t\tmimeType = fctx.overrideMIME;\n\t\t\t\telse if(result.alreadyFiltered && ((!fctx.filterData) || (!mimeType.equals(fctx.overrideMIME)))) {\n\t\t\t\t\t// Doesn't work.\n\t\t\t\t\tdata = null;\n\t\t\t\t\tmimeType = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data != null) {\n\t\t\t\tString fullMimeType = mimeType;\n\t\t\t\tmimeType = ContentFilter.stripMIMEType(mimeType);\n\t\t\t\tMIMEType type = ContentFilter.getMIMEType(mimeType);\n\t\t\t\tif(type == null || ((!type.safeToRead) && type.readFilter == null)) {\n\t\t\t\t\tUnknownContentTypeException e = new UnknownContentTypeException(mimeType);\n\t\t\t\t\tdata.free();\n\t\t\t\t\tonFailure(new FetchException(e.getFetchErrorCode(), data.size(), e, mimeType), null, null);\n\t\t\t\t\treturn;\n\t\t\t\t} else if(type.safeToRead) {\n\t\t\t\t\tonSuccess(new FetchResult(new ClientMetadata(mimeType), data), null, null);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t// Try to filter it.\n\t\t\t\t\tBucket output = null;\n\t\t\t\t\tInputStream is = null;\n\t\t\t\t\tOutputStream os = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutput = context.tempBucketFactory.makeBucket(-1);\n\t\t\t\t\t\tis = data.getInputStream();\n\t\t\t\t\t\tos = output.getOutputStream();\n\t\t\t\t\t\tContentFilter.filter(is, os, fullMimeType, uri.toURI(\"/\"), null, null, fctx.charset);\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t\tis = null;\n\t\t\t\t\t\tos.close();\n\t\t\t\t\t\tos = null;\n\t\t\t\t\t\tthis.onSuccess(new FetchResult(new ClientMetadata(fullMimeType), output), null, null);\n\t\t\t\t\t\toutput = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Failed filtering coalesced data in fproxy\");\n\t\t\t\t\t\t// Failed. :|\n\t\t\t\t\t\t// Let it run normally.\n\t\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t\tLogger.error(this, \"Impossible: \"+e, e);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tCloser.close(is);\n\t\t\t\t\t\tCloser.close(os);\n\t\t\t\t\t\tCloser.close(output);\n\t\t\t\t\t\tCloser.close(data);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcontext.start(getter);\n\t\t} catch (FetchException e) {\n\t\t\tsynchronized(this) {\n\t\t\t\tthis.failed = e;\n\t\t\t\tthis.finished = true;\n\t\t\t}\n\t\t} catch (DatabaseDisabledException e) {\n\t\t\t// Impossible\n\t\t\tLogger.error(this, \"Failed to start: \"+e);\n\t\t\tsynchronized(this) {\n\t\t\t\tthis.failed = new FetchException(FetchException.INTERNAL_ERROR, e);\n\t\t\t\tthis.finished = true;\n\t\t\t}\n\t\t}\n\t}","commit_id":"2675d63ceb33337c1cff9b8f8b7eeebc37e70b39","url":"https://github.com/freenet/fred"},{"original_method":"public int decompress(byte[] dbuf, int i, int j, byte[] output) throws CompressionOutputSizeException {\n\t\t// Didn't work with Inflater.\n\t\t// FIXME fix sometimes to use Inflater - format issue?\n\t\tByteArrayInputStream bais = new ByteArrayInputStream(dbuf, i, j);\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(output.length);\n\t\tint bytes = 0;\n\t\ttry {\n\t\t\tbytes = (int)decompress(bais, baos, output.length, -1);\n\t\t} catch (IOException e) {\n\t\t\t// Impossible\n\t\t\tthrow new Error(\"Got IOException: \" + e.getMessage(), e);\n\t\t}\n\t\tbyte[] buf = baos.toByteArray();\n\t\tSystem.arraycopy(buf, 0, output, 0, bytes);\n\t\treturn bytes;\n\t}","id":40863,"modified_method":"public int decompress(byte[] dbuf, int i, int j, byte[] output) throws CompressionOutputSizeException {\n\t\t// Didn't work with Inflater.\n\t\t// FIXME fix sometimes to use Inflater - format issue?\n\t\tByteArrayInputStream bais = new ByteArrayInputStream(dbuf, i, j);\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(output.length);\n\t\tint bytes = 0;\n\t\ttry {\n\t\t\tdecompress(bais, baos, output.length, -1);\n\t\t} catch (IOException e) {\n\t\t\t// Impossible\n\t\t\tthrow new Error(\"Got IOException: \" + e.getMessage(), e);\n\t\t}\n\t\tbyte[] buf = baos.toByteArray();\n\t\tSystem.arraycopy(buf, 0, output, 0, bytes);\n\t\treturn bytes;\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"private long decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tCBZip2InputStream bz2is = new CBZip2InputStream(is);\n\t\tlong written = 0;\n\t\tbyte[] buffer = new byte[4096];\n\t\twhile(true) {\n\t\t\tint l = (int) Math.min(buffer.length, maxLength - written);\n\t\t\t// We can over-read to determine whether we have over-read.\n\t\t\t// We enforce maximum size this way.\n\t\t\t// FIXME there is probably a better way to do this!\n\t\t\tint x = bz2is.read(buffer, 0, buffer.length);\n\t\t\tif(l < x) {\n\t\t\t\tLogger.normal(this, \"l=\"+l+\", x=\"+x+\", written=\"+written+\", maxLength=\"+maxLength+\" throwing a CompressionOutputSizeException\");\n\t\t\t\tif(maxCheckSizeBytes > 0) {\n\t\t\t\t\twritten += x;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tl = (int) Math.min(buffer.length, maxLength + maxCheckSizeBytes - written);\n\t\t\t\t\t\tx = bz2is.read(buffer, 0, l);\n\t\t\t\t\t\tif(x <= -1) throw new CompressionOutputSizeException(written);\n\t\t\t\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\t\t\t\twritten += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new CompressionOutputSizeException();\n\t\t\t}\n\t\t\tif(x <= -1) return written;\n\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\tos.write(buffer, 0, x);\n\t\t\twritten += x;\n\t\t}\n\t}","id":40864,"modified_method":"public long decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tCBZip2InputStream bz2is = new CBZip2InputStream(is);\n\t\tlong written = 0;\n\t\tbyte[] buffer = new byte[4096];\n\t\twhile(true) {\n\t\t\tint l = (int) Math.min(buffer.length, maxLength - written);\n\t\t\t// We can over-read to determine whether we have over-read.\n\t\t\t// We enforce maximum size this way.\n\t\t\t// FIXME there is probably a better way to do this!\n\t\t\tint x = bz2is.read(buffer, 0, buffer.length);\n\t\t\tif(l < x) {\n\t\t\t\tLogger.normal(this, \"l=\"+l+\", x=\"+x+\", written=\"+written+\", maxLength=\"+maxLength+\" throwing a CompressionOutputSizeException\");\n\t\t\t\tif(maxCheckSizeBytes > 0) {\n\t\t\t\t\twritten += x;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tl = (int) Math.min(buffer.length, maxLength + maxCheckSizeBytes - written);\n\t\t\t\t\t\tx = bz2is.read(buffer, 0, l);\n\t\t\t\t\t\tif(x <= -1) throw new CompressionOutputSizeException(written);\n\t\t\t\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\t\t\t\twritten += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new CompressionOutputSizeException();\n\t\t\t}\n\t\t\tif(x <= -1) return written;\n\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\tos.write(buffer, 0, x);\n\t\t\twritten += x;\n\t\t}\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Called when the request succeeds.\n\t * @param result The final data.\n\t * @param state The ClientGetState which retrieved the data.\n\t */\n\tpublic void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Succeeded from \"+state+\" on \"+this);\n\t\tif(persistent())\n\t\t\tcontainer.activate(uri, 5);\n\t\tif(!closeBinaryBlobStream(container, context)) return;\n\t\tsynchronized(this) {\n\t\t\tfinished = true;\n\t\t\tcurrentState = null;\n\t\t}\n\t\tif(persistent()) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Rest of method does not need to be synchronized.\n\t\t// Variables will be updated on exit of method, and the only thing that is\n\t\t// set is the returnBucket and the result. Not locking not only prevents\n\t\t// nested locking resulting in deadlocks, it also prevents long locks due to\n\t\t// doing massive encrypted I/Os while holding a lock.\n\n\t\tBucket data = result.asBucket();\n\t\t// Decompress\n\t\tif(decompressors != null) {\n\t\t\tLogger.minor(this, \"decompressing...\");\n\t\t\ttry {\n\t\t\t\tif(persistent()) {\n\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t}\n\t\t\t\tint count = 0;\n\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tBucket out = returnBucket;\n\t\t\t\t\t\tif(!decompressors.isEmpty()) out = null;\n\t\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(persistent()), maxLen, maxLen * 4, null);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tif(e.getMessage().equals(\"Not in GZIP format\") && count == 1) {\n\t\t\t\t\t\t\tLogger.error(this, \"Attempting to decompress twice, failed, returning first round data: \"+this);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), state, container, context);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Too big: maxSize = \"+ctx.maxOutputLength+\" maxTempSize = \"+ctx.maxTempLength);\n\t\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, false, result.getMimeType()), state, container, context);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t}\n\t\t}\n\t\tresult = new FetchResult(result, data);\n\n\t\t//Filter the data, if we are supposed to\n\t\tif(ctx.filterData){\n\t\t\tif(logMINOR) Logger.minor(this, \"Running content filter... Prefetch hook: \"+ctx.prefetchHook+\" tagReplacer: \"+ctx.tagReplacer);\n\t\t\tInputStream input = null;\n\t\t\tOutputStream output = null;\n\t\t\ttry {\n\t\t\t\tString mimeType = ctx.overrideMIME != null ? ctx.overrideMIME: expectedMIME;\n\t\t\t\tif(mimeType.compareTo(\"application/xhtml+xml\") == 0) mimeType = \"text/html\";\n\t\t\t\tassert(data != returnBucket);\n\t\t\t\tBucket filteredResult;\n\t\t\t\tif(returnBucket == null) filteredResult = context.getBucketFactory(persistent()).makeBucket(-1);\n\t\t\t\telse {\n\t\t\t\t\tif(persistent()) container.activate(returnBucket, 5);\n\t\t\t\t\tfilteredResult = returnBucket;\n\t\t\t\t}\n\t\t\t\tinput = data.getInputStream();\n\t\t\t\toutput = filteredResult.getOutputStream();\n\t\t\t\tFilterStatus filterStatus = ContentFilter.filter(input, output, mimeType, uri.toURI(\"/\"), ctx.prefetchHook, ctx.tagReplacer, ctx.charset);\n\t\t\t\tinput.close();\n\t\t\t\toutput.close();\n\t\t\t\tString detectedMIMEType = filterStatus.mimeType.concat(filterStatus.charset == null ? \"\" : \"; charset=\"+filterStatus.charset);\n\t\t\t\tresult.asBucket().free();\n\t\t\t\tresult = new FetchResult(new ClientMetadata(detectedMIMEType), filteredResult);\n\t\t\t} catch (UnsafeContentTypeException e) {\n\t\t\t\tLogger.error(this, \"Error filtering content: will not validate\", e);\n\t\t\t\tonFailure(new FetchException(e.getFetchErrorCode(), expectedSize, e.getMessage(), e, ctx.overrideMIME != null ? ctx.overrideMIME : expectedMIME), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// Impossible\n\t\t\t\tLogger.error(this, \"URISyntaxException converting a FreenetURI to a URI!: \"+e, e);\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Error filtering content\", e);\n\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tCloser.close(input);\n\t\t\t\tCloser.close(output);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring content filter.\");\n\t\t}\n\t\tif(returnBucket == null) if(logMINOR) Logger.minor(this, \"Returnbucket is null\");\n\t\tif((returnBucket != null) && (data != returnBucket)) {\n\t\t\tBucket from = data;\n\t\t\tBucket to = returnBucket;\n\t\t\ttry {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Copying - returnBucket not respected by client.async\");\n\t\t\t\tif(persistent()) {\n\t\t\t\t\tcontainer.activate(from, 5);\n\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t}\n\t\t\t\tBucketTools.copy(from, to);\n\t\t\t\tfrom.free();\n\t\t\t\tif(persistent())\n\t\t\t\t\tfrom.removeFrom(container);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Error copying from \"+from+\" to \"+to+\" : \"+e.toString(), e);\n\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e.toString()), state /* not strictly to blame, but we're not ako ClientGetState... */, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = new FetchResult(result, to);\n\t\t} else {\n\t\t\tif(returnBucket != null && logMINOR)\n\t\t\t\tLogger.minor(this, \"client.async returned data in returnBucket\");\n\t\t}\n\t\tif(persistent()) {\n\t\t\tcontainer.activate(state, 1);\n\t\t\tstate.removeFrom(container, context);\n\t\t\tcontainer.activate(clientCallback, 1);\n\t\t}\n\t\tclientCallback.onSuccess(result, ClientGetter.this, container);\n\t}","id":40865,"modified_method":"/**\n\t * Called when the request succeeds.\n\t * @param result The final data.\n\t * @param state The ClientGetState which retrieved the data.\n\t */\n\tpublic void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Succeeded from \"+state+\" on \"+this);\n\t\tif(persistent())\n\t\t\tcontainer.activate(uri, 5);\n\t\tif(!closeBinaryBlobStream(container, context)) return;\n\t\tsynchronized(this) {\n\t\t\tfinished = true;\n\t\t\tcurrentState = null;\n\t\t}\n\t\tif(persistent()) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Rest of method does not need to be synchronized.\n\t\t// Variables will be updated on exit of method, and the only thing that is\n\t\t// set is the returnBucket and the result. Not locking not only prevents\n\t\t// nested locking resulting in deadlocks, it also prevents long locks due to\n\t\t// doing massive encrypted I/Os while holding a lock.\n\n\t\tBucket data = result.asBucket();\n\t\tOutputStream output = null;\n\t\tInputStream input = null;\n\t\t// Decompress\n\t\tif(decompressors != null) {\n\t\t\tLogger.minor(this, \"decompressing...\");\n\t\t\ttry {\n\t\t\t\tif(persistent()) {\n\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t}\n\t\t\t\tint count = 0;\n\t\t\t\toutput = null;\n\t\t\t\tinput = data.getInputStream();\n\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\tDecompressorThreadManager decompressorManager =  new DecompressorThreadManager(input, maxLen);\n\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\tdecompressorManager.addDecompressor(c);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tinput = decompressorManager.execute();\n\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t}\n\t\t}\n\t\tresult = new FetchResult(result, data);\n\n\t\t//Filter the data, if we are supposed to\n\t\tif(ctx.filterData){\n\t\t\tif(logMINOR) Logger.minor(this, \"Running content filter... Prefetch hook: \"+ctx.prefetchHook+\" tagReplacer: \"+ctx.tagReplacer);\n\t\t\ttry {\n\t\t\t\tString mimeType = ctx.overrideMIME != null ? ctx.overrideMIME: expectedMIME;\n\t\t\t\tif(mimeType.compareTo(\"application/xhtml+xml\") == 0) mimeType = \"text/html\";\n\t\t\t\tassert(data != returnBucket);\n\t\t\t\tBucket filteredResult;\n\t\t\t\tif(returnBucket == null) filteredResult = context.getBucketFactory(persistent()).makeBucket(-1);\n\t\t\t\telse {\n\t\t\t\t\tif(persistent()) container.activate(returnBucket, 5);\n\t\t\t\t\tfilteredResult = returnBucket;\n\t\t\t\t}\n\t\t\t\toutput = filteredResult.getOutputStream();\n\t\t\t\tFilterStatus filterStatus = ContentFilter.filter(input, output, mimeType, uri.toURI(\"/\"), ctx.prefetchHook, ctx.tagReplacer, ctx.charset);\n\t\t\t\tinput.close();\n\t\t\t\toutput.close();\n\t\t\t\tString detectedMIMEType = filterStatus.mimeType.concat(filterStatus.charset == null ? \"\" : \"; charset=\"+filterStatus.charset);\n\t\t\t\tresult.asBucket().free();\n\t\t\t\tresult = new FetchResult(new ClientMetadata(detectedMIMEType), filteredResult);\n\t\t\t} catch (UnsafeContentTypeException e) {\n\t\t\t\tLogger.error(this, \"Error filtering content: will not validate\", e);\n\t\t\t\tonFailure(new FetchException(e.getFetchErrorCode(), expectedSize, e.getMessage(), e, ctx.overrideMIME != null ? ctx.overrideMIME : expectedMIME), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// Impossible\n\t\t\t\tLogger.error(this, \"URISyntaxException converting a FreenetURI to a URI!: \"+e, e);\n\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Error filtering content\", e);\n\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), state/*Not really the state's fault*/, container, context);\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tCloser.close(input);\n\t\t\t\tCloser.close(output);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring content filter.\");\n\t\t}\n\t\tif(returnBucket == null) if(logMINOR) Logger.minor(this, \"Returnbucket is null\");\n\t\tif((returnBucket != null) && (data != returnBucket)) {\n\t\t\tBucket from = data;\n\t\t\tBucket to = returnBucket;\n\t\t\ttry {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Copying - returnBucket not respected by client.async\");\n\t\t\t\tif(persistent()) {\n\t\t\t\t\tcontainer.activate(from, 5);\n\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t}\n\t\t\t\tBucketTools.copy(from, to);\n\t\t\t\tfrom.free();\n\t\t\t\tif(persistent())\n\t\t\t\t\tfrom.removeFrom(container);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Error copying from \"+from+\" to \"+to+\" : \"+e.toString(), e);\n\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e.toString()), state /* not strictly to blame, but we're not ako ClientGetState... */, container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = new FetchResult(result, to);\n\t\t} else {\n\t\t\tif(returnBucket != null && logMINOR)\n\t\t\t\tLogger.minor(this, \"client.async returned data in returnBucket\");\n\t\t}\n\t\tif(persistent()) {\n\t\t\tcontainer.activate(state, 1);\n\t\t\tstate.removeFrom(container, context);\n\t\t\tcontainer.activate(clientCallback, 1);\n\t\t}\n\t\tclientCallback.onSuccess(result, ClientGetter.this, container);\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"private long decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tGZIPInputStream gis = new GZIPInputStream(is);\n\t\tlong written = 0;\n\t\tbyte[] buffer = new byte[4096];\n\t\twhile(true) {\n\t\t\tint l = (int) Math.min(buffer.length, maxLength - written);\n\t\t\t// We can over-read to determine whether we have over-read.\n\t\t\t// We enforce maximum size this way.\n\t\t\t// FIXME there is probably a better way to do this!\n\t\t\tint x = gis.read(buffer, 0, buffer.length);\n\t\t\tif(l < x) {\n\t\t\t\tLogger.normal(this, \"l=\"+l+\", x=\"+x+\", written=\"+written+\", maxLength=\"+maxLength+\" throwing a CompressionOutputSizeException\");\n\t\t\t\tif(maxCheckSizeBytes > 0) {\n\t\t\t\t\twritten += x;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tl = (int) Math.min(buffer.length, maxLength + maxCheckSizeBytes - written);\n\t\t\t\t\t\tx = gis.read(buffer, 0, l);\n\t\t\t\t\t\tif(x <= -1) throw new CompressionOutputSizeException(written);\n\t\t\t\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\t\t\t\twritten += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new CompressionOutputSizeException();\n\t\t\t}\n\t\t\tif(x <= -1) return written;\n\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\tos.write(buffer, 0, x);\n\t\t\twritten += x;\n\t\t}\n\t}","id":40866,"modified_method":"public long decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tGZIPInputStream gis = new GZIPInputStream(is);\n\t\tlong written = 0;\n\t\tbyte[] buffer = new byte[4096];\n\t\twhile(true) {\n\t\t\tint l = (int) Math.min(buffer.length, maxLength - written);\n\t\t\t// We can over-read to determine whether we have over-read.\n\t\t\t// We enforce maximum size this way.\n\t\t\t// FIXME there is probably a better way to do this!\n\t\t\tint x = gis.read(buffer, 0, buffer.length);\n\t\t\tif(l < x) {\n\t\t\t\tLogger.normal(this, \"l=\"+l+\", x=\"+x+\", written=\"+written+\", maxLength=\"+maxLength+\" throwing a CompressionOutputSizeException\");\n\t\t\t\tif(maxCheckSizeBytes > 0) {\n\t\t\t\t\twritten += x;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tl = (int) Math.min(buffer.length, maxLength + maxCheckSizeBytes - written);\n\t\t\t\t\t\tx = gis.read(buffer, 0, l);\n\t\t\t\t\t\tif(x <= -1) throw new CompressionOutputSizeException(written);\n\t\t\t\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\t\t\t\twritten += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new CompressionOutputSizeException();\n\t\t\t}\n\t\t\tif(x <= -1) return written;\n\t\t\tif(x == 0) throw new IOException(\"Returned zero from read()\");\n\t\t\tos.write(buffer, 0, x);\n\t\t\twritten += x;\n\t\t}\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"static Bucket decompress(boolean isCompressed, byte[] output, int outputLength, BucketFactory bf, long maxLength, short compressionAlgorithm, boolean shortLength) throws CHKDecodeException, IOException {\n\t    if(maxLength < 0)\n\t\t    throw new IllegalArgumentException(\"maxlength=\"+maxLength);\n        if(isCompressed) {\n        \tif(Logger.shouldLog(Logger.MINOR, Key.class))\n        \t\tLogger.minor(Key.class, \"Decompressing \"+output.length+\" bytes in decode with codec \"+compressionAlgorithm);\n            if(output.length < (shortLength ? 3 : 5)) throw new CHKDecodeException(\"No bytes to decompress\");\n            // Decompress\n            // First get the length\n            int len;\n            if(shortLength)\n            \tlen = ((output[0] & 0xff) << 8) + (output[1] & 0xff);\n            else \n            \tlen = ((((((output[0] & 0xff) << 8) + (output[1] & 0xff)) << 8) + (output[2] & 0xff)) << 8) +\n            \t\t(output[3] & 0xff);\n            if(len > maxLength)\n                throw new TooBigException(\"Invalid precompressed size: \"+len + \" maxlength=\"+maxLength);\n            COMPRESSOR_TYPE decompressor = COMPRESSOR_TYPE.getCompressorByMetadataID(compressionAlgorithm);\n            if (decompressor==null)\n            \tthrow new CHKDecodeException(\"Unknown compression algorithm: \"+compressionAlgorithm);\n            Bucket inputBucket = new SimpleReadOnlyArrayBucket(output, shortLength?2:4, outputLength-(shortLength?2:4));\n            try {\n\t\t\t\treturn decompressor.decompress(inputBucket, bf, maxLength, -1, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\tthrow new TooBigException(\"Too big\");\n\t\t\t}\n        } else {\n        \treturn BucketTools.makeImmutableBucket(bf, output, outputLength);\n        }\n\t}","id":40867,"modified_method":"static Bucket decompress(boolean isCompressed, byte[] output, int outputLength, BucketFactory bf, long maxLength, short compressionAlgorithm, boolean shortLength) throws CHKDecodeException, IOException {\n\t    if(maxLength < 0)\n\t\t    throw new IllegalArgumentException(\"maxlength=\"+maxLength);\n        if(isCompressed) {\n        \tif(Logger.shouldLog(Logger.MINOR, Key.class))\n        \t\tLogger.minor(Key.class, \"Decompressing \"+output.length+\" bytes in decode with codec \"+compressionAlgorithm);\n            if(output.length < (shortLength ? 3 : 5)) throw new CHKDecodeException(\"No bytes to decompress\");\n            // Decompress\n            // First get the length\n            int len;\n            if(shortLength)\n            \tlen = ((output[0] & 0xff) << 8) + (output[1] & 0xff);\n            else \n            \tlen = ((((((output[0] & 0xff) << 8) + (output[1] & 0xff)) << 8) + (output[2] & 0xff)) << 8) +\n            \t\t(output[3] & 0xff);\n            if(len > maxLength)\n                throw new TooBigException(\"Invalid precompressed size: \"+len + \" maxlength=\"+maxLength);\n            COMPRESSOR_TYPE decompressor = COMPRESSOR_TYPE.getCompressorByMetadataID(compressionAlgorithm);\n            if (decompressor==null)\n            \tthrow new CHKDecodeException(\"Unknown compression algorithm: \"+compressionAlgorithm);\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            Bucket inputBucket = new SimpleReadOnlyArrayBucket(output, shortLength?2:4, outputLength-(shortLength?2:4));\n            Bucket outputBucket = bf.makeBucket(maxLength);\n            outputStream = outputBucket.getOutputStream();\n            inputStream = inputBucket.getInputStream();\n            try {\n            \tdecompressor.decompress(inputStream, outputStream, maxLength, -1);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            inputStream.close();\n            outputStream.close();\n            inputBucket.free();\n            return outputBucket;\n        } else {\n        \treturn BucketTools.makeImmutableBucket(bf, output, outputLength);\n        }\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"private void decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tDecoder decoder = new Decoder();\n\t\tdecoder.SetDecoderProperties(props);\n\t\tdecoder.Code(is, os, maxLength);\n\t}","id":40868,"modified_method":"public long decompress(InputStream is, OutputStream os, long maxLength, long maxCheckSizeBytes) throws IOException, CompressionOutputSizeException {\n\t\tCountedOutputStream cos = new CountedOutputStream(os);\n\t\tDecoder decoder = new Decoder();\n\t\tdecoder.SetDecoderProperties(props);\n\t\tdecoder.Code(is, cos, maxLength);\n\t\treturn cos.written();\n\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tBucket data = result.asBucket();\n\t\t\tif(decompressors != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif(persistent()) {\n\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t}\n\t\t\t\t\tint count = 0;\n\t\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\t\t\tBucket orig = result.asBucket();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(persistent()), maxLen, maxLen * 4, null);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tif(e.getMessage().equals(\"Not in GZIP format\") && count == 1) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Attempting to decompress twice, failed, returning first round data: \"+this);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), state, container, context);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Too big: maxSize = \"+ctx.maxOutputLength+\" maxTempSize = \"+ctx.maxTempLength);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, false /* FIXME */, result.getMimeType()), state, container, context);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif(orig != data) {\n\t\t\t\t\t\t\t\torig.free();\n\t\t\t\t\t\t\t\tif(persistent()) orig.removeFrom(container);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!persistent) {\n\t\t\t\t// Run directly - we are running on some thread somewhere, don't worry about it.\n\t\t\t\tinnerSuccess(data, container, context);\n\t\t\t} else {\n\t\t\t\tboolean wasActive;\n\t\t\t\t// We are running on the database thread.\n\t\t\t\t// Add a tag, unpack on a separate thread, copy the data to a persistent bucket, then schedule on the database thread,\n\t\t\t\t// remove the tag, and call the callback.\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t\tparent.onTransition(state, SingleFileFetcher.this, container);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(actx, 1);\n\t\t\t\tah.activateForExecution(container);\n\t\t\t\tah.extractPersistentOffThread(result.asBucket(), true, actx, element, callback, container, context);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\tif(state != null)\n\t\t\t\t\tstate.removeFrom(container, context);\n\t\t\t\tcontainer.delete(this);\n\t\t\t}\n\t\t}","id":40869,"modified_method":"public void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tBucket data = result.asBucket();\n\t\t\tInputStream input = null;\n\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\tif(decompressors != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif(persistent()) {\n\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t}\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tinput = data.getInputStream();\n\t\t\t\t\tDecompressorThreadManager decompressorManager =  new DecompressorThreadManager(input, maxLen);\n\t\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\t\tdecompressorManager.addDecompressor(c);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tinput = decompressorManager.execute();\n\t\t\t\t\tif(returnBucket != null) data = returnBucket;\n\t\t\t\t\telse data = context.getBucketFactory(persistent()).makeBucket(maxLen);\n\t\t\t\t\tBucketTools.copyFrom(data, input, -1);\n\t\t\t\t\tinput.close();\n\t\t\t\t\tresult = new FetchResult(result, data);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t\t} finally {\n\t\t\t\t\tCloser.close(input);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!persistent) {\n\t\t\t\t// Run directly - we are running on some thread somewhere, don't worry about it.\n\t\t\t\tinnerSuccess(data, container, context);\n\t\t\t} else {\n\t\t\t\tboolean wasActive;\n\t\t\t\t// We are running on the database thread.\n\t\t\t\t// Add a tag, unpack on a separate thread, copy the data to a persistent bucket, then schedule on the database thread,\n\t\t\t\t// remove the tag, and call the callback.\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t\tparent.onTransition(state, SingleFileFetcher.this, container);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(actx, 1);\n\t\t\t\tah.activateForExecution(container);\n\t\t\t\tah.extractPersistentOffThread(result.asBucket(), true, actx, element, callback, container, context);\n\t\t\t\tif(!wasActive)\n\t\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\t\tif(state != null)\n\t\t\t\t\tstate.removeFrom(container, context);\n\t\t\t\tcontainer.delete(this);\n\t\t\t}\n\t\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tBucket data = result.asBucket();\n\t\t\tif(decompressors != null) {\n\t\t\t\tLogger.minor(this, \"decompressing...\");\n\t\t\t\ttry {\n\t\t\t\t\tif(persistent()) {\n\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t}\n\t\t\t\t\tint count = 0;\n\t\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\t\t\t\tBucket orig = result.asBucket();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tBucket out = returnBucket;\n\t\t\t\t\t\t\tif(!decompressors.isEmpty()) out = null;\n\t\t\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(persistent()), maxLen, maxLen * 4, out);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tif(e.getMessage().equals(\"Not in GZIP format\") && count == 1) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Attempting to decompress twice, failed, returning first round data: \"+this);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.BUCKET_ERROR, e), state, container, context);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Too big: maxSize = \"+ctx.maxOutputLength+\" maxTempSize = \"+ctx.maxTempLength);\n\t\t\t\t\t\t\tonFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, false /* FIXME */, result.getMimeType()), state, container, context);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif(orig != data) {\n\t\t\t\t\t\t\t\torig.free();\n\t\t\t\t\t\t\t\tif(persistent()) orig.removeFrom(container);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tparent.onTransition(state, SingleFileFetcher.this, container);\n\t\t\t\tMetadata meta = Metadata.construct(result.asBucket());\n\t\t\t\tremoveMetadata(container);\n\t\t\t\tsynchronized(SingleFileFetcher.this) {\n\t\t\t\t\tmetadata = meta;\n\t\t\t\t}\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(meta);\n\t\t\t\t\tcontainer.store(SingleFileFetcher.this);\n\t\t\t\t}\n\t\t\t\tinnerWrapHandleMetadata(true, container, context);\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Bucket error?\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t} finally {\n\t\t\t\tresult.asBucket().free();\n\t\t\t\tif(persistent)\n\t\t\t\t\tresult.asBucket().removeFrom(container);\n\t\t\t}\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\tif(persistent) {\n\t\t\t\tif(state != null) state.removeFrom(container, context);\n\t\t\t\tcontainer.delete(this);\n\t\t\t}\n\t\t}","id":40870,"modified_method":"public void onSuccess(FetchResult result, List<? extends Compressor> decompressors, ClientGetState state, ObjectContainer container, ClientContext context) {\n\t\t\tBucket data = result.asBucket();\n\t\t\tlong maxLen = Math.max(ctx.maxTempLength, ctx.maxOutputLength);\n\t\t\tInputStream input = null;\n\t\t\tif(decompressors != null) {\n\t\t\t\tLogger.minor(this, \"decompressing...\");\n\t\t\t\ttry {\n\t\t\t\t\tif(persistent()) {\n\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\tif(ctx == null) {\n\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null\");\n\t\t\t\t\t\t\tif(!container.ext().isActive(ctx)) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile is not activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\t\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Fetch context is null and splitfile IS activated\", new Exception(\"error\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontainer.activate(ctx, 1);\n\t\t\t\t\t}\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tinput = data.getInputStream();\n\t\t\t\t\tDecompressorThreadManager decompressorManager =  new DecompressorThreadManager(input, maxLen);\n\t\t\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\t\t\tCompressor c = decompressors.remove(decompressors.size()-1);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\t\t\tdecompressorManager.addDecompressor(c);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tinput = decompressorManager.execute();\n\t\t\t\t\tif(returnBucket != null) data = returnBucket;\n\t\t\t\t\telse data = context.getBucketFactory(persistent()).makeBucket(maxLen);\n\t\t\t\t\tBucketTools.copyFrom(data, input, -1);\n\t\t\t\t\tinput.close();\n\t\t\t\t\tresult.asBucket().free();\n\t\t\t\t\tresult = new FetchResult(result, data);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tOOMHandler.handleOOM(e);\n\t\t\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, e), state, container, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\t\tonFailure(new FetchException(FetchException.INTERNAL_ERROR, t), state, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean wasActive = true;\n\t\t\tif(persistent) {\n\t\t\t\twasActive = container.ext().isActive(SingleFileFetcher.this);\n\t\t\t\tcontainer.activate(SingleFileFetcher.this, 1);\n\t\t\t\tcontainer.activate(parent, 1);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tparent.onTransition(state, SingleFileFetcher.this, container);\n\t\t\t\tMetadata meta = Metadata.construct(result.asBucket());\n\t\t\t\tremoveMetadata(container);\n\t\t\t\tsynchronized(SingleFileFetcher.this) {\n\t\t\t\t\tmetadata = meta;\n\t\t\t\t}\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(meta);\n\t\t\t\t\tcontainer.store(SingleFileFetcher.this);\n\t\t\t\t}\n\t\t\t\tinnerWrapHandleMetadata(true, container, context);\n\t\t\t} catch (MetadataParseException e) {\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.INVALID_METADATA, e), false, container, context);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Bucket error?\n\t\t\t\tSingleFileFetcher.this.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), false, container, context);\n\t\t\t} finally {\n\t\t\t\tresult.asBucket().free();\n\t\t\t\tif(persistent)\n\t\t\t\t\tresult.asBucket().removeFrom(container);\n\t\t\t}\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.deactivate(SingleFileFetcher.this, 1);\n\t\t\tif(persistent) {\n\t\t\t\tif(state != null) state.removeFrom(container, context);\n\t\t\t\tcontainer.delete(this);\n\t\t\t}\n\t\t}","commit_id":"089d7dc4e6ddb518062da2e29287a400f9604a22","url":"https://github.com/freenet/fred"},{"original_method":"protected Edge drawFollowerEdge(AbstractElement ele, TreeConstTransition t,\n\t\t\tboolean isParent) {\n\t\tEdge e = new Edge(ele, t.getTarget().getElement());\n\t\te.setLabel(String.valueOf(t.getPrecedence()));\n\t\te.setStyle(\"dotted\");\n\t\tif (isParent)\n\t\t\te.put(\"arrowtail\", \"odot\");\n\t\tif (t.isRuleCall())\n\t\t\te.put(\"arrowhead\", \"onormalonormal\");\n\t\telse\n\t\t\te.put(\"arrowhead\", \"onormal\");\n\t\treturn e;\n\t}","id":40871,"modified_method":"protected Edge drawFollowerEdge(AbstractElement ele, TreeConstTransition t,\n\t\t\tboolean isParent) {\n\t\tEdge e = new Edge(ele, t.getTarget().getElement());\n\t\tif (t.getPrecedence() > -1)\n\t\t\te.setLabel(String.valueOf(t.getPrecedence()));\n\t\te.setStyle(\"dotted\");\n\t\tif (isParent)\n\t\t\te.put(\"arrowtail\", \"odot\");\n\t\tif (t.isRuleCall())\n\t\t\te.put(\"arrowhead\", \"onormalonormal\");\n\t\telse\n\t\t\te.put(\"arrowhead\", \"onormal\");\n\t\tsetStatusStyle(e, t.getStatus());\n\t\treturn e;\n\t}","commit_id":"e5ef379fac414fd47c90251a50c086db139311be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected Node drawAbstractElementTree(AbstractElement ele, Digraph d) {\n\t\tNode n = super.drawAbstractElementTree(ele, d);\n\t\tTreeConstState nfas = nfaProvider.getNFA(ele);\n\n\t\tfor (TreeConstTransition t : nfas.getFollowers())\n\t\t\td.add(drawFollowerEdge(ele, t, false));\n\t\tfor (TreeConstTransition t : nfas.getParentFollowers())\n\t\t\td.add(drawFollowerEdge(ele, t, true));\n\n\t\tif (nfas.getFollowers().size() == 0\n\t\t\t\t&& nfas.getParentFollowers().size() == 0 && !nfas.isEndState())\n\t\t\tn.setStyle(\"dotted\");\n\t\tif (nfas.isEndState())\n\t\t\tn.put(\"peripheries\", \"2\");\n\t\treturn n;\n\t}","id":40872,"modified_method":"@Override\n\tprotected Node drawAbstractElementTree(AbstractElement ele, Digraph d) {\n\t\tNode n = super.drawAbstractElementTree(ele, d);\n\t\tTreeConstState nfas = nfaProvider.getNFA(ele);\n\n\t\tfor (TreeConstTransition t : nfas.getFollowers())\n\t\t\td.add(drawFollowerEdge(ele, t, false));\n\t\tfor (TreeConstTransition t : nfas.getParentFollowers())\n\t\t\td.add(drawFollowerEdge(ele, t, true));\n\n\t\tif (nfas.getStatInt() != Status.ENABLED)\n\t\t\tn.setStyle(\"dashed\");\n\t\tif (nfas.isEndState())\n\t\t\tn.put(\"peripheries\", \"2\");\n\t\tsetStatusStyle(n, nfas.getStatus());\n\t\t// n.setLabel(nfas + n.get(\"label\"));\n\t\treturn n;\n\t}","commit_id":"e5ef379fac414fd47c90251a50c086db139311be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic List<TreeConstTransition> getParentFollowers() {\n\t\treturn super.getParentFollowers();\n\t}","id":40873,"modified_method":"public List<TreeConstTransition> getEnabledParentFollowers() {\n\t\tif(enabledParentFollowers == null) {\n\t\t\tenabledParentFollowers = new ArrayList<TreeConstTransition>();\n\t\t\tfor(TreeConstTransition t:getParentFollowers())\n\t\t\t\tif(!t.isDisabled())\n\t\t\t\t\tenabledParentFollowers.add(t);\n\t\t}\n\t\treturn enabledParentFollowers;\n\t}","commit_id":"e5ef379fac414fd47c90251a50c086db139311be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic List<TreeConstTransition> getFollowers() {\n\t\treturn super.getFollowers();\n\t}","id":40874,"modified_method":"public List<TreeConstTransition> getEnabledFollowers() {\n\t\tif(enabledFollowers == null) {\n\t\t\tenabledFollowers = new ArrayList<TreeConstTransition>();\n\t\t\tfor(TreeConstTransition t: getFollowers())\n\t\t\t\tif(!t.isDisabled())\n\t\t\t\t\tenabledFollowers.add(t);\n\t\t}\n\t\treturn enabledFollowers;\n\t}","commit_id":"e5ef379fac414fd47c90251a50c086db139311be","url":"https://github.com/eclipse/xtext"},{"original_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.iconsToDraw, new Comparator<IconDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IconDrawInfo object1, IconDrawInfo object2) {\n\t\t\t\treturn object1.iconOrder - object2.iconOrder;\n\t\t\t}\n\t\t});\n\t\tQuadRect bounds = new QuadRect(0, 0, rc.width, rc.height);\n\t\tbounds.inset(-bounds.width()/4, -bounds.height()/4);\n\t\tQuadTree<RectF> boundIntersections = new QuadTree<RectF>(bounds, 4, 0.6f);\n\t\tList<RectF> result = new ArrayList<RectF>();\n\t\t\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId, true);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint visbleWidth = icon.iconSize >= 0 ? (int) icon.iconSize : ico.getWidth();\n\t\t\t\t\t\tint visbleHeight = icon.iconSize >= 0 ? (int) icon.iconSize : ico.getHeight();\n\t\t\t\t\t\tboolean intersects = false;\n\t\t\t\t\t\tfloat coeff = rc.getDensityValue(rc.screenDensityRatio * rc.textScale);\n\t\t\t\t\t\tRectF rf = calculateRect(rc, icon, ico.getWidth(), ico.getHeight());\n\t\t\t\t\t\tRectF visibleRect = null;\n\t\t\t\t\t\tif (visbleHeight > 0 && visbleWidth > 0) {\n\t\t\t\t\t\t\tvisibleRect = calculateRect(rc, icon, visbleWidth, visbleHeight);\n\t\t\t\t\t\t\tboundIntersections.queryInBox(new QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom), result);\n\t\t\t\t\t\t\tfor (RectF r : result) {\n\t\t\t\t\t\t\t\tif (r.intersect(visibleRect)) {\n\t\t\t\t\t\t\t\t\tintersects = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!intersects) {\n\t\t\t\t\t\t\tBitmap shield = icon.shieldId == null ? null : RenderingIcons.getIcon(context, icon.shieldId, true);\n\t\t\t\t\t\t\tif(shield != null) {\n\t\t\t\t\t\t\t\tRectF shieldRf = calculateRect(rc, icon, shield.getWidth(), shield.getHeight());\n\t\t\t\t\t\t\t\tif (coeff != 1f) {\n\t\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, shield.getWidth(), shield.getHeight());\n\t\t\t\t\t\t\t\t\tdrawBitmap(cv, shield, shieldRf, src);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdrawBitmap(cv, shield, shieldRf);\n\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (coeff != 1f) {\n\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, ico.getWidth(), ico.getHeight());\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId_1, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, ico, rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId2, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId3, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId4, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId5, true), rf, src);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId_1, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, ico, rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId2, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId3, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId4, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId5, true), rf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(visibleRect != null) {\n\t\t\t\t\t\t\t\tvisibleRect.inset(-visibleRect.width() / 4, -visibleRect.height() / 4);\n\t\t\t\t\t\t\t\tboundIntersections.insert(visibleRect, \n\t\t\t\t\t\t\t\t\t\tnew QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","id":40875,"modified_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.iconsToDraw, new Comparator<IconDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IconDrawInfo object1, IconDrawInfo object2) {\n\t\t\t\treturn object1.iconOrder - object2.iconOrder;\n\t\t\t}\n\t\t});\n\t\tQuadRect bounds = new QuadRect(0, 0, rc.width, rc.height);\n\t\tbounds.inset(-bounds.width()/4, -bounds.height()/4);\n\t\tQuadTree<RectF> boundIntersections = new QuadTree<RectF>(bounds, 4, 0.6f);\n\t\tList<RectF> result = new ArrayList<RectF>();\n\t\t\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId, true);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint visbleWidth = icon.iconSize >= 0 ? (int) icon.iconSize : ico.getWidth();\n\t\t\t\t\t\tint visbleHeight = icon.iconSize >= 0 ? (int) icon.iconSize : ico.getHeight();\n\t\t\t\t\t\tboolean intersects = false;\n\t\t\t\t\t\tfloat coeff = rc.getDensityValue(rc.screenDensityRatio * rc.textScale);\n\t\t\t\t\t\tRectF rf = calculateRect(rc, icon, ico.getWidth(), ico.getHeight());\n\t\t\t\t\t\tRectF visibleRect = null;\n\t\t\t\t\t\tif (visbleHeight > 0 && visbleWidth > 0) {\n\t\t\t\t\t\t\tvisibleRect = calculateRect(rc, icon, visbleWidth, visbleHeight);\n\t\t\t\t\t\t\tboundIntersections.queryInBox(new QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom), result);\n\t\t\t\t\t\t\tfor (RectF r : result) {\n\t\t\t\t\t\t\t\tif (r.intersects(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom)) {\n\t\t\t\t\t\t\t\t\tintersects = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!intersects) {\n\t\t\t\t\t\t\tBitmap shield = icon.shieldId == null ? null : RenderingIcons.getIcon(context, icon.shieldId, true);\n\t\t\t\t\t\t\tif(shield != null) {\n\t\t\t\t\t\t\t\tRectF shieldRf = calculateRect(rc, icon, shield.getWidth(), shield.getHeight());\n\t\t\t\t\t\t\t\tif (coeff != 1f) {\n\t\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, shield.getWidth(), shield.getHeight());\n\t\t\t\t\t\t\t\t\tdrawBitmap(cv, shield, shieldRf, src);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdrawBitmap(cv, shield, shieldRf);\n\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (coeff != 1f) {\n\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, ico.getWidth(), ico.getHeight());\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId_1, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, ico, rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId2, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId3, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId4, true), rf, src);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId5, true), rf, src);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId_1, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, ico, rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId2, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId3, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId4, true), rf);\n\t\t\t\t\t\t\t\tdrawBitmap(cv, RenderingIcons.getIcon(context, icon.resId5, true), rf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(visibleRect != null) {\n\t\t\t\t\t\t\t\tvisibleRect.inset(-visibleRect.width() / 4, -visibleRect.height() / 4);\n\t\t\t\t\t\t\t\tboundIntersections.insert(visibleRect, \n\t\t\t\t\t\t\t\t\t\tnew QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"79fcd12f5647b198398a466c61695f4013d10863","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onPrepareBufferImage(Canvas canvas, RotatedTileBox tileBox, DrawSettings settings) {\n\t\tif(!Algorithms.objectEquals(this.settings.SELECTED_POI_FILTER_FOR_MAP.get(), \n\t\t\t\tfilter == null ? null : filter.getFilterId())) {\n\t\t\tif(this.settings.SELECTED_POI_FILTER_FOR_MAP.get() == null) {\n\t\t\t\tthis.filter = null;\n\t\t\t} else {\n\t\t\t\tPoiFiltersHelper pfh = app.getPoiFilters();\n\t\t\t\tthis.filter = pfh.getFilterById(this.settings.SELECTED_POI_FILTER_FOR_MAP.get());\n\t\t\t}\n\t\t\tdata.clearCache();\n\t\t}\n\t\tList<Amenity> objects = Collections.emptyList();\n\t\tif (filter != null) {\n\t\t\tif (tileBox.getZoom() >= startZoom) {\n\t\t\t\tdata.queryNewData(tileBox);\n\t\t\t\tobjects = data.getResults();\n\t\t\t\tif (objects != null) {\n\t\t\t\t\tint r = getRadiusPoi(tileBox);\n\t\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\t\tint x = (int) tileBox.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tint y = (int) tileBox.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tcanvas.drawCircle(x, y, r, pointAltUI);\n\t\t\t\t\t\tcanvas.drawCircle(x, y, r, point);\n\t\t\t\t\t\tString id = null;\n\t\t\t\t\t\tPoiType st = o.getType().getPoiTypeByKeyName(o.getSubType());\n\t\t\t\t\t\tif (st != null) {\n\t\t\t\t\t\t\tif (RenderingIcons.containsSmallIcon(st.getIconKeyName())) {\n\t\t\t\t\t\t\t\tid = st.getIconKeyName();\n\t\t\t\t\t\t\t} else if (RenderingIcons.containsSmallIcon(st.getOsmTag() + \"_\" + st.getOsmValue())) {\n\t\t\t\t\t\t\t\tid = st.getOsmTag() + \"_\" + st.getOsmValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id != null) {\n\t\t\t\t\t\t\tBitmap bmp = RenderingIcons.getIcon(view.getContext(), id, false);\n\t\t\t\t\t\t\tif (bmp != null) {\n\t\t\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmapTextLayer.putData(this, objects);\n\t}","id":40876,"modified_method":"@Override\n\tpublic void onPrepareBufferImage(Canvas canvas, RotatedTileBox tileBox, DrawSettings settings) {\n\t\tif(!Algorithms.objectEquals(this.settings.SELECTED_POI_FILTER_FOR_MAP.get(), \n\t\t\t\tfilter == null ? null : filter.getFilterId())) {\n\t\t\tif(this.settings.SELECTED_POI_FILTER_FOR_MAP.get() == null) {\n\t\t\t\tthis.filter = null;\n\t\t\t} else {\n\t\t\t\tPoiFiltersHelper pfh = app.getPoiFilters();\n\t\t\t\tthis.filter = pfh.getFilterById(this.settings.SELECTED_POI_FILTER_FOR_MAP.get());\n\t\t\t}\n\t\t\tdata.clearCache();\n\t\t}\n\n\t\tList<Amenity> objects = Collections.emptyList();\n\t\tif (filter != null) {\n\t\t\tif (tileBox.getZoom() >= startZoom) {\n\t\t\t\tdata.queryNewData(tileBox);\n\t\t\t\tobjects = data.getResults();\n\t\t\t\tif (objects != null) {\n\t\t\t\t\tint iconSize = poiBackground.getWidth() * 3 / 2;\n\t\t\t\t\tList<Amenity> fullObjects = new ArrayList<>();\n\t\t\t\t\tQuadRect bounds = new QuadRect(0, 0, tileBox.getPixWidth(), tileBox.getPixHeight());\n\t\t\t\t\t//bounds.inset(-bounds.width()/4, -bounds.height()/4);\n\t\t\t\t\tQuadTree<RectF> boundIntersections = new QuadTree<RectF>(bounds, 4, 0.6f);\n\t\t\t\t\tList<RectF> result = new ArrayList<RectF>();\n\n\t\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\t\tint x = (int) tileBox.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tint y = (int) tileBox.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tboolean intersects =false;\n\t\t\t\t\t\tRectF visibleRect = calculateRect(x, y, iconSize, iconSize);\n\t\t\t\t\t\t//canvas.drawRect(visibleRect, paintIcon);\n\n\t\t\t\t\t\tboundIntersections.queryInBox(new QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom), result);\n\t\t\t\t\t\tfor (RectF r : result) {\n\t\t\t\t\t\t\tif (r.intersects(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom)) {\n\t\t\t\t\t\t\t\tintersects = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (intersects) {\n\t\t\t\t\t\t\tcanvas.drawBitmap(poiBackgroundSmall, x - poiBackgroundSmall.getWidth() / 2, y - poiBackgroundSmall.getHeight() / 2, paintIconBackground);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tboundIntersections.insert(visibleRect,\n\t\t\t\t\t\t\t\t\tnew QuadRect(visibleRect.left, visibleRect.top, visibleRect.right, visibleRect.bottom));\n\t\t\t\t\t\t\tfullObjects.add(o);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (Amenity o : fullObjects) {\n\t\t\t\t\t\tint x = (int) tileBox.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tint y = (int) tileBox.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation()\n\t\t\t\t\t\t\t\t.getLongitude());\n\t\t\t\t\t\tcanvas.drawBitmap(poiBackground, x - poiBackground.getWidth() / 2, y - poiBackground.getHeight() / 2, paintIconBackground);\n\t\t\t\t\t\tString id = null;\n\t\t\t\t\t\tPoiType st = o.getType().getPoiTypeByKeyName(o.getSubType());\n\t\t\t\t\t\tif (st != null) {\n\t\t\t\t\t\t\tif (RenderingIcons.containsSmallIcon(st.getIconKeyName())) {\n\t\t\t\t\t\t\t\tid = st.getIconKeyName();\n\t\t\t\t\t\t\t} else if (RenderingIcons.containsSmallIcon(st.getOsmTag() + \"_\" + st.getOsmValue())) {\n\t\t\t\t\t\t\t\tid = st.getOsmTag() + \"_\" + st.getOsmValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id != null) {\n\t\t\t\t\t\t\tBitmap bmp = RenderingIcons.getIcon(view.getContext(), id, false);\n\t\t\t\t\t\t\tif (bmp != null) {\n\t\t\t\t\t\t\t\tpaintIcon.setColorFilter(new PorterDuffColorFilter(Color.WHITE, PorterDuff.Mode.SRC_IN));\n\t\t\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmapTextLayer.putData(this, objects);\n\t}","commit_id":"79fcd12f5647b198398a466c61695f4013d10863","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public POIMapLayer(final MapActivity activity) {\n\t\troutingHelper = activity.getRoutingHelper();\n\t\troutingHelper.addListener(this);\n\t\tsettings = activity.getMyApplication().getSettings();\n\t\tapp = activity.getMyApplication();\n\t\tdata = new OsmandMapLayer.MapLayerData<List<Amenity>>() {\n\t\t\t{\n\t\t\t\tZOOM_THRESHOLD = 0;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean isInterrupted() {\n\t\t\t\treturn super.isInterrupted();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void layerOnPostExecute() {\n\t\t\t\tactivity.getMapView().refreshMap();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected List<Amenity> calculateResult(RotatedTileBox tileBox) {\n\t\t\t\tQuadRect latLonBounds = tileBox.getLatLonBounds();\n\t\t\t\tif (filter == null) {\n\t\t\t\t\treturn new ArrayList<Amenity>();\n\t\t\t\t}\n\t\t\t\tint z = (int) Math.floor(tileBox.getZoom() + Math.log(view.getSettings().MAP_DENSITY.get()) / Math.log(2)); \n\t\t\t\t\n\t\t\t\treturn filter.searchAmenities(latLonBounds.top, latLonBounds.left,\n\t\t\t\t\t\tlatLonBounds.bottom, latLonBounds.right, z , new ResultMatcher<Amenity>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(Amenity object) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn isInterrupted();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}","id":40877,"modified_method":"public POIMapLayer(final MapActivity activity) {\n\t\troutingHelper = activity.getRoutingHelper();\n\t\troutingHelper.addListener(this);\n\t\tsettings = activity.getMyApplication().getSettings();\n\t\tapp = activity.getMyApplication();\n\t\tdata = new OsmandMapLayer.MapLayerData<List<Amenity>>() {\n\t\t\t{\n\t\t\t\tZOOM_THRESHOLD = 0;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean isInterrupted() {\n\t\t\t\treturn super.isInterrupted();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void layerOnPostExecute() {\n\t\t\t\tactivity.getMapView().refreshMap();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected List<Amenity> calculateResult(RotatedTileBox tileBox) {\n\t\t\t\tQuadRect latLonBounds = tileBox.getLatLonBounds();\n\t\t\t\tif (filter == null) {\n\t\t\t\t\treturn new ArrayList<Amenity>();\n\t\t\t\t}\n\t\t\t\tint z = (int) Math.floor(tileBox.getZoom() + Math.log(view.getSettings().MAP_DENSITY.get()) / Math.log(2));\n\n\t\t\t\tList<Amenity> res = filter.searchAmenities(latLonBounds.top, latLonBounds.left,\n\t\t\t\t\t\tlatLonBounds.bottom, latLonBounds.right, z , new ResultMatcher<Amenity>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(Amenity object) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn isInterrupted();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tCollections.sort(res, new Comparator<Amenity>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(Amenity lhs, Amenity rhs) {\n\t\t\t\t\t\treturn lhs.getId() < rhs.getId() ? -1 : (lhs.getId().longValue() == rhs.getId().longValue() ? 0 : 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t}","commit_id":"79fcd12f5647b198398a466c61695f4013d10863","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void initLayer(OsmandMapTileView view) {\n\t\tthis.view = view;\n\t\tpointAltUI = new Paint();\n\t\tpointAltUI.setColor(view.getApplication().getResources().getColor(R.color.poi_background));\n\t\tpointAltUI.setStyle(Style.FILL);\n\n\t\tpaintIcon = new Paint();\n\n\t\tpoint = new Paint();\n\t\tpoint.setColor(Color.GRAY);\n\t\tpoint.setAntiAlias(true);\n\t\tpoint.setStyle(Style.STROKE);\n\t\tresourceManager = view.getApplication().getResourceManager();\n\t\tmapTextLayer = view.getLayerByClass(MapTextLayer.class);\n\t}","id":40878,"modified_method":"@Override\n\tpublic void initLayer(OsmandMapTileView view) {\n\t\tthis.view = view;\n\n\t\tpaintIcon = new Paint();\n\t\tpaintIcon.setStrokeWidth(1);\n\t\tpaintIcon.setStyle(Style.STROKE);\n\t\tpaintIcon.setColor(Color.BLUE);\n\t\tpaintIconBackground = new Paint();\n\t\tpoiBackground = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_white_orange_poi_shield);\n\t\tpoiBackgroundSmall = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_white_orange_poi_shield_small);\n\n\t\tresourceManager = view.getApplication().getResourceManager();\n\t\tmapTextLayer = view.getLayerByClass(MapTextLayer.class);\n\t}","commit_id":"79fcd12f5647b198398a466c61695f4013d10863","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void insertMapRenderObjectIndex(Map<PreparedStatement, Integer> statements, \r\n\t\t\tPreparedStatement mapStat, PreparedStatement mapWayLocationsStat, Entity e, String name, int type, boolean writeAsPoint, int batchSize) throws SQLException {\r\n\t\tassert IndexMapRenderObject.values().length == 4;\r\n\t\tif(e instanceof Relation){\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tboolean init = false;\r\n\t\tdouble minLat = 180;\r\n\t\tdouble maxLat = -180;\r\n\t\tdouble minLon = 360;\r\n\t\tdouble maxLon = -360;\r\n\t\tCollection<Node> nodes; \r\n\t\tif (e instanceof Way) {\r\n\t\t\tif (writeAsPoint) {\r\n\t\t\t\tLatLon center = MapUtils.getCenter(((Way) e));\r\n\t\t\t\tnodes = Collections.singleton(new Node(center.getLatitude(), center.getLongitude(), -1));\r\n\t\t\t} else {\r\n\t\t\t\tnodes = ((Way) e).getNodes();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnodes = Collections.singleton((Node) e);\r\n\t\t}\r\n\t\tbyte[] bytes = new byte[nodes.size() * 8];\r\n\t\t// generate unique id\r\n\t\tlong id = e.getId() << 1;\r\n\t\tif(e instanceof Way){\r\n\t\t\tid ++;\r\n\t\t}\r\n\t\tint offset = 0;\r\n\t\tfor (Node n : nodes) {\r\n\t\t\tif (n != null) {\r\n\t\t\t\tminLat = Math.min(minLat, n.getLatitude());\r\n\t\t\t\tmaxLat = Math.max(maxLat, n.getLatitude());\r\n\t\t\t\tminLon = Math.min(minLon, n.getLongitude());\r\n\t\t\t\tmaxLon = Math.max(maxLon, n.getLongitude());\r\n\t\t\t\tinit = true;\r\n\t\t\t\tAlgoritms.putIntToBytes(bytes, offset, Float.floatToIntBits((float) n.getLatitude()));\r\n\t\t\t\toffset += 4;\r\n\t\t\t\tAlgoritms.putIntToBytes(bytes, offset, Float.floatToIntBits((float) n.getLongitude()));\r\n\t\t\t\toffset += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (init) {\r\n\t\t\tmapStat.setLong(IndexMapRenderObject.ID.ordinal() + 1, id);\r\n\t\t\tmapStat.setInt(IndexMapRenderObject.TYPE.ordinal() + 1, type);\r\n\t\t\tmapStat.setString(IndexMapRenderObject.NAME.ordinal() + 1, name);\r\n\t\t\tmapStat.setBytes(IndexMapRenderObject.NODES.ordinal() + 1, bytes);\r\n\t\t\taddBatch(statements, mapStat);\r\n\r\n\t\t\tmapWayLocationsStat.setLong(1, id);\r\n\t\t\tmapWayLocationsStat.setDouble(2, minLon);\r\n\t\t\tmapWayLocationsStat.setDouble(3, maxLon);\r\n\t\t\tmapWayLocationsStat.setDouble(4, minLat);\r\n\t\t\tmapWayLocationsStat.setDouble(5, maxLat);\r\n\t\t\taddBatch(statements, mapWayLocationsStat);\r\n\t\t}\r\n\t}","id":40879,"modified_method":"public static void insertMapRenderObjectIndex(Map<PreparedStatement, Integer> statements, \r\n\t\t\tPreparedStatement mapStat, PreparedStatement mapWayLocationsStat, Entity e, String name, int type, boolean writeAsPoint, int batchSize) throws SQLException {\r\n\t\tassert IndexMapRenderObject.values().length == 4;\r\n\t\tif(e instanceof Relation){\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tboolean init = false;\r\n\t\tdouble minLat = 180;\r\n\t\tdouble maxLat = -180;\r\n\t\tdouble minLon = 360;\r\n\t\tdouble maxLon = -360;\r\n\t\tCollection<Node> nodes; \r\n\t\tif (e instanceof Way) {\r\n\t\t\tif (writeAsPoint) {\r\n\t\t\t\tLatLon center = MapUtils.getCenter(((Way) e));\r\n\t\t\t\tnodes = Collections.singleton(new Node(center.getLatitude(), center.getLongitude(), -1));\r\n\t\t\t} else {\r\n\t\t\t\tnodes = ((Way) e).getNodes();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnodes = Collections.singleton((Node) e);\r\n\t\t}\r\n\t\tbyte[] bytes = new byte[nodes.size() * 8];\r\n\t\t// generate unique id\r\n\t\tlong id = e.getId() << 1;\r\n\t\tif(e instanceof Way){\r\n\t\t\tid ++;\r\n\t\t}\r\n\t\tint offset = 0;\r\n\t\tfor (Node n : nodes) {\r\n\t\t\tif (n != null) {\r\n\t\t\t\tminLat = Math.min(minLat, n.getLatitude());\r\n\t\t\t\tmaxLat = Math.max(maxLat, n.getLatitude());\r\n\t\t\t\tminLon = Math.min(minLon, n.getLongitude());\r\n\t\t\t\tmaxLon = Math.max(maxLon, n.getLongitude());\r\n\t\t\t\tinit = true;\r\n\t\t\t\tAlgoritms.putIntToBytes(bytes, offset, Float.floatToIntBits((float) n.getLatitude()));\r\n\t\t\t\toffset += 4;\r\n\t\t\t\tAlgoritms.putIntToBytes(bytes, offset, Float.floatToIntBits((float) n.getLongitude()));\r\n\t\t\t\toffset += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (init) {\r\n\t\t\tmapStat.setLong(IndexMapRenderObject.ID.ordinal() + 1, id);\r\n\t\t\tmapStat.setInt(IndexMapRenderObject.TYPE.ordinal() + 1, type);\r\n\t\t\tmapStat.setString(IndexMapRenderObject.NAME.ordinal() + 1, name);\r\n\t\t\tmapStat.setBytes(IndexMapRenderObject.NODES.ordinal() + 1, bytes);\r\n\t\t\taddBatch(statements, mapStat);\r\n\r\n\t\t\tmapWayLocationsStat.setLong(1, id);\r\n\t\t\tmapWayLocationsStat.setFloat(2, (float) minLon);\r\n\t\t\tmapWayLocationsStat.setFloat(3, (float) maxLon);\r\n\t\t\tmapWayLocationsStat.setFloat(4, (float) minLat);\r\n\t\t\tmapWayLocationsStat.setFloat(5, (float) maxLat);\r\n\t\t\taddBatch(statements, mapWayLocationsStat);\r\n\t\t}\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setType(int type) {\r\n\t\tthis.type = type;\r\n\t}","id":40880,"modified_method":"public void setType(int type) {\r\n\t\tthis.type = type;\r\n\t\torder = -1;\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int getMapOrder(){\r\n\t\tint order = -1;\r\n\t\tif((type & MapRenderingTypes.TYPE_MASK) == MapRenderingTypes.POLYGON_TYPE){\r\n\t\t\tif(MapRenderingTypes.isPolygonBuilding(type)){\r\n\t\t\t\torder = 64;\r\n\t\t\t} else {\r\n\t\t\t\torder = 1;\r\n\t\t\t}\r\n\t\t} else if((type & MapRenderingTypes.TYPE_MASK) == MapRenderingTypes.POLYLINE_TYPE){\r\n\t\t\tint oType = MapRenderingTypes.getObjectType(type);\r\n\t\t\tint sType = MapRenderingTypes.getPolylineSubType(type);\r\n\t\t\tif(oType == MapRenderingTypes.HIGHWAY){\r\n\t\t\t\torder = 32 - sType + 24;\r\n\t\t\t} else if(oType == MapRenderingTypes.RAILWAY){\r\n\t\t\t\torder = 58;\r\n\t\t\t} else if(oType == MapRenderingTypes.WATERWAY){\r\n\t\t\t\torder = 18;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\torder = 128;\r\n\t\t}\r\n\t\treturn order;\r\n\t}","id":40881,"modified_method":"public int getMapOrder(){\r\n\t\tif (order == -1) {\r\n\t\t\tint oType = MapRenderingTypes.getObjectType(type);\r\n\t\t\tint sType = MapRenderingTypes.getPolylineSubType(type);\r\n\t\t\tif ((type & MapRenderingTypes.TYPE_MASK) == MapRenderingTypes.POLYGON_TYPE) {\r\n\t\t\t\tif (MapRenderingTypes.isPolygonBuilding(type)) {\r\n\t\t\t\t\torder = 64;\r\n\t\t\t\t} else if (oType == MapRenderingTypes.POWER) {\r\n\t\t\t\t\torder = 60;\r\n\t\t\t\t} else {\r\n\t\t\t\t\torder = 1;\r\n\t\t\t\t}\r\n\t\t\t} else if ((type & MapRenderingTypes.TYPE_MASK) == MapRenderingTypes.POLYLINE_TYPE) {\r\n\r\n\t\t\t\tif (oType == MapRenderingTypes.HIGHWAY) {\r\n\t\t\t\t\torder = 32 - sType + 24;\r\n\t\t\t\t} else if (oType == MapRenderingTypes.RAILWAY) {\r\n\t\t\t\t\torder = 58;\r\n\t\t\t\t} else if (oType == MapRenderingTypes.AERIALWAY) {\r\n\t\t\t\t\torder = 68; // over buildings\r\n\t\t\t\t} else if (oType == MapRenderingTypes.POWER) {\r\n\t\t\t\t\torder = 68; // over buildings\r\n\t\t\t\t} else if (oType == MapRenderingTypes.ADMINISTRATIVE) {\r\n\t\t\t\t\torder = 62;\r\n\t\t\t\t} else if (oType == MapRenderingTypes.WATERWAY) {\r\n\t\t\t\t\torder = 18;\r\n\t\t\t\t} else {\r\n\t\t\t\t\torder = 10;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\torder = 128;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn order;\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static void init(){\r\n\t\t\r\n\t// 1. highway\t\r\n\t\tregister(\"highway\", \"motorway\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"motorway_link\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"trunk\", HIGHWAY, PL_HW_TRUNK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"trunk_link\", HIGHWAY, PL_HW_TRUNK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"primary\", HIGHWAY, PL_HW_PRIMARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"primary_link\", HIGHWAY, PL_HW_PRIMARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"secondary\", HIGHWAY, PL_HW_SECONDARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"secondary_link\", HIGHWAY, PL_HW_SECONDARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"tertiary\", HIGHWAY, PL_HW_TERTIARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"unclassified\", HIGHWAY, PL_HW_UNCLASSIFIED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"road\", HIGHWAY, PL_HW_UNCLASSIFIED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"residential\", HIGHWAY, PL_HW_RESIDENTIAL, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"living_street\", HIGHWAY, PL_HW_LIVING_STREET, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"service\", HIGHWAY, PL_HW_SERVICE, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"track\", HIGHWAY, PL_HW_TRACK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"pedestrian\", HIGHWAY, PL_HW_PEDESTRIAN, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n//\t\tregister(\"highway\", \"raceway\", HIGHWAY, PL_HW_RACEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"services\", HIGHWAY, PL_HW_SERVICES, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n//\t\tregister(\"highway\", \"bus_guideway\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"path\", HIGHWAY, PL_HW_PATH, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"cycleway\", HIGHWAY, PL_HW_CYCLEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"footway\", HIGHWAY, PL_HW_FOOTWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"bridleway\", HIGHWAY, PL_HW_BRIDLEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"byway\", HIGHWAY, PL_HW_BYWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"steps\", HIGHWAY, PL_HW_STEPS, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"ford\", HIGHWAY, PL_HW_FORD, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"construction\", HIGHWAY, PL_HW_CONSTRUCTION, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"proposed\", HIGHWAY, PL_HW_PROPOSED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"highway\", \"mini_roundabout\", HIGHWAY, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"stop\", HIGHWAY, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"give_way\", HIGHWAY, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"traffic_signals\", HIGHWAY, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"motorway_junction\", HIGHWAY, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"bus_stop\", HIGHWAY, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"platform\", HIGHWAY, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"turning_circle\", HIGHWAY, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"emergency_access_point\", HIGHWAY, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"speed_camera\", HIGHWAY, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"street_lamp\", HIGHWAY, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"traffic_calming\", \"yes\", HIGHWAY, 50, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"bump\", HIGHWAY, 51, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"chicane\", HIGHWAY, 52, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"cushion\", HIGHWAY, 53, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"hump\", HIGHWAY, 54, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"rumble_strip\", HIGHWAY, 55, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"table\", HIGHWAY, 56, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"choker\", HIGHWAY, 57, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", null, HIGHWAY, 58, POINT_TYPE); //$NON-NLS-1$\r\n\t\t\r\n\t// 2. barrier\t\r\n\t\tregister(\"barrier\", \"hedge\", BARRIER, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"fence\", BARRIER, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"wall\", BARRIER, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"ditch\", BARRIER, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"retaining_wall\", BARRIER, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"city_wall\", BARRIER, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"bollard\", BARRIER, 6, POLYLINE_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"cycle_barrier\", BARRIER, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"block\", BARRIER, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"cattle_grid\", BARRIER, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"toll_booth\", BARRIER, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"entrance\", BARRIER, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"gate\", BARRIER, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"lift_gate\", BARRIER, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"stile\", BARRIER, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"horse_stile\", BARRIER, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"kissing_gate\", BARRIER, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"sally_port\", BARRIER, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"turnstile\", BARRIER, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"kent_carriage_gap\", BARRIER, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t// 3. waterway\t\r\n\t\tregister(\"waterway\", \"stream\", WATERWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\t\t\r\n\t\tregister(\"waterway\", \"river\", WATERWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"riverbank\", WATERWAY, 3, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"canal\", WATERWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"ditch\", WATERWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"drain\", WATERWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"dock\", WATERWAY, 7, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"lock_gate\", WATERWAY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"turning_point\", WATERWAY, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"boatyard\", WATERWAY, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"weir\", WATERWAY, 11, POLYLINE_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"dam\", WATERWAY, 12, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 4. railway\t\r\n\t\tregister(\"railway\", \"rail\", RAILWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"tram\", RAILWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"light_rail\", RAILWAY, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"abandoned\", RAILWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"disused\", RAILWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"subway\", RAILWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"preserved\", RAILWAY, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"narrow_gauge\", RAILWAY, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"construction\", RAILWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"monorail\", RAILWAY, 10, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"funicular\", RAILWAY, 11, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"railway\", \"platform\", RAILWAY, 12, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"station\", RAILWAY, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"turntable\", RAILWAY, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"railway\", \"halt\", RAILWAY, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"tram_stop\", RAILWAY, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"crossing\", RAILWAY, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"level_crossing\", RAILWAY, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"subway_entrance\", RAILWAY, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"buffer_stop\", RAILWAY, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\r\n\t// 5. aeroway\r\n\t\tregister(\"aeroway\", \"aerodrome\", AEROWAY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"terminal\", AEROWAY, 2, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"helipad\", AEROWAY, 3, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"runway\", AEROWAY, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"taxiway\", AEROWAY, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"apron\", AEROWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"gate\", AEROWAY, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"windsock\", AEROWAY, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 6. aerialway\r\n\t\tregister(\"aerialway\", \"cable_car\", AERIALWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"gondola\", AERIALWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"chair_lift\", AERIALWAY, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"mixed_lift\", AERIALWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"drag_lift\", AERIALWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"gondola\", AERIALWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"aerialway\", \"station\", AERIALWAY, 7); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"aerialway\", \"pylon\", AERIALWAY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"goods\", AERIALWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t// 7. power\r\n\t\tregister(\"power\", \"tower\", POWER, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"pole\", POWER, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"line\", POWER, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"minor_line\", POWER, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"power\", \"station\", POWER, 5); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"power\", \"sub_station\", POWER, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"generator\", POWER, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"cable_distribution_cabinet\", POWER, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t// 8. man_made\r\n\t\tregister(\"building\", \"yes\", MAN_MADE, SUBTYPE_BUILDING, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"building\", null, MAN_MADE, SUBTYPE_BUILDING, POLYGON_TYPE); //$NON-NLS-1$ \r\n\t\tregister(\"man_made\", \"wastewater_plant\", MAN_MADE, 2, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"man_made\", \"water_works\", MAN_MADE, 3); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"man_made\", \"works\", MAN_MADE, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"building\", \"garages\", MAN_MADE, SUBTYPE_GARAGES, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t\r\n\t\tregister(\"man_made\", \"cutline\", MAN_MADE, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"groyne\", MAN_MADE, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"pier\", MAN_MADE, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"pipeline\", MAN_MADE, 10, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"reservoir_covered\", MAN_MADE, 11, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"man_made\", \"beacon\", MAN_MADE, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"crane\", MAN_MADE, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"lighthouse\", MAN_MADE, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"mineshaft\", MAN_MADE, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"adit\", MAN_MADE, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"petroleum_well\", MAN_MADE, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"surveillance\", MAN_MADE, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"survey_point\", MAN_MADE, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"tower\", MAN_MADE, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"watermill\", MAN_MADE, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"water_tower\", MAN_MADE, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"water_well\", MAN_MADE, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"windmill\", MAN_MADE, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 9. leisure\r\n\t\tregister(\"leisure\", \"dog_park\", LEISURE, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"sports_centre\", LEISURE, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"golf_course\", LEISURE, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"stadium\", LEISURE, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterRules(\"leisure\", \"track\", LEISURE, 5, POINT_TYPE, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"pitch\", LEISURE, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"water_park\", LEISURE, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"marina\", LEISURE, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"slipway\", LEISURE, 9, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"fishing\", LEISURE, 10, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"nature_reserve\", LEISURE, 11, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"park\", LEISURE, 12, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"playground\", LEISURE, 13, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"garden\", LEISURE, 14, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"common\", LEISURE, 15, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"ice_rink\", LEISURE, 16, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"miniature_golf\", LEISURE, 17, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"dance\", LEISURE, 18, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 10. office\r\n\t\tregister(\"office\", \"accountant\", OFFICE, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"architect\", OFFICE, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"company\", OFFICE, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"employment_agency\", OFFICE, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"estate_agent\", OFFICE, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"government\", OFFICE, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"insurance\", OFFICE, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"it\", OFFICE, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"lawyer\", OFFICE, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"ngo\", OFFICE, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"quango\", OFFICE, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"research\", OFFICE, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"telecommunication\", OFFICE, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"travel_agent\", OFFICE, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t// changed\r\n\t\tregister(\"amenity\", \"architect_office\", OFFICE, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 11. shop\r\n\t\t// reserve numbers from 1-10\r\n\t\tregister(\"shop\", \"alcohol\", SHOP, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"bakery\", SHOP, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"beauty\", SHOP, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"beverages\", SHOP, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"bicycle\", SHOP, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"books\", SHOP, 46, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"boutique\", SHOP, 47, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"butcher\", SHOP, 48, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"car\", SHOP, 49, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"car_repair\", SHOP, 50, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"charity\", SHOP, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"chemist\", SHOP, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"clothes\", SHOP, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"computer\", SHOP, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"confectionery\", SHOP, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"convenience\", SHOP, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"department_store\", SHOP, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"dry_cleaning\", SHOP, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"doityourself\", SHOP, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"electronics\", SHOP, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"fabrics\", SHOP, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"farm\", SHOP, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"florist\", SHOP, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"funeral_directors\", SHOP, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"furniture\", SHOP, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"garden_centre\", SHOP, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"general\", SHOP, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"gift\", SHOP, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"glaziery\", SHOP, 29, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"greengrocer\", SHOP, 30, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hairdresser\", SHOP, 31, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hardware\", SHOP, 32, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hearing_aids\", SHOP, 33, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hifi\", SHOP, 34, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"ice_cream\", SHOP, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hardware\", SHOP, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hearing_aids\", SHOP, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hifi\", SHOP, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"ice_cream\", SHOP, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"jewelry\", SHOP, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"kiosk\", SHOP, 51, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"laundry\", SHOP, 52, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"mall\", SHOP, 53, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"massage\", SHOP, 54, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"money_lender\", SHOP, 55, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"motorcycle\", SHOP, 56, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"newsagent\", SHOP, 57, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"optician\", SHOP, 58, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"organic\", SHOP, 59, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"outdoor\", SHOP, 60, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"pawnbroker\", SHOP, 61, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"second_hand\", SHOP, 62, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"sports\", SHOP, 63, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"stationery\", SHOP, 64, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"supermarket\", SHOP, 65, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"shoes\", SHOP, 66, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"tattoo\", SHOP, 67, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"toys\", SHOP, 68, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"travel_agency\", SHOP, 69, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"variety_store\", SHOP, 70, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"video\", SHOP, 71, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\t\r\n\t// 12. emergency\r\n\t\tregisterAsBuilding(\"emergency\", \"ambulance_station\", EMERGENCY, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"emergency\", \"ses_station\", EMERGENCY, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"emergency\", \"fire_extinguisher\", EMERGENCY, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_flapper\", EMERGENCY, 4,POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_hose\", EMERGENCY, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_hydrant\", EMERGENCY, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"phone\", EMERGENCY, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"ses_station\", EMERGENCY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"siren\", EMERGENCY, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\t// change category\r\n\t\tregister(\"amenity\", \"fire_station\", EMERGENCY, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 13. tourism\r\n\t\tregister(\"tourism\", \"attraction\", TOURISM, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"artwork\", TOURISM, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"camp_site\", TOURISM, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"caravan_site\", TOURISM, 5, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"picnic_site\", TOURISM, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"theme_park\", TOURISM, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"zoo\", TOURISM, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"tourism\", \"alpine_hut\",  TOURISM, 9); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"chalet\", TOURISM, 10); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"guest_house\", TOURISM, 11); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"hostel\", TOURISM, 12); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"hotel\", TOURISM, 13); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"motel\", TOURISM, 14); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"museum\", TOURISM, 15); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"tourism\", \"information\", TOURISM, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"viewpoint\", TOURISM, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", null, TOURISM, 18, POINT_TYPE); //$NON-NLS-1$ \r\n\t\r\n\t// 14. historic\r\n\t\tregister(\"historic\", \"archaeological_site\", HISTORIC, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"battlefield\", HISTORIC, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"castle\", HISTORIC, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"fort\", HISTORIC, 5, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"ruins\", HISTORIC, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"historic\", \"monument\", HISTORIC, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"historic\", \"boundary_stone\", HISTORIC, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"memorial\", HISTORIC, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wayside_cross\", HISTORIC, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wayside_shrine\", HISTORIC, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wreck\", HISTORIC, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", null, HISTORIC, 12, POINT_TYPE); //$NON-NLS-1$ \r\n\t\r\n\t// 15. landuse\r\n\t\tregister(\"landuse\", \"allotments\", LANDUSE, 1, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"basin\", LANDUSE, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"brownfield\", LANDUSE, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"cemetery\", LANDUSE, 4, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"commercial\", LANDUSE, 5, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"construction\", LANDUSE, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farm\", LANDUSE, 7, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farmland\", LANDUSE, 8, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farmyard\", LANDUSE, 9, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"forest\", LANDUSE, 10, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"garages\", LANDUSE, 11, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"grass\", LANDUSE, 12, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"greenfield\", LANDUSE, 13, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"greenhouse_horticulture\", LANDUSE, 14, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"industrial\", LANDUSE, 15, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"landfill\", LANDUSE, 16, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"meadow\", LANDUSE, 17, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"military\", LANDUSE, 18, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"landuse\", \"orchard\", LANDUSE, 19, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"railway\", LANDUSE, 20, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$]\r\n\t\tregister(\"landuse\", \"recreation_ground\", LANDUSE, 21, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"reservoir\", LANDUSE, 22, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"residential\", LANDUSE, 23, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"retail\", LANDUSE, 24, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"salt_pond\", LANDUSE, 25, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"village_green\", LANDUSE, 26, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"vineyard\", LANDUSE, 27, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 16. military\r\n\t\tregister(\"military\", \"airfield\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"bunker\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"barracks\", MILITARY, 1, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"danger_area\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"range\", MILITARY, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"naval_base\", MILITARY, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t\r\n\t// 17. natural\t\r\n\t\tregister(\"natural\", \"coastline\", NATURAL, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"natural\", \"bay\", NATURAL, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"beach\", NATURAL, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"cave_entrance\", NATURAL, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterRules(\"natural\", \"cliff\", NATURAL, 4, POLYGON_TYPE, POINT_TYPE, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"fell\", NATURAL, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"glacier\", NATURAL, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"heath\", NATURAL, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"land\", NATURAL, 9, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"heath\", NATURAL, 10, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"marsh\", NATURAL, 11, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"mud\", NATURAL, 12, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"peak\", NATURAL, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"sand\", NATURAL, 14, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"scree\", NATURAL, 15, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"scrub\", NATURAL, 16, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"spring\", NATURAL, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"stone\", NATURAL, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"tree\", NATURAL, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"volcano\", NATURAL, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"water\", NATURAL, 21, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"wetland\", NATURAL, 22, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"wood\", NATURAL, 23, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 18. amenity sustenance\r\n\t\tregisterAsBuilding(\"amenity\", \"restaurant\", AMENITY_SUSTENANCE, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"cafe\", AMENITY_SUSTENANCE, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"food_court\", AMENITY_SUSTENANCE, 3); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"fast_food\", AMENITY_SUSTENANCE, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"pub\", AMENITY_SUSTENANCE, 5); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"bar\", AMENITY_SUSTENANCE, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"biergarten\", AMENITY_SUSTENANCE, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"drinking_water\", AMENITY_SUSTENANCE, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bbq\", AMENITY_SUSTENANCE, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 19. amenity education\r\n\t\tregisterAsBuilding(\"amenity\", \"kindergarten\", AMENITY_EDUCATION, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"school\", AMENITY_EDUCATION, 2, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"college\", AMENITY_EDUCATION, 3, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"library\", AMENITY_EDUCATION, 4, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"university\", AMENITY_EDUCATION, 5, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t\r\n\t// 20. amenity transportation\r\n\t\tregister(\"amenity\", \"parking\", AMENITY_TRANSPORTATION, SUBTYPE_PARKING, //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\t\t\tPOLYGON_WITH_CENTER_TYPE, POINT_TYPE); \r\n\t\tregister(\"amenity\", \"bicycle_parking\", AMENITY_TRANSPORTATION, 2, //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\t\t\tPOLYGON_WITH_CENTER_TYPE, POINT_TYPE); \r\n\t\tregister(\"amenity\", \"ferry_terminal\", AMENITY_TRANSPORTATION, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"fuel\", AMENITY_TRANSPORTATION, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t// do not register small objects as area\r\n\t\tregister(\"amenity\", \"taxi\", AMENITY_TRANSPORTATION, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bicycle_rental\", AMENITY_TRANSPORTATION, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bus_station\", AMENITY_TRANSPORTATION, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"amenity\", \"car_rental\", AMENITY_TRANSPORTATION, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"car_sharing\", AMENITY_TRANSPORTATION, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"car_wash\", AMENITY_TRANSPORTATION, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"grit_bin\", AMENITY_TRANSPORTATION, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 21. amenity finance\r\n\t\tregister(\"amenity\", \"atm\", AMENITY_FINANCE, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"bank\", AMENITY_FINANCE, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bureau_de_change\", AMENITY_FINANCE, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 22. amenity healthcare\r\n\t\tregisterAsBuilding(\"amenity\", \"pharmacy\", AMENITY_HEALTHCARE, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"hospital\", AMENITY_HEALTHCARE, 2, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"baby_hatch\", AMENITY_HEALTHCARE, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"dentist\", AMENITY_HEALTHCARE, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"doctors\", AMENITY_HEALTHCARE, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"veterinary\", AMENITY_HEALTHCARE, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"first_aid\", AMENITY_HEALTHCARE, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 23. amenity entertainment\r\n\t\t\r\n\t\tregister(\"amenity\", \"arts_centre\", AMENITY_ENTERTAINMENT, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"cinema\", AMENITY_ENTERTAINMENT, 3, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"community_centre\", AMENITY_ENTERTAINMENT, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"social_centre\", AMENITY_ENTERTAINMENT, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"amenity\", \"nightclub\", AMENITY_ENTERTAINMENT, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"stripclub\", AMENITY_ENTERTAINMENT, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"studio\", AMENITY_ENTERTAINMENT, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"theatre\", AMENITY_ENTERTAINMENT, 9); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"sauna\", AMENITY_ENTERTAINMENT, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"brothel\", AMENITY_ENTERTAINMENT, 11); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 24. amenity others\r\n\t\tregister(\"amenity\", \"marketplace\", AMENITY_OTHER, 1, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"amenity\", \"courthouse\", AMENITY_OTHER, 5); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"crematorium\", AMENITY_OTHER, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"embassy\", AMENITY_OTHER, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"grave_yard\", AMENITY_OTHER, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"hunting_stand\", AMENITY_OTHER, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"police\", AMENITY_OTHER, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"post_box\", AMENITY_OTHER, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"post_office\", AMENITY_OTHER, 12); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"prison\", AMENITY_OTHER, 13); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"public_building\", AMENITY_OTHER, 14); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"recycling\", AMENITY_OTHER, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"shelter\", AMENITY_OTHER, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"telephone\", AMENITY_OTHER, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"toilets\", AMENITY_OTHER, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"townhall\", AMENITY_OTHER, 19); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"vending_machine\", AMENITY_OTHER, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"waste_basket\", AMENITY_OTHER, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"waste_disposal\", AMENITY_OTHER, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"fountain\", AMENITY_OTHER, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bench\", AMENITY_OTHER, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"clock\", AMENITY_OTHER, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 25. administrative \r\n\t\tregister(\"place\", \"continent\", ADMINISTRATIVE, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"country\", ADMINISTRATIVE, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"state\", ADMINISTRATIVE, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"region\", ADMINISTRATIVE, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"county\", ADMINISTRATIVE, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"city\", ADMINISTRATIVE, 6, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"town\", ADMINISTRATIVE, 7, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"village\", ADMINISTRATIVE, 8, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"hamlet\", ADMINISTRATIVE, 9, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"suburb\", ADMINISTRATIVE, 10, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"locality\", ADMINISTRATIVE, 11, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"island\", ADMINISTRATIVE, 12, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"boundary\", \"administrative\", ADMINISTRATIVE, 15, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"civil\", ADMINISTRATIVE, 16, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"political\", ADMINISTRATIVE, 17, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"maritime\", ADMINISTRATIVE, 18, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"national_park\", ADMINISTRATIVE, 19, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"protected_area\", ADMINISTRATIVE, 20, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"addr:housenumber\", null, ADMINISTRATIVE, 21, POINT_TYPE); //$NON-NLS-1$\r\n\r\n\t\t\r\n\t\t\r\n\t// 27. sport\r\n\t\tregister(\"sport\", \"9pin\", SPORT, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"10pin\", SPORT, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"archery\", SPORT, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"athletics\", SPORT, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"australian_football\", SPORT, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"baseball\", SPORT, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"basketball\", SPORT, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"beachvolleyball\", SPORT, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"boules\", SPORT, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"bowls\", SPORT, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"canoe\", SPORT, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"chess\", SPORT, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"climbing\", SPORT, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cricket\", SPORT, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cricket_nets\", SPORT, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"croquet\", SPORT, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cycling\", SPORT, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"diving\", SPORT, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"dog_racing\", SPORT, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"equestrian\", SPORT, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"football\", SPORT, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"golf\", SPORT, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"gymnastics\", SPORT, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"hockey\", SPORT, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"horse_racing\", SPORT, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"ice_stock\", SPORT, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"korfball\", SPORT, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"motor\", SPORT, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"multi\", SPORT, 29, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"orienteering\", SPORT, 30, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"paddle_tennis\", SPORT, 31, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"paragliding\", SPORT, 32, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"pelota\", SPORT, 33, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"racquet\", SPORT, 34, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"rowing\", SPORT, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"rugby\", SPORT, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"shooting\", SPORT, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skating\", SPORT, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skateboard\", SPORT, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skiing\", SPORT, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"soccer\", SPORT, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"swimming\", SPORT, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"table_tennis\", SPORT, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"team_handball\", SPORT, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"tennis\", SPORT, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"toboggan\", SPORT, 46, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"volleyball\", SPORT, 47, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\t\t\r\n\t}","id":40882,"modified_method":"private static void init(){\r\n\t\t\r\n\t// 1. highway\t\r\n\t\tregister(\"highway\", \"motorway\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"motorway_link\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"trunk\", HIGHWAY, PL_HW_TRUNK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"trunk_link\", HIGHWAY, PL_HW_TRUNK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"primary\", HIGHWAY, PL_HW_PRIMARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"primary_link\", HIGHWAY, PL_HW_PRIMARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"secondary\", HIGHWAY, PL_HW_SECONDARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"secondary_link\", HIGHWAY, PL_HW_SECONDARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"tertiary\", HIGHWAY, PL_HW_TERTIARY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"unclassified\", HIGHWAY, PL_HW_UNCLASSIFIED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"road\", HIGHWAY, PL_HW_UNCLASSIFIED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"residential\", HIGHWAY, PL_HW_RESIDENTIAL, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"living_street\", HIGHWAY, PL_HW_LIVING_STREET, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"service\", HIGHWAY, PL_HW_SERVICE, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"track\", HIGHWAY, PL_HW_TRACK, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"pedestrian\", HIGHWAY, PL_HW_PEDESTRIAN, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n//\t\tregister(\"highway\", \"raceway\", HIGHWAY, PL_HW_RACEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"services\", HIGHWAY, PL_HW_SERVICES, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n//\t\tregister(\"highway\", \"bus_guideway\", HIGHWAY, PL_HW_MOTORWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"path\", HIGHWAY, PL_HW_PATH, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"cycleway\", HIGHWAY, PL_HW_CYCLEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"footway\", HIGHWAY, PL_HW_FOOTWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"bridleway\", HIGHWAY, PL_HW_BRIDLEWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"byway\", HIGHWAY, PL_HW_BYWAY, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"steps\", HIGHWAY, PL_HW_STEPS, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"ford\", HIGHWAY, PL_HW_FORD, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"construction\", HIGHWAY, PL_HW_CONSTRUCTION, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"proposed\", HIGHWAY, PL_HW_PROPOSED, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"highway\", \"mini_roundabout\", HIGHWAY, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"stop\", HIGHWAY, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"give_way\", HIGHWAY, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"traffic_signals\", HIGHWAY, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"motorway_junction\", HIGHWAY, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"bus_stop\", HIGHWAY, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"platform\", HIGHWAY, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"turning_circle\", HIGHWAY, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"emergency_access_point\", HIGHWAY, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"speed_camera\", HIGHWAY, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"highway\", \"street_lamp\", HIGHWAY, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"traffic_calming\", \"yes\", HIGHWAY, 50, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"bump\", HIGHWAY, 51, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"chicane\", HIGHWAY, 52, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"cushion\", HIGHWAY, 53, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"hump\", HIGHWAY, 54, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"rumble_strip\", HIGHWAY, 55, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"table\", HIGHWAY, 56, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", \"choker\", HIGHWAY, 57, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"traffic_calming\", null, HIGHWAY, 58, POINT_TYPE); //$NON-NLS-1$\r\n\t\t\r\n\t// 2. barrier\t\r\n\t\tregister(\"barrier\", \"hedge\", BARRIER, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"fence\", BARRIER, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"wall\", BARRIER, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"ditch\", BARRIER, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"retaining_wall\", BARRIER, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"city_wall\", BARRIER, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"bollard\", BARRIER, 6, POLYLINE_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"cycle_barrier\", BARRIER, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"block\", BARRIER, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"cattle_grid\", BARRIER, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"toll_booth\", BARRIER, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"entrance\", BARRIER, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"gate\", BARRIER, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"lift_gate\", BARRIER, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"stile\", BARRIER, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"horse_stile\", BARRIER, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"kissing_gate\", BARRIER, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"sally_port\", BARRIER, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"turnstile\", BARRIER, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"barrier\", \"kent_carriage_gap\", BARRIER, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t// 3. waterway\t\r\n\t\tregister(\"waterway\", \"stream\", WATERWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\t\t\r\n\t\tregister(\"waterway\", \"river\", WATERWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"riverbank\", WATERWAY, 3, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"canal\", WATERWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"ditch\", WATERWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"drain\", WATERWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"dock\", WATERWAY, 7, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"lock_gate\", WATERWAY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"turning_point\", WATERWAY, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"boatyard\", WATERWAY, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"weir\", WATERWAY, 11, POLYLINE_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"waterway\", \"dam\", WATERWAY, 12, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 4. railway\t\r\n\t\tregister(\"railway\", \"rail\", RAILWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"tram\", RAILWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"light_rail\", RAILWAY, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"abandoned\", RAILWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"disused\", RAILWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"subway\", RAILWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"preserved\", RAILWAY, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"narrow_gauge\", RAILWAY, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"construction\", RAILWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"monorail\", RAILWAY, 10, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"funicular\", RAILWAY, 11, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"railway\", \"platform\", RAILWAY, 12, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"station\", RAILWAY, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"turntable\", RAILWAY, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"railway\", \"halt\", RAILWAY, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"tram_stop\", RAILWAY, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"crossing\", RAILWAY, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"level_crossing\", RAILWAY, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"subway_entrance\", RAILWAY, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"railway\", \"buffer_stop\", RAILWAY, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\r\n\t// 5. aeroway\r\n\t\tregister(\"aeroway\", \"aerodrome\", AEROWAY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"terminal\", AEROWAY, 2, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"helipad\", AEROWAY, 3, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"runway\", AEROWAY, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"taxiway\", AEROWAY, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"apron\", AEROWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"gate\", AEROWAY, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aeroway\", \"windsock\", AEROWAY, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 6. aerialway\r\n\t\tregister(\"aerialway\", \"cable_car\", AERIALWAY, 1, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"gondola\", AERIALWAY, 2, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"chair_lift\", AERIALWAY, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"mixed_lift\", AERIALWAY, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"drag_lift\", AERIALWAY, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"gondola\", AERIALWAY, 6, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"aerialway\", \"station\", AERIALWAY, 7); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"aerialway\", \"pylon\", AERIALWAY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"aerialway\", \"goods\", AERIALWAY, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t// 7. power\r\n\t\tregister(\"power\", \"tower\", POWER, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"pole\", POWER, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"line\", POWER, 3, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"minor_line\", POWER, 4, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"station\", POWER, 5, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"sub_station\", POWER, 6, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"generator\", POWER, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"power\", \"cable_distribution_cabinet\", POWER, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t// 8. man_made\r\n\t\tregister(\"building\", \"yes\", MAN_MADE, SUBTYPE_BUILDING, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"building\", null, MAN_MADE, SUBTYPE_BUILDING, POLYGON_TYPE); //$NON-NLS-1$ \r\n\t\tregister(\"man_made\", \"wastewater_plant\", MAN_MADE, 2, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"man_made\", \"water_works\", MAN_MADE, 3); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"man_made\", \"works\", MAN_MADE, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"building\", \"garages\", MAN_MADE, SUBTYPE_GARAGES, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t\r\n\t\tregister(\"man_made\", \"cutline\", MAN_MADE, 7, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"groyne\", MAN_MADE, 8, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"pier\", MAN_MADE, 9, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"pipeline\", MAN_MADE, 10, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"reservoir_covered\", MAN_MADE, 11, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"man_made\", \"beacon\", MAN_MADE, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"crane\", MAN_MADE, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"lighthouse\", MAN_MADE, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"mineshaft\", MAN_MADE, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"adit\", MAN_MADE, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"petroleum_well\", MAN_MADE, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"surveillance\", MAN_MADE, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"survey_point\", MAN_MADE, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"tower\", MAN_MADE, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"watermill\", MAN_MADE, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"water_tower\", MAN_MADE, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"water_well\", MAN_MADE, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"man_made\", \"windmill\", MAN_MADE, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 9. leisure\r\n\t\tregister(\"leisure\", \"dog_park\", LEISURE, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"sports_centre\", LEISURE, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"golf_course\", LEISURE, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"stadium\", LEISURE, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterRules(\"leisure\", \"track\", LEISURE, 5, POINT_TYPE, POLYLINE_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"pitch\", LEISURE, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"water_park\", LEISURE, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"marina\", LEISURE, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"slipway\", LEISURE, 9, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"fishing\", LEISURE, 10, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"nature_reserve\", LEISURE, 11, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"park\", LEISURE, 12, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"playground\", LEISURE, 13, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"garden\", LEISURE, 14, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"common\", LEISURE, 15, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"ice_rink\", LEISURE, 16, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"miniature_golf\", LEISURE, 17, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"leisure\", \"dance\", LEISURE, 18, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 10. office\r\n\t\tregister(\"office\", \"accountant\", OFFICE, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"architect\", OFFICE, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"company\", OFFICE, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"employment_agency\", OFFICE, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"estate_agent\", OFFICE, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"government\", OFFICE, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"insurance\", OFFICE, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"it\", OFFICE, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"lawyer\", OFFICE, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"ngo\", OFFICE, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"quango\", OFFICE, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"research\", OFFICE, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"telecommunication\", OFFICE, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"office\", \"travel_agent\", OFFICE, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t// changed\r\n\t\tregister(\"amenity\", \"architect_office\", OFFICE, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 11. shop\r\n\t\t// reserve numbers from 1-10\r\n\t\tregister(\"shop\", \"alcohol\", SHOP, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"bakery\", SHOP, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"beauty\", SHOP, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"beverages\", SHOP, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"bicycle\", SHOP, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"books\", SHOP, 46, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"boutique\", SHOP, 47, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"butcher\", SHOP, 48, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"car\", SHOP, 49, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"car_repair\", SHOP, 50, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"charity\", SHOP, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"chemist\", SHOP, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"clothes\", SHOP, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"computer\", SHOP, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"confectionery\", SHOP, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"convenience\", SHOP, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"department_store\", SHOP, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"dry_cleaning\", SHOP, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"doityourself\", SHOP, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"electronics\", SHOP, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"fabrics\", SHOP, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"farm\", SHOP, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"florist\", SHOP, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"funeral_directors\", SHOP, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"furniture\", SHOP, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"garden_centre\", SHOP, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"general\", SHOP, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"gift\", SHOP, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"glaziery\", SHOP, 29, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"greengrocer\", SHOP, 30, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hairdresser\", SHOP, 31, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hardware\", SHOP, 32, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hearing_aids\", SHOP, 33, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hifi\", SHOP, 34, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"ice_cream\", SHOP, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hardware\", SHOP, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hearing_aids\", SHOP, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"hifi\", SHOP, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"ice_cream\", SHOP, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"jewelry\", SHOP, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"kiosk\", SHOP, 51, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"laundry\", SHOP, 52, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"mall\", SHOP, 53, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"massage\", SHOP, 54, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"money_lender\", SHOP, 55, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"motorcycle\", SHOP, 56, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"newsagent\", SHOP, 57, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"optician\", SHOP, 58, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"organic\", SHOP, 59, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"outdoor\", SHOP, 60, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"pawnbroker\", SHOP, 61, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"second_hand\", SHOP, 62, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"sports\", SHOP, 63, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"stationery\", SHOP, 64, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"supermarket\", SHOP, 65, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"shoes\", SHOP, 66, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"tattoo\", SHOP, 67, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"toys\", SHOP, 68, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"travel_agency\", SHOP, 69, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"variety_store\", SHOP, 70, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"shop\", \"video\", SHOP, 71, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\t\r\n\t// 12. emergency\r\n\t\tregisterAsBuilding(\"emergency\", \"ambulance_station\", EMERGENCY, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"emergency\", \"ses_station\", EMERGENCY, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"emergency\", \"fire_extinguisher\", EMERGENCY, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_flapper\", EMERGENCY, 4,POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_hose\", EMERGENCY, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"fire_hydrant\", EMERGENCY, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"phone\", EMERGENCY, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"ses_station\", EMERGENCY, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"emergency\", \"siren\", EMERGENCY, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\t// change category\r\n\t\tregister(\"amenity\", \"fire_station\", EMERGENCY, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 13. tourism\r\n\t\tregister(\"tourism\", \"attraction\", TOURISM, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"artwork\", TOURISM, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"camp_site\", TOURISM, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"caravan_site\", TOURISM, 5, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"picnic_site\", TOURISM, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"theme_park\", TOURISM, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"zoo\", TOURISM, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"tourism\", \"alpine_hut\",  TOURISM, 9); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"chalet\", TOURISM, 10); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"guest_house\", TOURISM, 11); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"hostel\", TOURISM, 12); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"hotel\", TOURISM, 13); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"motel\", TOURISM, 14); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"tourism\", \"museum\", TOURISM, 15); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"tourism\", \"information\", TOURISM, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", \"viewpoint\", TOURISM, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"tourism\", null, TOURISM, 18, POINT_TYPE); //$NON-NLS-1$ \r\n\t\r\n\t// 14. historic\r\n\t\tregister(\"historic\", \"archaeological_site\", HISTORIC, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"battlefield\", HISTORIC, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"castle\", HISTORIC, 4, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"fort\", HISTORIC, 5, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"ruins\", HISTORIC, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"historic\", \"monument\", HISTORIC, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"historic\", \"boundary_stone\", HISTORIC, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"memorial\", HISTORIC, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wayside_cross\", HISTORIC, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wayside_shrine\", HISTORIC, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", \"wreck\", HISTORIC, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"historic\", null, HISTORIC, 12, POINT_TYPE); //$NON-NLS-1$ \r\n\t\r\n\t// 15. landuse\r\n\t\tregister(\"landuse\", \"allotments\", LANDUSE, 1, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"basin\", LANDUSE, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"brownfield\", LANDUSE, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"cemetery\", LANDUSE, 4, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"commercial\", LANDUSE, 5, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"construction\", LANDUSE, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farm\", LANDUSE, 7, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farmland\", LANDUSE, 8, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"farmyard\", LANDUSE, 9, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"forest\", LANDUSE, 10, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"garages\", LANDUSE, 11, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"grass\", LANDUSE, 12, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"greenfield\", LANDUSE, 13, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"greenhouse_horticulture\", LANDUSE, 14, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"industrial\", LANDUSE, 15, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"landfill\", LANDUSE, 16, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"meadow\", LANDUSE, 17, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"military\", LANDUSE, 18, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"landuse\", \"orchard\", LANDUSE, 19, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"railway\", LANDUSE, 20, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$]\r\n\t\tregister(\"landuse\", \"recreation_ground\", LANDUSE, 21, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"reservoir\", LANDUSE, 22, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"residential\", LANDUSE, 23, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"retail\", LANDUSE, 24, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"salt_pond\", LANDUSE, 25, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"village_green\", LANDUSE, 26, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"landuse\", \"vineyard\", LANDUSE, 27, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 16. military\r\n\t\tregister(\"military\", \"airfield\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"bunker\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"barracks\", MILITARY, 1, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"danger_area\", MILITARY, 1, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"range\", MILITARY, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"military\", \"naval_base\", MILITARY, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t\r\n\t// 17. natural\t\r\n\t\tregister(\"natural\", \"coastline\", NATURAL, 5, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregister(\"natural\", \"bay\", NATURAL, 1, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"beach\", NATURAL, 2, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"cave_entrance\", NATURAL, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterRules(\"natural\", \"cliff\", NATURAL, 4, POLYGON_TYPE, POINT_TYPE, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"fell\", NATURAL, 6, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"glacier\", NATURAL, 7, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"heath\", NATURAL, 8, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"land\", NATURAL, 9, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"heath\", NATURAL, 10, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"marsh\", NATURAL, 11, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"mud\", NATURAL, 12, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"peak\", NATURAL, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"sand\", NATURAL, 14, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"scree\", NATURAL, 15, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"scrub\", NATURAL, 16, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"spring\", NATURAL, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"stone\", NATURAL, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"tree\", NATURAL, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"volcano\", NATURAL, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"water\", NATURAL, 21, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"wetland\", NATURAL, 22, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"natural\", \"wood\", NATURAL, 23, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 18. amenity sustenance\r\n\t\tregisterAsBuilding(\"amenity\", \"restaurant\", AMENITY_SUSTENANCE, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"cafe\", AMENITY_SUSTENANCE, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"food_court\", AMENITY_SUSTENANCE, 3); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"fast_food\", AMENITY_SUSTENANCE, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"pub\", AMENITY_SUSTENANCE, 5); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"bar\", AMENITY_SUSTENANCE, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"biergarten\", AMENITY_SUSTENANCE, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"drinking_water\", AMENITY_SUSTENANCE, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bbq\", AMENITY_SUSTENANCE, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 19. amenity education\r\n\t\tregisterAsBuilding(\"amenity\", \"kindergarten\", AMENITY_EDUCATION, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"school\", AMENITY_EDUCATION, 2, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"college\", AMENITY_EDUCATION, 3, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"library\", AMENITY_EDUCATION, 4, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"university\", AMENITY_EDUCATION, 5, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t\r\n\t\r\n\t// 20. amenity transportation\r\n\t\tregister(\"amenity\", \"parking\", AMENITY_TRANSPORTATION, SUBTYPE_PARKING, //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\t\t\tPOLYGON_WITH_CENTER_TYPE, POINT_TYPE); \r\n\t\tregister(\"amenity\", \"bicycle_parking\", AMENITY_TRANSPORTATION, 2, //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\t\t\tPOLYGON_WITH_CENTER_TYPE, POINT_TYPE); \r\n\t\tregister(\"amenity\", \"ferry_terminal\", AMENITY_TRANSPORTATION, 3, POLYGON_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"fuel\", AMENITY_TRANSPORTATION, 4); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t// do not register small objects as area\r\n\t\tregister(\"amenity\", \"taxi\", AMENITY_TRANSPORTATION, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bicycle_rental\", AMENITY_TRANSPORTATION, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bus_station\", AMENITY_TRANSPORTATION, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$ \r\n\t\tregister(\"amenity\", \"car_rental\", AMENITY_TRANSPORTATION, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"car_sharing\", AMENITY_TRANSPORTATION, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"car_wash\", AMENITY_TRANSPORTATION, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"grit_bin\", AMENITY_TRANSPORTATION, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 21. amenity finance\r\n\t\tregister(\"amenity\", \"atm\", AMENITY_FINANCE, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"bank\", AMENITY_FINANCE, 2); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bureau_de_change\", AMENITY_FINANCE, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 22. amenity healthcare\r\n\t\tregisterAsBuilding(\"amenity\", \"pharmacy\", AMENITY_HEALTHCARE, 1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"hospital\", AMENITY_HEALTHCARE, 2, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"baby_hatch\", AMENITY_HEALTHCARE, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"dentist\", AMENITY_HEALTHCARE, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"doctors\", AMENITY_HEALTHCARE, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"veterinary\", AMENITY_HEALTHCARE, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"first_aid\", AMENITY_HEALTHCARE, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 23. amenity entertainment\r\n\t\t\r\n\t\tregister(\"amenity\", \"arts_centre\", AMENITY_ENTERTAINMENT, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"cinema\", AMENITY_ENTERTAINMENT, 3, POLYGON_WITH_CENTER_TYPE, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"community_centre\", AMENITY_ENTERTAINMENT, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"social_centre\", AMENITY_ENTERTAINMENT, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"amenity\", \"nightclub\", AMENITY_ENTERTAINMENT, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"stripclub\", AMENITY_ENTERTAINMENT, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"studio\", AMENITY_ENTERTAINMENT, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"theatre\", AMENITY_ENTERTAINMENT, 9); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"sauna\", AMENITY_ENTERTAINMENT, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"brothel\", AMENITY_ENTERTAINMENT, 11); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\r\n\t// 24. amenity others\r\n\t\tregister(\"amenity\", \"marketplace\", AMENITY_OTHER, 1, POINT_TYPE, POLYGON_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tregisterAsBuilding(\"amenity\", \"courthouse\", AMENITY_OTHER, 5); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"crematorium\", AMENITY_OTHER, 6); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"embassy\", AMENITY_OTHER, 7); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"grave_yard\", AMENITY_OTHER, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"hunting_stand\", AMENITY_OTHER, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"police\", AMENITY_OTHER, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"post_box\", AMENITY_OTHER, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"post_office\", AMENITY_OTHER, 12); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"prison\", AMENITY_OTHER, 13); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"public_building\", AMENITY_OTHER, 14); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"recycling\", AMENITY_OTHER, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"shelter\", AMENITY_OTHER, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"telephone\", AMENITY_OTHER, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"toilets\", AMENITY_OTHER, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregisterAsBuilding(\"amenity\", \"townhall\", AMENITY_OTHER, 19); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"vending_machine\", AMENITY_OTHER, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"waste_basket\", AMENITY_OTHER, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"waste_disposal\", AMENITY_OTHER, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"fountain\", AMENITY_OTHER, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"bench\", AMENITY_OTHER, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"amenity\", \"clock\", AMENITY_OTHER, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t// 25. administrative \r\n\t\tregister(\"place\", \"continent\", ADMINISTRATIVE, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"country\", ADMINISTRATIVE, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"state\", ADMINISTRATIVE, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"region\", ADMINISTRATIVE, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"county\", ADMINISTRATIVE, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"city\", ADMINISTRATIVE, 6, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"town\", ADMINISTRATIVE, 7, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"village\", ADMINISTRATIVE, 8, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"hamlet\", ADMINISTRATIVE, 9, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"suburb\", ADMINISTRATIVE, 10, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"locality\", ADMINISTRATIVE, 11, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"place\", \"island\", ADMINISTRATIVE, 12, POINT_TYPE, POLYGON_WITH_CENTER_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n//\t\tregister(\"boundary\", \"administrative\", ADMINISTRATIVE, 15, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t//\"boundary\", \"administrative\"\r\n\t\tregister(\"admin_level\", \"1\", ADMINISTRATIVE, 21, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"2\", ADMINISTRATIVE, 22, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"3\", ADMINISTRATIVE, 23, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"4\", ADMINISTRATIVE, 24, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"5\", ADMINISTRATIVE, 25, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"6\", ADMINISTRATIVE, 26, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"7\", ADMINISTRATIVE, 27, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"8\", ADMINISTRATIVE, 28, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"9\", ADMINISTRATIVE, 29, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"admin_level\", \"10\", ADMINISTRATIVE, 30, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\t\r\n\t\tregister(\"boundary\", \"civil\", ADMINISTRATIVE, 16, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"political\", ADMINISTRATIVE, 17, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"maritime\", ADMINISTRATIVE, 18, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"national_park\", ADMINISTRATIVE, 19, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"boundary\", \"protected_area\", ADMINISTRATIVE, 20, POLYLINE_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"addr:housenumber\", null, ADMINISTRATIVE, 33, POINT_TYPE); //$NON-NLS-1$\r\n\r\n\t\t\r\n\t\t\r\n\t// 27. sport\r\n\t\tregister(\"sport\", \"9pin\", SPORT, 1, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"10pin\", SPORT, 2, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"archery\", SPORT, 3, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"athletics\", SPORT, 4, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"australian_football\", SPORT, 5, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"baseball\", SPORT, 6, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"basketball\", SPORT, 7, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"beachvolleyball\", SPORT, 8, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"boules\", SPORT, 9, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"bowls\", SPORT, 10, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"canoe\", SPORT, 11, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"chess\", SPORT, 12, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"climbing\", SPORT, 13, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cricket\", SPORT, 14, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cricket_nets\", SPORT, 15, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"croquet\", SPORT, 16, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"cycling\", SPORT, 17, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"diving\", SPORT, 18, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"dog_racing\", SPORT, 19, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"equestrian\", SPORT, 20, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"football\", SPORT, 21, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"golf\", SPORT, 22, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"gymnastics\", SPORT, 23, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"hockey\", SPORT, 24, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"horse_racing\", SPORT, 25, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"ice_stock\", SPORT, 26, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"korfball\", SPORT, 27, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"motor\", SPORT, 28, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"multi\", SPORT, 29, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"orienteering\", SPORT, 30, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"paddle_tennis\", SPORT, 31, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"paragliding\", SPORT, 32, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"pelota\", SPORT, 33, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"racquet\", SPORT, 34, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"rowing\", SPORT, 35, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"rugby\", SPORT, 36, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"shooting\", SPORT, 37, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skating\", SPORT, 38, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skateboard\", SPORT, 39, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"skiing\", SPORT, 40, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"soccer\", SPORT, 41, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"swimming\", SPORT, 42, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"table_tennis\", SPORT, 43, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"team_handball\", SPORT, 44, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"tennis\", SPORT, 45, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"toboggan\", SPORT, 46, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tregister(\"sport\", \"volleyball\", SPORT, 47, POINT_TYPE); //$NON-NLS-1$ //$NON-NLS-2$\t\t\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public OsmandRenderer(Context context){\r\n\t\tthis.context = context;\r\n\t\tpaintStroke = new Paint();\r\n\t\tpaintStroke.setStyle(Style.STROKE);\r\n\t\tpaintStroke.setStrokeWidth(2);\r\n\t\tpaintStroke.setColor(Color.BLACK);\r\n\t\tpaintStroke.setStrokeJoin(Join.ROUND);\r\n\t\tpaintStroke.setAntiAlias(true);\r\n\t\t\r\n\t\t\r\n\t\tpaintText = new Paint();\r\n\t\tpaintText.setStyle(Style.STROKE);\r\n\t\tpaintText.setColor(Color.BLACK);\r\n\t\tpaintText.setTextAlign(Align.CENTER);\r\n\t\tpaintText.setAntiAlias(true);\r\n\t\t\r\n\t\tpaintFill = new Paint();\r\n\t\tpaintFill.setStyle(Style.FILL_AND_STROKE);\r\n\t\tpaintFill.setStrokeWidth(2);\r\n\t\tpaintFill.setColor(Color.LTGRAY);\r\n\t\tpaintFill.setAntiAlias(true);\r\n\t\t\r\n\t\tpaintFillWhite = new Paint();\r\n\t\tpaintFillWhite.setStyle(Style.FILL);\r\n\t\tpaintFillWhite.setColor(clFillScreen);\r\n\t\t\r\n\t}","id":40883,"modified_method":"public OsmandRenderer(Context context){\r\n\t\tthis.context = context;\r\n\t\tpaintStroke = new Paint();\r\n\t\tpaintStroke.setStyle(Style.STROKE);\r\n\t\tpaintStroke.setStrokeWidth(2);\r\n\t\tpaintStroke.setColor(Color.BLACK);\r\n\t\tpaintStroke.setStrokeJoin(Join.ROUND);\r\n\t\tpaintStroke.setAntiAlias(true);\r\n\t\t\r\n\t\tpaintIcon = new Paint();\r\n\t\tpaintIcon.setStyle(Style.STROKE);\r\n\t\t\r\n\t\tpaintText = new TextPaint();\r\n\t\tpaintText.setStyle(Style.FILL);\r\n\t\tpaintText.setColor(Color.BLACK);\r\n\t\tpaintText.setTextAlign(Align.CENTER);\r\n\t\tpaintText.setAntiAlias(true);\r\n\t\t\r\n\t\tpaintFill = new Paint();\r\n\t\tpaintFill.setStyle(Style.FILL_AND_STROKE);\r\n\t\tpaintFill.setStrokeWidth(2);\r\n\t\tpaintFill.setColor(Color.LTGRAY);\r\n\t\tpaintFill.setAntiAlias(true);\r\n\t\t\r\n\t\tpaintFillEmpty = new Paint();\r\n\t\tpaintFillEmpty.setStyle(Style.FILL);\r\n\t\tpaintFillEmpty.setColor(clFillScreen);\r\n\t\t\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Bitmap generateNewBitmap(RectF objectLoc, List<MapRenderObject> objects, int zoom, float rotate) {\r\n\t\tlong now = System.currentTimeMillis();\r\n\t\tCollections.sort(objects, this);\r\n\t\tBitmap bmp = null; \r\n\t\tif (objects != null && !objects.isEmpty() && objectLoc.width() != 0f && objectLoc.height() != 0f) {\r\n\t\t\tdouble leftX = MapUtils.getTileNumberX(zoom, objectLoc.left);\r\n\t\t\tdouble rightX = MapUtils.getTileNumberX(zoom, objectLoc.right);\r\n\t\t\tdouble topY = MapUtils.getTileNumberY(zoom, objectLoc.top);\r\n\t\t\tdouble bottomY = MapUtils.getTileNumberY(zoom, objectLoc.bottom);\r\n\t\t\tbmp = Bitmap.createBitmap((int) ((rightX - leftX) * 256), (int) ((bottomY - topY) * 256), Config.RGB_565);\r\n\t\t\tCanvas cv = new Canvas(bmp);\r\n\t\t\tcv.drawRect(0, 0, bmp.getWidth(), bmp.getHeight(), paintFillWhite);\r\n\t\t\tcv.rotate(-rotate);\r\n\t\t\tfor (MapRenderObject w : objects) {\r\n\t\t\t\tdraw(w, cv, leftX, topY, zoom, rotate);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlog.info(String.format(\"Rendering has been done in %s ms. \", System.currentTimeMillis() - now)); //$NON-NLS-1$\r\n\t\treturn bmp;\r\n\t}","id":40884,"modified_method":"public Bitmap generateNewBitmap(RectF objectLoc, List<MapRenderObject> objects, int zoom, float rotate) {\r\n\t\tlong now = System.currentTimeMillis();\r\n\t\tCollections.sort(objects, this);\r\n\t\tBitmap bmp = null; \r\n\t\tif (objects != null && !objects.isEmpty() && objectLoc.width() != 0f && objectLoc.height() != 0f) {\r\n\t\t\tList<TextDrawInfo> textToDraw = new ArrayList<TextDrawInfo>();\r\n\t\t\tList<IconDrawInfo> iconsToDraw = new ArrayList<IconDrawInfo>();\r\n\t\t\tdouble leftX = MapUtils.getTileNumberX(zoom, objectLoc.left);\r\n\t\t\tdouble rightX = MapUtils.getTileNumberX(zoom, objectLoc.right);\r\n\t\t\tdouble topY = MapUtils.getTileNumberY(zoom, objectLoc.top);\r\n\t\t\tdouble bottomY = MapUtils.getTileNumberY(zoom, objectLoc.bottom);\r\n\t\t\tbmp = Bitmap.createBitmap((int) ((rightX - leftX) * 256), (int) ((bottomY - topY) * 256), Config.RGB_565);\r\n\t\t\tCanvas cv = new Canvas(bmp);\r\n\t\t\tcv.drawRect(0, 0, bmp.getWidth(), bmp.getHeight(), paintFillEmpty);\r\n\t\t\tcv.rotate(-rotate);\r\n\t\t\tfor (MapRenderObject w : objects) {\r\n\t\t\t\tdraw(w, cv, leftX, topY, zoom, rotate, textToDraw, iconsToDraw);\r\n\t\t\t}\r\n\t\t\tfor(IconDrawInfo icon : iconsToDraw){\r\n\t\t\t\tif(icon.resId != 0){\r\n\t\t\t\t\tBitmap ico = BitmapFactory.decodeResource(context.getResources(), icon.resId);\r\n\t\t\t\t\tif (ico  != null) {\r\n\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - bmp.getWidth() / 2, icon.y - bmp.getHeight() / 2, paintIcon);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(TextDrawInfo text : textToDraw){\r\n\t\t\t\tif(text.text != null){\r\n\t\t\t\t\tpaintText.setTextSize(text.textSize);\r\n\t\t\t\t\tpaintText.setColor(text.textColor);\r\n\t\t\t\t\tif(text.drawOnPath != null){\r\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcv.drawText(text.text, text.centerX, text.centerY, paintText);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlog.info(String.format(\"Rendering has been done in %s ms. \", System.currentTimeMillis() - now)); //$NON-NLS-1$\r\n\t\treturn bmp;\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void draw(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate) {\r\n\t\tif(obj.isPoint()){\r\n\t\t\tdrawPoint(obj, canvas, leftTileX, topTileY, zoom, rotate);\r\n\t\t} else if(obj.isPolyLine()){\r\n\t\t\tdrawPolyline(obj, canvas, leftTileX, topTileY, zoom, rotate);\r\n\t\t} else {\r\n\t\t\tPointF center = drawPolygon(obj, canvas, leftTileX, topTileY, zoom, rotate);\r\n\t\t\tif(center != null){\r\n\t\t\t\tint typeT = MapRenderingTypes.getPolygonPointType(obj.getType());\r\n\t\t\t\tint subT = MapRenderingTypes.getPolygonPointSubType(obj.getType());\r\n\t\t\t\tif(typeT > 0 && subT > 0){\r\n\t\t\t\t\tdrawPointBitmap(canvas, center.x, center.y, typeT, subT, zoom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":40885,"modified_method":"protected void draw(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate, \r\n\t\t\tList<TextDrawInfo> textToDraw, List<IconDrawInfo> iconsToDraw) {\r\n\t\tif(obj.isPoint()){\r\n\t\t\tdrawPoint(obj, canvas, leftTileX, topTileY, zoom, rotate, textToDraw, iconsToDraw);\r\n\t\t} else if(obj.isPolyLine()){\r\n\t\t\tdrawPolyline(obj, canvas, leftTileX, topTileY, zoom, rotate, textToDraw, iconsToDraw);\r\n\t\t} else {\r\n\t\t\tPointF center = drawPolygon(obj, canvas, leftTileX, topTileY, zoom, rotate, textToDraw, iconsToDraw);\r\n\t\t\tif(center != null){\r\n\t\t\t\tint typeT = MapRenderingTypes.getPolygonPointType(obj.getType());\r\n\t\t\t\tint subT = MapRenderingTypes.getPolygonPointSubType(obj.getType());\r\n\t\t\t\tif(typeT != 0 && subT != 0){\r\n\t\t\t\t\tint resId = PointRenderer.getPointBitmap(zoom, typeT, subT);\r\n\t\t\t\t\tif(resId != 0){\r\n\t\t\t\t\t\tIconDrawInfo ico = new IconDrawInfo();\r\n\t\t\t\t\t\tico.x = center.x;\r\n\t\t\t\t\t\tico.y = center.y;\r\n\t\t\t\t\t\tico.resId = resId;\r\n\t\t\t\t\t\ticonsToDraw.add(ico);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawPoint(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate){\r\n\t\tif (zoom > 15) {\r\n\t\t\tfloat lon = obj.getPointLongitude(0);\r\n\t\t\tfloat lat = obj.getPointLatitude(0);\r\n\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\tint subType = MapRenderingTypes.getPointSubType(obj.getType());\r\n\t\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\t\tdrawPointBitmap(canvas, p.x, p.y, type, subType, zoom);\r\n\t\t}\r\n\t}","id":40886,"modified_method":"private void drawPoint(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate, \r\n\t\t\tList<TextDrawInfo> textToDraw, List<IconDrawInfo> iconsToDraw) {\r\n\t\tfloat lon = obj.getPointLongitude(0);\r\n\t\tfloat lat = obj.getPointLatitude(0);\r\n\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\tint subType = MapRenderingTypes.getPointSubType(obj.getType());\r\n\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\tint resId = PointRenderer.getPointBitmap(zoom, type, subType);\r\n\t\tif(resId != 0){\r\n\t\t\tIconDrawInfo ico = new IconDrawInfo();\r\n\t\t\tico.x = p.x;\r\n\t\t\tico.y = p.y;\r\n\t\t\tico.resId = resId;\r\n\t\t\ticonsToDraw.add(ico);\r\n\t\t}\r\n\t\t\r\n\t\tint textSize = 0;\r\n\t\tint textColor = 0;\r\n\t\t@SuppressWarnings(\"unused\")\r\n\t\tint textWrap = 0;\r\n\t\t@SuppressWarnings(\"unused\")\r\n\t\tint shadowRadius = 0;\r\n\t\t@SuppressWarnings(\"unused\")\r\n\t\tint shadowColor = Color.WHITE;\r\n\t\tif(type == MapRenderingTypes.ADMINISTRATIVE){\r\n\t\t\tshadowRadius = 4;\r\n\t\t\tif(subType == 9 || subType == 11){\r\n\t\t\t\tif(zoom >= 14 && zoom < 16){\r\n\t\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\t\ttextSize = 8;\r\n\t\t\t\t} else if(zoom >= 16){\r\n\t\t\t\t\ttextColor = 0xFF777777;\r\n\t\t\t\t\ttextSize = 11;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 8){\r\n\t\t\t\tif(zoom >= 12 && zoom < 15){\r\n\t\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\t\ttextSize = 9;\r\n\t\t\t\t} else if(zoom >= 15){\r\n\t\t\t\t\ttextColor = 0xFF777777;\r\n\t\t\t\t\ttextSize = 12;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 10){\r\n\t\t\t\tif(zoom >= 12 && zoom < 14){\r\n\t\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\t\ttextSize = 10;\r\n\t\t\t\t} else if(zoom >= 14){\r\n\t\t\t\t\ttextColor = 0xFF777777;\r\n\t\t\t\t\ttextSize = 13;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 7){\r\n\t\t\t\ttextWrap = 20;\r\n\t\t\t\tif(zoom >= 9 && zoom < 11){\r\n\t\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\t\ttextSize = 8;\r\n\t\t\t\t} else if(zoom >= 13 && zoom < 14){\r\n\t\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\t\ttextSize = 10;\r\n\t\t\t\t} else if(zoom >= 14){\r\n\t\t\t\t\ttextColor = 0xFF777777;\r\n\t\t\t\t\ttextSize = 13;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 6){\r\n\t\t\t\ttextWrap = 20;\r\n\t\t\t\ttextColor = 0xFF000000;\r\n\t\t\t\tif(zoom >= 6 && zoom < 9){\r\n\t\t\t\t\ttextSize = 8;\r\n\t\t\t\t} else if(zoom >= 9 && zoom < 11){\r\n\t\t\t\t\ttextSize = 11;\r\n\t\t\t\t} else if(zoom >= 11 && zoom <= 14){\r\n\t\t\t\t\ttextSize = 14;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 42){\r\n\t\t\t\ttextWrap = 20;\r\n\t\t\t\ttextColor = 0xff9d6c9d;\r\n\t\t\t\tif(zoom >= 2 && zoom < 4){\r\n\t\t\t\t\ttextSize = 8;\r\n\t\t\t\t} else if(zoom >= 4 && zoom < 7){\r\n\t\t\t\t\ttextSize = 10;\r\n\t\t\t\t}\r\n\t\t\t} else \tif(subType == 43 || subType == 44){\r\n\t\t\t\ttextWrap = 20;\r\n\t\t\t\ttextColor = 0xff9d6c9d;\r\n\t\t\t\tif(zoom >= 4 && zoom < 8){\r\n\t\t\t\t\ttextSize = 9;\r\n\t\t\t\t} else if(zoom >= 7 && zoom < 9){\r\n\t\t\t\t\ttextSize = 11;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttextSize += 4; // for small screen\r\n\t\t}\r\n\t\tif(obj.getName() != null && textSize > 0){\r\n\t\t\tpaintText.setTextSize(textSize);\r\n\t\t\tpaintText.setColor(textColor);\r\n\t\t\tcanvas.drawText(obj.getName(), p.x, p.y - textSize, paintText);\r\n\t\t\t\r\n\t\t}\r\n\t\t\t\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private PointF drawPolygon(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate) {\r\n\t\tPaint paint = paintFill;\r\n\t\tfloat xText = 0;\r\n\t\tfloat yText = 0;\r\n\t\tPath path = null;\r\n\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\tint subtype = MapRenderingTypes.getPolygonSubType(obj.getType());\r\n\t\tint color = Color.WHITE;\r\n\t\tint colorAround = 0;\r\n\t\tShader shader = null;\r\n\t\tif (type == MapRenderingTypes.MAN_MADE) {\r\n\t\t\tif (subtype == MapRenderingTypes.SUBTYPE_BUILDING) {\r\n\t\t\t\tcolor = Color.rgb(188, 169, 169);\r\n\t\t\t} else if (subtype == MapRenderingTypes.SUBTYPE_GARAGES) {\r\n\t\t\t\tcolor = Color.rgb(221, 221, 221);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.WATERWAY) {\r\n\t\t\tif(subtype == 3){\r\n\t\t\t\tcolor = Color.rgb(181, 208, 208);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.HIGHWAY) {\r\n\t\t\tif (subtype == MapRenderingTypes.PL_HW_SERVICE || subtype == MapRenderingTypes.PL_HW_UNCLASSIFIED\r\n\t\t\t\t|| subtype == MapRenderingTypes.PL_HW_RESIDENTIAL) {\r\n\t\t\t\tcolorAround = Color.rgb(194, 194, 194);\r\n\t\t\t\tcolor = clRoadColor;\r\n\t\t\t} else if(subtype == MapRenderingTypes.PL_HW_PEDESTRIAN || subtype == MapRenderingTypes.PL_HW_FOOTWAY){\r\n\t\t\t\tcolor = Color.rgb(236, 236, 236);\r\n\t\t\t\tcolorAround = Color.rgb(176, 176, 176);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.TOURISM) {\r\n\t\t\tif (subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(204, 153, 153);\r\n\t\t\t} else if(subtype == 8){\r\n\t\t\t\tshader = getShader(R.drawable.h_zoo);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.NATURAL) {\r\n\t\t\tif(subtype == 23){\r\n\t\t\t\tcolor = Color.rgb(114, 191, 129);\r\n\t\t\t} else if(subtype == 2){\r\n\t\t\t\tcolor = Color.rgb(238, 204, 85);\r\n\t\t\t} else if(subtype == 21 || subtype == 5){\r\n\t\t\t\tcolor = Color.rgb(181, 214, 241);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.LANDUSE) {\r\n\t\t\tswitch (subtype) {\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor = Color.rgb(189, 227, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\tcase 22:\r\n\t\t\t\tcolor = Color.rgb(180, 213, 240);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcolor = Color.rgb(235, 215, 254);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tshader = getShader(R.drawable.h_grave_yard);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = Color.rgb(239, 200, 200);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tcolor = Color.rgb(157, 157, 108);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 10:\r\n\t\t\t\tshader = getShader(R.drawable.h_forest);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 12:\r\n\t\t\t\tcolor = Color.rgb(207, 236, 168);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 15:\r\n\t\t\t\tcolor = Color.rgb(223, 209, 214);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 23:\r\n\t\t\t\tcolor = Color.rgb(221, 221, 221);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 24:\r\n\t\t\t\tcolor = Color.rgb(254, 234, 234);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 27:\r\n\t\t\t\tshader = getShader(R.drawable.h_vineyard);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.LEISURE) {\r\n\t\t\tcolorAround = Color.rgb(147, 207, 170);\r\n\t\t\tswitch (subtype) {\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor = Color.rgb(189, 227, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\tcase 14:\r\n\t\t\tcase 15:\r\n\t\t\t\tcolor = Color.rgb(199, 241, 163);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tcolor = Color.rgb(137, 210, 174);\r\n\t\t\tcase 4:\r\n\t\t\t\tcolor = Color.rgb(51, 204, 153);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = Color.rgb(189, 207, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 12:\r\n\t\t\t\tcolor = Color.rgb(206, 246, 202);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 13:\r\n\t\t\t\tcolor = Color.rgb(204, 255, 241);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 11:\r\n\t\t\t\tshader = getShader(R.drawable.h_nr);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_HEALTHCARE) {\r\n\t\t\tif (subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(240, 240, 216);\r\n\t\t\t\tcolorAround = Color.rgb(212, 168, 158);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_TRANSPORTATION) {\r\n\t\t\tif (subtype == 1 || subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(246, 238, 183);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_ENTERTAINMENT) {\r\n\t\t\tif (subtype == 3) {\r\n\t\t\t\tcolor = Color.rgb(204, 153, 153);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_EDUCATION) {\r\n\t\t\tif(subtype == 2 || subtype == 3 || subtype == 5){\r\n\t\t\t\tcolor = Color.rgb(240, 240, 216);\r\n\t\t\t\tcolorAround = Color.rgb(212, 168, 158);\r\n\t\t\t} else {\r\n\t\t\t\t// draw as building education\r\n\t\t\t\tcolor = Color.rgb(188, 169, 169);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\tpaint.setColor(color);\r\n\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\r\n\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\txText += p.x;\r\n\t\t\tyText += p.y;\r\n\t\t\tif (path == null) {\r\n\t\t\t\tpath = new Path();\r\n\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t} else {\r\n\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (path != null) {\r\n\t\t\txText /= obj.getPointsLength();\r\n\t\t\tyText /= obj.getPointsLength();\r\n\t\t\tpaint.setShader(shader);\r\n\t\t\tcanvas.drawPath(path, paint);\r\n\t\t\tif(colorAround != 0){\r\n\t\t\t\tpaintStroke.setColor(colorAround);\r\n\t\t\t\tpaintStroke.setStrokeWidth(1);\r\n\t\t\t\tcanvas.drawPath(path, paintStroke);\r\n\t\t\t}\r\n\t\t\tString name = obj.getName();\r\n\t\t\tif(name != null){\r\n\t\t\t\t\r\n\t\t\t\tboolean accept = zoom > 17;\r\n\t\t\t\tif(zoom > 15){\r\n\t\t\t\t\taccept = name.length() < 4; \r\n\t\t\t\t} else if(zoom > 16){\r\n\t\t\t\t\taccept = name.length() < 8;\r\n\t\t\t\t}\r\n\t\t\t\tif(accept){\r\n\t\t\t\t\tcanvas.drawText(name, xText, yText, paintText);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new PointF(xText, yText);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":40887,"modified_method":"private PointF drawPolygon(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate, \r\n\t\t\tList<TextDrawInfo> textToDraw, List<IconDrawInfo> iconsToDraw) {\r\n\t\tPaint paint = paintFill;\r\n\t\tfloat xText = 0;\r\n\t\tfloat yText = 0;\r\n\t\tPath path = null;\r\n\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\tint subtype = MapRenderingTypes.getPolygonSubType(obj.getType());\r\n\t\tint color = Color.rgb(245, 245, 245);\r\n\t\tint colorAround = 0;\r\n\t\tShader shader = null;\r\n\t\tboolean showPolygon = true;\r\n\t\tif (type == MapRenderingTypes.MAN_MADE) {\r\n\t\t\tshowPolygon = zoom > 15;\r\n\t\t\tif (subtype == MapRenderingTypes.SUBTYPE_BUILDING) {\r\n\t\t\t\tcolor = Color.rgb(188, 169, 169);\r\n\t\t\t} else if (subtype == MapRenderingTypes.SUBTYPE_GARAGES) {\r\n\t\t\t\tcolor = Color.rgb(221, 221, 221);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.WATERWAY) {\r\n\t\t\tif(subtype == 3){\r\n\t\t\t\tcolor = Color.rgb(181, 208, 208);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.POWER) {\r\n\t\t\tif(subtype == 5 || subtype == 6){\r\n\t\t\t\tcolor = Color.rgb(186, 186, 186);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.HIGHWAY) {\r\n\t\t\tif (subtype == MapRenderingTypes.PL_HW_SERVICE || subtype == MapRenderingTypes.PL_HW_UNCLASSIFIED\r\n\t\t\t\t|| subtype == MapRenderingTypes.PL_HW_RESIDENTIAL) {\r\n\t\t\t\tcolorAround = Color.rgb(194, 194, 194);\r\n\t\t\t\tcolor = clRoadColor;\r\n\t\t\t} else if(subtype == MapRenderingTypes.PL_HW_PEDESTRIAN || subtype == MapRenderingTypes.PL_HW_FOOTWAY){\r\n\t\t\t\tcolor = Color.rgb(236, 236, 236);\r\n\t\t\t\tcolorAround = Color.rgb(176, 176, 176);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.TOURISM) {\r\n\t\t\tshowPolygon = zoom > 15;\r\n\t\t\tif (subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(204, 153, 153);\r\n\t\t\t} else if(subtype == 8){\r\n\t\t\t\tshader = getShader(R.drawable.h_zoo);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.NATURAL) {\r\n\t\t\tif(subtype == 23){\r\n\t\t\t\tcolor = Color.rgb(174, 209, 160);\r\n\t\t\t} else if(subtype == 2){\r\n\t\t\t\tcolor = Color.rgb(238, 204, 85);\r\n\t\t\t} else if(subtype == 21 || subtype == 5){\r\n\t\t\t\tcolor = Color.rgb(181, 208, 208);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (type == MapRenderingTypes.LANDUSE) {\r\n\t\t\tswitch (subtype) {\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor = Color.rgb(189, 227, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\tcase 22:\r\n\t\t\t\tcolor = Color.rgb(180, 213, 240);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcolor = Color.rgb(235, 215, 254);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tshader = getShader(R.drawable.h_grave_yard);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = Color.rgb(239, 200, 200);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tcolor = Color.rgb(157, 157, 108);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 10:\r\n\t\t\t\tshader = getShader(R.drawable.h_forest);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 11 :\r\n\t\t\t\tcolor = Color.rgb(223, 209, 214);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 12:\r\n\t\t\t\tcolor = Color.rgb(207, 236, 168);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 15:\r\n\t\t\t\tcolor = Color.rgb(223, 209, 214);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 18:\r\n\t\t\t\tcolor = Color.rgb(252, 216, 219);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 23:\r\n\t\t\t\tcolor = Color.rgb(221, 221, 221);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 24:\r\n\t\t\t\tcolor = Color.rgb(254, 234, 234);\r\n\t\t\t\tcolorAround = Color.rgb(245, 154, 152);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 27:\r\n\t\t\t\tshader = getShader(R.drawable.h_vineyard);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.LEISURE) {\r\n\t\t\tcolorAround = Color.rgb(147, 207, 170);\r\n\t\t\tswitch (subtype) {\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor = Color.rgb(189, 227, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\tcase 14:\r\n\t\t\tcase 15:\r\n\t\t\t\tcolor = Color.rgb(199, 241, 163);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tcolor = Color.rgb(137, 210, 174);\r\n\t\t\tcase 4:\r\n\t\t\t\tcolor = Color.rgb(51, 204, 153);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = Color.rgb(189, 207, 203);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 12:\r\n\t\t\t\tcolor = Color.rgb(206, 246, 202);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 13:\r\n\t\t\t\tcolor = Color.rgb(204, 255, 241);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 11:\r\n\t\t\t\tshader = getShader(R.drawable.h_nr);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_HEALTHCARE) {\r\n\t\t\tif (subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(240, 240, 216);\r\n\t\t\t\tcolorAround = Color.rgb(212, 168, 158);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_TRANSPORTATION) {\r\n\t\t\tif (subtype == 1 || subtype == 2) {\r\n\t\t\t\tcolor = Color.rgb(246, 238, 183);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_ENTERTAINMENT) {\r\n\t\t\tif (subtype == 3) {\r\n\t\t\t\tcolor = Color.rgb(204, 153, 153);\r\n\t\t\t}\r\n\t\t} else if (type == MapRenderingTypes.AMENITY_EDUCATION) {\r\n\t\t\tif(subtype == 2 || subtype == 3 || subtype == 5){\r\n\t\t\t\tcolor = Color.rgb(240, 240, 216);\r\n\t\t\t\tcolorAround = Color.rgb(212, 168, 158);\r\n\t\t\t} else {\r\n\t\t\t\t// draw as building education\r\n\t\t\t\tcolor = Color.rgb(188, 169, 169);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!showPolygon){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\t\r\n\t\tpaint.setColor(color);\r\n\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\r\n\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\txText += p.x;\r\n\t\t\tyText += p.y;\r\n\t\t\tif (path == null) {\r\n\t\t\t\tpath = new Path();\r\n\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t} else {\r\n\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (path != null) {\r\n\t\t\txText /= obj.getPointsLength();\r\n\t\t\tyText /= obj.getPointsLength();\r\n\t\t\tpaint.setShader(shader);\r\n\t\t\tcanvas.drawPath(path, paint);\r\n\t\t\tif(colorAround != 0){\r\n\t\t\t\tpaintStroke.setColor(colorAround);\r\n\t\t\t\tpaintStroke.setStrokeWidth(1);\r\n\t\t\t\tcanvas.drawPath(path, paintStroke);\r\n\t\t\t}\r\n\t\t\tString name = obj.getName();\r\n\t\t\tif(name != null){\r\n\t\t\t\t\r\n\t\t\t\tboolean accept = zoom > 17;\r\n\t\t\t\tif(zoom > 15){\r\n\t\t\t\t\taccept = name.length() < 4; \r\n\t\t\t\t} else if(zoom > 16){\r\n\t\t\t\t\taccept = name.length() < 8;\r\n\t\t\t\t}\r\n\t\t\t\tif(accept){\r\n\t\t\t\t\tcanvas.drawText(name, xText, yText, paintText);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new PointF(xText, yText);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawPolyline(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate) {\r\n\t\tif(obj.getPointsLength() == 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tPath path = null;\r\n\t\tfloat pathRotate = 0;\r\n\t\tfloat xLength = 0;\r\n\t\tfloat yLength = 0;\r\n\t\t\r\n\t\t\r\n\t\tPaint paint = paintStroke;\r\n\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\tint subtype = MapRenderingTypes.getPolylineSubType(obj.getType());\r\n\t\t\r\n\t\tboolean showText = true;\r\n\t\tboolean showLine = true;\r\n\t\tpaint.setPathEffect(null);\r\n\t\tpaint.setShadowLayer(0, 0, 0, 0);\r\n\t\tpaint.setColor(Color.BLACK);\r\n\t\tpaint.setStrokeWidth(1);\r\n\t\t\r\n\t\tif (type == MapRenderingTypes.HIGHWAY) {\r\n\t\t\tint hwType = subtype;\r\n\t\t\tboolean carRoad = true;\r\n\t\t\tif (hwType == MapRenderingTypes.PL_HW_TRUNK) {\r\n\t\t\t\tpaint.setColor(clTrunkRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_MOTORWAY) {\r\n\t\t\t\tpaint.setColor(clMotorwayRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_PRIMARY) {\r\n\t\t\t\tpaint.setColor(clPrimaryRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_SECONDARY) {\r\n\t\t\t\tpaint.setColor(clSecondaryRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_TERTIARY) {\r\n\t\t\t\tpaint.setColor(clTertiaryRoad);\r\n\t\t\t\tpaint.setShadowLayer(2, 0, 0, Color.rgb(186, 186, 186));\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_SERVICE || hwType == MapRenderingTypes.PL_HW_UNCLASSIFIED\r\n\t\t\t\t\t|| hwType == MapRenderingTypes.PL_HW_RESIDENTIAL) {\r\n\t\t\t\tpaint.setShadowLayer(1, 0, 0, Color.rgb(194, 194, 194));\r\n\t\t\t\tpaint.setColor(clRoadColor);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_PEDESTRIAN) {\r\n\t\t\t\tpaint.setShadowLayer(1, 0, 0, Color.rgb(176, 176, 176));\r\n\t\t\t\tpaint.setColor(Color.rgb(236, 236, 236));\r\n\t\t\t} else {\r\n\t\t\t\tcarRoad = false;\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setPathEffect(pedestrianPathEffect);\r\n\t\t\t\tif (hwType == MapRenderingTypes.PL_HW_TRACK || hwType == MapRenderingTypes.PL_HW_PATH) {\r\n\t\t\t\t\tpaint.setColor(clTrackRoad);\r\n\t\t\t\t\tpaint.setPathEffect(trackPathEffect);\r\n\t\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_CYCLEWAY || hwType == MapRenderingTypes.PL_HW_BRIDLEWAY) {\r\n\t\t\t\t\tpaint.setColor(clCycleWayRoad);\r\n\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaint.setColor(clPedestrianRoad);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (carRoad) {\r\n\t\t\t\tif (zoom < 16) {\r\n\t\t\t\t\tpaint.setStrokeWidth(6);\r\n\t\t\t\t} else if (zoom == 16) {\r\n\t\t\t\t\tpaint.setStrokeWidth(7);\r\n\t\t\t\t} else if (zoom == 17) {\r\n\t\t\t\t\tpaint.setStrokeWidth(11);\r\n\t\t\t\t} else if (zoom >= 18) {\r\n\t\t\t\t\tpaint.setStrokeWidth(16);\r\n\t\t\t\t}\r\n\t\t\t\tif (hwType == MapRenderingTypes.PL_HW_SERVICE) {\r\n\t\t\t\t\tpaint.setStrokeWidth(paint.getStrokeWidth() - 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tshowText = carRoad || zoom > 16;\r\n\t\t} else if(type == MapRenderingTypes.BARRIER){\r\n\t\t\tshowLine = zoom > 16;\t\r\n//\t\t\tif(subtype == 2){\r\n\t\t\tpaint.setColor(Color.rgb(137, 136, 132));\r\n//\t\t\t}\r\n\t\t\tpaint.setStrokeWidth(1);\r\n\t\t} else if(type == MapRenderingTypes.RAILWAY){\r\n\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\tif(subtype == 6){\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t\tif(zoom > 16){\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t}\r\n\t\t\t\tpaint.setPathEffect(subwayPathEffect);\r\n\t\t\t} else if(subtype == 2){\r\n\t\t\t\tpaint.setColor(Color.rgb(62, 62, 62));\r\n\t\t\t} else if(subtype == 1){\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t\tif(zoom >= 16){\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t}\r\n\t\t\t\tpaint.setPathEffect(railwayPathEffect);\r\n\t\t\t} else {\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t}\r\n\t\t} else if(type == MapRenderingTypes.WATERWAY){\r\n\t\t\tif(subtype >= 1 && subtype <= 6){\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setColor(Color.rgb(181, 208, 208));\r\n\t\t\t}\r\n\t\t} \r\n\t\t\r\n\t\tif(!showLine){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tboolean inverse = false;\r\n\t\tfloat xPrev = 0;\r\n\t\tfloat yPrev = 0;\r\n\t\tint middle = obj.getPointsLength() / 2;\r\n\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\r\n\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\tif (path == null) {\r\n\t\t\t\tpath = new Path();\r\n\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t} else {\r\n\t\t\t\txLength += p.x - xPrev; // not abs\r\n\t\t\t\tyLength += p.y - yPrev; // not abs\r\n\t\t\t\tif(i == middle){\r\n\t\t\t\t\tdouble rot = - Math.atan2(p.x - xPrev, p.y - yPrev) * 180 / Math.PI;\r\n\t\t\t\t\tif (rot < 0) {\r\n\t\t\t\t\t\trot += 360;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (rot < 180) {\r\n\t\t\t\t\t\trot += 180;\r\n\t\t\t\t\t\tinverse = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpathRotate = (float) rot;\r\n\t\t\t\t}\r\n\t\t\t\tif (pathRotate == 0) {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t}\r\n\t\t\txPrev = p.x;\r\n\t\t\tyPrev = p.y;\r\n\t\t}\r\n\t\tif (path != null) {\r\n\t\t\tcanvas.drawPath(path, paint);\r\n\t\t\tif (obj.getName() != null && showText) {\r\n\t\t\t\t\r\n\t\t\t\tif (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength), Math.abs(yLength))) {\r\n\t\t\t\t\tif (inverse) {\r\n\t\t\t\t\t\tpath.rewind();\r\n\t\t\t\t\t\tboolean st = true;\r\n\t\t\t\t\t\tfor (int i = obj.getPointsLength() - 1; i >= 0; i--) {\r\n\t\t\t\t\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\t\t\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\t\t\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\t\t\t\t\tif (st) {\r\n\t\t\t\t\t\t\t\tst = false;\r\n\t\t\t\t\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcanvas.drawTextOnPath(obj.getName(), path, 0, 2, paintText);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":40888,"modified_method":"private void drawPolyline(MapRenderObject obj, Canvas canvas, double leftTileX, double topTileY, int zoom, float rotate, \r\n\t\t\tList<TextDrawInfo> textToDraw, List<IconDrawInfo> iconsToDraw) {\r\n\t\tif(obj.getPointsLength() == 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tPath path = null;\r\n\t\tfloat pathRotate = 0;\r\n\t\tfloat xLength = 0;\r\n\t\tfloat yLength = 0;\r\n\t\t\r\n\t\t\r\n\t\tPaint paint = paintStroke;\r\n\t\tint type = MapRenderingTypes.getObjectType(obj.getType());\r\n\t\tint subtype = MapRenderingTypes.getPolylineSubType(obj.getType());\r\n\t\t\r\n\t\tboolean showText = true;\r\n\t\tboolean showLine = true;\r\n\t\tpaint.setPathEffect(null);\r\n\t\tpaint.setShadowLayer(0, 0, 0, 0);\r\n\t\tpaint.setColor(Color.BLACK);\r\n\t\tpaint.setStrokeWidth(1);\r\n\t\t\r\n\t\tif (type == MapRenderingTypes.HIGHWAY) {\r\n\t\t\tint hwType = subtype;\r\n\t\t\tboolean carRoad = true;\r\n\t\t\tif (hwType == MapRenderingTypes.PL_HW_TRUNK) {\r\n\t\t\t\tpaint.setColor(clTrunkRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_MOTORWAY) {\r\n\t\t\t\tpaint.setColor(clMotorwayRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_PRIMARY) {\r\n\t\t\t\tpaint.setColor(clPrimaryRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_SECONDARY) {\r\n\t\t\t\tpaint.setColor(clSecondaryRoad);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_TERTIARY) {\r\n\t\t\t\tpaint.setColor(clTertiaryRoad);\r\n\t\t\t\tpaint.setShadowLayer(2, 0, 0, Color.rgb(186, 186, 186));\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_SERVICE || hwType == MapRenderingTypes.PL_HW_UNCLASSIFIED\r\n\t\t\t\t\t|| hwType == MapRenderingTypes.PL_HW_RESIDENTIAL) {\r\n\t\t\t\tpaint.setShadowLayer(1, 0, 0, Color.rgb(194, 194, 194));\r\n\t\t\t\tpaint.setColor(clRoadColor);\r\n\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_PEDESTRIAN) {\r\n\t\t\t\tpaint.setShadowLayer(1, 0, 0, Color.rgb(176, 176, 176));\r\n\t\t\t\tpaint.setColor(Color.rgb(236, 236, 236));\r\n\t\t\t} else {\r\n\t\t\t\tcarRoad = false;\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setPathEffect(dashEffect2_2);\r\n\t\t\t\tif (hwType == MapRenderingTypes.PL_HW_TRACK || hwType == MapRenderingTypes.PL_HW_PATH) {\r\n\t\t\t\t\tpaint.setColor(clTrackRoad);\r\n\t\t\t\t\tpaint.setPathEffect(dashEffect6_2);\r\n\t\t\t\t} else if (hwType == MapRenderingTypes.PL_HW_CYCLEWAY || hwType == MapRenderingTypes.PL_HW_BRIDLEWAY) {\r\n\t\t\t\t\tpaint.setColor(clCycleWayRoad);\r\n\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaint.setColor(clPedestrianRoad);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (carRoad) {\r\n\t\t\t\tif (zoom < 16) {\r\n\t\t\t\t\tpaint.setStrokeWidth(6);\r\n\t\t\t\t} else if (zoom == 16) {\r\n\t\t\t\t\tpaint.setStrokeWidth(8);\r\n\t\t\t\t} else if (zoom == 17) {\r\n\t\t\t\t\tpaint.setStrokeWidth(13);\r\n\t\t\t\t} else if (zoom >= 18) {\r\n\t\t\t\t\tpaint.setStrokeWidth(16);\r\n\t\t\t\t} else if (zoom >= 19) {\r\n\t\t\t\t\tpaint.setStrokeWidth(20);\r\n\t\t\t\t}\r\n\t\t\t\tif (hwType == MapRenderingTypes.PL_HW_SERVICE) {\r\n\t\t\t\t\tpaint.setStrokeWidth(paint.getStrokeWidth() - 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tshowText = carRoad || zoom > 16;\r\n\t\t} else if(type == MapRenderingTypes.BARRIER){\r\n\t\t\tshowLine = zoom >= 16;\t\r\n//\t\t\tif(subtype == 2){\r\n\t\t\tpaint.setColor(Color.rgb(137, 136, 132));\r\n//\t\t\t}\r\n\t\t\tpaint.setStrokeWidth(1);\r\n\t\t} else if(type == MapRenderingTypes.POWER){\r\n\t\t\tif(subtype == 3){\r\n\t\t\t\tpaint.setColor(Color.rgb(186, 186, 186));\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t} else if(subtype == 4){\r\n\t\t\t\tpaint.setColor(Color.rgb(186, 186, 186));\r\n\t\t\t\tpaint.setStrokeWidth(1);\r\n\t\t\t}\r\n\t\t} else if(type == MapRenderingTypes.AERIALWAY){\r\n\t\t\t// TODO effect circles between line \r\n\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\tpaint.setColor(Color.rgb(186, 186, 186));\r\n\t\t} else if(type == MapRenderingTypes.ADMINISTRATIVE){\r\n\t\t\tif(subtype == 29 || subtype == 30){\r\n\t\t\t\tshowLine = zoom > 12;\r\n\t\t\t\tpaint.setColor(Color.rgb(170, 86, 170));\r\n\t\t\t\tpaint.setPathEffect(dashEffect2_2);\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tif(zoom > 16){\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t}\r\n\t\t\t} else if(subtype == 28 || subtype == 27){\r\n\t\t\t\tshowLine = zoom > 11;\r\n\t\t\t\tpaint.setColor(Color.rgb(208, 167, 201));\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setPathEffect(dashEffect6_3);\r\n\t\t\t} else if(subtype == 26 || subtype == 25){\r\n\t\t\t\tshowLine = zoom > 10;\r\n\t\t\t\tpaint.setColor(Color.rgb(169, 193, 156));\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setPathEffect(dashEffect5_2_2_2);\r\n\t\t\t} else if(subtype == 24 || subtype == 23){\r\n\t\t\t\tshowLine = zoom > 5;\r\n\t\t\t\tpaint.setColor(Color.rgb(141, 67, 137));\r\n\t\t\t\tif (zoom > 11) {\r\n\t\t\t\t\tpaint.setPathEffect(dashEffect5_2_2_2);\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaint.setPathEffect(dashEffect4_4);\r\n\t\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if(type == MapRenderingTypes.RAILWAY){\r\n\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\tif(subtype == 6){\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t\tif(zoom > 16){\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t}\r\n\t\t\t\tpaint.setPathEffect(dashEffect6_3);\r\n\t\t\t} else if(subtype == 2){\r\n\t\t\t\tpaint.setColor(Color.rgb(62, 62, 62));\r\n\t\t\t} else if(subtype == 1){\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t\tif(zoom >= 16){\r\n\t\t\t\t\tpaint.setStrokeWidth(3);\r\n\t\t\t\t}\r\n\t\t\t\tpaint.setPathEffect(dashEffect7_7);\r\n\t\t\t} else {\r\n\t\t\t\tpaint.setColor(Color.rgb(153, 153, 153));\r\n\t\t\t}\r\n\t\t} else if(type == MapRenderingTypes.WATERWAY){\r\n\t\t\tif(subtype >= 1 && subtype <= 6){\r\n\t\t\t\tpaint.setStrokeWidth(2);\r\n\t\t\t\tpaint.setColor(Color.rgb(181, 208, 208));\r\n\t\t\t}\r\n\t\t} \r\n\t\t\r\n\t\tif(!showLine){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tboolean inverse = false;\r\n\t\tfloat xPrev = 0;\r\n\t\tfloat yPrev = 0;\r\n\t\tfloat xMid = 0;\r\n\t\tfloat yMid = 0;\r\n\t\tint middle = obj.getPointsLength() / 2;\r\n\t\tfor (int i = 0; i < obj.getPointsLength(); i++) {\r\n\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\tif (path == null) {\r\n\t\t\t\tpath = new Path();\r\n\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t} else {\r\n\t\t\t\txLength += p.x - xPrev; // not abs\r\n\t\t\t\tyLength += p.y - yPrev; // not abs\r\n\t\t\t\tif(i == middle){\r\n\t\t\t\t\txMid = p.x;\r\n\t\t\t\t\tyMid = p.y;\r\n\t\t\t\t\tdouble rot = - Math.atan2(p.x - xPrev, p.y - yPrev) * 180 / Math.PI;\r\n\t\t\t\t\tif (rot < 0) {\r\n\t\t\t\t\t\trot += 360;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (rot < 180) {\r\n\t\t\t\t\t\trot += 180;\r\n\t\t\t\t\t\tinverse = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpathRotate = (float) rot;\r\n\t\t\t\t}\r\n\t\t\t\tif (pathRotate == 0) {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t}\r\n\t\t\txPrev = p.x;\r\n\t\t\tyPrev = p.y;\r\n\t\t}\r\n\t\tif (path != null) {\r\n\t\t\tcanvas.drawPath(path, paint);\r\n\t\t\tif (obj.getName() != null && showText) {\r\n\t\t\t\tfloat w = paint.getStrokeWidth() + 3;\r\n\t\t\t\tif(w < 10){\r\n\t\t\t\t\t w = 10;\r\n\t\t\t\t}\r\n\t\t\t\tpaintText.setTextSize(w);\r\n\t\t\t\tif (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength), Math.abs(yLength))) {\r\n\t\t\t\t\tif (inverse) {\r\n\t\t\t\t\t\tpath.rewind();\r\n\t\t\t\t\t\tboolean st = true;\r\n\t\t\t\t\t\tfor (int i = obj.getPointsLength() - 1; i >= 0; i--) {\r\n\t\t\t\t\t\t\tfloat lon = obj.getPointLongitude(i);\r\n\t\t\t\t\t\t\tfloat lat = obj.getPointLatitude(i);\r\n\t\t\t\t\t\t\tPointF p = calcPoint(leftTileX, topTileY, lat, lon, zoom, rotate);\r\n\t\t\t\t\t\t\tif (st) {\r\n\t\t\t\t\t\t\t\tst = false;\r\n\t\t\t\t\t\t\t\tpath.moveTo(p.x, p.y);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpath.lineTo(p.x, p.y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tTextDrawInfo text = new TextDrawInfo();\r\n\t\t\t\t\ttext.text = obj.getName();\r\n\t\t\t\t\ttext.centerX = xMid;\r\n\t\t\t\t\ttext.centerY = yMid;\r\n\t\t\t\t\ttext.drawOnPath = path;\r\n\t\t\t\t\ttext.textColor = Color.BLACK;\r\n\t\t\t\t\ttext.textSize = w;\r\n\t\t\t\t\ttext.vOffset = paint.getStrokeWidth() / 2 - 1;\r\n\t\t\t\t\ttextToDraw.add(text);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"f327faf9183bcfc6328ef50ae07844d9f23915ea","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static String detectCharset(Bucket data, MIMEType handler) throws IOException {\n\t\t\n\t\t// Detect charset\n\t\t\n\t\tString charset = detectBOM(data);\n\t\t\n\t\tif(charset == null && handler.charsetExtractor != null) {\n\n\t\t\t// Obviously, this is slow!\n\t\t\t// This is why we need to detect on insert.\n\t\t\t\n\t\t\tif(handler.defaultCharset != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, handler.defaultCharset)) != null)\n\t\t\t\t\t\treturn charset;\n\t\t\t\t} catch (DataFilterException e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"ISO-8859-1\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-8\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-16\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-32\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t// Doesn't seem to be supported by prior to 1.6.\n\t\t\t\tLogger.minor(ContentFilter.class, \"UTF-32 not supported\");\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// If it doesn't have a BOM, then it's *probably* safe to use as default.\n\t\t\n\t\treturn handler.defaultCharset;\n\t}","id":40889,"modified_method":"private static String detectCharset(Bucket data, MIMEType handler) throws IOException {\n\t\t\n\t\t// Detect charset\n\t\t\n\t\tString charset = detectBOM(data);\n\t\t\n\t\tif(charset == null && handler.charsetExtractor != null) {\n\n\t\t\t// Obviously, this is slow!\n\t\t\t// This is why we need to detect on insert.\n\t\t\t\n\t\t\tif(handler.defaultCharset != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, handler.defaultCharset)) != null) {\n\t\t\t\t\t\tLogger.minor(ContentFilter.class, \"Returning charset: \"+charset);\n\t\t\t\t\t\treturn charset;\n\t\t\t\t\t}\n\t\t\t\t} catch (DataFilterException e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"ISO-8859-1\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-8\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-16\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif((charset = handler.charsetExtractor.getCharset(data, \"UTF-32\")) != null)\n\t\t\t\t\treturn charset;\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t// Doesn't seem to be supported by prior to 1.6.\n\t\t\t\tLogger.minor(ContentFilter.class, \"UTF-32 not supported\");\n\t\t\t} catch (DataFilterException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// If it doesn't have a BOM, then it's *probably* safe to use as default.\n\t\t\n\t\treturn handler.defaultCharset;\n\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"Hashtable finish(\n\t\t\tHashtable h,\n\t\t\tHashtable hn,\n\t\t\tHTMLParseContext pc) throws DataFilterException {\n\t\t\t// Finishing\n\t\t\tpc.styleScriptRecurseCount--;\n\t\t\tif (pc.styleScriptRecurseCount < 0) {\n\t\t\t\tif (deleteErrors)\n\t\t\t\t\tpc.writeAfterTag\n\t\t\t\t\t\t+= \"<!-- Too many nested style or script tags - ambiguous or invalid parsing -->\";\n\t\t\t\telse\n\t\t\t\t\tthrowFilterException(\"Too many nested <\/style> tags - ambiguous or invalid parsing, can't reliably filter so removing the inner tags - garbage may appear in browser\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsetStyle(false, pc);\n\t\t\tprocessStyle(pc);\n\t\t\tpc.expectingBadComment = false;\n\t\t\tpc.writeStyleScriptWithTag = true;\n\t\t\t// Pass it on, no params for <\/style>\n\t\t\treturn hn;\n\t\t}","id":40890,"modified_method":"Hashtable finish(\n\t\t\tHashtable h,\n\t\t\tHashtable hn,\n\t\t\tHTMLParseContext pc) throws DataFilterException {\n\t\t\tLogger.minor(this, \"Finishing script/style\");\n\t\t\t// Finishing\n\t\t\tsetStyle(false, pc);\n\t\t\tpc.styleScriptRecurseCount--;\n\t\t\tif (pc.styleScriptRecurseCount < 0) {\n\t\t\t\tif (deleteErrors)\n\t\t\t\t\tpc.writeAfterTag\n\t\t\t\t\t\t+= \"<!-- Too many nested style or script tags - ambiguous or invalid parsing -->\";\n\t\t\t\telse\n\t\t\t\t\tthrowFilterException(\"Too many nested <\/style> tags - ambiguous or invalid parsing, can't reliably filter so removing the inner tags - garbage may appear in browser\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!pc.killStyle) {\n\t\t\t\tprocessStyle(pc);\n\t\t\t\tpc.writeStyleScriptWithTag = true;\n\t\t\t} else {\n\t\t\t\tpc.killStyle = false;\n\t\t\t\tpc.currentStyleScriptChunk = \"\";\n\t\t\t}\n\t\t\tpc.expectingBadComment = false;\n\t\t\t// Pass it on, no params for <\/style>\n\t\t\treturn hn;\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"Hashtable start(Hashtable h, Hashtable hn, HTMLParseContext pc) throws DataFilterException {\n\t\t\tpc.styleScriptRecurseCount++;\n\t\t\tif (pc.styleScriptRecurseCount > 1) {\n\t\t\t\tif (deleteErrors)\n\t\t\t\t\tpc.writeAfterTag\n\t\t\t\t\t\t+= \"<!-- Too many nested style or script tags -->\";\n\t\t\t\telse\n\t\t\t\t\tthrowFilterException(\"Too many nested <\/style> tags - ambiguous or invalid parsing, can't reliably filter so removing the inner tags - garbage may appear in browser\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsetStyle(true, pc);\n\t\t\tString type = getHashString(h, \"type\");\n\t\t\tif (type != null) {\n\t\t\t\tif (!type.equalsIgnoreCase(\"text/css\") /* FIXME */\n\t\t\t\t\t) {\n\t\t\t\t\tpc.killText = true;\n\t\t\t\t\tpc.expectingBadComment = true;\n\t\t\t\t\treturn null; // kill the tag\n\t\t\t\t}\n\t\t\t\thn.put(\"type\", \"text/css\");\n\t\t\t}\n\t\t\treturn hn;\n\t\t}","id":40891,"modified_method":"Hashtable start(Hashtable h, Hashtable hn, HTMLParseContext pc) throws DataFilterException {\n\t\t\tLogger.minor(this, \"Starting script/style\");\n\t\t\tpc.styleScriptRecurseCount++;\n\t\t\tif (pc.styleScriptRecurseCount > 1) {\n\t\t\t\tif (deleteErrors)\n\t\t\t\t\tpc.writeAfterTag\n\t\t\t\t\t\t+= \"<!-- Too many nested style or script tags -->\";\n\t\t\t\telse\n\t\t\t\t\tthrowFilterException(\"Too many nested <\/style> tags - ambiguous or invalid parsing, can't reliably filter so removing the inner tags - garbage may appear in browser\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsetStyle(true, pc);\n\t\t\tString type = getHashString(h, \"type\");\n\t\t\tif (type != null) {\n\t\t\t\tif (!type.equalsIgnoreCase(\"text/css\") /* FIXME */\n\t\t\t\t\t) {\n\t\t\t\t\tpc.killStyle = true;\n\t\t\t\t\tpc.expectingBadComment = true;\n\t\t\t\t\treturn null; // kill the tag\n\t\t\t\t}\n\t\t\t\thn.put(\"type\", \"text/css\");\n\t\t\t}\n\t\t\treturn hn;\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"void saveComment(StringBuffer s, Writer w, HTMLParseContext pc)\n\t\tthrows IOException {\n\t\tif (pc.expectingBadComment)\n\t\t\treturn; // ignore it\n\n\t\tif (pc.inStyle || pc.inScript) {\n\t\t\tpc.currentStyleScriptChunk += \"<\" + s + \">\";\n\t\t\treturn; // <\/style> handler should write\n\t\t}\n\t\tif (pc.killTag) {\n\t\t\tpc.killTag = false;\n\t\t\treturn;\n\t\t}\n\t\tw.write('<');\n\t\tw.write(s.toString());\n\t\tw.write('>');\n\t}","id":40892,"modified_method":"void saveComment(StringBuffer s, Writer w, HTMLParseContext pc)\n\t\tthrows IOException {\n\t\tif (pc.expectingBadComment)\n\t\t\treturn; // ignore it\n\n\t\tif (pc.inStyle || pc.inScript) {\n\t\t\tpc.currentStyleScriptChunk += s;\n\t\t\treturn; // <\/style> handler should write\n\t\t}\n\t\tif (pc.killTag) {\n\t\t\tpc.killTag = false;\n\t\t\treturn;\n\t\t}\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(c == '<') {\n\t\t\t\tsb.append(\"&lt;\");\n\t\t\t} else if(c == '>') {\n\t\t\t\tsb.append(\"&gt;\");\n\t\t\t} else {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\ts = sb;\n\t\tw.write('<');\n\t\tw.write(s.toString());\n\t\tw.write('>');\n\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"void saveText(StringBuffer s, Writer w, HTMLParseContext pc)\n\t\tthrows IOException {\n\t\tif (pc.killText) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif(s.charAt(i) < 32) {\n\t\t\t\t// Not a real character\n\t\t\t\t// STRONGLY suggests somebody is using a bogus charset.\n\t\t\t\t// This could be in order to break the filter.\n\t\t\t\ts.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tString style = s.toString();\n\t\tif (pc.inStyle) {\n\t\t\tpc.currentStyleScriptChunk += style;\n\t\t\treturn; // is parsed and written elsewhere\n\t\t}\n\t\tw.write(style);\n\t}","id":40893,"modified_method":"void saveText(StringBuffer s, Writer w, HTMLParseContext pc)\n\t\tthrows IOException {\n\t\tif (pc.killText) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(c < 32 && c != '\\n' && c != '\\r' ) {\n\t\t\t\t// Not a real character\n\t\t\t\t// STRONGLY suggests somebody is using a bogus charset.\n\t\t\t\t// This could be in order to break the filter.\n\t\t\t\ts.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tString style = s.toString();\n\t\tif (pc.inStyle || pc.inScript) {\n\t\t\tpc.currentStyleScriptChunk += style;\n\t\t\treturn; // is parsed and written elsewhere\n\t\t}\n\t\tw.write(style);\n\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"Hashtable sanitizeHash(\n\t\t\tHashtable h,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc,\n\t\t\tint linkHtl) throws DataFilterException {\n\t\t\tHashtable hn = super.sanitizeHash(h, p, pc);\n\t\t\tString xmlns = getHashString(h, \"xmlns\");\n\t\t\tif (xmlns != null && xmlns.equals(\"http://www.w3.org/1999/xhtml\"))\n\t\t\t\thn.put(\"xmlns\", xmlns);\n\t\t\treturn hn;\n\t\t}","id":40894,"modified_method":"Hashtable sanitizeHash(\n\t\t\tHashtable h,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc) throws DataFilterException {\n\t\t\tHashtable hn = super.sanitizeHash(h, p, pc);\n\t\t\tString xmlns = getHashString(h, \"xmlns\");\n\t\t\tif (xmlns != null && xmlns.equals(\"http://www.w3.org/1999/xhtml\"))\n\t\t\t\thn.put(\"xmlns\", xmlns);\n\t\t\treturn hn;\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"Hashtable sanitizeHash(\n\t\t\tHashtable h,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc,\n\t\t\tint linkHtl) throws DataFilterException {\n\t\t\tHashtable hn = super.sanitizeHash(h, p, pc);\n\t\t\t/*\n\t\t\t * Several possibilities: a) meta http-equiv=X content=Y b) meta\n\t\t\t * name=X content=Y\n\t\t\t */\n\t\t\tString http_equiv = getHashString(h, \"http-equiv\");\n\t\t\tString name = getHashString(h, \"name\");\n\t\t\tString content = getHashString(h, \"content\");\n\t\t\tString scheme = getHashString(h, \"scheme\");\n\t\t\tif (content != null) {\n\t\t\t\tif (name != null && http_equiv == null) {\n\t\t\t\t\tif (name.equalsIgnoreCase(\"Author\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (name.equalsIgnoreCase(\"Keywords\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (name.equalsIgnoreCase(\"Description\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t}\n\t\t\t\t} else if (http_equiv != null && name == null) {\n\t\t\t\t\tif (http_equiv.equalsIgnoreCase(\"Expires\")) {\n\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Script-Type\")) {\n\t\t\t\t\t\t// We don't support script at this time.\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Style-Type\")) {\n\t\t\t\t\t\t// FIXME: charsets\n\t\t\t\t\t\tif (content.equalsIgnoreCase(\"text/css\")) {\n\t\t\t\t\t\t\t// FIXME: selectable style languages - only matters\n\t\t\t\t\t\t\t// when we have implemented more than one\n\t\t\t\t\t\t\t// FIXME: if we ever do allow it... the spec\n\t\t\t\t\t\t\t// http://www.w3.org/TR/html4/present/styles.html#h-14.2.1\n\t\t\t\t\t\t\t// says only the last definition counts...\n\t\t\t\t\t\t\t//        but it only counts if it's in the HEAD section,\n\t\t\t\t\t\t\t// so we DONT need to parse the whole doc\n\t\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// FIXME: add some more headers - Dublin Core?\n\t\t\t\t\t} else if (http_equiv.equalsIgnoreCase(\"Content-Type\")) {\n\t\t\t\t\t\tString[] typesplit = splitType(content);\n\t\t\t\t\t\tif (typesplit[0].equalsIgnoreCase(\"text/html\")\n\t\t\t\t\t\t\t&& (typesplit[1] == null\n\t\t\t\t\t\t\t\t|| typesplit[1].equalsIgnoreCase(pc.charset))) {\n\t\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\t\thn.put(\n\t\t\t\t\t\t\t\t\"content\",\n\t\t\t\t\t\t\t\ttypesplit[0]\n\t\t\t\t\t\t\t\t\t+ (typesplit[1] != null\n\t\t\t\t\t\t\t\t\t\t? \"; charset=\" + typesplit[1]\n\t\t\t\t\t\t\t\t\t\t: \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(typesplit[1] != null)\n\t\t\t\t\t\t\tpc.detectedCharset = typesplit[1];\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Language\")) {\n\t\t\t\t\t\thn.put(\"http-equiv\", \"Content-Language\");\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hn.isEmpty())\n\t\t\t\treturn null;\n\t\t\treturn hn;\n\t\t}","id":40895,"modified_method":"Hashtable sanitizeHash(\n\t\t\tHashtable h,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc) throws DataFilterException {\n\t\t\tHashtable hn = super.sanitizeHash(h, p, pc);\n\t\t\t/*\n\t\t\t * Several possibilities: a) meta http-equiv=X content=Y b) meta\n\t\t\t * name=X content=Y\n\t\t\t */\n\t\t\tString http_equiv = getHashString(h, \"http-equiv\");\n\t\t\tString name = getHashString(h, \"name\");\n\t\t\tString content = getHashString(h, \"content\");\n\t\t\tString scheme = getHashString(h, \"scheme\");\n\t\t\tLogger.minor(this, \"meta: name=\"+name+\", content=\"+content+\", http-equiv=\"+http_equiv+\", scheme=\"+scheme);\n\t\t\tif (content != null) {\n\t\t\t\tif (name != null && http_equiv == null) {\n\t\t\t\t\tif (name.equalsIgnoreCase(\"Author\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (name.equalsIgnoreCase(\"Keywords\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (name.equalsIgnoreCase(\"Description\")) {\n\t\t\t\t\t\thn.put(\"name\", name);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t}\n\t\t\t\t} else if (http_equiv != null && name == null) {\n\t\t\t\t\tif (http_equiv.equalsIgnoreCase(\"Expires\")) {\n\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Script-Type\")) {\n\t\t\t\t\t\t// We don't support script at this time.\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Style-Type\")) {\n\t\t\t\t\t\t// FIXME: charsets\n\t\t\t\t\t\tif (content.equalsIgnoreCase(\"text/css\")) {\n\t\t\t\t\t\t\t// FIXME: selectable style languages - only matters\n\t\t\t\t\t\t\t// when we have implemented more than one\n\t\t\t\t\t\t\t// FIXME: if we ever do allow it... the spec\n\t\t\t\t\t\t\t// http://www.w3.org/TR/html4/present/styles.html#h-14.2.1\n\t\t\t\t\t\t\t// says only the last definition counts...\n\t\t\t\t\t\t\t//        but it only counts if it's in the HEAD section,\n\t\t\t\t\t\t\t// so we DONT need to parse the whole doc\n\t\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// FIXME: add some more headers - Dublin Core?\n\t\t\t\t\t} else if (http_equiv.equalsIgnoreCase(\"Content-Type\")) {\n\t\t\t\t\t\tLogger.minor(this, \"Found http-equiv content-type=\"+content);\n\t\t\t\t\t\tString[] typesplit = splitType(content);\n\t\t\t\t\t\tfor(int i=0;i<typesplit.length;i++)\n\t\t\t\t\t\t\tLogger.minor(this, \"[\"+i+\"] = \"+typesplit[i]);\n\t\t\t\t\t\tif (typesplit[0].equalsIgnoreCase(\"text/html\")\n\t\t\t\t\t\t\t&& (typesplit[1] == null\n\t\t\t\t\t\t\t\t|| typesplit[1].equalsIgnoreCase(pc.charset))) {\n\t\t\t\t\t\t\thn.put(\"http-equiv\", http_equiv);\n\t\t\t\t\t\t\thn.put(\n\t\t\t\t\t\t\t\t\"content\",\n\t\t\t\t\t\t\t\ttypesplit[0]\n\t\t\t\t\t\t\t\t\t+ (typesplit[1] != null\n\t\t\t\t\t\t\t\t\t\t? \"; charset=\" + typesplit[1]\n\t\t\t\t\t\t\t\t\t\t: \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(typesplit[1] != null)\n\t\t\t\t\t\t\tpc.detectedCharset = typesplit[1].trim();\n\t\t\t\t\t} else if (\n\t\t\t\t\t\thttp_equiv.equalsIgnoreCase(\"Content-Language\")) {\n\t\t\t\t\t\thn.put(\"http-equiv\", \"Content-Language\");\n\t\t\t\t\t\thn.put(\"content\", content);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hn.isEmpty())\n\t\t\t\treturn null;\n\t\t\treturn hn;\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"void processTag(Vector splitTag, Writer w, HTMLParseContext pc)\n\t\tthrows IOException, DataFilterException {\n\t\t// First, check that it is a recognized tag\n\t\tParsedTag t = new ParsedTag(splitTag);\n\t\tif (!pc.killTag) {\n\t\t\tt = t.sanitize(pc);\n\t\t\tif (t != null) {\n\t\t\t\tboolean deletedStyle = false;\n\t\t\t\tif (pc.writeStyleScriptWithTag) {\n\t\t\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t\t\t\tString style = pc.currentStyleScriptChunk;\n\t\t\t\t\tif (style == null || style.length() == 0)\n\t\t\t\t\t\tpc.writeAfterTag += \"<!-- deleted unknown style -->\";\n\t\t\t\t\telse\n\t\t\t\t\t\tw.write(style);\n\t\t\t\t\tpc.currentStyleScriptChunk = \"\";\n\t\t\t\t}\n\t\t\t\tt.write(w);\n\t\t\t\tif (pc.writeAfterTag.length() > 0) {\n\t\t\t\t\tw.write(pc.writeAfterTag);\n\t\t\t\t\tpc.writeAfterTag = \"\";\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t} else {\n\t\t\tpc.killTag = false;\n\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t}\n\t}","id":40896,"modified_method":"void processTag(Vector splitTag, Writer w, HTMLParseContext pc)\n\t\tthrows IOException, DataFilterException {\n\t\t// First, check that it is a recognized tag\n\t\tfor(int i=0;i<splitTag.size();i++)\n\t\t\tLogger.minor(this, \"Tag[\"+i+\"]=\"+splitTag.get(i));\n\t\tParsedTag t = new ParsedTag(splitTag);\n\t\tif (!pc.killTag) {\n\t\t\tt = t.sanitize(pc);\n\t\t\tif (t != null) {\n\t\t\t\tboolean deletedStyle = false;\n\t\t\t\tif (pc.writeStyleScriptWithTag) {\n\t\t\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t\t\t\tString style = pc.currentStyleScriptChunk;\n\t\t\t\t\tif (style == null || style.length() == 0)\n\t\t\t\t\t\tpc.writeAfterTag += \"<!-- deleted unknown style -->\";\n\t\t\t\t\telse\n\t\t\t\t\t\tw.write(style);\n\t\t\t\t\tpc.currentStyleScriptChunk = \"\";\n\t\t\t\t}\n\t\t\t\tt.write(w);\n\t\t\t\tif (pc.writeAfterTag.length() > 0) {\n\t\t\t\t\tw.write(pc.writeAfterTag);\n\t\t\t\t\tpc.writeAfterTag = \"\";\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t} else {\n\t\t\tpc.killTag = false;\n\t\t\tpc.writeStyleScriptWithTag = false;\n\t\t}\n\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"public ParsedTag sanitize(HTMLParseContext pc) throws DataFilterException {\n\t\t\tTagVerifier tv =\n\t\t\t\t(TagVerifier) allowedTagsVerifiers.get(element.toLowerCase());\n\t\t\tif (tv == null) {\n\t\t\t\tif (deleteWierdStuff) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tString err = \"<!-- unknown tag \";\n\t\t\t\t\tboolean safe = true;\n\t\t\t\t\tfor (int x = 0; x < element.length(); x++) {\n\t\t\t\t\t\tif (!Character.isLetter(element.charAt(x))) {\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (safe)\n\t\t\t\t\t\terr += element + \" \";\n\t\t\t\t\terr += \"-->\";\n\t\t\t\t\t// FIXME: Hmmm, why did we just do all this, err is not\n\t\t\t\t\t// used beyond this point... (avian)\n\t\t\t\t\tif (!deleteErrors)\n\t\t\t\t\t\tthrowFilterException(\n\t\t\t\t\t\t\t\"Unknown tag: \" + HTMLEncoder.encode(element));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tv.sanitize(this, pc);\n\t\t}","id":40897,"modified_method":"public ParsedTag sanitize(HTMLParseContext pc) throws DataFilterException {\n\t\t\tTagVerifier tv =\n\t\t\t\t(TagVerifier) allowedTagsVerifiers.get(element.toLowerCase());\n\t\t\tLogger.minor(this, \"Got verifier: \"+tv+\" for \"+element);\n\t\t\tif (tv == null) {\n\t\t\t\tif (deleteWierdStuff) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tString err = \"<!-- unknown tag \";\n\t\t\t\t\tboolean safe = true;\n\t\t\t\t\tfor (int x = 0; x < element.length(); x++) {\n\t\t\t\t\t\tif (!Character.isLetter(element.charAt(x))) {\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (safe)\n\t\t\t\t\t\terr += element + \" \";\n\t\t\t\t\terr += \"-->\";\n\t\t\t\t\t// FIXME: Hmmm, why did we just do all this, err is not\n\t\t\t\t\t// used beyond this point... (avian)\n\t\t\t\t\tif (!deleteErrors)\n\t\t\t\t\t\tthrowFilterException(\n\t\t\t\t\t\t\t\"Unknown tag: \" + HTMLEncoder.encode(element));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tv.sanitize(this, pc);\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"public ParsedTag(Vector v) {\n\t\t\tint len = v.size();\n\t\t\tif (len == 0)\n\t\t\t\treturn;\n\t\t\tString s = (String) v.elementAt(len - 1);\n\t\t\tif ((len - 1 != 0 || s.length() > 1) && s.endsWith(\"/\")) {\n\t\t\t\ts = s.substring(0, s.length() - 1);\n\t\t\t\tv.setElementAt(s, len - 1);\n\t\t\t\tif (s.length() == 0)\n\t\t\t\t\tlen--;\n\t\t\t\tendSlash = true;\n\t\t\t\t// Don't need to set it back because everything is an I-value\n\t\t\t}\n\t\t\ts = (String) v.elementAt(0);\n\t\t\tif (s.length() > 1 && s.startsWith(\"/\")) {\n\t\t\t\ts = s.substring(1);\n\t\t\t\tv.setElementAt(s, 0);\n\t\t\t\tstartSlash = true;\n\t\t\t}\n\t\t\telement = (String) v.elementAt(0);\n\t\t\tif (len > 1) {\n\t\t\t\tunparsedAttrs = new String[len - 1];\n\t\t\t\tfor (int x = 1; x < len; x++)\n\t\t\t\t\tunparsedAttrs[x - 1] = (String) v.elementAt(x);\n\t\t\t}\n\t\t}","id":40898,"modified_method":"public ParsedTag(Vector v) {\n\t\t\tint len = v.size();\n\t\t\tif (len == 0)\n\t\t\t\treturn;\n\t\t\tString s = (String) v.elementAt(len - 1);\n\t\t\tif ((len - 1 != 0 || s.length() > 1) && s.endsWith(\"/\")) {\n\t\t\t\ts = s.substring(0, s.length() - 1);\n\t\t\t\tv.setElementAt(s, len - 1);\n\t\t\t\tif (s.length() == 0)\n\t\t\t\t\tlen--;\n\t\t\t\tendSlash = true;\n\t\t\t\t// Don't need to set it back because everything is an I-value\n\t\t\t}\n\t\t\ts = (String) v.elementAt(0);\n\t\t\tif (s.length() > 1 && s.startsWith(\"/\")) {\n\t\t\t\ts = s.substring(1);\n\t\t\t\tv.setElementAt(s, 0);\n\t\t\t\tstartSlash = true;\n\t\t\t}\n\t\t\telement = (String) v.elementAt(0);\n\t\t\tif (len > 1) {\n\t\t\t\tunparsedAttrs = new String[len - 1];\n\t\t\t\tfor (int x = 1; x < len; x++)\n\t\t\t\t\tunparsedAttrs[x - 1] = (String) v.elementAt(x);\n\t\t\t}\n\t\t\tLogger.minor(this, \"Element = \"+element);\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"static String sanitizeStyle(String style, FilterCallback cb) throws DataFilterException {\n\t\tLogger.debug(\n\t\t\tHTMLFilter.class,\n\t\t\t\"Sanitizing style: \" + style);\n\t\tReader r = new StringReader(style);\n\t\tWriter w = new StringWriter();\n\t\tCSSParser pc = new CSSParser(r, w, false, cb);\n\t\ttry {\n\t\t\tpc.parse();\n\t\t} catch (IOException e) {\n\t\t\tLogger.error(\n\t\t\t\tHTMLFilter.class,\n\t\t\t\t\"IOException parsing inline CSS!\");\n\t\t} catch (Error e) {\n\t\t\tif (e.getMessage().equals(\"Error: could not match input\")) {\n\t\t\t\t// this sucks, it should be a proper exception\n\t\t\t\tLogger.normal(\n\t\t\t\t\tHTMLFilter.class,\n\t\t\t\t\t\"CSS Parse Error!\",\n\t\t\t\t\te);\n\t\t\t\treturn \"/* Could not match input style */\";\n\t\t\t} else\n\t\t\t\tthrow e;\n\t\t}\n\t\tString s = w.toString();\n\t\tif (s == null || s.length() == 0)\n\t\t\treturn null;\n\t\t//\t\tCore.logger.log(SaferFilter.class, \"Style now: \" + s, Logger.DEBUG);\n\t\tLogger.debug(HTMLFilter.class, \"Style finally: \" + s);\n\t\treturn s;\n\t}","id":40899,"modified_method":"static String sanitizeStyle(String style, FilterCallback cb) throws DataFilterException {\n\t\tLogger.debug(\n\t\t\tHTMLFilter.class,\n\t\t\t\"Sanitizing style: \" + style);\n\t\tif(style == null) return null;\n\t\tReader r = new StringReader(style);\n\t\tWriter w = new StringWriter();\n\t\tCSSParser pc = new CSSParser(r, w, false, cb);\n\t\ttry {\n\t\t\tpc.parse();\n\t\t} catch (IOException e) {\n\t\t\tLogger.error(\n\t\t\t\tHTMLFilter.class,\n\t\t\t\t\"IOException parsing inline CSS!\");\n\t\t} catch (Error e) {\n\t\t\tif (e.getMessage().equals(\"Error: could not match input\")) {\n\t\t\t\t// this sucks, it should be a proper exception\n\t\t\t\tLogger.normal(\n\t\t\t\t\tHTMLFilter.class,\n\t\t\t\t\t\"CSS Parse Error!\",\n\t\t\t\t\te);\n\t\t\t\treturn \"/* Could not match input style */\";\n\t\t\t} else\n\t\t\t\tthrow e;\n\t\t}\n\t\tString s = w.toString();\n\t\tif (s == null || s.length() == 0)\n\t\t\treturn null;\n\t\t//\t\tCore.logger.log(SaferFilter.class, \"Style now: \" + s, Logger.DEBUG);\n\t\tLogger.debug(HTMLFilter.class, \"Style finally: \" + s);\n\t\treturn s;\n\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"Hashtable sanitizeHash(\n\t\t\tHashtable hn,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc) {\n\t\t\t//Hashtable h = super.sanitizeHash(hn, p, pc);\n\t\t\treturn null; // Lose the tags\n\t\t}","id":40900,"modified_method":"Hashtable sanitizeHash(\n\t\t\tHashtable hn,\n\t\t\tParsedTag p,\n\t\t\tHTMLParseContext pc) throws DataFilterException {\n\t\t\t// Call parent so we swallow the scripting\n\t\t\tHashtable h = super.sanitizeHash(hn, p, pc);\n\t\t\treturn null; // Lose the tags\n\t\t}","commit_id":"6dbf50e3e8a2482888ed83ccd35839e0451449b7","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\t\tpublic LocalRepository createLocalRepository(long repositoryId)\n\t\t\tthrows PortalException {\n\n\t\t\treturn new LiferayWorkflowLocalRepositoryWrapper(\n\t\t\t\tnew ModelValidatorLocalRepositoryWrapper(\n\t\t\t\t\t_repositoryFactory.createLocalRepository(repositoryId),\n\t\t\t\t\tModelValidatorUtil.getDefaultFileSizeModelValidator()),\n\t\t\t\t_liferayWorkflowCapability);\n\t\t}","id":40901,"modified_method":"@Override\n\t\tpublic LocalRepository createLocalRepository(long repositoryId)\n\t\t\tthrows PortalException {\n\n\t\t\tLocalRepository localRepository =\n\t\t\t\t_repositoryFactory.createLocalRepository(repositoryId);\n\n\t\t\tModelValidator<ContentReference> modelValidator =\n\t\t\t\tModelValidatorUtil.getDefaultFileSizeModelValidator();\n\n\t\t\tLocalRepository localRepositoryWrapper =\n\t\t\t\tnew ModelValidatorLocalRepositoryWrapper(\n\t\t\t\t\tlocalRepository, modelValidator);\n\n\t\t\treturn new LiferayWorkflowLocalRepositoryWrapper(\n\t\t\t\tlocalRepositoryWrapper, _liferayWorkflowCapability);\n\t\t}","commit_id":"fdbb4c7103e067be8373116988664b6795377f89","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic Repository createRepository(long repositoryId)\n\t\t\tthrows PortalException {\n\n\t\t\treturn new LiferayWorkflowRepositoryWrapper(\n\t\t\t\tnew ModelValidatorRepositoryWrapper(\n\t\t\t\t\t_repositoryFactory.createRepository(repositoryId),\n\t\t\t\t\tModelValidatorUtil.getDefaultFileSizeModelValidator()),\n\t\t\t\t_liferayWorkflowCapability);\n\t\t}","id":40902,"modified_method":"@Override\n\t\tpublic Repository createRepository(long repositoryId)\n\t\t\tthrows PortalException {\n\n\t\t\tRepository repository = _repositoryFactory.createRepository(\n\t\t\t\trepositoryId);\n\n\t\t\tModelValidator<ContentReference> modelValidator =\n\t\t\t\tModelValidatorUtil.getDefaultFileSizeModelValidator();\n\n\t\t\tRepository repositoryWrapper = new ModelValidatorRepositoryWrapper(\n\t\t\t\trepository, modelValidator);\n\n\t\t\treturn new LiferayWorkflowRepositoryWrapper(\n\t\t\t\trepositoryWrapper, _liferayWorkflowCapability);\n\t\t}","commit_id":"fdbb4c7103e067be8373116988664b6795377f89","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Repository getTargetRepository(){\n        return new Jcr(new Oak(targetNodeStore)).createRepository();\n    }","id":40903,"modified_method":"public Repository getTargetRepository() {\n        if (targetRepository == null) {\n            targetRepository = (JackrabbitRepository) new Jcr(new Oak(\n                    targetNodeStore)).createRepository();\n        }\n        return targetRepository;\n    }","commit_id":"44edcca310d3b2956a4161da776efdb14326c631","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void load() {\n      if (myPI != null) {\n        myPI.setText2(SvnBundle.message(\"progress.text2.changes.establishing.connection\", myUrl));\n      }\n\n      try {\n        if (myForceBackwards) {\n          SVNURL svnurl = SVNURL.parseURIEncoded(myUrl);\n          if (! existsNow(svnurl)) {\n            loadBackwards(svnurl);\n            return;\n          }\n        }\n\n        SVNWCClient wcClient = myVcs.createWCClient();\n        final SVNURL svnurl = SVNURL.parseURIEncoded(myUrl);\n        SVNRevision operationalFrom = myFrom == null ? SVNRevision.HEAD : myFrom;\n        final SVNURL rootURL = getRepositoryRoot(svnurl, myFrom);\n        final String root = rootURL.toString();\n        String relativeUrl = myUrl;\n        if (myUrl.startsWith(root)) {\n          relativeUrl = myUrl.substring(root.length());\n        }\n        SVNLogClient client = myVcs.createLogClient();\n        client.doLog(svnurl, new String[]{}, myPeg == null ? myFrom : myPeg,\n                     operationalFrom, myTo == null ? SVNRevision.create(1) : myTo, false, true, mySupport15, myLimit, null,\n                     new RepositoryLogEntryHandler(myVcs, myUrl, SVNRevision.UNDEFINED, relativeUrl, createConsumerAdapter(myConsumer), rootURL));\n      }\n      catch (SVNCancelException e) {\n        //\n      }\n      catch (SVNException e) {\n        myException = new VcsException(e);\n      }\n      catch (VcsException e) {\n        myException = e;\n      }\n    }","id":40904,"modified_method":"@Override\n    protected void load() {\n      if (myPI != null) {\n        myPI.setText2(SvnBundle.message(\"progress.text2.changes.establishing.connection\", myUrl));\n      }\n\n      try {\n        if (myForceBackwards) {\n          SVNURL svnurl = SVNURL.parseURIEncoded(myUrl);\n          if (! existsNow(svnurl)) {\n            loadBackwards(svnurl);\n            return;\n          }\n        }\n\n        SVNWCClient wcClient = myVcs.createWCClient();\n        final SVNURL svnurl = SVNURL.parseURIEncoded(myUrl);\n        SVNRevision operationalFrom = myFrom == null ? SVNRevision.HEAD : myFrom;\n        final SVNURL rootURL = getRepositoryRoot(svnurl, myFrom);\n        if (rootURL == null) {\n          throw new VcsException(\"Could not find repository root for URL: \" + myUrl);\n        }\n        final String root = rootURL.toString();\n        String relativeUrl = myUrl;\n        if (myUrl.startsWith(root)) {\n          relativeUrl = myUrl.substring(root.length());\n        }\n        SVNLogClient client = myVcs.createLogClient();\n        client.doLog(svnurl, new String[]{}, myPeg == null ? myFrom : myPeg,\n                     operationalFrom, myTo == null ? SVNRevision.create(1) : myTo, false, true, mySupport15, myLimit, null,\n                     new RepositoryLogEntryHandler(myVcs, myUrl, SVNRevision.UNDEFINED, relativeUrl, createConsumerAdapter(myConsumer), rootURL));\n      }\n      catch (SVNCancelException e) {\n        //\n      }\n      catch (SVNException e) {\n        myException = new VcsException(e);\n      }\n      catch (VcsException e) {\n        myException = e;\n      }\n    }","commit_id":"b4d2c4e9c18bc54c802e33dd7853ca034c61e8bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SVNURL getRepositoryRoot(SVNURL svnurl, SVNRevision operationalFrom) throws SVNException {\n      return myVcs.createRepository(svnurl).getRepositoryRoot(false);\n      /*final SVNWCClient wcClient = myVcs.createWCClient();\n      try {\n        final SVNInfo info;\n        info = wcClient.doInfo(svnurl, myPeg, operationalFrom);\n        return info.getRepositoryRootURL();\n      }\n      catch (SVNException e) {\n        try {\n          final SVNInfo info;\n          info = wcClient.doInfo(svnurl, SVNRevision.UNDEFINED, SVNRevision.UNDEFINED);\n          return info.getRepositoryRootURL();\n        } catch (SVNException e1) {\n          final SVNInfo info;\n          info = wcClient.doInfo(svnurl, SVNRevision.UNDEFINED, SVNRevision.HEAD);\n          return info.getRepositoryRootURL();\n        }\n      }*/\n    }","id":40905,"modified_method":"private SVNURL getRepositoryRoot(SVNURL svnurl, SVNRevision operationalFrom) throws SVNException {\n      final SVNRepository repository = myVcs.createRepository(svnurl);\n      final SVNURL root = repository.getRepositoryRoot(false);\n      if (root == null) {\n        return repository.getRepositoryRoot(true);\n      }\n      return root;\n      /*final SVNWCClient wcClient = myVcs.createWCClient();\n      try {\n        final SVNInfo info;\n        info = wcClient.doInfo(svnurl, myPeg, operationalFrom);\n        return info.getRepositoryRootURL();\n      }\n      catch (SVNException e) {\n        try {\n          final SVNInfo info;\n          info = wcClient.doInfo(svnurl, SVNRevision.UNDEFINED, SVNRevision.UNDEFINED);\n          return info.getRepositoryRootURL();\n        } catch (SVNException e1) {\n          final SVNInfo info;\n          info = wcClient.doInfo(svnurl, SVNRevision.UNDEFINED, SVNRevision.HEAD);\n          return info.getRepositoryRootURL();\n        }\n      }*/\n    }","commit_id":"b4d2c4e9c18bc54c802e33dd7853ca034c61e8bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174903629960(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","id":40906,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174903629960(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174826611348(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"childRole\");\n  }","id":40907,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174826611348(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"childRole\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174909796960(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = BaseAdapter.fromAdapter(AsPattern_AnnotationLink.getAsPattern((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(node))));\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40908,"modified_method":"public static SNode referenceMacro_GetReferent_1174909796960(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = BaseAdapter.fromAdapter(AsPattern_AnnotationLink.getAsPattern((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(node))));\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1176737323510(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"AntiquotationField\");\n  }","id":40909,"modified_method":"public static Object propertyMacro_GetPropertyValue_1176737323510(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"AntiquotationField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174906675670(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentModel\");\n  }","id":40910,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174906675670(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentModel\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1179741174631(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40911,"modified_method":"public static SNode referenceMacro_GetReferent_1179741174631(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174823842615(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(SNodeOperations.getParent(node, null, false, false), \"matchMethodParameter\").getTargetNode();\n  }","id":40912,"modified_method":"public static SNode referenceMacro_GetReferent_1174823842615(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(SNodeOperations.getParent(node, null, false, false), \"matchMethodParameter\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174906306924(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"isExternalInfo\");\n  }","id":40913,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174906306924(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"isExternalInfo\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174811055861(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"Pattern_\");\n  }","id":40914,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174811055861(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"Pattern_\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174820293524(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyValue\");\n  }","id":40915,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174820293524(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyValue\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174820532447(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String propertyName = node.getProperty(\"propertyName\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    SNode propertyPattern = mainNode.getPropertyAttribute(propertyName);\n    return generator.findNodeBuilderForSource(propertyPattern, \"patternVarField\").getTargetNode();\n  }","id":40916,"modified_method":"public static SNode referenceMacro_GetReferent_1174820532447(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String propertyName = node.getProperty(\"propertyName\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    SNode propertyPattern = mainNode.getPropertyAttribute(propertyName);\n    return generator.findOutputNodeByInputNodeAndMappingName(propertyPattern, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174906782393(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","id":40917,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174906782393(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1176822806433(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"childVar\").getTargetNode();\n  }","id":40918,"modified_method":"public static SNode referenceMacro_GetReferent_1176822806433(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"childVar\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1179741230558(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40919,"modified_method":"public static SNode referenceMacro_GetReferent_1179741230558(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1176737471291(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"antiquotationParameters\").getTargetNode();\n  }","id":40920,"modified_method":"public static SNode referenceMacro_GetReferent_1176737471291(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"antiquotationParameters\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174909655556(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(SNodeOperations.getParent(node, null, false, false), \"nodeToMatch\").getTargetNode();\n  }","id":40921,"modified_method":"public static SNode referenceMacro_GetReferent_1174909655556(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(SNodeOperations.getParent(node, null, false, false), \"nodeToMatch\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1176737392657(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"parameter_\" + node.getId();\n  }","id":40922,"modified_method":"public static Object propertyMacro_GetPropertyValue_1176737392657(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"parameter_\" + node.getId();\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174827615903(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"childVar_\" + node.getId();\n  }","id":40923,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174827615903(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"childVar_\" + node.getId();\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174901525140(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40924,"modified_method":"public static SNode referenceMacro_GetReferent_1174901525140(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174820316054(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyName\");\n  }","id":40925,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174820316054(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyName\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1176737467861(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"antiquotations\").getTargetNode();\n  }","id":40926,"modified_method":"public static SNode referenceMacro_GetReferent_1176737467861(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"antiquotations\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174811358972(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"PatternVar\");\n  }","id":40927,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174811358972(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return generator.getGeneratorSessionContext().createUniqueName(\"PatternVar\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174827696302(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    SNode mainNode = node.getReferent(\"mainNode\");\n    String role = node.getProperty(\"childRole\");\n    return mainNode.getChildCount(role) + \"\";\n  }","id":40928,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174827696302(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    SNode mainNode = node.getReferent(\"mainNode\");\n    String role = node.getProperty(\"childRole\");\n    return mainNode.getChildCount(role) + \"\";\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1176737751209(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String refRole = node.getProperty(\"referentRole\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    ReferenceAntiquotation refAntiq = ReferenceAntiquotation_AnnotationLink.getReferenceAntiquotation((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(mainNode)), refRole);\n    return generator.findNodeBuilderForSource(refAntiq.getExpression().getNode(), \"antiquotations\").getTargetNode();\n  }","id":40929,"modified_method":"public static SNode referenceMacro_GetReferent_1176737751209(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String refRole = node.getProperty(\"referentRole\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    ReferenceAntiquotation refAntiq = ReferenceAntiquotation_AnnotationLink.getReferenceAntiquotation((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(mainNode)), refRole);\n    return generator.findOutputNodeByInputNodeAndMappingName(refAntiq.getExpression().getNode(), \"antiquotations\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174909759055(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = BaseAdapter.fromAdapter(AsPattern_AnnotationLink.getAsPattern((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(node))));\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40930,"modified_method":"public static SNode referenceMacro_GetReferent_1174909759055(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = BaseAdapter.fromAdapter(AsPattern_AnnotationLink.getAsPattern((BaseConcept)((INodeAdapter)SNodeOperations.getAdapter(node))));\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174909927153(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findNodeBuilderForSource(attribute, \"patternVarField\").getTargetNode();\n  }","id":40931,"modified_method":"public static SNode referenceMacro_GetReferent_1174909927153(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    SNode attribute = node.getAttribute();\n    return generator.findOutputNodeByInputNodeAndMappingName(attribute, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174829805023(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(SNodeOperations.getParent(node, null, false, false), \"nodeToMatch\").getTargetNode();\n  }","id":40932,"modified_method":"public static SNode referenceMacro_GetReferent_1174829805023(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(SNodeOperations.getParent(node, null, false, false), \"nodeToMatch\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174820511130(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyName\");\n  }","id":40933,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174820511130(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"propertyName\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174824244245(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"childVar\").getTargetNode();\n  }","id":40934,"modified_method":"public static SNode referenceMacro_GetReferent_1174824244245(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"childVar\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174823343924(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"nodeToMatch_\" + node.getId();\n  }","id":40935,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174823343924(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return \"nodeToMatch_\" + node.getId();\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174906425197(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"targetInfo\");\n  }","id":40936,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174906425197(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"targetInfo\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174828161687(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getParent().getChildren(node.getRole_()).indexOf(node) + \"\";\n  }","id":40937,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174828161687(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getParent().getChildren(node.getRole_()).indexOf(node) + \"\";\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1176737721511(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    Antiquotation antiquotation = Antiquotation_AnnotationLink.getAntiquotation((BaseConcept)((BaseConcept)SNodeOperations.getAdapter(node)));\n    return generator.findNodeBuilderForSource(antiquotation.getNode(), \"antiquotations\").getTargetNode();\n  }","id":40938,"modified_method":"public static SNode referenceMacro_GetReferent_1176737721511(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    Antiquotation antiquotation = Antiquotation_AnnotationLink.getAntiquotation((BaseConcept)((BaseConcept)SNodeOperations.getAdapter(node)));\n    return generator.findOutputNodeByInputNodeAndMappingName(antiquotation.getNode(), \"antiquotations\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String propertyMacro_GetPropertyValue_1174906743818(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","id":40939,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174906743818(SNode node, String templateValue, SNode templateNode, SModel sourceModel, ITemplateGenerator generator, IScope scope, IOperationContext operationContext) {\n    return node.getProperty(\"referentRole\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174903629930(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String referentRole = node.getProperty(\"referentRole\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    SNode linkPattern = mainNode.getLinkAttribute(referentRole);\n    return generator.findNodeBuilderForSource(linkPattern, \"patternVarField\").getTargetNode();\n  }","id":40940,"modified_method":"public static SNode referenceMacro_GetReferent_1174903629930(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    String referentRole = node.getProperty(\"referentRole\");\n    SNode mainNode = node.getReferent(\"mainNode\");\n    SNode linkPattern = mainNode.getLinkAttribute(referentRole);\n    return generator.findOutputNodeByInputNodeAndMappingName(linkPattern, \"patternVarField\");\n  }","commit_id":"8af15b54b19f91dc8b002bdd91c8a38ead428f90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode find_Closure_generatedClosureAdapter_constructor(SNode closure, ITemplateGenerator generator) {\n    INodeBuilder builder = generator.findNodeBuilderForSource(closure, ClosuresMappingId.CLOSURE__ADAPTER_CLASS);\n    SNode closureAdapterClass = builder.getTargetNode();\n    return ((ClassConcept) closureAdapterClass.getAdapter()).constructors().next().getNode();\n  }","id":40941,"modified_method":"public static SNode find_Closure_generatedClosureAdapter_constructor(SNode closure, ITemplateGenerator generator) {\n    SNode closureAdapterClass = generator.findOutputNodeByInputNodeAndMappingName(closure, ClosuresMappingId.CLOSURE__ADAPTER_CLASS);\n    return ((ClassConcept) closureAdapterClass.getAdapter()).constructors().next().getNode();\n  }","commit_id":"286f7d508fcd4ad3709f7b94a58537cb525def0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode find_ContextOwner_ClosureContext_generatedClass(SNode inputNode, ITemplateGenerator generator) {\n    INodeBuilder builder = generator.findNodeBuilderForSource(inputNode, ClosuresMappingId.CONTEXT_OWNER__CLOSURE_CONTEXT__CLASS);\n    if (builder != null) {\n      return builder.getTargetNode();\n    }\n    return null;\n  }","id":40942,"modified_method":"public static SNode find_ContextOwner_ClosureContext_generatedClass(SNode inputNode, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(inputNode, ClosuresMappingId.CONTEXT_OWNER__CLOSURE_CONTEXT__CLASS);\n  }","commit_id":"286f7d508fcd4ad3709f7b94a58537cb525def0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode resolve_VariableReference_Variable_ClosureContext_generatedField(SNode varRef, ITemplateGenerator generator) {\n    VariableDeclaration variableAdapter = ((VariableReference) varRef.getAdapter()).getVariableDeclaration();\n    if (variableAdapter != null) {\n      INodeBuilder builder = generator.findNodeBuilderForSource(variableAdapter.getNode(), ClosuresMappingId.VARIABLE__CLOSURE_CONTEXT__CLASS_FIELD);\n      return builder.getTargetNode();\n    }\n    return null;\n  }","id":40943,"modified_method":"public static SNode resolve_VariableReference_Variable_ClosureContext_generatedField(SNode varRef, ITemplateGenerator generator) {\n    VariableDeclaration variableAdapter = ((VariableReference) varRef.getAdapter()).getVariableDeclaration();\n    if (variableAdapter != null) {\n      return generator.findOutputNodeByInputNodeAndMappingName(variableAdapter.getNode(), ClosuresMappingId.VARIABLE__CLOSURE_CONTEXT__CLASS_FIELD);\n    }\n    return null;\n  }","commit_id":"286f7d508fcd4ad3709f7b94a58537cb525def0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode resolve_VariableDeclStmt_Variable_ClosureContext_generatedField(SNode localVarDeclStmt, ITemplateGenerator generator) {\n    VariableDeclaration variableAdapter = ((LocalVariableDeclarationStatement) localVarDeclStmt.getAdapter()).getLocalVariableDeclaration();\n    if (variableAdapter != null) {\n      INodeBuilder builder = generator.findNodeBuilderForSource(variableAdapter.getNode(), ClosuresMappingId.VARIABLE__CLOSURE_CONTEXT__CLASS_FIELD);\n      return builder.getTargetNode();\n    }\n    return null;\n  }","id":40944,"modified_method":"public static SNode resolve_VariableDeclStmt_Variable_ClosureContext_generatedField(SNode localVarDeclStmt, ITemplateGenerator generator) {\n    VariableDeclaration variableAdapter = ((LocalVariableDeclarationStatement) localVarDeclStmt.getAdapter()).getLocalVariableDeclaration();\n    if (variableAdapter != null) {\n      return generator.findOutputNodeByInputNodeAndMappingName(variableAdapter.getNode(), ClosuresMappingId.VARIABLE__CLOSURE_CONTEXT__CLASS_FIELD);\n    }\n    return null;\n  }","commit_id":"286f7d508fcd4ad3709f7b94a58537cb525def0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1179457640879(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"variable\").getTargetNode();\n  }","id":40945,"modified_method":"public static SNode referenceMacro_GetReferent_1179457640879(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"variable\");\n  }","commit_id":"4a95c1a2aebdb136a06182155e310c8c84253140","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1181738985236(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findNodeBuilderForSource(node, \"variable\").getTargetNode();\n  }","id":40946,"modified_method":"public static SNode referenceMacro_GetReferent_1181738985236(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return generator.findOutputNodeByInputNodeAndMappingName(node, \"variable\");\n  }","commit_id":"4a95c1a2aebdb136a06182155e310c8c84253140","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = parseAndSaveTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n\n      // Metadata at the header level\n      Map<String,Object> tmMetadata = TMXMetadataHelper.getMetadata(tm);\n      assertThat(tmMetadata.size(), is(10));\n      // TODO Add assertions about the metadata contents\n      System.out.println(tmMetadata);\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,Object> tu0Metadata = TMXMetadataHelper.getMetadata(tu0);\n      System.out.println(tu0Metadata);\n      assertThat(tu0Metadata.size(), is(5));\n      // TODO Add assertions about the metadata contents\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,Object> tu1Metadata = TMXMetadataHelper.getMetadata(tu1);\n      System.out.println(tu1Metadata);\n      assertThat(tu1Metadata.size(), is(5));\n      // TODO Add assertions about the metadata contents\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, Object> tuv0Metadata = TMXMetadataHelper.getMetadata(tuv0);\n      System.out.println(tuv0Metadata);\n      assertThat(tuv0Metadata.size(), is(4));\n      // TODO Add assertions about the metadata contents\n   }","id":40947,"modified_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = parseAndSaveTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n\n      // Metadata at the header level\n      Map<String,String> tmAtts = TMXMetadataHelper.getAttributes(tm);\n      assertThat(tmAtts.size(), is(9));\n      assertThat(tmAtts,\n            allOf(\n                  hasEntry(\"segtype\", \"paragraph\"),\n                  hasEntry(\"creationtoolversion\", \"unknown\"),\n                  hasEntry(\"creationtool\", \"Zanata TransMemoryExportTMXStrategy\"),\n                  hasEntry(\"datatype\", \"unknown\"),\n                  hasEntry(\"adminlang\", \"en\"),\n                  hasEntry(\"o-tmf\", \"unknown\"),\n                  hasEntry(\"srclang\", \"*all*\"),\n                  hasKey(\"creationdate\"),\n                  hasKey(\"changedate\")\n            ));\n\n      List<Element> tmChildren = TMXMetadataHelper.getChildren(tm);\n      assertThat(tmChildren.size(), is(2));\n      assertThat(tmChildren.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tmChildren.get(0).getValue(), is(\"Header Prop value\"));\n      assertThat(tmChildren.get(1).getLocalName(), is(\"note\"));\n      assertThat(tmChildren.get(1).getValue(), is(\"Header Note value\"));\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,String> tu0Atts = TMXMetadataHelper.getAttributes(tu0);\n      assertThat(tu0Atts.size(), is(4));\n      assertThat(tu0Atts,\n            allOf(\n                  hasEntry(\"tuid\", \"doc0:resId0\"),\n                  hasEntry(\"srclang\", \"en\"),\n                  hasKey(\"creationdate\"),\n                  hasKey(\"changedate\")\n            ));\n\n      List<Element> tu0Children = TMXMetadataHelper.getChildren(tu0);\n      assertThat(tu0Children.size(), is(2));\n      assertThat(tu0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu0Children.get(1).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(1).getValue(), is(\"Custom prop1 value\"));\n      assertThat(tu0Children.get(2).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(2).getValue(), is(\"Custom note0 value\"));\n      assertThat(tu0Children.get(3).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(3).getValue(), is(\"Custom note1 value\"));\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,String> tu1Atts = TMXMetadataHelper.getAttributes(tu1);\n      assertThat(tu1Atts.size(), is(4));\n      assertThat(tu1Atts,\n            allOf(\n                  hasEntry(\"tuid\", \"doc0:resId1\"),\n                  hasEntry(\"srclang\", \"en\"),\n                  hasKey(\"creationdate\"),\n                  hasKey(\"changedate\")\n            ));\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, String> tuv0Atts = TMXMetadataHelper.getAttributes(tuv0);\n      assertThat(tuv0Atts.size(), is(3));\n      assertThat(tuv0Atts,\n            allOf(\n                  hasEntry(\"lang\", \"en\"),\n                  hasKey(\"creationdate\"),\n                  hasKey(\"changedate\")\n            ));\n   }","commit_id":"a7ebbbdc8bbe49afc8d1a1d4e96e206eb7c117c2","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void mousePressed(MouseEvent e) {\n      Component owner = IdeFocusManager.getInstance(null).getFocusOwner();\n      myWasPressedOnFocusTransfer = owner == null;\n\n      if (passIfNeeded(e, !myWasPressedOnFocusTransfer)) return;\n\n      setPressedByMouse(true);\n\n      repaintComponent();\n    }","id":40948,"modified_method":"public void mousePressed(MouseEvent e) {\n      Component owner = IdeFocusManager.getInstance(null).getFocusOwner();\n      myWasPressedOnFocusTransfer = owner == null;\n\n      if (passIfNeeded(e, !myWasPressedOnFocusTransfer)) return;\n\n      setPressedByMouse(true);\n\n      if (myActionTrigger == MouseEvent.MOUSE_PRESSED) {\n        if (execute(e)) return;\n      } else {\n        repaintComponent();\n      }\n    }","commit_id":"268927bca8280949f19955b801a646108c352b0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void mouseReleased(MouseEvent e) {\n      try {\n        if (passIfNeeded(e, !myWasPressedOnFocusTransfer)) return;\n\n        setPressedByMouse(false);\n\n        Point point = e.getPoint();\n        if (point.x < 0 || point.x > myComponent.getWidth()) return;\n        if (point.y < 0 || point.y > myComponent.getHeight()) return;\n\n        repaintComponent();\n\n        execute(e);\n      }\n      finally {\n        myWasPressedOnFocusTransfer = false;\n      }\n    }","id":40949,"modified_method":"public void mouseReleased(MouseEvent e) {\n      try {\n        if (passIfNeeded(e, !myWasPressedOnFocusTransfer)) return;\n\n        setPressedByMouse(false);\n\n        if (myActionTrigger == MouseEvent.MOUSE_RELEASED) {\n          if (execute(e)) return;\n        } else {\n          repaintComponent();\n        }\n      }\n      finally {\n        myWasPressedOnFocusTransfer = false;\n      }\n    }","commit_id":"268927bca8280949f19955b801a646108c352b0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean passIfNeeded(final MouseEvent e, boolean considerDeadzone) {\n      final boolean actionClick = UIUtil.isActionClick(e, MouseEvent.MOUSE_RELEASED) || UIUtil.isActionClick(e, MouseEvent.MOUSE_PRESSED);\n\n      if (!actionClick || (considerDeadzone && myMouseDeadzone.isWithin())) {\n        pass(e);\n        return true;\n      }\n      return false;\n    }","id":40950,"modified_method":"private boolean passIfNeeded(final MouseEvent e, boolean considerDeadzone) {\n      final boolean actionClick = UIUtil.isActionClick(e, myActionTrigger);\n\n      if (!actionClick || (considerDeadzone && myMouseDeadzone.isWithin())) {\n        pass(e);\n        return true;\n      }\n      return false;\n    }","commit_id":"268927bca8280949f19955b801a646108c352b0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseButtonBehavior(JComponent component, TimedDeadzone.Length mouseDeadzoneTime) {\n    myComponent = component;\n    myMouseDeadzone = new TimedDeadzone(mouseDeadzoneTime, Alarm.ThreadToUse.SWING_THREAD);\n    myComponent.addMouseListener(new MyMouseListener());\n    myComponent.addMouseMotionListener(new MyMouseMotionListener());\n  }","id":40951,"modified_method":"public BaseButtonBehavior(JComponent component, TimedDeadzone.Length mouseDeadzoneTime) {\n    myComponent = component;\n    myMouseDeadzone = new TimedDeadzone(mouseDeadzoneTime, Alarm.ThreadToUse.SWING_THREAD);\n    myComponent.addMouseListener(new MyMouseListener());\n    myComponent.addMouseMotionListener(new MyMouseMotionListener());\n    setActionTrigger(MouseEvent.MOUSE_RELEASED);\n  }","commit_id":"268927bca8280949f19955b801a646108c352b0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ContentTabLabel(final Content content, TabContentLayout layout) {\n    super(layout.myUi, true);\n    myLayout = layout;\n    myContent = content;\n    update();\n\n    myBehavior = new BaseButtonBehavior(this) {\n      protected void execute(final MouseEvent e) {\n        final ContentManager mgr = myUi.myWindow.getContentManager();\n        if (mgr.getIndexOfContent(myContent) >= 0) {\n          mgr.setSelectedContent(myContent, true);\n        }\n      }\n    };\n\n  }","id":40952,"modified_method":"public ContentTabLabel(final Content content, TabContentLayout layout) {\n    super(layout.myUi, true);\n    myLayout = layout;\n    myContent = content;\n    update();\n\n    myBehavior = new BaseButtonBehavior(this) {\n      protected void execute(final MouseEvent e) {\n        final ContentManager mgr = myUi.myWindow.getContentManager();\n        if (mgr.getIndexOfContent(myContent) >= 0) {\n          mgr.setSelectedContent(myContent, true);\n        }\n      }\n    };\n    myBehavior.setActionTrigger(MouseEvent.MOUSE_PRESSED);\n    myBehavior.setMouseDeadzone(TimedDeadzone.NULL);\n  }","commit_id":"268927bca8280949f19955b801a646108c352b0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean passIfNeeded(final MouseEvent e) {\n      if (!UIUtil.isActionClick(e, MouseEvent.MOUSE_RELEASED) || myMouseDeadzone.isWithin()) {\n        pass(e);\n        return true;\n      }\n      return false;\n    }","id":40953,"modified_method":"private boolean passIfNeeded(final MouseEvent e) {\n      final boolean actionClick = UIUtil.isActionClick(e, MouseEvent.MOUSE_RELEASED) || UIUtil.isActionClick(e, MouseEvent.MOUSE_PRESSED);\n\n      if (!actionClick || myMouseDeadzone.isWithin()) {\n        pass(e);\n        return true;\n      }\n      return false;\n    }","commit_id":"5d5b20801bf144e2b0a643b68227126cb098e855","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void mousePressed(final MouseEvent e) {\n      if (UIUtil.isCloseClick(e, MouseEvent.MOUSE_PRESSED)) {\n        final TabInfo info = myTabs.findInfo(e);\n        if (info != null) {\n          IdeEventQueue.getInstance().blockNextEvents(e);\n          FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)info.getObject(), myWindow);\n          return;\n        }\n      }\n\n      if (UIUtil.isActionClick(e) && (e.getClickCount() % 2) == 0 && !isFloating()) {\n        final ActionManager mgr = ActionManager.getInstance();\n        mgr.tryToExecute(mgr.getAction(\"HideAllWindows\"), e, null, ActionPlaces.UNKNOWN, true);\n      }\n    }","id":40954,"modified_method":"@Override\n    public void mousePressed(final MouseEvent e) {\n      if (UIUtil.isCloseClick(e, MouseEvent.MOUSE_PRESSED)) {\n        final TabInfo info = myTabs.findInfo(e);\n        if (info != null) {\n          IdeEventQueue.getInstance().blockNextEvents(e);\n          FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)info.getObject(), myWindow);\n          return;\n        }\n      }\n\n      if (UIUtil.isActionClick(e)) {\n        if (e.getClickCount() == 1) {\n          myActionClickCount = 0;\n        }\n        // clicks on the close window button don't count in determining whether we have a double-click on tab (IDEA-70403)\n        final Component deepestComponent = SwingUtilities.getDeepestComponentAt(e.getComponent(), e.getX(), e.getY());\n        if (!(deepestComponent instanceof InplaceButton)) {\n          myActionClickCount++;\n        }\n        if (myActionClickCount == 2 && !isFloating()) {\n          final ActionManager mgr = ActionManager.getInstance();\n          mgr.tryToExecute(mgr.getAction(\"HideAllWindows\"), e, null, ActionPlaces.UNKNOWN, true);\n        }\n      }\n    }","commit_id":"11b639909cdb0b83ca0beb45f9111905baad9559","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void parse(Document doc, Locator locator, boolean addon)\n\tthrows Exception {\n\t\tfinal Element root = doc.getRootElement();\n\t\tfinal String lang = IDOMs.getRequiredElementValue(root, \"language-name\");\n\t\tfinal LanguageDefinition langdef;\n\t\tif (addon) {\n\t\t\tif (log.debugable()) log.debug(\"Addon language to \"+lang+\" from \"+root.getElementValue(\"addon-name\", true));\n\t\t\tlangdef = LanguageDefinition.lookup(lang);\n\n\t\t\tif (!root.getElements(\"case-insensitive\").isEmpty())\n\t\t\t\tthrow new UiException(\"You can not specify case-insensitive in addon\");\n\t\t} else if (\"[system-config]\".equals(lang)) { //system config only\n\t\t\tparseZScriptConfig(root);\n\t\t\treturn; //done\n\t\t} else {\n\t\t\tfinal String ns = (String)IDOMs.getRequiredElementValue(root, \"namespace\");\n\t\t\tif (log.debugable()) log.debug(\"Load language: \"+lang+\", \"+ns);\n\n\t\t\tString clientType = root.getElementValue(\"client-type\", true);\n\t\t\tif (clientType == null || clientType.length() == 0)\n\t\t\t\tclientType = \"html\"; //default\n\n\t\t\tfinal Map pagemolds = parseMolds(root);\n\t\t\tfinal String desktopURI = (String)pagemolds.get(\"desktop\");\n\t\t\tfinal String pageURI = (String)pagemolds.get(\"page\");\n\t\t\tif (desktopURI == null || pageURI == null)\n\t\t\t\tthrow new IllegalSyntaxException(\"Both desktop and page molds must be specified, \"+root.getLocator());\n\n\t\t\tfinal List exts = parseExtensions(root);\n\t\t\tif (exts.isEmpty())\n\t\t\t\tthrow new IllegalSyntaxException(\"The extension must be specified for \"+lang);\n\n\t\t\tlangdef = new LanguageDefinition(\n\t\t\t\tclientType, lang, ns, exts, desktopURI, pageURI, locator);\n\n\t\t\tfor (Iterator it = root.getElements(\"case-insensitive\").iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Element el = (Element)it.next();\n\t\t\t\tfinal String s = el.getText(true);\n\t\t\t\tlangdef.setCaseInsensitive(!\"false\".equalsIgnoreCase(s));\n\t\t\t}\n\t\t}\n\n\t\tparsePI(langdef, doc);\n\t\tparseLabelTemplate(langdef, root);\n\t\tparseDynamicTag(langdef, root);\n\t\tparseMacroTemplate(langdef, root);\n\t\tparseZScriptConfig(root);\n\n\t\tfor (Iterator it = root.getElements(\"javascript\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String src = el.getAttributeValue(\"src\");\n\t\t\tfinal String ctn = el.getText(true);\n\t\t\tfinal JavaScript js;\n\t\t\tif (src != null && src.length() > 0) {\n\t\t\t\tif (ctn != null && ctn.length() > 0)\n\t\t\t\t\tthrow new UiException(\"You cannot specify the content if the src attribute is specified, \"+el.getLocator());\n\t\t\t\tfinal String charset = el.getAttributeValue(\"charset\");\n\t\t\t\tjs = new JavaScript(src, charset);\n\t\t\t} else if (ctn != null && ctn.length() > 0) {\n\t\t\t\tjs = new JavaScript(ctn);\n\t\t\t} else {\n\t\t\t\tthrow new UiException(\"You must specify either the src attribute or the content, \"+el.getLocator());\n\t\t\t}\n\t\t\tlangdef.addJavaScript(js);\n\t\t}\n\t\tfor (Iterator it = root.getElements(\"javascript-module\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tlangdef.addJavaScriptModule(\n\t\t\t\tIDOMs.getRequiredAttributeValue(el, \"name\"),\n\t\t\t\tIDOMs.getRequiredAttributeValue(el, \"version\"));\n\t\t}\n\n\n\t\tfor (Iterator it = root.getElements(\"stylesheet\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String href = el.getAttributeValue(\"href\");\n\t\t\tfinal String ctn = el.getText(true);\n\t\t\tfinal StyleSheet ss;\n\t\t\tif (href != null && href.length() > 0) {\n\t\t\t\tif (ctn != null && ctn.length() > 0)\n\t\t\t\t\tthrow new UiException(\"You cannot specify the content if the href attribute is specified, \"+el.getLocator());\n\t\t\t\tss = new StyleSheet(href, el.getAttributeValue(\"type\"));\n\t\t\t} else if (ctn != null && ctn.length() > 0) {\n\t\t\t\tss = new StyleSheet(ctn, el.getAttributeValue(\"type\"), true);\n\t\t\t} else {\n\t\t\t\tthrow new UiException(\"You must specify either the href attribute or the content, \"+el.getLocator());\n\t\t\t}\n\t\t\tlangdef.addStyleSheet(ss);\n\t\t}\n\n\t\tfor (Iterator it = root.getElements(\"zscript\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String zslang;\n\t\t\tfinal Attribute attr = el.getAttributeItem(\"language\");\n\t\t\tif (attr == null) {\n\t\t\t\tzslang = \"Java\";\n\t\t\t} else {\n\t\t\t\tzslang = attr.getValue();\n\t\t\t\tif (zslang == null || zslang.length() == 0)\n\t\t\t\t\tthrow new UiException(\"The language attribute cannot be empty, \"+attr.getLocator());\n\t\t\t}\n\t\t\tfinal String s = el.getText(true);\n\t\t\tlangdef.addScript(zslang, s);\n\t\t}\n\n\t\tfor (Iterator it = root.getElements(\"component\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String name =\n\t\t\t\tIDOMs.getRequiredElementValue(el, \"component-name\");\n\n\t\t\tfinal String macroUri = el.getElementValue(\"macro-uri\", true);\n\t\t\tfinal ComponentDefinition compdef;\n\t\t\tif (macroUri != null && macroUri.length() != 0) {\n\t\t\t\tif (log.finerable()) log.finer(\"macro component definition: \"+name);\n\n\t\t\t\tcompdef = new ComponentDefinition(langdef, name, macroUri);\n\t\t\t\tlangdef.initMacroDefinition(compdef);\n\n\t\t\t\tfinal String clsnm = el.getElementValue(\"component-class\", true);\n\t\t\t\tif (clsnm != null && clsnm.length() > 0) {\n\t\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\t\tcompdef.setImplementationClass(locateClass(clsnm));\n\t\t\t\t\t\t//resolve it now because it is part of lang-addon\n\t\t\t\t}\n\n\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t} else if (el.getElement(\"extends\") != null) { //override\n\t\t\t\tif (log.finerable()) log.finer(\"Override component definition: \"+name);\n\n\t\t\t\tfinal String extnm = el.getElementValue(\"extends\", true);\n\t\t\t\tfinal ComponentDefinition ref =\n\t\t\t\t\tlangdef.getComponentDefinition(extnm);\n\t\t\t\tif (ref.isMacro())\n\t\t\t\t\tthrow new UiException(\"Unable to extend from a macro component, \"+el.getLocator());\n\n\t\t\t\tif (extnm.equals(name)) {\n\t\t\t\t\tcompdef = ref;\n\t\t\t\t} else {\n\t\t\t\t\tcompdef = ref.clone(name);\n\t\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t\t}\n\n\t\t\t\tfinal String clsnm = el.getElementValue(\"component-class\", true);\n\t\t\t\tif (clsnm != null && clsnm.length() > 0) {\n\t\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\t\tcompdef.setImplementationClass(locateClass(clsnm));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (log.finerable()) log.finer(\"Add component definition: name=\"+name);\n\n\t\t\t\tfinal String clsnm =\n\t\t\t\t\tIDOMs.getRequiredElementValue(el, \"component-class\");\n\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\tcompdef = new ComponentDefinition(\n\t\t\t\t\tlangdef, name, locateClass(clsnm));\n\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseMolds(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addMold((String)me.getKey(), (String)me.getValue());\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseParams(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addParam((String)me.getKey(), (String)me.getValue());\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseProps(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addProperty(\n\t\t\t\t\t(String)me.getKey(), (String)me.getValue(), null);\n\t\t\t}\n\n\t\t\tparseAnnots(compdef, el);\n\t\t}\n\t}","id":40955,"modified_method":"private static void parseLang(Document doc, Locator locator, boolean addon)\n\tthrows Exception {\n\t\tfinal Element root = doc.getRootElement();\n\t\tfinal String lang = IDOMs.getRequiredElementValue(root, \"language-name\");\n\t\tfinal LanguageDefinition langdef;\n\t\tif (addon) {\n\t\t\tif (log.debugable()) log.debug(\"Addon language to \"+lang+\" from \"+root.getElementValue(\"addon-name\", true));\n\t\t\tlangdef = LanguageDefinition.lookup(lang);\n\n\t\t\tif (!root.getElements(\"case-insensitive\").isEmpty())\n\t\t\t\tthrow new UiException(\"You can not specify case-insensitive in addon\");\n\t\t} else {\n\t\t\tfinal String ns = (String)IDOMs.getRequiredElementValue(root, \"namespace\");\n\t\t\tif (log.debugable()) log.debug(\"Load language: \"+lang+\", \"+ns);\n\n\t\t\tString clientType = root.getElementValue(\"client-type\", true);\n\t\t\tif (clientType == null || clientType.length() == 0)\n\t\t\t\tclientType = \"html\"; //default\n\n\t\t\tfinal Map pagemolds = parseMolds(root);\n\t\t\tfinal String desktopURI = (String)pagemolds.get(\"desktop\");\n\t\t\tfinal String pageURI = (String)pagemolds.get(\"page\");\n\t\t\tif (desktopURI == null || pageURI == null)\n\t\t\t\tthrow new IllegalSyntaxException(\"Both desktop and page molds must be specified, \"+root.getLocator());\n\n\t\t\tfinal List exts = parseExtensions(root);\n\t\t\tif (exts.isEmpty())\n\t\t\t\tthrow new IllegalSyntaxException(\"The extension must be specified for \"+lang);\n\n\t\t\tlangdef = new LanguageDefinition(\n\t\t\t\tclientType, lang, ns, exts, desktopURI, pageURI, locator);\n\n\t\t\tfor (Iterator it = root.getElements(\"case-insensitive\").iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Element el = (Element)it.next();\n\t\t\t\tfinal String s = el.getText(true);\n\t\t\t\tlangdef.setCaseInsensitive(!\"false\".equalsIgnoreCase(s));\n\t\t\t}\n\t\t}\n\n\t\tparsePI(langdef, doc);\n\t\tparseLabelTemplate(langdef, root);\n\t\tparseDynamicTag(langdef, root);\n\t\tparseMacroTemplate(langdef, root);\n\n\t\tfor (Iterator it = root.getElements(\"javascript\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String src = el.getAttributeValue(\"src\");\n\t\t\tfinal String ctn = el.getText(true);\n\t\t\tfinal JavaScript js;\n\t\t\tif (src != null && src.length() > 0) {\n\t\t\t\tif (ctn != null && ctn.length() > 0)\n\t\t\t\t\tthrow new UiException(\"You cannot specify the content if the src attribute is specified, \"+el.getLocator());\n\t\t\t\tfinal String charset = el.getAttributeValue(\"charset\");\n\t\t\t\tjs = new JavaScript(src, charset);\n\t\t\t} else if (ctn != null && ctn.length() > 0) {\n\t\t\t\tjs = new JavaScript(ctn);\n\t\t\t} else {\n\t\t\t\tthrow new UiException(\"You must specify either the src attribute or the content, \"+el.getLocator());\n\t\t\t}\n\t\t\tlangdef.addJavaScript(js);\n\t\t}\n\t\tfor (Iterator it = root.getElements(\"javascript-module\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tlangdef.addJavaScriptModule(\n\t\t\t\tIDOMs.getRequiredAttributeValue(el, \"name\"),\n\t\t\t\tIDOMs.getRequiredAttributeValue(el, \"version\"));\n\t\t}\n\n\n\t\tfor (Iterator it = root.getElements(\"stylesheet\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String href = el.getAttributeValue(\"href\");\n\t\t\tfinal String ctn = el.getText(true);\n\t\t\tfinal StyleSheet ss;\n\t\t\tif (href != null && href.length() > 0) {\n\t\t\t\tif (ctn != null && ctn.length() > 0)\n\t\t\t\t\tthrow new UiException(\"You cannot specify the content if the href attribute is specified, \"+el.getLocator());\n\t\t\t\tss = new StyleSheet(href, el.getAttributeValue(\"type\"));\n\t\t\t} else if (ctn != null && ctn.length() > 0) {\n\t\t\t\tss = new StyleSheet(ctn, el.getAttributeValue(\"type\"), true);\n\t\t\t} else {\n\t\t\t\tthrow new UiException(\"You must specify either the href attribute or the content, \"+el.getLocator());\n\t\t\t}\n\t\t\tlangdef.addStyleSheet(ss);\n\t\t}\n\n\t\tfor (Iterator it = root.getElements(\"zscript\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String zslang;\n\t\t\tfinal Attribute attr = el.getAttributeItem(\"language\");\n\t\t\tif (attr == null) {\n\t\t\t\tzslang = \"Java\";\n\t\t\t} else {\n\t\t\t\tzslang = attr.getValue();\n\t\t\t\tif (zslang == null || zslang.length() == 0)\n\t\t\t\t\tthrow new UiException(\"The language attribute cannot be empty, \"+attr.getLocator());\n\t\t\t}\n\t\t\tfinal String s = el.getText(true);\n\t\t\tlangdef.addScript(zslang, s);\n\t\t}\n\n\t\tfor (Iterator it = root.getElements(\"component\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element el = (Element)it.next();\n\t\t\tfinal String name =\n\t\t\t\tIDOMs.getRequiredElementValue(el, \"component-name\");\n\n\t\t\tfinal String macroUri = el.getElementValue(\"macro-uri\", true);\n\t\t\tfinal ComponentDefinition compdef;\n\t\t\tif (macroUri != null && macroUri.length() != 0) {\n\t\t\t\tif (log.finerable()) log.finer(\"macro component definition: \"+name);\n\n\t\t\t\tcompdef = new ComponentDefinition(langdef, name, macroUri);\n\t\t\t\tlangdef.initMacroDefinition(compdef);\n\n\t\t\t\tfinal String clsnm = el.getElementValue(\"component-class\", true);\n\t\t\t\tif (clsnm != null && clsnm.length() > 0) {\n\t\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\t\tcompdef.setImplementationClass(locateClass(clsnm));\n\t\t\t\t\t\t//resolve it now because it is part of lang-addon\n\t\t\t\t}\n\n\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t} else if (el.getElement(\"extends\") != null) { //override\n\t\t\t\tif (log.finerable()) log.finer(\"Override component definition: \"+name);\n\n\t\t\t\tfinal String extnm = el.getElementValue(\"extends\", true);\n\t\t\t\tfinal ComponentDefinition ref =\n\t\t\t\t\tlangdef.getComponentDefinition(extnm);\n\t\t\t\tif (ref.isMacro())\n\t\t\t\t\tthrow new UiException(\"Unable to extend from a macro component, \"+el.getLocator());\n\n\t\t\t\tif (extnm.equals(name)) {\n\t\t\t\t\tcompdef = ref;\n\t\t\t\t} else {\n\t\t\t\t\tcompdef = ref.clone(name);\n\t\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t\t}\n\n\t\t\t\tfinal String clsnm = el.getElementValue(\"component-class\", true);\n\t\t\t\tif (clsnm != null && clsnm.length() > 0) {\n\t\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\t\tcompdef.setImplementationClass(locateClass(clsnm));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (log.finerable()) log.finer(\"Add component definition: name=\"+name);\n\n\t\t\t\tfinal String clsnm =\n\t\t\t\t\tIDOMs.getRequiredElementValue(el, \"component-class\");\n\t\t\t\tnoEL(\"component-class\", clsnm, el);\n\t\t\t\tcompdef = new ComponentDefinition(\n\t\t\t\t\tlangdef, name, locateClass(clsnm));\n\t\t\t\tlangdef.addComponentDefinition(compdef);\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseMolds(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addMold((String)me.getKey(), (String)me.getValue());\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseParams(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addParam((String)me.getKey(), (String)me.getValue());\n\t\t\t}\n\n\t\t\tfor (Iterator e = parseProps(el).entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\tcompdef.addProperty(\n\t\t\t\t\t(String)me.getKey(), (String)me.getValue(), null);\n\t\t\t}\n\n\t\t\tparseAnnots(compdef, el);\n\t\t}\n\t}","commit_id":"6703799990131335044ec74e9027d53175d538e8","url":"https://github.com/zkoss/zk"},{"original_method":"/** Loads all lang.xml found in /metainfo/zk. */\n\t/*package*/ static void load() {\n\t\tfinal ClassLocator locator = new ClassLocator();\n\n\t\t//1. process lang.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/lang.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\tparse(doc, locator, false);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//2. process lang-addon.xml (with dependency)\n\t\ttry {\n\t\t\tfinal List xmls = locator.getDependentXMLResources(\n\t\t\t\t\"metainfo/zk/lang-addon.xml\", \"addon-name\", \"depends\");\n\t\t\tfor (Iterator it = xmls.iterator(); it.hasNext();) {\n\t\t\t\tfinal ClassLocator.Resource res = (ClassLocator.Resource)it.next();\n\t\t\t\tif (checkVersion(res.url, res.document)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparse(res.document, locator, true);\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t\t\t\t//keep running\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t//keep running\n\t\t}\n\n\t\t//3. process other addon (from ConfigParser)\n\t\tfor (Iterator it = _addons.iterator(); it.hasNext();) {\n\t\t\tfinal Object[] p = (Object[])it.next();\n\t\t\tfinal Locator loc = (Locator)p[0];\n\t\t\tfinal URL url = (URL)p[1];\n\t\t\ttry {\n\t\t\t\tparse(new SAXBuilder(false, false, true).build(url),\n\t\t\t\t\tloc, true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.error(\"Failed to load addon: \"+url, ex);\n\t\t\t\t//keep running\n\t\t\t}\n\t\t}\n\t\t_addons = null; //prevent addLanguage being called again\n\t}","id":40956,"modified_method":"/** Loads all lang.xml found in /metainfo/zk. */\n\t/*package*/ static void load() {\n\t\tfinal ClassLocator locator = new ClassLocator();\n\n\t\t//1. process config.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/config.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\tparseConfig(doc, locator);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//2. process lang.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/lang.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\tparseLang(doc, locator, false);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//3. process lang-addon.xml (with dependency)\n\t\ttry {\n\t\t\tfinal List xmls = locator.getDependentXMLResources(\n\t\t\t\t\"metainfo/zk/lang-addon.xml\", \"addon-name\", \"depends\");\n\t\t\tfor (Iterator it = xmls.iterator(); it.hasNext();) {\n\t\t\t\tfinal ClassLocator.Resource res = (ClassLocator.Resource)it.next();\n\t\t\t\tif (checkVersion(res.url, res.document)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparseLang(res.document, locator, true);\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t\t\t\t//keep running\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t//keep running\n\t\t}\n\n\t\t//4. process other addon (from ConfigParser)\n\t\tfor (Iterator it = _addons.iterator(); it.hasNext();) {\n\t\t\tfinal Object[] p = (Object[])it.next();\n\t\t\tfinal Locator loc = (Locator)p[0];\n\t\t\tfinal URL url = (URL)p[1];\n\t\t\ttry {\n\t\t\t\tparseLang(new SAXBuilder(false, false, true).build(url),\n\t\t\t\t\tloc, true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.error(\"Failed to load addon: \"+url, ex);\n\t\t\t\t//keep running\n\t\t\t}\n\t\t}\n\t\t_addons = null; //prevent addLanguage being called again\n\t}","commit_id":"6703799990131335044ec74e9027d53175d538e8","url":"https://github.com/zkoss/zk"},{"original_method":"public NSArray orderedComponents(EOEditingContext ec) {\n\t\t\tNSMutableArray result = new NSMutableArray();\n\t\t\tif (_cachedComponents == null) {\n\t\t\t\t_editingContext = ERXEC.newEditingContext();\n\t\t\t\t_cachedComponents = new NSMutableArray();\n\t\t\t\taddChildrenOfComponentToArray(null, _cachedComponents, _editingContext);\n\t\t\t}\n\t\t\tint level = 0;\n\t\t\tfor (Enumeration e = _cachedComponents.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tComponent component = (Component) EOUtilities.localInstanceOfObject(ec, (EOEnterpriseObject) e.nextElement());\n\t\t\t\tcomponent.sortOrder = level++;\n\t\t\t\tresult.addObject(component);\n\t\t\t}\n\t\t\treturn result;\n\t\t}","id":40957,"modified_method":"public synchronized NSArray orderedComponents(EOEditingContext ec) {\n\t\t\tNSMutableArray result = new NSMutableArray();\n\t\t\tif (_cachedComponentsByGlobalID == null) {\n\t\t\t\taddChildrenOfComponentToArray(null, result, ec);\n\t\t\t\t_cachedComponentsByGlobalID = new NSMutableDictionary();\n\t\t\t\t_cachedComponents = new NSMutableArray();\n\t\t\t\tint level = 0;\n\t\t\t\tfor (Enumeration e = result.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\t\tComponent component = (Component) e.nextElement();\n\t\t\t\t\tString sortOrder = (level < 10 ? \"0\" : \"\") + (level);\n\t\t\t\t\t_cachedComponentsByGlobalID.setObjectForKey(sortOrder, component.permanentGlobalID());\n\t\t\t\t\t_cachedComponents.addObject(component.permanentGlobalID());\n\t\t\t\t\tlevel++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.removeAllObjects();\n\t\t\tfor (Enumeration e = _cachedComponents.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tEOGlobalID gid = (EOGlobalID) e.nextElement();\n\t\t\t\tComponent component = (Component) ec.faultForGlobalID(gid, ec);\n\t\t\t\tif(component != null) {\n\t\t\t\t\tresult.addObject(component);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(\"No object: \" + gid);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}","commit_id":"b05016647795f6c593ed9d69364c647ea33f0967","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int level(int safe) {\n\t\tif (safe > 10)\n\t\t\treturn -1;\n\t\tComponent parent = (Component) valueForKey(\"parent\");\n\t\treturn parent == null ? 0 : 1 + parent.level(safe + 1);\n\t}","id":40958,"modified_method":"public int level(int safe) {\n\t\tif (safe > 10)\n\t\t\treturn -1;\n\t\tComponent parent = (Component) parent();\n\t\treturn parent == null ? 0 : 1 + parent.level(safe + 1);\n\t}","commit_id":"b05016647795f6c593ed9d69364c647ea33f0967","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected NSArray _ignoredPackages() {\n        Enumeration enumerator;\n        NSBundle bundle;\n        String path, content;\n        NSArray tmpArray;\n        NSDictionary dic;\n        NSMutableArray allBundles = new NSMutableArray(NSBundle.frameworkBundles());\n        NSMutableArray ignored = new NSMutableArray();\n        \n        enumerator = allBundles.objectEnumerator();\n        while (enumerator.hasMoreElements()) {\n            bundle = (NSBundle) enumerator.nextElement();\n            path = WOApplication.application().resourceManager().pathForResourceNamed(\"WOIgnoredPackage.plist\",bundle.name(),null);\n            if (path != null) {\n                content = _stringFromFile(path);\n                dic = (NSDictionary) NSPropertyListSerialization.propertyListFromString(content);\n                tmpArray = (NSArray) dic.objectForKey(\"ignoredPackages\");\n                if (tmpArray != null && tmpArray.count() > 0) {\n                    ignored.addObjectsFromArray(tmpArray);\n                }\n            }\n        }\n        return ignored;\n    }","id":40959,"modified_method":"protected NSArray _ignoredPackages() {\n        NSBundle bundle;\n        String path, content;\n        NSDictionary dic = null;\n        NSMutableArray allBundles = new NSMutableArray(NSBundle.frameworkBundles());\n        NSMutableArray ignored = new NSMutableArray();\n\n        for (Enumeration enumerator = allBundles.objectEnumerator(); enumerator.hasMoreElements(); ) {\n            bundle = (NSBundle) enumerator.nextElement();\n            path = WOApplication.application().resourceManager().pathForResourceNamed(\"WOIgnoredPackage.plist\",bundle.name(),null);\n            if (path != null) {\n                content = _stringFromFileSafely(path);\n                if (content != null) {\n                    dic = (NSDictionary) NSPropertyListSerialization.propertyListFromString(content);\n                    if (dic != null && dic.containsKey(\"ignoredPackages\")) {\n                        NSArray tmpArray = (NSArray) dic.objectForKey(\"ignoredPackages\");\n                        if (tmpArray != null && tmpArray.count() > 0) {\n                            ignored.addObjectsFromArray(tmpArray);\n                        }\n                    }\n                }\n            }\n        }\n        System.out.println(\"_ignoredPackages:: \"+ignored);\n        return ignored;\n    }","commit_id":"15ca23460fc348cc756bff626c0a3663d997131d","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected static String _stringFromFile(String path) {\n        File f = new File(path);\n        FileInputStream fis = null;\n        byte[] data = null;\n\n        if (!f.exists()) {\n            return null;\n        }\n        \n        try {\n            int size = (int) f.length();\n            fis = new FileInputStream(f);\n            data = new byte[size];\n            int bytesRead = 0;\n\n            while (bytesRead < size) {\n                bytesRead += fis.read(data, bytesRead, size - bytesRead);\n            }\n\n        } catch (IOException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        } finally {\n            if (f != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    if (NSLog.debugLoggingAllowedForLevelAndGroups(NSLog.DebugLevelInformational, NSLog.DebugGroupIO)) {\n                        NSLog.debug.appendln(\"Exception while closing file input stream: \" + e.getMessage());\n                        NSLog.debug.appendln(e);\n                    }\n\n                }\n\n                f = null;\n            }\n\n        }\n\n        return new String(data);\n    }","id":40960,"modified_method":"/**\n     * Return a string for a file, or return an exception.\n     */\n    // TODO Are any sub-classes using this? Do they catch exceptions?\n    protected static String _stringFromFile(String path) {\n        File f = new File(path);\n        FileInputStream fis = null;\n        byte[] data = null;\n\n        if (!f.exists()) {\n            return null;\n        }\n\n        try {\n            int size = (int) f.length();\n            fis = new FileInputStream(f);\n            data = new byte[size];\n            int bytesRead = 0;\n\n            while (bytesRead < size) {\n                bytesRead += fis.read(data, bytesRead, size - bytesRead);\n            }\n\n        } catch (IOException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        } finally {\n            if (f != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    if (NSLog.debugLoggingAllowedForLevelAndGroups(NSLog.DebugLevelInformational, NSLog.DebugGroupIO)) {\n                        NSLog.debug.appendln(\"Exception while closing file input stream: \" + e.getMessage());\n                        NSLog.debug.appendln(e);\n                    }\n                }\n\n                f = null;\n            }\n\n        }\n\n        return new String(data);\n    }","commit_id":"15ca23460fc348cc756bff626c0a3663d997131d","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     *  @return a sorted array of all addresses\n     *  @param includeLocal whether to include local\n     *  @param includeIPv6 whether to include IPV6\n     *  @return an array of all addresses\n     *  @since 0.8.3\n     */\n    public static SortedSet<String> getAddresses(boolean includeLocal, boolean includeIPv6) {\n        boolean haveIPv4 = false;\n        boolean haveIPv6 = false;\n        SortedSet<String> rv = new TreeSet();\n        try {\n            InetAddress localhost = InetAddress.getLocalHost();\n            InetAddress[] allMyIps = InetAddress.getAllByName(localhost.getCanonicalHostName());\n            if (allMyIps != null) {\n                for (int i = 0; i < allMyIps.length; i++) {\n                    if (allMyIps[i] instanceof Inet4Address)\n                        haveIPv4 = true;\n                    else\n                        haveIPv6 = true;\n                    if (shouldInclude(allMyIps[i], includeLocal, includeIPv6))\n                        rv.add(allMyIps[i].getHostAddress());\n                }\n            }\n        } catch (UnknownHostException e) {}\n\n        try {\n            for(Enumeration<NetworkInterface> ifcs = NetworkInterface.getNetworkInterfaces(); ifcs.hasMoreElements();) {\n                NetworkInterface ifc = ifcs.nextElement();\n                for(Enumeration<InetAddress> addrs =  ifc.getInetAddresses(); addrs.hasMoreElements();) {\n                    InetAddress addr = addrs.nextElement();\n                    if (addr instanceof Inet4Address)\n                        haveIPv4 = true;\n                    else\n                        haveIPv6 = true;\n                    if (shouldInclude(addr, includeLocal, includeIPv6))\n                        rv.add(addr.getHostAddress());\n                }\n            }\n        } catch (SocketException e) {}\n\n        if (includeLocal && haveIPv4)\n            rv.add(\"0.0.0.0\");\n        if (includeLocal && includeIPv6 && haveIPv6)\n            rv.add(\"0:0:0:0:0:0:0:0\");  // we could do \"::\" but all the other ones are probably in long form\n        return rv;\n    }","id":40961,"modified_method":"/**\n     *  @return a sorted array of all addresses\n     *  @param includeLocal whether to include local\n     *  @param includeIPv6 whether to include IPV6\n     *  @return an array of all addresses\n     *  @since 0.8.3\n     */\n    public static SortedSet<String> getAddresses(boolean includeLocal, boolean includeIPv6) {\n        boolean haveIPv4 = false;\n        boolean haveIPv6 = false;\n        SortedSet<String> rv = new TreeSet();\n        try {\n            InetAddress localhost = InetAddress.getLocalHost();\n            InetAddress[] allMyIps = InetAddress.getAllByName(localhost.getCanonicalHostName());\n            if (allMyIps != null) {\n                for (int i = 0; i < allMyIps.length; i++) {\n                    if (allMyIps[i] instanceof Inet4Address)\n                        haveIPv4 = true;\n                    else\n                        haveIPv6 = true;\n                    if (shouldInclude(allMyIps[i], includeLocal, includeIPv6))\n                        rv.add(allMyIps[i].getHostAddress());\n                }\n            }\n        } catch (UnknownHostException e) {}\n\n        try {\n            Enumeration<NetworkInterface> ifcs = NetworkInterface.getNetworkInterfaces();\n            if (ifcs != null) {\n                while (ifcs.hasMoreElements()) {\n                    NetworkInterface ifc = ifcs.nextElement();\n                    for(Enumeration<InetAddress> addrs =  ifc.getInetAddresses(); addrs.hasMoreElements();) {\n                        InetAddress addr = addrs.nextElement();\n                        if (addr instanceof Inet4Address)\n                            haveIPv4 = true;\n                        else\n                            haveIPv6 = true;\n                        if (shouldInclude(addr, includeLocal, includeIPv6))\n                            rv.add(addr.getHostAddress());\n                    }\n                }\n            }\n        } catch (SocketException e) {}\n\n        if (includeLocal && haveIPv4)\n            rv.add(\"0.0.0.0\");\n        if (includeLocal && includeIPv6 && haveIPv6)\n            rv.add(\"0:0:0:0:0:0:0:0\");  // we could do \"::\" but all the other ones are probably in long form\n        return rv;\n    }","commit_id":"fb8deb327d7f9326734ae88d5e47b7a2162c1e32","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Unzip given file to temp folder.\n     *\n     * @param zip ZIP <tt>File<\/tt> to be unzipped.\n     * @return temporary directory with the content of the ZIP file.\n     * @throws IOException Is thrown if a file operation goes wrong.\n     */\n    private static File unzipIntoTmp(File zip)\n        throws IOException\n    {\n        File dest = File.createTempFile(\"zip\", null);\n\n        if (!dest.delete())\n        {\n            throw new IOException(\"Cannot unzip given zip file\");\n        }\n\n        if (!dest.mkdirs())\n        {\n            throw new IOException(\"Cannot unzip given zip file\");\n        }\n\n        ZipFile archive = new ZipFile(zip);\n        Enumeration<? extends ZipEntry> e = archive.entries();\n        while (e.hasMoreElements())\n        {\n            ZipEntry entry = e.nextElement();\n            File file = new File(dest, entry.getName());\n            if (entry.isDirectory() && !file.exists())\n            {\n                file.mkdirs();\n            }\n            else\n            {\n                if (!file.getParentFile().exists())\n                {\n                    file.getParentFile().mkdirs();\n                }\n                InputStream in = archive.getInputStream(entry);\n                BufferedOutputStream out\n                    = new BufferedOutputStream(new FileOutputStream(file));\n                byte[] buffer = new byte[8192];\n                int read;\n                while (-1 != (read = in.read(buffer)))\n                {\n                    out.write(buffer, 0, read);\n                }\n                in.close();\n                out.close();\n            }\n        }\n\n        return dest;\n    }","id":40962,"modified_method":"/**\n     * Unzips a specified <tt>File<\/tt> to temp folder.\n     *\n     * @param zip ZIP <tt>File<\/tt> to be unzipped.\n     * @return temporary directory with the content of the ZIP file.\n     * @throws IOException Is thrown if a file operation goes wrong.\n     */\n    private static File unzipIntoTmp(File zip)\n        throws IOException\n    {\n        File dest = File.createTempFile(\"zip\", null);\n\n        if (!dest.delete())\n            throw new IOException(\"Cannot unzip given zip file\");\n        if (!dest.mkdirs())\n            throw new IOException(\"Cannot unzip given zip file\");\n\n        ZipFile archive = new ZipFile(zip);\n\n        try\n        {\n            Enumeration<? extends ZipEntry> e = archive.entries();\n\n            if (e.hasMoreElements())\n            {\n                byte[] buffer = new byte[8192];\n\n                while (e.hasMoreElements())\n                {\n                    ZipEntry entry = e.nextElement();\n                    File file = new File(dest, entry.getName());\n\n                    if (entry.isDirectory() && !file.exists())\n                    {\n                        file.mkdirs();\n                    }\n                    else\n                    {\n                        File parentFile = file.getParentFile();\n\n                        if (!parentFile.exists())\n                            parentFile.mkdirs();\n\n                        InputStream in = archive.getInputStream(entry);\n\n                        try\n                        {\n                            BufferedOutputStream out\n                                = new BufferedOutputStream(\n                                        new FileOutputStream(file));\n\n                            try\n                            {\n                                int read;\n    \n                                while (-1 != (read = in.read(buffer)))\n                                    out.write(buffer, 0, read);\n                            }\n                            finally\n                            {\n                                out.close();\n                            }\n                        }\n                        finally\n                        {\n                            in.close();\n                        }\n                    }\n                }\n            }\n        }\n        finally\n        {\n            archive.close();\n        }\n        return dest;\n    }","commit_id":"f749b64f3f5f335a4acc4d0aa8e09e5a5d6d4e14","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void renderWith(ActionContext ac, Status st, Enumeration enm)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; enm.hasMoreElements(); ++j) {\n\t\t\tfinal Object val = enm.nextElement();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40963,"modified_method":"private void renderWith(ActionContext ac, Status st, Enumeration enm)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\n\t\tfor (int j = 0; ++j <= _beg && enm.hasMoreElements();) //skip\n\t\t\tenm.nextElement();\n\n\t\tfor (int j = 0, cnt = _end - _beg + 1; enm.hasMoreElements() && --cnt >= 0; ++j) {\n\t\t\tfinal Object val = enm.nextElement();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, Iterator it)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; it.hasNext(); ++j) {\n\t\t\tfinal Object val = it.next();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40964,"modified_method":"private void renderWith(ActionContext ac, Status st, Iterator it)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\n\t\tfor (int j = 0; ++j <= _beg && it.hasNext();) //skip\n\t\t\tit.next();\n\n\t\tfor (int j = 0, cnt = _end - _beg + 1; it.hasNext() && --cnt >= 0; ++j) {\n\t\t\tfinal Object val = it.next();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, float[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Float(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40965,"modified_method":"private void renderWith(ActionContext ac, Status st, float[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Float(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, double[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Double(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40966,"modified_method":"private void renderWith(ActionContext ac, Status st, double[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Double(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, byte[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Byte(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40967,"modified_method":"private void renderWith(ActionContext ac, Status st, byte[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Byte(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, int[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Integer(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40968,"modified_method":"private void renderWith(ActionContext ac, Status st, int[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Integer(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, String txt)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringBuffer sb = new StringBuffer();\n\t\tint idx = 0;\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0, len = txt.length(); j < len; ++j) {\n\t\t\tchar cc = txt.charAt(j);\n\t\t\tif (cc == ',') {\n\t\t\t\tfinal Object val = sb.toString();\n\t\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\t\tif (st != null) st.update(idx++, val);\n\t\t\t\tac.renderFragment(out);\n\t\t\t\tsb.setLength(0);\n\t\t\t} else if (cc == '\\\\' && j + 1 < len) {\n\t\t\t\tcc = txt.charAt(j + 1);\n\t\t\t\tswitch (cc) {\n\t\t\t\tcase 'n': cc = '\\n'; break;\n\t\t\t\tcase 'r': cc = '\\r'; break;\n\t\t\t\tcase 't': cc = '\\t'; break;\n\t\t\t\tcase 'b': cc = '\\b'; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(cc);\n\t\t}\n\t\tif (sb.length() > 0) {\n\t\t\tfinal Object val = sb.toString();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(idx++, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40969,"modified_method":"private void renderWith(ActionContext ac, Status st, String txt)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringBuffer sb = new StringBuffer();\n\t\tint idx = 0;\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg, len = txt.length(); j < len && j <= _end; ++j) {\n\t\t\tchar cc = txt.charAt(j);\n\t\t\tif (cc == ',') {\n\t\t\t\tfinal Object val = sb.toString();\n\t\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\t\tif (st != null) st.update(idx++, val);\n\t\t\t\tac.renderFragment(out);\n\t\t\t\tsb.setLength(0);\n\t\t\t} else if (cc == '\\\\' && j + 1 < len) {\n\t\t\t\tcc = txt.charAt(j + 1);\n\t\t\t\tswitch (cc) {\n\t\t\t\tcase 'n': cc = '\\n'; break;\n\t\t\t\tcase 'r': cc = '\\r'; break;\n\t\t\t\tcase 't': cc = '\\t'; break;\n\t\t\t\tcase 'b': cc = '\\b'; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(cc);\n\t\t}\n\t\tif (sb.length() > 0) {\n\t\t\tfinal Object val = sb.toString();\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(idx++, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, short[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Short(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40970,"modified_method":"private void renderWith(ActionContext ac, Status st, short[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Short(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, Object[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = ary[j];\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40971,"modified_method":"private void renderWith(ActionContext ac, Status st, Object[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = ary[j];\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, long[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Long(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40972,"modified_method":"private void renderWith(ActionContext ac, Status st, long[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Long(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(ActionContext ac, boolean nested)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tif (!nested || _items == null || !isEffective())\n\t\t\treturn;\n\n\t\tfinal Object old1 =\n\t\t\t_var != null ? ac.getAttribute(_var, ac.PAGE_SCOPE): null;\n\t\tfinal Object old2;\n\t\tfinal Status st;\n\t\tif (_varStatus != null) {\n\t\t\told2 = ac.getAttribute(_varStatus, ac.PAGE_SCOPE);\n\t\t\tac.setAttribute(_varStatus, st = new Status(), ac.PAGE_SCOPE);\n\t\t} else {\n\t\t\told2 = null;\n\t\t\tst = null;\n\t\t}\n\n\t\tif (_items.getClass().isArray()) {\n\t\t\tif (_items instanceof Object[])\n\t\t\t\trenderWith(ac, st, (Object[])_items);\n\t\t\telse if (_items instanceof int[])\n\t\t\t\trenderWith(ac, st, (int[])_items);\n\t\t\telse if (_items instanceof short[])\n\t\t\t\trenderWith(ac, st, (short[])_items);\n\t\t\telse if (_items instanceof long[])\n\t\t\t\trenderWith(ac, st, (long[])_items);\n\t\t\telse if (_items instanceof byte[])\n\t\t\t\trenderWith(ac, st, (byte[])_items);\n\t\t\telse if (_items instanceof char[])\n\t\t\t\trenderWith(ac, st, (char[])_items);\n\t\t\telse if (_items instanceof double[])\n\t\t\t\trenderWith(ac, st, (double[])_items);\n\t\t\telse if (_items instanceof float[])\n\t\t\t\trenderWith(ac, st, (float[])_items);\n\t\t\telse\n\t\t\t\tthrow new InternalError(\"Unknown \"+_items.getClass());\n\t\t} else if (_items instanceof Collection) {\n\t\t\trenderWith(ac, st, ((Collection)_items).iterator());\n\t\t} else if (_items instanceof Map) {\n\t\t\trenderWith(ac, st, ((Map)_items).entrySet().iterator());\n\t\t} else if (_items instanceof Iterator) {\n\t\t\trenderWith(ac, st, (Iterator)_items);\n\t\t} else if (_items instanceof Enumeration) {\n\t\t\trenderWith(ac, st, (Enumeration)_items);\n\t\t} else if (_items instanceof String) {\n\t\t\trenderWith(ac, st, (String)_items);\n\t\t} else {\n\t\t\tthrow new ServletException(MWeb.DSP_UNKNOWN_ATTRIBUTE_VALUE,\n\t\t\t\tnew Object[] {this, \"items\", new Integer(ac.getLineNumber())});\n\t\t}\n\n\t\tif (_var != null) ac.setAttribute(_var, old1, ac.PAGE_SCOPE);\n\t\tif (_varStatus != null) ac.setAttribute(_varStatus, old2, ac.PAGE_SCOPE);\n\t}","id":40973,"modified_method":"public void render(ActionContext ac, boolean nested)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tif (!nested || _items == null || !isEffective())\n\t\t\treturn;\n\n\t\tfinal Object old1 =\n\t\t\t_var != null ? ac.getAttribute(_var, ac.PAGE_SCOPE): null;\n\t\tfinal Object old2;\n\t\tfinal Status st;\n\t\tif (_varStatus != null) {\n\t\t\told2 = ac.getAttribute(_varStatus, ac.PAGE_SCOPE);\n\t\t\tac.setAttribute(_varStatus, st = new Status(), ac.PAGE_SCOPE);\n\t\t} else {\n\t\t\told2 = null;\n\t\t\tst = null;\n\t\t}\n\n\t\tif (_items.getClass().isArray()) {\n\t\t\tif (_items instanceof Object[])\n\t\t\t\trenderWith(ac, st, (Object[])_items);\n\t\t\telse if (_items instanceof int[])\n\t\t\t\trenderWith(ac, st, (int[])_items);\n\t\t\telse if (_items instanceof short[])\n\t\t\t\trenderWith(ac, st, (short[])_items);\n\t\t\telse if (_items instanceof long[])\n\t\t\t\trenderWith(ac, st, (long[])_items);\n\t\t\telse if (_items instanceof byte[])\n\t\t\t\trenderWith(ac, st, (byte[])_items);\n\t\t\telse if (_items instanceof char[])\n\t\t\t\trenderWith(ac, st, (char[])_items);\n\t\t\telse if (_items instanceof double[])\n\t\t\t\trenderWith(ac, st, (double[])_items);\n\t\t\telse if (_items instanceof float[])\n\t\t\t\trenderWith(ac, st, (float[])_items);\n\t\t\telse\n\t\t\t\tthrow new InternalError(\"Unknown \"+_items.getClass());\n\t\t} else if (_beg > 0 && (_items instanceof List)) {\n\t\t\tfinal List l = (List)_items;\n\t\t\tfinal int size = l.size();\n\t\t\trenderWith(ac, st, l.listIterator(_beg > size ? size: _beg));\n\t\t} else if (_items instanceof Collection) {\n\t\t\trenderWith(ac, st, ((Collection)_items).iterator());\n\t\t} else if (_items instanceof Map) {\n\t\t\trenderWith(ac, st, ((Map)_items).entrySet().iterator());\n\t\t} else if (_items instanceof Iterator) {\n\t\t\trenderWith(ac, st, (Iterator)_items);\n\t\t} else if (_items instanceof Enumeration) {\n\t\t\trenderWith(ac, st, (Enumeration)_items);\n\t\t} else if (_items instanceof String) {\n\t\t\trenderWith(ac, st, (String)_items);\n\t\t} else {\n\t\t\tthrow new ServletException(MWeb.DSP_UNKNOWN_ATTRIBUTE_VALUE,\n\t\t\t\tnew Object[] {this, \"items\", new Integer(ac.getLineNumber())});\n\t\t}\n\n\t\tif (_var != null) ac.setAttribute(_var, old1, ac.PAGE_SCOPE);\n\t\tif (_varStatus != null) ac.setAttribute(_varStatus, old2, ac.PAGE_SCOPE);\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"private void renderWith(ActionContext ac, Status st, char[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = 0; j < ary.length; ++j) {\n\t\t\tfinal Object val = new Character(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","id":40974,"modified_method":"private void renderWith(ActionContext ac, Status st, char[] ary)\n\tthrows javax.servlet.ServletException, IOException {\n\t\tfinal StringWriter out = _trim ? new StringWriter(): null;\n\t\tfor (int j = _beg; j < ary.length && j <= _end; ++j) {\n\t\t\tfinal Object val = new Character(ary[j]);\n\t\t\tif (_var != null) ac.setAttribute(_var, val, ac.PAGE_SCOPE);\n\t\t\tif (st != null) st.update(j, val);\n\t\t\tac.renderFragment(out);\n\t\t}\n\t\tif (out != null)\n\t\t\tac.getOut().write(out.toString().trim());\n\t}","commit_id":"6eb6e727598d7632dad973c5e72778c2bee86c18","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n   * Extract named attributes from a single LDAP directory\n   *\n   * <p>Connect to the LDAP server indicated by the URL.\n   * An optional userid and password will be used if the LDAP server\n   * requires logon (AD does, most directories don't). The userid given\n   * here would establish access privileges to directory fields for the\n   * uPortal. Connection establishes an initial context (like a current\n   * directory in a file system) that is usually the root of the directory.\n   * Howwever, while a file system root is simply \"/\", a directory root is\n   * the global name of the directory, like \"dc=yu,dc=yale,dc=edu\" or\n   * \"o=Yale University\",c=US\". Then search a subcontext where the people\n   * are (cn=Users in AD, ou=People sometimes, its a local convention).\n   *\n   */\n  void processLdapDir(String username, PersonDirInfo pdi, Hashtable attribs) {\n\n    Hashtable jndienv = new Hashtable();\n    DirContext context = null;\n    ILdapServer srvr = null;\n    boolean fromLdapServices = false;\n\n    //Check for a named ldap reference \n    if (pdi.LdapRefName!=null && pdi.LdapRefName.length()>0) {\n        //Get a ILdapServer info interface from LdapServices\n        srvr = LdapServices.getLdapServer(pdi.LdapRefName);\n        \n        if (srvr != null) {\n            context = srvr.getConnection();\n            fromLdapServices = true;\n        }\n        \n        log.debug(\"PersonDirectory::processLdapDir(): Looking in \"+pdi.LdapRefName+\n          \" for person attributes of \"+username);\n    }\n    \n    //Either no named ldap reference specified or it wasn't found\n    if (context == null) {\n        //JNDI boilerplate to connect to an initial context\n        jndienv.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.ldap.LdapCtxFactory\");\n        jndienv.put(Context.SECURITY_AUTHENTICATION,\"simple\");\n        if (pdi.url.startsWith(\"ldaps\")) { // Handle SSL connections\n          String newurl=pdi.url.substring(0,4) + pdi.url.substring(5);\n          jndienv.put(Context.SECURITY_PROTOCOL,\"ssl\");\n          jndienv.put(Context.PROVIDER_URL,newurl);\n        }\n        else {\n          jndienv.put(Context.PROVIDER_URL,pdi.url);\n        }\n        if (pdi.logonid!=null)\n          jndienv.put(Context.SECURITY_PRINCIPAL,pdi.logonid);\n        if (pdi.logonpassword!=null)\n          jndienv.put(Context.SECURITY_CREDENTIALS,pdi.logonpassword);\n        try {\n          context = new InitialDirContext(jndienv);\n        } catch (NamingException nex) {\n          return;\n        }\n    }\n\n    // Search for the userid in the usercontext subtree of the directory\n    // Use the uidquery substituting username for {0}\n    NamingEnumeration userlist = null;\n    SearchControls sc = new SearchControls();\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n    sc.setTimeLimit(pdi.ldaptimelimit);\n    Object [] args = new Object[] {username};\n    try {\n        String userCtx = pdi.usercontext;\n        \n        // ILdapServer instances have no DN in the connect string.\n        // Append the baseDN for the server here.\n        if (fromLdapServices && srvr != null) {\n            String baseDN = srvr.getBaseDN();\n            if (baseDN != null && baseDN.trim().length() > 0) {\n                userCtx = userCtx + \",\" + baseDN;\n            }\n        }\n        \n        userlist = context.search(userCtx,pdi.uidquery,args,sc);\n    } catch (NamingException nex) {\n      return;\n    }\n\n    // If one object matched, extract properties from the attribute list\n    try {\n      if (userlist.hasMoreElements()) {\n        SearchResult result = (SearchResult) userlist.next();\n        Attributes ldapattribs = result.getAttributes();\n        for (int i=0;i<pdi.attributenames.length;i++) {\n          Attribute tattrib = null;\n          if (pdi.attributenames[i] != null)\n            tattrib = ldapattribs.get(pdi.attributenames[i]);\n          if (tattrib!=null) {\n            // determine if this attribute is a String or a binary (byte array)\n            if (tattrib.size() == 1) {\n                Object att = tattrib.get();\n                if (att instanceof byte[]) {\n                    attribs.put(pdi.attributealiases[i],(Object)att);\n                } else {\n                    String value = att.toString();\n                    attribs.put(pdi.attributealiases[i],value);\n                }\n            } else {\n                // multivalued\n                Vector values = new Vector();\n                for (NamingEnumeration ne = tattrib.getAll(); ne.hasMoreElements(); ) {\n                    Object value = ne.nextElement();\n                    if (value instanceof byte[]) {\n                        values.add(value);\n                    } else {\n                        values.add(value.toString());\n                    }\n                }\n                attribs.put(pdi.attributealiases[i], values);\n            }\n          }\n        }\n      }\n    } catch (NamingException nex) {\n      ;\n    }\n\n    try {userlist.close();} catch (Exception e) {;}\n    \n    if (srvr != null && fromLdapServices) {\n        srvr.releaseConnection(context);\n    }\n    else {\n        try {context.close();} catch (Exception e) {;}\n    }\n\n  }","id":40975,"modified_method":"/**\n   * Extract named attributes from a single LDAP directory\n   *\n   * <p>Connect to the LDAP server indicated by the URL.\n   * An optional userid and password will be used if the LDAP server\n   * requires logon (AD does, most directories don't). The userid given\n   * here would establish access privileges to directory fields for the\n   * uPortal. Connection establishes an initial context (like a current\n   * directory in a file system) that is usually the root of the directory.\n   * Howwever, while a file system root is simply \"/\", a directory root is\n   * the global name of the directory, like \"dc=yu,dc=yale,dc=edu\" or\n   * \"o=Yale University\",c=US\". Then search a subcontext where the people\n   * are (cn=Users in AD, ou=People sometimes, its a local convention).\n   *\n   */\n  void processLdapDir(String username, PersonDirInfo pdi, Hashtable attribs) {\n\n      Hashtable jndienv = new Hashtable();\n      DirContext context = null;\n      ILdapServer srvr = null;\n      boolean fromLdapServices = false;\n\n      try {\n          //Check for a named ldap reference\n          if (pdi.LdapRefName != null && pdi.LdapRefName.length() > 0) {\n              //Get a ILdapServer info interface from LdapServices\n              srvr = LdapServices.getLdapServer(pdi.LdapRefName);\n\n              if (srvr != null) {\n                  context = srvr.getConnection();\n                  fromLdapServices = true;\n              }\n\n              log.debug(\"PersonDirectory::processLdapDir(): Looking in \" + pdi.LdapRefName + \" for person attributes of \" + username);\n          } else if (context == null) {\n              //JNDI boilerplate to connect to an initial context\n              jndienv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n              jndienv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n              if (pdi.url.startsWith(\"ldaps\")) { // Handle SSL connections\n                  String newurl = pdi.url.substring(0, 4) + pdi.url.substring(5);\n                  jndienv.put(Context.SECURITY_PROTOCOL, \"ssl\");\n                  jndienv.put(Context.PROVIDER_URL, newurl);\n              } else {\n                  jndienv.put(Context.PROVIDER_URL, pdi.url);\n              }\n              if (pdi.logonid != null)\n                  jndienv.put(Context.SECURITY_PRINCIPAL, pdi.logonid);\n              if (pdi.logonpassword != null)\n                  jndienv.put(Context.SECURITY_CREDENTIALS, pdi.logonpassword);\n              try {\n                  context = new InitialDirContext(jndienv);\n              } catch (NamingException nex) {\n                  return;\n              }\n          }\n\n          // Search for the userid in the usercontext subtree of the directory\n          // Use the uidquery substituting username for {0}\n          NamingEnumeration userlist = null;\n          try {\n              SearchControls sc = new SearchControls();\n              sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n              sc.setTimeLimit(pdi.ldaptimelimit);\n              Object[] args = new Object[] { username };\n              try {\n                  String userCtx = pdi.usercontext;\n\n                  // If we're using LdapServices, we will assume\n                  // that the baseDN is already specific enough\n                  // and that no separate user context is needed.\n                  // Note that the LDAP security providers in uPortal\n                  // in conjunction with ldap.properties behave this way too.\n                  if (fromLdapServices && srvr != null) {\n                      String baseDN = srvr.getBaseDN();\n                      if (baseDN != null && baseDN.trim().length() > 0) {\n                          userCtx = baseDN;\n                      }\n                  }\n\n                  if (context != null) {\n                      userlist = context.search(userCtx, pdi.uidquery, args, sc);\n                  }\n              } catch (NamingException nex) {\n                  return;\n              }\n\n              // If one object matched, extract properties from the attribute\n              // list\n              try {\n                  if (userlist != null && userlist.hasMoreElements()) {\n                      SearchResult result = (SearchResult) userlist.next();\n                      Attributes ldapattribs = result.getAttributes();\n                      for (int i = 0; i < pdi.attributenames.length; i++) {\n                          Attribute tattrib = null;\n                          if (pdi.attributenames[i] != null)\n                              tattrib = ldapattribs.get(pdi.attributenames[i]);\n                          if (tattrib != null) {\n                              // determine if this attribute is a String or a\n                              // binary (byte array)\n                              if (tattrib.size() == 1) {\n                                  Object att = tattrib.get();\n                                  if (att instanceof byte[]) {\n                                      attribs.put(pdi.attributealiases[i], (Object) att);\n                                  } else {\n                                      String value = att.toString();\n                                      attribs.put(pdi.attributealiases[i], value);\n                                  }\n                              } else {\n                                  // multivalued\n                                  Vector values = new Vector();\n                                  for (NamingEnumeration ne = tattrib.getAll(); ne.hasMoreElements();) {\n                                      Object value = ne.nextElement();\n                                      if (value instanceof byte[]) {\n                                          values.add(value);\n                                      } else {\n                                          values.add(value.toString());\n                                      }\n                                  }\n                                  attribs.put(pdi.attributealiases[i], values);\n                              }\n                          }\n                      }\n                  }\n              } catch (NamingException ne) {\n                  if (log.isErrorEnabled()) {\n                      log.error(\"Unable to extract properties from attribute list\", ne);\n                  }\n              }\n          } finally {\n              try {\n                  if (userlist != null) {\n                      userlist.close();\n                  }\n              } catch (NamingException ne) {\n                  if (log.isErrorEnabled()) {\n                      log.error(\"Unable to close the user list\", ne);\n                  }\n              }\n          }\n      } finally {\n          if (fromLdapServices && srvr != null) {\n              srvr.releaseConnection(context);\n          } else {\n              try {\n                  if (context != null) {\n                      context.close();\n                  }\n              } catch (NamingException ne) {\n                  if (log.isErrorEnabled()) {\n                      log.error(\"Unable to close the context\", ne);\n                  }\n              }\n          }\n      }\n  }","commit_id":"6b2dee8c412073e02f48cd82f0bcff79b4553122","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Look for the home directory of jetty as defined by the system property\n     * 'jetty.home'. If undefined, look at the current bundle and uses its own\n     * jettyhome folder for this feature.\n     * <p>\n     * Special case: inside eclipse-SDK:<br/>\n     * If the bundle is jarred, see if we are inside eclipse-PDE itself. In that\n     * case, look for the installation directory of eclipse-PDE, try to create a\n     * jettyhome folder there and install the sample jettyhome folder at that\n     * location. This makes the installation in eclipse-SDK easier. <br/>\n     * This is a bit redundant with the work done by the jetty configuration\n     * launcher.\n     * <\/p>\n     * \n     * @param context\n     * @throws Exception\n     */\n    public void setup(BundleContext context, Map<String, String> configProperties) throws Exception\n    {\n    \tEnumeration<?> enUrls = context.getBundle().findEntries(\"/etc\", \"jetty.xml\", false);System.err.println();\n    \tif (enUrls.hasMoreElements())\n    \t{\n\t    \tURL url = (URL) enUrls.nextElement();\n\t    \tif (url != null)\n\t    \t{\n\t    \t\t//bug 317231: there is a fragment that defines the jetty configuration file.\n\t    \t\t//let's use that as the jetty home.\n\t    \t\turl = DefaultFileLocatorHelper.getLocalURL(url);\n\t    \t\tif (url.getProtocol().equals(\"file\"))\n\t    \t\t{\n\t    \t\t\t//ok good.\n\t    \t\t\tFile jettyxml = new File(url.toURI());\n\t    \t\t\tFile jettyhome = jettyxml.getParentFile().getParentFile();\n\t    \t\t\tSystem.setProperty(\"jetty.home\", jettyhome.getAbsolutePath());\n\t    \t\t}\n\t    \t}\n    \t}\n    \tFile _installLocation = BUNDLE_FILE_LOCATOR_HELPER.getBundleInstallLocation(context.getBundle());\n        // debug:\n        // new File(\"~/proj/eclipse-install/eclipse-3.5.1-SDK-jetty7/\" +\n        // \"dropins/jetty7/plugins/org.eclipse.jetty.osgi.boot_0.0.1.001-SNAPSHOT.jar\");\n        boolean bootBundleCanBeJarred = true;\n        String jettyHome = stripQuotesIfPresent(System.getProperty(\"jetty.home\"));\n\n        if (jettyHome == null || jettyHome.length() == 0)\n        {\n            if (_installLocation.getName().endsWith(\".jar\"))\n            {\n                jettyHome = JettyHomeHelper.setupJettyHomeInEclipsePDE(_installLocation);\n            }\n            if (jettyHome == null)\n            {\n                jettyHome = _installLocation.getAbsolutePath() + \"/jettyhome\";\n                bootBundleCanBeJarred = false;\n            }\n        }\n        // in case we stripped the quotes.\n        System.setProperty(\"jetty.home\",jettyHome);\n\n        String jettyLogs = stripQuotesIfPresent(System.getProperty(\"jetty.logs\"));\n        if (jettyLogs == null || jettyLogs.length() == 0)\n        {\n            System.setProperty(\"jetty.logs\",jettyHome + \"/logs\");\n        }\n\n        if (!bootBundleCanBeJarred && !_installLocation.isDirectory())\n        {\n            String install = _installLocation != null?_installLocation.getCanonicalPath():\" unresolved_install_location\";\n            throw new IllegalArgumentException(\"The system property -Djetty.home\" + \" must be set to a directory or the bundle \"\n                    + context.getBundle().getSymbolicName() + \" installed here \" + install + \" must be unjarred.\");\n        }\n        try\n        {\n            System.err.println(\"JETTY_HOME set to \" + new File(jettyHome).getCanonicalPath());\n        }\n        catch (Throwable t)\n        {\n            System.err.println(\"JETTY_HOME _set to \" + new File(jettyHome).getAbsolutePath());\n        }\n\n        ClassLoader contextCl = Thread.currentThread().getContextClassLoader();\n        try\n        {\n\n            // passing this bundle's classloader as the context classlaoder\n            // makes sure there is access to all the jetty's bundles\n\n            File jettyHomeF = new File(jettyHome);\n            URLClassLoader libExtClassLoader = null;\n            try\n            {\n            \tlibExtClassLoader = LibExtClassLoaderHelper.createLibEtcClassLoaderHelper(jettyHomeF,_server,\n            \t\t\tJettyBootstrapActivator.class.getClassLoader());\n            }\n            catch (MalformedURLException e)\n            {\n                e.printStackTrace();\n            }\n\n            Thread.currentThread().setContextClassLoader(libExtClassLoader);\n\n            String jettyetc = System.getProperty(OSGiWebappConstants.SYS_PROP_JETTY_ETC_FILES,\"etc/jetty.xml\");\n            StringTokenizer tokenizer = new StringTokenizer(jettyetc,\";,\");\n            \n            Map<Object,Object> id_map = new HashMap<Object,Object>();\n            id_map.put(\"Server\",_server);\n            Map<Object,Object> properties = new HashMap<Object,Object>();\n            properties.put(\"jetty.home\",jettyHome);\n            properties.put(\"jetty.host\",System.getProperty(\"jetty.host\",\"\"));\n            properties.put(\"jetty.port\",System.getProperty(\"jetty.port\",\"8080\"));\n            properties.put(\"jetty.port.ssl\",System.getProperty(\"jetty.port.ssl\",\"8443\"));\n\n            while (tokenizer.hasMoreTokens())\n            {\n                String etcFile = tokenizer.nextToken().trim();\n                File conffile = etcFile.startsWith(\"/\")?new File(etcFile):new File(jettyHomeF,etcFile);\n                if (!conffile.exists())\n                {\n                    __logger.warn(\"Unable to resolve the jetty/etc file \" + etcFile);\n\n                    if (\"etc/jetty.xml\".equals(etcFile))\n                    {\n                        // Missing jetty.xml file, so create a minimal Jetty configuration\n                        __logger.info(\"Configuring default server on 8080\");\n                        SelectChannelConnector connector = new SelectChannelConnector();\n                        connector.setPort(8080);\n                        _server.addConnector(connector);\n\n                        HandlerCollection handlers = new HandlerCollection();\n                        ContextHandlerCollection contexts = new ContextHandlerCollection();\n                        RequestLogHandler requestLogHandler = new RequestLogHandler();\n                        handlers.setHandlers(new Handler[] { contexts, new DefaultHandler(), requestLogHandler });\n                        _server.setHandler(handlers);\n                    }\n                }\n                else\n                {\n                    try\n                    {\n                        // Execute a Jetty configuration file\n                        XmlConfiguration config = new XmlConfiguration(new FileInputStream(conffile));\n                        config.setIdMap(id_map);\n                        config.setProperties(properties);\n                        config.configure();\n                        id_map=config.getIdMap();\n                    }\n                    catch (SAXParseException saxparse)\n                    {\n                        Log.getLogger(WebappRegistrationHelper.class.getName()).warn(\"Unable to configure the jetty/etc file \" + etcFile,saxparse);\n                        throw saxparse;\n                    }\n                }\n            }\n\n            init();\n\n            //now that we have an app provider we can call the registration customizer.\n            try\n            {\n                URL[] jarsWithTlds = getJarsWithTlds();\n                _commonParentClassLoaderForWebapps = jarsWithTlds == null?libExtClassLoader:new TldLocatableURLClassloader(libExtClassLoader,getJarsWithTlds());\n            }\n            catch (MalformedURLException e)\n            {\n                e.printStackTrace();\n            }\n\n            \n            _server.start();\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n        }\n        finally\n        {\n            Thread.currentThread().setContextClassLoader(contextCl);\n        }\n\n    }","id":40976,"modified_method":"/**\n     * Look for the home directory of jetty as defined by the system property\n     * 'jetty.home'. If undefined, look at the current bundle and uses its own\n     * jettyhome folder for this feature.\n     * <p>\n     * Special case: inside eclipse-SDK:<br/>\n     * If the bundle is jarred, see if we are inside eclipse-PDE itself. In that\n     * case, look for the installation directory of eclipse-PDE, try to create a\n     * jettyhome folder there and install the sample jettyhome folder at that\n     * location. This makes the installation in eclipse-SDK easier. <br/>\n     * This is a bit redundant with the work done by the jetty configuration\n     * launcher.\n     * <\/p>\n     * \n     * @param context\n     * @throws Exception\n     */\n    public void setup(BundleContext context, Map<String, String> configProperties) throws Exception\n    {\n    \tEnumeration<?> enUrls = context.getBundle().findEntries(\"/etc\", \"jetty.xml\", false);System.err.println();\n    \tif (enUrls != null && enUrls.hasMoreElements())\n    \t{\n\t    \tURL url = (URL) enUrls.nextElement();\n\t    \tif (url != null)\n\t    \t{\n\t    \t\t//bug 317231: there is a fragment that defines the jetty configuration file.\n\t    \t\t//let's use that as the jetty home.\n\t    \t\turl = DefaultFileLocatorHelper.getLocalURL(url);\n\t    \t\tif (url.getProtocol().equals(\"file\"))\n\t    \t\t{\n\t    \t\t\t//ok good.\n\t    \t\t\tFile jettyxml = new File(url.toURI());\n\t    \t\t\tFile jettyhome = jettyxml.getParentFile().getParentFile();\n\t    \t\t\tSystem.setProperty(\"jetty.home\", jettyhome.getAbsolutePath());\n\t    \t\t}\n\t    \t}\n    \t}\n    \tFile _installLocation = BUNDLE_FILE_LOCATOR_HELPER.getBundleInstallLocation(context.getBundle());\n        // debug:\n        // new File(\"~/proj/eclipse-install/eclipse-3.5.1-SDK-jetty7/\" +\n        // \"dropins/jetty7/plugins/org.eclipse.jetty.osgi.boot_0.0.1.001-SNAPSHOT.jar\");\n        boolean bootBundleCanBeJarred = true;\n        String jettyHome = stripQuotesIfPresent(System.getProperty(\"jetty.home\"));\n\n        if (jettyHome == null || jettyHome.length() == 0)\n        {\n            if (_installLocation.getName().endsWith(\".jar\"))\n            {\n                jettyHome = JettyHomeHelper.setupJettyHomeInEclipsePDE(_installLocation);\n            }\n            if (jettyHome == null)\n            {\n                jettyHome = _installLocation.getAbsolutePath() + \"/jettyhome\";\n                bootBundleCanBeJarred = false;\n            }\n        }\n        // in case we stripped the quotes.\n        System.setProperty(\"jetty.home\",jettyHome);\n\n        String jettyLogs = stripQuotesIfPresent(System.getProperty(\"jetty.logs\"));\n        if (jettyLogs == null || jettyLogs.length() == 0)\n        {\n            System.setProperty(\"jetty.logs\",jettyHome + \"/logs\");\n        }\n\n        if (!bootBundleCanBeJarred && !_installLocation.isDirectory())\n        {\n            String install = _installLocation != null?_installLocation.getCanonicalPath():\" unresolved_install_location\";\n            throw new IllegalArgumentException(\"The system property -Djetty.home\" + \" must be set to a directory or the bundle \"\n                    + context.getBundle().getSymbolicName() + \" installed here \" + install + \" must be unjarred.\");\n        }\n        try\n        {\n            System.err.println(\"JETTY_HOME set to \" + new File(jettyHome).getCanonicalPath());\n        }\n        catch (Throwable t)\n        {\n            System.err.println(\"JETTY_HOME _set to \" + new File(jettyHome).getAbsolutePath());\n        }\n\n        ClassLoader contextCl = Thread.currentThread().getContextClassLoader();\n        try\n        {\n\n            // passing this bundle's classloader as the context classlaoder\n            // makes sure there is access to all the jetty's bundles\n\n            File jettyHomeF = new File(jettyHome);\n            URLClassLoader libExtClassLoader = null;\n            try\n            {\n            \tlibExtClassLoader = LibExtClassLoaderHelper.createLibEtcClassLoaderHelper(jettyHomeF,_server,\n            \t\t\tJettyBootstrapActivator.class.getClassLoader());\n            }\n            catch (MalformedURLException e)\n            {\n                e.printStackTrace();\n            }\n\n            Thread.currentThread().setContextClassLoader(libExtClassLoader);\n\n            String jettyetc = System.getProperty(OSGiWebappConstants.SYS_PROP_JETTY_ETC_FILES,\"etc/jetty.xml\");\n            StringTokenizer tokenizer = new StringTokenizer(jettyetc,\";,\");\n            \n            Map<Object,Object> id_map = new HashMap<Object,Object>();\n            id_map.put(\"Server\",_server);\n            Map<Object,Object> properties = new HashMap<Object,Object>();\n            properties.put(\"jetty.home\",jettyHome);\n            properties.put(\"jetty.host\",System.getProperty(\"jetty.host\",\"\"));\n            properties.put(\"jetty.port\",System.getProperty(\"jetty.port\",\"8080\"));\n            properties.put(\"jetty.port.ssl\",System.getProperty(\"jetty.port.ssl\",\"8443\"));\n\n            while (tokenizer.hasMoreTokens())\n            {\n                String etcFile = tokenizer.nextToken().trim();\n                File conffile = etcFile.startsWith(\"/\")?new File(etcFile):new File(jettyHomeF,etcFile);\n                if (!conffile.exists())\n                {\n                    __logger.warn(\"Unable to resolve the jetty/etc file \" + etcFile);\n\n                    if (\"etc/jetty.xml\".equals(etcFile))\n                    {\n                        // Missing jetty.xml file, so create a minimal Jetty configuration\n                        __logger.info(\"Configuring default server on 8080\");\n                        SelectChannelConnector connector = new SelectChannelConnector();\n                        connector.setPort(8080);\n                        _server.addConnector(connector);\n\n                        HandlerCollection handlers = new HandlerCollection();\n                        ContextHandlerCollection contexts = new ContextHandlerCollection();\n                        RequestLogHandler requestLogHandler = new RequestLogHandler();\n                        handlers.setHandlers(new Handler[] { contexts, new DefaultHandler(), requestLogHandler });\n                        _server.setHandler(handlers);\n                    }\n                }\n                else\n                {\n                    try\n                    {\n                        // Execute a Jetty configuration file\n                        XmlConfiguration config = new XmlConfiguration(new FileInputStream(conffile));\n                        config.setIdMap(id_map);\n                        config.setProperties(properties);\n                        config.configure();\n                        id_map=config.getIdMap();\n                    }\n                    catch (SAXParseException saxparse)\n                    {\n                        Log.getLogger(WebappRegistrationHelper.class.getName()).warn(\"Unable to configure the jetty/etc file \" + etcFile,saxparse);\n                        throw saxparse;\n                    }\n                }\n            }\n\n            init();\n\n            //now that we have an app provider we can call the registration customizer.\n            try\n            {\n                URL[] jarsWithTlds = getJarsWithTlds();\n                _commonParentClassLoaderForWebapps = jarsWithTlds == null?libExtClassLoader:new TldLocatableURLClassloader(libExtClassLoader,getJarsWithTlds());\n            }\n            catch (MalformedURLException e)\n            {\n                e.printStackTrace();\n            }\n\n            \n            _server.start();\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n        }\n        finally\n        {\n            Thread.currentThread().setContextClassLoader(contextCl);\n        }\n\n    }","commit_id":"ce7a271f7da2ffe4b5a24221e4a960bea15d004d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Finds all possible Components on the classpath and Registry\n     */\n    public static SortedMap<String, Properties> findComponents(CamelContext camelContext) throws LoadPropertiesException {\n        SortedMap<String, Properties> map = new TreeMap<String, Properties>();\n        Enumeration<URL> iter = camelContext.getClassResolver().loadResourcesAsURL(COMPONENT_DESCRIPTOR);\n        while (iter.hasMoreElements()) {\n            URL url = iter.nextElement();\n            try {\n                Properties properties = new Properties();\n                properties.load(url.openStream());\n                String names = properties.getProperty(\"components\");\n                if (names != null) {\n                    StringTokenizer tok = new StringTokenizer(names);\n                    while (tok.hasMoreTokens()) {\n                        String name = tok.nextToken();\n                        map.put(name, properties);\n                    }\n                }\n            } catch (IOException e) {\n                throw new LoadPropertiesException(url, e);\n            }\n        }\n\n        // lets see what other components are in the registry\n        Map<String, Component> beanMap = camelContext.getRegistry().findByTypeWithName(Component.class);\n        Set<Map.Entry<String, Component>> entries = beanMap.entrySet();\n        for (Map.Entry<String, Component> entry : entries) {\n            String name = entry.getKey();\n            if (!map.containsKey(name)) {\n                Properties properties = new Properties();\n                Component component = entry.getValue();\n                if (component != null) {\n                    properties.put(\"component\", component);\n                    properties.put(\"class\", component.getClass().getName());\n                    map.put(name, properties);\n                }\n            }\n        }\n        return map;\n    }","id":40977,"modified_method":"/**\n     * Finds all possible Components on the classpath and Registry\n     */\n    public static SortedMap<String, Properties> findComponents(CamelContext camelContext) throws LoadPropertiesException {\n        SortedMap<String, Properties> map = new TreeMap<String, Properties>();\n        Enumeration<URL> iter = camelContext.getClassResolver().loadResourcesAsURL(COMPONENT_DESCRIPTOR);\n        while (iter != null && iter.hasMoreElements()) {\n            URL url = iter.nextElement();\n            try {\n                Properties properties = new Properties();\n                properties.load(url.openStream());\n                String names = properties.getProperty(\"components\");\n                if (names != null) {\n                    StringTokenizer tok = new StringTokenizer(names);\n                    while (tok.hasMoreTokens()) {\n                        String name = tok.nextToken();\n                        map.put(name, properties);\n                    }\n                }\n            } catch (IOException e) {\n                throw new LoadPropertiesException(url, e);\n            }\n        }\n\n        // lets see what other components are in the registry\n        Map<String, Component> beanMap = camelContext.getRegistry().findByTypeWithName(Component.class);\n        Set<Map.Entry<String, Component>> entries = beanMap.entrySet();\n        for (Map.Entry<String, Component> entry : entries) {\n            String name = entry.getKey();\n            if (!map.containsKey(name)) {\n                Properties properties = new Properties();\n                Component component = entry.getValue();\n                if (component != null) {\n                    properties.put(\"component\", component);\n                    properties.put(\"class\", component.getClass().getName());\n                    map.put(name, properties);\n                }\n            }\n        }\n        return map;\n    }","commit_id":"2fe5d2acaf9f3d1b1c91001007645364f6dbfd90","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /* Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n        Set<WebXml> defaults = new HashSet<WebXml>();\n        defaults.add(getDefaultWebXmlFragment());\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        parseWebXml(contextWebXml, webXml, false);\n\n        if (webXml.getMajorVersion() >= 3) {\n            // Ordering is important here\n\n            // Step 1. Identify all the JARs packaged with the application\n            // If the JARs have a web-fragment.xml it will be parsed at this\n            // point.\n            Map<String,WebXml> fragments = processJarsForWebFragments();\n\n            // Only need to process fragments and annotations if metadata is\n            // not complete\n            Set<WebXml> orderedFragments = null;\n            if  (!webXml.isMetadataComplete()) {\n                // Step 2. Order the fragments.\n                orderedFragments = WebXml.orderWebFragments(webXml, fragments);\n\n                // Step 3. Look for ServletContainerInitializer implementations\n                if (ok) {\n                    processServletContainerInitializers(orderedFragments);\n                }\n\n                // Step 4. Process /WEB-INF/classes for annotations\n                // This will add any matching classes to the typeInitializerMap\n                if (ok) {\n                    try {\n                        NamingEnumeration<Binding> listBindings =\n                            context.getResources().listBindings(\"/WEB-INF/classes\");\n                        while (listBindings.hasMoreElements()) {\n                            Binding binding = listBindings.nextElement();\n                            if (binding.getObject() instanceof FileDirContext) {\n                                File webInfCLassDir =\n                                    new File(\n                                        ((FileDirContext) binding.getObject()).getDocBase());\n                                processAnnotationsFile(webInfCLassDir, webXml);\n                            }\n                        }\n                    } catch (NamingException e) {\n                        log.error(sm.getString(\n                            \"contextConfig.webinfClassesUrl\"), e);\n                    }\n                }\n\n                // Step 5. Process JARs for annotations - only need to process\n                // those fragments we are going to use\n                // This will add any matching classes to the typeInitializerMap\n                if (ok) {\n                    processAnnotations(orderedFragments);\n                }\n\n                // Step 6. Merge web-fragment.xml files into the main web.xml\n                // file.\n                if (ok) {\n                    ok = webXml.merge(orderedFragments);\n                }\n\n                // Step 7. Apply global defaults\n                // Have to merge defaults before JSP conversion since defaults\n                // provide JSP servlet definition.\n                webXml.merge(defaults);\n\n                // Step 8. Convert explicitly mentioned jsps to servlets\n                if (ok) {\n                    convertJsps(webXml);\n                }\n\n                // Step 9. Apply merged web.xml to Context\n                if (ok) {\n                    webXml.configureContext(context);\n\n                    // Step 9a. Make the merged web.xml available to other\n                    // components, specifically Jasper, to save those components\n                    // from having to re-generate it.\n                    // TODO Use a ServletContainerInitializer for Jasper\n                    String mergedWebXml = webXml.toXml();\n                    context.getServletContext().setAttribute(\n                           org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,\n                            mergedWebXml);\n                    if (context.getLogEffectiveWebXml()) {\n                        log.info(\"web.xml:\\n\" + mergedWebXml);\n                    }\n                }\n            } else {\n                webXml.merge(defaults);\n                webXml.configureContext(context);\n            }\n\n            // Always need to look for static resources\n            // Step 10. Look for static resources packaged in JARs\n            if (ok) {\n                // Spec does not define an order.\n                // Use ordered JARs followed by remaining JARs\n                Set<WebXml> resourceJars = new LinkedHashSet<WebXml>();\n                if (orderedFragments != null) {\n                    for (WebXml fragment : orderedFragments) {\n                        resourceJars.add(fragment);\n                    }\n                }\n                for (WebXml fragment : fragments.values()) {\n                    if (!resourceJars.contains(fragment)) {\n                        resourceJars.add(fragment);\n                    }\n                }\n                processResourceJARs(resourceJars);\n                // See also StandardContext.resourcesStart() for\n                // WEB-INF/classes/META-INF/resources configuration\n            }\n\n            // Only look for ServletContainerInitializer if metadata is not\n            // complete\n            if (!webXml.isMetadataComplete()) {\n                // Step 11. Apply the ServletContainerInitializer config to the\n                // context\n                if (ok) {\n                    for (Map.Entry<ServletContainerInitializer,\n                            Set<Class<?>>> entry :\n                                initializerClassMap.entrySet()) {\n                        if (entry.getValue().isEmpty()) {\n                            context.addServletContainerInitializer(\n                                    entry.getKey(), null);\n                        } else {\n                            context.addServletContainerInitializer(\n                                    entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n            }\n        } else {\n            // Apply unmerged web.xml to Context\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            webXml.configureContext(context);\n        }\n    }","id":40978,"modified_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /* Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n        Set<WebXml> defaults = new HashSet<WebXml>();\n        defaults.add(getDefaultWebXmlFragment());\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        parseWebXml(contextWebXml, webXml, false);\n\n        if (webXml.getMajorVersion() >= 3) {\n            // Ordering is important here\n\n            // Step 1. Identify all the JARs packaged with the application\n            // If the JARs have a web-fragment.xml it will be parsed at this\n            // point.\n            Map<String,WebXml> fragments = processJarsForWebFragments();\n\n            // Only need to process fragments and annotations if metadata is\n            // not complete\n            Set<WebXml> orderedFragments = null;\n            if  (!webXml.isMetadataComplete()) {\n                // Step 2. Order the fragments.\n                orderedFragments = WebXml.orderWebFragments(webXml, fragments);\n\n                // Step 3. Look for ServletContainerInitializer implementations\n                if (ok) {\n                    processServletContainerInitializers(orderedFragments);\n                }\n\n                // Step 4. Process /WEB-INF/classes for annotations\n                // This will add any matching classes to the typeInitializerMap\n                if (ok) {\n                    NamingEnumeration<Binding> listBindings = null;\n                    try {\n                        try {\n                            listBindings = context.getResources().listBindings(\n                                    \"/WEB-INF/classes\");\n                        } catch (NameNotFoundException ignore) {\n                            // Safe to ignore\n                        }\n                        while (listBindings != null &&\n                                listBindings.hasMoreElements()) {\n                            Binding binding = listBindings.nextElement();\n                            if (binding.getObject() instanceof FileDirContext) {\n                                File webInfCLassDir = new File(\n                                        ((FileDirContext) binding.getObject()).getDocBase());\n                                processAnnotationsFile(webInfCLassDir, webXml);\n                            }\n                        }\n                    } catch (NamingException e) {\n                        log.error(sm.getString(\n                            \"contextConfig.webinfClassesUrl\"), e);\n                    }\n                }\n\n                // Step 5. Process JARs for annotations - only need to process\n                // those fragments we are going to use\n                // This will add any matching classes to the typeInitializerMap\n                if (ok) {\n                    processAnnotations(orderedFragments);\n                }\n\n                // Step 6. Merge web-fragment.xml files into the main web.xml\n                // file.\n                if (ok) {\n                    ok = webXml.merge(orderedFragments);\n                }\n\n                // Step 7. Apply global defaults\n                // Have to merge defaults before JSP conversion since defaults\n                // provide JSP servlet definition.\n                webXml.merge(defaults);\n\n                // Step 8. Convert explicitly mentioned jsps to servlets\n                if (ok) {\n                    convertJsps(webXml);\n                }\n\n                // Step 9. Apply merged web.xml to Context\n                if (ok) {\n                    webXml.configureContext(context);\n\n                    // Step 9a. Make the merged web.xml available to other\n                    // components, specifically Jasper, to save those components\n                    // from having to re-generate it.\n                    // TODO Use a ServletContainerInitializer for Jasper\n                    String mergedWebXml = webXml.toXml();\n                    context.getServletContext().setAttribute(\n                           org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,\n                            mergedWebXml);\n                    if (context.getLogEffectiveWebXml()) {\n                        log.info(\"web.xml:\\n\" + mergedWebXml);\n                    }\n                }\n            } else {\n                webXml.merge(defaults);\n                webXml.configureContext(context);\n            }\n\n            // Always need to look for static resources\n            // Step 10. Look for static resources packaged in JARs\n            if (ok) {\n                // Spec does not define an order.\n                // Use ordered JARs followed by remaining JARs\n                Set<WebXml> resourceJars = new LinkedHashSet<WebXml>();\n                if (orderedFragments != null) {\n                    for (WebXml fragment : orderedFragments) {\n                        resourceJars.add(fragment);\n                    }\n                }\n                for (WebXml fragment : fragments.values()) {\n                    if (!resourceJars.contains(fragment)) {\n                        resourceJars.add(fragment);\n                    }\n                }\n                processResourceJARs(resourceJars);\n                // See also StandardContext.resourcesStart() for\n                // WEB-INF/classes/META-INF/resources configuration\n            }\n\n            // Only look for ServletContainerInitializer if metadata is not\n            // complete\n            if (!webXml.isMetadataComplete()) {\n                // Step 11. Apply the ServletContainerInitializer config to the\n                // context\n                if (ok) {\n                    for (Map.Entry<ServletContainerInitializer,\n                            Set<Class<?>>> entry :\n                                initializerClassMap.entrySet()) {\n                        if (entry.getValue().isEmpty()) {\n                            context.addServletContainerInitializer(\n                                    entry.getKey(), null);\n                        } else {\n                            context.addServletContainerInitializer(\n                                    entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n            }\n        } else {\n            // Apply unmerged web.xml to Context\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            webXml.configureContext(context);\n        }\n    }","commit_id":"32774944c3a754dc568a2fc2a90cadafc86333be","url":"https://github.com/apache/tomcat"},{"original_method":"private void truncateTables() {\n    Connection connection = null;\n    try {\n      connection = datasource.getConnection();\n\n      DatabaseMetaData meta = connection.getMetaData();\n\n      ResultSet res = meta.getTables(null, null, null, new String[] { \"TABLE\" });\n      while (res.next()) {\n        String tableName = res.getString(\"TABLE_NAME\");\n        connection.prepareStatement(\"TRUNCATE TABLE \" + tableName).execute();\n      }\n      res.close();\n\n      // See https://issues.apache.org/jira/browse/DERBY-5403\n      res = meta.getColumns(null, null, null, \"ID\");\n      while (res.next()) {\n        String tableName = res.getString(\"TABLE_NAME\");\n        connection.prepareStatement(\"ALTER TABLE \" + tableName + \" ALTER COLUMN ID RESTART WITH 1\").execute();\n      }\n      res.close();\n\n    } catch (SQLException e) {\n      throw new IllegalStateException(\"Fail to truncate tables\", e);\n\n    } finally {\n      closeQuietly(connection); // Important, otherwise tests can stuck\n    }\n  }","id":40979,"modified_method":"private void truncateTables() {\n    Connection connection = null;\n    try {\n      connection = datasource.getConnection();\n\n      DatabaseMetaData meta = connection.getMetaData();\n      Statement statement = connection.createStatement();\n\n      ResultSet res = meta.getTables(null, null, null, new String[] { \"TABLE\" });\n      while (res.next()) {\n        String tableName = res.getString(\"TABLE_NAME\");\n        statement.executeUpdate(\"TRUNCATE TABLE \" + tableName);\n      }\n      res.close();\n\n      // See https://issues.apache.org/jira/browse/DERBY-5403\n      res = meta.getColumns(null, null, null, \"ID\");\n      while (res.next()) {\n        String tableName = res.getString(\"TABLE_NAME\");\n        statement.executeUpdate(\"ALTER TABLE \" + tableName + \" ALTER COLUMN ID RESTART WITH 1\");\n      }\n      res.close();\n\n      statement.close();\n    } catch (SQLException e) {\n      throw new IllegalStateException(\"Fail to truncate tables\", e);\n\n    } finally {\n      closeQuietly(connection); // Important, otherwise tests can stuck\n    }\n  }","commit_id":"30161cdacfd051bcf339fcc0b8c9ad1307370765","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * IMPORTANT: DB name changed from \"sonar\" to \"sonar2\" in order to not conflict with {@link org.sonar.test.persistence.DatabaseTestCase}\n   */\n  void startDatabase() {\n    try {\n      Properties properties = new Properties();\n      properties.put(\"driverClassName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n      properties.put(\"username\", \"sonar\");\n      properties.put(\"password\", \"sonar\");\n      properties.put(\"url\", \"jdbc:derby:memory:sonar2;create=true;user=sonar;password=sonar\");\n\n      // limit to 2 because of Hibernate and MyBatis\n      properties.put(\"maxActive\", \"2\");\n      properties.put(\"maxIdle\", \"2\");\n      datasource = (BasicDataSource) BasicDataSourceFactory.createDataSource(properties);\n\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Fail to start Derby\", e);\n    }\n  }","id":40980,"modified_method":"/**\n   * IMPORTANT: DB name changed from \"sonar\" to \"sonar2\" in order to not conflict with {@link DefaultDatabaseTest}\n   */\n  void startDatabase() {\n    try {\n      Properties properties = new Properties();\n      properties.put(\"driverClassName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n      properties.put(\"username\", \"sonar\");\n      properties.put(\"password\", \"sonar\");\n      properties.put(\"url\", \"jdbc:derby:memory:sonar2;create=true;user=sonar;password=sonar\");\n\n      // limit to 2 because of Hibernate and MyBatis\n      properties.put(\"maxActive\", \"2\");\n      properties.put(\"maxIdle\", \"2\");\n      datasource = (BasicDataSource) BasicDataSourceFactory.createDataSource(properties);\n\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Fail to start Derby\", e);\n    }\n  }","commit_id":"30161cdacfd051bcf339fcc0b8c9ad1307370765","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCloseReviewWithoutCorrespondingViolation() throws Exception {\n    setupData(\"purgeOrphanReviews\");\n\n    Statement stmt = getConnection().createStatement();\n    int count = stmt.executeUpdate(new PurgeOrphanReviews(null).getDeleteReviewsSqlRequest());\n    assertThat(count, is(1));\n\n    count = stmt.executeUpdate(new PurgeOrphanReviews(null).getDeleteReviewCommentsSqlRequest());\n    assertThat(count, is(1));\n\n    assertTables(\"purgeOrphanReviews\", \"reviews\");\n  }","id":40981,"modified_method":"@Test\n  public void shouldCloseReviewWithoutCorrespondingViolation() throws Exception {\n    setupData(\"purgeOrphanReviews\");\n\n    Statement stmt = getConnection().getConnection().createStatement();\n    int count = stmt.executeUpdate(new PurgeOrphanReviews(null).getDeleteReviewsSqlRequest());\n    assertThat(count, is(1));\n\n    count = stmt.executeUpdate(new PurgeOrphanReviews(null).getDeleteReviewCommentsSqlRequest());\n    assertThat(count, is(1));\n\n    checkTables(\"purgeOrphanReviews\", \"reviews\");\n  }","commit_id":"30161cdacfd051bcf339fcc0b8c9ad1307370765","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void currentVersionShouldBeUnknownWhenSchemaIsEmpty() throws Exception {\n    HsqlDatabase hsqlDatabase = new HsqlDatabase();\n    hsqlDatabase.start();\n\n    MemoryDatabaseConnector connector = new MemoryDatabaseConnector(hsqlDatabase, SchemaMigration.VERSION_UNKNOWN);\n    connector.start();\n\n    Connection connection = Mockito.mock(Connection.class);\n    try {\n      connection = connector.getConnection();\n      assertEquals(SchemaMigration.VERSION_UNKNOWN, SchemaMigration.getCurrentVersion(connection));\n    } finally {\n      if (connection != null) {\n        connection.close();\n      }\n    }\n    connector.stop();\n    hsqlDatabase.stop();\n  }","id":40982,"modified_method":"@Test\n  public void currentVersionShouldBeUnknownWhenSchemaIsEmpty() throws Exception {\n    Database database = new InMemoryDatabase();\n    database.start();\n\n    MemoryDatabaseConnector connector = new MemoryDatabaseConnector(database, SchemaMigration.VERSION_UNKNOWN);\n    connector.start();\n\n    Connection connection = null;\n    try {\n      connection = connector.getConnection();\n      assertEquals(SchemaMigration.VERSION_UNKNOWN, SchemaMigration.getCurrentVersion(connection));\n    } finally {\n      if (connection != null) {\n        connection.close();\n      }\n    }\n    connector.stop();\n    database.stop();\n  }","commit_id":"30161cdacfd051bcf339fcc0b8c9ad1307370765","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void versionShouldBeLoadedFromSchemaMigrationsTable() throws Exception {\n    HsqlDatabase hsqlDatabase = new HsqlDatabase();\n    hsqlDatabase.start();\n    MemoryDatabaseConnector connector = new MemoryDatabaseConnector(hsqlDatabase, 30);\n    connector.start();\n\n    Connection connection = null;\n    try {\n      connection = connector.getConnection();\n      assertEquals(30, SchemaMigration.getCurrentVersion(connection));\n\n    } finally {\n      if (connection != null) {\n        connection.close();\n      }\n    }\n    connector.stop();\n    hsqlDatabase.stop();\n  }","id":40983,"modified_method":"@Test\n  public void versionShouldBeLoadedFromSchemaMigrationsTable() throws Exception {\n    Database database = new InMemoryDatabase();\n    database.start();\n    MemoryDatabaseConnector connector = new MemoryDatabaseConnector(database, 30);\n    connector.start();\n\n    Connection connection = null;\n    try {\n      connection = connector.getConnection();\n      assertEquals(30, SchemaMigration.getCurrentVersion(connection));\n\n    } finally {\n      if (connection != null) {\n        connection.close();\n      }\n    }\n    connector.stop();\n    database.stop();\n  }","commit_id":"30161cdacfd051bcf339fcc0b8c9ad1307370765","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public KernelNodeStateEditor edit(String name) {\n        TransientKernelNodeState childState = transientState.getChildNode(name);\n        return childState == null\n            ? null\n            : childState.getEditor();\n    }","id":40984,"modified_method":"@Override\n    public KernelNodeStateEditor edit(String path) {\n        TransientKernelNodeState state = getTransientState(path);\n        return state == null\n            ? null\n            : state.getEditor();\n    }","commit_id":"24f55c225e011c6902bbacea7db64d6183ef637b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                for (String element : PathUtils.elements(parentPath)) {\n                    editor = editor.edit(element);\n                }\n                editor.removeProperty(name);\n            }","id":40985,"modified_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                editor.edit(parentPath).removeProperty(name);\n            }","commit_id":"24f55c225e011c6902bbacea7db64d6183ef637b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                for (String element : PathUtils.elements(parentPath)) {\n                    editor = editor.edit(element);\n                }\n                editor.addNode(name);\n            }","id":40986,"modified_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                editor.edit(parentPath).addNode(name);\n            }","commit_id":"24f55c225e011c6902bbacea7db64d6183ef637b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                for (String element : PathUtils.elements(PathUtils.getParentPath(path))) {\n                    editor = editor.edit(element);\n                }\n                editor.removeNode(PathUtils.getName(path));\n            }","id":40987,"modified_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                String parentPath = PathUtils.getParentPath(path);\n                String name = PathUtils.getName(path);\n                editor.edit(parentPath).removeNode(name);\n            }","commit_id":"24f55c225e011c6902bbacea7db64d6183ef637b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                for (String element : PathUtils.elements(parentPath)) {\n                    editor = editor.edit(element);\n                }\n                editor.setProperty(propertyName, propertyValue);\n            }","id":40988,"modified_method":"@Override\n            void apply(KernelNodeStateEditor editor) {\n                editor.edit(parentPath).setProperty(propertyName, propertyValue);\n            }","commit_id":"24f55c225e011c6902bbacea7db64d6183ef637b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"PropertyDelegate getPropertyOrNull(String relOakPath)\r\n            throws RepositoryException {\r\n\r\n        String absPath = Paths.concat(getPath(),\r\n                Paths.getParentPath(relOakPath));\r\n        Tree parent = getRoot().getTree(absPath);\r\n        if (parent == null) {\r\n            return null;\r\n        }\r\n\r\n        String name = Paths.getName(relOakPath);\r\n        PropertyState propertyState = parent.getProperty(name);\r\n        return propertyState == null ? null : new PropertyDelegate(\r\n                sessionContext, parent, propertyState);\r\n    }","id":40989,"modified_method":"PropertyDelegate getPropertyOrNull(String relOakPath)\r\n            throws RepositoryException {\r\n\r\n        Tree parent = getTree(Paths.getParentPath(relOakPath));\r\n        if (parent == null) {\r\n            return null;\r\n        }\r\n\r\n        String name = Paths.getName(relOakPath);\r\n        PropertyState propertyState = parent.getProperty(name);\r\n        return propertyState == null ? null : new PropertyDelegate(\r\n                sessionContext, parent, propertyState);\r\n    }","commit_id":"d8c9008794e9a0fef1382dd5069c36aa4780c697","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"NodeDelegate getNodeOrNull(String relOakPath) {\r\n        String absPath = Paths.concat(getPath(), relOakPath);\r\n        Tree tree = getRoot().getTree(absPath);\r\n        return tree == null ? null : new NodeDelegate(sessionContext, tree);\r\n    }","id":40990,"modified_method":"NodeDelegate getNodeOrNull(String relOakPath) {\r\n        Tree tree = getTree(relOakPath);\r\n        return tree == null ? null : new NodeDelegate(sessionContext, tree);\r\n    }","commit_id":"d8c9008794e9a0fef1382dd5069c36aa4780c697","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"NodeDelegate addNode(String relPath) throws RepositoryException {\r\n        String parentPath = Paths.concat(getPath(), Paths.getParentPath(relPath));\r\n        Tree parentState = getRoot().getTree(parentPath);\r\n        if (parentState == null) {\r\n            throw new PathNotFoundException(relPath);\r\n        }\r\n\r\n        String name = Paths.getName(relPath);\r\n        parentState.addChild(name);\r\n        return new NodeDelegate(sessionContext, parentState.getChild(name));\r\n    }","id":40991,"modified_method":"NodeDelegate addNode(String relPath) throws RepositoryException {\r\n        Tree parentState = getTree(Paths.getParentPath(relPath));\r\n        if (parentState == null) {\r\n            throw new PathNotFoundException(relPath);\r\n        }\r\n\r\n        String name = Paths.getName(relPath);\r\n        parentState.addChild(name);\r\n        return new NodeDelegate(sessionContext, parentState.getChild(name));\r\n    }","commit_id":"d8c9008794e9a0fef1382dd5069c36aa4780c697","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private synchronized void resolve() {\r\n        parent = getBranch().getTree(parent.getPath());\r\n        String path = Paths.concat(parent.getPath(), propertyState.getName());\r\n\r\n        if (parent == null) {\r\n            propertyState = null;\r\n        } else {\r\n            propertyState = parent.getProperty(Paths.getName(path));\r\n        }\r\n    }","id":40992,"modified_method":"private synchronized void resolve() {\r\n        parent = sessionContext.getTree(parent.getPath());\r\n        String path = Paths.concat(parent.getPath(), propertyState.getName());\r\n\r\n        if (parent == null) {\r\n            propertyState = null;\r\n        } else {\r\n            propertyState = parent.getProperty(Paths.getName(path));\r\n        }\r\n    }","commit_id":"d8c9008794e9a0fef1382dd5069c36aa4780c697","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public boolean launch(@NotNull AndroidRunningState state, @NotNull IDevice device) {\n      if (myActivityName == null) return true;\n      final String activityPath = state.getPackageName() + '/' + myActivityName;\n      ProcessHandler processHandler = state.getProcessHandler();\n      processHandler.notifyTextAvailable(\"Launching application: \" + activityPath + \".\\n\", STDOUT);\n      AndroidRunningState.MyReceiver receiver = new AndroidRunningState.MyReceiver();\n      boolean debug = state.isDebugMode();\n      while (true) {\n        if (state.isStopped()) return false;\n        try {\n          String command = \"am start \" + (debug ? \"-D \" : \"\") + \"-n \\\"\" + activityPath + \"\\\"\";\n          state.executeDeviceCommandAndWriteToConsole(device, command, receiver);\n        }\n        catch (IOException e) {\n          processHandler.notifyTextAvailable(\"Can't launch application (I/O error).\\n\", STDERR);\n        }\n        if (receiver.getErrorType() != 2) {\n          break;\n        }\n        processHandler.notifyTextAvailable(\"Device is not ready. Waiting for \" + AndroidRunningState.WAITING_TIME + \" sec.\\n\", STDOUT);\n        synchronized (state.getRunningLock()) {\n          try {\n            state.getRunningLock().wait(AndroidRunningState.WAITING_TIME * 1000);\n          }\n          catch (InterruptedException e) {\n          }\n        }\n        receiver = new AndroidRunningState.MyReceiver();\n      }\n      boolean success = receiver.getErrorType() == AndroidRunningState.MyReceiver.NO_ERROR;\n      if (success) {\n        processHandler.notifyTextAvailable(receiver.getOutput().toString(), STDOUT);\n      }\n      else {\n        processHandler.notifyTextAvailable(receiver.getOutput().toString(), STDERR);\n      }\n      return success;\n    }","id":40993,"modified_method":"public boolean launch(@NotNull AndroidRunningState state, @NotNull IDevice device) throws IOException {\n      if (myActivityName == null) return true;\n      final String activityPath = state.getPackageName() + '/' + myActivityName;\n      ProcessHandler processHandler = state.getProcessHandler();\n      if (state.isStopped()) return false;\n      processHandler.notifyTextAvailable(\"Launching application: \" + activityPath + \".\\n\", STDOUT);\n      AndroidRunningState.MyReceiver receiver = state.new MyReceiver();\n      boolean debug = state.isDebugMode();\n      while (true) {\n        if (state.isStopped()) return false;\n        String command = \"am start \" + (debug ? \"-D \" : \"\") + \"-n \\\"\" + activityPath + \"\\\"\";\n        state.executeDeviceCommandAndWriteToConsole(device, command, receiver);\n        if (receiver.getErrorType() != 2) {\n          break;\n        }\n        processHandler.notifyTextAvailable(\"Device is not ready. Waiting for \" + AndroidRunningState.WAITING_TIME + \" sec.\\n\", STDOUT);\n        synchronized (state.getRunningLock()) {\n          try {\n            state.getRunningLock().wait(AndroidRunningState.WAITING_TIME * 1000);\n          }\n          catch (InterruptedException e) {\n          }\n        }\n        receiver = state.new MyReceiver();\n      }\n      boolean success = receiver.getErrorType() == AndroidRunningState.NO_ERROR;\n      if (success) {\n        processHandler.notifyTextAvailable(receiver.getOutput().toString(), STDOUT);\n      }\n      else {\n        processHandler.notifyTextAvailable(receiver.getOutput().toString(), STDERR);\n      }\n      return success;\n    }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean installApp(IDevice device, String remotePath, @NotNull String packageName) {\n    getProcessHandler().notifyTextAvailable(\"Installing \" + packageName + \".\\n\", STDOUT);\n    MyReceiver receiver = new MyReceiver();\n    while (true) {\n      if (myStopped) return false;\n      try {\n        executeDeviceCommandAndWriteToConsole(device, \"pm install \\\"\" + remotePath + \"\\\"\", receiver);\n      }\n      catch (IOException e) {\n        LOG.info(e);\n        getProcessHandler().notifyTextAvailable(e.getMessage() + '\\n', STDERR);\n        return false;\n      }\n      if (receiver.errorType != 1 && receiver.errorType != MyReceiver.UNTYPED_ERROR) {\n        break;\n      }\n      getProcessHandler().notifyTextAvailable(\"Device is not ready. Waiting for \" + WAITING_TIME + \" sec.\\n\", STDOUT);\n      synchronized (myLock) {\n        try {\n          myLock.wait(WAITING_TIME * 1000);\n        }\n        catch (InterruptedException e) {\n          LOG.info(e);\n        }\n      }\n      receiver = new MyReceiver();\n    }\n    if (receiver.failureMessage != null && receiver.failureMessage.equals(\"INSTALL_FAILED_ALREADY_EXISTS\")) {\n      if (myStopped) return false;\n      receiver = new MyReceiver();\n      getProcessHandler().notifyTextAvailable(\"Application is already installed. Reinstalling.\\n\", STDOUT);\n      try {\n        executeDeviceCommandAndWriteToConsole(device, \"pm install -r \\\"\" + remotePath + '\\\"', receiver);\n      }\n      catch (IOException e) {\n        LOG.info(e);\n        getProcessHandler().notifyTextAvailable(e.getMessage() + '\\n', STDERR);\n        return false;\n      }\n    }\n    if (!isSuccess(receiver)) {\n      getProcessHandler().notifyTextAvailable(\"Can't reinstall application. Installing from scratch.\\n\", STDOUT);\n      try {\n        executeDeviceCommandAndWriteToConsole(device, \"pm uninstall \\\"\" + remotePath + '\\\"', receiver);\n        executeDeviceCommandAndWriteToConsole(device, \"pm install \\\"\" + remotePath + '\\\"', receiver);\n      }\n      catch (IOException e) {\n        LOG.info(e);\n        getProcessHandler().notifyTextAvailable(e.getMessage() + '\\n', STDERR);\n        return false;\n      }\n    }\n    boolean success = isSuccess(receiver);\n    getProcessHandler().notifyTextAvailable(receiver.output.toString(), success ? STDOUT : STDERR);\n    return success;\n  }","id":40994,"modified_method":"private boolean installApp(IDevice device, String remotePath, @NotNull String packageName) throws IOException {\n    getProcessHandler().notifyTextAvailable(\"Installing \" + packageName + \".\\n\", STDOUT);\n    MyReceiver receiver = new MyReceiver();\n    while (true) {\n      if (myStopped) return false;\n      boolean deviceNotResponding = false;\n      try {\n        executeDeviceCommandAndWriteToConsole(device, \"pm install \\\"\" + remotePath + \"\\\"\", receiver);\n      }\n      catch (ShellCommandUnresponsiveException e) {\n        LOG.info(e);\n        deviceNotResponding = true;\n      }\n      if (!deviceNotResponding && receiver.errorType != 1 && receiver.errorType != UNTYPED_ERROR) {\n        break;\n      }\n      getProcessHandler().notifyTextAvailable(\"Device is not ready. Waiting for \" + WAITING_TIME + \" sec.\\n\", STDOUT);\n      synchronized (myLock) {\n        try {\n          myLock.wait(WAITING_TIME * 1000);\n        }\n        catch (InterruptedException e) {\n          LOG.info(e);\n        }\n      }\n      receiver = new MyReceiver();\n    }\n    if (receiver.failureMessage != null && receiver.failureMessage.equals(\"INSTALL_FAILED_ALREADY_EXISTS\")) {\n      if (myStopped) return false;\n      receiver = new MyReceiver();\n      getProcessHandler().notifyTextAvailable(\"Application is already installed. Reinstalling.\\n\", STDOUT);\n      executeDeviceCommandAndWriteToConsole(device, \"pm install -r \\\"\" + remotePath + '\\\"', receiver);\n      if (myStopped) return false;\n    }\n    if (!isSuccess(receiver)) {\n      getProcessHandler().notifyTextAvailable(\"Can't reinstall application. Installing from scratch.\\n\", STDOUT);\n      executeDeviceCommandAndWriteToConsole(device, \"pm uninstall \\\"\" + remotePath + '\\\"', receiver);\n      if (myStopped) return false;\n      executeDeviceCommandAndWriteToConsole(device, \"pm install \\\"\" + remotePath + '\\\"', receiver);\n      if (myStopped) return false;\n    }\n    boolean success = isSuccess(receiver);\n    getProcessHandler().notifyTextAvailable(receiver.output.toString(), success ? STDOUT : STDERR);\n    return success;\n  }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSuccess(MyReceiver receiver) {\n    return receiver.errorType == MyReceiver.NO_ERROR && receiver.failureMessage == null;\n  }","id":40995,"modified_method":"private static boolean isSuccess(MyReceiver receiver) {\n    return receiver.errorType == NO_ERROR && receiver.failureMessage == null;\n  }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isCancelled() {\n      return false;\n    }","id":40996,"modified_method":"public boolean isCancelled() {\n      return myStopped;\n    }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean prepareAndStartApp(IDevice device) {\n    try {\n      StringBuilder deviceMessageBuilder = new StringBuilder(\"Target device: \");\n      deviceMessageBuilder.append(device.getSerialNumber());\n      if (device.getAvdName() != null) {\n        deviceMessageBuilder.append(\" (\").append(device.getAvdName()).append(')');\n      }\n      deviceMessageBuilder.append('\\n');\n      getProcessHandler().notifyTextAvailable(deviceMessageBuilder.toString(), STDOUT);\n      Module module = myFacet.getModule();\n      if (!uploadAndInstall(device, myPackageName, module)) return false;\n      if (!uploadAndInstallDependentModules(device)) return false;\n      return myApplicationLauncher.launch(this, device);\n    }\n    catch (IOException e) {\n      LOG.info(e);\n      getProcessHandler().notifyTextAvailable(\"IOException: \" + e.getMessage(), STDERR);\n      return false;\n    }\n  }","id":40997,"modified_method":"private boolean prepareAndStartApp(IDevice device) {\n    StringBuilder deviceMessageBuilder = new StringBuilder(\"Target device: \");\n    deviceMessageBuilder.append(device.getSerialNumber());\n    if (device.getAvdName() != null) {\n      deviceMessageBuilder.append(\" (\").append(device.getAvdName()).append(')');\n    }\n    deviceMessageBuilder.append('\\n');\n    getProcessHandler().notifyTextAvailable(deviceMessageBuilder.toString(), STDOUT);\n    Module module = myFacet.getModule();\n    try {\n      if (!uploadAndInstall(device, myPackageName, module)) return false;\n      if (!uploadAndInstallDependentModules(device)) return false;\n      return myApplicationLauncher.launch(this, device);\n    }\n    catch (TimeoutException e) {\n      LOG.info(e);\n      getProcessHandler().notifyTextAvailable(\"Error: Connection to ADB failed with a timeout\\n\", STDERR);\n      return false;\n    }\n    catch (AdbCommandRejectedException e) {\n      LOG.info(e);\n      getProcessHandler().notifyTextAvailable(\"Error: Adb refused a command\\n\", STDERR);\n      return false;\n    }\n    catch (IOException e) {\n      LOG.info(e);\n      String message = e.getMessage();\n      getProcessHandler().notifyTextAvailable(\"I/O Error\" + (message != null ? \": \" + message : \"\") + '\\n', STDERR);\n      return false;\n    }\n  }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void executeCommand(IDevice device, String command, AndroidOutputReceiver receiver, boolean infinite) throws IOException {\n    int attempt = 0;\n    while (attempt < 5) {\n      device.executeShellCommand(command, receiver);\n      if (infinite && !receiver.isCancelled()) {\n        attempt++;\n      }\n      else if (receiver.isTryAgain()) {\n        attempt++;\n      }\n      else {\n        break;\n      }\n      receiver.invalidate();\n    }\n  }","id":40998,"modified_method":"@SuppressWarnings({\"DuplicateThrows\"})\n  public static void executeCommand(IDevice device, String command, AndroidOutputReceiver receiver, boolean infinite) throws IOException,\n                                                                                                                             TimeoutException,\n                                                                                                                             AdbCommandRejectedException,\n                                                                                                                             ShellCommandUnresponsiveException {\n    int attempt = 0;\n    while (attempt < 5) {\n      if (infinite) {\n        device.executeShellCommand(command, receiver, 0);\n      }\n      else {\n        device.executeShellCommand(command, receiver);\n      }\n      if (infinite && !receiver.isCancelled()) {\n        attempt++;\n      }\n      else if (receiver.isTryAgain()) {\n        attempt++;\n      }\n      else {\n        break;\n      }\n      receiver.invalidate();\n    }\n  }","commit_id":"2ebe22039afe967099ea01a01bac3ccedbb36137","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LogConsoleBase(@NotNull Project project, @Nullable Reader reader, String title, final boolean buildInActions, LogFilterModel model,\n                        @NotNull GlobalSearchScope scope) {\n    super(new BorderLayout());\n    myProject = project;\n    myTitle = title;\n    myModel = model;\n    myFilters = myModel.getLogFilters();\n    myReaderThread = new ReaderThread(reader);\n    myBuildInActions = buildInActions;\n    TextConsoleBuilder builder = TextConsoleBuilderFactory.getInstance().createBuilder(project, scope);\n    myConsole = builder.getConsole();\n    myConsole.attachToProcess(myProcessHandler);\n    myDisposed = false;\n    myModel.addFilterListener(this);\n  }","id":40999,"modified_method":"public LogConsoleBase(@NotNull Project project, @Nullable Reader reader, String title, final boolean buildInActions, LogFilterModel model,\n                        @NotNull GlobalSearchScope scope){\n    this(project, reader, title, buildInActions, model, scope, new DefaultLogFormatter());\n  }","commit_id":"f22ab2b1671a965d0169b61e6126336df27860e4","url":"https://github.com/JetBrains/intellij-community"}]