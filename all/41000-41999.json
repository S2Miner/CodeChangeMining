[{"original_method":"private int printMessageToConsole(String line) {\n    final ConsoleView console = getConsoleNotNull();\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          console.print(fragment.getText(), consoleViewType);\n        }\n      }\n      return line.length() + 1;\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(line);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          ConsoleViewContentType type = ConsoleViewContentType.getConsoleViewType(key);\n          if (type != null) {\n            final String messagePrefix = processingResult.getMessagePrefix();\n            if (messagePrefix != null) {\n              console.print(messagePrefix, type);\n            }\n            console.print(line + \"\\n\", type);\n            return (messagePrefix != null ? messagePrefix.length() : 0) + line.length() + 1;\n          }\n        }\n      }\n      return 0;\n    }\n  }","id":41000,"modified_method":"private int printMessageToConsole(String line) {\n    final ConsoleView console = getConsoleNotNull();\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          String formattedText = myFormatter.formatMessage(fragment.getText());\n          console.print(formattedText, consoleViewType);\n        }\n      }\n      return line.length() + 1;\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(line);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          ConsoleViewContentType type = ConsoleViewContentType.getConsoleViewType(key);\n          if (type != null) {\n            final String messagePrefix = processingResult.getMessagePrefix();\n            if (messagePrefix != null) {\n              String formattedPrefix = myFormatter.formatPrefix(messagePrefix);\n              console.print(formattedPrefix, type);\n            }\n            String formattedMessage = myFormatter.formatMessage(line);\n            console.print(formattedMessage + \"\\n\", type);\n            return (messagePrefix != null ? messagePrefix.length() : 0) + line.length() + 1;\n          }\n        }\n      }\n      return 0;\n    }\n  }","commit_id":"f22ab2b1671a965d0169b61e6126336df27860e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        myProcessHandler.notifyTextAvailable(fragment.getText(), fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(text);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          final String messagePrefix = processingResult.getMessagePrefix();\n          if (messagePrefix != null) {\n            myProcessHandler.notifyTextAvailable(messagePrefix, key);\n          }\n          myProcessHandler.notifyTextAvailable(text + \"\\n\", key);\n        }\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","id":41001,"modified_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        String formattedMessage = myFormatter.formatMessage(fragment.getText());\n        myProcessHandler.notifyTextAvailable(formattedMessage, fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(text);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          final String messagePrefix = processingResult.getMessagePrefix();\n          if (messagePrefix != null) {\n            String formattedPrefix = myFormatter.formatPrefix(messagePrefix);\n            myProcessHandler.notifyTextAvailable(formattedPrefix, key);\n          }\n          String formattedMessage = myFormatter.formatMessage(text);\n          myProcessHandler.notifyTextAvailable(formattedMessage + \"\\n\", key);\n        }\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","commit_id":"f22ab2b1671a965d0169b61e6126336df27860e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Key processLine(String line) {\n    String tag = null;\n    String pid = null;\n    \n    final Matcher matcher = ANDROID_LOG_MESSAGE_PATTERN.matcher(line);\n    if (matcher.matches()) {\n      String s = matcher.group(1).trim();\n      if (s.length() > 0) {\n        tag = s;\n      }\n      \n      s = matcher.group(2).trim();\n      if (s.length() > 0) {\n        pid = s;\n      }\n    }\n    \n    if (tag != null) {\n      myPrevTag = tag;\n    }\n    \n    if (pid != null) {\n      myPrevPid = pid;\n    }\n    \n    Log.LogLevel logLevel = AndroidLogcatUtil.getLogLevel(line);\n    if (logLevel != null) {\n      myPrevMessageLogLevel = logLevel;\n    }\n    return myPrevMessageLogLevel != null ? getProcessOutputType(myPrevMessageLogLevel) : ProcessOutputTypes.STDOUT;\n  }","id":41002,"modified_method":"@NotNull\n  public MyProcessingResult processLine(String line) {\n    final Matcher matcher = ANDROID_LOG_MESSAGE_PATTERN.matcher(line);\n    final boolean messageHeader = matcher.matches();\n\n    if (messageHeader) {\n      String s = matcher.group(1).trim();\n      if (s.length() > 0) {\n        myPrevTag = s;\n      }\n      \n      s = matcher.group(2).trim();\n      if (s.length() > 0) {\n        myPrevPid = s;\n      }\n    }\n    \n    Log.LogLevel logLevel = AndroidLogcatUtil.getLogLevel(line);\n    if (logLevel != null) {\n      myPrevMessageLogLevel = logLevel;\n    }\n    final Key key = myPrevMessageLogLevel != null ? getProcessOutputType(myPrevMessageLogLevel) : ProcessOutputTypes.STDOUT;\n    \n    \n    final boolean applicable = isApplicable(line); \n    final boolean applicableByCustomFilter = isApplicableByCustomFilter(line);\n\n    String messagePrefix;\n    \n    if (messageHeader) {\n      messagePrefix = null;\n      myMessageBuilder = new StringBuilder(line);\n      myMessageBuilder.append('\\n');\n      myFullMessageApplicable = applicable;\n      myFullMessageApplicableByCustomFilter = applicableByCustomFilter;\n    }\n    else {\n      messagePrefix = (myFullMessageApplicable || applicable) &&\n                      (myFullMessageApplicableByCustomFilter || applicableByCustomFilter) &&\n                      !(myFullMessageApplicable && myFullMessageApplicableByCustomFilter)\n                      ? myMessageBuilder.toString()\n                      : null;\n      myMessageBuilder.append(line).append('\\n');\n      myFullMessageApplicable = myFullMessageApplicable || applicable;\n      myFullMessageApplicableByCustomFilter = myFullMessageApplicableByCustomFilter || applicableByCustomFilter;\n    }\n    \n    return new MyProcessingResult(key,\n                                  myFullMessageApplicable && myFullMessageApplicableByCustomFilter,\n                                  messagePrefix);\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isApplicable(String text) {\n    if (!super.isApplicable(text)) return false;\n    \n    if (!(mySelectedLogFilter == null || mySelectedLogFilter.isAcceptable(text))) {\n      return false;\n    }\n\n    final ConfiguredFilter configuredFilterName = getConfiguredFilter();\n    if (configuredFilterName == null) {\n      return true;\n    }\n\n\n    String tag = null;\n    String pid = null;\n    String message = null;\n    \n    final Matcher matcher = ANDROID_LOG_MESSAGE_PATTERN.matcher(text);\n    if (matcher.matches()) {\n      String s = matcher.group(1).trim();\n      if (s.length() > 0) {\n        tag = s;\n      }\n      \n      s = matcher.group(2).trim();\n      if (s.length() > 0) {\n        pid = s;\n      }\n      \n      s = matcher.group(3).trim();\n      if (s.length() > 0) {\n        message = s;\n      }\n    }\n\n    if (tag == null) {\n      tag = myPrevTag;\n    }\n    \n    if (pid == null) {\n      pid = myPrevPid;\n    }\n\n    return configuredFilterName.isApplicable(message, tag, pid, getLogLevel(text));\n  }","id":41003,"modified_method":"@Override\n  public boolean isApplicable(String text) {\n    if (!super.isApplicable(text)) return false;\n\n    if (!(mySelectedLogFilter == null || mySelectedLogFilter.isAcceptable(text))) {\n      return false;\n    }\n    return true;\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Key processLine(String line) {\n    final String type = LogConsolePreferences.getType(line);\n    Key contentType = type != null\n                      ? LogConsolePreferences.getProcessOutputTypes(type)\n                      : (myPrevType == LogConsolePreferences.ERROR ? ProcessOutputTypes.STDERR : ProcessOutputTypes.STDOUT);\n    if (type != null) {\n      myPrevType = type;\n    }\n    return contentType;\n  }","id":41004,"modified_method":"@NotNull\n  public MyProcessingResult processLine(String line) {\n    final String type = LogConsolePreferences.getType(line);\n    Key contentType = type != null\n                      ? LogConsolePreferences.getProcessOutputTypes(type)\n                      : (myPrevType == LogConsolePreferences.ERROR ? ProcessOutputTypes.STDERR : ProcessOutputTypes.STDOUT);\n    if (type != null) {\n      myPrevType = type;\n    }\n    final boolean applicable = isApplicable(line);\n    return new MyProcessingResult(contentType, applicable, null);\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized void filterConsoleOutput(Condition<String> isApplicable) {\n    myOriginalDocument = getOriginalDocument();\n    if (myOriginalDocument != null) {\n      final Editor editor = getEditor();\n      LOG.assertTrue(editor != null);\n      final Document document = editor.getDocument();\n      final int caretOffset = editor.getCaretModel().getOffset();\n      if (caretOffset > -1) {\n        int line = document.getLineNumber(caretOffset);\n        if (line > -1 && line < document.getLineCount()) {\n          final int startOffset = document.getLineStartOffset(line);\n          myLineUnderSelection = document.getText().substring(startOffset, document.getLineEndOffset(line));\n          myLineOffset = caretOffset - startOffset;\n        }\n      }\n      myConsole.clear();\n      final String[] lines = myOriginalDocument.toString().split(\"\\n\");\n      int offset = 0;\n      boolean caretPositioned = false;\n      for (String line : lines) {\n        if (printMessageToConsole(line, isApplicable)) {\n          if (!caretPositioned) {\n            if (Comparing.strEqual(myLineUnderSelection, line)) {\n              caretPositioned = true;\n              offset += myLineOffset != -1 ? myLineOffset : 0;\n            }\n            else {\n              offset += line.length() + 1;\n            }\n          }\n        }\n      }\n      myConsole.scrollTo(offset);\n    }\n  }","id":41005,"modified_method":"private synchronized void filterConsoleOutput() {\n    myOriginalDocument = getOriginalDocument();\n    if (myOriginalDocument != null) {\n      final Editor editor = getEditor();\n      LOG.assertTrue(editor != null);\n      final Document document = editor.getDocument();\n      final int caretOffset = editor.getCaretModel().getOffset();\n      if (caretOffset > -1) {\n        int line = document.getLineNumber(caretOffset);\n        if (line > -1 && line < document.getLineCount()) {\n          final int startOffset = document.getLineStartOffset(line);\n          myLineUnderSelection = document.getText().substring(startOffset, document.getLineEndOffset(line));\n          myLineOffset = caretOffset - startOffset;\n        }\n      }\n      myConsole.clear();\n      final String[] lines = myOriginalDocument.toString().split(\"\\n\");\n      int offset = 0;\n      boolean caretPositioned = false;\n      for (String line : lines) {\n        if (printMessageToConsole(line)) {\n          if (!caretPositioned) {\n            if (Comparing.strEqual(myLineUnderSelection, line)) {\n              caretPositioned = true;\n              offset += myLineOffset != -1 ? myLineOffset : 0;\n            }\n            else {\n              offset += line.length() + 1;\n            }\n          }\n        }\n      }\n      myConsole.scrollTo(offset);\n    }\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onTextFilterChange() {\n    filterConsoleOutput(new Condition<String>() {\n      public boolean value(final String line) {\n        return myModel.isApplicable(line);\n      }\n    });\n  }","id":41006,"modified_method":"public void onTextFilterChange() {\n    filterConsoleOutput();\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onFilterStateChange(final LogFilter filter) {\n    filterConsoleOutput(new Condition<String>() {\n      public boolean value(final String line) {\n        return myModel.isApplicable(line);\n      }\n    });\n  }","id":41007,"modified_method":"public void onFilterStateChange(final LogFilter filter) {\n    filterConsoleOutput();\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final java.util.List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        myProcessHandler.notifyTextAvailable(fragment.getText(), fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      Key key = myModel.processLine(text);\n      if (myModel.isApplicable(text)) {\n        if (key != null) {\n          myProcessHandler.notifyTextAvailable(text + \"\\n\", key);\n        }\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","id":41008,"modified_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final java.util.List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        myProcessHandler.notifyTextAvailable(fragment.getText(), fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(text);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          final String messagePrefix = processingResult.getMessagePrefix();\n          if (messagePrefix != null) {\n            myProcessHandler.notifyTextAvailable(messagePrefix, key);\n          }\n          myProcessHandler.notifyTextAvailable(text + \"\\n\", key);\n        }\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean printMessageToConsole(String line, Condition<String> isApplicable) {\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          myConsole.print(fragment.getText(), consoleViewType);\n        }\n      }\n    }\n    else {\n      Key key = myModel.processLine(line);\n      if (isApplicable.value(line) && key != null) {\n        ConsoleViewContentType type = ConsoleViewContentType.getConsoleViewType(key);\n        if (type != null) {\n          myConsole.print(line + \"\\n\", type);\n        }\n      }\n    }\n    return true;\n  }","id":41009,"modified_method":"private boolean printMessageToConsole(String line) {\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          myConsole.print(fragment.getText(), consoleViewType);\n        }\n      }\n    }\n    else {\n      final LogFilterModel.MyProcessingResult processingResult = myModel.processLine(line);\n      if (processingResult.isApplicable()) {\n        final Key key = processingResult.getKey();\n        if (key != null) {\n          ConsoleViewContentType type = ConsoleViewContentType.getConsoleViewType(key);\n          if (type != null) {\n            final String messagePrefix = processingResult.getMessagePrefix();\n            if (messagePrefix != null) {\n              myConsole.print(messagePrefix, type);\n            }\n            myConsole.print(line + \"\\n\", type);\n          }\n        }\n      }\n    }\n    return true;\n  }","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public abstract Key processLine(String line);","id":41010,"modified_method":"@NotNull\n  public abstract MyProcessingResult processLine(String line);","commit_id":"6278d14365a9e508699a4bb125c3eec32c843002","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final java.util.List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        myProcessHandler.notifyTextAvailable(fragment.getText(), fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      if (myModel.isApplicable(text)) {\n        myProcessHandler.notifyTextAvailable(text + \"\\n\", myModel.processLine(text));\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","id":41011,"modified_method":"protected synchronized void addMessage(final String text) {\n    if (text == null) return;\n    if (myContentPreprocessor != null) {\n      final java.util.List<LogFragment> fragments = myContentPreprocessor.parseLogLine(text + \"\\n\");\n      myOriginalDocument = getOriginalDocument();\n      for (LogFragment fragment : fragments) {\n        myProcessHandler.notifyTextAvailable(fragment.getText(), fragment.getOutputType());\n        if (myOriginalDocument != null) {\n          myOriginalDocument.append(fragment.getText());\n        }\n      }\n    }\n    else {\n      if (myModel.isApplicable(text)) {\n        Key key = myModel.processLine(text);\n        if (key != null) {\n          myProcessHandler.notifyTextAvailable(text + \"\\n\", key);\n        }\n      }\n      myOriginalDocument = getOriginalDocument();\n      if (myOriginalDocument != null) {\n        myOriginalDocument.append(text).append(\"\\n\");\n      }\n    }\n  }","commit_id":"e38d642d846778bdd7d6941248ef432f3e1f2e13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean printMessageToConsole(String line, Condition<String> isApplicable) {\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          myConsole.print(fragment.getText(), consoleViewType);\n        }\n      }\n    }\n    else if (isApplicable.value(line)) {\n      Key key = myModel.processLine(line);\n      myConsole.print(line + \"\\n\", ConsoleViewContentType.getConsoleViewType(key));\n    }\n    return true;\n  }","id":41012,"modified_method":"private boolean printMessageToConsole(String line, Condition<String> isApplicable) {\n    if (myContentPreprocessor != null) {\n      List<LogFragment> fragments = myContentPreprocessor.parseLogLine(line + '\\n');\n      for (LogFragment fragment : fragments) {\n        ConsoleViewContentType consoleViewType = ConsoleViewContentType.getConsoleViewType(fragment.getOutputType());\n        if (consoleViewType != null) {\n          myConsole.print(fragment.getText(), consoleViewType);\n        }\n      }\n    }\n    else if (isApplicable.value(line)) {\n      Key key = myModel.processLine(line);\n      if (key != null) {\n        ConsoleViewContentType type = ConsoleViewContentType.getConsoleViewType(key);\n        if (type != null) {\n          myConsole.print(line + \"\\n\", type);\n        }\n      }\n    }\n    return true;\n  }","commit_id":"e38d642d846778bdd7d6941248ef432f3e1f2e13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void handleOrphan( Cluster cluster, ClusterAddressInfo address ) {\n    Integer orphanCount = 1;\n    orphanCount = orphans.putIfAbsent( address, orphanCount );\n    orphanCount = ( orphanCount == null )\n      ? 1\n      : orphanCount;\n    orphans.put( address, orphanCount + 1 );\n    EventRecord.caller( ClusterState.class, EventType.ADDRESS_STATE,\n                        \"Updated orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount ).debug( );\n    if ( orphanCount > AddressingConfiguration.getInstance( ).getMaxKillOrphans( ) ) {\n      EventRecord.caller( ClusterState.class, EventType.ADDRESS_STATE,\n                          \"Unassigning orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount ).warn( );\n      try {\n        final Address addr = Addresses.getInstance( ).lookup( address.getAddress( ) );\n        try {\n          if ( addr.isAssigned( ) ) {\n            AsyncRequests.newRequest( new UnassignAddressCallback( address ) ).sendSync( cluster.getConfiguration( ) );\n          } else if ( !addr.isAssigned( ) && addr.isAllocated( ) && addr.isSystemOwned( ) ) {\n            addr.release( );\n          }\n        } catch ( ExecutionException ex ) {\n          if ( !addr.isAssigned( ) && addr.isAllocated( ) && addr.isSystemOwned( ) ) {\n            addr.release( );\n          }\n        }\n      } catch ( InterruptedException ex ) {\n        Exceptions.maybeInterrupted( ex );\n      } catch ( NoSuchElementException ex ) {\n      } finally {\n        orphans.remove( address );\n      }\n    }\n  }","id":41013,"modified_method":"public static void handleOrphan( Cluster cluster, ClusterAddressInfo address ) {\n    Integer orphanCount = 1;\n    orphanCount = orphans.putIfAbsent( address, orphanCount );\n    orphanCount = ( orphanCount == null )\n      ? 1\n      : orphanCount;\n    orphans.put( address, orphanCount + 1 );\n    EventRecord.caller( ClusterState.class, EventType.ADDRESS_STATE,\n                        \"Updated orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount ).debug( );\n    if ( orphanCount > AddressingConfiguration.getInstance( ).getMaxKillOrphans( ) ) {\n      EventRecord.caller( ClusterState.class, EventType.ADDRESS_STATE,\n                          \"Unassigning orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount ).warn( );\n      try {\n        final Address addr = Addresses.getInstance( ).lookup( address.getAddress( ) );\n        try {\n          if ( addr.isAssigned( ) && \"0.0.0.0\".equals( address.getInstanceIp( ) ) ) {\n            addr.unassign( ).clearPending( );\n            if ( addr.isSystemOwned( ) ) {\n              addr.release( );\n            }\n          } else if ( addr.isAssigned( ) && !\"0.0.0.0\".equals( address.getInstanceIp( ) ) ) {\n            AsyncRequests.newRequest( new UnassignAddressCallback( address ) ).sendSync( cluster.getConfiguration( ) );\n            if ( addr.isSystemOwned( ) ) {\n              addr.release( );\n            }\n          } else if ( !addr.isAssigned( ) && addr.isAllocated( ) && addr.isSystemOwned( ) ) {\n            addr.release( );\n          }\n        } catch ( ExecutionException ex ) {\n          if ( !addr.isAssigned( ) && addr.isAllocated( ) && addr.isSystemOwned( ) ) {\n            addr.release( );\n          }\n        }\n      } catch ( InterruptedException ex ) {\n        Exceptions.maybeInterrupted( ex );\n      } catch ( NoSuchElementException ex ) {\n      } finally {\n        orphans.remove( address );\n      }\n    }\n  }","commit_id":"60dcb9ac036e36d519ddb9a6848465c8a24ac981","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void fire( UnassignAddressResponseType reply ) {\n    try {\n//      this.sendSecondaryUnassign( );\n      this.clearVmAddress( );\n      this.address.clearPending( );\n    } catch ( IllegalStateException t ) {\n      LOG.debug( t );\n    } catch ( Exception t ) {\n      LOG.warn( t.getMessage( ) );\n      EventRecord.here( UnassignAddressCallback.class, EventType.ADDRESS_STATE, \"broken\", this.address.toString( ) ).warn( );\n      LOG.trace( t, t );\n    } finally {\n      if ( this.system ) {\n        try {\n          if ( !this.address.isPending( ) && this.address.isAssigned( ) ) {\n            this.address.unassign( ).clearPending( ).release( );\n          } else {\n            this.address.release( );\n          }\n        } catch ( Exception t ) {\n          LOG.warn( \"Failed to release orphan address: \" + this.address, t);\n        }\n      }\n    }\n  }","id":41014,"modified_method":"@Override\n  public void fire( UnassignAddressResponseType reply ) {\n    try {\n//      this.sendSecondaryUnassign( );\n      this.address.clearPending( );\n      this.clearVmAddress( );\n    } catch ( IllegalStateException t ) {\n      LOG.debug( t );\n    } catch ( Exception t ) {\n      LOG.warn( t.getMessage( ) );\n      EventRecord.here( UnassignAddressCallback.class, EventType.ADDRESS_STATE, \"broken\", this.address.toString( ) ).warn( );\n      LOG.trace( t, t );\n    } finally {\n      if ( this.system ) {\n        try {\n          if ( !this.address.isPending( ) && this.address.isAssigned( ) ) {\n            this.address.unassign( ).clearPending( ).release( );\n          } else {\n            this.address.release( );\n          }\n        } catch ( Exception t ) {\n          LOG.warn( \"Failed to release orphan address: \" + this.address, t);\n        }\n      }\n    }\n  }","commit_id":"60dcb9ac036e36d519ddb9a6848465c8a24ac981","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void update( Cluster cluster, List<ClusterAddressInfo> ccList ) {\n    if ( !cluster.getState( ).isAddressingInitialized( ) ) {\n      Helper.loadStoredAddresses( cluster );\n      cluster.getState( ).setAddressingInitialized( true );\n    }\n    for ( ClusterAddressInfo addrInfo : ccList ) {\n      try {\n        Address address = Helper.lookupOrCreate( cluster, addrInfo );\n        if ( address.isAssigned( ) ) {\n          if ( Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) ) {\n            Helper.markAsAllocated( cluster, addrInfo, address );\n          }\n          try {\n            VmInstance vm = VmInstances.getInstance( ).lookupByInstanceIp( addrInfo.getInstanceIp( ) );\n            cluster.getState( ).clearOrphan( addrInfo );\n          } catch ( NoSuchElementException e ) {\n            InetAddress addr = null;\n            try {\n              addr = Inet4Address.getByName( addrInfo.getInstanceIp( ) );\n            } catch ( UnknownHostException e1 ) {\n              LOG.debug( e1, e1 );\n            }\n            if ( addr == null || !addr.isLoopbackAddress( ) ) {\n              cluster.getState( ).handleOrphan( addrInfo );\n            }\n          }\n        } else if ( address.isAllocated( ) && Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) && !address.isPending( ) ) {\n          Helper.markAsAllocated( cluster, addrInfo, address );\n        }\n      } catch ( Throwable e ) {\n        LOG.debug( e, e );\n      }\n    }\n  }","id":41015,"modified_method":"public void update( Cluster cluster, List<ClusterAddressInfo> ccList ) {\n    if ( !cluster.getState( ).isAddressingInitialized( ) ) {\n      Helper.loadStoredAddresses( cluster );\n      cluster.getState( ).setAddressingInitialized( true );\n    }\n    for ( ClusterAddressInfo addrInfo : ccList ) {\n      try {\n        Address address = Helper.lookupOrCreate( cluster, addrInfo );\n        if ( address.isAssigned( ) && !address.isPending( ) ) {\n          if ( Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) ) {\n            Helper.markAsAllocated( cluster, addrInfo, address );\n          }\n          try {\n            VmInstance vm = VmInstances.getInstance( ).lookupByInstanceIp( addrInfo.getInstanceIp( ) );\n            cluster.getState( ).clearOrphan( addrInfo );\n          } catch ( NoSuchElementException e ) {\n            InetAddress addr = null;\n            try {\n              addr = Inet4Address.getByName( addrInfo.getInstanceIp( ) );\n            } catch ( UnknownHostException e1 ) {\n              LOG.debug( e1, e1 );\n            }\n            if ( addr == null || !addr.isLoopbackAddress( ) ) {\n              cluster.getState( ).handleOrphan( addrInfo );\n            }\n          }\n        } else if ( address.isAllocated( ) && Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) && !address.isPending( ) ) {\n          Helper.markAsAllocated( cluster, addrInfo, address );\n        }\n      } catch ( Throwable e ) {\n        LOG.debug( e, e );\n      }\n    }\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Address release( ) {\n    SplitTransition release = new SplitTransition( Transition.unallocating ) {\n      public void top( ) {\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_RELEASE ).withDetails( Address.this.userId, Address.this.name, \"type\",\n                                                                                                      Address.this.isSystemOwned( )\n                                                                                                        ? \"SYSTEM\"\n                                                                                                        : \"USER\" ).info( );\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n        Address.this.userId = UNALLOCATED_USERID;\n        Address.removeAddress( Address.this.name );\n        Address.this.state.attemptMark( State.unallocated, false );\n      }\n      \n      public void bottom( ) {}\n    };\n    if ( State.impending.equals( this.state.getReference( ) ) ) {\n      this.transition( State.impending, State.unallocated, true, true, release );\n    } else {\n      this.transition( State.allocated, State.unallocated, false, true, release );\n    }\n    return this;\n  }","id":41016,"modified_method":"public Address release( ) {\n    SplitTransition release = new SplitTransition( Transition.unallocating ) {\n      public void top( ) {\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_RELEASE ).withDetails( Address.this.userId, Address.this.name, \"type\",\n                                                                                                      Address.this.isSystemOwned( )\n                                                                                                        ? \"SYSTEM\"\n                                                                                                        : \"USER\" ).info( );\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n        Address.this.userId = UNALLOCATED_USERID;\n        Address.removeAddress( Address.this.name );\n        Address.this.stateUuid = UUID.randomUUID( ).toString( );\n        Address.this.state.attemptMark( State.unallocated, false );\n      }\n      \n      public void bottom( ) {}\n    };\n    if ( State.impending.equals( this.state.getReference( ) ) ) {\n      this.transition( State.impending, State.unallocated, true, true, release );\n    } else {\n      this.transition( State.allocated, State.unallocated, false, true, release );\n    }\n    return this;\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Address assign( final VmInstance vm ) {\n    SplitTransition assign = new SplitTransition( Transition.assigning ) {\n      public void top( ) {\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGNING )\n                   .withDetails( vm.getOwnerId( ), Address.this.getName( ), \"instanceid\", vm.getInstanceId( ) )\n                   .withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" )\n                   .withDetails( \"cluster\", Address.this.getCluster( ) ).info( );\n        Address.this.setInstanceId( vm.getInstanceId( ) );\n        Address.this.setInstanceAddress( vm.getPrivateAddress( ) );\n      }\n      \n      public void bottom( ) {\n        String userId = Address.this.userId;\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGN )\n                   .withDetails( userId, Address.this.name, \"instance\", Address.this.instanceId )\n                   .withDetails( \"instance-address\", Address.this.instanceAddress ).withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" ).info( );\n      }\n    };\n    if( State.impending.equals( this.state.getReference( ) ) ) { \n      this.transition( State.impending, State.assigned, true, true, assign );\n    } else {\n      this.transition( State.allocated, State.assigned, false, true, assign );\n    }\n    return this;\n  }","id":41017,"modified_method":"public Address assign( final VmInstance vm ) {\n    SplitTransition assign = new SplitTransition( Transition.assigning ) {\n      public void top( ) {\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGNING )\n                   .withDetails( vm.getOwnerId( ), Address.this.getName( ), \"instanceid\", vm.getInstanceId( ) )\n                   .withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" )\n                   .withDetails( \"cluster\", Address.this.getCluster( ) ).info( );\n        Address.this.setInstanceId( vm.getInstanceId( ) );\n        Address.this.setInstanceAddress( vm.getPrivateAddress( ) );\n        Address.this.stateUuid = UUID.randomUUID( ).toString( );\n      }\n      \n      public void bottom( ) {\n        String userId = Address.this.userId;\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGN )\n                   .withDetails( userId, Address.this.name, \"instance\", Address.this.instanceId )\n                   .withDetails( \"instance-address\", Address.this.instanceAddress ).withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" ).info( );\n      }\n    };\n    if ( State.impending.equals( this.state.getReference( ) ) ) {\n      this.transition( State.impending, State.assigned, true, true, assign );\n    } else {\n      this.transition( State.allocated, State.assigned, false, true, assign );\n    }\n    return this;\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Address pendingAssignment( ) {\n    this.transition( State.unallocated, State.impending, false, true, //\n                     new SplitTransition( Transition.system ) {\n                       public void top( ) {\n                         Address.this.instanceId = PENDING_ASSIGNMENT;\n                         Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n                         Address.this.userId = SYSTEM_ALLOCATED_USERID;\n                         try {\n                           Addresses.getInstance( ).register( Address.this );\n                         } catch ( NoSuchElementException e ) {\n                           LOG.debug( e );\n                         }\n                         EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ALLOCATE ).withDetails( Address.this.userId, Address.this.name,\n                                                                                                                        \"type\", Address.this.isSystemOwned( )\n                                                                                                                          ? \"SYSTEM\"\n                                                                                                                          : \"USER\" ).info( );\n                       }\n                       \n                       public void bottom( ) {}\n                     } );\n    return this;\n  }","id":41018,"modified_method":"public Address pendingAssignment( ) {\n    this.transition( State.unallocated, State.impending, false, true, //\n                     new SplitTransition( Transition.system ) {\n                       public void top( ) {\n                         Address.this.instanceId = PENDING_ASSIGNMENT;\n                         Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n                         Address.this.userId = SYSTEM_ALLOCATED_USERID;\n                         Address.this.stateUuid = UUID.randomUUID( ).toString( );\n                         try {\n                           Addresses.getInstance( ).register( Address.this );\n                         } catch ( NoSuchElementException e ) {\n                           LOG.debug( e );\n                         }\n                         EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ALLOCATE ).withDetails( Address.this.userId, Address.this.name,\n                                                                                                                        \"type\", Address.this.isSystemOwned( )\n                                                                                                                          ? \"SYSTEM\"\n                                                                                                                          : \"USER\" ).info( );\n                       }\n                       \n                       public void bottom( ) {}\n                     } );\n    return this;\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Address allocate( final String userId ) {\n    this.transition( State.unallocated, State.allocated, false, true, new SplitTransition( Transition.allocating ) {\n      public void top( ) {\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n        Address.this.userId = userId;\n        Address.addAddress( Address.this );\n        try {\n          Addresses.getInstance( ).register( Address.this );\n        } catch ( NoSuchElementException e ) {\n          LOG.debug( e );\n        }\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ALLOCATE ).withDetails( Address.this.userId, Address.this.name, \"type\",\n                                                                                                       Address.this.isSystemOwned( )\n                                                                                                         ? \"SYSTEM\"\n                                                                                                         : \"USER\" ).info( );\n        Address.this.state.attemptMark( State.allocated, false );\n      }\n      \n      public void bottom( ) {}\n    } );\n    return this;\n  }","id":41019,"modified_method":"public Address allocate( final String userId ) {\n    this.transition( State.unallocated, State.allocated, false, true, new SplitTransition( Transition.allocating ) {\n      public void top( ) {\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n        Address.this.userId = userId;\n        Address.addAddress( Address.this );\n        try {\n          Addresses.getInstance( ).register( Address.this );\n        } catch ( NoSuchElementException e ) {\n          LOG.debug( e );\n        }\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ALLOCATE ).withDetails( Address.this.userId, Address.this.name, \"type\",\n                                                                                                       Address.this.isSystemOwned( )\n                                                                                                         ? \"SYSTEM\"\n                                                                                                         : \"USER\" ).info( );\n        Address.this.stateUuid = UUID.randomUUID( ).toString( );\n        Address.this.state.attemptMark( State.allocated, false );\n      }\n      \n      public void bottom( ) {}\n    } );\n    return this;\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Address unassign( ) {\n    SplitTransition unassign = new SplitTransition( Transition.unassigning ) {\n      public void top( ) {\n        String userId = Address.this.userId;\n        try {\n          VmInstance vm = VmInstances.getInstance( ).lookup( Address.this.getInstanceId( ) );\n          EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_UNASSIGNING )\n                     .withDetails( vm.getOwnerId( ), Address.this.getName( ), \"instanceid\", vm.getInstanceId( ) )\n                     .withDetails( \"type\", Address.this.isSystemOwned( )\n                       ? \"SYSTEM\"\n                       : \"USER\" )\n                     .withDetails( \"cluster\", Address.this.getCluster( ) ).info( );\n        } catch ( NoSuchElementException e ) {}\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGN )\n                   .withDetails( userId, Address.this.name, \"instance\", Address.this.instanceId )\n                   .withDetails( \"instance-address\", Address.this.instanceAddress ).withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" ).info( );\n      }\n      \n      public void bottom( ) {\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n      }\n    };\n    if ( State.impending.equals( this.state.getReference( ) ) ) {\n      this.transition( State.impending, State.allocated, true, true, unassign );\n    } else {\n      this.transition( State.assigned, State.allocated, false, true, unassign );\n    }\n    return this;\n  }","id":41020,"modified_method":"public Address unassign( ) {\n    SplitTransition unassign = new SplitTransition( Transition.unassigning ) {\n      public void top( ) {\n        String userId = Address.this.userId;\n        try {\n          VmInstance vm = VmInstances.getInstance( ).lookup( Address.this.getInstanceId( ) );\n          EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_UNASSIGNING )\n                     .withDetails( vm.getOwnerId( ), Address.this.getName( ), \"instanceid\", vm.getInstanceId( ) )\n                     .withDetails( \"type\", Address.this.isSystemOwned( )\n                       ? \"SYSTEM\"\n                       : \"USER\" )\n                     .withDetails( \"cluster\", Address.this.getCluster( ) ).info( );\n        } catch ( NoSuchElementException e ) {}\n        EventRecord.here( Address.class, EventClass.ADDRESS, EventType.ADDRESS_ASSIGN )\n                   .withDetails( userId, Address.this.name, \"instance\", Address.this.instanceId )\n                   .withDetails( \"instance-address\", Address.this.instanceAddress ).withDetails( \"type\", Address.this.isSystemOwned( )\n                     ? \"SYSTEM\"\n                     : \"USER\" ).info( );\n      }\n      \n      public void bottom( ) {\n        Address.this.stateUuid = UUID.randomUUID( ).toString( );\n        Address.this.instanceId = UNASSIGNED_INSTANCEID;\n        Address.this.instanceAddress = UNASSIGNED_INSTANCEADDR;\n      }\n    };\n    if ( State.impending.equals( this.state.getReference( ) ) ) {\n      this.transition( State.impending, State.allocated, true, true, unassign );\n    } else {\n      this.transition( State.assigned, State.allocated, false, true, unassign );\n    }\n    return this;\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AssignAddressCallback( Address address ) {\n    this.address = address;\n    super.setRequest( new AssignAddressType( address.getName( ), address.getInstanceAddress( ), address.getInstanceId( ) ) );\n  }","id":41021,"modified_method":"public AssignAddressCallback( Address address ) {\n    this.address = address;\n    super.setRequest( new AssignAddressType( address.getStateUuid( ), address.getName( ), address.getInstanceAddress( ), address.getInstanceId( ) ) );\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void fire( DescribePublicAddressesResponseType reply ) {\n    this.getSubject( ).getState( ).setPublicAddressing( true );\n    \n    List<ClusterAddressInfo> addrInfo = ClusterAddressInfo.fromLists( reply.getAddresses( ), reply.getMapping( ) );\n    if ( addrInfo != null ) {\n      Addresses.getAddressManager( ).update( this.getSubject( ), addrInfo );\n    }\n  }","id":41022,"modified_method":"@Override\n  public void fire( DescribePublicAddressesResponseType reply ) {\n    this.getSubject( ).getState( ).setPublicAddressing( true );\n    Addresses.getAddressManager( ).update( this.getSubject( ), reply.getAddresses( ) );\n  }","commit_id":"c33d8331d9a7a721e03b3de551b87d576db50ec0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void cleanUp( final VmInstance vm ) {\n    Logs.extreme( ).info( \"Terminating instance: \" + vm.getInstanceId( ), new RuntimeException( ) );\n    try {\n      Address address = null;\n      if ( NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n        try {\n          address = Addresses.getInstance( ).lookup( vm.getPublicAddress( ) );\n          if ( address.isAssigned( ) ) {\n            AsyncRequests.newRequest( address.unassign( ).getCallback( ) ).dispatch( vm.getPartition( ) );\n            if ( address.isSystemOwned( ) ) {\n              EventRecord.caller( VmInstances.class, EventType.VM_TERMINATING, \"SYSTEM_ADDRESS\", address.toString( ) ).debug( );\n            } else {\n              EventRecord.caller( VmInstances.class, EventType.VM_TERMINATING, \"USER_ADDRESS\", address.toString( ) ).debug( );\n            }\n          }\n        } catch ( final NoSuchElementException e ) {\n\n        } catch ( final Exception e1 ) {\n          LOG.debug( e1, e1 );\n        }\n      }\n    } catch ( final Exception e ) {\n      LOG.error( e );\n      Logs.extreme( ).error( e, e );\n    }\n    try {\n      VmInstances.cleanUpAttachedVolumes( vm );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n    try {\n      AsyncRequests.newRequest( new TerminateCallback( vm.getInstanceId( ) ) ).dispatch( vm.getPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","id":41023,"modified_method":"public static void cleanUp( final VmInstance vm ) {\n    VmState vmLastState = vm.getLastState( );\n    VmState vmState = vm.getState( );\n    RuntimeException logEx = new RuntimeException( \"Cleaning up instance: \" + vm.getInstanceId( ) + \" \" + vmLastState + \" -> \" + vmState );\n    LOG.debug( logEx.getMessage( ) );\n    Logs.extreme( ).info( logEx, logEx );\n    try {\n      if ( NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n        try {\n          Address address = Addresses.getInstance( ).lookup( vm.getPublicAddress( ) );\n          if ( ( address.isAssigned( ) && vm.getInstanceId( ).equals( address.getInstanceId( ) ) ) //assigned to this instance explicitly\n               || VmState.PENDING.equals( vmLastState ) ) { //partial assignment implicitly associated with this failed (PENDING->SHUTTINGDOWN) instance\n            if ( address.isSystemOwned( ) ) {\n              EventRecord.caller( VmInstances.class, EventType.VM_TERMINATING, \"SYSTEM_ADDRESS\", address.toString( ) ).debug( );\n            } else {\n              EventRecord.caller( VmInstances.class, EventType.VM_TERMINATING, \"USER_ADDRESS\", address.toString( ) ).debug( );\n            }\n            AsyncRequests.newRequest( address.unassign( ).getCallback( ) ).dispatch( vm.getPartition( ) );\n          }\n        } catch ( final NoSuchElementException e ) {\n          //PENDING->SHUTTINGDOWN might happen before address info reported in describe instances by CC, need to try finding address\n          if ( VmState.PENDING.equals( vmLastState ) ) {\n            for ( Address addr : Addresses.getInstance( ).listValues( ) ) {\n              if ( addr.getInstanceId( ).equals( vm.getInstanceId( ) ) ) {\n                AsyncRequests.newRequest( addr.unassign( ).getCallback( ) ).dispatch( vm.getPartition( ) );\n                break;\n              }\n            }\n          }\n        } catch ( final Exception e1 ) {\n          LOG.debug( e1, e1 );\n        }\n      }\n    } catch ( final Exception e ) {\n      LOG.error( e );\n      Logs.extreme( ).error( e, e );\n    }\n    try {\n      VmInstances.cleanUpAttachedVolumes( vm );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n    try {\n      AsyncRequests.newRequest( new TerminateCallback( vm.getInstanceId( ) ) ).dispatch( vm.getPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","commit_id":"3680bfbff028a52260d1e415a135db0ad816a50e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Callable<Boolean> handleStateTransition( final VmState newState, final VmState oldState, final VmState olderState ) {\n    Callable<Boolean> action = null;\n    LOG.info( String.format( \"%s state change: %s -> %s (previously %s)\", this.getVmInstance( ).getInstanceId( ), oldState, newState, olderState ) );\n    if ( VmStateSet.RUN.contains( oldState )\n         && VmStateSet.NOT_RUNNING.contains( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.PENDING.equals( oldState )\n                && VmState.RUNNING.equals( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      if ( VmState.STOPPED.equals( olderState ) ) {\n        this.restoreVolumeState( );\n      }\n    } else if ( VmState.PENDING.equals( oldState )\n                && VmState.TERMINATED.equals( newState )\n                && VmState.STOPPED.equals( olderState ) ) {\n      this.getVmInstance( ).setState( VmState.STOPPED );\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.STOPPED.equals( oldState )\n                && VmState.TERMINATED.equals( newState ) ) {\n      this.getVmInstance( ).setState( VmState.TERMINATED );\n      action = this.cleanUpRunnable( );\n    } else if ( VmStateSet.EXPECTING_TEARDOWN.contains( oldState )\n                && VmStateSet.RUN.contains( newState ) ) {\n      this.getVmInstance( ).setState( oldState );//mask/ignore running on {stopping,shutting-down} transitions \n    } else if ( VmStateSet.EXPECTING_TEARDOWN.contains( oldState )\n                && VmStateSet.TORNDOWN.contains( newState ) ) {\n      if ( VmState.SHUTTING_DOWN.equals( oldState ) ) {\n        this.getVmInstance( ).setState( VmState.TERMINATED );\n      } else {//if ( VmState.STOPPING.equals( oldState ) ) {\n        this.getVmInstance( ).setState( VmState.STOPPED );\n      }\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.STOPPED.equals( oldState )\n                && VmState.PENDING.equals( newState ) ) {\n      this.getVmInstance( ).setState( VmState.PENDING );\n    } else if ( VmStateSet.RUN.contains( oldState )\n                && VmStateSet.NOT_RUNNING.contains( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      action = this.cleanUpRunnable( );\n    } else {//if ( VmState.TERMINATED.equals( newState ) && ( oldState.ordinal( ) > VmState.RUNNING.ordinal( ) ) ) {\n      this.getVmInstance( ).setState( newState );\n    }\n    try {\n      this.getVmInstance( ).store( );\n    } catch ( final Exception ex1 ) {\n      LOG.error( ex1, ex1 );\n    }\n    return action;\n  }","id":41024,"modified_method":"private Callable<Boolean> handleStateTransition( final VmState newState, final VmState oldState, final VmState olderState ) {\n    Callable<Boolean> action = null;\n    LOG.info( String.format( \"%s state change: %s -> %s (previously %s)\", this.getVmInstance( ).getInstanceId( ), oldState, newState, olderState ) );\n    if ( VmStateSet.RUN.contains( oldState )\n         && VmStateSet.NOT_RUNNING.contains( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.PENDING.equals( oldState )\n                && VmState.RUNNING.equals( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      if ( VmState.STOPPED.equals( olderState ) ) {\n        this.restoreVolumeState( );\n      }\n    } else if ( VmState.PENDING.equals( oldState )\n                && VmState.TERMINATED.equals( newState )\n                && VmState.STOPPED.equals( olderState ) ) {\n      this.getVmInstance( ).setState( VmState.STOPPED );\n      this.getVmInstance( ).updatePublicAddress( this.getVmInstance( ).getPrivateAddress( ) );\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.STOPPED.equals( oldState )\n                && VmState.TERMINATED.equals( newState ) ) {\n      this.getVmInstance( ).setState( VmState.TERMINATED );\n      this.getVmInstance( ).updatePublicAddress( this.getVmInstance( ).getPrivateAddress( ) );\n      action = this.cleanUpRunnable( );\n    } else if ( VmStateSet.EXPECTING_TEARDOWN.contains( oldState )\n                && VmStateSet.RUN.contains( newState ) ) {\n      this.getVmInstance( ).setState( oldState );//mask/ignore running on {stopping,shutting-down} transitions \n    } else if ( VmStateSet.EXPECTING_TEARDOWN.contains( oldState )\n                && VmStateSet.TORNDOWN.contains( newState ) ) {\n      if ( VmState.SHUTTING_DOWN.equals( oldState ) ) {\n        this.getVmInstance( ).setState( VmState.TERMINATED );\n        this.getVmInstance( ).updatePublicAddress( this.getVmInstance( ).getPrivateAddress( ) );\n      } else {//if ( VmState.STOPPING.equals( oldState ) ) {\n        this.getVmInstance( ).setState( VmState.STOPPED );\n        this.getVmInstance( ).updatePublicAddress( this.getVmInstance( ).getPrivateAddress( ) );\n      }\n      action = this.cleanUpRunnable( );\n    } else if ( VmState.STOPPED.equals( oldState )\n                && VmState.PENDING.equals( newState ) ) {\n      this.getVmInstance( ).setState( VmState.PENDING );\n    } else if ( VmStateSet.RUN.contains( oldState )\n                && VmStateSet.NOT_RUNNING.contains( newState ) ) {\n      this.getVmInstance( ).setState( newState );\n      action = this.cleanUpRunnable( );\n    } else {//if ( VmState.TERMINATED.equals( newState ) && ( oldState.ordinal( ) > VmState.RUNNING.ordinal( ) ) ) {\n      this.getVmInstance( ).setState( newState );\n    }\n    try {\n      this.getVmInstance( ).store( );\n    } catch ( final Exception ex1 ) {\n      LOG.error( ex1, ex1 );\n    }\n    return action;\n  }","commit_id":"3680bfbff028a52260d1e415a135db0ad816a50e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * Populate the associated resources by making a call to the Metrics\n     * service.\n     *\n     * @return a collection of populated resources\n     * @throws SystemException if unable to populate the resources\n     */\n    public Collection<Resource> populateResources() throws SystemException {\n      // No open ended query support.\n      if (temporalInfo != null && (temporalInfo.getStartTime() == null\n        || temporalInfo.getEndTime() == null)) {\n        return Collections.emptySet();\n      }\n\n      for (Map.Entry<String, Set<Resource>> resourceEntry : resources.entrySet()) {\n        String hostname = resourceEntry.getKey();\n        Set<Resource> resourceSet = resourceEntry.getValue();\n\n        for (Resource resource : resourceSet) {\n          String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n\n          // Check liveliness of host\n          if (!hostProvider.isCollectorHostLive(clusterName, TIMELINE_METRICS)) {\n            LOG.info(\"METRIC_COLLECTOR host is not live. Skip populating \" +\n              \"resources with metrics.\");\n            return Collections.emptySet();\n          }\n\n          // Check liveliness of Collector\n          if (!hostProvider.isCollectorComponentLive(clusterName, TIMELINE_METRICS)) {\n            LOG.info(\"METRIC_COLLECTOR is not live. Skip populating resources\" +\n              \" with metrics.\");\n            return Collections.emptySet();\n          }\n\n          String spec = getSpec(hostname, resource);\n\n          BufferedReader reader = null;\n          try {\n            LOG.debug(\"Metrics request url =\" + spec);\n            reader = new BufferedReader(new InputStreamReader(streamProvider.readFrom(spec)));\n\n            TimelineMetrics timelineMetrics = timelineObjectReader.readValue(reader);\n            LOG.debug(\"Timeline metrics response => \" + timelineMetrics);\n\n            Set<String> patterns = createPatterns(metrics.keySet());\n\n            for (TimelineMetric metric : timelineMetrics.getMetrics()) {\n              if (metric.getMetricName() != null\n                && metric.getMetricValues() != null\n                && checkMetricName(patterns, metric.getMetricName())) {\n                populateResource(resource, metric);\n              }\n            }\n\n          } catch (IOException io) {\n            LOG.warn(\"Error getting timeline metrics.\", io);\n          } finally {\n            if (reader != null) {\n              try {\n                reader.close();\n              } catch (IOException e) {\n                if (LOG.isWarnEnabled()) {\n                  LOG.warn(\"Unable to close http input steam : spec=\" + spec, e);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return Collections.emptySet();\n    }","id":41025,"modified_method":"/**\n     * Populate the associated resources by making a call to the Metrics\n     * service.\n     *\n     * @return a collection of populated resources\n     * @throws SystemException if unable to populate the resources\n     */\n    public Collection<Resource> populateResources() throws SystemException {\n      // No open ended query support.\n      if (temporalInfo == null || temporalInfo.getStartTime() == null ||\n          temporalInfo.getEndTime() == null) {\n        return Collections.emptySet();\n      }\n\n      for (Map.Entry<String, Set<Resource>> resourceEntry : resources.entrySet()) {\n        String hostname = resourceEntry.getKey();\n        Set<Resource> resourceSet = resourceEntry.getValue();\n\n        for (Resource resource : resourceSet) {\n          String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n\n          // Check liveliness of host\n          if (!hostProvider.isCollectorHostLive(clusterName, TIMELINE_METRICS)) {\n            LOG.info(\"METRIC_COLLECTOR host is not live. Skip populating \" +\n              \"resources with metrics.\");\n            return Collections.emptySet();\n          }\n\n          // Check liveliness of Collector\n          if (!hostProvider.isCollectorComponentLive(clusterName, TIMELINE_METRICS)) {\n            LOG.info(\"METRIC_COLLECTOR is not live. Skip populating resources\" +\n              \" with metrics.\");\n            return Collections.emptySet();\n          }\n\n          String metricsParam = getSetString(processRegexps(metrics.keySet()), -1);\n          // Reuse uriBuilder\n          uriBuilder.removeQuery();\n\n          if (metricsParam.length() > 0) {\n            uriBuilder.setParameter(\"metricNames\", metricsParam);\n          }\n\n          if (hostname != null && !hostname.isEmpty() && !hostname.equals(dummyHostName)) {\n            uriBuilder.setParameter(\"hostname\", hostname);\n          }\n\n          String componentName = getComponentName(resource);\n          if (componentName != null && !componentName.isEmpty()) {\n            if (TIMELINE_APPID_MAP.containsKey(componentName)) {\n              componentName = TIMELINE_APPID_MAP.get(componentName);\n            }\n            uriBuilder.setParameter(\"appId\", componentName);\n          }\n\n          long startTime = temporalInfo.getStartTime();\n          if (startTime != -1) {\n            uriBuilder.setParameter(\"startTime\", String.valueOf(startTime));\n          }\n\n          long endTime = temporalInfo.getEndTime();\n          if (endTime != -1) {\n            uriBuilder.setParameter(\"endTime\", String.valueOf(endTime));\n          }\n\n          BufferedReader reader = null;\n          String spec = uriBuilder.toString();\n          try {\n            LOG.debug(\"Metrics request url =\" + spec);\n            reader = new BufferedReader(new InputStreamReader(streamProvider.readFrom(spec)));\n\n            TimelineMetrics timelineMetrics = timelineObjectReader.readValue(reader);\n            LOG.debug(\"Timeline metrics response => \" + timelineMetrics);\n\n            Set<String> patterns = createPatterns(metrics.keySet());\n\n            for (TimelineMetric metric : timelineMetrics.getMetrics()) {\n              if (metric.getMetricName() != null && metric.getMetricValues() != null\n                  && checkMetricName(patterns, metric.getMetricName())) {\n                populateResource(resource, metric);\n              }\n            }\n\n          } catch (IOException io) {\n            LOG.warn(\"Error getting timeline metrics.\", io);\n          } finally {\n            if (reader != null) {\n              try {\n                reader.close();\n              } catch (IOException e) {\n                if (LOG.isWarnEnabled()) {\n                  LOG.warn(\"Unable to close http input steam : spec=\" + spec, e);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return Collections.emptySet();\n    }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testShouldAggregateClusterProperly() throws Exception {\n    // GIVEN\n    TimelineMetricClusterAggregator agg =\n      new TimelineMetricClusterAggregator(hdb, new Configuration());\n\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 2));\n    ctime += minute;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 1));\n\n    // WHEN\n    long endTime = ctime + minute;\n    boolean success = agg.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    int recordCount = 0;\n    while (rs.next()) {\n      TimelineClusterMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricClusterKeyFromResultSet(rs);\n      MetricClusterAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricClusterAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2, currentHostAggregate.getNumberOfHosts());\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(3.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n  }","id":41026,"modified_method":"@Test\n  public void testShouldAggregateClusterProperly() throws Exception {\n    // GIVEN\n    TimelineMetricClusterAggregator agg =\n      new TimelineMetricClusterAggregator(hdb, new Configuration());\n\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 2));\n    ctime += minute;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 1));\n\n    // WHEN\n    long endTime = ctime + minute;\n    boolean success = agg.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    int recordCount = 0;\n    while (rs.next()) {\n      TimelineClusterMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricClusterKeyFromResultSet(rs);\n      MetricClusterAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricClusterAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2, currentHostAggregate.getNumberOfHosts());\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(3.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testShouldAggregateDifferentMetricsOnClusterProperly()\n    throws Exception {\n    // GIVEN\n    TimelineMetricClusterAggregator agg =\n      new TimelineMetricClusterAggregator(hdb, new Configuration());\n\n    // here we put some metrics tha will be aggregated\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_used\", 1));\n\n    ctime += minute;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_used\", 1));\n\n    // WHEN\n    long endTime = ctime + minute;\n    boolean success = agg.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    int recordCount = 0;\n    while (rs.next()) {\n      TimelineClusterMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricClusterKeyFromResultSet(rs);\n      MetricClusterAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricClusterAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2, currentHostAggregate.getNumberOfHosts());\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(3.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else if (\"disk_used\".equals(currentMetric.getMetricName())) {\n        assertEquals(1, currentHostAggregate.getNumberOfHosts());\n        assertEquals(1.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(1.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n  }","id":41027,"modified_method":"@Test\n  public void testShouldAggregateDifferentMetricsOnClusterProperly()\n    throws Exception {\n    // GIVEN\n    TimelineMetricClusterAggregator agg =\n      new TimelineMetricClusterAggregator(hdb, new Configuration());\n\n    // here we put some metrics tha will be aggregated\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_used\", 1));\n\n    ctime += minute;\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_free\", 2));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local2\",\n      \"disk_free\", 1));\n    hdb.insertMetricRecords(prepareSingleTimelineMetric(ctime, \"local1\",\n      \"disk_used\", 1));\n\n    // WHEN\n    long endTime = ctime + minute;\n    boolean success = agg.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    int recordCount = 0;\n    while (rs.next()) {\n      TimelineClusterMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricClusterKeyFromResultSet(rs);\n      MetricClusterAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricClusterAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2, currentHostAggregate.getNumberOfHosts());\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(3.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else if (\"disk_used\".equals(currentMetric.getMetricName())) {\n        assertEquals(1, currentHostAggregate.getNumberOfHosts());\n        assertEquals(1.0, currentHostAggregate.getMax());\n        assertEquals(1.0, currentHostAggregate.getMin());\n        assertEquals(1.0, currentHostAggregate.getSum());\n        recordCount++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testShouldAggregateHourProperly() throws Exception {\n    // GIVEN\n//    TimelineMetricAggregatorHourly aggregator =\n//      new TimelineMetricAggregatorHourly(hdb, new Configuration());\n\n    TimelineMetricAggregator aggregator = TimelineMetricAggregatorFactory\n      .createTimelineMetricAggregatorHourly(hdb, new Configuration());\n    long startTime = System.currentTimeMillis();\n\n    MetricHostAggregate expectedAggregate =\n      createMetricHostAggregate(2.0, 0.0, 20, 15.0);\n    Map<TimelineMetric, MetricHostAggregate>\n      aggMap = new HashMap<TimelineMetric,\n      MetricHostAggregate>();\n\n    int min_5 = 5 * 60 * 1000;\n    long ctime = startTime - min_5;\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n\n    hdb.saveHostAggregateRecords(aggMap, METRICS_AGGREGATE_MINUTE_TABLE_NAME);\n\n    //WHEN\n    long endTime = ctime + min_5;\n    boolean success = aggregator.doWork(startTime, endTime);\n    assertTrue(success);\n\n    //THEN\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_AGGREGATE_HOURLY_TABLE_NAME));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    while (rs.next()) {\n      TimelineMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricKeyFromResultSet(rs);\n      MetricHostAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricHostAggregateFromResultSet(rs);\n\n      if (\"disk_used\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(12 * 20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(12 * 15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n      }\n    }\n  }","id":41028,"modified_method":"@Test\n  public void testShouldAggregateHourProperly() throws Exception {\n    // GIVEN\n//    TimelineMetricAggregatorHourly aggregator =\n//      new TimelineMetricAggregatorHourly(hdb, new Configuration());\n\n    TimelineMetricAggregator aggregator = TimelineMetricAggregatorFactory\n      .createTimelineMetricAggregatorHourly(hdb, new Configuration());\n    long startTime = System.currentTimeMillis();\n\n    MetricHostAggregate expectedAggregate =\n      createMetricHostAggregate(2.0, 0.0, 20, 15.0);\n    Map<TimelineMetric, MetricHostAggregate>\n      aggMap = new HashMap<TimelineMetric,\n      MetricHostAggregate>();\n\n    int min_5 = 5 * 60 * 1000;\n    long ctime = startTime - min_5;\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n    aggMap.put(createEmptyTimelineMetric(ctime += min_5), expectedAggregate);\n\n    hdb.saveHostAggregateRecords(aggMap, METRICS_AGGREGATE_MINUTE_TABLE_NAME);\n\n    //WHEN\n    long endTime = ctime + min_5;\n    boolean success = aggregator.doWork(startTime, endTime);\n    assertTrue(success);\n\n    //THEN\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_AGGREGATE_HOURLY_TABLE_NAME));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n\n    while (rs.next()) {\n      TimelineMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricKeyFromResultSet(rs);\n      MetricHostAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricHostAggregateFromResultSet(rs);\n\n      if (\"disk_used\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(12 * 20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(12 * 15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n      }\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testShouldInsertMetrics() throws Exception {\n    // GIVEN\n\n    // WHEN\n    long startTime = System.currentTimeMillis();\n    TimelineMetrics metricsSent = prepareTimelineMetrics(startTime, \"local\");\n    hdb.insertMetricRecords(metricsSent);\n\n    Condition queryCondition = new DefaultCondition(null, \"local\", null, null,\n      startTime, startTime + (15 * 60 * 1000), null, false);\n    TimelineMetrics recordRead = hdb.getMetricRecords(queryCondition);\n\n    // THEN\n    assertThat(recordRead.getMetrics()).hasSize(2)\n      .extracting(\"metricName\")\n      .containsOnly(\"mem_free\", \"disk_free\");\n\n    assertThat(metricsSent.getMetrics())\n      .usingElementComparator(TIME_IGNORING_COMPARATOR)\n      .containsExactlyElementsOf(recordRead.getMetrics());\n  }","id":41029,"modified_method":"@Test\n  public void testShouldInsertMetrics() throws Exception {\n    // GIVEN\n\n    // WHEN\n    long startTime = System.currentTimeMillis();\n    TimelineMetrics metricsSent = prepareTimelineMetrics(startTime, \"local\");\n    hdb.insertMetricRecords(metricsSent);\n\n    Condition queryCondition = new Condition(null, \"local\", null, null,\n      startTime, startTime + (15 * 60 * 1000), null, false);\n    TimelineMetrics recordRead = hdb.getMetricRecords(queryCondition);\n\n    // THEN\n    assertThat(recordRead.getMetrics()).hasSize(2)\n      .extracting(\"metricName\")\n      .containsOnly(\"mem_free\", \"disk_free\");\n\n    assertThat(metricsSent.getMetrics())\n      .usingElementComparator(TIME_IGNORING_COMPARATOR)\n      .containsExactlyElementsOf(recordRead.getMetrics());\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testShouldAggregateMinuteProperly() throws Exception {\n    // GIVEN\n//    TimelineMetricAggregatorMinute aggregatorMinute =\n//      new TimelineMetricAggregatorMinute(hdb, new Configuration());\n    TimelineMetricAggregator aggregatorMinute = TimelineMetricAggregatorFactory\n      .createTimelineMetricAggregatorMinute(hdb, new Configuration());\n\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareTimelineMetrics(startTime, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n\n    // WHEN\n    long endTime = startTime + 1000 * 60 * 4;\n    boolean success = aggregatorMinute.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_AGGREGATE_MINUTE_TABLE_NAME));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n    MetricHostAggregate expectedAggregate =\n      createMetricHostAggregate(2.0, 0.0, 20, 15.0);\n\n    int count = 0;\n    while (rs.next()) {\n      TimelineMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricKeyFromResultSet(rs);\n      MetricHostAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricHostAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n        count++;\n      } else if (\"mem_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n        count++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n    assertEquals(\"Two aggregated entries expected\", 2, count);\n  }","id":41030,"modified_method":"@Test\n  public void testShouldAggregateMinuteProperly() throws Exception {\n    // GIVEN\n//    TimelineMetricAggregatorMinute aggregatorMinute =\n//      new TimelineMetricAggregatorMinute(hdb, new Configuration());\n    TimelineMetricAggregator aggregatorMinute = TimelineMetricAggregatorFactory\n      .createTimelineMetricAggregatorMinute(hdb, new Configuration());\n\n    long startTime = System.currentTimeMillis();\n    long ctime = startTime;\n    long minute = 60 * 1000;\n    hdb.insertMetricRecords(prepareTimelineMetrics(startTime, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n    hdb.insertMetricRecords(prepareTimelineMetrics(ctime += minute, \"local\"));\n\n    // WHEN\n    long endTime = startTime + 1000 * 60 * 4;\n    boolean success = aggregatorMinute.doWork(startTime, endTime);\n\n    //THEN\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_AGGREGATE_MINUTE_TABLE_NAME));\n\n    PreparedStatement pstmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt\n      (conn, condition);\n    ResultSet rs = pstmt.executeQuery();\n    MetricHostAggregate expectedAggregate =\n      createMetricHostAggregate(2.0, 0.0, 20, 15.0);\n\n    int count = 0;\n    while (rs.next()) {\n      TimelineMetric currentMetric =\n        PhoenixHBaseAccessor.getTimelineMetricKeyFromResultSet(rs);\n      MetricHostAggregate currentHostAggregate =\n        PhoenixHBaseAccessor.getMetricHostAggregateFromResultSet(rs);\n\n      if (\"disk_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n        count++;\n      } else if (\"mem_free\".equals(currentMetric.getMetricName())) {\n        assertEquals(2.0, currentHostAggregate.getMax());\n        assertEquals(0.0, currentHostAggregate.getMin());\n        assertEquals(20, currentHostAggregate.getNumberOfSamples());\n        assertEquals(15.0, currentHostAggregate.getSum());\n        assertEquals(15.0 / 20, currentHostAggregate.getAvg());\n        count++;\n      } else {\n        fail(\"Unexpected entry\");\n      }\n    }\n    assertEquals(\"Two aggregated entries expected\", 2, count);\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"public void saveHostAggregateRecords(Map<TimelineMetric,\n    MetricHostAggregate> hostAggregateMap, String phoenixTableName)\n    throws SQLException {\n\n    if (hostAggregateMap == null || hostAggregateMap.isEmpty()) {\n      LOG.debug(\"Empty aggregate records.\");\n      return;\n    }\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n\n    long start = System.currentTimeMillis();\n    int rowCount = 0;\n\n    try {\n      stmt = conn.prepareStatement(\n        String.format(UPSERT_AGGREGATE_RECORD_SQL, phoenixTableName));\n\n      for (Map.Entry<TimelineMetric, MetricHostAggregate> metricAggregate :\n        hostAggregateMap.entrySet()) {\n\n        TimelineMetric metric = metricAggregate.getKey();\n        MetricHostAggregate hostAggregate = metricAggregate.getValue();\n\n        rowCount++;\n        stmt.clearParameters();\n        stmt.setString(1, metric.getMetricName());\n        stmt.setString(2, metric.getHostName());\n        stmt.setString(3, metric.getAppId());\n        stmt.setString(4, metric.getInstanceId());\n        stmt.setLong(5, metric.getTimestamp());\n        stmt.setString(6, metric.getType());\n        stmt.setDouble(7, hostAggregate.getSum());\n        stmt.setDouble(8, hostAggregate.getMax());\n        stmt.setDouble(9, hostAggregate.getMin());\n        stmt.setDouble(10, hostAggregate.getNumberOfSamples());\n\n        try {\n          stmt.executeUpdate();\n        } catch (SQLException sql) {\n          LOG.error(sql);\n        }\n\n        if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n          conn.commit();\n          rowCount = 0;\n        }\n\n      }\n\n      conn.commit();\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n\n    long end = System.currentTimeMillis();\n\n    if ((end - start) > 60000l) {\n      LOG.info(\"Time to save map: \" + (end - start) + \", \" +\n        \"thread = \" + Thread.currentThread().getClass());\n    }\n  }","id":41031,"modified_method":"public void saveHostAggregateRecords(Map<TimelineMetric,\n    MetricHostAggregate> hostAggregateMap, String phoenixTableName)\n    throws SQLException {\n\n    if (hostAggregateMap != null && !hostAggregateMap.isEmpty()) {\n      Connection conn = getConnection();\n      PreparedStatement stmt = null;\n\n      long start = System.currentTimeMillis();\n      int rowCount = 0;\n\n      try {\n        stmt = conn.prepareStatement(\n          String.format(UPSERT_AGGREGATE_RECORD_SQL, phoenixTableName));\n\n        for (Map.Entry<TimelineMetric, MetricHostAggregate> metricAggregate :\n          hostAggregateMap.entrySet()) {\n\n          TimelineMetric metric = metricAggregate.getKey();\n          MetricHostAggregate hostAggregate = metricAggregate.getValue();\n\n          rowCount++;\n          stmt.clearParameters();\n          stmt.setString(1, metric.getMetricName());\n          stmt.setString(2, metric.getHostName());\n          stmt.setString(3, metric.getAppId());\n          stmt.setString(4, metric.getInstanceId());\n          stmt.setLong(5, metric.getTimestamp());\n          stmt.setString(6, metric.getType());\n          stmt.setDouble(7, hostAggregate.getSum());\n          stmt.setDouble(8, hostAggregate.getMax());\n          stmt.setDouble(9, hostAggregate.getMin());\n          stmt.setDouble(10, hostAggregate.getNumberOfSamples());\n\n          try {\n            // TODO: Why this exception is swallowed\n            stmt.executeUpdate();\n          } catch (SQLException sql) {\n            LOG.error(sql);\n          }\n\n          if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n            conn.commit();\n            rowCount = 0;\n          }\n\n        }\n\n        conn.commit();\n\n      } finally {\n        if (stmt != null) {\n          try {\n            stmt.close();\n          } catch (SQLException e) {\n            // Ignore\n          }\n        }\n        if (conn != null) {\n          try {\n            conn.close();\n          } catch (SQLException sql) {\n            // Ignore\n          }\n        }\n      }\n\n      long end = System.currentTimeMillis();\n\n      if ((end - start) > 60000l) {\n        LOG.info(\"Time to save map: \" + (end - start) + \", \" +\n          \"thread = \" + Thread.currentThread().getClass());\n      }\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Save Metric aggregate records.\n   *\n   * @throws SQLException\n   */\n  public void saveClusterAggregateHourlyRecords(\n    Map<TimelineClusterMetric, MetricHostAggregate> records,\n    String tableName)\n    throws SQLException {\n    if (records == null || records.isEmpty()) {\n      LOG.debug(\"Empty aggregate records.\");\n      return;\n    }\n\n    long start = System.currentTimeMillis();\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    try {\n      stmt = conn.prepareStatement(String.format\n        (UPSERT_CLUSTER_AGGREGATE_TIME_SQL, tableName));\n      int rowCount = 0;\n\n      for (Map.Entry<TimelineClusterMetric, MetricHostAggregate>\n        aggregateEntry : records.entrySet()) {\n        TimelineClusterMetric clusterMetric = aggregateEntry.getKey();\n        MetricHostAggregate aggregate = aggregateEntry.getValue();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"clusterMetric = \" + clusterMetric + \", \" +\n            \"aggregate = \" + aggregate);\n        }\n\n        rowCount++;\n        stmt.clearParameters();\n        stmt.setString(1, clusterMetric.getMetricName());\n        stmt.setString(2, clusterMetric.getAppId());\n        stmt.setString(3, clusterMetric.getInstanceId());\n        stmt.setLong(4, clusterMetric.getTimestamp());\n        stmt.setString(5, clusterMetric.getType());\n        stmt.setDouble(6, aggregate.getSum());\n//        stmt.setInt(7, aggregate.getNumberOfHosts());\n        stmt.setLong(7, aggregate.getNumberOfSamples());\n        stmt.setDouble(8, aggregate.getMax());\n        stmt.setDouble(9, aggregate.getMin());\n\n        try {\n          stmt.executeUpdate();\n        } catch (SQLException sql) {\n          // we have no way to verify it works!!!\n          LOG.error(sql);\n        }\n\n        if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n          conn.commit();\n          rowCount = 0;\n        }\n      }\n\n      conn.commit();\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n    long end = System.currentTimeMillis();\n    if ((end - start) > 60000l) {\n      LOG.info(\"Time to save: \" + (end - start) + \", \" +\n        \"thread = \" + Thread.currentThread().getName());\n    }\n  }","id":41032,"modified_method":"/**\n   * Save Metric aggregate records.\n   *\n   * @throws SQLException\n   */\n  public void saveClusterAggregateHourlyRecords(\n    Map<TimelineClusterMetric, MetricHostAggregate> records,\n    String tableName)\n    throws SQLException {\n    if (records == null || records.isEmpty()) {\n      LOG.debug(\"Empty aggregate records.\");\n      return;\n    }\n\n    long start = System.currentTimeMillis();\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    try {\n      stmt = conn.prepareStatement(String.format\n        (UPSERT_CLUSTER_AGGREGATE_TIME_SQL, tableName));\n      int rowCount = 0;\n\n      for (Map.Entry<TimelineClusterMetric, MetricHostAggregate>\n        aggregateEntry : records.entrySet()) {\n        TimelineClusterMetric clusterMetric = aggregateEntry.getKey();\n        MetricHostAggregate aggregate = aggregateEntry.getValue();\n\n        LOG.trace(\"clusterMetric = \" + clusterMetric + \", \" +\n          \"aggregate = \" + aggregate);\n\n        rowCount++;\n        stmt.clearParameters();\n        stmt.setString(1, clusterMetric.getMetricName());\n        stmt.setString(2, clusterMetric.getAppId());\n        stmt.setString(3, clusterMetric.getInstanceId());\n        stmt.setLong(4, clusterMetric.getTimestamp());\n        stmt.setString(5, clusterMetric.getType());\n        stmt.setDouble(6, aggregate.getSum());\n//        stmt.setInt(7, aggregate.getNumberOfHosts());\n        stmt.setLong(7, aggregate.getNumberOfSamples());\n        stmt.setDouble(8, aggregate.getMax());\n        stmt.setDouble(9, aggregate.getMin());\n\n        try {\n          stmt.executeUpdate();\n        } catch (SQLException sql) {\n          // we have no way to verify it works!!!\n          LOG.error(sql);\n        }\n\n        if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n          conn.commit();\n          rowCount = 0;\n        }\n      }\n\n      conn.commit();\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n    long end = System.currentTimeMillis();\n    if ((end - start) > 60000l) {\n      LOG.info(\"Time to save: \" + (end - start) + \", \" +\n        \"thread = \" + Thread.currentThread().getName());\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"public void insertMetricRecords(TimelineMetrics metrics)\n    throws SQLException, IOException {\n\n    List<TimelineMetric> timelineMetrics = metrics.getMetrics();\n    if (timelineMetrics == null || timelineMetrics.isEmpty()) {\n      LOG.debug(\"Empty metrics insert request.\");\n      return;\n    }\n\n    Connection conn = getConnection();\n    PreparedStatement metricRecordStmt = null;\n    long currentTime = System.currentTimeMillis();\n\n    try {\n      metricRecordStmt = conn.prepareStatement(String.format(\n        UPSERT_METRICS_SQL, METRICS_RECORD_TABLE_NAME));\n\n      for (TimelineMetric metric : timelineMetrics) {\n        metricRecordStmt.clearParameters();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"host: \" + metric.getHostName() + \", \" +\n            \"metricName = \" + metric.getMetricName() + \", \" +\n            \"values: \" + metric.getMetricValues());\n        }\n        Aggregator agg = new Aggregator();\n        double[] aggregates =  agg.calculateAggregates(\n          metric.getMetricValues());\n\n        metricRecordStmt.setString(1, metric.getMetricName());\n        metricRecordStmt.setString(2, metric.getHostName());\n        metricRecordStmt.setString(3, metric.getAppId());\n        metricRecordStmt.setString(4, metric.getInstanceId());\n        metricRecordStmt.setLong(5, currentTime);\n        metricRecordStmt.setLong(6, metric.getStartTime());\n        metricRecordStmt.setString(7, metric.getType());\n        metricRecordStmt.setDouble(8, aggregates[0]);\n        metricRecordStmt.setDouble(9, aggregates[1]);\n        metricRecordStmt.setDouble(10, aggregates[2]);\n        metricRecordStmt.setLong(11, (long)aggregates[3]);\n        String json =\n          TimelineUtils.dumpTimelineRecordtoJSON(metric.getMetricValues());\n        metricRecordStmt.setString(12, json);\n\n        try {\n          metricRecordStmt.executeUpdate();\n        } catch (SQLException sql) {\n          LOG.error(sql);\n        }\n      }\n\n      conn.commit();\n\n    } finally {\n      if (metricRecordStmt != null) {\n        try {\n          metricRecordStmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n  }","id":41033,"modified_method":"public void insertMetricRecords(TimelineMetrics metrics)\n    throws SQLException, IOException {\n\n    List<TimelineMetric> timelineMetrics = metrics.getMetrics();\n    if (timelineMetrics == null || timelineMetrics.isEmpty()) {\n      LOG.debug(\"Empty metrics insert request.\");\n      return;\n    }\n\n    Connection conn = getConnection();\n    PreparedStatement metricRecordStmt = null;\n    long currentTime = System.currentTimeMillis();\n\n    try {\n      metricRecordStmt = conn.prepareStatement(String.format(\n        UPSERT_METRICS_SQL, METRICS_RECORD_TABLE_NAME));\n\n      for (TimelineMetric metric : timelineMetrics) {\n        metricRecordStmt.clearParameters();\n\n        LOG.trace(\"host: \" + metric.getHostName() + \", \" +\n          \"metricName = \" + metric.getMetricName() + \", \" +\n          \"values: \" + metric.getMetricValues());\n        Aggregator agg = new Aggregator();\n        double[] aggregates =  agg.calculateAggregates(\n          metric.getMetricValues());\n\n        metricRecordStmt.setString(1, metric.getMetricName());\n        metricRecordStmt.setString(2, metric.getHostName());\n        metricRecordStmt.setString(3, metric.getAppId());\n        metricRecordStmt.setString(4, metric.getInstanceId());\n        metricRecordStmt.setLong(5, currentTime);\n        metricRecordStmt.setLong(6, metric.getStartTime());\n        metricRecordStmt.setString(7, metric.getType());\n        metricRecordStmt.setDouble(8, aggregates[0]);\n        metricRecordStmt.setDouble(9, aggregates[1]);\n        metricRecordStmt.setDouble(10, aggregates[2]);\n        metricRecordStmt.setLong(11, (long)aggregates[3]);\n        String json =\n          TimelineUtils.dumpTimelineRecordtoJSON(metric.getMetricValues());\n        metricRecordStmt.setString(12, json);\n\n        try {\n          metricRecordStmt.executeUpdate();\n        } catch (SQLException sql) {\n          LOG.error(sql);\n        }\n      }\n\n      conn.commit();\n\n    } finally {\n      if (metricRecordStmt != null) {\n        try {\n          metricRecordStmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get metrics aggregated across hosts.\n   *\n   * @param condition @Condition\n   * @return @TimelineMetrics\n   * @throws SQLException\n   */\n  public TimelineMetrics getAggregateMetricRecords(final Condition condition)\n    throws SQLException {\n\n    verifyCondition(condition);\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    try {\n      //get latest\n      if(condition.isPointInTime()) {\n        stmt = getLatestAggregateMetricRecords(condition, conn, metrics);\n      } else {\n        stmt = PhoenixTransactSQL.prepareGetAggregateSqlStmt(conn, condition);\n\n        ResultSet rs = stmt.executeQuery();\n        while (rs.next()) {\n          TimelineMetric metric = getAggregateTimelineMetricFromResultSet(rs);\n\n          if (condition.isGrouped()) {\n            metrics.addOrMergeTimelineMetric(metric);\n          } else {\n            metrics.getMetrics().add(metric);\n          }\n        }\n      }\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n\n    LOG.info(\"Aggregate records size: \" + metrics.getMetrics().size());\n    return metrics;\n  }","id":41034,"modified_method":"/**\n   * Get metrics aggregated across hosts.\n   *\n   * @param condition @Condition\n   * @return @TimelineMetrics\n   * @throws SQLException\n   */\n  public TimelineMetrics getAggregateMetricRecords(final Condition condition)\n    throws SQLException {\n\n    if (condition.isEmpty()) {\n      throw new SQLException(\"No filter criteria specified.\");\n    }\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    try {\n      stmt = PhoenixTransactSQL.prepareGetAggregateSqlStmt(conn, condition);\n\n      ResultSet rs = stmt.executeQuery();\n\n      while (rs.next()) {\n        TimelineMetric metric = new TimelineMetric();\n        metric.setMetricName(rs.getString(\"METRIC_NAME\"));\n        metric.setAppId(rs.getString(\"APP_ID\"));\n        metric.setInstanceId(rs.getString(\"INSTANCE_ID\"));\n        metric.setTimestamp(rs.getLong(\"SERVER_TIME\"));\n        metric.setStartTime(rs.getLong(\"SERVER_TIME\"));\n        Map<Long, Double> valueMap = new HashMap<Long, Double>();\n        valueMap.put(rs.getLong(\"SERVER_TIME\"),\n          rs.getDouble(\"METRIC_SUM\") / rs.getInt(\"HOSTS_COUNT\"));\n        metric.setMetricValues(valueMap);\n\n        if (condition.isGrouped()) {\n          metrics.addOrMergeTimelineMetric(metric);\n        } else {\n          metrics.getMetrics().add(metric);\n        }\n      }\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n    LOG.info(\"Aggregate records size: \" + metrics.getMetrics().size());\n    return metrics;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Save Metric aggregate records.\n   *\n   * @throws SQLException\n   */\n  public void saveClusterAggregateRecords(\n    Map<TimelineClusterMetric, MetricClusterAggregate> records)\n    throws SQLException {\n\n    if (records == null || records.isEmpty()) {\n      LOG.debug(\"Empty aggregate records.\");\n      return;\n    }\n\n    long start = System.currentTimeMillis();\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    try {\n      stmt = conn.prepareStatement(UPSERT_CLUSTER_AGGREGATE_SQL);\n      int rowCount = 0;\n\n      for (Map.Entry<TimelineClusterMetric, MetricClusterAggregate>\n        aggregateEntry : records.entrySet()) {\n        TimelineClusterMetric clusterMetric = aggregateEntry.getKey();\n        MetricClusterAggregate aggregate = aggregateEntry.getValue();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"clusterMetric = \" + clusterMetric + \", \" +\n            \"aggregate = \" + aggregate);\n        }\n\n        rowCount++;\n        stmt.clearParameters();\n        stmt.setString(1, clusterMetric.getMetricName());\n        stmt.setString(2, clusterMetric.getAppId());\n        stmt.setString(3, clusterMetric.getInstanceId());\n        stmt.setLong(4, clusterMetric.getTimestamp());\n        stmt.setString(5, clusterMetric.getType());\n        stmt.setDouble(6, aggregate.getSum());\n        stmt.setInt(7, aggregate.getNumberOfHosts());\n        stmt.setDouble(8, aggregate.getMax());\n        stmt.setDouble(9, aggregate.getMin());\n\n        try {\n          stmt.executeUpdate();\n        } catch (SQLException sql) {\n          // we have no way to verify it works!!!\n          LOG.error(sql);\n        }\n\n        if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n          conn.commit();\n          rowCount = 0;\n        }\n      }\n\n      conn.commit();\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n    long end = System.currentTimeMillis();\n    if ((end - start) > 60000l) {\n      LOG.info(\"Time to save: \" + (end - start) + \", \" +\n        \"thread = \" + Thread.currentThread().getName());\n    }\n  }","id":41035,"modified_method":"/**\n   * Save Metric aggregate records.\n   *\n   * @throws SQLException\n   */\n  public void saveClusterAggregateRecords(\n    Map<TimelineClusterMetric, MetricClusterAggregate> records)\n    throws SQLException {\n\n      if (records == null || records.isEmpty()) {\n        LOG.debug(\"Empty aggregate records.\");\n        return;\n      }\n\n      long start = System.currentTimeMillis();\n\n      Connection conn = getConnection();\n      PreparedStatement stmt = null;\n      try {\n        stmt = conn.prepareStatement(UPSERT_CLUSTER_AGGREGATE_SQL);\n        int rowCount = 0;\n\n        for (Map.Entry<TimelineClusterMetric, MetricClusterAggregate>\n          aggregateEntry : records.entrySet()) {\n          TimelineClusterMetric clusterMetric = aggregateEntry.getKey();\n          MetricClusterAggregate aggregate = aggregateEntry.getValue();\n\n          LOG.trace(\"clusterMetric = \" + clusterMetric + \", \" +\n            \"aggregate = \" + aggregate);\n\n          rowCount++;\n          stmt.clearParameters();\n          stmt.setString(1, clusterMetric.getMetricName());\n          stmt.setString(2, clusterMetric.getAppId());\n          stmt.setString(3, clusterMetric.getInstanceId());\n          stmt.setLong(4, clusterMetric.getTimestamp());\n          stmt.setString(5, clusterMetric.getType());\n          stmt.setDouble(6, aggregate.getSum());\n          stmt.setInt(7, aggregate.getNumberOfHosts());\n          stmt.setDouble(8, aggregate.getMax());\n          stmt.setDouble(9, aggregate.getMin());\n\n          try {\n            stmt.executeUpdate();\n          } catch (SQLException sql) {\n            // TODO: Why this exception is swallowed\n            LOG.error(sql);\n          }\n\n          if (rowCount >= PHOENIX_MAX_MUTATION_STATE_SIZE - 1) {\n            conn.commit();\n            rowCount = 0;\n          }\n        }\n\n        conn.commit();\n\n      } finally {\n        if (stmt != null) {\n          try {\n            stmt.close();\n          } catch (SQLException e) {\n            // Ignore\n          }\n        }\n        if (conn != null) {\n          try {\n            conn.close();\n          } catch (SQLException sql) {\n            // Ignore\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if ((end - start) > 60000l) {\n        LOG.info(\"Time to save: \" + (end - start) + \", \" +\n          \"thread = \" + Thread.currentThread().getName());\n      }\n    }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public TimelineMetrics getMetricRecords(final Condition condition)\n    throws SQLException, IOException {\n\n    verifyCondition(condition);\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    try {\n      //get latest\n      if(condition.isPointInTime()){\n        stmt = getLatestMetricRecords(condition, conn, metrics);\n      } else {\n        stmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt(conn, condition);\n\n        ResultSet rs = stmt.executeQuery();\n        while (rs.next()) {\n          TimelineMetric metric = getTimelineMetricFromResultSet(rs);\n\n          if (condition.isGrouped()) {\n            metrics.addOrMergeTimelineMetric(metric);\n          } else {\n            metrics.getMetrics().add(metric);\n          }\n        }\n      }\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n\n    LOG.info(\"Metrics records size: \" + metrics.getMetrics().size());\n    return metrics;\n  }","id":41036,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public TimelineMetrics getMetricRecords(final Condition condition)\n    throws SQLException, IOException {\n\n    if (condition.isEmpty()) {\n      throw new SQLException(\"No filter criteria specified.\");\n    }\n\n    Connection conn = getConnection();\n    PreparedStatement stmt = null;\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    try {\n      stmt = PhoenixTransactSQL.prepareGetMetricsSqlStmt(conn, condition);\n\n      ResultSet rs = stmt.executeQuery();\n\n      while (rs.next()) {\n        TimelineMetric metric = getTimelineMetricFromResultSet(rs);\n\n        if (condition.isGrouped()) {\n          metrics.addOrMergeTimelineMetric(metric);\n        } else {\n          metrics.getMetrics().add(metric);\n        }\n      }\n\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          // Ignore\n        }\n      }\n      if (conn != null) {\n        try {\n          conn.close();\n        } catch (SQLException sql) {\n          // Ignore\n        }\n      }\n    }\n    return metrics;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"static TimelineMetric getTimelineMetricFromResultSet(ResultSet rs)\n    throws SQLException, IOException {\n    TimelineMetric metric = getTimelineMetricCommonsFromResultSet(rs);\n    Map<Long, Double> sortedByTimeMetrics =\n      new TreeMap<Long, Double>(readMetricFromJSON(rs.getString(\"METRICS\")));\n    metric.setMetricValues(sortedByTimeMetrics);\n    return metric;\n  }","id":41037,"modified_method":"@SuppressWarnings(\"unchecked\")\n  static TimelineMetric getTimelineMetricFromResultSet(ResultSet rs)\n    throws SQLException, IOException {\n    TimelineMetric metric = new TimelineMetric();\n    metric.setMetricName(rs.getString(\"METRIC_NAME\"));\n    metric.setAppId(rs.getString(\"APP_ID\"));\n    metric.setInstanceId(rs.getString(\"INSTANCE_ID\"));\n    metric.setHostName(rs.getString(\"HOSTNAME\"));\n    metric.setTimestamp(rs.getLong(\"SERVER_TIME\"));\n    metric.setStartTime(rs.getLong(\"START_TIME\"));\n    metric.setType(rs.getString(\"UNITS\"));\n    Map<Long, Double> sortedByTimeMetrics =\n        new TreeMap<Long, Double>((Map<Long, Double>) readMetricFromJSON(rs.getString(\"METRICS\")));\n    metric.setMetricValues(sortedByTimeMetrics);\n    return metric;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public static Map<Long, Double>  readMetricFromJSON(String json)\n    throws IOException {\n    return (Map<Long, Double>) mapper.readValue(json, metricValuesTypeRef);\n  }","id":41038,"modified_method":"public static Map readMetricFromJSON(String json) throws IOException {\n    return mapper.readValue(json, metricValuesTypeRef);\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"public static PreparedStatement prepareGetAggregateSqlStmt(\n    Connection connection, Condition condition) throws SQLException {\n\n    if (condition.isEmpty()) {\n      throw new IllegalArgumentException(\"Condition is empty.\");\n    }\n\n    StringBuilder sb = new StringBuilder(GET_CLUSTER_AGGREGATE_SQL);\n    sb.append(\" WHERE \");\n    sb.append(condition.getConditionClause());\n    sb.append(\" ORDER BY METRIC_NAME, SERVER_TIME\");\n    if (condition.getLimit() != null) {\n      sb.append(\" LIMIT \").append(condition.getLimit());\n    }\n\n    String query = String.format(sb.toString(),\n      PhoenixTransactSQL.getNaiveTimeRangeHint(condition.getStartTime(),\n        NATIVE_TIME_RANGE_DELTA));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"SQL => \" + query + \", condition => \" + condition);\n    }\n    PreparedStatement stmt = connection.prepareStatement(query);\n    int pos = 1;\n    if (condition.getMetricNames() != null) {\n      for (; pos <= condition.getMetricNames().size(); pos++) {\n        stmt.setString(pos, condition.getMetricNames().get(pos - 1));\n      }\n    }\n    // TODO: Upper case all strings on POST\n    if (condition.getAppId() != null) {\n      stmt.setString(pos++, condition.getAppId());\n    }\n    if (condition.getInstanceId() != null) {\n      stmt.setString(pos++, condition.getInstanceId());\n    }\n    if (condition.getStartTime() != null) {\n      stmt.setLong(pos++, condition.getStartTime());\n    }\n    if (condition.getEndTime() != null) {\n      stmt.setLong(pos, condition.getEndTime());\n    }\n\n    return stmt;\n  }","id":41039,"modified_method":"public static PreparedStatement prepareGetAggregateSqlStmt(\n    Connection connection, Condition condition) throws SQLException {\n\n    if (condition.isEmpty()) {\n      throw new IllegalArgumentException(\"Condition is empty.\");\n    }\n\n    StringBuilder sb = new StringBuilder(GET_CLUSTER_AGGREGATE_SQL);\n    sb.append(\" WHERE \");\n    sb.append(condition.getConditionClause());\n    sb.append(\" ORDER BY METRIC_NAME, SERVER_TIME\");\n    if (condition.getLimit() != null) {\n      sb.append(\" LIMIT \").append(condition.getLimit());\n    }\n\n    String query = String.format(sb.toString(),\n      PhoenixTransactSQL.getNaiveTimeRangeHint(condition.getStartTime(),\n        NATIVE_TIME_RANGE_DELTA));\n    LOG.debug(\"SQL => \" + query + \", condition => \" + condition);\n    PreparedStatement stmt = connection.prepareStatement(query);\n    int pos = 1;\n    if (condition.getMetricNames() != null) {\n      for (; pos <= condition.getMetricNames().size(); pos++) {\n        stmt.setString(pos, condition.getMetricNames().get(pos - 1));\n      }\n    }\n    // TODO: Upper case all strings on POST\n    if (condition.getAppId() != null) {\n      stmt.setString(pos++, condition.getAppId());\n    }\n    if (condition.getInstanceId() != null) {\n      stmt.setString(pos++, condition.getInstanceId());\n    }\n    if (condition.getStartTime() != null) {\n      stmt.setLong(pos++, condition.getStartTime());\n    }\n    if (condition.getEndTime() != null) {\n      stmt.setLong(pos, condition.getEndTime());\n    }\n\n    return stmt;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"public static PreparedStatement prepareGetMetricsSqlStmt(\n    Connection connection, Condition condition) throws SQLException {\n\n    if (condition.isEmpty()) {\n      throw new IllegalArgumentException(\"Condition is empty.\");\n    }\n    String stmtStr;\n    if (condition.getStatement() != null) {\n      stmtStr = condition.getStatement();\n    } else {\n      stmtStr = String.format(GET_METRIC_SQL,\n        getNaiveTimeRangeHint(condition.getStartTime(), NATIVE_TIME_RANGE_DELTA),\n        METRICS_RECORD_TABLE_NAME);\n    }\n\n    StringBuilder sb = new StringBuilder(stmtStr);\n    sb.append(\" WHERE \");\n    sb.append(condition.getConditionClause());\n    String orderByClause = condition.getOrderByClause();\n\n    if (orderByClause != null) {\n      sb.append(orderByClause);\n    } else {\n      sb.append(\" ORDER BY METRIC_NAME, SERVER_TIME \");\n    }\n    if (condition.getLimit() != null) {\n      sb.append(\" LIMIT \").append(condition.getLimit());\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"SQL: \" + sb.toString() + \", condition: \" + condition);\n    }\n    PreparedStatement stmt = connection.prepareStatement(sb.toString());\n    int pos = 1;\n    if (condition.getMetricNames() != null) {\n      for (; pos <= condition.getMetricNames().size(); pos++) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Setting pos: \" + pos + \", value = \" + condition.getMetricNames().get(pos - 1));\n        }\n        stmt.setString(pos, condition.getMetricNames().get(pos - 1));\n      }\n    }\n    if (condition.getHostname() != null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getHostname());\n      }\n      stmt.setString(pos++, condition.getHostname());\n    }\n    if (condition.getAppId() != null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getAppId());\n      }\n      stmt.setString(pos++, condition.getAppId());\n    }\n    if (condition.getInstanceId() != null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getInstanceId());\n      }\n      stmt.setString(pos++, condition.getInstanceId());\n    }\n    if (condition.getStartTime() != null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getStartTime());\n      }\n      stmt.setLong(pos++, condition.getStartTime());\n    }\n    if (condition.getEndTime() != null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getEndTime());\n      }\n      stmt.setLong(pos, condition.getEndTime());\n    }\n    if (condition.getFetchSize() != null) {\n      stmt.setFetchSize(condition.getFetchSize());\n    }\n\n    return stmt;\n  }","id":41040,"modified_method":"public static PreparedStatement prepareGetMetricsSqlStmt(\n    Connection connection, Condition condition) throws SQLException {\n\n    if (condition.isEmpty()) {\n      throw new IllegalArgumentException(\"Condition is empty.\");\n    }\n    String stmtStr;\n    if (condition.getStatement() != null) {\n      stmtStr = condition.getStatement();\n    } else {\n      stmtStr = String.format(GET_METRIC_SQL,\n        getNaiveTimeRangeHint(condition.getStartTime(), NATIVE_TIME_RANGE_DELTA),\n        METRICS_RECORD_TABLE_NAME);\n    }\n\n    StringBuilder sb = new StringBuilder(stmtStr);\n    sb.append(\" WHERE \");\n    sb.append(condition.getConditionClause());\n    String orderByClause = condition.getOrderByClause();\n\n    if (orderByClause != null) {\n      sb.append(orderByClause);\n    } else {\n      sb.append(\" ORDER BY METRIC_NAME, SERVER_TIME \");\n    }\n    if (condition.getLimit() != null) {\n      sb.append(\" LIMIT \").append(condition.getLimit());\n    }\n\n    LOG.debug(\"SQL: \" + sb.toString() + \", condition: \" + condition);\n    PreparedStatement stmt = connection.prepareStatement(sb.toString());\n    int pos = 1;\n    if (condition.getMetricNames() != null) {\n      for (; pos <= condition.getMetricNames().size(); pos++) {\n        LOG.debug(\"Setting pos: \" + pos + \", value = \" + condition.getMetricNames().get(pos - 1));\n        stmt.setString(pos, condition.getMetricNames().get(pos - 1));\n      }\n    }\n    if (condition.getHostname() != null) {\n      LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getHostname());\n      stmt.setString(pos++, condition.getHostname());\n    }\n    if (condition.getAppId() != null) {\n      LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getAppId());\n      stmt.setString(pos++, condition.getAppId());\n    }\n    if (condition.getInstanceId() != null) {\n      LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getInstanceId());\n      stmt.setString(pos++, condition.getInstanceId());\n    }\n    if (condition.getStartTime() != null) {\n      LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getStartTime());\n      stmt.setLong(pos++, condition.getStartTime());\n    }\n    if (condition.getEndTime() != null) {\n      LOG.debug(\"Setting pos: \" + pos + \", value: \" + condition.getEndTime());\n      stmt.setLong(pos, condition.getEndTime());\n    }\n    if (condition.getFetchSize() != null) {\n      stmt.setFetchSize(condition.getFetchSize());\n    }\n\n    return stmt;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public String getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n\n      if (getMetricNames() != null) {\n        sb.append(\"(\");\n        for (String name : getMetricNames()) {\n          if (sb.length() > 1) {\n            sb.append(\" OR \");\n          }\n          sb.append(\"METRIC_NAME LIKE ?\");\n        }\n\n        sb.append(\")\");\n        appendConjunction = true;\n      }\n\n      appendConjunction = append(sb, appendConjunction, getHostname(), \" HOSTNAME = ?\");\n      appendConjunction = append(sb, appendConjunction, getAppId(), \" APP_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getInstanceId(), \" INSTANCE_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getStartTime(), \" SERVER_TIME >= ?\");\n      append(sb, appendConjunction, getEndTime(), \" SERVER_TIME < ?\");\n\n      return sb.toString();\n    }","id":41041,"modified_method":"@Override\n    String getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n\n      if (getMetricNames() != null) {\n        sb.append(\"(\");\n        for (String name : metricNames) {\n          if (sb.length() > 1) {\n            sb.append(\" OR \");\n          }\n          sb.append(\"METRIC_NAME LIKE ?\");\n        }\n        sb.append(\")\");\n        appendConjunction = true;\n      }\n      if (appendConjunction) {\n        sb.append(\" AND\");\n      }\n      appendConjunction = false;\n      if (getHostname() != null) {\n        sb.append(\" HOSTNAME = ?\");\n        appendConjunction = true;\n      }\n      if (appendConjunction) {\n        sb.append(\" AND\");\n      }\n      appendConjunction = false;\n      if (getAppId() != null) {\n        sb.append(\" APP_ID = ?\");\n        appendConjunction = true;\n      }\n      if (appendConjunction) {\n        sb.append(\" AND\");\n      }\n      appendConjunction = false;\n      if (getInstanceId() != null) {\n        sb.append(\" INSTANCE_ID = ?\");\n        appendConjunction = true;\n      }\n      if (appendConjunction) {\n        sb.append(\" AND\");\n      }\n      appendConjunction = false;\n      if (getStartTime() != null) {\n        sb.append(\" SERVER_TIME >= ?\");\n        appendConjunction = true;\n      }\n      if (appendConjunction) {\n        sb.append(\" AND\");\n      }\n      if (getEndTime() != null) {\n        sb.append(\" SERVER_TIME < ?\");\n      }\n      return sb.toString();\n    }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testConditionClause() throws Exception {\n    Condition condition = new DefaultCondition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, false);\n\n    String preparedClause = condition.getConditionClause();\n    String expectedClause = \"METRIC_NAME IN (?, ?) AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","id":41042,"modified_method":"@Test\n  public void testConditionClause() throws Exception {\n    Condition condition = new Condition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, false);\n\n    String preparedClause = condition.getConditionClause();\n    String expectedClause = \"METRIC_NAME IN (?, ?) AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime, long endTime) {\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, nativeTimeRangeDelay),\n      tableName));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"HOSTNAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","id":41043,"modified_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime, long endTime) {\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_METRIC_AGGREGATE_ONLY_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, nativeTimeRangeDelay),\n      tableName));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"HOSTNAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime, long endTime) {\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_METRIC_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_RECORD_TABLE_NAME));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","id":41044,"modified_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime, long endTime) {\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_METRIC_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA),\n      METRICS_RECORD_TABLE_NAME));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime,\n                                                  long endTime) {\n    Condition condition = new DefaultCondition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","id":41045,"modified_method":"@Override\n  protected Condition prepareMetricQueryCondition(long startTime,\n                                                  long endTime) {\n    Condition condition = new Condition(null, null, null, null, startTime,\n      endTime, null, true);\n    condition.setNoLimit();\n    condition.setFetchSize(resultsetFetchSize);\n    condition.setStatement(String.format(GET_CLUSTER_AGGREGATE_SQL,\n      PhoenixTransactSQL.getNaiveTimeRangeHint(startTime, NATIVE_TIME_RANGE_DELTA)));\n    condition.addOrderByColumn(\"METRIC_NAME\");\n    condition.addOrderByColumn(\"APP_ID\");\n    condition.addOrderByColumn(\"INSTANCE_ID\");\n    condition.addOrderByColumn(\"SERVER_TIME\");\n    return condition;\n  }","commit_id":"102b47736e9f721baa6bac434cd58bfeaf105aff","url":"https://github.com/apache/ambari"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public static TreeMap<Long, Double>  readMetricFromJSON(String json) throws IOException {\n    return (TreeMap<Long, Double>) mapper.readValue(json, metricValuesTypeRef);\n  }","id":41046,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public static TreeMap<Long, Double>  readMetricFromJSON(String json) throws IOException {\n    return mapper.readValue(json, metricValuesTypeRef);\n  }","commit_id":"b0aeefc87daa7ed8040032a2998764f27bbdaa8d","url":"https://github.com/apache/ambari"},{"original_method":"public TimelineMetric getTimelineMetricFromResultSet(ResultSet rs)\n      throws SQLException, IOException {\n    TimelineMetric metric = getTimelineMetricCommonsFromResultSet(rs);\n    TreeMap<Long, Double> sortedByTimeMetrics = new TreeMap<Long, Double>(\n        PhoenixHBaseAccessor.readMetricFromJSON(rs.getString(\"METRICS\")));\n    metric.setMetricValues(sortedByTimeMetrics);\n    return metric;\n  }","id":41047,"modified_method":"public TimelineMetric getTimelineMetricFromResultSet(ResultSet rs)\n      throws SQLException, IOException {\n    TimelineMetric metric = getTimelineMetricCommonsFromResultSet(rs);\n    TreeMap<Long, Double> sortedByTimeMetrics =\n      PhoenixHBaseAccessor.readMetricFromJSON(rs.getString(\"METRICS\"));\n    metric.setMetricValues(sortedByTimeMetrics);\n    return metric;\n  }","commit_id":"b0aeefc87daa7ed8040032a2998764f27bbdaa8d","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Sets alluxio home.\n   *\n   * @throws IOException when the operation fails\n   */\n  protected void setAlluxioHome() {\n    mHome = AlluxioTestDirectory.createTemporaryDirectory(\"test-cluster\").getAbsolutePath();\n  }","id":41048,"modified_method":"/**\n   * Sets alluxio home.\n   */\n  protected void setAlluxioHome() {\n    mHome = AlluxioTestDirectory.createTemporaryDirectory(\"test-cluster\").getAbsolutePath();\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Given an allocator with the location and blockSize,\n   * we assert the allocator should be able to\n   * 1. @param avail: the block should be successfully allocated or not\n   * 2. @param tierAlias: the block should be allocated at this tier\n   * 3. @param dirIndex : the block should be allocated at this dir\n   */\n  protected void assertTempBlockMeta(Allocator allocator, BlockStoreLocation location,\n      int blockSize, boolean avail, String tierAlias, int dirIndex) throws Exception {\n\n    mTestBlockId++;\n\n    StorageDirView dirView =\n        allocator.allocateBlockWithView(SESSION_ID, blockSize, location, getManagerView());\n    TempBlockMeta tempBlockMeta =\n        dirView == null ? null : dirView.createTempBlockMeta(SESSION_ID, mTestBlockId, blockSize);\n\n    if (avail == false) {\n      Assert.assertTrue(tempBlockMeta == null);\n    } else {\n      Assert.assertTrue(tempBlockMeta != null);\n\n      StorageDir pDir = tempBlockMeta.getParentDir();\n      StorageTier pTier = pDir.getParentTier();\n\n      Assert.assertTrue(pDir.getDirIndex() == dirIndex);\n      Assert.assertTrue(pTier.getTierAlias() == tierAlias);\n\n      //update the dir meta info\n      pDir.addBlockMeta(new BlockMeta(mTestBlockId, blockSize, pDir));\n    }\n  }","id":41049,"modified_method":"/**\n   * Given an allocator with the location and blockSize,\n   * we assert the allocator should be able to\n   * 1. @param avail: the block should be successfully allocated or not\n   * 2. @param tierAlias: the block should be allocated at this tier\n   * 3. @param dirIndex : the block should be allocated at this dir\n   */\n  protected void assertTempBlockMeta(Allocator allocator, BlockStoreLocation location,\n      int blockSize, boolean avail, String tierAlias, int dirIndex) throws Exception {\n\n    mTestBlockId++;\n\n    StorageDirView dirView =\n        allocator.allocateBlockWithView(SESSION_ID, blockSize, location, getManagerView());\n    TempBlockMeta tempBlockMeta =\n        dirView == null ? null : dirView.createTempBlockMeta(SESSION_ID, mTestBlockId, blockSize);\n\n    if (!avail) {\n      Assert.assertTrue(tempBlockMeta == null);\n    } else {\n      Assert.assertTrue(tempBlockMeta != null);\n\n      StorageDir pDir = tempBlockMeta.getParentDir();\n      StorageTier pTier = pDir.getParentTier();\n\n      Assert.assertTrue(pDir.getDirIndex() == dirIndex);\n      Assert.assertTrue(pTier.getTierAlias() == tierAlias);\n\n      //update the dir meta info\n      pDir.addBlockMeta(new BlockMeta(mTestBlockId, blockSize, pDir));\n    }\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Given an allocator with the location and blockSize, we assert whether the block can be\n   * allocated.\n   */\n  protected void assertTempBlockMeta(Allocator allocator, BlockStoreLocation location,\n      long blockSize, boolean avail) throws IOException {\n\n    mTestBlockId++;\n    StorageDirView dirView =\n        allocator.allocateBlockWithView(SESSION_ID, blockSize, location, getManagerView());\n    TempBlockMeta tempBlockMeta =\n        dirView == null ? null : dirView.createTempBlockMeta(SESSION_ID, mTestBlockId, blockSize);\n\n    if (avail == false) {\n      Assert.assertTrue(tempBlockMeta == null);\n    } else {\n      Assert.assertTrue(tempBlockMeta != null);\n    }\n  }","id":41050,"modified_method":"/**\n   * Given an allocator with the location and blockSize, we assert whether the block can be\n   * allocated.\n   */\n  protected void assertTempBlockMeta(Allocator allocator, BlockStoreLocation location,\n      long blockSize, boolean avail) throws IOException {\n\n    mTestBlockId++;\n    StorageDirView dirView =\n        allocator.allocateBlockWithView(SESSION_ID, blockSize, location, getManagerView());\n    TempBlockMeta tempBlockMeta =\n        dirView == null ? null : dirView.createTempBlockMeta(SESSION_ID, mTestBlockId, blockSize);\n\n    if (!avail) {\n      Assert.assertTrue(tempBlockMeta == null);\n    } else {\n      Assert.assertTrue(tempBlockMeta != null);\n    }\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getMetricsTest() throws Exception {\n    String result =\n        new TestCase(mHostname, mPort, getEndpoint(AlluxioMasterRestServiceHandler.GET_METRICS),\n            NO_PARAMS, HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Long> metrics = (Map<String, Long>) new ObjectMapper().readValue(result,\n        new TypeReference<Map<String, Long>>() {});\n\n    Assert.assertEquals(Long.valueOf(0), metrics.get(\"master.CompleteFileOps\"));\n  }","id":41051,"modified_method":"@Test\n  public void getMetricsTest() throws Exception {\n    String result =\n        new TestCase(mHostname, mPort, getEndpoint(AlluxioMasterRestServiceHandler.GET_METRICS),\n            NO_PARAMS, HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Long> metrics = new ObjectMapper().readValue(result,\n        new TypeReference<Map<String, Long>>() {});\n\n    Assert.assertEquals(Long.valueOf(0), metrics.get(\"master.CompleteFileOps\"));\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getMetricsTest() throws Exception {\n    String result =\n        new TestCase(mHostname, mPort, getEndpoint(AlluxioWorkerRestServiceHandler.GET_METRICS),\n            NO_PARAMS, HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Long> metrics = (Map<String, Long>) new ObjectMapper().readValue(result,\n        new TypeReference<Map<String, Long>>() {});\n\n    String blocksAccessedMetricName =\n        WorkerContext.getWorkerSource().getName() + \".\" + WorkerSource.BLOCKS_ACCESSED;\n    Assert.assertTrue(metrics.get(blocksAccessedMetricName) >= 0);\n  }","id":41052,"modified_method":"@Test\n  public void getMetricsTest() throws Exception {\n    String result =\n        new TestCase(mHostname, mPort, getEndpoint(AlluxioWorkerRestServiceHandler.GET_METRICS),\n            NO_PARAMS, HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Long> metrics = new ObjectMapper().readValue(result,\n        new TypeReference<Map<String, Long>>() {});\n\n    String blocksAccessedMetricName =\n        WorkerContext.getWorkerSource().getName() + \".\" + WorkerSource.BLOCKS_ACCESSED;\n    Assert.assertTrue(metrics.get(blocksAccessedMetricName) >= 0);\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getDirectoryPathsOnTiersTest() throws Exception {\n    String result = new TestCase(mHostname, mPort,\n        getEndpoint(AlluxioWorkerRestServiceHandler.GET_DIRECTORY_PATHS_ON_TIERS), NO_PARAMS,\n        HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, List<String>> pathsOnTiers = (Map<String, List<String>>) new ObjectMapper()\n        .readValue(result, new TypeReference<Map<String, List<String>>>() {});\n    Entry<String, List<String>> entry = Iterables.getOnlyElement(pathsOnTiers.entrySet());\n    Assert.assertEquals(\"MEM\", entry.getKey());\n    String path = Iterables.getOnlyElement(entry.getValue());\n    Assert.assertTrue(path.contains(Configuration.get(PropertyKey.WORKER_DATA_FOLDER)));\n  }","id":41053,"modified_method":"@Test\n  public void getDirectoryPathsOnTiersTest() throws Exception {\n    String result = new TestCase(mHostname, mPort,\n        getEndpoint(AlluxioWorkerRestServiceHandler.GET_DIRECTORY_PATHS_ON_TIERS), NO_PARAMS,\n        HttpMethod.GET, null).call();\n    @SuppressWarnings(\"unchecked\")\n    Map<String, List<String>> pathsOnTiers = new ObjectMapper()\n        .readValue(result, new TypeReference<Map<String, List<String>>>() {});\n    Entry<String, List<String>> entry = Iterables.getOnlyElement(pathsOnTiers.entrySet());\n    Assert.assertEquals(\"MEM\", entry.getKey());\n    String path = Iterables.getOnlyElement(entry.getValue());\n    Assert.assertTrue(path.contains(Configuration.get(PropertyKey.WORKER_DATA_FOLDER)));\n  }","commit_id":"dafc1c533fdd0289361f9e71515cd6701939b9ca","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override public boolean checkout(Run<?,?> build, Launcher launcher, FilePath remoteDir, TaskListener listener, File changeLogFile) throws IOException, InterruptedException {\n        if (changeLogFile != null) {\n            return createEmptyChangeLog(changeLogFile, listener, \"log\");\n        } else {\n            return true;\n        }\n    }","id":41054,"modified_method":"@Override public void checkout(Run<?,?> build, Launcher launcher, FilePath remoteDir, TaskListener listener, File changeLogFile) throws IOException, InterruptedException {\n        if (changeLogFile != null) {\n            createEmptyChangeLog(changeLogFile, listener, \"log\");\n        }\n    }","commit_id":"ae09ee99c2090f5922a9f278374bde51080869dc","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Obtains a fresh workspace of the module(s) into the specified directory\n     * of the specified machine.\n     *\n     * <p>\n     * The \"update\" operation can be performed instead of a fresh checkout if\n     * feasible.\n     *\n     * <p>\n     * This operation should also capture the information necessary to tag the workspace later.\n     *\n     * @param launcher\n     *      Abstracts away the machine that the files will be checked out.\n     * @param workspace\n     *      a directory to check out the source code. May contain left-over\n     *      from the previous build.\n     * @param changelogFile\n     *      Upon a successful return, this file should capture the changelog.\n     *      When there's no change, this file should contain an empty entry.\n     *      See {@link #createEmptyChangeLog(File, TaskListener, String)}.\n     *      May be null, in which case no changelog was requested.\n     * @return\n     *      false if the operation fails. The error should be reported to the listener.\n     *      Otherwise return the changes included in this update (if this was an update.)\n     *      <p>\n     *      Using the return value to indicate success/failure should\n     *      be considered deprecated, and implementations are encouraged\n     *      to throw {@link AbortException} to indicate a failure.\n     *\n     * @throws InterruptedException\n     *      interruption is usually caused by the user aborting the build.\n     *      this exception will cause the build to be aborted.\n     */\n    public boolean checkout(Run<?,?> build, Launcher launcher, FilePath workspace, TaskListener listener, @CheckForNull File changelogFile) throws IOException, InterruptedException {\n        if (build instanceof AbstractBuild && listener instanceof BuildListener && Util.isOverridden(SCM.class, getClass(), \"checkout\", AbstractBuild.class, Launcher.class, FilePath.class, BuildListener.class, File.class)) {\n            if (changelogFile == null) {\n                changelogFile = File.createTempFile(\"changelog\", \".xml\");\n                try {\n                    return checkout((AbstractBuild) build, launcher, workspace, (BuildListener) listener, changelogFile);\n                } finally {\n                    Util.deleteFile(changelogFile);\n                }\n            } else {\n                return checkout((AbstractBuild) build, launcher, workspace, (BuildListener) listener, changelogFile);\n            }\n        } else {\n            throw new AbstractMethodError(\"you must override the new overload of checkout\");\n        }\n    }","id":41055,"modified_method":"/**\n     * Obtains a fresh workspace of the module(s) into the specified directory\n     * of the specified machine.\n     *\n     * <p>\n     * The \"update\" operation can be performed instead of a fresh checkout if\n     * feasible.\n     *\n     * <p>\n     * This operation should also capture the information necessary to tag the workspace later.\n     *\n     * @param launcher\n     *      Abstracts away the machine that the files will be checked out.\n     * @param workspace\n     *      a directory to check out the source code. May contain left-over\n     *      from the previous build.\n     * @param changelogFile\n     *      Upon a successful return, this file should capture the changelog.\n     *      When there's no change, this file should contain an empty entry.\n     *      See {@link #createEmptyChangeLog(File, TaskListener, String)}.\n     *      May be null, in which case no changelog was requested.\n     *\n     * @throws InterruptedException\n     *      interruption is usually caused by the user aborting the build.\n     *      this exception will cause the build to be aborted.\n     * @throws AbortException in case of a routine failure\n     */\n    public void checkout(Run<?,?> build, Launcher launcher, FilePath workspace, TaskListener listener, @CheckForNull File changelogFile) throws IOException, InterruptedException {\n        if (build instanceof AbstractBuild && listener instanceof BuildListener && Util.isOverridden(SCM.class, getClass(), \"checkout\", AbstractBuild.class, Launcher.class, FilePath.class, BuildListener.class, File.class)) {\n            if (changelogFile == null) {\n                changelogFile = File.createTempFile(\"changelog\", \".xml\");\n                try {\n                    if (!checkout((AbstractBuild) build, launcher, workspace, (BuildListener) listener, changelogFile)) {\n                        throw new AbortException();\n                    }\n                } finally {\n                    Util.deleteFile(changelogFile);\n                }\n            } else {\n                if (!checkout((AbstractBuild) build, launcher, workspace, (BuildListener) listener, changelogFile)) {\n                    throw new AbortException();\n                }\n            }\n        } else {\n            throw new AbstractMethodError(\"you must override the new overload of checkout\");\n        }\n    }","commit_id":"ae09ee99c2090f5922a9f278374bde51080869dc","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Deprecated\n    protected final boolean createEmptyChangeLog(File changelogFile, BuildListener listener, String rootTag) {\n        return createEmptyChangeLog(changelogFile, (TaskListener) listener, rootTag);\n    }","id":41056,"modified_method":"@Deprecated\n    protected final boolean createEmptyChangeLog(File changelogFile, BuildListener listener, String rootTag) {\n        try {\n            createEmptyChangeLog(changelogFile, (TaskListener) listener, rootTag);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace(listener.error(e.getMessage()));\n            return false;\n        }\n    }","commit_id":"ae09ee99c2090f5922a9f278374bde51080869dc","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected final boolean createEmptyChangeLog(File changelogFile, TaskListener listener, String rootTag) {\n        FileWriter w = null;\n        try {\n            w = new FileWriter(changelogFile);\n            w.write(\"<\"+rootTag +\"/>\");\n            w.close();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace(listener.error(e.getMessage()));\n            return false;\n        } finally {\n            IOUtils.closeQuietly(w);\n        }\n    }","id":41057,"modified_method":"protected final void createEmptyChangeLog(File changelogFile, TaskListener listener, String rootTag) throws IOException {\n        FileWriter w = null;\n        try {\n            w = new FileWriter(changelogFile);\n            w.write(\"<\"+rootTag +\"/>\");\n            w.close();\n        } finally {\n            IOUtils.closeQuietly(w);\n        }\n    }","commit_id":"ae09ee99c2090f5922a9f278374bde51080869dc","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Deprecated\n    public boolean checkout(AbstractBuild<?,?> build, Launcher launcher, FilePath workspace, BuildListener listener, @Nonnull File changelogFile) throws IOException, InterruptedException {\n        return checkout((Run) build, launcher, workspace, listener, changelogFile);\n    }","id":41058,"modified_method":"@Deprecated\n    public boolean checkout(AbstractBuild<?,?> build, Launcher launcher, FilePath workspace, BuildListener listener, @Nonnull File changelogFile) throws IOException, InterruptedException {\n        checkout((Run) build, launcher, workspace, listener, changelogFile);\n        return true;\n    }","commit_id":"ae09ee99c2090f5922a9f278374bde51080869dc","url":"https://github.com/kohsuke/hudson"},{"original_method":"private static boolean init(Project project, VirtualFile root) {\n    try {\n      Git.init(project, root);\n    } catch (VcsException e) {\n      LOG.info(\"init \", e);\n      GitUIUtil.notifyError(project, \"Couldn't clone\", \"Couldn't <code>git init<\/code> in <code>\" + root.getPresentableUrl() + \"<\/code>\", true, e);\n      return false;\n    }\n    return true;\n  }","id":41059,"modified_method":"private static boolean init(Project project, VirtualFile root) {\n    try {\n      Git.init(project, root);\n    } catch (VcsException e) {\n      LOG.info(\"init \", e);\n      GitVcs vcs = GitVcs.getInstance(project);\n      if (vcs == null || vcs.getExecutableValidator().isExecutableValid()) { // invalid executable will be notified in GitHandler.start()\n        GitUIUtil.notifyError(project, \"Couldn't clone\", \"Couldn't <code>git init<\/code> in <code>\" + root.getPresentableUrl() + \"<\/code>\", true, e);\n      }\n      return false;\n    }\n    return true;\n  }","commit_id":"668fb25e28d17f8c77dbc6edd67c7e732d2d5af5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static @Nullable VirtualFile mkdir(Project project, String directoryName, String parentDirectory) {\n    final File dir = new File(parentDirectory, directoryName);\n    if (dir.exists()) {\n      GitUIUtil.notifyError(project, \"Couldn't clone\", \"Directory <code>\" + dir + \"<\/code> already exists.\");\n      return null;\n    }\n    if (!dir.mkdir()) {\n      GitUIUtil.notifyError(project, \"Couldn't clone\", \"Can't create directory <code>\" + dir + \"<\/code>\");\n      return null;\n    }\n\n    return VcsUtil.getVirtualFileWithRefresh(dir);\n  }","id":41060,"modified_method":"private static @Nullable File mkdir(Project project, String directoryName, String parentDirectory) {\n    final File dir = new File(parentDirectory, directoryName);\n    if (dir.exists()) {\n      GitUIUtil.notifyError(project, \"Couldn't clone\", \"Directory <code>\" + dir + \"<\/code> already exists.\");\n      return null;\n    }\n    if (!dir.mkdir()) {\n      GitUIUtil.notifyError(project, \"Couldn't clone\", \"Can't create directory <code>\" + dir + \"<\/code>\");\n      return null;\n    }\n    return dir;\n  }","commit_id":"668fb25e28d17f8c77dbc6edd67c7e732d2d5af5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doClone(ProgressIndicator indicator, Project project, String directoryName, String parentDirectory, String sourceRepositoryURL) {\n    final VirtualFile root = mkdir(project, directoryName, parentDirectory);\n    if (root == null) { return false; }\n    if (!init(project, root)) { return false; }\n    if (!addRemote(project, root, sourceRepositoryURL)) { return false; }\n    if (!fetch(project, root, indicator)) { return false; }\n    return checkout(project, root);\n  }","id":41061,"modified_method":"private static boolean doClone(ProgressIndicator indicator, Project project, String directoryName, String parentDirectory, String sourceRepositoryURL) {\n    File dir = mkdir(project, directoryName, parentDirectory);\n    if (dir == null) {\n      return false;\n    }\n    VirtualFile root = VcsUtil.getVirtualFileWithRefresh(dir);\n    if (root != null &&\n        init(project, root) &&\n        addRemote(project, root, sourceRepositoryURL) &&\n        fetch(project, root, indicator) &&\n        checkout(project, root)) {\n      return true;\n    }\n    cleanup(dir);\n    return false;\n  }","commit_id":"668fb25e28d17f8c77dbc6edd67c7e732d2d5af5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Pair<Collection<EditorMessage>, Boolean> update(final EditorComponent editorComponent, final boolean incremental, final boolean applyQuickFixes,\n      final Cancellable cancellable) {\n    try {\n      return TypeContextManager.getInstance().runTypeCheckingComputation(editorComponent.getTypecheckingContextOwner(), editorComponent.getEditedNode(),\n          new Computation<Pair<Collection<EditorMessage>, Boolean>>() {\n            @Override\n            public Pair<Collection<EditorMessage>, Boolean> compute(final TypeCheckingContext context) {\n              return doCreateMessages(context, incremental, editorComponent.getEditorContext(), editorComponent.getEditedNode(), cancellable, applyQuickFixes);\n            }\n          });\n    } catch (IndexNotReadyException e) {\n      if (editorComponent.getNodeForTypechecking() != null) {\n        TypeContextManager.getInstance().acquireTypecheckingContext(editorComponent.getNodeForTypechecking(), editorComponent);\n        TypeContextManager.getInstance().releaseTypecheckingContext(editorComponent);\n      }\n      throw e;\n    }\n  }","id":41062,"modified_method":"@NotNull\n  @Override\n  public UpdateResult update(final EditorComponent editorComponent, final boolean incremental, final boolean applyQuickFixes,\n      final Cancellable cancellable) {\n    try {\n      return TypeContextManager.getInstance().runTypeCheckingComputation(editorComponent.getTypecheckingContextOwner(), editorComponent.getEditedNode(),\n          context -> doCreateMessages(context, incremental, editorComponent.getEditorContext(), editorComponent.getEditedNode(), cancellable, applyQuickFixes));\n    } catch (IndexNotReadyException e) {\n      if (editorComponent.getNodeForTypechecking() != null) {\n        TypeContextManager.getInstance().acquireTypecheckingContext(editorComponent.getNodeForTypechecking(), editorComponent);\n        TypeContextManager.getInstance().releaseTypecheckingContext(editorComponent);\n      }\n      throw e;\n    }\n  }","commit_id":"362e8931fde13352b5109a9dc5f0ee7921e73034","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean updateEditor(final EditorComponent editor, final boolean wasCheckedOnce,\n      List<EditorChecker> checkersToRecheck, boolean recreateInspectorMessages, final boolean applyQuickFixes) {\n    if (editor == null || editor.getRootCell() == null) return false;\n\n    final NodeHighlightManager highlightManager = editor.getHighlightManager();\n    boolean anyMessageChanged = false;\n    for (final EditorChecker checker : checkersToRecheck) {\n      Pair<Collection<EditorMessage>, Boolean> checkResult = runLoPrioRead(new Computable<Pair<Collection<EditorMessage>, Boolean>>() {\n        @Override\n        public Pair<Collection<EditorMessage>, Boolean> compute() {\n          if (myHighlighter.isPausedOrStopping()) return CHECK_ABORTED;\n\n          SNode node = editor.getEditedNode(); // XXX perhaps, shall use getEditedNodePointer and resolve it, rather than check isAccessible?\n          if (node == null) {\n            return CHECK_ABORTED;\n          }\n          if (!SNodeUtil.isAccessible(node, editor.getEditorContext().getRepository())) {\n            // asking runLoPrioRead() implementation to re-execute this task later:\n            // editor was not updated in accordance with last modelReload event yet.\n            return null;\n          }\n\n          try {\n            return checker.update(editor, wasCheckedOnce, applyQuickFixes,\n                new HighlighterUpdateSessionCancellable(myHighlighter, checker.toString(), editor));\n          } catch (IndexNotReadyException ex) {\n            highlightManager.clearForOwner(checker.getEditorMessageOwner(), true);\n            throw ex;\n          }\n        }\n      });\n      if (myHighlighter.isStopping()) return false;\n\n      if (checkResult.o2 || (myHighlighter.getEditorTracker().isInspector(editor) && recreateInspectorMessages)) {\n        anyMessageChanged = true;\n        highlightManager.clearForOwner(checker.getEditorMessageOwner(), false);\n        for (EditorMessage message : checkResult.o1) {\n          highlightManager.mark(message);\n        }\n      }\n    }\n    if (myHighlighter.isStopping()) return false;\n\n    if (anyMessageChanged) {\n      highlightManager.repaintAndRebuildEditorMessages();\n      editor.updateStatusBarMessage();\n    }\n\n    return anyMessageChanged;\n  }","id":41063,"modified_method":"private boolean updateEditor(final EditorComponent editor, final boolean wasCheckedOnce,\n      List<EditorChecker> checkersToRecheck, boolean recreateInspectorMessages, final boolean applyQuickFixes) {\n    if (editor == null || editor.getRootCell() == null) return false;\n\n    final NodeHighlightManager highlightManager = editor.getHighlightManager();\n    boolean anyMessageChanged = false;\n    for (final EditorChecker checker : checkersToRecheck) {\n      UpdateResult checkResult = runLoPrioRead(new Computable<UpdateResult>() {\n        @Override\n        public UpdateResult compute() {\n          if (myHighlighter.isPausedOrStopping()) return UpdateResult.CANCELLED;\n\n          SNode node = editor.getEditedNode(); // XXX perhaps, shall use getEditedNodePointer and resolve it, rather than check isAccessible?\n          if (node == null) {\n            return UpdateResult.CANCELLED;\n          }\n          if (!SNodeUtil.isAccessible(node, editor.getEditorContext().getRepository())) {\n            // asking runLoPrioRead() implementation to re-execute this task later:\n            // editor was not updated in accordance with last modelReload event yet.\n            return null;\n          }\n\n          boolean recreateMessages = myHighlighter.getEditorTracker().isInspector(editor) && recreateInspectorMessages;\n\n          try {\n            return checker.update(editor, wasCheckedOnce, applyQuickFixes,\n                new HighlighterUpdateSessionCancellable(myHighlighter, checker.toString(), editor));\n          } catch (IndexNotReadyException ex) {\n            highlightManager.clearForOwner(checker.getEditorMessageOwner(), true);\n            throw ex;\n          }\n        }\n      });\n      if (myHighlighter.isStopping()) return false;\n\n      if (checkResult instanceof Completed) {\n        Completed completed = (Completed) checkResult;\n        if (completed.myMessagesChanged || myHighlighter.getEditorTracker().isInspector(editor) && recreateInspectorMessages) {\n          anyMessageChanged = true;\n          highlightManager.clearForOwner(checker.getEditorMessageOwner(), false);\n          for (EditorMessage message : completed.myMessages) {\n            highlightManager.mark(message);\n          }\n        }\n      }\n    }\n    if (myHighlighter.isStopping()) return false;\n\n    if (anyMessageChanged) {\n      highlightManager.repaintAndRebuildEditorMessages();\n      editor.updateStatusBarMessage();\n    }\n\n    return anyMessageChanged;\n  }","commit_id":"362e8931fde13352b5109a9dc5f0ee7921e73034","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public Pair<Collection<EditorMessage>, Boolean> update(EditorComponent editorComponent, boolean incremental, boolean applyQuickFixes,\n      Cancellable cancellable) {\n    try {\n      Set<EditorMessage> messages = myChecker.createMessagesProtected(editorComponent.getEditedNode(), myEvents, incremental,\n          editorComponent.getEditorContext(), cancellable, applyQuickFixes);\n\n      boolean changed = myChecker.areMessagesChangedProtected();\n      return new Pair<Collection<EditorMessage>, Boolean>(messages, changed);\n    } catch (IndexNotReadyException e) {\n      myChecker.clearProtected(editorComponent.getEditedNode(), editorComponent);\n      throw e;\n    }\n  }","id":41064,"modified_method":"@NotNull\n  @Override\n  public UpdateResult update(EditorComponent editorComponent, boolean incremental, boolean applyQuickFixes, Cancellable cancellable) {\n    try {\n      Set<EditorMessage> messages = myChecker.createMessagesProtected(editorComponent.getEditedNode(), myEvents, incremental,\n          editorComponent.getEditorContext(), cancellable, applyQuickFixes);\n\n      boolean changed = myChecker.areMessagesChangedProtected();\n      return new Completed(changed, messages);\n    } catch (IndexNotReadyException e) {\n      myChecker.clearProtected(editorComponent.getEditedNode(), editorComponent);\n      throw e;\n    }\n  }","commit_id":"362e8931fde13352b5109a9dc5f0ee7921e73034","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  protected Pair<Collection<EditorMessage>, Boolean> doCreateMessages(final TypeCheckingContext context, final boolean incremental,\n      final EditorContext editorContext, SNode rootNode, final Cancellable cancellable, final boolean applyQuickFixes) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) {\n      return CANCELLED;\n    }\n\n    if (cancellable.isCancelled()) {\n      return CANCELLED;\n    }\n\n    return ((IncrementalTypecheckingContext) context).runTypeCheckingAction(new Computable<Pair<Collection<EditorMessage>, Boolean>>() {\n      @Override\n      public Pair<Collection<EditorMessage>, Boolean> compute() {\n        IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n        boolean messagesChanged = false;\n\n        //non-typesystem checks\n        if (!incremental || !typesComponent.isCheckedNonTypesystem()) {\n          try {\n            messagesChanged = true;\n            context.setIsNonTypesystemComputation();\n            if (typesComponent.applyNonTypesystemRulesToRoot(context, cancellable)) {\n              typesComponent.setCheckedNonTypesystem();\n            }\n          } catch (Throwable t) {\n            LOG.error(null, t);\n            typesComponent.setCheckedNonTypesystem();\n          } finally {\n            context.resetIsNonTypesystemComputation();\n          }\n        }\n\n        // highlight nodes with errors\n        Collection<EditorMessage> messages = collectMessagesForNodesWithErrors(context, editorContext, false, applyQuickFixes);\n        return new Pair<Collection<EditorMessage>, Boolean>(messages, messagesChanged);\n      }\n    });\n  }","id":41065,"modified_method":"@NotNull\n  @Override\n  protected UpdateResult doCreateMessages(final TypeCheckingContext context, final boolean incremental,\n      final EditorContext editorContext, SNode rootNode, final Cancellable cancellable, final boolean applyQuickFixes) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) {\n      return UpdateResult.CANCELLED;\n    }\n\n    if (cancellable.isCancelled()) {\n      return UpdateResult.CANCELLED;\n    }\n\n    return ((IncrementalTypecheckingContext) context).runTypeCheckingAction(() -> {\n      IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n      boolean messagesChanged = false;\n\n      //non-typesystem checks\n      if (!incremental || !typesComponent.isCheckedNonTypesystem()) {\n        try {\n          messagesChanged = true;\n          context.setIsNonTypesystemComputation();\n          if (typesComponent.applyNonTypesystemRulesToRoot(context, cancellable)) {\n            typesComponent.setCheckedNonTypesystem();\n          }\n        } catch (Throwable t) {\n          LOG.error(null, t);\n          typesComponent.setCheckedNonTypesystem();\n        } finally {\n          context.resetIsNonTypesystemComputation();\n        }\n      }\n\n      // highlight nodes with errors\n      Collection<EditorMessage> messages = collectMessagesForNodesWithErrors(context, editorContext, false, applyQuickFixes);\n      return new Completed(messagesChanged, messages);\n    });\n  }","commit_id":"362e8931fde13352b5109a9dc5f0ee7921e73034","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  protected Pair<Collection<EditorMessage>, Boolean> doCreateMessages(final TypeCheckingContext context, final boolean wasCheckedOnce,\n      final EditorContext editorContext, final SNode rootNode, Cancellable cancellable, final boolean applyQuickFixes) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) {\n      return CANCELLED;\n    }\n\n    return ((IncrementalTypecheckingContext) context).runTypeCheckingAction(new Computable<Pair<Collection<EditorMessage>, Boolean>>() {\n      @Override\n      public Pair<Collection<EditorMessage>, Boolean> compute() {\n        boolean messagesChanged = false;\n\n        if (!wasCheckedOnce || !context.isCheckedRoot(true) || context.messagesChanged(editorContext.getEditorComponent().getClass())) {\n          IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n          try {\n            messagesChanged = true;\n            context.checkIfNotChecked(rootNode, false);\n          } catch (Throwable t) {\n            LOG.error(null, t);\n            typesComponent.setCheckedTypesystem();\n            return CANCELLED;\n          }\n        }\n\n        // highlight nodes with errors\n        Collection<EditorMessage> messages = collectMessagesForNodesWithErrors(context, editorContext, true, applyQuickFixes);\n        return new Pair<Collection<EditorMessage>, Boolean>(messages, messagesChanged);\n      }\n    });\n  }","id":41066,"modified_method":"@NotNull\n  @Override\n  protected UpdateResult doCreateMessages(final TypeCheckingContext context, final boolean wasCheckedOnce,\n      final EditorContext editorContext, final SNode rootNode, Cancellable cancellable, final boolean applyQuickFixes) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) {\n      return UpdateResult.CANCELLED;\n    }\n\n    return ((IncrementalTypecheckingContext) context).runTypeCheckingAction(() -> {\n      boolean messagesChanged = false;\n\n      if (!wasCheckedOnce || !context.isCheckedRoot(true) || context.messagesChanged(editorContext.getEditorComponent().getClass())) {\n        IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n        try {\n          messagesChanged = true;\n          context.checkIfNotChecked(rootNode, false);\n        } catch (Throwable t) {\n          LOG.error(null, t);\n          typesComponent.setCheckedTypesystem();\n          return UpdateResult.CANCELLED;\n        }\n      }\n\n      // highlight nodes with errors\n      Collection<EditorMessage> messages = collectMessagesForNodesWithErrors(context, editorContext, true, applyQuickFixes);\n      return new Completed(messagesChanged, messages);\n    });\n  }","commit_id":"362e8931fde13352b5109a9dc5f0ee7921e73034","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void projectOpened() {\n    if (myThread != null && myThread.isAlive()) {\n      LOG.error(\"trying to initialize a Highlighter being already initialized\", new Throwable());\n      return;\n    }\n    myClassLoaderManager.addReloadHandler(myReloadListener);\n    myGlobalSModelEventsManager.addGlobalCommandListener(myModelCommandListener);\n    SModelRepository.getInstance().addModelRepositoryListener(myModelReloadListener);\n\n    myInspectorTool = myProject.getComponent(InspectorTool.class);\n    myMessageBusConnection = myProject.getMessageBus().connect();\n    myMessageBusConnection.subscribe(EditorComponentCreateListener.EDITOR_COMPONENT_CREATION, new EditorComponentCreateListener() {\n      @Override\n      public void editorComponentCreated(@NotNull EditorComponent editorComponent) {\n      }\n\n      @Override\n      public void editorComponentDisposed(@NotNull final EditorComponent editorComponent) {\n        if (editorComponent == myInspectorTool.getInspector()) {\n          addPendingAction(new Runnable() {\n            @Override\n            public void run() {\n              myInspectorMessagesCreated = false;\n            }\n          });\n        }\n      }\n    });\n    ModelAccess.instance().addCommandListener(myCommandListener);\n    myThread = new HighlighterThread();\n    myThread.start();\n  }","id":41067,"modified_method":"@Override\n  public void projectOpened() {\n    if (myThread != null && myThread.isAlive()) {\n      LOG.error(\"trying to initialize a Highlighter being already initialized\", new Throwable());\n      return;\n    }\n    myClassLoaderManager.addReloadHandler(myReloadListener);\n    myGlobalSModelEventsManager.addGlobalCommandListener(myModelCommandListener);\n    SModelRepository.getInstance().addModelRepositoryListener(myModelReloadListener);\n\n    myInspectorTool = myProject.getComponent(InspectorTool.class);\n    myMessageBusConnection = myProject.getMessageBus().connect();\n    myMessageBusConnection.subscribe(EditorComponentCreateListener.EDITOR_COMPONENT_CREATION, new EditorComponentCreateListener() {\n      @Override\n      public void editorComponentCreated(@NotNull EditorComponent editorComponent) {\n      }\n\n      @Override\n      public void editorComponentDisposed(@NotNull final EditorComponent editorComponent) {\n        if (editorComponent == myInspectorTool.getInspector()) {\n          addPendingAction(new Runnable() {\n            @Override\n            public void run() {\n              myInspectorMessagesCreated = false;\n            }\n          });\n        }\n      }\n    });\n    ModelAccess.instance().addCommandListener(myCommandWatcher);\n    myThread = new HighlighterThread();\n    myThread.start();\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean updateEditorComponent(final EditorComponent component, final List<SModelEvent> events, final Set<BaseEditorChecker> checkers, final Set<BaseEditorChecker> checkersToRemove, final boolean mainEditorMessagesChanged) {\n    return runUpdateMessagesAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        final SNode editedNode = component.getEditedNode();\n        if (editedNode != null && editedNode.isInRepository()) {\n          final Set<BaseEditorChecker> checkersToRecheck = new LinkedHashSet<BaseEditorChecker>();\n          boolean rootWasCheckedOnce = wasCheckedOnce(component);\n          if (!rootWasCheckedOnce) {\n            checkersToRecheck.addAll(checkers);\n          } else {\n            ModelAccess.instance().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                if (myStopThread) {\n                  return;\n                }\n                for (BaseEditorChecker checker : checkers) {\n                  if (checker.hasDramaticalEventProtected(events)) {\n                    checkersToRecheck.add(checker);\n                  }\n                }\n              }\n            });\n          }\n\n          if ((checkersToRecheck.isEmpty() && checkersToRemove.isEmpty()) || myStopThread) {\n            return false;\n          }\n          List<BaseEditorChecker> checkersToRecheckList = new ArrayList<BaseEditorChecker>(checkersToRecheck);\n          Collections.sort(checkersToRecheckList, new PriorityComparator());\n\n          boolean recreateInspectorMessages = mainEditorMessagesChanged || !myInspectorMessagesCreated;\n          if (component instanceof InspectorEditorComponent) {\n            myInspectorMessagesCreated = true;\n          } else {\n            myCheckedOnceEditors.add(component);\n          }\n\n\n          if (updateEditor(component, events, rootWasCheckedOnce, checkersToRecheckList, checkersToRemove, recreateInspectorMessages)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    });\n  }","id":41068,"modified_method":"private boolean updateEditorComponent(final EditorComponent component, final List<SModelEvent> events, final Set<BaseEditorChecker> checkers, final Set<BaseEditorChecker> checkersToRemove, final boolean mainEditorMessagesChanged, final boolean essentialOnly) {\n    return runUpdateMessagesAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        final SNode editedNode = component.getEditedNode();\n        if (editedNode != null && editedNode.isInRepository()) {\n          final Set<BaseEditorChecker> checkersToRecheck = new LinkedHashSet<BaseEditorChecker>();\n          boolean rootWasCheckedOnce = wasCheckedOnce(component);\n          if (!rootWasCheckedOnce) {\n            checkersToRecheck.addAll(checkers);\n          } else {\n            ModelAccess.instance().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                if (myStopThread) {\n                  return;\n                }\n                for (BaseEditorChecker checker : checkers) {\n                  if (checker.hasDramaticalEventProtected(events) && (!essentialOnly || checker.isEssentialProtected())) {\n                    checkersToRecheck.add(checker);\n                  }\n                }\n              }\n            });\n          }\n\n          if ((checkersToRecheck.isEmpty() && checkersToRemove.isEmpty()) || myStopThread) {\n            return false;\n          }\n          List<BaseEditorChecker> checkersToRecheckList = new ArrayList<BaseEditorChecker>(checkersToRecheck);\n          Collections.sort(checkersToRecheckList, new PriorityComparator());\n\n          boolean recreateInspectorMessages = mainEditorMessagesChanged || !myInspectorMessagesCreated;\n          if (component instanceof InspectorEditorComponent) {\n            myInspectorMessagesCreated = true;\n          } else {\n            myCheckedOnceEditors.add(component);\n          }\n\n\n          if (updateEditor(component, events, rootWasCheckedOnce, checkersToRecheckList, checkersToRemove, recreateInspectorMessages)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    });\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doUpdate() {\n    if (ApplicationManager.getApplication() == null || ApplicationManager.getApplication().isDisposed()) {\n      return;\n    }\n    if (IMakeService.INSTANCE.isSessionActive()) {\n      return;\n    }\n    // SwingUtilities.invokeLater(new Runnable() {\n    //   public void run() {\n\n    final List<SModelEvent> events = new ArrayList<SModelEvent>();\n    synchronized (EVENTS_LOCK) {\n      events.addAll(myLastEvents);\n      myLastEvents.clear();\n    }\n\n    final Set<BaseEditorChecker> checkers = new LinkedHashSet<BaseEditorChecker>();\n    final Set<BaseEditorChecker> checkersToRemove = new LinkedHashSet<BaseEditorChecker>();\n    // to avoid inconsistency between checkers, we collect them from fields here\n    // in the synchronized block and then do not read the fields in this iteration anymore\n    synchronized (CHECKERS_LOCK) {\n      if (!EditorSettings.getInstance().isPowerSaveMode() || myForceUpdateInPowerSaveModeFlag) {\n        // calling checkers only if we are not in powerSafeMode or updateEditorFlag was set by\n        // explicit update action (available in powerSafeMode only)\n        checkers.addAll(myCheckers);\n        myForceUpdateInPowerSaveModeFlag = false;\n      }\n      checkersToRemove.addAll(myCheckersToRemove);\n      myCheckersToRemove.clear();\n    }\n\n    final List<EditorComponent> allEditorComponents = getAllEditorComponents();\n    runUpdateMessagesAction(new Runnable() {\n      @Override\n      public void run() {\n        if (EditorSettings.getInstance().isPowerSaveMode()) {\n          // if we are in powerSaveMode then next editor checkers execution should\n          // recheck all editors completely\n          myCheckedOnceEditors.clear();\n          myInspectorMessagesCreated = false;\n        } else {\n          cleanupCheckedOnce(allEditorComponents);\n        }\n      }\n    });\n    if (checkers.isEmpty() && checkersToRemove.isEmpty()) {\n      return;\n    }\n\n    final boolean[] isUpdated = {false};\n    final boolean[] inspectorIsUpdated = {false};\n    EditorComponent inspector = null;\n\n    for (final EditorComponent editorComponent : allEditorComponents) {\n      if (myStopThread) {\n        return;\n      }\n      TypeContextManager.getInstance().runTypecheckingAction(editorComponent, new Runnable() {\n        @Override\n        public void run() {\n          if (updateEditorComponent(editorComponent, events, checkers, checkersToRemove, false)) {\n            isUpdated[0] = true;\n          }\n        }\n      });\n    }\n\n    if (myStopThread) {\n      return;\n    }\n\n    if (myInspectorTool != null && myInspectorTool.getInspector() != null) {\n      inspector = myInspectorTool.getInspector();\n      final EditorComponent finalInspector = inspector;\n      TypeContextManager.getInstance().runTypecheckingAction(inspector, new Runnable() {\n        @Override\n        public void run() {\n          if (updateEditorComponent(finalInspector, events, checkers, checkersToRemove, isUpdated[0])) {\n            inspectorIsUpdated[0] = true;\n          }\n        }\n      });\n    }\n\n    if (myStopThread) {\n      return;\n    }\n\n    if (isUpdated[0]) {\n      for (EditorComponent editorComponent : allEditorComponents) {\n        editorComponent.repaint();\n        editorComponent.getVerticalScrollBar().repaint();\n      }\n    }\n    if (inspectorIsUpdated[0]) {\n      inspector.repaint();\n      inspector.getVerticalScrollBar().repaint();\n    }\n  }","id":41069,"modified_method":"protected void doUpdate(final boolean essentialOnly) {\n    if (ApplicationManager.getApplication() == null || ApplicationManager.getApplication().isDisposed()) {\n      return;\n    }\n    if (IMakeService.INSTANCE.isSessionActive()) {\n      return;\n    }\n    // SwingUtilities.invokeLater(new Runnable() {\n    //   public void run() {\n\n    final List<SModelEvent> events = new ArrayList<SModelEvent>();\n    synchronized (EVENTS_LOCK) {\n      events.addAll(myLastEvents);\n      myLastEvents.clear();\n    }\n\n    final Set<BaseEditorChecker> checkers = new LinkedHashSet<BaseEditorChecker>();\n    final Set<BaseEditorChecker> checkersToRemove = new LinkedHashSet<BaseEditorChecker>();\n    // to avoid inconsistency between checkers, we collect them from fields here\n    // in the synchronized block and then do not read the fields in this iteration anymore\n    synchronized (CHECKERS_LOCK) {\n      if (!EditorSettings.getInstance().isPowerSaveMode() || myForceUpdateInPowerSaveModeFlag) {\n        // calling checkers only if we are not in powerSafeMode or updateEditorFlag was set by\n        // explicit update action (available in powerSafeMode only)\n        checkers.addAll(myCheckers);\n        myForceUpdateInPowerSaveModeFlag = false;\n      }\n      checkersToRemove.addAll(myCheckersToRemove);\n      myCheckersToRemove.clear();\n    }\n\n    final List<EditorComponent> allEditorComponents = getAllEditorComponents();\n    runUpdateMessagesAction(new Runnable() {\n      @Override\n      public void run() {\n        if (EditorSettings.getInstance().isPowerSaveMode()) {\n          // if we are in powerSaveMode then next editor checkers execution should\n          // recheck all editors completely\n          myCheckedOnceEditors.clear();\n          myInspectorMessagesCreated = false;\n        } else {\n          cleanupCheckedOnce(allEditorComponents);\n        }\n      }\n    });\n    if (checkers.isEmpty() && checkersToRemove.isEmpty()) {\n      return;\n    }\n\n    final boolean[] isUpdated = {false};\n    final boolean[] inspectorIsUpdated = {false};\n    EditorComponent inspector = null;\n\n    for (final EditorComponent editorComponent : allEditorComponents) {\n      if (myStopThread) {\n        return;\n      }\n      TypeContextManager.getInstance().runTypecheckingAction(editorComponent, new Runnable() {\n        @Override\n        public void run() {\n          if (updateEditorComponent(editorComponent, events, checkers, checkersToRemove, false, essentialOnly)) {\n            isUpdated[0] = true;\n          }\n        }\n      });\n    }\n\n    if (myStopThread) {\n      return;\n    }\n\n    if (myInspectorTool != null && myInspectorTool.getInspector() != null) {\n      inspector = myInspectorTool.getInspector();\n      final EditorComponent finalInspector = inspector;\n      TypeContextManager.getInstance().runTypecheckingAction(inspector, new Runnable() {\n        @Override\n        public void run() {\n          if (updateEditorComponent(finalInspector, events, checkers, checkersToRemove, isUpdated[0], essentialOnly)) {\n            inspectorIsUpdated[0] = true;\n          }\n        }\n      });\n    }\n\n    if (myStopThread) {\n      return;\n    }\n\n    if (isUpdated[0]) {\n      for (EditorComponent editorComponent : allEditorComponents) {\n        editorComponent.repaint();\n        editorComponent.getVerticalScrollBar().repaint();\n      }\n    }\n    if (inspectorIsUpdated[0]) {\n      inspector.repaint();\n      inspector.getVerticalScrollBar().repaint();\n    }\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void projectClosed() {\n    stopUpdater();\n    ModelAccess.instance().removeCommandListener(myCommandListener);\n    SModelRepository.getInstance().removeModelRepositoryListener(myModelReloadListener);\n    myGlobalSModelEventsManager.removeGlobalCommandListener(myModelCommandListener);\n    myClassLoaderManager.removeReloadHandler(myReloadListener);\n    myMessageBusConnection.disconnect();\n    myInspectorTool = null;\n  }","id":41070,"modified_method":"@Override\n  public void projectClosed() {\n    stopUpdater();\n    ModelAccess.instance().removeCommandListener(myCommandWatcher);\n    SModelRepository.getInstance().removeModelRepositoryListener(myModelReloadListener);\n    myGlobalSModelEventsManager.removeGlobalCommandListener(myModelCommandListener);\n    myClassLoaderManager.removeReloadHandler(myReloadListener);\n    myMessageBusConnection.disconnect();\n    myInspectorTool = null;\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void run() {\n      if (IdeMain.getTestMode() != TestMode.NO_TEST) return;\n      DumbService dumbService = DumbService.getInstance(myProject);\n      CommandProcessor commandProcessor = CommandProcessor.getInstance();\n      while (true) {\n        try {\n          while (true) {\n            while (commandProcessor.getCurrentCommand() != null) {\n              if (myStopThread) {\n                return;\n              }\n              Thread.sleep(200);\n            }\n            while (dumbService.isDumb()) {\n              if (myStopThread) return;\n              Thread.sleep(600);\n            }\n            long current = System.currentTimeMillis();\n            long commandTime = myLastCommandTime;\n            long millisSinceLastCommand = current - commandTime;\n            if (millisSinceLastCommand < 200) {\n              long millis = 200 - millisSinceLastCommand;\n              Thread.sleep(millis);\n            } else break;\n          }\n          if (myStopThread) return;\n\n          try {\n            doUpdate();\n          } catch (IndexNotReadyException ex) {\n            myCheckedOnceEditors.clear();\n            myInspectorMessagesCreated = false;\n          }\n          processPendingActions();\n          if (myStopThread) {\n            return;\n          }\n          Thread.sleep(300);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n      }\n    }","id":41071,"modified_method":"@Override\n    public void run() {\n      if (IdeMain.getTestMode() != TestMode.NO_TEST) return;\n      DumbService dumbService = DumbService.getInstance(myProject);\n      CommandProcessor commandProcessor = CommandProcessor.getInstance();\n      while (true) {\n        try {\n          while (true) {\n            while (commandProcessor.getCurrentCommand() != null) {\n              if (myStopThread) {\n                return;\n              }\n              Thread.sleep(DEFAULT_GRACE_PERIOD);\n            }\n            while (dumbService.isDumb()) {\n              if (myStopThread) return;\n              Thread.sleep(DEFAULT_GRACE_PERIOD*3);\n            }\n            if (!myCommandWatcher.isGracePeriodExpired()) {\n              Thread.sleep(myCommandWatcher.timeToExpiration());\n              continue;\n            }\n            break;\n          }\n\n          if (myStopThread) return;\n\n          try {\n            doUpdate(!myCommandWatcher.isLargerGracePeriodExpired());\n          } catch (IndexNotReadyException ex) {\n            myCheckedOnceEditors.clear();\n            myInspectorMessagesCreated = false;\n          }\n          processPendingActions();\n          if (myStopThread) {\n            return;\n          }\n          Thread.sleep(DEFAULT_GRACE_PERIOD);\n\n          if (myCommandWatcher.isLargerGracePeriodExpired()) {\n            myCommandWatcher.resetGracePeriod();\n          }\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n      }\n    }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void initComponent() {\n    // TODO: create editor-specific \"core\" component in editor-runtime module and register all common checkers from there\n    addChecker(new TypesEditorChecker());\n    addChecker(new AutoResolver());\n    addChecker(new LanguageEditorChecker());\n    addChecker(new SuppressErrorsChecker());\n    addChecker(new ModelProblemsChecker(GlobalSModelEventsManager.getInstance()));\n  }","id":41072,"modified_method":"@Override\n  public void initComponent() {\n    // TODO: create editor-specific \"core\" component in editor-runtime module and register all common checkers from there\n    addChecker(new TypesEditorChecker());\n    addChecker(new NonTypesystemEditorChecker());\n    addChecker(new AutoResolver());\n    addChecker(new LanguageEditorChecker());\n    addChecker(new SuppressErrorsChecker());\n    addChecker(new ModelProblemsChecker(GlobalSModelEventsManager.getInstance()));\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void doCreateMessages(final TypeCheckingContext context, final boolean wasCheckedOnce, final EditorContext editorContext, final SNode rootNode, final Set<EditorMessage> messages) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) return;\n\n    ((IncrementalTypecheckingContext)context).runTypeCheckingAction(new Runnable() {\n      @Override\n      public void run() {\n        IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n        if (!wasCheckedOnce || !context.isCheckedRoot(true) || context.messagesChanged(editorContext.getEditorComponent().getClass())) {\n          try {\n            myMessagesChanged = true;\n            context.checkIfNotChecked(rootNode, false);\n          } catch (Throwable t) {\n            LOG.error(t);\n            typesComponent.setCheckedTypesystem();\n            return;\n          }\n        }\n\n        //non-typesystem checks\n        if (!wasCheckedOnce || !typesComponent.isCheckedNonTypesystem()) {\n          try {\n            myMessagesChanged = true;\n            context.setIsNonTypesystemComputation();\n            typesComponent.applyNonTypesystemRulesToRoot(editorContext.getOperationContext(), context);\n            typesComponent.setCheckedNonTypesystem();\n          } catch (Throwable t) {\n            LOG.error(t);\n            typesComponent.setCheckedNonTypesystem();\n          } finally {\n            context.resetIsNonTypesystemComputation();\n          }\n        }\n\n        // highlight nodes with errors\n        for (Pair<SNode, List<IErrorReporter>> errorNode : context.getNodesWithErrors()) {\n          List<IErrorReporter> errors = new ArrayList<IErrorReporter>(errorNode.o2);\n          Collections.sort(errors, new Comparator<IErrorReporter>() {\n            @Override\n            public int compare(IErrorReporter o1, IErrorReporter o2) {\n              return o2.getMessageStatus().compareTo(o1.getMessageStatus());\n            }\n          });\n          boolean instantIntentionApplied = false;\n          for (IErrorReporter errorReporter : errors) {\n            MessageStatus status = errorReporter.getMessageStatus();\n            String errorString = errorReporter.reportError();\n            HighlighterMessage message = HighlightUtil.createHighlighterMessage(\n              errorNode.o1,\n              NameUtil.capitalize(status.getPresentation()) + \": \" + errorString,\n              errorReporter,\n              TypesEditorChecker.this,\n              editorContext\n            );\n            List<QuickFixProvider> intentionProviders = message.getIntentionProviders();\n            final SNode quickFixNode = errorNode.o1;\n            if (intentionProviders.size() == 1 && intentionProviders.get(0) != null && intentionProviders.get(0).isExecutedImmediately() && !IMMEDIATE_QFIX_DISABLED) {\n              QuickFixProvider intentionProvider = intentionProviders.get(0);\n              if (!instantIntentionApplied) {\n                final QuickFix_Runtime intention = intentionProvider.getQuickFix();\n                if (intention != null) {\n                  instantIntentionApplied = true;\n                  if (!myOnceExecutedQuickFixes.contains(intention)) {\n                    myOnceExecutedQuickFixes.add(intention);\n                    LaterInvocator.invokeLater(new Runnable() {\n                      @Override\n                      public void run() {\n                        EditorCell selectedCell = editorContext.getSelectedCell();\n                        if (selectedCell == null) return;\n                        boolean restoreCaretPosition = false;\n                        int caretX = 0;\n                        int caretY = 0;\n\n                        Project p = (editorContext != null && editorContext.getOperationContext() != null ?\n                          editorContext.getOperationContext().getProject() :\n                          null\n                        );\n                        if (p == null) {\n                          return;\n                        }\n\n                        if (selectedCell instanceof EditorCell_Label) {\n                          EditorCell_Label cell_label = (EditorCell_Label) selectedCell;\n                          restoreCaretPosition = jetbrains.mps.util.SNodeOperations.isAncestor(quickFixNode, cell_label.getSNode());\n                          caretX = cell_label.getCaretX();\n                          caretY = cell_label.getBaseline();\n                          boolean last = cell_label.getCaretPosition() == cell_label.getText().length();\n                          boolean first = cell_label.getCaretPosition() == 0;\n                          if (last) {\n                            caretX = caretX - 1;\n                          }\n                          if (first) {\n                            caretY = caretY + 1;\n                          }\n                        }\n\n                        ModelAccess.instance().runUndoTransparentCommand(new Runnable() {\n                          @Override\n                          public void run() {\n                            intention.execute(quickFixNode);\n                          }\n                        }, p);\n\n                        if (restoreCaretPosition) {\n                          editorContext.flushEvents();\n                          EditorCell rootCell = editorContext.getEditorComponent().getRootCell();\n                          EditorCell leaf = rootCell.findLeaf(caretX, caretY);\n                          if (leaf != null) {\n                            editorContext.getEditorComponent().changeSelection(leaf);\n                            leaf.setCaretX(caretX);\n                          }\n                        }\n                      }\n                    }, ModalityState.NON_MODAL);\n                  }\n                }\n              }\n            } else {\n              messages.add(message);\n            }\n          }\n        }\n      }\n    });\n  }","id":41073,"modified_method":"@Override\n  protected void doCreateMessages(final TypeCheckingContext context, final boolean wasCheckedOnce, final EditorContext editorContext, final SNode rootNode, final Set<EditorMessage> messages) {\n    if (context == null || !(context instanceof IncrementalTypecheckingContext)) return;\n\n    ((IncrementalTypecheckingContext)context).runTypeCheckingAction(new Runnable() {\n      @Override\n      public void run() {\n        IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();\n        if (!wasCheckedOnce || !context.isCheckedRoot(true) || context.messagesChanged(editorContext.getEditorComponent().getClass())) {\n          try {\n            myMessagesChanged = true;\n            context.checkIfNotChecked(rootNode, false);\n          } catch (Throwable t) {\n            LOG.error(t);\n            typesComponent.setCheckedTypesystem();\n            return;\n          }\n        }\n\n        // highlight nodes with errors\n        collectMessagesForNodesWithErrors(context, editorContext, messages);\n      }\n    });\n  }","commit_id":"7f28df9b3c5dbf64e274eaae8adcc543a9196bbc","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected OuterLanguageElementImpl createOuterLanguageElement(final Lexer lexer, final CharTable table,\n                                                                final IElementType outerElementType) {\n    return new OuterLanguageElementImpl(outerElementType, lexer.getBufferSequence(),\n                                                                            lexer.getTokenStart(), lexer.getTokenEnd(), table);\n  }","id":41074,"modified_method":"protected OuterLanguageElementImpl createOuterLanguageElement(final Lexer lexer, final CharTable table,\n                                                                final IElementType outerElementType) {\n    final CharSequence buffer = lexer.getBufferSequence();\n    final int tokenStart = lexer.getTokenStart();\n    if (tokenStart < 0 || tokenStart >= buffer.length()) {\n      LOG.assertTrue(false, \"Invalid start: \" + tokenStart + \"; \" + lexer);\n    }\n    final int tokenEnd = lexer.getTokenEnd();\n    if (tokenEnd < 0 || tokenEnd >= buffer.length()) {\n      LOG.assertTrue(false, \"Invalid end: \" + tokenEnd + \"; \" + lexer);\n    }\n\n    return new OuterLanguageElementImpl(outerElementType, buffer, tokenStart, tokenEnd, table);\n  }","commit_id":"ed3d593135911a8e78d1314d543146277bd68d1a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Actually carry out the log10PNonRef calculation on vc, storing results in results\n     *\n     * @param vc                                variant context with alleles and genotype likelihoods\n     * @param log10AlleleFrequencyPriors        priors\n     * @param result                            (pre-allocated) object to store results\n     */\n    // TODO -- add consistent requires among args\n    public abstract void computeLog10PNonRef(final VariantContext vc,\n                                             final double[] log10AlleleFrequencyPriors,\n                                             final AFCalcResult result);","id":41075,"modified_method":"/**\n     * Actually carry out the log10PNonRef calculation on vc, storing results in results\n     *\n     * @param vc                                variant context with alleles and genotype likelihoods\n     * @param log10AlleleFrequencyPriors        priors\n     * @param resultTracker                            (pre-allocated) object to store results\n     */\n    // TODO -- add consistent requires among args\n    public abstract void computeLog10PNonRef(final VariantContext vc,\n                                             final double[] log10AlleleFrequencyPriors,\n                                             final AFCalcResultTracker resultTracker);","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected AFCalc(final int nSamples,\n                     final int maxAltAlleles,\n                     final int maxAltAllelesForIndels,\n                     final File exactCallsLog,\n                     final Logger logger,\n                     final PrintStream verboseWriter) {\n        if ( nSamples < 0 ) throw new IllegalArgumentException(\"nSamples must be greater than zero \" + nSamples);\n        if ( maxAltAlleles < 1 ) throw new IllegalArgumentException(\"maxAltAlleles must be greater than zero \" + maxAltAlleles);\n\n        this.nSamples = nSamples;\n        this.MAX_ALTERNATE_ALLELES_TO_GENOTYPE = maxAltAlleles;\n        this.MAX_ALTERNATE_ALLELES_FOR_INDELS = maxAltAllelesForIndels;\n        this.logger = logger == null ? defaultLogger : logger;\n        this.verboseWriter = verboseWriter;\n        if ( exactCallsLog != null )\n            initializeOutputFile(exactCallsLog);\n    }","id":41076,"modified_method":"protected AFCalc(final int nSamples,\n                     final int maxAltAlleles,\n                     final int maxAltAllelesForIndels,\n                     final File exactCallsLog,\n                     final Logger logger,\n                     final PrintStream verboseWriter) {\n        if ( nSamples < 0 ) throw new IllegalArgumentException(\"nSamples must be greater than zero \" + nSamples);\n        if ( maxAltAlleles < 1 ) throw new IllegalArgumentException(\"maxAltAlleles must be greater than zero \" + maxAltAlleles);\n\n        this.nSamples = nSamples;\n        this.MAX_ALTERNATE_ALLELES_TO_GENOTYPE = maxAltAlleles;\n        this.MAX_ALTERNATE_ALLELES_FOR_INDELS = maxAltAllelesForIndels;\n        this.logger = logger == null ? defaultLogger : logger;\n        this.verboseWriter = verboseWriter;\n        if ( exactCallsLog != null )\n            initializeOutputFile(exactCallsLog);\n        this.resultTracker = new AFCalcResultTracker(Math.max(maxAltAlleles, maxAltAllelesForIndels));\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * @see #getLog10PNonRef(org.broadinstitute.sting.utils.variantcontext.VariantContext, double[], AFCalcResult)\n     *\n     * Allocates a new results object.  Useful for testing but slow in practice.\n     */\n    public final AFCalcResult getLog10PNonRef(final VariantContext vc,\n                                                                  final double[] log10AlleleFrequencyPriors) {\n        return getLog10PNonRef(vc, log10AlleleFrequencyPriors, new AFCalcResult(getMaxAltAlleles()));\n    }","id":41077,"modified_method":"/**\n     * Compute the probability of the alleles segregating given the genotype likelihoods of the samples in vc\n     *\n     * @param vc the VariantContext holding the alleles and sample information\n     * @param log10AlleleFrequencyPriors a prior vector nSamples x 2 in length indicating the Pr(AF = i)\n     * @return result (for programming convenience)\n     */\n    public AFCalcResultTracker getLog10PNonRef(final VariantContext vc, final double[] log10AlleleFrequencyPriors) {\n        if ( vc == null ) throw new IllegalArgumentException(\"VariantContext cannot be null\");\n        if ( log10AlleleFrequencyPriors == null ) throw new IllegalArgumentException(\"priors vector cannot be null\");\n        if ( resultTracker == null ) throw new IllegalArgumentException(\"Results object cannot be null\");\n\n        // reset the result, so we can store our new result there\n        resultTracker.reset();\n\n        final VariantContext vcWorking = reduceScope(vc);\n\n        callTimer.start();\n        computeLog10PNonRef(vcWorking, log10AlleleFrequencyPriors, resultTracker);\n        final long nanoTime = callTimer.getElapsedTimeNano();\n\n        if ( callReport != null )\n            printCallInfo(vcWorking, log10AlleleFrequencyPriors, nanoTime, resultTracker.getLog10PosteriorOfAFzero());\n\n        resultTracker.setAllelesUsedInGenotyping(vcWorking.getAlleles());\n        return resultTracker;\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static boolean goodLog10Value(final double result) {\n        return result <= 0.0 || Double.isInfinite(result) || Double.isNaN(result);\n    }","id":41078,"modified_method":"private static boolean goodLog10Value(final double result) {\n        return result <= 0.0 && ! Double.isInfinite(result) && ! Double.isNaN(result);\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * TODO -- eric what is this supposed to return?  my unit tests don't do what I think they should\n     *\n     * @return\n     */\n    public double getLog10LikelihoodOfAFzero() {\n        return log10LikelihoodOfAFzero;\n    }","id":41079,"modified_method":"/**\n     * Get the log10 unnormalized -- across all ACs -- likelihood of AC == 0\n     *\n     * @return\n     */\n    @Ensures({\"goodLog10Value(result)\"})\n    public double getLog10LikelihoodOfAFEq0() {\n        return log10LikelihoodsOfAC[AF0];\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void setLog10LikelihoodOfAFzero(final double log10LikelihoodOfAFzero) {\n        this.log10LikelihoodOfAFzero = log10LikelihoodOfAFzero;\n        if ( log10LikelihoodOfAFzero > log10MLE ) {\n            log10MLE = log10LikelihoodOfAFzero;\n            Arrays.fill(alleleCountsOfMLE, 0);\n        }\n    }","id":41080,"modified_method":"/**\n     * Get the log10 unnormalized -- across all ACs -- likelihood of AC > 0\n     *\n     * @return\n     */\n    @Ensures({\"goodLog10Value(result)\"})\n    public double getLog10LikelihoodOfAFGT0() {\n        return log10LikelihoodsOfAC[AF1p];\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * TODO -- eric what is this supposed to return?  my unit tests don't do what I think they should\n     *\n     * @return\n     */\n    public double getLog10PosteriorOfAFzero() {\n        return log10PosteriorOfAFzero;\n    }","id":41081,"modified_method":"/**\n     * Get the log10 normalized -- across all ACs -- posterior probability of AC == 0\n     *\n     * @return\n     */\n    @Ensures({\"goodLog10Value(result)\"})\n    public double getLog10PosteriorOfAFEq0() {\n        return log10PosteriorsOfAC[AF0];\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void setLog10PosteriorOfAFzero(final double log10PosteriorOfAFzero) {\n        this.log10PosteriorOfAFzero = log10PosteriorOfAFzero;\n        if ( log10PosteriorOfAFzero > log10MAP ) {\n            log10MAP = log10PosteriorOfAFzero;\n            Arrays.fill(alleleCountsOfMAP, 0);\n        }\n    }","id":41082,"modified_method":"/**\n     * Get the log10 normalized -- across all ACs -- posterior probability of AC > 0\n     *\n     * @return\n     */\n    @Ensures({\"goodLog10Value(result)\"})\n    public double getLog10PosteriorOfAFGT0() {\n        return log10PosteriorsOfAC[AF1p];\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResult result) {\n        final int[] maxACsToConsider = computeMaxACs(vc);\n        result.setAClimits(maxACsToConsider);\n        return new StateTracker(maxACsToConsider);\n    }","id":41083,"modified_method":"protected StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResultTracker resultTracker) {\n        final int[] maxACsToConsider = computeMaxACs(vc);\n        resultTracker.setAClimits(maxACsToConsider);\n        return new StateTracker(maxACsToConsider);\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"private double calculateAlleleCountConformation(final ExactACset set,\n                                                    final ArrayList<double[]> genotypeLikelihoods,\n                                                    final StateTracker stateTracker,\n                                                    final int numChr,\n                                                    final LinkedList<ExactACset> ACqueue,\n                                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                    final double[] log10AlleleFrequencyPriors,\n                                                    final AFCalcResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( stateTracker.abort(log10LofK, set.getACcounts()) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.getACcounts().getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.getACcounts().getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(stateTracker, ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.getACcounts().getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(stateTracker, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(stateTracker, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","id":41084,"modified_method":"private double calculateAlleleCountConformation(final ExactACset set,\n                                                    final ArrayList<double[]> genotypeLikelihoods,\n                                                    final StateTracker stateTracker,\n                                                    final int numChr,\n                                                    final LinkedList<ExactACset> ACqueue,\n                                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                    final double[] log10AlleleFrequencyPriors,\n                                                    final AFCalcResultTracker resultTracker) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, resultTracker);\n\n        final double log10LofK = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( stateTracker.abort(log10LofK, set.getACcounts()) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.getACcounts().getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.getACcounts().getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(stateTracker, ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.getACcounts().getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(stateTracker, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(stateTracker, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AFCalcResult result) {\n        final int numAlternateAlleles = vc.getNAlleles() - 1;\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(vc.getGenotypes());\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        final int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.getACcounts(), zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        final StateTracker stateTracker = makeMaxLikelihood(vc, result);\n\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n\n            if ( stateTracker.withinMaxACs(set.getACcounts()) ) {\n                final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, stateTracker, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n                // adjust max likelihood seen if needed\n                stateTracker.update(log10LofKs, set.getACcounts());\n\n                // clean up memory\n                indexesToACset.remove(set.getACcounts());\n                //if ( DEBUG )\n                //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n            }\n        }\n    }","id":41085,"modified_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AFCalcResultTracker resultTracker) {\n        final int numAlternateAlleles = vc.getNAlleles() - 1;\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(vc.getGenotypes());\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        final int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.getACcounts(), zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        final StateTracker stateTracker = makeMaxLikelihood(vc, resultTracker);\n\n        while ( !ACqueue.isEmpty() ) {\n            resultTracker.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n\n            if ( stateTracker.withinMaxACs(set.getACcounts()) ) {\n                final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, stateTracker, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, resultTracker);\n\n                // adjust max likelihood seen if needed\n                stateTracker.update(log10LofKs, set.getACcounts());\n\n                // clean up memory\n                indexesToACset.remove(set.getACcounts());\n                //if ( DEBUG )\n                //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n            }\n        }\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected abstract StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResult result);","id":41086,"modified_method":"protected abstract StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResultTracker resultTracker);","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void computeLofK(final ExactACset set,\n                             final ArrayList<double[]> genotypeLikelihoods,\n                             final double[] log10AlleleFrequencyPriors,\n                             final AFCalcResult result) {\n\n        set.getLog10Likelihoods()[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.getLog10Likelihoods().length; j++ )\n                set.getLog10Likelihoods()[j] = set.getLog10Likelihoods()[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n            result.setLog10LikelihoodOfAFzero(log10Lof0);\n            result.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.getLog10Likelihoods().length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.getLog10Likelihoods()[j-1] + gl[HOM_REF_INDEX];\n                set.getLog10Likelihoods()[j] = MathUtils.approximateLog10SumLog10(set.getLog10Likelihoods()[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.getLog10Likelihoods()[j] = set.getLog10Likelihoods()[j] - logDenominator;\n        }\n\n        double log10LofK = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n\n        // update the MLE if necessary\n        result.updateMLEifNeeded(log10LofK, set.getACcounts().getCounts());\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.getACcounts().getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        result.updateMAPifNeeded(log10LofK, set.getACcounts().getCounts());\n    }","id":41087,"modified_method":"private void computeLofK(final ExactACset set,\n                             final ArrayList<double[]> genotypeLikelihoods,\n                             final double[] log10AlleleFrequencyPriors,\n                             final AFCalcResultTracker resultTracker) {\n\n        set.getLog10Likelihoods()[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.getLog10Likelihoods().length; j++ )\n                set.getLog10Likelihoods()[j] = set.getLog10Likelihoods()[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n            resultTracker.setLog10LikelihoodOfAFzero(log10Lof0);\n            resultTracker.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.getLog10Likelihoods().length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.getLog10Likelihoods()[j-1] + gl[HOM_REF_INDEX];\n                set.getLog10Likelihoods()[j] = MathUtils.approximateLog10SumLog10(set.getLog10Likelihoods()[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.getLog10Likelihoods()[j] = set.getLog10Likelihoods()[j] - logDenominator;\n        }\n\n        double log10LofK = set.getLog10Likelihoods()[set.getLog10Likelihoods().length-1];\n\n        // update the MLE if necessary\n        resultTracker.updateMLEifNeeded(log10LofK, set.getACcounts().getCounts());\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.getACcounts().getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        resultTracker.updateMAPifNeeded(log10LofK, set.getACcounts().getCounts());\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean selectSiteInSamples(VariantContext vc) {\n        if ( samples == null || samples.isEmpty() )\n            return true;\n        // want to include a site in the given samples if it is *likely* to be variant (via the EXACT model)\n        // first subset to the samples\n        VariantContext subContext = vc.subContextFromSamples(samples);\n\n        // now check to see (using EXACT model) whether this should be variant\n        // do we want to apply a prior? maybe user-spec?\n        if ( flatPriors == null ) {\n            flatPriors = new double[1+2*samples.size()];\n            AFCalculator = new ReferenceDiploidExactAFCalc(samples.size(), 4);\n        }\n        AFCalcResult result = new AFCalcResult(vc.getAlternateAlleles().size());\n        AFCalculator.computeLog10PNonRef(subContext, flatPriors, result);\n        // do we want to let this qual go up or down?\n        if ( result.getLog10PosteriorOfAFzero() < referenceLikelihood ) {\n            return true;\n        }\n\n        return false;\n    }","id":41088,"modified_method":"public boolean selectSiteInSamples(VariantContext vc) {\n        if ( samples == null || samples.isEmpty() )\n            return true;\n        // want to include a site in the given samples if it is *likely* to be variant (via the EXACT model)\n        // first subset to the samples\n        VariantContext subContext = vc.subContextFromSamples(samples);\n\n        // now check to see (using EXACT model) whether this should be variant\n        // do we want to apply a prior? maybe user-spec?\n        if ( flatPriors == null ) {\n            flatPriors = new double[1+2*samples.size()];\n            AFCalculator = new ReferenceDiploidExactAFCalc(samples.size(), 4);\n        }\n        AFCalcResultTracker resultTracker = new AFCalcResultTracker(vc.getAlternateAlleles().size());\n        AFCalculator.computeLog10PNonRef(subContext, flatPriors, resultTracker);\n        // do we want to let this qual go up or down?\n        if ( resultTracker.getLog10PosteriorOfAFzero() < referenceLikelihood ) {\n            return true;\n        }\n\n        return false;\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    protected StateTracker makeMaxLikelihood(VariantContext vc, AFCalcResult result) {\n        return refModel.makeMaxLikelihood(vc, result);\n    }","id":41089,"modified_method":"@Override\n    protected StateTracker makeMaxLikelihood(VariantContext vc, AFCalcResultTracker resultTracker) {\n        return refModel.makeMaxLikelihood(vc, resultTracker);\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AFCalcResult result) {\n        final List<AFCalcResult> independentResults = computeLog10PNonRefForEachAllele(vc, log10AlleleFrequencyPriors);\n        combineIndependentPNonRefs(vc, independentResults, log10AlleleFrequencyPriors, result);\n    }","id":41090,"modified_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AFCalcResultTracker resultTracker) {\n        final List<AFCalcResultTracker> independentResultTrackers = computeLog10PNonRefForEachAllele(vc, log10AlleleFrequencyPriors);\n        combineIndependentPNonRefs(vc, independentResultTrackers, log10AlleleFrequencyPriors, resultTracker);\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Take the independent estimates of pNonRef for each alt allele and combine them into a single result\n     *\n     * Takes each independent result and merges it into the final result object\n     *\n     * @param independentPNonRefs the pNonRef result for each allele independently\n     * @param result the destination for the combined result\n     */\n    protected void combineIndependentPNonRefs(final VariantContext vc,\n                                              final List<AFCalcResult> independentPNonRefs,\n                                              final double[] log10AlleleFrequencyPriors,\n                                              final AFCalcResult result) {\n        final int nChrom = vc.getNSamples() * 2;\n\n        result.reset();\n\n        // both the likelihood and the posterior of AF=0 are the same for all alleles\n        // TODO -- check and ensure this is true\n        result.setLog10LikelihoodOfAFzero(independentPNonRefs.get(0).getLog10LikelihoodOfAFzero());\n        result.setLog10PosteriorOfAFzero(independentPNonRefs.get(0).getLog10PosteriorOfAFzero());\n        result.log10PosteriorMatrixSum = 0.0;\n\n        int altI = 0;\n        for ( final AFCalcResult independentPNonRef : independentPNonRefs ) {\n            result.log10MLE += independentPNonRef.getLog10MLE();\n\n            // TODO -- technically double counting some posterior mass\n            result.log10MAP += independentPNonRef.getLog10MAP();\n\n            // TODO -- technically double counting some posterior mass\n            result.log10PosteriorMatrixSum += independentPNonRef.getLog10PosteriorsMatrixSumWithoutAFzero();\n\n            result.getAlleleCountsOfMAP()[altI] = independentPNonRef.getAlleleCountsOfMAP()[0];\n            result.getAlleleCountsOfMLE()[altI] = independentPNonRef.getAlleleCountsOfMLE()[0];\n\n            result.nEvaluations += independentPNonRef.nEvaluations;\n            altI++;\n        }\n    }","id":41091,"modified_method":"/**\n     * Take the independent estimates of pNonRef for each alt allele and combine them into a single result\n     *\n     * Takes each independent result and merges it into the final result object\n     *\n     * @param independentPNonRefs the pNonRef result for each allele independently\n     * @param resultTracker the destination for the combined result\n     */\n    protected void combineIndependentPNonRefs(final VariantContext vc,\n                                              final List<AFCalcResultTracker> independentPNonRefs,\n                                              final double[] log10AlleleFrequencyPriors,\n                                              final AFCalcResultTracker resultTracker) {\n        final int nChrom = vc.getNSamples() * 2;\n\n        resultTracker.reset();\n\n        // both the likelihood and the posterior of AF=0 are the same for all alleles\n        // TODO -- check and ensure this is true\n        resultTracker.setLog10LikelihoodOfAFzero(independentPNonRefs.get(0).getLog10LikelihoodOfAFzero());\n        resultTracker.setLog10PosteriorOfAFzero(independentPNonRefs.get(0).getLog10PosteriorOfAFzero());\n        resultTracker.log10PosteriorMatrixSum = 0.0;\n\n        int altI = 0;\n        for ( final AFCalcResultTracker independentPNonRef : independentPNonRefs ) {\n            resultTracker.log10MLE += independentPNonRef.getLog10MLE();\n\n            // TODO -- technically double counting some posterior mass\n            resultTracker.log10MAP += independentPNonRef.getLog10MAP();\n\n            // TODO -- technically double counting some posterior mass\n            resultTracker.log10PosteriorMatrixSum += independentPNonRef.getLog10PosteriorsMatrixSumWithoutAFzero();\n\n            resultTracker.getAlleleCountsOfMAP()[altI] = independentPNonRef.getAlleleCountsOfMAP()[0];\n            resultTracker.getAlleleCountsOfMLE()[altI] = independentPNonRef.getAlleleCountsOfMLE()[0];\n\n            resultTracker.nEvaluations += independentPNonRef.nEvaluations;\n            altI++;\n        }\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected List<AFCalcResult> computeLog10PNonRefForEachAllele(final VariantContext vc,\n                                                                  final double[] log10AlleleFrequencyPriors) {\n        final int nAltAlleles = vc.getNAlleles() - 1;\n        final List<AFCalcResult> results = new ArrayList<AFCalcResult>(nAltAlleles);\n\n        for ( int altI = 0; altI < nAltAlleles; altI++ ) {\n            final List<Allele> biallelic = Arrays.asList(vc.getReference(), vc.getAlternateAllele(altI));\n            final VariantContext subvc = biallelicCombinedGLs(vc, biallelic, altI + 1);\n            final AFCalcResult result = refModel.getLog10PNonRef(subvc, log10AlleleFrequencyPriors);\n            results.add(result);\n        }\n\n        return results;\n    }","id":41092,"modified_method":"protected List<AFCalcResultTracker> computeLog10PNonRefForEachAllele(final VariantContext vc,\n                                                                  final double[] log10AlleleFrequencyPriors) {\n        final int nAltAlleles = vc.getNAlleles() - 1;\n        final List<AFCalcResultTracker> resultTrackers = new ArrayList<AFCalcResultTracker>(nAltAlleles);\n\n        for ( int altI = 0; altI < nAltAlleles; altI++ ) {\n            final List<Allele> biallelic = Arrays.asList(vc.getReference(), vc.getAlternateAllele(altI));\n            final VariantContext subvc = biallelicCombinedGLs(vc, biallelic, altI + 1);\n            final AFCalcResultTracker resultTracker = refModel.getLog10PNonRef(subvc, log10AlleleFrequencyPriors);\n            resultTrackers.add(resultTracker);\n        }\n\n        return resultTrackers;\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResult result) {\n        return new StateTracker();\n    }","id":41093,"modified_method":"protected StateTracker makeMaxLikelihood(final VariantContext vc, final AFCalcResultTracker resultTracker) {\n        return new StateTracker();\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Main entry function to calculate genotypes of a given VC with corresponding GL's\n     * @param tracker                            Tracker\n     * @param refContext                         Reference context\n     * @param rawContext                         Raw context\n     * @param stratifiedContexts                 Stratified alignment contexts\n     * @param vc                                 Input VC\n     * @param model                              GL calculation model\n     * @param inheritAttributesFromInputVC       Output VC will contain attributes inherited from input vc\n     * @return                                   VC with assigned genotypes\n     */\n    public VariantCallContext calculateGenotypes(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                 final AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts,\n                                                 final VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model,\n                                                 final boolean inheritAttributesFromInputVC,\n                                                 final Map<String,PerReadAlleleLikelihoodMap> perReadAlleleLikelihoodMap) {\n\n        boolean limitedContext = tracker == null || refContext == null || rawContext == null || stratifiedContexts == null;\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n            alleleFrequencyCalculationResult.set(new AFCalcResult(UAC.MAX_ALTERNATE_ALLELES));\n        }\n        AFCalcResult AFresult = alleleFrequencyCalculationResult.get();\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 ) {\n            if ( limitedContext )\n                return null;\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getTheta(model), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n        }\n\n        afcm.get().getLog10PNonRef(vc, getAlleleFrequencyPriors(model), AFresult);\n\n        // is the most likely frequency conformation AC=0 for all alternate alleles?\n        boolean bestGuessIsRef = true;\n\n        // determine which alternate alleles have AF>0\n        final List<Allele> myAlleles = new ArrayList<Allele>(vc.getAlleles().size());\n        final List<Integer> alleleCountsofMLE = new ArrayList<Integer>(vc.getAlleles().size());\n        myAlleles.add(vc.getReference());\n        for ( int i = 0; i < vc.getAlternateAlleles().size(); i++ ) {\n            final Allele alternateAllele = vc.getAlternateAllele(i);\n            final int indexOfAllele = AFresult.getAllelesUsedInGenotyping().indexOf(alternateAllele);\n            // the genotyping model may have stripped it out\n            if ( indexOfAllele == -1 )\n                continue;\n\n            final int indexOfBestAC = AFresult.getAlleleCountsOfMAP()[indexOfAllele-1];\n\n            // if the most likely AC is not 0, then this is a good alternate allele to use\n            if ( indexOfBestAC != 0 ) {\n                myAlleles.add(alternateAllele);\n                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);\n                bestGuessIsRef = false;\n            }\n            // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele\n            else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n                myAlleles.add(alternateAllele);\n                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);\n            }\n        }\n\n        // calculate p(f>0):\n        final double PoFEq0 = AFresult.getNormalizedPosteriorOfAFzero();\n        final double PoFGT0 = AFresult.getNormalizedPosteriorOfAFGTZero();\n\n        double phredScaledConfidence;\n        if ( !bestGuessIsRef || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PoFEq0);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * AFresult.getLog10PosteriorOfAFzero();\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PoFGT0);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                final double sum = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestGuessIsRef) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return limitedContext ? null : estimateReferenceConfidence(vc, stratifiedContexts, getTheta(model), true, PoFGT0);\n        }\n\n        // start constructing the resulting VC\n        final GenomeLoc loc = genomeLocParser.createGenomeLoc(vc);\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), loc.getStop(), myAlleles);\n        builder.log10PError(phredScaledConfidence/-10.0);\n        if ( ! passesCallThreshold(phredScaledConfidence) )\n            builder.filters(filter);\n\n        // create the genotypes\n        final GenotypesContext genotypes = afcm.get().subsetAlleles(vc, myAlleles, true,ploidy);\n        builder.genotypes(genotypes);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null && !limitedContext )\n            printVerboseData(refContext.getLocus().toString(), vc, PoFGT0, phredScaledConfidence, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        final HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // inherit attributed from input vc if requested\n        if (inheritAttributesFromInputVC)\n            attributes.putAll(vc.getAttributes());\n        // if the site was downsampled, record that fact\n        if ( !limitedContext && rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n        if ( UAC.ANNOTATE_NUMBER_OF_ALLELES_DISCOVERED )\n            attributes.put(NUMBER_OF_DISCOVERED_ALLELES_KEY, vc.getAlternateAlleles().size());\n\n        // add the MLE AC and AF annotations\n        if ( alleleCountsofMLE.size() > 0 ) {\n            attributes.put(VCFConstants.MLE_ALLELE_COUNT_KEY, alleleCountsofMLE);\n            final int AN = builder.make().getCalledChrCount();\n            final ArrayList<Double> MLEfrequencies = new ArrayList<Double>(alleleCountsofMLE.size());\n            // the MLEAC is allowed to be larger than the AN (e.g. in the case of all PLs being 0, the GT is ./. but the exact model may arbitrarily choose an AC>1)\n            for ( int AC : alleleCountsofMLE )\n                MLEfrequencies.add(Math.min(1.0, (double)AC / (double)AN));\n            attributes.put(VCFConstants.MLE_ALLELE_FREQUENCY_KEY, MLEfrequencies);\n        }\n\n        if ( !UAC.NO_SLOD && !limitedContext && !bestGuessIsRef ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            //double overallLog10PofNull = AFresult.log10AlleleFrequencyPosteriors[0];\n            double overallLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            List<Allele> allAllelesToUse = builder.make().getAlleles();\n            \n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, allAllelesToUse, false, model, perReadAlleleLikelihoodMap);\n            afcm.get().getLog10PNonRef(vcForward, getAlleleFrequencyPriors(model), AFresult);\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double forwardLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double forwardLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, allAllelesToUse, false, model, perReadAlleleLikelihoodMap);\n            afcm.get().getLog10PNonRef(vcReverse, getAlleleFrequencyPriors(model), AFresult);\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double reverseLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double reverseLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            if ( !Double.isNaN(strandScore) )\n                attributes.put(\"SB\", strandScore);\n        }\n\n        // finish constructing the resulting VC\n        builder.attributes(attributes);\n        VariantContext vcCall = builder.make();\n\n        // if we are subsetting alleles (either because there were too many or because some were not polymorphic)\n        // then we may need to trim the alleles (because the original VariantContext may have had to pad at the end).\n        if ( myAlleles.size() != vc.getAlleles().size() && !limitedContext ) // limitedContext callers need to handle allele trimming on their own to keep their perReadAlleleLikelihoodMap alleles in sync\n            vcCall = VariantContextUtils.reverseTrimAlleles(vcCall);\n\n        if ( annotationEngine != null && !limitedContext ) { // limitedContext callers need to handle annotations on their own by calling their own annotationEngine\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            final ReadBackedPileup pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall, perReadAlleleLikelihoodMap);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PoFGT0));\n    }","id":41094,"modified_method":"/**\n     * Main entry function to calculate genotypes of a given VC with corresponding GL's\n     * @param tracker                            Tracker\n     * @param refContext                         Reference context\n     * @param rawContext                         Raw context\n     * @param stratifiedContexts                 Stratified alignment contexts\n     * @param vc                                 Input VC\n     * @param model                              GL calculation model\n     * @param inheritAttributesFromInputVC       Output VC will contain attributes inherited from input vc\n     * @return                                   VC with assigned genotypes\n     */\n    public VariantCallContext calculateGenotypes(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                 final AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts,\n                                                 final VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model,\n                                                 final boolean inheritAttributesFromInputVC,\n                                                 final Map<String,PerReadAlleleLikelihoodMap> perReadAlleleLikelihoodMap) {\n\n        boolean limitedContext = tracker == null || refContext == null || rawContext == null || stratifiedContexts == null;\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n        }\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 ) {\n            if ( limitedContext )\n                return null;\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getTheta(model), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n        }\n\n        AFCalcResultTracker AFresult = afcm.get().getLog10PNonRef(vc, getAlleleFrequencyPriors(model));\n\n        // is the most likely frequency conformation AC=0 for all alternate alleles?\n        boolean bestGuessIsRef = true;\n\n        // determine which alternate alleles have AF>0\n        final List<Allele> myAlleles = new ArrayList<Allele>(vc.getAlleles().size());\n        final List<Integer> alleleCountsofMLE = new ArrayList<Integer>(vc.getAlleles().size());\n        myAlleles.add(vc.getReference());\n        for ( int i = 0; i < vc.getAlternateAlleles().size(); i++ ) {\n            final Allele alternateAllele = vc.getAlternateAllele(i);\n            final int indexOfAllele = AFresult.getAllelesUsedInGenotyping().indexOf(alternateAllele);\n            // the genotyping model may have stripped it out\n            if ( indexOfAllele == -1 )\n                continue;\n\n            final int indexOfBestAC = AFresult.getAlleleCountsOfMAP()[indexOfAllele-1];\n\n            // if the most likely AC is not 0, then this is a good alternate allele to use\n            if ( indexOfBestAC != 0 ) {\n                myAlleles.add(alternateAllele);\n                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);\n                bestGuessIsRef = false;\n            }\n            // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele\n            else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n                myAlleles.add(alternateAllele);\n                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);\n            }\n        }\n\n        // calculate p(f>0):\n        final double PoFEq0 = AFresult.getNormalizedPosteriorOfAFzero();\n        final double PoFGT0 = AFresult.getNormalizedPosteriorOfAFGTZero();\n\n        double phredScaledConfidence;\n        if ( !bestGuessIsRef || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PoFEq0);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * AFresult.getLog10PosteriorOfAFzero();\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PoFGT0);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                final double sum = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestGuessIsRef) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return limitedContext ? null : estimateReferenceConfidence(vc, stratifiedContexts, getTheta(model), true, PoFGT0);\n        }\n\n        // start constructing the resulting VC\n        final GenomeLoc loc = genomeLocParser.createGenomeLoc(vc);\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), loc.getStop(), myAlleles);\n        builder.log10PError(phredScaledConfidence/-10.0);\n        if ( ! passesCallThreshold(phredScaledConfidence) )\n            builder.filters(filter);\n\n        // create the genotypes\n        final GenotypesContext genotypes = afcm.get().subsetAlleles(vc, myAlleles, true,ploidy);\n        builder.genotypes(genotypes);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null && !limitedContext )\n            printVerboseData(refContext.getLocus().toString(), vc, PoFGT0, phredScaledConfidence, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        final HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // inherit attributed from input vc if requested\n        if (inheritAttributesFromInputVC)\n            attributes.putAll(vc.getAttributes());\n        // if the site was downsampled, record that fact\n        if ( !limitedContext && rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n        if ( UAC.ANNOTATE_NUMBER_OF_ALLELES_DISCOVERED )\n            attributes.put(NUMBER_OF_DISCOVERED_ALLELES_KEY, vc.getAlternateAlleles().size());\n\n        // add the MLE AC and AF annotations\n        if ( alleleCountsofMLE.size() > 0 ) {\n            attributes.put(VCFConstants.MLE_ALLELE_COUNT_KEY, alleleCountsofMLE);\n            final int AN = builder.make().getCalledChrCount();\n            final ArrayList<Double> MLEfrequencies = new ArrayList<Double>(alleleCountsofMLE.size());\n            // the MLEAC is allowed to be larger than the AN (e.g. in the case of all PLs being 0, the GT is ./. but the exact model may arbitrarily choose an AC>1)\n            for ( int AC : alleleCountsofMLE )\n                MLEfrequencies.add(Math.min(1.0, (double)AC / (double)AN));\n            attributes.put(VCFConstants.MLE_ALLELE_FREQUENCY_KEY, MLEfrequencies);\n        }\n\n        if ( !UAC.NO_SLOD && !limitedContext && !bestGuessIsRef ) {\n            //final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            //double overallLog10PofNull = AFresult.log10AlleleFrequencyPosteriors[0];\n            double overallLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            List<Allele> allAllelesToUse = builder.make().getAlleles();\n            \n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, allAllelesToUse, false, model, perReadAlleleLikelihoodMap);\n            AFresult = afcm.get().getLog10PNonRef(vcForward, getAlleleFrequencyPriors(model));\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double forwardLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double forwardLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, allAllelesToUse, false, model, perReadAlleleLikelihoodMap);\n            AFresult = afcm.get().getLog10PNonRef(vcReverse, getAlleleFrequencyPriors(model));\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(AFresult.log10AlleleFrequencyPosteriors, true);\n            double reverseLog10PofNull = AFresult.getLog10PosteriorOfAFzero();\n            double reverseLog10PofF = AFresult.getLog10PosteriorsMatrixSumWithoutAFzero();\n            //if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            //if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            if ( !Double.isNaN(strandScore) )\n                attributes.put(\"SB\", strandScore);\n        }\n\n        // finish constructing the resulting VC\n        builder.attributes(attributes);\n        VariantContext vcCall = builder.make();\n\n        // if we are subsetting alleles (either because there were too many or because some were not polymorphic)\n        // then we may need to trim the alleles (because the original VariantContext may have had to pad at the end).\n        if ( myAlleles.size() != vc.getAlleles().size() && !limitedContext ) // limitedContext callers need to handle allele trimming on their own to keep their perReadAlleleLikelihoodMap alleles in sync\n            vcCall = VariantContextUtils.reverseTrimAlleles(vcCall);\n\n        if ( annotationEngine != null && !limitedContext ) { // limitedContext callers need to handle annotations on their own by calling their own annotationEngine\n            // Note: we want to use the *unfiltered* and *unBAQed* context for the annotations\n            final ReadBackedPileup pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup);\n\n            vcCall = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall, perReadAlleleLikelihoodMap);\n        }\n\n        return new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PoFGT0));\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void printVerboseData(String pos, VariantContext vc, double PofF, double phredScaledConfidence, final GenotypeLikelihoodsCalculationModel.Model model) {\n        Allele refAllele = null, altAllele = null;\n        for ( Allele allele : vc.getAlleles() ) {\n            if ( allele.isReference() )\n                refAllele = allele;\n            else\n                altAllele = allele;\n        }\n\n        for (int i = 0; i <= N; i++) {\n            StringBuilder AFline = new StringBuilder(\"AFINFO\\t\");\n            AFline.append(pos);\n            AFline.append(\"\\t\");\n            AFline.append(refAllele);\n            AFline.append(\"\\t\");\n            if ( altAllele != null )\n                AFline.append(altAllele);\n            else\n                AFline.append(\"N/A\");\n            AFline.append(\"\\t\");\n            AFline.append(i + \"/\" + N + \"\\t\");\n            AFline.append(String.format(\"%.2f\\t\", ((float)i)/N));\n            AFline.append(String.format(\"%.8f\\t\", getAlleleFrequencyPriors(model)[i]));\n            AFline.append(String.format(\"%.8f\\t\", alleleFrequencyCalculationResult.get().getLog10MLE()));\n            AFline.append(String.format(\"%.8f\\t\", alleleFrequencyCalculationResult.get().getLog10MAP()));\n            verboseWriter.println(AFline.toString());\n        }\n\n        verboseWriter.println(\"P(f>0) = \" + PofF);\n        verboseWriter.println(\"Qscore = \" + phredScaledConfidence);\n        verboseWriter.println();\n    }","id":41095,"modified_method":"protected void printVerboseData(String pos, VariantContext vc, double PofF, double phredScaledConfidence, final GenotypeLikelihoodsCalculationModel.Model model) {\n        Allele refAllele = null, altAllele = null;\n        for ( Allele allele : vc.getAlleles() ) {\n            if ( allele.isReference() )\n                refAllele = allele;\n            else\n                altAllele = allele;\n        }\n\n        for (int i = 0; i <= N; i++) {\n            StringBuilder AFline = new StringBuilder(\"AFINFO\\t\");\n            AFline.append(pos);\n            AFline.append(\"\\t\");\n            AFline.append(refAllele);\n            AFline.append(\"\\t\");\n            if ( altAllele != null )\n                AFline.append(altAllele);\n            else\n                AFline.append(\"N/A\");\n            AFline.append(\"\\t\");\n            AFline.append(i + \"/\" + N + \"\\t\");\n            AFline.append(String.format(\"%.2f\\t\", ((float)i)/N));\n            AFline.append(String.format(\"%.8f\\t\", getAlleleFrequencyPriors(model)[i]));\n            verboseWriter.println(AFline.toString());\n        }\n\n        verboseWriter.println(\"P(f>0) = \" + PofF);\n        verboseWriter.println(\"Qscore = \" + phredScaledConfidence);\n        verboseWriter.println();\n    }","commit_id":"050d2aa6fd2c0a400743958b06be47594df6db62","url":"https://github.com/broadgsa/gatk"},{"original_method":"private JCMethodDecl transformDefaultedParameter(boolean abstract_, Tree.Parameter param, \n            Tree.Declaration container, Tree.ParameterList params) {\n        Parameter parameter = param.getDeclarationModel();\n        String name = Util.getDefaultedParamMethodName(container.getDeclarationModel(), parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(param), true, name);\n        \n        int modifiers = abstract_ ? PUBLIC | ABSTRACT : FINAL;\n        if (container.getDeclarationModel().isShared()) {\n            modifiers |= PUBLIC;\n        } else if (!container.getDeclarationModel().isToplevel()\n                && !abstract_){\n            modifiers |= PRIVATE;\n        }\n        if (Decl.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        methodBuilder.modifiers(modifiers);\n        \n        if (container instanceof Tree.AnyMethod) {\n            if (((Tree.AnyMethod)container).getTypeParameterList() != null) {\n                for (Tree.TypeParameterDeclaration t : ((Tree.AnyMethod)container).getTypeParameterList().getTypeParameterDeclarations()) {\n                    methodBuilder.typeParameter(t);\n                }\n            }\n        }\n        \n        /*if (!Decl.defaultParameterMethodOnSelf(container)) {\n            ProducedType thisType = getThisType(container);\n            methodBuilder.parameter(0, \"$this\", makeJavaType(thisType), null);\n        }*/\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == param) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        if (!abstract_) {\n            JCExpression expr = expressionGen().transform(param);\n            JCBlock body = at(param).Block(0, List.<JCStatement> of(at(param).Return(expr)));\n            methodBuilder.block(body);\n        }\n\n        return methodBuilder.build();\n    }","id":41096,"modified_method":"private JCMethodDecl makeParamDefaultValueMethod(boolean noBody, Tree.Parameter param, \n            Tree.Declaration container, Tree.ParameterList params) {\n        Parameter parameter = param.getDeclarationModel();\n        String name = Util.getDefaultedParamMethodName(container.getDeclarationModel(), parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(param), true, name);\n        \n        int modifiers = noBody ? PUBLIC | ABSTRACT : FINAL;\n        if (container.getDeclarationModel().isShared()) {\n            modifiers |= PUBLIC;\n        } else if (!container.getDeclarationModel().isToplevel()\n                && !noBody){\n            modifiers |= PRIVATE;\n        }\n        if (Decl.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        methodBuilder.modifiers(modifiers);\n        \n        if (container instanceof Tree.AnyMethod) {\n            if (((Tree.AnyMethod)container).getTypeParameterList() != null) {\n                for (Tree.TypeParameterDeclaration t : ((Tree.AnyMethod)container).getTypeParameterList().getTypeParameterDeclarations()) {\n                    methodBuilder.typeParameter(t);\n                }\n            }\n        }\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == param) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        if (noBody) {\n            methodBuilder.noBody();\n        } else {\n            JCExpression expr = expressionGen().transform(param);\n            JCBlock body = at(param).Block(0, List.<JCStatement> of(at(param).Return(expr)));\n            methodBuilder.block(body);\n        }\n\n        return methodBuilder.build();\n    }","commit_id":"74be2c3b77e25b6b79a32282f2a960d902b09c33","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void buildCompanion(final Tree.ClassOrInterface def,\n            final ClassOrInterface model, ClassDefinitionBuilder classBuilder) {\n        at(def);\n        // Give the $impl companion a $this field...\n        ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n        \n        ProducedType thisType = model.getType();\n        companionBuilder.field(PRIVATE | FINAL, \n                \"$this\", \n                makeJavaType(thisType), \n                null, false);\n        MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n        \n        // ...initialize the $this field from a ctor parameter...\n        ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n        ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                make().Exec(\n                        make().Assign(\n                                makeSelect(\"this\", \"$this\"), \n                                makeUnquotedIdent(\"$this\"))));\n        ctor.body(bodyStatements.toList());\n        if (!model.isToplevel()) {\n            // interfaces inner to local types have a different type in the \n            // interface and on the $impl because the real outer type is not \n            // visible because the interfaces is hoisted to top level\n            final ProducedType outerTypeInterface;\n            final ProducedType outerTypeCompanion;\n            if (Decl.isAncestorLocal(model)) {\n                Scope container = Decl.container(model);\n                while (!(container instanceof TypeDeclaration)) {\n                    container = container.getContainer();\n                }\n                outerTypeCompanion = ((TypeDeclaration)container).getType();\n                outerTypeInterface = typeFact().getObjectDeclaration().getType();\n            } else {\n                outerTypeInterface = thisType.getQualifyingType();\n                outerTypeCompanion = outerTypeInterface;\n            }\n            // ...add a $outer() method to the impl\n            {\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.modifiers(PRIVATE | FINAL);\n                JCExpression jt = makeJavaType(outerTypeCompanion);\n                outerBuilder.resultType(null, jt);\n                boolean requiresCast = false;\n                JCExpression expr = makeErroneous();\n                Scope container = model.getContainer();\n                if (container instanceof Class) {\n                    expr = makeSelect(makeQuotedQualIdentFromString(getFQDeclarationName((Class)container)), \"this\");\n                } else if (container instanceof Interface) {\n                    expr = make().Apply(null,// TODO Type args\n                            makeSelect(\"$this\", \"$outer\"),\n                            List.<JCExpression>nil());\n                    requiresCast = Decl.isLocal((Interface)container);\n                } else if (Decl.isLocal((model))) {\n                    while (!(container instanceof TypeDeclaration)) {\n                        container = container.getContainer();\n                    }\n                    expr = makeSelect(\n                                    makeQuotedQualIdentFromString(getFQDeclarationName((TypeDeclaration)container)), \n                                    \"this\");\n                } else {\n                    throw new RuntimeException();\n                }\n                if (requiresCast) {\n                    expr = make().TypeCast(makeJavaType(outerTypeCompanion), expr);\n                }\n                outerBuilder.body(make().Return(expr));\n                companionBuilder.defs(outerBuilder.build());\n            }\n            \n            {\n            // Add an $outer() method to the interface\n            MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n            outerBuilder.annotations(makeAtIgnore());\n            outerBuilder.modifiers(PUBLIC | ABSTRACT);\n            outerBuilder.resultType(null, makeJavaType(outerTypeInterface));\n            classBuilder.defs(outerBuilder.build());\n            }\n        }\n    }","id":41097,"modified_method":"private void buildCompanion(final Tree.ClassOrInterface def,\n            final ClassOrInterface model, ClassDefinitionBuilder classBuilder) {\n        at(def);\n        // Give the $impl companion a $this field...\n        ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n        \n        ProducedType thisType = model.getType();\n        companionBuilder.field(PRIVATE | FINAL, \n                \"$this\", \n                makeJavaType(thisType), \n                null, false);\n        MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n        \n        // ...initialize the $this field from a ctor parameter...\n        ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n        ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                make().Exec(\n                        make().Assign(\n                                makeSelect(\"this\", \"$this\"), \n                                makeUnquotedIdent(\"$this\"))));\n        ctor.body(bodyStatements.toList());\n        if (!model.isToplevel()) {\n            // interfaces inner to local types have a different type in the \n            // interface and on the $impl because the real outer type is not \n            // visible because the interfaces is hoisted to top level\n            final ProducedType outerTypeInterface;\n            final ProducedType outerTypeCompanion;\n            if (Decl.isAncestorLocal(model)) {\n                Scope container = Decl.container(model);\n                while (!(container instanceof TypeDeclaration)) {\n                    container = container.getContainer();\n                }\n                outerTypeCompanion = ((TypeDeclaration)container).getType();\n                outerTypeInterface = typeFact().getObjectDeclaration().getType();\n            } else {\n                outerTypeInterface = thisType.getQualifyingType();\n                outerTypeCompanion = outerTypeInterface;\n            }\n            // ...add a $outer() method to the impl\n            \n            MethodDefinitionBuilder outerBuilderCompanion = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n            outerBuilderCompanion.modifiers(PRIVATE | FINAL);\n            JCExpression jt = makeJavaType(outerTypeCompanion);\n            outerBuilderCompanion.resultType(null, jt);\n            boolean requiresCast = false;\n            JCExpression expr = makeErroneous();\n            Scope container = model.getContainer();\n            if (container instanceof Class) {\n                expr = makeSelect(makeQuotedQualIdentFromString(getFQDeclarationName((Class)container)), \"this\");\n            } else if (container instanceof Interface) {\n                expr = make().Apply(null,// TODO Type args\n                        makeSelect(\"$this\", \"$outer\"),\n                        List.<JCExpression>nil());\n                requiresCast = Decl.isLocal((Interface)container);\n            } else if (Decl.isLocal((model))) {\n                while (!(container instanceof TypeDeclaration)) {\n                    container = container.getContainer();\n                }\n                expr = makeSelect(\n                                makeQuotedQualIdentFromString(getFQDeclarationName((TypeDeclaration)container)), \n                                \"this\");\n            } else {\n                throw new RuntimeException();\n            }\n            if (requiresCast) {\n                expr = make().TypeCast(makeJavaType(outerTypeCompanion), expr);\n            }\n            outerBuilderCompanion.body(make().Return(expr));\n            companionBuilder.defs(outerBuilderCompanion.build());\n\n            // Add an $outer() method to the interface\n            MethodDefinitionBuilder outerBuilderInterface = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n            outerBuilderInterface.annotations(makeAtIgnore());\n            outerBuilderInterface.modifiers(PUBLIC | ABSTRACT);\n            outerBuilderInterface.resultType(null, makeJavaType(outerTypeInterface));\n            classBuilder.defs(outerBuilderInterface.build());\n        }\n    }","commit_id":"74be2c3b77e25b6b79a32282f2a960d902b09c33","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        if (model.isToplevel()) {\n            resetLocals();\n        } else if (Decl.isLocal(model)){\n            local(model.getContainer());\n        }\n        final String className;\n        if (def instanceof Tree.AnyInterface) {\n            className = getFQDeclarationName(model).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                // Does the parameter have a default value?\n                if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                    classBuilder.getCompanionBuilder().defs(transformDefaultedParameter(false, param, def, paramList));\n                }\n            }\n            \n            // Add overloaded constructors for defaulted parameter\n            for (Tree.Parameter param : paramList.getParameters()) {\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(true,\n                            overloadBuilder,\n                            def, model, true, paramList, param);\n                    \n                }\n            }\n            \n            if (model.getType().getQualifyingType() != null\n                    && model.getType().getQualifyingType().getDeclaration() instanceof Interface) {\n                // TODO \n            }\n            \n            // For each satisfied interface, instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            for (TypeDeclaration decl : model.getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)) {\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                ListBuffer<JCExpression> state = ListBuffer.<JCExpression>of(makeUnquotedIdent(\"this\"));\n                //if (!iface.isToplevel()) {\n                //    state.append(makeQualIdent(makeJavaType(iface.getType().getQualifyingType()), \"this\"));\n                //}\n                final String fieldName = getCompanionFieldName(iface);\n                classBuilder.init(make().Exec(make().Assign(\n                        makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                        make().NewClass(null, \n                                null, // TODO Type args \n                                makeCompanionType(iface), \n                                state.toList(),  \n                                null))));\n                \n                classBuilder.field(PRIVATE | FINAL, fieldName, \n                        makeCompanionType(iface), null, false);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            ProducedType type = model.getType().getQualifyingType();\n            while (type != null) {\n                java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                if (typeArguments == null) {\n                    continue;\n                }\n                for (TypeParameter typeArgument : typeArguments) {\n                    classBuilder.typeParameter(typeArgument);\n                }\n                type = type.getQualifyingType();\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            buildCompanion(def, model, classBuilder);   \n        }\n        \n        if (def instanceof Tree.AnyClass && def.getSatisfiedTypes() != null) {\n            for (Tree.SimpleType satisfiedType : def.getSatisfiedTypes().getTypes()) {\n                at(satisfiedType);\n                TypeDeclaration decl = satisfiedType.getDeclarationModel();\n                if (!(decl instanceof Interface)\n                        || decl.isToplevel()) {\n                    // TODO What about local interfaces?\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                \n                // Generate $outer() impl if implementing an inner interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), true, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtOverride());\n                outerBuilder.annotations(makeAtIgnore());\n                outerBuilder.modifiers(FINAL | PUBLIC);\n                outerBuilder.resultType(null, makeJavaType(iface.getType().getQualifyingType()));\n                Scope container = model.getContainer();\n                final JCExpression expr;\n                if (container instanceof Class) {\n                    expr = makeSelect(makeQuotedQualIdentFromString(getFQDeclarationName((Class)container)), \"this\");\n                } else {\n                    expr = makeNull();//TODO makeQuotedIdent(\"$outer\");// TODO Need to have a $outer field and pass in the outer instance to the ctor\n                }\n                outerBuilder.body(make().Return(expr));\n                classBuilder.defs(outerBuilder.build());\n            }\n            at(def);\n        }\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (Strategy.generateMain(def)) {\n            // Add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","id":41098,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        if (model.isToplevel()) {\n            resetLocals();\n        } else if (Decl.isLocal(model)){\n            local(model.getContainer());\n        }\n        final String className;\n        if (def instanceof Tree.AnyInterface) {\n            className = getFQDeclarationName(model).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    if (param.getDefaultArgument().getSpecifierExpression() != null) {\n                        classBuilder.getCompanionBuilder().defs(makeParamDefaultValueMethod(false, param, def, paramList));\n                    }    \n                    // Add overloaded constructors for defaulted parameter\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(true,\n                            overloadBuilder,\n                            def, model, true, paramList, param);\n                    \n                }\n            }\n            \n            if (model.getType().getQualifyingType() != null\n                    && model.getType().getQualifyingType().getDeclaration() instanceof Interface) {\n                // TODO \n            }\n            \n            if (def.getSatisfiedTypes() != null) {\n                for (Tree.SimpleType satisfiedType : def.getSatisfiedTypes().getTypes()) {\n                    TypeDeclaration decl = satisfiedType.getDeclarationModel();\n                    if (!(decl instanceof Interface)) {\n                        continue;\n                    }\n                    Interface iface = (Interface)decl;\n                    \n                    // For each satisfied interface, instantiate an instance of the \n                    // companion class in the constructor and assign it to a\n                    // $Interface$impl field\n                    transformInstantiateCompanions(classBuilder,\n                            satisfiedType, iface);\n                    \n                    if (!decl.isToplevel()) {// TODO What about local interfaces?\n                        // Generate $outer() impl if implementing an inner interface\n                        classBuilder.defs(makeOuterImpl(model, satisfiedType, iface));\n                    }\n                }\n                at(def);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            ProducedType type = model.getType().getQualifyingType();\n            while (type != null) {\n                java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                if (typeArguments == null) {\n                    continue;\n                }\n                for (TypeParameter typeArgument : typeArguments) {\n                    classBuilder.typeParameter(typeArgument);\n                }\n                type = type.getQualifyingType();\n            }\n        \n            buildCompanion(def, model, classBuilder);   \n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","commit_id":"74be2c3b77e25b6b79a32282f2a960d902b09c33","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(Tree.AnyMethod def, ClassDefinitionBuilder classBuilder) {\n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final Method model = def.getDeclarationModel();\n        final String methodName = Util.quoteMethodNameIfProperty(model, gen());\n        \n        java.util.List<ParameterList> parameterLists = def.getParameterLists();\n        boolean mpl = parameterLists.size() > 1;\n        ProducedType innerResultType = model.getType();\n        ProducedType resultType = innerResultType;\n        boolean isVoid = gen().isVoid(def.getType().getTypeModel());\n        // Transform the method body of the 'inner-most method'\n        List<JCStatement> body = null;\n        if (def instanceof Tree.MethodDefinition) {\n            Scope container = model.getContainer();\n            boolean isInterface = container instanceof com.redhat.ceylon.compiler.typechecker.model.Interface;\n            if(!isInterface){\n                body = statementGen().transform(((Tree.MethodDefinition)def).getBlock()).getStatements();\n            }\n        } else if (def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() != null) {\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), ((MethodDeclaration) def).getSpecifierExpression(), def.getDeclarationModel());\n            if (isVoid) {\n                body = List.<JCStatement>of(make().Exec(specifierBuilder.build()));\n            } else {\n                body = List.<JCStatement>of(make().Return(specifierBuilder.build()));\n            }\n        }\n        \n        // Construct all but the outer-most method\n        for (int index = parameterLists.size() - 1; index >  0; index--) {\n            resultType = gen().typeFact().getCallableType(resultType);\n            CallableBuilder cb = CallableBuilder.mpl(gen(), resultType, def.getDeclarationModel().getParameterLists().get(index), body);\n            body = List.<JCStatement>of(make().Return(cb.build()));\n        }\n        \n        // Finally construct the outermost method using the body we've built so far\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(), \n                methodName);\n        \n        final ParameterList paramList = parameterLists.get(0);\n        \n        if (mpl) {\n            methodBuilder.resultType(null, makeJavaType(resultType));\n        } else {\n            methodBuilder.resultType(model);\n        }\n        \n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            methodBuilder.parameter(param);\n            // Does the parameter have a default value?\n            if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                JCMethodDecl defaultValueMethodImpl = transformDefaultedParameter(false, param, def, paramList);\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    lb.add(defaultValueMethodImpl);\n                } else {\n                    lb.add(transformDefaultedParameter(true, param, def, paramList));\n                    classBuilder.getCompanionBuilder().defs(defaultValueMethodImpl);\n                }\n            }\n        }\n        \n        if (body != null) {\n            methodBuilder.body(body);\n        } else {\n            methodBuilder.noBody();\n        }\n        \n        if(Util.hasCompilerAnnotation(def, \"test\")){\n            methodBuilder.annotations(List.of(make().Annotation(makeQualIdentFromString(\"org.junit.Test\"), List.<JCTree.JCExpression>nil())));\n        }\n        \n        methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(Decl.isActual(def))\n            .modelAnnotations(model.getAnnotations());\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            DefaultArgument defaultArgument = param.getDefaultArgument();\n            if (defaultArgument != null) {\n                MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(),\n                        methodName);\n                JCMethodDecl overloadedMethod = transformForDefaultedParameter(!Decl.withinInterface(model), overloadBuilder, \n                        def, model, isVoid, paramList, param).build();\n                lb.prepend(overloadedMethod);    \n            }\n        }\n        \n        // Generate an impl for overloaded methods using the $impl instance\n        // TODO MPL\n        if (Decl.withinInterface(model.getRefinedDeclaration())\n                && !Decl.withinInterface(model)) {\n            java.util.List<Parameter> parameters = model.getParameterLists().get(0).getParameters();\n            for (Parameter p : parameters) {\n                if (p.isDefaulted()) {\n                    classBuilder.defs(transformDefaultValueMethodImpl(model, parameters, p));\n                    classBuilder.defs(overloadMethodImpl(model, parameters, p));\n                }\n            }\n        }\n        \n        // interface methods without concrete implementation (including \n        // overloaded versions) on the companion class by delegating to \n        // $this (for closure purposes) \n        if (Decl.withinInterface(model)\n                && def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() == null) {\n            \n            for (Tree.Parameter param : paramList.getParameters()) {\n                if (param.getDefaultArgument() != null\n                        || paramList.getParameters().indexOf(param) == paramList.getParameters().size()) {\n                    MethodDefinitionBuilder delegateBuilder = MethodDefinitionBuilder.method(gen(), false, true, methodName);\n                    delegateBuilder.modifiers(PRIVATE | FINAL);\n                    if (def.getTypeParameterList() != null) {\n                        for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                            delegateBuilder.typeParameter(t);\n                        }\n                    }\n                    delegateBuilder.resultType(model);\n                    ListBuffer<JCExpression> arguments = ListBuffer.<JCExpression>lb();\n                    for (Tree.Parameter p : paramList.getParameters().subList(0, paramList.getParameters().indexOf(param))) {\n                        delegateBuilder.parameter(p);\n                        arguments.append(makeQuotedIdent(p.getDeclarationModel().getName()));\n                    }\n                    JCExpression expr = make().Apply(\n                            typeParams(model),\n                            makeSelect(\"$this\", methodName), \n                            arguments.toList());\n                    if (isVoid) {\n                        delegateBuilder.body(make().Exec(expr));\n                    } else {\n                        delegateBuilder.body(make().Return(expr));\n                    }\n                    classBuilder.getCompanionBuilder().defs(delegateBuilder.build());\n                }\n            }\n        }\n        \n        lb.prepend(methodBuilder.build());\n        \n        return lb.toList();\n    }","id":41099,"modified_method":"public List<JCTree> transform(Tree.AnyMethod def, ClassDefinitionBuilder classBuilder) {\n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final Method model = def.getDeclarationModel();\n        final String methodName = Util.quoteMethodNameIfProperty(model, gen());\n        \n        java.util.List<ParameterList> parameterLists = def.getParameterLists();\n        boolean mpl = parameterLists.size() > 1;\n        ProducedType innerResultType = model.getType();\n        ProducedType resultType = innerResultType;\n        boolean isVoid = gen().isVoid(def.getType().getTypeModel());\n        // Transform the method body of the 'inner-most method'\n        List<JCStatement> body = null;\n        if (def instanceof Tree.MethodDefinition) {\n            Scope container = model.getContainer();\n            boolean isInterface = container instanceof com.redhat.ceylon.compiler.typechecker.model.Interface;\n            if(!isInterface){\n                body = statementGen().transform(((Tree.MethodDefinition)def).getBlock()).getStatements();\n            }\n        } else if (def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() != null) {\n            InvocationBuilder specifierBuilder = InvocationBuilder.forSpecifierInvocation(gen(), ((MethodDeclaration) def).getSpecifierExpression(), def.getDeclarationModel());\n            if (isVoid) {\n                body = List.<JCStatement>of(make().Exec(specifierBuilder.build()));\n            } else {\n                body = List.<JCStatement>of(make().Return(specifierBuilder.build()));\n            }\n        }\n        \n        // Construct all but the outer-most method\n        for (int index = parameterLists.size() - 1; index >  0; index--) {\n            resultType = gen().typeFact().getCallableType(resultType);\n            CallableBuilder cb = CallableBuilder.mpl(gen(), resultType, def.getDeclarationModel().getParameterLists().get(index), body);\n            body = List.<JCStatement>of(make().Return(cb.build()));\n        }\n        \n        // Finally construct the outermost method using the body we've built so far\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(), \n                methodName);\n        \n        final ParameterList paramList = parameterLists.get(0);\n        \n        if (mpl) {\n            methodBuilder.resultType(null, makeJavaType(resultType));\n        } else {\n            methodBuilder.resultType(model);\n        }\n        \n        if (def.getTypeParameterList() != null) {\n            for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                methodBuilder.typeParameter(t);\n            }\n        }\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            methodBuilder.parameter(param);\n            // Does the parameter have a default value?\n            if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                JCMethodDecl defaultValueMethodImpl = makeParamDefaultValueMethod(false, param, def, paramList);\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    lb.add(defaultValueMethodImpl);\n                } else {\n                    lb.add(makeParamDefaultValueMethod(true, param, def, paramList));\n                    classBuilder.getCompanionBuilder().defs(defaultValueMethodImpl);\n                }\n            }\n        }\n        \n        if (body != null) {\n            methodBuilder.body(body);\n        } else {\n            methodBuilder.noBody();\n        }\n        \n        if(Util.hasCompilerAnnotation(def, \"test\")){\n            methodBuilder.annotations(List.of(make().Annotation(makeQualIdentFromString(\"org.junit.Test\"), List.<JCTree.JCExpression>nil())));\n        }\n        \n        methodBuilder\n            .modifiers(transformMethodDeclFlags(def))\n            .isActual(Decl.isActual(def))\n            .modelAnnotations(model.getAnnotations());\n        \n        for (Tree.Parameter param : paramList.getParameters()) {\n            DefaultArgument defaultArgument = param.getDefaultArgument();\n            if (defaultArgument != null) {\n                MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(def), model.isClassOrInterfaceMember(),\n                        methodName);\n                JCMethodDecl overloadedMethod = transformForDefaultedParameter(!Decl.withinInterface(model), overloadBuilder, \n                        def, model, isVoid, paramList, param).build();\n                lb.prepend(overloadedMethod);    \n            }\n        }\n        \n        // Generate an impl for overloaded methods using the $impl instance\n        // TODO MPL\n        if (Decl.withinInterface(model.getRefinedDeclaration())\n                && !Decl.withinInterface(model)) {\n            java.util.List<Parameter> parameters = model.getParameterLists().get(0).getParameters();\n            for (Parameter p : parameters) {\n                if (p.isDefaulted()) {\n                    classBuilder.defs(transformDefaultValueMethodImpl(model, parameters, p));\n                    classBuilder.defs(overloadMethodImpl(model, parameters, p));\n                }\n            }\n        }\n        \n        // interface methods without concrete implementation (including \n        // overloaded versions) on the companion class by delegating to \n        // $this (for closure purposes) \n        if (Decl.withinInterface(model)\n                && def instanceof MethodDeclaration\n                && ((MethodDeclaration) def).getSpecifierExpression() == null) {\n            \n            for (Tree.Parameter param : paramList.getParameters()) {\n                if (param.getDefaultArgument() != null\n                        || paramList.getParameters().indexOf(param) == paramList.getParameters().size()) {\n                    MethodDefinitionBuilder delegateBuilder = MethodDefinitionBuilder.method(gen(), false, true, methodName);\n                    delegateBuilder.modifiers(PRIVATE | FINAL);\n                    if (def.getTypeParameterList() != null) {\n                        for (Tree.TypeParameterDeclaration t : def.getTypeParameterList().getTypeParameterDeclarations()) {\n                            delegateBuilder.typeParameter(t);\n                        }\n                    }\n                    delegateBuilder.resultType(model);\n                    ListBuffer<JCExpression> arguments = ListBuffer.<JCExpression>lb();\n                    for (Tree.Parameter p : paramList.getParameters().subList(0, paramList.getParameters().indexOf(param))) {\n                        delegateBuilder.parameter(p);\n                        arguments.append(makeQuotedIdent(p.getDeclarationModel().getName()));\n                    }\n                    JCExpression expr = make().Apply(\n                            typeParams(model),\n                            makeSelect(\"$this\", methodName), \n                            arguments.toList());\n                    if (isVoid) {\n                        delegateBuilder.body(make().Exec(expr));\n                    } else {\n                        delegateBuilder.body(make().Return(expr));\n                    }\n                    classBuilder.getCompanionBuilder().defs(delegateBuilder.build());\n                }\n            }\n        }\n        \n        lb.prepend(methodBuilder.build());\n        \n        return lb.toList();\n    }","commit_id":"74be2c3b77e25b6b79a32282f2a960d902b09c33","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCMethodDecl transformDefaultedParameter(Tree.Parameter param, Tree.Declaration container, Tree.ParameterList params) {\n        Parameter parameter = param.getDeclarationModel();\n        String name = Util.getDefaultedParamMethodName(container.getDeclarationModel(), parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(param), true, name);\n        \n        int modifiers = FINAL;\n        if (container.getDeclarationModel().isShared()) {\n            modifiers |= PUBLIC;\n        } else {\n            modifiers |= PRIVATE;\n        }\n        if (Decl.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        \n        if (!Decl.defaultParameterMethodOnSelf(container)) {\n            ProducedType thisType = getThisType(container);\n            methodBuilder.parameter(0, \"$this\", makeJavaType(thisType), null);\n        }\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == param) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        JCExpression expr = expressionGen().transform(param);\n        JCBlock body = at(param).Block(0, List.<JCStatement> of(at(param).Return(expr)));\n        methodBuilder.block(body);\n\n        return methodBuilder\n            .modifiers(modifiers)\n            .build();\n    }","id":41100,"modified_method":"private JCMethodDecl transformDefaultedParameter(Tree.Parameter param, Tree.Declaration container, Tree.ParameterList params) {\n        Parameter parameter = param.getDeclarationModel();\n        String name = Util.getDefaultedParamMethodName(container.getDeclarationModel(), parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(param), true, name);\n        \n        int modifiers = FINAL;\n        if (container.getDeclarationModel().isShared()) {\n            modifiers |= PUBLIC;\n        } else {\n            modifiers |= PRIVATE;\n        }\n        if (Decl.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        methodBuilder.modifiers(modifiers);\n        \n        if (container instanceof Tree.AnyMethod) {\n            if (((Tree.AnyMethod)container).getTypeParameterList() != null) {\n                for (Tree.TypeParameterDeclaration t : ((Tree.AnyMethod)container).getTypeParameterList().getTypeParameterDeclarations()) {\n                    methodBuilder.typeParameter(t);\n                }\n            }\n        }\n        \n        if (!Decl.defaultParameterMethodOnSelf(container)) {\n            ProducedType thisType = getThisType(container);\n            methodBuilder.parameter(0, \"$this\", makeJavaType(thisType), null);\n        }\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == param) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        JCExpression expr = expressionGen().transform(param);\n        JCBlock body = at(param).Block(0, List.<JCStatement> of(at(param).Return(expr)));\n        methodBuilder.block(body);\n\n        return methodBuilder.build();\n    }","commit_id":"a11f609c32a3db12cd22f7a9769513ff022a901f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> transformMethod(Tree.AnyMethod def,\n            final Method model, final String methodName,\n            boolean method,\n            boolean includeBody,\n            List<JCStatement> body,\n            boolean overloads,\n            boolean overloadsBody,\n            boolean overloadsImplementor,\n            boolean overloadsDelegator,\n            boolean defaultValues,\n            boolean defaultValuesBody) {\n        \n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(\n                this, Decl.isAncestorLocal(model), model.isClassOrInterfaceMember(), \n                methodName);\n        methodBuilder.resultType(model);\n        copyTypeParameters(model, methodBuilder);\n        final ParameterList parameterList = model.getParameterLists().get(0);\n        Tree.ParameterList paramList = def.getParameterLists().get(0);\n        for (Tree.Parameter param : paramList.getParameters()) {\n            Parameter parameter = param.getDeclarationModel();\n            methodBuilder.parameter(parameter);\n            if (parameter.isDefaulted()\n                    || parameter.isSequenced()) {\n                if (model.getRefinedDeclaration() == model) {\n                    \n                    if (overloads) {\n                        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(model), model.isClassOrInterfaceMember(),\n                                methodName);\n                        JCMethodDecl overloadedMethod = makeOverloadsForDefaultedParameter(\n                                overloadsBody, overloadsImplementor, overloadsDelegator, \n                                overloadBuilder, \n                                model, parameterList.getParameters(), parameter).build();\n                        lb.prepend(overloadedMethod);\n                    }\n                    \n                    if (defaultValues) {\n                        lb.add(makeParamDefaultValueMethod(defaultValuesBody, model, paramList, param));    \n                    }\n                }\n            }    \n        }\n        if (includeBody) {\n            // Construct the outermost method using the body we've built so far\n            body = transformMplBody(model, body);\n            methodBuilder.body(body);\n        } else {\n            methodBuilder.noBody();\n        }\n        methodBuilder\n            .modifiers(transformMethodDeclFlags(model))\n            .isActual(model.isActual())\n            .modelAnnotations(model.getAnnotations());\n        if(CodegenUtil.hasCompilerAnnotation(def, \"test\")){\n            methodBuilder.annotations(List.of(make().Annotation(makeSelect(\"org\", \"junit\", \"Test\"), List.<JCTree.JCExpression>nil())));\n        }\n        if (method) {\n            lb.prepend(methodBuilder.build());\n        }\n        return lb.toList();\n    }","id":41101,"modified_method":"/**\n     * Transforms a method, optionally generating overloads and \n     * default value methods\n     * @param def The method\n     * @param model The method model\n     * @param methodName The method name\n     * @param transformMethod Whether the method itself should be transformed.\n     * @param actualAndAnnotations Whether the method itself is actual and has \n     * model annotations\n     * @param body The body of the method (or null for an abstract method)\n     * @param transformOverloads Whether to generate overload methods\n     * @param overloadsFlags The overload flags\n     * @param transformDefaultValues Whether to generate default value methods\n     * @param defaultValuesBody Whether the default value methods should have a body\n     */\n    private List<JCTree> transformMethod(Tree.AnyMethod def,\n            final Method model, final String methodName,\n            boolean transformMethod, boolean actualAndAnnotations, List<JCStatement> body, \n            boolean transformOverloads, int overloadsFlags, \n            boolean transformDefaultValues, boolean defaultValuesBody) {\n        \n        ListBuffer<JCTree> lb = ListBuffer.<JCTree>lb();\n        final MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(\n                this, Decl.isAncestorLocal(model), model.isClassOrInterfaceMember(), \n                methodName);\n        final ParameterList parameterList = model.getParameterLists().get(0);\n        Tree.ParameterList paramList = def.getParameterLists().get(0);\n        for (Tree.Parameter param : paramList.getParameters()) {\n            Parameter parameter = param.getDeclarationModel();\n            methodBuilder.parameter(parameter);\n            if (parameter.isDefaulted()\n                    || parameter.isSequenced()) {\n                if (model.getRefinedDeclaration() == model) {\n                    \n                    if (transformOverloads) {\n                        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(model), model.isClassOrInterfaceMember(),\n                                methodName);\n                        JCMethodDecl overloadedMethod = makeOverloadsForDefaultedParameter(\n                                overloadsFlags, \n                                overloadBuilder, \n                                model, parameterList.getParameters(), parameter).build();\n                        lb.prepend(overloadedMethod);\n                    }\n                    \n                    if (transformDefaultValues) {\n                        lb.add(makeParamDefaultValueMethod(defaultValuesBody, model, paramList, param));    \n                    }\n                }\n            }    \n        }\n        \n        if (transformMethod) {\n            methodBuilder.resultType(model);\n            copyTypeParameters(model, methodBuilder);\n            if (body != null) {\n                // Construct the outermost method using the body we've built so far\n                methodBuilder.body(body);\n            } else {\n                methodBuilder.noBody();\n            }\n            methodBuilder\n                .modifiers(transformMethodDeclFlags(model));\n            if (actualAndAnnotations) {\n                methodBuilder.isActual(model.isActual())\n                    .modelAnnotations(model.getAnnotations());\n            }\n            if (CodegenUtil.hasCompilerAnnotation(def, \"test\")){\n                methodBuilder.annotations(List.of(make().Annotation(makeSelect(\"org\", \"junit\", \"Test\"), List.<JCTree.JCExpression>nil())));\n            }\n            lb.prepend(methodBuilder.build());\n        }\n        return lb.toList();\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            boolean generateBody,\n            boolean forImplementor, \n            boolean forDelegator,\n            MethodDefinitionBuilder overloadBuilder,\n            Declaration model,\n            Tree.ParameterList paramList,\n            Tree.Parameter currentParam) {\n        at(currentParam);\n        java.util.List<Parameter> parameters = new java.util.ArrayList<Parameter>(paramList.getParameters().size());\n        for (Tree.Parameter param : paramList.getParameters()) {\n            parameters.add(param.getDeclarationModel());\n        }\n        return makeOverloadsForDefaultedParameter(generateBody, forImplementor, forDelegator,\n                overloadBuilder, model,\n                parameters, currentParam);\n    }","id":41102,"modified_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags,\n            MethodDefinitionBuilder overloadBuilder,\n            Declaration model,\n            Tree.ParameterList paramList,\n            Tree.Parameter currentParam) {\n        at(currentParam);\n        java.util.List<Parameter> parameters = new java.util.ArrayList<Parameter>(paramList.getParameters().size());\n        for (Tree.Parameter param : paramList.getParameters()) {\n            parameters.add(param.getDeclarationModel());\n        }\n        return makeOverloadsForDefaultedParameter(flags,\n                overloadBuilder, model,\n                parameters, currentParam.getDeclarationModel());\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"List<JCTree> transform(Tree.AnyMethod def,\n            ClassDefinitionBuilder classBuilder, List<JCStatement> body) {\n        final Method model = def.getDeclarationModel();\n        final String methodName = CodegenUtil.quoteMethodNameIfProperty(model, gen());\n        if (Decl.withinInterface(model)) {\n            // Transform it for the companion\n            final List<JCTree> companionDefs = transformMethod(def, model, methodName, \n                    def instanceof MethodDeclaration\n                    && ((MethodDeclaration) def).getSpecifierExpression() != null,\n                    def instanceof MethodDeclaration\n                    && ((MethodDeclaration) def).getSpecifierExpression() != null,\n                    body,\n                    def instanceof MethodDeclaration,\n                    true, true, true,\n                    !Strategy.defaultParameterMethodOnSelf(model),\n                    false);\n            classBuilder.getCompanionBuilder((Declaration)model.getContainer()).defs(companionDefs);\n        }\n        \n        List<JCTree> result;\n        if (Strategy.onlyOnCompanion(model)) {\n            result = List.<JCTree>nil();\n        } else {\n            // Transform it for the interface/class\n            result = transformMethod(def, model, methodName, true, !model.isInterfaceMember(), \n                    body, \n                    true,\n                    !Decl.withinInterface(model), false, false,\n                    true,\n                    !Strategy.defaultParameterMethodOnSelf(model));\n        }\n        \n        if (def instanceof Tree.MethodDefinition) {\n            Tree.MethodDefinition m = (Tree.MethodDefinition)def;\n            if (Decl.withinInterface(m) && m.getBlock() != null) {\n                classBuilder.getCompanionBuilder((Declaration)model.getContainer())\n                .defs(transformConcreteInterfaceMember(m, \n                        ((ClassOrInterface)Decl.container(def)).getType()));\n            }\n        }\n        \n        return result;\n    }","id":41103,"modified_method":"List<JCTree> transform(Tree.AnyMethod def,\n            ClassDefinitionBuilder classBuilder, List<JCStatement> body) {\n        final Method model = def.getDeclarationModel();\n        final String methodName = CodegenUtil.quoteMethodNameIfProperty(model, gen());\n        if (Decl.withinInterface(model)) {\n            // Transform it for the companion\n            final Block block;\n            final SpecifierExpression specifier;\n            if (def instanceof MethodDeclaration) {\n                block = null;\n                specifier = ((MethodDeclaration) def).getSpecifierExpression();\n            } else if (def instanceof MethodDefinition) {\n                block = ((MethodDefinition) def).getBlock();\n                specifier = null;\n            } else {\n                throw new RuntimeException();\n            }\n            boolean transformMethod = specifier != null || block != null;\n            boolean actualAndAnnotations = def instanceof MethodDeclaration;\n            List<JCStatement> cbody = specifier != null ? transformMplBody(model, body) \n                    : block != null ? statementGen().transform(block).getStatements() \n                    : null;\n                    \n            boolean transformOverloads = def instanceof MethodDeclaration || block != null;\n            int overloadsDelegator = OL_BODY | OL_IMPLEMENTOR | (def instanceof MethodDeclaration ? OL_DELEGATOR : 0);\n            \n            boolean transformDefaultValues = def instanceof MethodDeclaration || block != null;\n            \n            List<JCTree> companionDefs = transformMethod(def, model, methodName, \n                        transformMethod,\n                        actualAndAnnotations,\n                        cbody,\n                        transformOverloads,\n                        overloadsDelegator,\n                        transformDefaultValues,\n                        false);\n            classBuilder.getCompanionBuilder((Declaration)model.getContainer()).defs(companionDefs);\n        }\n        \n        List<JCTree> result;\n        if (Strategy.onlyOnCompanion(model)) {\n            result = List.<JCTree>nil();\n        } else {\n            // Transform it for the interface/class\n            List<JCStatement> cbody = !model.isInterfaceMember() ? transformMplBody(model, body) : null;\n            result = transformMethod(def, model, methodName, true, true, \n                    cbody, \n                    true,\n                    Decl.withinInterface(model) ? 0 : OL_BODY,\n                    true,\n                    !Strategy.defaultParameterMethodOnSelf(model));\n        }\n        \n        return result;\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCMethodDecl makeParamDefaultValueMethod(boolean noBody, Declaration container, \n            Tree.ParameterList params, Tree.Parameter currentParam) {\n        at(currentParam);\n        Parameter parameter = currentParam.getDeclarationModel();\n        String name = CodegenUtil.getDefaultedParamMethodName(container, parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(container), true, name);\n        methodBuilder.annotations(makeAtIgnore());\n        int modifiers = noBody ? PUBLIC | ABSTRACT : FINAL;\n        if (container.isShared()) {\n            modifiers |= PUBLIC;\n        } else if (!container.isToplevel()\n                && !noBody){\n            modifiers |= PRIVATE;\n        }\n        if (Strategy.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        methodBuilder.modifiers(modifiers);\n        \n        if (container instanceof Method) {\n            copyTypeParameters((Method)container, methodBuilder);\n        } else if (Decl.isToplevel(container)\n                && container instanceof Class) {\n            copyTypeParameters((Class)container, methodBuilder);\n        }\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == currentParam) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        if (noBody) {\n            methodBuilder.noBody();\n        } else {\n            JCExpression expr = expressionGen().transform(currentParam);\n            JCBlock body = at(currentParam).Block(0, List.<JCStatement> of(at(currentParam).Return(expr)));\n            methodBuilder.block(body);\n        }\n\n        return methodBuilder.build();\n    }","id":41104,"modified_method":"/**\n     * Creates a (possibly abstract) method for retrieving the value for a \n     * defaulted parameter\n     */\n    private JCMethodDecl makeParamDefaultValueMethod(boolean noBody, Declaration container, \n            Tree.ParameterList params, Tree.Parameter currentParam) {\n        at(currentParam);\n        Parameter parameter = currentParam.getDeclarationModel();\n        String name = CodegenUtil.getDefaultedParamMethodName(container, parameter );\n        MethodDefinitionBuilder methodBuilder = MethodDefinitionBuilder.method(this, Decl.isAncestorLocal(container), true, name);\n        methodBuilder.annotations(makeAtIgnore());\n        int modifiers = noBody ? PUBLIC | ABSTRACT : FINAL;\n        if (container.isShared()) {\n            modifiers |= PUBLIC;\n        } else if (!container.isToplevel()\n                && !noBody){\n            modifiers |= PRIVATE;\n        }\n        if (Strategy.defaultParameterMethodStatic(container)) {\n            modifiers |= STATIC;\n        }\n        methodBuilder.modifiers(modifiers);\n        \n        if (container instanceof Method) {\n            copyTypeParameters((Method)container, methodBuilder);\n        } else if (Decl.isToplevel(container)\n                && container instanceof Class) {\n            copyTypeParameters((Class)container, methodBuilder);\n        }\n        \n        // Add any of the preceding parameters as parameters to the method\n        for (Tree.Parameter p : params.getParameters()) {\n            if (p == currentParam) {\n                break;\n            }\n            methodBuilder.parameter(p);\n        }\n\n        // The method's return type is the same as the parameter's type\n        methodBuilder.resultType(parameter);\n\n        // The implementation of the method\n        if (noBody) {\n            methodBuilder.noBody();\n        } else {\n            JCExpression expr = expressionGen().transform(currentParam);\n            JCBlock body = at(currentParam).Block(0, List.<JCStatement> of(at(currentParam).Return(expr)));\n            methodBuilder.block(body);\n        }\n\n        return methodBuilder.build();\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            boolean generateBody, \n            boolean forImplementor, \n            boolean forDelegator, MethodDefinitionBuilder overloadBuilder,\n            final Declaration model, java.util.List<Parameter> parameters,\n            final Parameter currentParam) {\n        overloadBuilder.annotations(makeAtIgnore());\n        \n        final JCExpression methName;\n        if (model instanceof Method) {\n            long mods = transformOverloadMethodDeclFlags((Method)model);\n            if (generateBody) {\n                mods &= ~ABSTRACT;\n            }\n            if (forImplementor || forDelegator) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            if (forDelegator) {\n                methName = makeSelect(makeUnquotedIdent(\"$this\"), CodegenUtil.quoteMethodNameIfProperty((Method)model, gen()));\n            } else {\n                methName = makeQuotedIdent(CodegenUtil.quoteMethodNameIfProperty((Method)model, gen()));\n            }\n            overloadBuilder.resultType((Method)model);\n        } else if (model instanceof Class) {\n            overloadBuilder.modifiers(transformOverloadCtorFlags((Class)model));\n            methName = makeUnquotedIdent(\"this\");\n        } else {\n            throw new RuntimeException();\n        }\n        \n        // TODO MPL\n        if (model instanceof Method) {\n            copyTypeParameters((Method)model, overloadBuilder);\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO This really belongs in the invocation builder\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCStatement> vars = ListBuffer.<JCStatement>lb();\n        \n        final String companionInstanceName = tempName(\"$impl$\");\n        if (model instanceof Class\n                && !Strategy.defaultParameterMethodStatic(model)) {\n            Class classModel = (Class)model;\n            vars.append(makeVar(companionInstanceName, \n                    makeJavaType(classModel.getType(), AbstractTransformer.COMPANION),\n                    make().NewClass(null, \n                            null,\n                            makeJavaType(classModel.getType(), AbstractTransformer.COMPANION),\n                            List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Parameter param2 : parameters) {\n            \n            if (param2 == currentParam) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                String methodName = CodegenUtil.getDefaultedParamMethodName(model, param2);\n                JCExpression defaultValueMethodName;\n                List<JCExpression> typeArguments = List.<JCExpression>nil();\n                if (Strategy.defaultParameterMethodOnSelf(model)\n                        || forImplementor) {\n                    defaultValueMethodName = gen().makeQuotedIdent(methodName);\n                } else if (Strategy.defaultParameterMethodStatic(model)){\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedQualIdentFromString(getFQDeclarationName(model)), methodName);\n                    if (model instanceof Class) {\n                        typeArguments = typeArguments((Class)model);\n                    } else if (model instanceof Method) {\n                        typeArguments = typeArguments((Method)model);\n                    }\n                } else {\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedIdent(companionInstanceName), methodName);\n                }\n                \n                String varName = tempName(\"$\"+param2.getName()+\"$\");\n                final ProducedType paramType;\n                if (param2 instanceof FunctionalParameter) {\n                    paramType = typeFact().getCallableType(param2.getType());\n                } else {\n                    paramType = param2.getType();\n                }\n                vars.append(makeVar(varName, \n                        makeJavaType(paramType), \n                        make().Apply(typeArguments, \n                                defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(makeUnquotedIdent(varName));\n            } else {\n                overloadBuilder.parameter(param2);\n                args.add(makeQuotedIdent(param2.getName()));\n            }\n        }\n        \n        // TODO Type args on method call\n        if (generateBody) {\n            JCExpression invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n               \n            if (isVoid(model)) {\n                vars.append(make().Exec(invocation));\n                invocation = make().LetExpr(vars.toList(), makeNull());\n                overloadBuilder.body(make().Exec(invocation));\n            } else {\n                invocation = make().LetExpr(vars.toList(), invocation);\n                overloadBuilder.body(make().Return(invocation));\n            }\n        } else {\n            overloadBuilder.noBody();\n        }\n        \n        return overloadBuilder;\n    }","id":41105,"modified_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags, MethodDefinitionBuilder overloadBuilder,\n            final Declaration model, java.util.List<Parameter> parameters,\n            final Parameter currentParam) {\n        overloadBuilder.annotations(makeAtIgnore());\n        \n        final JCExpression methName;\n        if (model instanceof Method) {\n            long mods = transformOverloadMethodDeclFlags((Method)model);\n            if ((flags & OL_BODY) != 0) {\n                mods &= ~ABSTRACT;\n            }\n            if ((flags & OL_IMPLEMENTOR) != 0 || (flags & OL_DELEGATOR) != 0) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            if ((flags & OL_DELEGATOR) != 0) {\n                methName = makeSelect(makeUnquotedIdent(\"$this\"), CodegenUtil.quoteMethodNameIfProperty((Method)model, gen()));\n            } else {\n                methName = makeQuotedIdent(CodegenUtil.quoteMethodNameIfProperty((Method)model, gen()));\n            }\n            overloadBuilder.resultType((Method)model);\n        } else if (model instanceof Class) {\n            overloadBuilder.modifiers(transformOverloadCtorFlags((Class)model));\n            methName = makeUnquotedIdent(\"this\");\n        } else {\n            throw new RuntimeException();\n        }\n        \n        // TODO MPL\n        if (model instanceof Method) {\n            copyTypeParameters((Method)model, overloadBuilder);\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO This really belongs in the invocation builder\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCStatement> vars = ListBuffer.<JCStatement>lb();\n        \n        final String companionInstanceName = tempName(\"$impl$\");\n        if (model instanceof Class\n                && !Strategy.defaultParameterMethodStatic(model)) {\n            Class classModel = (Class)model;\n            vars.append(makeVar(companionInstanceName, \n                    makeJavaType(classModel.getType(), AbstractTransformer.COMPANION),\n                    make().NewClass(null, \n                            null,\n                            makeJavaType(classModel.getType(), AbstractTransformer.COMPANION),\n                            List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Parameter param2 : parameters) {\n            \n            if (param2 == currentParam) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                String methodName = CodegenUtil.getDefaultedParamMethodName(model, param2);\n                JCExpression defaultValueMethodName;\n                List<JCExpression> typeArguments = List.<JCExpression>nil();\n                if (Strategy.defaultParameterMethodOnSelf(model)\n                        || (flags & OL_IMPLEMENTOR) != 0) {\n                    defaultValueMethodName = gen().makeQuotedIdent(methodName);\n                } else if (Strategy.defaultParameterMethodStatic(model)){\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedQualIdentFromString(getFQDeclarationName(model)), methodName);\n                    if (model instanceof Class) {\n                        typeArguments = typeArguments((Class)model);\n                    } else if (model instanceof Method) {\n                        typeArguments = typeArguments((Method)model);\n                    }\n                } else {\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedIdent(companionInstanceName), methodName);\n                }\n                \n                String varName = tempName(\"$\"+param2.getName()+\"$\");\n                final ProducedType paramType;\n                if (param2 instanceof FunctionalParameter) {\n                    paramType = typeFact().getCallableType(param2.getType());\n                } else {\n                    paramType = param2.getType();\n                }\n                vars.append(makeVar(varName, \n                        makeJavaType(paramType), \n                        make().Apply(typeArguments, \n                                defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(makeUnquotedIdent(varName));\n            } else {\n                overloadBuilder.parameter(param2);\n                args.add(makeQuotedIdent(param2.getName()));\n            }\n        }\n        \n        // TODO Type args on method call\n        if ((flags & OL_BODY) != 0) {\n            JCExpression invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n               \n            if (isVoid(model)) {\n                vars.append(make().Exec(invocation));\n                invocation = make().LetExpr(vars.toList(), makeNull());\n                overloadBuilder.body(make().Exec(invocation));\n            } else {\n                invocation = make().LetExpr(vars.toList(), invocation);\n                overloadBuilder.body(make().Return(invocation));\n            }\n        } else {\n            overloadBuilder.noBody();\n        }\n        \n        return overloadBuilder;\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        noteDecl(model);\n        final String className;\n        if (def instanceof Tree.AnyInterface) {\n            className = declName(model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null\n                        || param.getDeclarationModel().isSequenced()) {\n                    ClassDefinitionBuilder cbForDevaultValues;\n                    if (Strategy.defaultParameterMethodStatic(model)) {\n                        cbForDevaultValues = classBuilder;\n                    } else {\n                        cbForDevaultValues = classBuilder.getCompanionBuilder(model);\n                    }\n                    cbForDevaultValues.defs(makeParamDefaultValueMethod(false, def, paramList, param));\n                    // Add overloaded constructors for defaulted parameter\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    makeOverloadsForDefaultedParameter(true, false, false,\n                            overloadBuilder,\n                            model, paramList, param);\n                }\n            }\n            satisfaction((Class)model, classBuilder);\n            at(def);\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            //  Copy all the qualifying type's type parameters into the interface\n            ProducedType type = model.getType().getQualifyingType();\n            while (type != null) {\n                java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                if (typeArguments == null) {\n                    continue;\n                }\n                for (TypeParameter typeArgument : typeArguments) {\n                    classBuilder.typeParameter(typeArgument);\n                }\n                type = type.getQualifyingType();\n            }\n            // Build the companion class\n            buildCompanion(def, (Interface)model, classBuilder);   \n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","id":41106,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        noteDecl(model);\n        final String className;\n        if (def instanceof Tree.AnyInterface) {\n            className = declName(model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null\n                        || param.getDeclarationModel().isSequenced()) {\n                    ClassDefinitionBuilder cbForDevaultValues;\n                    if (Strategy.defaultParameterMethodStatic(model)) {\n                        cbForDevaultValues = classBuilder;\n                    } else {\n                        cbForDevaultValues = classBuilder.getCompanionBuilder(model);\n                    }\n                    cbForDevaultValues.defs(makeParamDefaultValueMethod(false, def.getDeclarationModel(), paramList, param));\n                    // Add overloaded constructors for defaulted parameter\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    makeOverloadsForDefaultedParameter(OL_BODY,\n                            overloadBuilder,\n                            model, paramList, param);\n                }\n            }\n            satisfaction((Class)model, classBuilder);\n            at(def);\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            //  Copy all the qualifying type's type parameters into the interface\n            ProducedType type = model.getType().getQualifyingType();\n            while (type != null) {\n                java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                if (typeArguments == null) {\n                    continue;\n                }\n                for (TypeParameter typeArgument : typeArguments) {\n                    classBuilder.typeParameter(typeArgument);\n                }\n                type = type.getQualifyingType();\n            }\n            // Build the companion class\n            buildCompanion(def, (Interface)model, classBuilder);   \n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","commit_id":"59f7f47bb02beb08dd0665d59ecf281f0a3898b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder(AbstractTransformer owner, TypedDeclaration attrType, String className, String attrName, String fieldName, boolean toplevel) {\n        int typeFlags = 0;\n        TypedDeclaration nonWideningTypeDeclaration = owner.nonWideningTypeDecl(attrType);\n        ProducedType nonWideningType = owner.nonWideningType(attrType, nonWideningTypeDeclaration);\n        if (!Util.isUnBoxed(nonWideningTypeDeclaration)) {\n            typeFlags |= AbstractTransformer.NO_PRIMITIVES;\n        }\n        // Special erasure for the \"hash\" attribute which gets translated to hashCode()\n        if (\"hash\".equals(attrName) && owner.isCeylonInteger(nonWideningType)) {\n            typeFlags = AbstractTransformer.SMALL_TYPE;\n        }\n        \n        this.ancestorLocal = Decl.isAncestorLocal(attrType);\n        this.attrType = owner.makeJavaType(nonWideningType, typeFlags);\n        this.attrTypeRaw = owner.makeJavaType(nonWideningType, AbstractTransformer.WANT_RAW_TYPE);\n        this.owner = owner;\n        this.className = className;\n        this.attrName = attrName;\n        this.fieldName = fieldName;\n        this.toplevel = toplevel;\n        \n        // Make sure we use the declaration for building the getter/setter names, as we might be trying to\n        // override a JavaBean property with an \"isFoo\" getter, or non-Ceylon casing, and we have to respect that.\n        getterBuilder = MethodDefinitionBuilder\n            .systemMethod(owner, ancestorLocal, Util.getGetterName(attrType))\n            .block(generateDefaultGetterBlock())\n            .isActual(attrType.isActual())\n            .annotations(owner.makeAtAnnotations(attrType.getAnnotations()))\n            .resultType(this.attrType, attrType);\n        setterBuilder = MethodDefinitionBuilder\n            .systemMethod(owner, ancestorLocal, Util.getSetterName(attrType))\n            .block(generateDefaultSetterBlock())\n            .isActual(attrType.isActual())\n            .parameter(0, attrName, attrType, nonWideningTypeDeclaration, nonWideningType);\n    }","id":41107,"modified_method":"private AttributeDefinitionBuilder(AbstractTransformer owner, TypedDeclaration attrType, String className, String attrName, String fieldName, boolean toplevel) {\n        int typeFlags = 0;\n        TypedDeclaration nonWideningTypeDeclaration = owner.nonWideningTypeDecl(attrType);\n        ProducedType nonWideningType = owner.nonWideningType(attrType, nonWideningTypeDeclaration);\n        if (!Util.isUnBoxed(nonWideningTypeDeclaration)) {\n            typeFlags |= AbstractTransformer.NO_PRIMITIVES;\n        }\n        // Special erasure for the \"hash\" attribute which gets translated to hashCode()\n        if (\"hash\".equals(attrName) && owner.isCeylonInteger(nonWideningType)) {\n            typeFlags = AbstractTransformer.SMALL_TYPE;\n        }\n        \n        this.ancestorLocal = Decl.isAncestorLocal(attrType);\n        this.attrType = owner.makeJavaType(nonWideningType, typeFlags);\n        this.attrTypeRaw = owner.makeJavaType(nonWideningType, AbstractTransformer.WANT_RAW_TYPE);\n        this.owner = owner;\n        this.className = className;\n        this.attrName = attrName;\n        this.fieldName = fieldName;\n        this.toplevel = toplevel;\n        \n        // Make sure we use the declaration for building the getter/setter names, as we might be trying to\n        // override a JavaBean property with an \"isFoo\" getter, or non-Ceylon casing, and we have to respect that.\n        getterBuilder = MethodDefinitionBuilder\n            .systemMethod(owner, ancestorLocal, Util.getGetterName(attrType))\n            .block(generateDefaultGetterBlock())\n            .isActual(attrType.isActual())\n            .annotations(owner.makeAtAnnotations(attrType.getAnnotations()))\n            .resultType(this.attrType, attrType);\n        setterBuilder = MethodDefinitionBuilder\n            .systemMethod(owner, ancestorLocal, Util.getSetterName(attrType))\n            .block(generateDefaultSetterBlock())\n            // only actual if the superclass is also variable\n            .isActual(attrType.isActual() && ((TypedDeclaration)attrType.getRefinedDeclaration()).isVariable())\n            .parameter(0, attrName, attrType, nonWideningTypeDeclaration, nonWideningType);\n    }","commit_id":"ce94934d916b7d7ceb73d3e9651736d60ee15e27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(AttributeGetterDefinition decl, boolean forCompanion) {\n        String name = decl.getIdentifier().getText();\n        \n        // TODO Support concrete getters on interfaces\n        final AttributeDefinitionBuilder builder = AttributeDefinitionBuilder\n            .getter(this, name, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion));\n        \n        if (Decl.withinClass(decl) || forCompanion) {\n            JCBlock body = statementGen().transform(decl.getBlock());\n            builder.getterBlock(body);\n            builder.isActual(Decl.isActual(decl));\n        } else {\n            builder.isFormal(true);\n        }\n        return builder.build();\n    }","id":41108,"modified_method":"public List<JCTree> transform(AttributeGetterDefinition decl, boolean forCompanion) {\n        String name = decl.getIdentifier().getText();\n        \n        // TODO Support concrete getters on interfaces\n        final AttributeDefinitionBuilder builder = AttributeDefinitionBuilder\n            .getter(this, name, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion));\n        \n        if (Decl.withinClass(decl) || forCompanion) {\n            JCBlock body = statementGen().transform(decl.getBlock());\n            builder.getterBlock(body);\n        } else {\n            builder.isFormal(true);\n        }\n        return builder.build();\n    }","commit_id":"ce94934d916b7d7ceb73d3e9651736d60ee15e27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                // TODO Concrete attributes \n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(makeErroneous()))));\n            } else {\n                String accessorName = isGetter ? \n                        Util.getGetterName(decl.getDeclarationModel()) :\n                        Util.getSetterName(decl.getDeclarationModel());\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null,// TODO Typeargs \n                                    makeSelect(\"$this\", accessorName), \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(makeQuotedIdent(decl.getIdentifier().getText()));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null,// TODO Typeargs \n                                    makeSelect(\"$this\", accessorName), \n                                    args)))));\n                }\n                \n            }\n        }\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isActual(Decl.isActual(decl) && !forCompanion)\n            .isFormal(Decl.isFormal(decl) && !forCompanion)\n            .build();\n    }","id":41109,"modified_method":"private List<JCTree> makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                // TODO Concrete attributes \n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(makeErroneous()))));\n            } else {\n                String accessorName = isGetter ? \n                        Util.getGetterName(decl.getDeclarationModel()) :\n                        Util.getSetterName(decl.getDeclarationModel());\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null,// TODO Typeargs \n                                    makeSelect(\"$this\", accessorName), \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(makeQuotedIdent(decl.getIdentifier().getText()));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null,// TODO Typeargs \n                                    makeSelect(\"$this\", accessorName), \n                                    args)))));\n                }\n                \n            }\n        }\n        if(forCompanion)\n            builder.notActual();\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isFormal(Decl.isFormal(decl) && !forCompanion)\n            .build();\n    }","commit_id":"ce94934d916b7d7ceb73d3e9651736d60ee15e27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> transformObject(Node def, Value model, \n            Class klass,\n            ClassDefinitionBuilder containingClassBuilder,\n            boolean makeInstanceIfLocal) {\n        noteDecl(model);\n        \n        String name = model.getName();\n        ClassDefinitionBuilder objectClassBuilder = ClassDefinitionBuilder.klass(this, Decl.isAncestorLocal(model), name);\n        \n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = objectClassBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        satisfaction(klass, objectClassBuilder);\n        \n        TypeDeclaration decl = model.getType().getDeclaration();\n\n        if (Decl.isToplevel(model)\n                && def instanceof Tree.ObjectDefinition) {\n            objectClassBuilder.body(makeObjectGlobal((Tree.ObjectDefinition)def, model.getQualifiedNameString()).toList());\n        }\n\n        List<JCTree> result = objectClassBuilder\n            .annotations(makeAtObject())\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformObjectDeclFlags(model))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init(childDefs)\n            .build();\n        \n        if (Decl.isLocal(model)\n                && makeInstanceIfLocal) {\n            result = result.append(makeLocalIdentityInstance(name, false));\n        } else if (Decl.withinClassOrInterface(model)) {\n            boolean visible = Decl.isCaptured(model);\n            int modifiers = FINAL | ((visible) ? PRIVATE : 0);\n            JCExpression type = makeJavaType(klass.getType());\n            JCExpression initialValue = makeNewClass(makeJavaType(klass.getType()), null);\n            containingClassBuilder.field(modifiers, name, type, initialValue, !visible);\n            \n            if (visible) {\n                result = result.appendList(AttributeDefinitionBuilder\n                    .getter(this, name, model)\n                    .modifiers(transformAttributeGetSetDeclFlags(model, false))\n                    .isActual(Decl.isActual(model))\n                    .build());\n            }\n        }\n        \n        return result;\n    }","id":41110,"modified_method":"private List<JCTree> transformObject(Node def, Value model, \n            Class klass,\n            ClassDefinitionBuilder containingClassBuilder,\n            boolean makeInstanceIfLocal) {\n        noteDecl(model);\n        \n        String name = model.getName();\n        ClassDefinitionBuilder objectClassBuilder = ClassDefinitionBuilder.klass(this, Decl.isAncestorLocal(model), name);\n        \n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = objectClassBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        satisfaction(klass, objectClassBuilder);\n        \n        TypeDeclaration decl = model.getType().getDeclaration();\n\n        if (Decl.isToplevel(model)\n                && def instanceof Tree.ObjectDefinition) {\n            objectClassBuilder.body(makeObjectGlobal((Tree.ObjectDefinition)def, model.getQualifiedNameString()).toList());\n        }\n\n        List<JCTree> result = objectClassBuilder\n            .annotations(makeAtObject())\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformObjectDeclFlags(model))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init(childDefs)\n            .build();\n        \n        if (Decl.isLocal(model)\n                && makeInstanceIfLocal) {\n            result = result.append(makeLocalIdentityInstance(name, false));\n        } else if (Decl.withinClassOrInterface(model)) {\n            boolean visible = Decl.isCaptured(model);\n            int modifiers = FINAL | ((visible) ? PRIVATE : 0);\n            JCExpression type = makeJavaType(klass.getType());\n            JCExpression initialValue = makeNewClass(makeJavaType(klass.getType()), null);\n            containingClassBuilder.field(modifiers, name, type, initialValue, !visible);\n            \n            if (visible) {\n                result = result.appendList(AttributeDefinitionBuilder\n                    .getter(this, name, model)\n                    .modifiers(transformAttributeGetSetDeclFlags(model, false))\n                    .build());\n            }\n        }\n        \n        return result;\n    }","commit_id":"ce94934d916b7d7ceb73d3e9651736d60ee15e27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(AttributeSetterDefinition decl) {\n        JCBlock body = statementGen().transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n                /* \n                 * We use the getter as TypedDeclaration here because this is the same type but has a refined\n                 * declaration we can use to make sure we're not widening the attribute type.\n                 */\n            .setter(this, name, decl.getDeclarationModel().getGetter())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), false))\n            .isActual(isActual(decl))\n            .setterBlock(body)\n            .build();\n    }","id":41111,"modified_method":"public List<JCTree> transform(AttributeSetterDefinition decl) {\n        JCBlock body = statementGen().transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n                /* \n                 * We use the getter as TypedDeclaration here because this is the same type but has a refined\n                 * declaration we can use to make sure we're not widening the attribute type.\n                 */\n            .setter(this, name, decl.getDeclarationModel().getGetter())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), false))\n            .setterBlock(body)\n            .build();\n    }","commit_id":"ce94934d916b7d7ceb73d3e9651736d60ee15e27","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private <D extends CallableDescriptor> void completeTypeInferenceDependentOnFunctionLiterals(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (context.call.getCallType() == Call.CallType.INVOKE) return;\n        if (!results.isSingleResult()) {\n            if (results.getResultCode() == INCOMPLETE_TYPE_INFERENCE) {\n                argumentTypeResolver.checkTypesWithNoCallee(context, RESOLVE_FUNCTION_ARGUMENTS);\n            }\n            return;\n        }\n\n        CallCandidateResolutionContext<D> candidateContext = CallCandidateResolutionContext.createForCallBeingAnalyzed(\n                results.getResultingCall().getCallToCompleteTypeArgumentInference(), context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnFunctionLiteralsForCall(candidateContext);\n    }","id":41112,"modified_method":"private <D extends CallableDescriptor> void completeTypeInferenceDependentOnFunctionLiterals(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (CallResolverUtil.isInvokeCallOnVariable(context.call)) return;\n        if (!results.isSingleResult()) {\n            if (results.getResultCode() == INCOMPLETE_TYPE_INFERENCE) {\n                argumentTypeResolver.checkTypesWithNoCallee(context, RESOLVE_FUNCTION_ARGUMENTS);\n            }\n            return;\n        }\n\n        CallCandidateResolutionContext<D> candidateContext = CallCandidateResolutionContext.createForCallBeingAnalyzed(\n                results.getResultingCall().getCallToCompleteTypeArgumentInference(), context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnFunctionLiteralsForCall(candidateContext);\n    }","commit_id":"c7087d170e80b8577ce67d1eafc19f8266551340","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> OverloadResolutionResultsImpl<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (context.call.getCallType() == Call.CallType.INVOKE) return results;\n\n        if (results.isSingleResult()) {\n            Set<ValueArgument> unmappedArguments = results.getResultingCall().getCallToCompleteTypeArgumentInference().getUnmappedArguments();\n            argumentTypeResolver.checkUnmappedArgumentTypes(context, unmappedArguments);\n            candidateResolver.completeUnmappedArguments(context, unmappedArguments);\n        }\n\n        if (!results.isSingleResult()) return results;\n\n        ResolvedCallWithTrace<D> resolvedCall = results.getResultingCall();\n        ResolvedCallImpl<D> callToCompleteInference = resolvedCall.getCallToCompleteTypeArgumentInference();\n\n        if (!callToCompleteInference.hasIncompleteTypeParameters()) {\n            CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                    CallCandidateResolutionContext.createForCallBeingAnalyzed(callToCompleteInference, context, tracing);\n            candidateResolver.completeNestedCallsInference(callCandidateResolutionContext);\n            candidateResolver.checkValueArgumentTypes(callCandidateResolutionContext);\n            return results;\n        }\n\n        CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                CallCandidateResolutionContext.createForCallBeingAnalyzed(callToCompleteInference, context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnExpectedTypeForCall(callCandidateResolutionContext, false);\n\n        if (callToCompleteInference.getStatus().isSuccess()) {\n            return OverloadResolutionResultsImpl.success(resolvedCall);\n        }\n        return OverloadResolutionResultsImpl.incompleteTypeInference(resolvedCall);\n    }","id":41113,"modified_method":"private <D extends CallableDescriptor> OverloadResolutionResultsImpl<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (CallResolverUtil.isInvokeCallOnVariable(context.call)) return results;\n\n        if (results.isSingleResult()) {\n            Set<ValueArgument> unmappedArguments = results.getResultingCall().getCallToCompleteTypeArgumentInference().getUnmappedArguments();\n            argumentTypeResolver.checkUnmappedArgumentTypes(context, unmappedArguments);\n            candidateResolver.completeUnmappedArguments(context, unmappedArguments);\n        }\n\n        if (!results.isSingleResult()) return results;\n\n        ResolvedCallWithTrace<D> resolvedCall = results.getResultingCall();\n        ResolvedCallImpl<D> callToCompleteInference = resolvedCall.getCallToCompleteTypeArgumentInference();\n\n        if (!callToCompleteInference.hasIncompleteTypeParameters()) {\n            CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                    CallCandidateResolutionContext.createForCallBeingAnalyzed(callToCompleteInference, context, tracing);\n            candidateResolver.completeNestedCallsInference(callCandidateResolutionContext);\n            candidateResolver.checkValueArgumentTypes(callCandidateResolutionContext);\n            return results;\n        }\n\n        CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                CallCandidateResolutionContext.createForCallBeingAnalyzed(callToCompleteInference, context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnExpectedTypeForCall(callCandidateResolutionContext, false);\n\n        if (callToCompleteInference.getStatus().isSuccess()) {\n            return OverloadResolutionResultsImpl.success(resolvedCall);\n        }\n        return OverloadResolutionResultsImpl.incompleteTypeInference(resolvedCall);\n    }","commit_id":"c7087d170e80b8577ce67d1eafc19f8266551340","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static CallKey createCallKey(@NotNull BasicCallResolutionContext context) {\n        if (context.call.getCallType() == Call.CallType.INVOKE) {\n            return null;\n        }\n        PsiElement callElement = context.call.getCallElement();\n        if (!(callElement instanceof JetExpression)) return null;\n        return CallKey.create(context.call.getCallType(), (JetExpression) callElement);\n    }","id":41114,"modified_method":"@Nullable\n    public static CallKey createCallKey(@NotNull BasicCallResolutionContext context) {\n        if (isInvokeCallOnVariable(context.call)) {\n            return null;\n        }\n        PsiElement callElement = context.call.getCallElement();\n        if (!(callElement instanceof JetExpression)) return null;\n        return CallKey.create(context.call.getCallType(), (JetExpression) callElement);\n    }","commit_id":"c7087d170e80b8577ce67d1eafc19f8266551340","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void completeNestedCallsForNotResolvedInvocation(@NotNull CallResolutionContext<?> context, @NotNull Collection<? extends ValueArgument> arguments) {\n        if (context.call.getCallType() == Call.CallType.INVOKE) return;\n        if (context.checkArguments == CheckValueArgumentsMode.DISABLED) return;\n\n        for (ValueArgument argument : arguments) {\n            JetExpression expression = argument.getArgumentExpression();\n\n            JetExpression keyExpression = getDeferredComputationKeyExpression(expression);\n            markResultingCallAsCompleted(context, keyExpression);\n\n            CallCandidateResolutionContext<?> storedContextForArgument =\n                    context.resolutionResultsCache.getDeferredComputation(keyExpression);\n            if (storedContextForArgument != null) {\n                completeNestedCallsForNotResolvedInvocation(storedContextForArgument);\n                CallCandidateResolutionContext<?> newContext = storedContextForArgument.replaceBindingTrace(context.trace);\n                completeUnmappedArguments(newContext, storedContextForArgument.candidateCall.getUnmappedArguments());\n                argumentTypeResolver.checkTypesForFunctionArgumentsWithNoCallee(newContext.replaceContextDependency(INDEPENDENT));\n            }\n        }\n    }","id":41115,"modified_method":"private void completeNestedCallsForNotResolvedInvocation(@NotNull CallResolutionContext<?> context, @NotNull Collection<? extends ValueArgument> arguments) {\n        if (CallResolverUtil.isInvokeCallOnVariable(context.call)) return;\n        if (context.checkArguments == CheckValueArgumentsMode.DISABLED) return;\n\n        for (ValueArgument argument : arguments) {\n            JetExpression expression = argument.getArgumentExpression();\n\n            JetExpression keyExpression = getDeferredComputationKeyExpression(expression);\n            markResultingCallAsCompleted(context, keyExpression);\n\n            CallCandidateResolutionContext<?> storedContextForArgument =\n                    context.resolutionResultsCache.getDeferredComputation(keyExpression);\n            if (storedContextForArgument != null) {\n                completeNestedCallsForNotResolvedInvocation(storedContextForArgument);\n                CallCandidateResolutionContext<?> newContext = storedContextForArgument.replaceBindingTrace(context.trace);\n                completeUnmappedArguments(newContext, storedContextForArgument.candidateCall.getUnmappedArguments());\n                argumentTypeResolver.checkTypesForFunctionArgumentsWithNoCallee(newContext.replaceContextDependency(INDEPENDENT));\n            }\n        }\n    }","commit_id":"c7087d170e80b8577ce67d1eafc19f8266551340","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public <D extends CallableDescriptor> void completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        if (context.call.getCallType() == Call.CallType.INVOKE) return;\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                completeInferenceForArgument(argument, parameterDescriptor, context);\n            }\n        }\n        completeUnmappedArguments(context, context.candidateCall.getUnmappedArguments());\n        recordReferenceForInvokeFunction(context);\n    }","id":41116,"modified_method":"public <D extends CallableDescriptor> void completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        if (CallResolverUtil.isInvokeCallOnVariable(context.call)) return;\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                completeInferenceForArgument(argument, parameterDescriptor, context);\n            }\n        }\n        completeUnmappedArguments(context, context.candidateCall.getUnmappedArguments());\n        recordReferenceForInvokeFunction(context);\n    }","commit_id":"c7087d170e80b8577ce67d1eafc19f8266551340","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testAddDLFolder() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add Folder\"),\n\t\t\tselenium.getText(\"//div[2]/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[2]/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Add Folder\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_20_name']\",\n\t\t\tRuntimeVariables.replace(\"DL Folder Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Name\"),\n\t\t\tselenium.getText(\"//a[2]/strong\"));\n\t}","id":41117,"modified_method":"public void testAddDLFolder() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//span[@title='Add']/ul\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Folder\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\",\n\t\t\tRuntimeVariables.replace(\"Folder\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_20_name']\",\n\t\t\tRuntimeVariables.replace(\"DM Folder Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Name\"),\n\t\t\tselenium.getText(\"//span[@class='document-title']\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddDLFolder() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add Folder\"),\n\t\t\tselenium.getText(\"//div[2]/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[2]/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Add Folder\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_20_name']\",\n\t\t\tRuntimeVariables.replace(\"DL Folder Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Name\"),\n\t\t\tselenium.getText(\"//a[2]/strong\"));\n\t}","id":41118,"modified_method":"public void testAddDLFolder() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//span[@title='Add']/ul\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Folder\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\",\n\t\t\tRuntimeVariables.replace(\"Folder\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_20_name']\",\n\t\t\tRuntimeVariables.replace(\"DM Folder Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Name\"),\n\t\t\tselenium.getText(\"//span[@class='document-title']\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddNewDLFolderDocumentAPActions() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Document Library Document\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Select']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Select\"));\n\t\t\t\tselenium.waitForPopUp(\"folder\",\n\t\t\t\t\tRuntimeVariables.replace(\"30000\"));\n\t\t\t\tselenium.selectWindow(\"name=folder\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean choose1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (choose1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean choose2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (!choose2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Choose']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(\"//input[@value='Choose']\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DL Folder Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@id='_20_folderName']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Name\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_20_folderName']\"));\n\t\t\t\tselenium.type(\"//input[@id='_20_file']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"L:\\\\portal\\\\build\\\\portal-web\\\\test\\\\com\\\\liferay\\\\portalweb\\\\portlet\\\\assetpublisher\\\\dependencies\\\\DLDocument.txt\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='_20_title']\",\n\t\t\t\t\tRuntimeVariables.replace(\"DL Folder Document Title\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DL Folder Document Title\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//h3[@class='asset-title']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DL Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DL Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='asset-resource-info']/span/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41119,"modified_method":"public void testAddNewDLFolderDocumentAPActions() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Document Library Document\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Document Library Document\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Select']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Select']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Select\"));\n\t\t\t\tselenium.waitForPopUp(\"folder\",\n\t\t\t\t\tRuntimeVariables.replace(\"30000\"));\n\t\t\t\tselenium.selectWindow(\"name=folder\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean choose1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (choose1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean choose2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (!choose2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Choose']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(\"//input[@value='Choose']\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DM Folder Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@id='_20_folderName']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Name\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_20_folderName']\"));\n\t\t\t\tselenium.type(\"//input[@id='_20_file']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"L:\\\\portal\\\\build\\\\portal-web\\\\test\\\\com\\\\liferay\\\\portalweb\\\\portlet\\\\assetpublisher\\\\dependencies\\\\DLDocument.txt\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='_20_title']\",\n\t\t\t\t\tRuntimeVariables.replace(\"DM Folder Document Title\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DM Folder Document Title\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//h3[@class='asset-title']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DM Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DM Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='asset-resource-info']/span/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddNewDLFolderDocumentAPActions() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Document Library Document\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Select']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Select\"));\n\t\t\t\tselenium.waitForPopUp(\"folder\",\n\t\t\t\t\tRuntimeVariables.replace(\"30000\"));\n\t\t\t\tselenium.selectWindow(\"name=folder\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean choose1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (choose1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean choose2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (!choose2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Choose']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(\"//input[@value='Choose']\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DL Folder Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@id='_20_folderName']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Name\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_20_folderName']\"));\n\t\t\t\tselenium.type(\"//input[@id='_20_file']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"L:\\\\portal\\\\build\\\\portal-web\\\\test\\\\com\\\\liferay\\\\portalweb\\\\portlet\\\\assetpublisher\\\\dependencies\\\\DLDocument.txt\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='_20_title']\",\n\t\t\t\t\tRuntimeVariables.replace(\"DL Folder Document Title\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DL Folder Document Title\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//h3[@class='asset-title']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DL Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DL Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='asset-resource-info']/span/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41120,"modified_method":"public void testAddNewDLFolderDocumentAPActions() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Document Library Document\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[4]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Document Library Document\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Select']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Select']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Select\"));\n\t\t\t\tselenium.waitForPopUp(\"folder\",\n\t\t\t\t\tRuntimeVariables.replace(\"30000\"));\n\t\t\t\tselenium.selectWindow(\"name=folder\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean choose1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (choose1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean choose2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[4]/input\");\n\n\t\t\t\tif (!choose2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@value='Choose']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(\"//input[@value='Choose']\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DM Folder Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@id='_20_folderName']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Name\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_20_folderName']\"));\n\t\t\t\tselenium.type(\"//input[@id='_20_file']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"L:\\\\portal\\\\build\\\\portal-web\\\\test\\\\com\\\\liferay\\\\portalweb\\\\portlet\\\\assetpublisher\\\\dependencies\\\\DLDocument.txt\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='_20_title']\",\n\t\t\t\t\tRuntimeVariables.replace(\"DM Folder Document Title\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"DM Folder Document Title\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//h3[@class='asset-title']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DM Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"DM Folder Document Title\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='asset-resource-info']/span/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPageDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"//nav[@id='navigation']\",\n\t\t\tRuntimeVariables.replace(\"Navigation\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//a[@id='addPage']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//a[@id='addPage']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@type='text']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@type='text']\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//button[@id='save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":41121,"modified_method":"public void testAddPageDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"//nav[@id='navigation']\",\n\t\t\tRuntimeVariables.replace(\"Navigation\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//a[@id='addPage']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//a[@id='addPage']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@type='text']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@type='text']\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//button[@id='save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPageDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"//nav[@id='navigation']\",\n\t\t\tRuntimeVariables.replace(\"Navigation\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//a[@id='addPage']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//a[@id='addPage']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@type='text']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@type='text']\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//button[@id='save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":41122,"modified_method":"public void testAddPageDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\t\tselenium.clickAt(\"//nav[@id='navigation']\",\n\t\t\tRuntimeVariables.replace(\"Navigation\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//a[@id='addPage']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//a[@id='addPage']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@type='text']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@type='text']\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//button[@id='save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":41123,"modified_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":41124,"modified_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Document Library']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Document Library']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":41125,"modified_method":"public void testAddPortletDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Documents and Media']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Documents and Media']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Document Library Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Document Library']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Document Library']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":41126,"modified_method":"public void testAddPortletDL() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Documents and Media Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Documents and Media']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Documents and Media']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testBeTheFirstDLFolderDocumentCommentAP()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"DL Folder Document Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\48\"));\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\8\"));\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"DL Folder Document Comment Body...\"),\n\t\t\tselenium.getText(\"//h1[@class='header-title']/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//td[2]/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//div[@class='user-details']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","id":41127,"modified_method":"public void testBeTheFirstDLFolderDocumentCommentAP()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"DM Folder Document Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"xpath=(//span[@class='user-name'])[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"DM Folder Document Comment Body...\"),\n\t\t\tselenium.getText(\"xpath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//td[2]/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"xpath=(//span[@class='user-name'])[2]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Title\"),\n\t\t\tselenium.getText(\"xpath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testBeTheFirstDLFolderDocumentCommentAP()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"DL Folder Document Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\48\"));\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\8\"));\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"DL Folder Document Comment Body...\"),\n\t\t\tselenium.getText(\"//h1[@class='header-title']/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//td[2]/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//div[@class='user-details']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DL Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","id":41128,"modified_method":"public void testBeTheFirstDLFolderDocumentCommentAP()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"DM Folder Document Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"xpath=(//span[@class='user-name'])[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"DM Folder Document Comment Body...\"),\n\t\t\tselenium.getText(\"xpath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//td[2]/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"xpath=(//span[@class='user-name'])[2]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Title\"),\n\t\t\tselenium.getText(\"xpath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"DM Folder Document Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddPageAPTest.class);\n\t\ttestSuite.addTestSuite(AddPortletAPTest.class);\n\t\ttestSuite.addTestSuite(AddPageDLTest.class);\n\t\ttestSuite.addTestSuite(AddPortletDLTest.class);\n\t\ttestSuite.addTestSuite(AddDLFolderTest.class);\n\t\ttestSuite.addTestSuite(AddNewDLFolderDocumentAPActionsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletDisplayStyleFullContentTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEnableCommentsTest.class);\n\t\ttestSuite.addTestSuite(BeTheFirstDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLFolderTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLDocumentTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","id":41129,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddPageAPTest.class);\n\t\ttestSuite.addTestSuite(AddPortletAPTest.class);\n\t\ttestSuite.addTestSuite(AddPageDLTest.class);\n\t\ttestSuite.addTestSuite(AddPortletDLTest.class);\n\t\ttestSuite.addTestSuite(AddDLFolderTest.class);\n\t\ttestSuite.addTestSuite(AddNewDLFolderDocumentAPActionsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletDisplayStyleFullContentTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEnableCommentsTest.class);\n\t\ttestSuite.addTestSuite(BeTheFirstDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLDocumentTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","id":41130,"modified_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","id":41131,"modified_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableCommentRatings()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentRatingsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comment Ratings\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":41132,"modified_method":"public void testConfigurePortletEnableCommentRatings()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentRatingsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comment Ratings\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":41133,"modified_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":41134,"modified_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testRateDLFolderDocumentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isPartialText(\n\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\",\n\t\t\t\t\t\t\t\"0 Votes\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\"//div[@class='aui-rating-label-element']\", \"0 Votes\"));\n\t\tselenium.clickAt(\"//div[3]/div/div[1]/div/div/div/div/a[1]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as good.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//div[3]/div/div[1]/div/div/div/div/a[2]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//div[3]/div/div[1]/div/div/div/div/a[2]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t}","id":41135,"modified_method":"public void testRateDLFolderDocumentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isPartialText(\n\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\",\n\t\t\t\t\t\t\t\"0 Votes\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\"//div[@class='aui-rating-label-element']\", \"0 Votes\"));\n\t\tselenium.clickAt(\"//a[@title=' Rate this as good. ']\",\n\t\t\tRuntimeVariables.replace(\"Rate this as good.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//a[@title=' Rate this as bad. ']\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//a[@title=' Rate this as bad. ']\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddPageAPTest.class);\n\t\ttestSuite.addTestSuite(AddPortletAPTest.class);\n\t\ttestSuite.addTestSuite(AddPageDLTest.class);\n\t\ttestSuite.addTestSuite(AddPortletDLTest.class);\n\t\ttestSuite.addTestSuite(AddDLFolderTest.class);\n\t\ttestSuite.addTestSuite(AddNewDLFolderDocumentAPActionsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletDisplayStyleFullContentTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEnableCommentsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletEnableCommentRatingsTest.class);\n\t\ttestSuite.addTestSuite(BeTheFirstDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(RateDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLFolderTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLDocumentTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","id":41136,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddPageAPTest.class);\n\t\ttestSuite.addTestSuite(AddPortletAPTest.class);\n\t\ttestSuite.addTestSuite(AddPageDLTest.class);\n\t\ttestSuite.addTestSuite(AddPortletDLTest.class);\n\t\ttestSuite.addTestSuite(AddDLFolderTest.class);\n\t\ttestSuite.addTestSuite(AddNewDLFolderDocumentAPActionsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletDisplayStyleFullContentTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEnableCommentsTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tConfigurePortletEnableCommentRatingsTest.class);\n\t\ttestSuite.addTestSuite(BeTheFirstDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(RateDLFolderDocumentCommentAPTest.class);\n\t\ttestSuite.addTestSuite(TearDownDLDocumentTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownDLDocument() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"link=Document Library Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean document1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean document2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean document3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean document4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean document5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41137,"modified_method":"public void testTearDownDLDocument() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"link=Documents and Media Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//button[@title='Icon View']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Icon View\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//a[@data-navigation='documents-home']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean dmDocumentPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[@class='document-title']\");\n\n\t\t\t\tif (!dmDocumentPresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_20_allRowIdsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='_20_allRowIdsCheckbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Row IDs Checked\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_20_allRowIdsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//span[@title='Actions']/ul/li/strong/a/span\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Actions']/ul/li/strong/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected entries[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"There are no documents in this folder.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-info']\"));\n\n\t\t\tcase 2:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownDLDocument() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"link=Document Library Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Document Library Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Document Library Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean document1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean document2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean document3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean document4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean document5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!document5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41138,"modified_method":"public void testTearDownDLDocument() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"link=Documents and Media Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Documents and Media Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Documents and Media Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//button[@title='Icon View']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Icon View\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//a[@data-navigation='documents-home']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean dmDocumentPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[@class='document-title']\");\n\n\t\t\t\tif (!dmDocumentPresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_20_allRowIdsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='_20_allRowIdsCheckbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Row IDs Checked\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_20_allRowIdsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//span[@title='Actions']/ul/li/strong/a/span\"));\n\t\t\t\tselenium.clickAt(\"//span[@title='Actions']/ul/li/strong/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected entries[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"There are no documents in this folder.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-info']\"));\n\n\t\t\tcase 2:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownPage() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tString guestCommunity = selenium.getText(\n\t\t\t\t\t\t\"//nav[@class='site-breadcrumbs']/ul/li[1]/span/a\");\n\t\t\t\tRuntimeVariables.setValue(\"guestCommunity\", guestCommunity);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//div/div[3]/div/ul/li[1]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div/div[3]/div/ul/li[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"${guestCommunity}\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[2]/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41139,"modified_method":"public void testTearDownPage() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"//div[4]/div/ul/li[1]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[4]/div/ul/li[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Public Pages\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownPage() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tString guestCommunity = selenium.getText(\n\t\t\t\t\t\t\"//nav[@class='site-breadcrumbs']/ul/li[1]/span/a\");\n\t\t\t\tRuntimeVariables.setValue(\"guestCommunity\", guestCommunity);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//div/div[3]/div/ul/li[1]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div/div[3]/div/ul/li[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"${guestCommunity}\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[2]/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//li[2]/div/div[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//td[2]/ul/li[1]/span/span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":41140,"modified_method":"public void testTearDownPage() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"//div[4]/div/ul/li[1]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[4]/div/ul/li[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Public Pages\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"23eb5863c1c200898c5b913f192482d72b85bd9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Inject\n\tprotected void setServiceScope(IServiceScope scope) {\n\t\tthis.preferenceStoreAccessor = new PreferenceStoreAccessor(scope);\n\t\t// XXX LITTLE HACK, adding PrefPage on the fly\n\t\tString languageTag = PreferenceStoreAccessor.languageTag(scope);\n\t\tString preferencePagePathSeparator = \"/\";\n\t\tString parentPreferencePagePath = languageTag + preferencePagePathSeparator + languageTag\n\t\t\t\t+ CommonPreferenceConstants.SEPARATOR + CommonPreferenceConstants.EDITOR_NODE_NAME;\n\t\tString preferencePagePath = parentPreferencePagePath + preferencePagePathSeparator\n\t\t\t\t+ PreferenceStoreAccessor.syntaxColorerTag(scope);\n\t\tif (PlatformUI.getWorkbench().getPreferenceManager().find(preferencePagePath) == null) {\n\t\t\tSyntaxColoringPreferencePage preferencePage = new SyntaxColoringPreferencePage();\n\t\t\tpreferencePage.setTitle(\"Syntax Colorer\");\n\t\t\tServiceRegistry.injectServices(scope, preferencePage);\n\t\t\tPlatformUI.getWorkbench().getPreferenceManager().addTo(parentPreferencePagePath,\n\t\t\t\t\tnew PreferenceNode(preferencePage.qualifiedName(), preferencePage));\n\t\t}\n\t\t// TODO redraw/revalidate editor's StyledText control\n\t}","id":41141,"modified_method":"@Inject\n\tprotected void setServiceScope(final IServiceScope scope) {\n\t\tthis.preferenceStoreAccessor = new PreferenceStoreAccessor(scope);\n\t\t// XXX LITTLE HACK, adding PrefPage on the fly\n\t\tString languageTag = PreferenceStoreAccessor.languageTag(scope);\n\t\tString preferencePagePathSeparator = \"/\";\n\t\tString parentPreferencePagePath = languageTag + preferencePagePathSeparator + languageTag\n\t\t\t\t+ CommonPreferenceConstants.SEPARATOR + CommonPreferenceConstants.EDITOR_NODE_NAME;\n\t\tString syntaxColorerPrefPageTag = PreferenceStoreAccessor.syntaxColorerTag(scope);\n\t\tString preferencePagePath = parentPreferencePagePath + preferencePagePathSeparator + syntaxColorerPrefPageTag;\n\t\tif (PlatformUI.getWorkbench().getPreferenceManager().find(preferencePagePath) == null) {\n\t\t\tPreferenceNode node = new PreferenceNode(syntaxColorerPrefPageTag, \"Syntax Colorer\", null, null) {\n\t\t\t\t@Override\n\t\t\t\tpublic void createPage() {\n\t\t\t\t\tSyntaxColoringPreferencePage page = new SyntaxColoringPreferencePage();\n\t\t\t\t\tpage.setTitle(getLabelText());\n\t\t\t\t\tServiceRegistry.injectServices(scope, page);\n\t\t\t\t\tsetPage(page);\n\t\t\t\t}\n\t\t\t};\n\t\t\tPlatformUI.getWorkbench().getPreferenceManager().addTo(parentPreferencePagePath, node);\n\t\t}\n\t\t// TODO redraw/revalidate editor's StyledText control\n\t}","commit_id":"55a26ffa13db3a458709d77ec49a63fcddd044a2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String findDisplayNameFromLocalAccountPerson(ILocalAccountPerson person) {\n        Object name = person.getAttributeValue(ILocalAccountPerson.ATTR_DISPLAY_NAME);\n        if ((name instanceof String) && !StringUtils.isEmpty((String) name)) {\n            return (String)name;\n        }\n\n        // if display name is not set, just return username.\n        return person.getName();\n    }","id":41142,"modified_method":"/**\n     * Determine the name to use in the password reset email that identifies the\n     * users whose password has been reset.\n     *\n     * @param person the account that has had its password reset\n     * @return the account holders name\n     */\n    protected String findDisplayNameFromLocalAccountPerson(ILocalAccountPerson person) {\n        Object name = person.getAttributeValue(ILocalAccountPerson.ATTR_DISPLAY_NAME);\n        if ((name instanceof String) && !StringUtils.isEmpty((String) name)) {\n            return (String)name;\n        }\n\n        // if display name is not set, just return username.\n        return person.getName();\n    }","commit_id":"bded682f58c92b29a79b65868476cf09e904aa7b","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void sendNotification(URL resetUrl, ILocalAccountPerson account, Locale locale) {\n        log.debug(\"Sending password reset instructions to user with url \" + resetUrl.toString());\n\n        List<String> recipients = getRecipientAddresses(account);\n        String subject = formatSubject(account, locale);\n        String body = formatBody(resetUrl, account, locale);\n\n        try {\n            MimeMessage message = mailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message, true);\n            for (String recipient : recipients) {\n                helper.addTo(recipient);\n            }\n\n            helper.setText(body, true);\n            helper.setSubject(subject);\n            helper.setFrom(portalEmailAddress, messageSource.getMessage(\"portal.name\", new Object[]{}, locale));\n\n            log.debug(\"Sending message to \" + recipients + \" from \" +\n                    Arrays.toString(message.getFrom()) +  \" subject \" + message.getSubject());\n            this.mailSender.send(helper.getMimeMessage());\n\n        } catch(MailException | MessagingException | UnsupportedEncodingException e) {\n            log.error(\"Unable to send password reset email \", e);\n        }\n    }","id":41143,"modified_method":"@Override\n    public void sendNotification(URL resetUrl, ILocalAccountPerson account, Locale locale) {\n        log.debug(\"Sending password reset instructions to user with url {}\", resetUrl.toString());\n\n        try {\n            MimeMessage message = mailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message, true);\n            String email = (String)account.getAttributeValue(ILocalAccountPerson.ATTR_MAIL);\n            String subject = messageSource.getMessage(subjectMessageKey, new Object[]{}, locale);\n            String body = formatBody(resetUrl, account, locale);\n\n            helper.addTo(email);\n            helper.setText(body, true);\n            helper.setSubject(subject);\n            helper.setFrom(portalEmailAddress, messageSource.getMessage(\"portal.name\", new Object[]{}, locale));\n\n            log.debug(\"Sending message to {} from {} subject {}\", email,\n                    Arrays.toString(message.getFrom()), message.getSubject());\n            this.mailSender.send(helper.getMimeMessage());\n\n        } catch(Exception e) {\n            log.error(\"Unable to send password reset email\", e);\n        }\n    }","commit_id":"bded682f58c92b29a79b65868476cf09e904aa7b","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected String formatBody(URL resetUrl, ILocalAccountPerson account, Locale locale) {\n        final STGroup group = new STGroupDir(templateDir, '$', '$');\n        final ST template = group.getInstanceOf(templateName);\n\n        String name = findDisplayNameFromLocalAccountPerson(account);\n        template.add(\"displayName\", name);\n        template.add(\"url\", resetUrl.toString());\n\n        return template.render();\n    }","id":41144,"modified_method":"/**\n     * Get the body content of the email.\n     *\n     * @param resetUrl the password reset URL\n     * @param account the user account that has had its password reset\n     * @param locale the locale of the user who reset the password\n     * @return The message body as a string.\n     */\n    private String formatBody(URL resetUrl, ILocalAccountPerson account, Locale locale) {\n        final STGroup group = new STGroupDir(templateDir, '$', '$');\n        final ST template = group.getInstanceOf(templateName);\n\n        String name = findDisplayNameFromLocalAccountPerson(account);\n        template.add(\"displayName\", name);\n        template.add(\"url\", resetUrl.toString());\n\n        return template.render();\n    }","commit_id":"bded682f58c92b29a79b65868476cf09e904aa7b","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Set the subject string.  Note that this is the i18n key, not a raw\n     * text string.  eg. reset.your.password\n     *\n     * @param i18nSubject\n     */\n    public void setI18nSubject(String i18nSubject) {\n        this.i18nSubject = i18nSubject;\n    }","id":41145,"modified_method":"/**\n     * Set the subject string.  Note that this is the i18n key, not a raw\n     * text string.  eg. reset.your.password\n     *\n     * @param subjectMessageKey the message key to use as a subject line.  Defaults to \"reset.your.password\"\n     */\n    public void setSubjectMessageKey(final String subjectMessageKey) {\n        this.subjectMessageKey = subjectMessageKey;\n    }","commit_id":"bded682f58c92b29a79b65868476cf09e904aa7b","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Test\n    public void testNotification() throws Exception {\n        final String fromAddress = \"portal@test.com\";\n        final String toAddress = \"to@test.com\";\n        final String subject = \"i18nSubject\";\n        final String resetUrl = \"http://localhost/testing\";\n        final String displayName = \"displayName\";\n\n        ILocalAccountPerson person = mock(ILocalAccountPerson.class);\n        when(person.getAttributeValue(eq(ILocalAccountPerson.ATTR_DISPLAY_NAME))).thenReturn(displayName);\n        when(person.getAttributeValue(eq(ILocalAccountPerson.ATTR_MAIL))).thenReturn(toAddress);\n\n        MimeMessage mockedMimeMessage = mock(MimeMessage.class);\n        when(mailSender.createMimeMessage()).thenReturn(mockedMimeMessage);\n\n        URL url = new URL(resetUrl);\n\n        service.setI18nSubject(subject);\n        service.setPortalEmailAddress(fromAddress);\n        service.sendNotification(url, person, Locale.getDefault());\n\n        // verify send request was made...\n        verify(mailSender).send(mimeMessageCaptor.capture());\n\n        // verify basic email contents...\n        ArgumentCaptor<InternetAddress> fromCaptor = ArgumentCaptor.forClass(InternetAddress.class);\n        ArgumentCaptor<InternetAddress> toCaptor = ArgumentCaptor.forClass(InternetAddress.class);\n        ArgumentCaptor<Multipart> bodyCaptor = ArgumentCaptor.forClass(Multipart.class);\n\n        verify(mockedMimeMessage).setFrom(fromCaptor.capture());\n        verify(mockedMimeMessage).addRecipient(eq(RecipientType.TO), toCaptor.capture());\n        verify(mockedMimeMessage).setSubject(eq(subject));\n        verify(mockedMimeMessage).setContent(bodyCaptor.capture());\n\n        assertThat(fromCaptor.getValue().getAddress(), equalTo(fromAddress));\n        assertThat(toCaptor.getValue().getAddress(), equalTo(toAddress));\n        assertThat(getBodyHtml(bodyCaptor.getValue()), containsString(resetUrl));\n    }","id":41146,"modified_method":"@Test\n    public void testNotification() throws Exception {\n        final String fromAddress = \"portal@test.com\";\n        final String toAddress = \"to@test.com\";\n        final String subject = \"i18nSubject\";\n        final String resetUrl = \"http://localhost/testing\";\n        final String displayName = \"displayName\";\n\n        ILocalAccountPerson person = mock(ILocalAccountPerson.class);\n        when(person.getAttributeValue(eq(ILocalAccountPerson.ATTR_DISPLAY_NAME))).thenReturn(displayName);\n        when(person.getAttributeValue(eq(ILocalAccountPerson.ATTR_MAIL))).thenReturn(toAddress);\n\n        MimeMessage mockedMimeMessage = mock(MimeMessage.class);\n        when(mailSender.createMimeMessage()).thenReturn(mockedMimeMessage);\n\n        URL url = new URL(resetUrl);\n\n        service.setSubjectMessageKey(subject);\n        service.setPortalEmailAddress(fromAddress);\n        service.sendNotification(url, person, Locale.getDefault());\n\n        // verify send request was made...\n        verify(mailSender).send(mimeMessageCaptor.capture());\n\n        // verify basic email contents...\n        ArgumentCaptor<InternetAddress> fromCaptor = ArgumentCaptor.forClass(InternetAddress.class);\n        ArgumentCaptor<InternetAddress> toCaptor = ArgumentCaptor.forClass(InternetAddress.class);\n        ArgumentCaptor<Multipart> bodyCaptor = ArgumentCaptor.forClass(Multipart.class);\n\n        verify(mockedMimeMessage).setFrom(fromCaptor.capture());\n        verify(mockedMimeMessage).addRecipient(eq(RecipientType.TO), toCaptor.capture());\n        verify(mockedMimeMessage).setSubject(eq(subject));\n        verify(mockedMimeMessage).setContent(bodyCaptor.capture());\n\n        assertThat(fromCaptor.getValue().getAddress(), equalTo(fromAddress));\n        assertThat(toCaptor.getValue().getAddress(), equalTo(toAddress));\n        assertThat(getBodyHtml(bodyCaptor.getValue()), containsString(resetUrl));\n    }","commit_id":"bded682f58c92b29a79b65868476cf09e904aa7b","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Inject\n\tprotected void setServiceScope(IServiceScope scope) {\n\t\tthis.preferenceStoreAccessor = new PreferenceStoreAccessor(scope);\n\t\t// XXX LITTLE HACK, adding PrefPage on the fly\n\t\tString languageTag = PreferenceStoreAccessor.languageTag(scope);\n\t\tString preferencePagePathSeparator = \"/\";\n\t\tString parentPreferencePagePath = languageTag + preferencePagePathSeparator + languageTag\n\t\t\t\t+ CommonPreferenceConstants.SEPARATOR + CommonPreferenceConstants.EDITOR_NODE_NAME;\n\t\tString preferencePagePath = parentPreferencePagePath + preferencePagePathSeparator\n\t\t\t\t+ PreferenceStoreAccessor.syntaxColorerTag(scope);\n\t\tif (PlatformUI.getWorkbench().getPreferenceManager().find(preferencePagePath) == null) {\n\t\t\tSyntaxColoringPreferencePage preferencePage = new SyntaxColoringPreferencePage();\n\t\t\tpreferencePage.setTitle(\"Syntax Colorer\");\n\t\t\tServiceRegistry.injectServices(scope, preferencePage);\n\t\t\tPlatformUI.getWorkbench().getPreferenceManager().addTo(parentPreferencePagePath,\n\t\t\t\t\tnew PreferenceNode(preferencePage.qualifiedName(), preferencePage));\n\t\t}\n\t\t// TODO redraw/revalidate editor's StyledText control\n\t}","id":41147,"modified_method":"@Inject\n\tprotected void setServiceScope(final IServiceScope scope) {\n\t\tthis.preferenceStoreAccessor = new PreferenceStoreAccessor(scope);\n\t\t// XXX LITTLE HACK, adding PrefPage on the fly\n\t\tString languageTag = PreferenceStoreAccessor.languageTag(scope);\n\t\tString preferencePagePathSeparator = \"/\";\n\t\tString parentPreferencePagePath = languageTag + preferencePagePathSeparator + languageTag\n\t\t\t\t+ CommonPreferenceConstants.SEPARATOR + CommonPreferenceConstants.EDITOR_NODE_NAME;\n\t\tString syntaxColorerPrefPageTag = PreferenceStoreAccessor.syntaxColorerTag(scope);\n\t\tString preferencePagePath = parentPreferencePagePath + preferencePagePathSeparator + syntaxColorerPrefPageTag;\n\t\tif (PlatformUI.getWorkbench().getPreferenceManager().find(preferencePagePath) == null) {\n\t\t\tPreferenceNode node = new PreferenceNode(syntaxColorerPrefPageTag, \"Syntax Colorer\", null, null) {\n\t\t\t\t@Override\n\t\t\t\tpublic void createPage() {\n\t\t\t\t\tSyntaxColoringPreferencePage page = new SyntaxColoringPreferencePage();\n\t\t\t\t\tpage.setTitle(getLabelText());\n\t\t\t\t\tServiceRegistry.injectServices(scope, page);\n\t\t\t\t\tsetPage(page);\n\t\t\t\t}\n\t\t\t};\n\t\t\tPlatformUI.getWorkbench().getPreferenceManager().addTo(parentPreferencePagePath, node);\n\t\t}\n\t\t// TODO redraw/revalidate editor's StyledText control\n\t}","commit_id":"87f7f200d7f1980befb5371ad0d41642eade5298","url":"https://github.com/eclipse/xtext"},{"original_method":"@NotNull\n  private static Balloon createNewBalloon(@Nullable JComponent windowComponent,\n                                          @NotNull Notification notification,\n                                          boolean showCallout,\n                                          boolean hideOnClickOutside,\n                                          @NotNull Ref<Object> layoutDataRef,\n                                          @NotNull Disposable parentDisposable) {\n    final BalloonLayoutData layoutData = layoutDataRef.isNull() ? new BalloonLayoutData() : (BalloonLayoutData)layoutDataRef.get();\n    if (layoutData.groupId == null) {\n      if (NotificationsConfigurationImpl.getSettings(notification.getGroupId()).isShouldLog()) {\n        layoutData.groupId = notification.getGroupId();\n        layoutData.id = notification.id;\n      }\n    }\n    else {\n      layoutData.groupId = null;\n    }\n    layoutDataRef.set(layoutData);\n\n    if (layoutData.fillColor == null) {\n      layoutData.fillColor = FILL_COLOR;\n    }\n    if (layoutData.borderColor == null) {\n      layoutData.borderColor = BORDER_COLOR;\n    }\n\n    boolean actions = !notification.getActions().isEmpty();\n    boolean showFullContent = layoutData.showFullContent || notification instanceof NotificationActionProvider;\n\n    Color foregroundR = Gray._0;\n    Color foregroundD = Gray._191;\n    final Color foreground = new JBColor(foregroundR, foregroundD);\n\n    final JEditorPane text = new JEditorPane() {\n      @Override\n      protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        if (layoutData.showMinSize) {\n          Point location = getCollapsedTextEndLocation(this, layoutData);\n          if (location != null) {\n            g.setColor(getForeground());\n            g.drawString(\"...\", location.x, location.y + g.getFontMetrics().getAscent());\n          }\n        }\n      }\n    };\n    text.setEditorKit(new HTMLEditorKit() {\n      final HTMLEditorKit kit = UIUtil.getHTMLEditorKit();\n\n      final HTMLFactory factory = new HTMLFactory() {\n        public View create(Element e) {\n          View view = super.create(e);\n          if (view instanceof ParagraphView) {\n            // wrap too long words, for example: ATEST_TABLE_SIGNLE_ROW_UPDATE_AUTOCOMMIT_A_FIK\n            return new ParagraphView(e) {\n              protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r) {\n                if (r == null) {\n                  r = new SizeRequirements();\n                }\n                r.minimum = (int)layoutPool.getMinimumSpan(axis);\n                r.preferred = Math.max(r.minimum, (int)layoutPool.getPreferredSpan(axis));\n                r.maximum = Integer.MAX_VALUE;\n                r.alignment = 0.5f;\n                return r;\n              }\n            };\n          }\n          return view;\n        }\n      };\n\n      @Override\n      public StyleSheet getStyleSheet() {\n        return kit.getStyleSheet();\n      }\n\n      @Override\n      public ViewFactory getViewFactory() {\n        return factory;\n      }\n    });\n    text.setForeground(foreground);\n\n    final HyperlinkListener listener = NotificationsUtil.wrapListener(notification);\n    if (listener != null) {\n      text.addHyperlinkListener(listener);\n    }\n\n    String fontStyle = NotificationsUtil.getFontStyle();\n    int prefSize = new JLabel(NotificationsUtil.buildHtml(notification, null, true, null, fontStyle)).getPreferredSize().width;\n    String style = prefSize > BalloonLayoutConfiguration.MaxWidth ? BalloonLayoutConfiguration.MaxWidthStyle : null;\n\n    if (layoutData.showFullContent) {\n      style = prefSize > BalloonLayoutConfiguration.MaxFullContentWidth ? BalloonLayoutConfiguration.MaxFullContentWidthStyle : null;\n    }\n\n    String textR = NotificationsUtil.buildHtml(notification, style, true, foregroundR, fontStyle);\n    String textD = NotificationsUtil.buildHtml(notification, style, true, foregroundD, fontStyle);\n    LafHandler lafHandler = new LafHandler(text, textR, textD);\n    layoutData.lafHandler = lafHandler;\n\n    text.setEditable(false);\n    text.setOpaque(false);\n\n    if (UIUtil.isUnderNimbusLookAndFeel()) {\n      text.setBackground(UIUtil.TRANSPARENT_COLOR);\n    }\n\n    text.setBorder(null);\n\n    final JPanel content = new NonOpaquePanel(new BorderLayout());\n\n    if (text.getCaret() != null) {\n      text.setCaretPosition(0);\n    }\n\n    final JScrollPane pane = createBalloonScrollPane(text, false);\n\n    pane.getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {\n      @Override\n      public void adjustmentValueChanged(AdjustmentEvent e) {\n        JScrollBar scrollBar = pane.getVerticalScrollBar();\n        if (layoutData.showMinSize && scrollBar.getValue() > 0) {\n          scrollBar.removeAdjustmentListener(this);\n          scrollBar.setValue(0);\n          scrollBar.addAdjustmentListener(this);\n        }\n      }\n    });\n\n    LinkLabel<Void> expandAction = null;\n\n    int lines = 3;\n    if (notification.isTitle()) {\n      lines--;\n    }\n    if (actions) {\n      lines--;\n    }\n\n    layoutData.fullHeight = text.getPreferredSize().height;\n    layoutData.twoLineHeight = calculateContentHeight(lines);\n    layoutData.maxScrollHeight = Math.min(layoutData.fullHeight, calculateContentHeight(10));\n    layoutData.configuration = BalloonLayoutConfiguration.create(notification, layoutData, actions);\n\n    if (layoutData.welcomeScreen) {\n      layoutData.maxScrollHeight = layoutData.fullHeight;\n    }\n    else if (!showFullContent && layoutData.maxScrollHeight != layoutData.fullHeight) {\n      pane.setViewport(new GradientViewport(text, JBUI.insets(10, 0), true) {\n        @Nullable\n        @Override\n        protected Color getViewColor() {\n          return layoutData.fillColor;\n        }\n\n        @Override\n        protected void paintGradient(Graphics g) {\n          if (!layoutData.showMinSize) {\n            super.paintGradient(g);\n          }\n        }\n      });\n    }\n\n    configureBalloonScrollPane(pane, layoutData.fillColor);\n\n    if (showFullContent) {\n      pane.setPreferredSize(text.getPreferredSize());\n    }\n    else if (layoutData.twoLineHeight < layoutData.fullHeight) {\n      text.setPreferredSize(null);\n      Dimension size = text.getPreferredSize();\n      size.height = layoutData.twoLineHeight;\n      text.setPreferredSize(size);\n      text.setSize(size);\n      layoutData.showMinSize = true;\n\n      pane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n      pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n      pane.setPreferredSize(size);\n\n      expandAction = new LinkLabel<Void>(null, AllIcons.Ide.Notification.Expand, new LinkListener<Void>() {\n        @Override\n        public void linkSelected(LinkLabel link, Void ignored) {\n          layoutData.showMinSize = !layoutData.showMinSize;\n\n          text.setPreferredSize(null);\n          Dimension size = text.getPreferredSize();\n\n          if (layoutData.showMinSize) {\n            size.height = layoutData.twoLineHeight;\n            pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n            link.setIcon(AllIcons.Ide.Notification.Expand);\n            link.setHoveringIcon(AllIcons.Ide.Notification.ExpandHover);\n          }\n          else {\n            size.height = layoutData.fullHeight;\n            pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n            link.setIcon(AllIcons.Ide.Notification.Collapse);\n            link.setHoveringIcon(AllIcons.Ide.Notification.CollapseHover);\n          }\n\n          text.setPreferredSize(size);\n          text.setSize(size);\n\n          if (!layoutData.showMinSize) {\n            size = new Dimension(size.width, layoutData.maxScrollHeight);\n          }\n          pane.setPreferredSize(size);\n\n          content.doLayout();\n          layoutData.doLayout.run();\n        }\n      });\n      expandAction.setHoveringIcon(AllIcons.Ide.Notification.ExpandHover);\n    }\n\n    final CenteredLayoutWithActions layout = new CenteredLayoutWithActions(text, layoutData);\n    JPanel centerPanel = new NonOpaquePanel(layout) {\n      @Override\n      protected void paintChildren(Graphics g) {\n        super.paintChildren(g);\n        Component title = layout.getTitle();\n\n        if (title != null && layoutData.showActions != null && layoutData.showActions.compute()) {\n          int width = layoutData.configuration.allActionsOffset;\n          int x = getWidth() - width - JBUI.scale(5);\n          int y = layoutData.configuration.topSpaceHeight;\n\n          int height = title instanceof JEditorPane ? getFirstLineHeight((JEditorPane)title) : title.getHeight();\n\n          g.setColor(layoutData.fillColor);\n          g.fillRect(x, y, width, height);\n\n          width = layoutData.configuration.beforeGearSpace;\n          x -= width;\n          ((Graphics2D)g)\n            .setPaint(new GradientPaint(x, y, ColorUtil.withAlpha(layoutData.fillColor, 0.2), x + width, y, layoutData.fillColor));\n          g.fillRect(x, y, width, height);\n        }\n      }\n    };\n    content.add(centerPanel, BorderLayout.CENTER);\n\n    if (notification.isTitle()) {\n      String titleStyle = StringUtil.defaultIfEmpty(fontStyle, \"\") + \"white-space:nowrap;\";\n      String titleR = NotificationsUtil.buildHtml(notification, titleStyle, false, foregroundR, null);\n      String titleD = NotificationsUtil.buildHtml(notification, titleStyle, false, foregroundD, null);\n      JLabel title = new JLabel();\n      lafHandler.setTitle(title, titleR, titleD);\n      title.setOpaque(false);\n      if (UIUtil.isUnderNimbusLookAndFeel()) {\n        title.setBackground(UIUtil.TRANSPARENT_COLOR);\n      }\n      title.setForeground(foreground);\n      centerPanel.add(title, BorderLayout.NORTH);\n    }\n\n    if (expandAction != null) {\n      centerPanel.add(expandAction, BorderLayout.EAST);\n    }\n\n    if (notification.isContent()) {\n      centerPanel.add(layoutData.welcomeScreen ? text : pane, BorderLayout.CENTER);\n    }\n\n    if (!layoutData.welcomeScreen) {\n      final Icon icon = NotificationsUtil.getIcon(notification);\n      JComponent iconComponent = new JComponent() {\n        @Override\n        protected void paintComponent(Graphics g) {\n          super.paintComponent(g);\n          icon.paintIcon(this, g, layoutData.configuration.iconOffset.width, layoutData.configuration.iconOffset.height);\n        }\n      };\n      iconComponent.setOpaque(false);\n      iconComponent.setPreferredSize(\n        new Dimension(layoutData.configuration.iconPanelWidth, 2 * layoutData.configuration.iconOffset.height + icon.getIconHeight()));\n\n      content.add(iconComponent, BorderLayout.WEST);\n    }\n\n    JPanel buttons = createButtons(notification, content, listener);\n    if (buttons != null) {\n      layoutData.groupId = null;\n      buttons.setBorder(new EmptyBorder(0, 0, JBUI.scale(5), JBUI.scale(7)));\n    }\n\n    HoverAdapter hoverAdapter = new HoverAdapter();\n    hoverAdapter.addSource(content);\n    hoverAdapter.addSource(centerPanel);\n\n    if (expandAction != null) {\n      hoverAdapter.addComponent(expandAction, JBUI.insets(5, 5, 7, 7));\n    }\n\n    if (buttons == null && actions) {\n      createActionPanel(notification, centerPanel, layoutData.configuration.actionGap, hoverAdapter);\n    }\n\n    hoverAdapter.initListeners();\n\n    if (layoutData.mergeData != null) {\n      createMergeAction(layoutData, content);\n    }\n\n    text.setSize(text.getPreferredSize());\n\n    Dimension paneSize = new Dimension(text.getPreferredSize());\n    int maxWidth = JBUI.scale(600);\n    if (windowComponent != null) {\n      maxWidth = Math.min(maxWidth, windowComponent.getWidth() - 20);\n    }\n    if (paneSize.width > maxWidth) {\n      pane.setPreferredSize(new Dimension(maxWidth, paneSize.height + UIUtil.getScrollBarWidth()));\n    }\n\n    final BalloonBuilder builder = JBPopupFactory.getInstance().createBalloonBuilder(content);\n    builder.setFillColor(layoutData.fillColor)\n      .setCloseButtonEnabled(buttons == null)\n      .setShowCallout(showCallout)\n      .setShadow(false)\n      .setHideOnClickOutside(hideOnClickOutside)\n      .setHideOnAction(hideOnClickOutside)\n      .setHideOnKeyOutside(hideOnClickOutside)\n      .setHideOnFrameResize(false)\n      .setBorderColor(layoutData.borderColor)\n      .setBorderInsets(JBUI.emptyInsets());\n\n    if (layoutData.fadeoutTime != 0) {\n      builder.setFadeoutTime(layoutData.fadeoutTime);\n    }\n\n    final BalloonImpl balloon = (BalloonImpl)builder.createBalloon();\n    balloon.setAnimationEnabled(false);\n    notification.setBalloon(balloon);\n\n    balloon.setShadowBorderProvider(new NotificationBalloonShadowBorderProvider(layoutData.fillColor, layoutData.borderColor));\n\n    if (!layoutData.welcomeScreen && buttons == null) {\n      balloon.setActionProvider(\n        new NotificationBalloonActionProvider(balloon, layout.getTitle(), layoutData, notification.getGroupId()));\n    }\n\n    Disposer.register(parentDisposable, balloon);\n    return balloon;\n  }","id":41148,"modified_method":"@NotNull\n  private static Balloon createNewBalloon(@Nullable JComponent windowComponent,\n                                          @NotNull Notification notification,\n                                          boolean showCallout,\n                                          boolean hideOnClickOutside,\n                                          @NotNull Ref<Object> layoutDataRef,\n                                          @NotNull Disposable parentDisposable) {\n    final BalloonLayoutData layoutData = layoutDataRef.isNull() ? new BalloonLayoutData() : (BalloonLayoutData)layoutDataRef.get();\n    if (layoutData.groupId == null) {\n      if (NotificationsConfigurationImpl.getSettings(notification.getGroupId()).isShouldLog()) {\n        layoutData.groupId = notification.getGroupId();\n        layoutData.id = notification.id;\n      }\n    }\n    else {\n      layoutData.groupId = null;\n    }\n    layoutDataRef.set(layoutData);\n\n    if (layoutData.fillColor == null) {\n      layoutData.fillColor = FILL_COLOR;\n    }\n    if (layoutData.borderColor == null) {\n      layoutData.borderColor = BORDER_COLOR;\n    }\n\n    boolean actions = !notification.getActions().isEmpty();\n    boolean showFullContent = layoutData.showFullContent || notification instanceof NotificationActionProvider;\n\n    Color foregroundR = Gray._0;\n    Color foregroundD = Gray._191;\n    final Color foreground = new JBColor(foregroundR, foregroundD);\n\n    final JEditorPane text = new JEditorPane() {\n      @Override\n      protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        if (layoutData.showMinSize) {\n          Point location = getCollapsedTextEndLocation(this, layoutData);\n          if (location != null) {\n            g.setColor(getForeground());\n            g.drawString(\"...\", location.x, location.y + g.getFontMetrics().getAscent());\n          }\n        }\n      }\n    };\n    text.setEditorKit(new HTMLEditorKit() {\n      final HTMLEditorKit kit = UIUtil.getHTMLEditorKit();\n\n      final HTMLFactory factory = new HTMLFactory() {\n        public View create(Element e) {\n          View view = super.create(e);\n          if (view instanceof ParagraphView) {\n            // wrap too long words, for example: ATEST_TABLE_SIGNLE_ROW_UPDATE_AUTOCOMMIT_A_FIK\n            return new ParagraphView(e) {\n              protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r) {\n                if (r == null) {\n                  r = new SizeRequirements();\n                }\n                r.minimum = (int)layoutPool.getMinimumSpan(axis);\n                r.preferred = Math.max(r.minimum, (int)layoutPool.getPreferredSpan(axis));\n                r.maximum = Integer.MAX_VALUE;\n                r.alignment = 0.5f;\n                return r;\n              }\n            };\n          }\n          return view;\n        }\n      };\n\n      @Override\n      public StyleSheet getStyleSheet() {\n        return kit.getStyleSheet();\n      }\n\n      @Override\n      public ViewFactory getViewFactory() {\n        return factory;\n      }\n    });\n    text.setForeground(foreground);\n\n    final HyperlinkListener listener = NotificationsUtil.wrapListener(notification);\n    if (listener != null) {\n      text.addHyperlinkListener(listener);\n    }\n\n    String fontStyle = NotificationsUtil.getFontStyle();\n    int prefSize = new JLabel(NotificationsUtil.buildHtml(notification, null, true, null, fontStyle)).getPreferredSize().width;\n    String style = prefSize > BalloonLayoutConfiguration.MaxWidth ? BalloonLayoutConfiguration.MaxWidthStyle : null;\n\n    if (layoutData.showFullContent) {\n      style = prefSize > BalloonLayoutConfiguration.MaxFullContentWidth ? BalloonLayoutConfiguration.MaxFullContentWidthStyle : null;\n    }\n\n    String textR = NotificationsUtil.buildHtml(notification, style, true, foregroundR, fontStyle);\n    String textD = NotificationsUtil.buildHtml(notification, style, true, foregroundD, fontStyle);\n    LafHandler lafHandler = new LafHandler(text, textR, textD);\n    layoutData.lafHandler = lafHandler;\n\n    text.setEditable(false);\n    text.setOpaque(false);\n\n    if (UIUtil.isUnderNimbusLookAndFeel()) {\n      text.setBackground(UIUtil.TRANSPARENT_COLOR);\n    }\n\n    text.setBorder(null);\n\n    final JPanel content = new NonOpaquePanel(new BorderLayout());\n\n    if (text.getCaret() != null) {\n      text.setCaretPosition(0);\n    }\n\n    final JScrollPane pane = createBalloonScrollPane(text, false);\n\n    pane.getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {\n      @Override\n      public void adjustmentValueChanged(AdjustmentEvent e) {\n        JScrollBar scrollBar = pane.getVerticalScrollBar();\n        if (layoutData.showMinSize && scrollBar.getValue() > 0) {\n          scrollBar.removeAdjustmentListener(this);\n          scrollBar.setValue(0);\n          scrollBar.addAdjustmentListener(this);\n        }\n      }\n    });\n\n    LinkLabel<Void> expandAction = null;\n\n    int lines = 3;\n    if (notification.isTitle()) {\n      lines--;\n    }\n    if (actions) {\n      lines--;\n    }\n\n    layoutData.fullHeight = text.getPreferredSize().height;\n    layoutData.twoLineHeight = calculateContentHeight(lines);\n    layoutData.maxScrollHeight = Math.min(layoutData.fullHeight, calculateContentHeight(10));\n    layoutData.configuration = BalloonLayoutConfiguration.create(notification, layoutData, actions);\n\n    if (layoutData.welcomeScreen) {\n      layoutData.maxScrollHeight = layoutData.fullHeight;\n    }\n    else if (!showFullContent && layoutData.maxScrollHeight != layoutData.fullHeight) {\n      pane.setViewport(new GradientViewport(text, JBUI.insets(10, 0), true) {\n        @Nullable\n        @Override\n        protected Color getViewColor() {\n          return layoutData.fillColor;\n        }\n\n        @Override\n        protected void paintGradient(Graphics g) {\n          if (!layoutData.showMinSize) {\n            super.paintGradient(g);\n          }\n        }\n      });\n    }\n\n    configureBalloonScrollPane(pane, layoutData.fillColor);\n\n    if (showFullContent) {\n      pane.setPreferredSize(text.getPreferredSize());\n    }\n    else if (layoutData.twoLineHeight < layoutData.fullHeight) {\n      text.setPreferredSize(null);\n      Dimension size = text.getPreferredSize();\n      size.height = layoutData.twoLineHeight;\n      text.setPreferredSize(size);\n      text.setSize(size);\n      layoutData.showMinSize = true;\n\n      pane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n      pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n      pane.setPreferredSize(size);\n\n      text.setCaret(new TextCaret(layoutData));\n\n      expandAction = new LinkLabel<Void>(null, AllIcons.Ide.Notification.Expand, new LinkListener<Void>() {\n        @Override\n        public void linkSelected(LinkLabel link, Void ignored) {\n          layoutData.showMinSize = !layoutData.showMinSize;\n\n          text.setPreferredSize(null);\n          Dimension size = text.getPreferredSize();\n\n          if (layoutData.showMinSize) {\n            size.height = layoutData.twoLineHeight;\n            pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n            link.setIcon(AllIcons.Ide.Notification.Expand);\n            link.setHoveringIcon(AllIcons.Ide.Notification.ExpandHover);\n          }\n          else {\n            text.select(0, 0);\n            size.height = layoutData.fullHeight;\n            pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n            link.setIcon(AllIcons.Ide.Notification.Collapse);\n            link.setHoveringIcon(AllIcons.Ide.Notification.CollapseHover);\n          }\n\n          text.setPreferredSize(size);\n          text.setSize(size);\n\n          if (!layoutData.showMinSize) {\n            size = new Dimension(size.width, layoutData.maxScrollHeight);\n          }\n          pane.setPreferredSize(size);\n\n          content.doLayout();\n          layoutData.doLayout.run();\n        }\n      });\n      expandAction.setHoveringIcon(AllIcons.Ide.Notification.ExpandHover);\n    }\n\n    final CenteredLayoutWithActions layout = new CenteredLayoutWithActions(text, layoutData);\n    JPanel centerPanel = new NonOpaquePanel(layout) {\n      @Override\n      protected void paintChildren(Graphics g) {\n        super.paintChildren(g);\n        Component title = layout.getTitle();\n\n        if (title != null && layoutData.showActions != null && layoutData.showActions.compute()) {\n          int width = layoutData.configuration.allActionsOffset;\n          int x = getWidth() - width - JBUI.scale(5);\n          int y = layoutData.configuration.topSpaceHeight;\n\n          int height = title instanceof JEditorPane ? getFirstLineHeight((JEditorPane)title) : title.getHeight();\n\n          g.setColor(layoutData.fillColor);\n          g.fillRect(x, y, width, height);\n\n          width = layoutData.configuration.beforeGearSpace;\n          x -= width;\n          ((Graphics2D)g)\n            .setPaint(new GradientPaint(x, y, ColorUtil.withAlpha(layoutData.fillColor, 0.2), x + width, y, layoutData.fillColor));\n          g.fillRect(x, y, width, height);\n        }\n      }\n    };\n    content.add(centerPanel, BorderLayout.CENTER);\n\n    if (notification.isTitle()) {\n      String titleStyle = StringUtil.defaultIfEmpty(fontStyle, \"\") + \"white-space:nowrap;\";\n      String titleR = NotificationsUtil.buildHtml(notification, titleStyle, false, foregroundR, null);\n      String titleD = NotificationsUtil.buildHtml(notification, titleStyle, false, foregroundD, null);\n      JLabel title = new JLabel();\n      lafHandler.setTitle(title, titleR, titleD);\n      title.setOpaque(false);\n      if (UIUtil.isUnderNimbusLookAndFeel()) {\n        title.setBackground(UIUtil.TRANSPARENT_COLOR);\n      }\n      title.setForeground(foreground);\n      centerPanel.add(title, BorderLayout.NORTH);\n    }\n\n    if (expandAction != null) {\n      centerPanel.add(expandAction, BorderLayout.EAST);\n    }\n\n    if (notification.isContent()) {\n      centerPanel.add(layoutData.welcomeScreen ? text : pane, BorderLayout.CENTER);\n    }\n\n    if (!layoutData.welcomeScreen) {\n      final Icon icon = NotificationsUtil.getIcon(notification);\n      JComponent iconComponent = new JComponent() {\n        @Override\n        protected void paintComponent(Graphics g) {\n          super.paintComponent(g);\n          icon.paintIcon(this, g, layoutData.configuration.iconOffset.width, layoutData.configuration.iconOffset.height);\n        }\n      };\n      iconComponent.setOpaque(false);\n      iconComponent.setPreferredSize(\n        new Dimension(layoutData.configuration.iconPanelWidth, 2 * layoutData.configuration.iconOffset.height + icon.getIconHeight()));\n\n      content.add(iconComponent, BorderLayout.WEST);\n    }\n\n    JPanel buttons = createButtons(notification, content, listener);\n    if (buttons != null) {\n      layoutData.groupId = null;\n      buttons.setBorder(new EmptyBorder(0, 0, JBUI.scale(5), JBUI.scale(7)));\n    }\n\n    HoverAdapter hoverAdapter = new HoverAdapter();\n    hoverAdapter.addSource(content);\n    hoverAdapter.addSource(centerPanel);\n    hoverAdapter.addSource(text);\n    hoverAdapter.addSource(pane);\n\n    if (expandAction != null) {\n      hoverAdapter.addComponent(expandAction, component -> {\n        Rectangle bounds;\n        Point location = SwingUtilities.convertPoint(content.getParent(), content.getLocation(), component.getParent());\n        if (layoutData.showMinSize) {\n          Component centerComponent = layoutData.welcomeScreen ? text : pane;\n          Point centerLocation =\n            SwingUtilities.convertPoint(centerComponent.getParent(), centerComponent.getLocation(), component.getParent());\n          bounds = new Rectangle(location.x, centerLocation.y, content.getWidth(), centerComponent.getHeight());\n        }\n        else {\n          bounds = new Rectangle(location.x, component.getY(), content.getWidth(), component.getHeight());\n          JBInsets.addTo(bounds, JBUI.insets(5, 0, 7, 0));\n        }\n        return bounds;\n      });\n    }\n\n    if (buttons == null && actions) {\n      createActionPanel(notification, centerPanel, layoutData.configuration.actionGap, hoverAdapter);\n    }\n\n    hoverAdapter.initListeners();\n\n    if (layoutData.mergeData != null) {\n      createMergeAction(layoutData, content);\n    }\n\n    text.setSize(text.getPreferredSize());\n\n    Dimension paneSize = new Dimension(text.getPreferredSize());\n    int maxWidth = JBUI.scale(600);\n    if (windowComponent != null) {\n      maxWidth = Math.min(maxWidth, windowComponent.getWidth() - 20);\n    }\n    if (paneSize.width > maxWidth) {\n      pane.setPreferredSize(new Dimension(maxWidth, paneSize.height + UIUtil.getScrollBarWidth()));\n    }\n\n    final BalloonBuilder builder = JBPopupFactory.getInstance().createBalloonBuilder(content);\n    builder.setFillColor(layoutData.fillColor)\n      .setCloseButtonEnabled(buttons == null)\n      .setShowCallout(showCallout)\n      .setShadow(false)\n      .setHideOnClickOutside(hideOnClickOutside)\n      .setHideOnAction(hideOnClickOutside)\n      .setHideOnKeyOutside(hideOnClickOutside)\n      .setHideOnFrameResize(false)\n      .setBorderColor(layoutData.borderColor)\n      .setBorderInsets(JBUI.emptyInsets());\n\n    if (layoutData.fadeoutTime != 0) {\n      builder.setFadeoutTime(layoutData.fadeoutTime);\n    }\n\n    final BalloonImpl balloon = (BalloonImpl)builder.createBalloon();\n    balloon.setAnimationEnabled(false);\n    notification.setBalloon(balloon);\n\n    balloon.setShadowBorderProvider(new NotificationBalloonShadowBorderProvider(layoutData.fillColor, layoutData.borderColor));\n\n    if (!layoutData.welcomeScreen && buttons == null) {\n      balloon.setActionProvider(\n        new NotificationBalloonActionProvider(balloon, layout.getTitle(), layoutData, notification.getGroupId()));\n    }\n\n    Disposer.register(parentDisposable, balloon);\n    return balloon;\n  }","commit_id":"5587eb00ec5d555acc7a12a4b89a2b4108990646","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleEvent(MouseEvent e, boolean pressed, boolean moved) {\n      for (Pair<Component, Insets> p : myComponents) {\n        Component component = p.first;\n        Rectangle bounds = component.getBounds();\n        JBInsets.addTo(bounds, p.second);\n        if (bounds.contains(SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getParent()))) {\n          if (myLastComponent != null && myLastComponent != component) {\n            mouseExited(e, myLastComponent);\n          }\n          myLastComponent = component;\n\n          MouseEvent event = createEvent(e, component);\n          if (moved) {\n            for (MouseMotionListener listener : component.getMouseMotionListeners()) {\n              listener.mouseMoved(event);\n            }\n          }\n          else {\n            MouseListener[] listeners = component.getMouseListeners();\n            if (pressed) {\n              for (MouseListener listener : listeners) {\n                listener.mousePressed(event);\n              }\n            }\n            else {\n              for (MouseListener listener : listeners) {\n                listener.mouseReleased(event);\n              }\n            }\n          }\n          return;\n        }\n        else if (component == myLastComponent) {\n          myLastComponent = null;\n          mouseExited(e, component);\n        }\n      }\n    }","id":41149,"modified_method":"private void handleEvent(MouseEvent e, boolean pressed, boolean moved) {\n      for (Pair<Component, ?> p : myComponents) {\n        Component component = p.first;\n        Rectangle bounds;\n        if (p.second instanceof Insets) {\n          bounds = component.getBounds();\n          JBInsets.addTo(bounds, (Insets)p.second);\n        }\n        else {\n          bounds = ((Function<Component, Rectangle>)p.second).fun(component);\n        }\n        if (bounds.contains(SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getParent()))) {\n          if (myLastComponent != null && myLastComponent != component) {\n            mouseExited(e, myLastComponent);\n          }\n          myLastComponent = component;\n\n          MouseEvent event = createEvent(e, component);\n          if (moved) {\n            for (MouseMotionListener listener : component.getMouseMotionListeners()) {\n              listener.mouseMoved(event);\n            }\n          }\n          else {\n            MouseListener[] listeners = component.getMouseListeners();\n            if (pressed) {\n              for (MouseListener listener : listeners) {\n                listener.mousePressed(event);\n              }\n            }\n            else {\n              for (MouseListener listener : listeners) {\n                listener.mouseReleased(event);\n              }\n            }\n          }\n\n          e.getComponent().setCursor(component.getCursor());\n          return;\n        }\n        else if (component == myLastComponent) {\n          myLastComponent = null;\n          mouseExited(e, component);\n        }\n      }\n    }","commit_id":"5587eb00ec5d555acc7a12a4b89a2b4108990646","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void mouseExited(MouseEvent e, Component component) {\n      MouseEvent event = createEvent(e, component);\n      MouseListener[] listeners = component.getMouseListeners();\n      for (MouseListener listener : listeners) {\n        listener.mouseExited(event);\n      }\n    }","id":41150,"modified_method":"private static void mouseExited(MouseEvent e, Component component) {\n      e.getComponent().setCursor(null);\n\n      MouseEvent event = createEvent(e, component);\n      MouseListener[] listeners = component.getMouseListeners();\n      for (MouseListener listener : listeners) {\n        listener.mouseExited(event);\n      }\n    }","commit_id":"5587eb00ec5d555acc7a12a4b89a2b4108990646","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1185457754240(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ide.scriptLanguage.structure.ActionContextReference\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41151,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1185457754240(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ide.scriptLanguage.structure.ActionContextReference\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_BaseAttribute_1167699332639(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"webr.xml.structure.Attribute\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(concept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            List<SNode> attributeDeclarations = new ArrayList<SNode>();\n            SNode parentElementDeclaration = ElementUtil.getParentElementDeclaration(_context.getParentNode(), operationContext.getScope());\n            if((parentElementDeclaration != null)) {\n              ListOperations.addAllElements(attributeDeclarations, ElementDeclaration_Behavior.call_getAttributeDeclarations_1183587644932(parentElementDeclaration));\n            }\n            return attributeDeclarations;\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode attribute = SModelOperations.createNewNode(model, \"webr.xml.structure.Attribute\", _context.getCurrentTargetNode());\n              SLinkOperations.setTarget(attribute, \"attributeDeclaration\", ((SNode)this.getParameterObject()), false);\n              SLinkOperations.setNewChild(attribute, \"value\", \"webr.xml.structure.Text\");\n              return attribute;\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"attributeName\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":41152,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_BaseAttribute_1167699332639(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"webr.xml.structure.Attribute\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            List<SNode> attributeDeclarations = new ArrayList<SNode>();\n            SNode parentElementDeclaration = ElementUtil.getParentElementDeclaration(_context.getParentNode(), operationContext.getScope());\n            if((parentElementDeclaration != null)) {\n              ListOperations.addAllElements(attributeDeclarations, ElementDeclaration_Behavior.call_getAttributeDeclarations_1183587644932(parentElementDeclaration));\n            }\n            return attributeDeclarations;\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode attribute = SModelOperations.createNewNode(model, \"webr.xml.structure.Attribute\", _context.getCurrentTargetNode());\n              SLinkOperations.setTarget(attribute, \"attributeDeclaration\", ((SNode)this.getParameterObject()), false);\n              SLinkOperations.setNewChild(attribute, \"value\", \"webr.xml.structure.Text\");\n              return attribute;\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"attributeName\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Content_1167757687265(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    final SNode parentElement;\n    final boolean isMixed;\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          return ElementUtil.getParentElementDeclaration(_context.getParentNode(), operationContext.getScope());\n        }\n\n      };\n      parentElement = (SNode)calc.calculate();\n    }\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          return (parentElement == null) || TypeExpression_Behavior.call_isMixed_1183649029971(parentElement);\n        }\n\n      };\n      isMixed = (Boolean)calc.calculate();\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"webr.xml.structure.Element\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(concept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            return ElementUtil.getElementDeclarations(parentElement, _context.getParentNode(), operationContext.getScope());\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode element = SModelOperations.createNewNode(model, \"webr.xml.structure.Element\", _context.getCurrentTargetNode());\n              SLinkOperations.setTarget(element, \"elementDeclaration\", ((SNode)this.getParameterObject()), false);\n              SPropertyOperations.set(element, \"isEmpty\", \"\" + (ElementDeclaration_Behavior.call_isEmpty_1183642787202(((SNode)this.getParameterObject()))));\n              return element;\n            }\n\n            public String getMatchingText(String pattern) {\n              return \"<\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"elementName\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":41153,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Content_1167757687265(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    final SNode parentElement;\n    final boolean isMixed;\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          return ElementUtil.getParentElementDeclaration(_context.getParentNode(), operationContext.getScope());\n        }\n\n      };\n      parentElement = (SNode)calc.calculate();\n    }\n    {\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          return (parentElement == null) || TypeExpression_Behavior.call_isMixed_1183649029971(parentElement);\n        }\n\n      };\n      isMixed = (Boolean)calc.calculate();\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"webr.xml.structure.Element\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            return ElementUtil.getElementDeclarations(parentElement, _context.getParentNode(), operationContext.getScope());\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode element = SModelOperations.createNewNode(model, \"webr.xml.structure.Element\", _context.getCurrentTargetNode());\n              SLinkOperations.setTarget(element, \"elementDeclaration\", ((SNode)this.getParameterObject()), false);\n              SPropertyOperations.set(element, \"isEmpty\", \"\" + (ElementDeclaration_Behavior.call_isEmpty_1183642787202(((SNode)this.getParameterObject()))));\n              return element;\n            }\n\n            public String getMatchingText(String pattern) {\n              return \"<\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"elementName\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Content_1201903366642(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"webr.xml.structure.Text\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode text = SConceptOperations.createNewNode(\"webr.xml.structure.Text\", _context.getCurrentTargetNode());\n          if(pattern.length() > 0) {\n            SPropertyOperations.set(text, \"text\", pattern.substring(1));\n          }\n          return text;\n        }\n\n        public boolean hasSubstitute() {\n          return true;\n        }\n\n        public boolean canSubstitute_internal(String pattern) {\n          return pattern.startsWith(\"/\") || pattern.length() == 0;\n        }\n\n        public String getDescriptionText(String pattern) {\n          return SConceptPropertyOperations.getString(SConceptOperations.findConceptDeclaration(\"webr.xml.structure.Text\"), \"short_description\");\n        }\n\n        public String getMatchingText(String pattern) {\n          return (pattern.length() == 0 ?\n            \"/text\" :\n            pattern\n          );\n        }\n\n      });\n    }\n    return result;\n  }","id":41154,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Content_1201903366642(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"webr.xml.structure.Text\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode text = SConceptOperations.createNewNode(\"webr.xml.structure.Text\", _context.getCurrentTargetNode());\n            if(pattern.length() > 0) {\n              SPropertyOperations.set(text, \"text\", pattern.substring(1));\n            }\n            return text;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern) {\n            return pattern.startsWith(\"/\") || pattern.length() == 0;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return SConceptPropertyOperations.getString(SConceptOperations.findConceptDeclaration(\"webr.xml.structure.Text\"), \"short_description\");\n          }\n\n          public String getMatchingText(String pattern) {\n            return (pattern.length() == 0 ?\n              \"/text\" :\n              pattern\n            );\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_LinePart_1182843946099(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.ConstantLinePart\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode part = SModelOperations.createNewNode(model, \"jetbrains.mpslite.structure.ConstantLinePart\", null);\n          SPropertyOperations.set(part, \"text\", pattern.substring(1));\n          return part;\n        }\n\n        public boolean hasSubstitute() {\n          return true;\n        }\n\n        public boolean canSubstitute_internal(String pattern) {\n          return pattern.startsWith(\"/\");\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"\";\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"/constant text\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41155,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_LinePart_1182843946099(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.ConstantLinePart\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode part = SModelOperations.createNewNode(model, \"jetbrains.mpslite.structure.ConstantLinePart\", null);\n            SPropertyOperations.set(part, \"text\", pattern.substring(1));\n            return part;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern) {\n            return pattern.startsWith(\"/\");\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"/constant text\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197554040398(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.LeftPartExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41156,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197554040398(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.LeftPartExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1196942335235(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode expr = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mpslite.structure.MPSLiteOperationExpression\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), expr);\n          SLinkOperations.setTarget(expr, \"expression\", _context.getSourceNode(), true);\n          return expr;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".mps lite operation\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41157,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1196942335235(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode expr = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mpslite.structure.MPSLiteOperationExpression\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), expr);\n          SLinkOperations.setTarget(expr, \"expression\", _context.getSourceNode(), true);\n          return expr;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".mps lite operation\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197284173199(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.ThisNodeExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41158,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197284173199(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.ThisNodeExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197293107768(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.AddEquationStatement\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.AddInequationStatement\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.AddComparableConstraintStatement\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.ReportErrorStatement\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41159,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197293107768(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.AddEquationStatement\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.AddInequationStatement\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.AddComparableConstraintStatement\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.ReportErrorStatement\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197631213002(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.LeftPartExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mpslite.structure.RightPartExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41160,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197631213002(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.LeftPartExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mpslite.structure.RightPartExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1199547332187(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.closures.structure.InvokeFunctionExpression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode invoke = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.closures.structure.InvokeFunctionExpression\");\n          SLinkOperations.setTarget(invoke, \"function\", _context.getSourceNode(), true);\n          return invoke;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".invoke\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41161,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1199547332187(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.closures.structure.InvokeFunctionExpression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode invoke = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.closures.structure.InvokeFunctionExpression\");\n          SLinkOperations.setTarget(invoke, \"function\", _context.getSourceNode(), true);\n          return invoke;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".invoke\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterReference_1199622421675(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterReference\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(concept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            SNode cl = SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.closures.structure.ClosureLiteral\", false, false);\n            return SLinkOperations.getTargets(cl, \"parameter\", true);\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode pr = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ParameterReference\", null);\n              SLinkOperations.setTarget(pr, \"variableDeclaration\", ((SNode)this.getParameterObject()), false);\n              return pr;\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":41162,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterReference_1199622421675(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ParameterReference\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            SNode cl = SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.closures.structure.ClosureLiteral\", false, false);\n            return SLinkOperations.getTargets(cl, \"parameter\", true);\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              SNode pr = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ParameterReference\", null);\n              SLinkOperations.setTarget(pr, \"variableDeclaration\", ((SNode)this.getParameterObject()), false);\n              return pr;\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1199711415359(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.closures.structure.InvokeExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41163,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1199711415359(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.closures.structure.InvokeExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ThisExpression_1199651306154(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41164,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ThisExpression_1199651306154(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ThisExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_RuleConsequence_1195244607537(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.transformation.TLBase.structure.InlineSwitch_RuleConsequence\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41165,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_RuleConsequence_1195244607537(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.transformation.TLBase.structure.InlineSwitch_RuleConsequence\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_RuleConsequence_1169570930693(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.transformation.TLBase.structure.WeaveEach_RuleConsequence\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41166,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_RuleConsequence_1169570930693(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.transformation.TLBase.structure.WeaveEach_RuleConsequence\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IFeature_1184067774388(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ListFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.SequenceFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ParamListFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ParamSequenceFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GenericFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GenericParamFeature\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41167,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IFeature_1184067774388(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ListFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.SequenceFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ParamListFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ParamSequenceFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.GenericFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.GenericParamFeature\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_TreeNodeKindOccurrence_1175164446140(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.MatchPropertyOperation\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tnko = _context.getSourceNode();\n            SNode mko = SNodeOperations.getParent(tnko, null, false, false);\n            SNode mpo = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mps.ypath.structure.MatchPropertyOperation\", null);\n            SNodeOperations.replaceWithAnother(mko, mpo);\n            SLinkOperations.setTarget(SLinkOperations.getTarget(mpo, \"nodeKindOccurrence\", true), \"nodeKind\", SLinkOperations.getTarget(tnko, \"nodeKind\", false), false);\n            SLinkOperations.setTarget(mpo, \"property\", ((SNode)this.getParameterObject()), false);\n            return mpo;\n          }\n\n          public String getMatchingText(String text) {\n            return \".\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match property value\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41168,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_TreeNodeKindOccurrence_1175164446140(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.MatchPropertyOperation\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tnko = _context.getSourceNode();\n            SNode mko = SNodeOperations.getParent(tnko, null, false, false);\n            SNode mpo = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mps.ypath.structure.MatchPropertyOperation\", null);\n            SNodeOperations.replaceWithAnother(mko, mpo);\n            SLinkOperations.setTarget(SLinkOperations.getTarget(mpo, \"nodeKindOccurrence\", true), \"nodeKind\", SLinkOperations.getTarget(tnko, \"nodeKind\", false), false);\n            SLinkOperations.setTarget(mpo, \"property\", ((SNode)this.getParameterObject()), false);\n            return mpo;\n          }\n\n          public String getMatchingText(String text) {\n            return \".\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match property value\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_GenericFeatureFunHolder_1196424373003(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode hld = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\", null);\n          SPropertyOperations.set(hld, \"byIndex\", \"\" + (true));\n          return hld;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"by index\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode hld = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\", null);\n          SPropertyOperations.set(hld, \"byIndex\", \"\" + (false));\n          return hld;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"byelement\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41169,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_GenericFeatureFunHolder_1196424373003(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"?output concept is not specified?\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode hld = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\", null);\n            SPropertyOperations.set(hld, \"byIndex\", \"\" + (true));\n            return hld;\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"by index\";\n          }\n\n        });\n      }\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"?output concept is not specified?\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode hld = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\", null);\n            SPropertyOperations.set(hld, \"byIndex\", \"\" + (false));\n            return hld;\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"byelement\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1196791152384(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          return SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.EmptySequenceExpression\", null);\n        }\n\n        public boolean hasSubstitute() {\n          return true;\n        }\n\n        public boolean canSubstitute_internal(String pattern) {\n          return SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.ReplaceWritePathStatement\");\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"NOTHING\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41170,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1196791152384(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"?output concept is not specified?\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            return SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.EmptySequenceExpression\", null);\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern) {\n            return SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.ReplaceWritePathStatement\");\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"NOTHING\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1198013853576(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          List<Quadruplet> res = ListOperations.<Quadruplet>createList();\n          SNode nodeType = (SNode)TypeChecker.getInstance().getTypeOf(_context.getSourceNode());\n          {\n            ICursor<SNode> _zCursor6 = CursorFactory.createCursor(TreePathAspectUtil.getTreePathAspects(_context.getSourceNode(), operationContext.getScope()));\n            try {\n              while(_zCursor6.moveToNext()) {\n                SNode aspect = _zCursor6.getCurrent();\n                {\n                  ICursor<TraversalAxis> _zCursor7 = CursorFactory.createCursor(TraversalAxis.getConstants());\n                  try {\n                    while(_zCursor7.moveToNext()) {\n                      TraversalAxis axis = _zCursor7.getCurrent();\n                      ListOperations.addElement(res, new Quadruplet(aspect, axis, null, null));\n                      {\n                        ICursor<SNode> _zCursor8 = CursorFactory.createCursor(TreePath_Behavior.call_getFeature_1184591220431(aspect, nodeType));\n                        try {\n                          while(_zCursor8.moveToNext()) {\n                            SNode feat = _zCursor8.getCurrent();\n                            if(TraversalAxisUtil.isAcceptableFeatureForAxis(feat, axis)) {\n                              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                                ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, null));\n                              } else\n                              if(SNodeOperations.isInstanceOf(feat, \"jetbrains.mps.ypath.structure.IParamFeature\")) {\n                                {\n                                  ICursor<SNode> _zCursor9 = CursorFactory.createCursor(IParamFeature_Behavior.call_getParameterObjects_1197461148674(feat, nodeType));\n                                  try {\n                                    while(_zCursor9.moveToNext()) {\n                                      SNode pw = _zCursor9.getCurrent();\n                                      ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, pw));\n                                    }\n                                  } finally {\n                                    _zCursor9.release();\n                                  }\n                                }\n                              } else\n                              {\n                                ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, null));\n                              }\n                            }\n                          }\n                        } finally {\n                          _zCursor8.release();\n                        }\n                      }\n                    }\n                  } finally {\n                    _zCursor7.release();\n                  }\n                }\n              }\n            } finally {\n              _zCursor6.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Quadruplet> parameterObjects = (Iterable<Quadruplet>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Quadruplet parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setNewChild(tpoExp, \"expression\", \"jetbrains.mps.ypath.structure.TreePathAdapterExpression\");\n            SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"expression\", true), \"expression\", _context.getSourceNode(), true);\n            SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"expression\", true), \"treepathAspect\", aspect, false);\n            SPropertyOperations.set(SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.IterateOperation\"), \"axis\", axis.getValue());\n            if((feat != null)) {\n              SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"usedFeature\", feat, false);\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                /*\n                  SPropertyOperations.set(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"useDefault\", \"\" + (true));\n                */\n              } else\n              if((pw != null)) {\n                SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"paramObject\", pw, true);\n              }\n            }\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \" *\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return TraversalAxisUtil.getOperationSign(axis) + suffix;\n          }\n\n          public String getDescriptionText(String text) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \"all\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"default\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\") + \" \" + SPropertyOperations.getString(feat, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return \"iterate \" + axis.getName() + \" @\" + suffix + \" using \" + SPropertyOperations.getString(aspect, \"name\");\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41171,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1198013853576(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          List<Quadruplet> res = ListOperations.<Quadruplet>createList();\n          SNode nodeType = (SNode)TypeChecker.getInstance().getTypeOf(_context.getSourceNode());\n          {\n            ICursor<SNode> _zCursor6 = CursorFactory.createCursor(TreePathAspectUtil.getTreePathAspects(_context.getSourceNode(), operationContext.getScope()));\n            try {\n              while(_zCursor6.moveToNext()) {\n                SNode aspect = _zCursor6.getCurrent();\n                {\n                  ICursor<TraversalAxis> _zCursor7 = CursorFactory.createCursor(TraversalAxis.getConstants());\n                  try {\n                    while(_zCursor7.moveToNext()) {\n                      TraversalAxis axis = _zCursor7.getCurrent();\n                      ListOperations.addElement(res, new Quadruplet(aspect, axis, null, null));\n                      {\n                        ICursor<SNode> _zCursor8 = CursorFactory.createCursor(TreePath_Behavior.call_getFeature_1184591220431(aspect, nodeType));\n                        try {\n                          while(_zCursor8.moveToNext()) {\n                            SNode feat = _zCursor8.getCurrent();\n                            if(TraversalAxisUtil.isAcceptableFeatureForAxis(feat, axis)) {\n                              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                                ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, null));\n                              } else\n                              if(SNodeOperations.isInstanceOf(feat, \"jetbrains.mps.ypath.structure.IParamFeature\")) {\n                                {\n                                  ICursor<SNode> _zCursor9 = CursorFactory.createCursor(IParamFeature_Behavior.call_getParameterObjects_1197461148674(feat, nodeType));\n                                  try {\n                                    while(_zCursor9.moveToNext()) {\n                                      SNode pw = _zCursor9.getCurrent();\n                                      ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, pw));\n                                    }\n                                  } finally {\n                                    _zCursor9.release();\n                                  }\n                                }\n                              } else\n                              {\n                                ListOperations.addElement(res, new Quadruplet(aspect, axis, feat, null));\n                              }\n                            }\n                          }\n                        } finally {\n                          _zCursor8.release();\n                        }\n                      }\n                    }\n                  } finally {\n                    _zCursor7.release();\n                  }\n                }\n              }\n            } finally {\n              _zCursor6.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Quadruplet> parameterObjects = (Iterable<Quadruplet>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Quadruplet parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setNewChild(tpoExp, \"expression\", \"jetbrains.mps.ypath.structure.TreePathAdapterExpression\");\n            SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"expression\", true), \"expression\", _context.getSourceNode(), true);\n            SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"expression\", true), \"treepathAspect\", aspect, false);\n            SPropertyOperations.set(SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.IterateOperation\"), \"axis\", axis.getValue());\n            if((feat != null)) {\n              SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"usedFeature\", feat, false);\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                /*\n                  SPropertyOperations.set(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"useDefault\", \"\" + (true));\n                */\n              } else\n              if((pw != null)) {\n                SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"paramObject\", pw, true);\n              }\n            }\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \" *\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return TraversalAxisUtil.getOperationSign(axis) + suffix;\n          }\n\n          public String getDescriptionText(String text) {\n            SNode aspect = (SNode)((Quadruplet)this.getParameterObject()).first();\n            TraversalAxis axis = (TraversalAxis)((Quadruplet)this.getParameterObject()).second();\n            SNode feat = (SNode)((Quadruplet)this.getParameterObject()).third();\n            SNode pw = (SNode)((Quadruplet)this.getParameterObject()).fourth();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \"all\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"default\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\") + \" \" + SPropertyOperations.getString(feat, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return \"iterate \" + axis.getName() + \" @\" + suffix + \" using \" + SPropertyOperations.getString(aspect, \"name\");\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_VisitParameterDeclaration_1180018851746(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.VisitParameterDeclaration\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode vpd = SModelOperations.createNewNode(model, \"jetbrains.mps.ypath.structure.VisitParameterDeclaration\", null);\n          SLinkOperations.setTarget(vpd, \"type\", nodeToWrap, true);\n          return vpd;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41172,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_VisitParameterDeclaration_1180018851746(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.VisitParameterDeclaration\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode vpd = SModelOperations.createNewNode(model, \"jetbrains.mps.ypath.structure.VisitParameterDeclaration\", null);\n          SLinkOperations.setTarget(vpd, \"type\", nodeToWrap, true);\n          return vpd;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1180026401346(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.SwitchNodeKindStatement\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41173,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1180026401346(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.SwitchNodeKindStatement\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_IFeature_1197904809758(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          final zClosureContext1 _zClosureContext1 = new zClosureContext1();\n          List<Pair> res = ListOperations.<Pair>createList();\n          _zClosureContext1.srcNode = _context.getSourceNode();\n          _zClosureContext1.isGeneric = SNodeOperations.isInstanceOf(_zClosureContext1.srcNode, \"jetbrains.mps.ypath.structure.IGenericFeature\");\n          {\n            ICursor<SNode> _zCursor2 = CursorFactory.createCursor(SequenceOperations.where(SLinkOperations.getTargets(SNodeOperations.getParent(_zClosureContext1.srcNode, null, false, false), \"features\", true), new zPredicate2(null, _zClosureContext1)));\n            try {\n              while(_zCursor2.moveToNext()) {\n                SNode fe = _zCursor2.getCurrent();\n                ListOperations.addElement(res, new Pair(fe, Boolean.TRUE));\n                ListOperations.addElement(res, new Pair(fe, Boolean.FALSE));\n              }\n            } finally {\n              _zCursor2.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Pair> parameterObjects = (Iterable<Pair>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Pair parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            IFeature_Behavior.call_setOpposite_1197913839765(_context.getSourceNode(), fe, mu);\n            return _context.getSourceNode();\n          }\n\n          public String getMatchingText(String text) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            return (mu ?\n              \"<-> \" + SPropertyOperations.getString(fe, \"name\") :\n              \"<-  \" + SPropertyOperations.getString(fe, \"name\")\n            );\n          }\n\n          public String getDescriptionText(String text) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            return (mu ?\n              \"set mutual opposite feature\" :\n              \"set opposite feature\"\n            );\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41174,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_IFeature_1197904809758(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          final zClosureContext1 _zClosureContext1 = new zClosureContext1();\n          List<Pair> res = ListOperations.<Pair>createList();\n          _zClosureContext1.srcNode = _context.getSourceNode();\n          _zClosureContext1.isGeneric = SNodeOperations.isInstanceOf(_zClosureContext1.srcNode, \"jetbrains.mps.ypath.structure.IGenericFeature\");\n          {\n            ICursor<SNode> _zCursor2 = CursorFactory.createCursor(SequenceOperations.where(SLinkOperations.getTargets(SNodeOperations.getParent(_zClosureContext1.srcNode, null, false, false), \"features\", true), new zPredicate2(null, _zClosureContext1)));\n            try {\n              while(_zCursor2.moveToNext()) {\n                SNode fe = _zCursor2.getCurrent();\n                ListOperations.addElement(res, new Pair(fe, Boolean.TRUE));\n                ListOperations.addElement(res, new Pair(fe, Boolean.FALSE));\n              }\n            } finally {\n              _zCursor2.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Pair> parameterObjects = (Iterable<Pair>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Pair parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            IFeature_Behavior.call_setOpposite_1197913839765(_context.getSourceNode(), fe, mu);\n            return _context.getSourceNode();\n          }\n\n          public String getMatchingText(String text) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            return (mu ?\n              \"<-> \" + SPropertyOperations.getString(fe, \"name\") :\n              \"<-  \" + SPropertyOperations.getString(fe, \"name\")\n            );\n          }\n\n          public String getDescriptionText(String text) {\n            SNode fe = (SNode)((Pair)this.getParameterObject()).o1;\n            Boolean mu = (Boolean)((Pair)this.getParameterObject()).o2;\n            return (mu ?\n              \"set mutual opposite feature\" :\n              \"set opposite feature\"\n            );\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterWrapper_1184768393149(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ParameterWrapper\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(concept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            SNode op = _context.getParentNode();\n            SNode tpoe = SNodeOperations.getParent(_context.getParentNode(), null, false, false);\n            return FeatureTargetTypeUtil.getParameterObjects(SLinkOperations.getTarget(op, \"usedFeature\", false), SLinkOperations.getTarget(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(tpoe, \"expression\", true)), \"nodeType\", true));\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              return ((SNode)this.getParameterObject());\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":41175,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterWrapper_1184768393149(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ParameterWrapper\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            SNode op = _context.getParentNode();\n            SNode tpoe = SNodeOperations.getParent(_context.getParentNode(), null, false, false);\n            return FeatureTargetTypeUtil.getParameterObjects(SLinkOperations.getTarget(op, \"usedFeature\", false), SLinkOperations.getTarget(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(tpoe, \"expression\", true)), \"nodeType\", true));\n          }\n\n        };\n        Iterable<SNode> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(SNode item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              return ((SNode)this.getParameterObject());\n            }\n\n            public String getMatchingText(String pattern) {\n              return SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1194616742213(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.IsWithinRangeExpression\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".isWithinRange ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange expression\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.IsAtInsertionPointExpression\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".isAtInsertionPoint ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange expression\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Statement\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.NextElementStatement\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".next ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange statement\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41176,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1194616742213(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.IsWithinRangeExpression\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".isWithinRange ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange expression\";\n        }\n\n      });\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.IsAtInsertionPointExpression\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".isAtInsertionPoint ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange expression\";\n        }\n\n      });\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Statement\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode res = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.NextElementStatement\");\n          SLinkOperations.setTarget(res, \"range\", _context.getSourceNode(), true);\n          return res;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \".next ()\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"IRange statement\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IAnchor_1194436439282(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.IndexAnchor\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ElementAnchor\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode anchor = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.ElementAnchor\", null);\n          SPropertyOperations.set(anchor, \"before\", \"\" + (true));\n          return anchor;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"BEFORE\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.ElementAnchor\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode anchor = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.ElementAnchor\", null);\n          SPropertyOperations.set(anchor, \"before\", \"\" + (false));\n          return anchor;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"AFTER\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41177,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IAnchor_1194436439282(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.IndexAnchor\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ElementAnchor\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode anchor = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.ElementAnchor\", null);\n            SPropertyOperations.set(anchor, \"before\", \"\" + (true));\n            return anchor;\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"BEFORE\";\n          }\n\n        });\n      }\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.ElementAnchor\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode anchor = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.ElementAnchor\", null);\n            SPropertyOperations.set(anchor, \"before\", \"\" + (false));\n            return anchor;\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"AFTER\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IGenericFeatureFun_1196420410543(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          List<SNode> res = ListOperations.<SNode>createList(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFReplaceFunWrapper\"), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFRemoveFunWrapper\"), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFInsertFunWrapper\"));\n          if(SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\")) {\n            {\n              ICursor<SNode> _zCursor = CursorFactory.createCursor(SLinkOperations.getTargets(_context.getParentNode(), \"functions\", true));\n              try {\n                while(_zCursor.moveToNext()) {\n                  SNode foo = _zCursor.getCurrent();\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureReplaceFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFReplaceFunWrapper\"));\n                  } else\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureRemoveFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFRemoveFunWrapper\"));\n                  } else\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureInsertFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFInsertFunWrapper\"));\n                  }\n                }\n              } finally {\n                _zCursor.release();\n              }\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable queryResult = (Iterable)calc.calculate();\n      assert queryResult != null;\n      for(Object item : queryResult) {\n        List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions((ConceptDeclaration)BaseAdapter.fromNode((SNode)item), _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n        result.addAll(defaultActions);\n      }\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.IGenericFeatureFunFragment\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(concept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            List<FragmentTypeEnum> types = ListOperations.<FragmentTypeEnum>createList(FragmentTypeEnum.replace_single, FragmentTypeEnum.replace_selection, FragmentTypeEnum.replace_all, FragmentTypeEnum.remove_single, FragmentTypeEnum.remove_selection, FragmentTypeEnum.remove_all, FragmentTypeEnum.insert_at_start, FragmentTypeEnum.insert_at_end, FragmentTypeEnum.insert_before, FragmentTypeEnum.insert_after);\n            if(SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\")) {\n              {\n                ICursor<SNode> _zCursor1 = CursorFactory.createCursor(SLinkOperations.getTargets(_context.getParentNode(), \"functions\", true));\n                try {\n                  while(_zCursor1.moveToNext()) {\n                    SNode foo = _zCursor1.getCurrent();\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureFunFragment\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.parseValue(SPropertyOperations.getString_def(foo, \"fragmentType\", \"REPLACE_SINGLE\")));\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureReplaceFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_single);\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_selection);\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_all);\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureRemoveFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_single);\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_selection);\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_all);\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureInsertFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_at_start);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_at_end);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_before);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_after);\n                    }\n                  }\n                } finally {\n                  _zCursor1.release();\n                }\n              }\n            }\n            return types;\n          }\n\n        };\n        Iterable<FragmentTypeEnum> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(FragmentTypeEnum item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              FragmentTypeEnum type = ((FragmentTypeEnum)this.getParameterObject());\n              SNode fragment = null;\n              if(type == FragmentTypeEnum.replace_single || type == FragmentTypeEnum.replace_selection || type == FragmentTypeEnum.replace_all) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFReplaceFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFReplacerParamFun\");\n                }\n              } else\n              if(type == FragmentTypeEnum.remove_single || type == FragmentTypeEnum.remove_selection || type == FragmentTypeEnum.remove_all) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFRemoveFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFRemoverParamFun\");\n                }\n              } else\n              if(type == FragmentTypeEnum.insert_at_start || type == FragmentTypeEnum.insert_at_end || type == FragmentTypeEnum.insert_before || type == FragmentTypeEnum.insert_after) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFInsertFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFInserterParamFun\");\n                }\n              }\n              return fragment;\n            }\n\n            public String getMatchingText(String pattern) {\n              return ((FragmentTypeEnum)this.getParameterObject()).getName();\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","id":41178,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_IGenericFeatureFun_1196420410543(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calc = new Calculable() {\n\n        public Object calculate() {\n          List<SNode> res = ListOperations.<SNode>createList(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFReplaceFunWrapper\"), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFRemoveFunWrapper\"), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFInsertFunWrapper\"));\n          if(SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\")) {\n            {\n              ICursor<SNode> _zCursor = CursorFactory.createCursor(SLinkOperations.getTargets(_context.getParentNode(), \"functions\", true));\n              try {\n                while(_zCursor.moveToNext()) {\n                  SNode foo = _zCursor.getCurrent();\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureReplaceFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFReplaceFunWrapper\"));\n                  } else\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureRemoveFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFRemoveFunWrapper\"));\n                  } else\n                  if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureInsertFun\")) {\n                    ListOperations.removeElement(res, SConceptOperations.findConceptDeclaration(\"jetbrains.mps.ypath.structure.GFInsertFunWrapper\"));\n                  }\n                }\n              } finally {\n                _zCursor.release();\n              }\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable queryResult = (Iterable)calc.calculate();\n      assert queryResult != null;\n      for(Object item : queryResult) {\n        List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions((ConceptDeclaration)BaseAdapter.fromNode((SNode)item), _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n        result.addAll(defaultActions);\n      }\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.IGenericFeatureFunFragment\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        Calculable calc = new Calculable() {\n\n          public Object calculate() {\n            List<FragmentTypeEnum> types = ListOperations.<FragmentTypeEnum>createList(FragmentTypeEnum.replace_single, FragmentTypeEnum.replace_selection, FragmentTypeEnum.replace_all, FragmentTypeEnum.remove_single, FragmentTypeEnum.remove_selection, FragmentTypeEnum.remove_all, FragmentTypeEnum.insert_at_start, FragmentTypeEnum.insert_at_end, FragmentTypeEnum.insert_before, FragmentTypeEnum.insert_after);\n            if(SNodeOperations.isInstanceOf(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericFeatureFunHolder\")) {\n              {\n                ICursor<SNode> _zCursor1 = CursorFactory.createCursor(SLinkOperations.getTargets(_context.getParentNode(), \"functions\", true));\n                try {\n                  while(_zCursor1.moveToNext()) {\n                    SNode foo = _zCursor1.getCurrent();\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureFunFragment\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.parseValue(SPropertyOperations.getString_def(foo, \"fragmentType\", \"REPLACE_SINGLE\")));\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureReplaceFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_single);\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_selection);\n                      ListOperations.removeElement(types, FragmentTypeEnum.replace_all);\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureRemoveFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_single);\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_selection);\n                      ListOperations.removeElement(types, FragmentTypeEnum.remove_all);\n                    } else\n                    if(SNodeOperations.isInstanceOf(foo, \"jetbrains.mps.ypath.structure.IGenericFeatureInsertFun\")) {\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_at_start);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_at_end);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_before);\n                      ListOperations.removeElement(types, FragmentTypeEnum.insert_after);\n                    }\n                  }\n                } finally {\n                  _zCursor1.release();\n                }\n              }\n            }\n            return types;\n          }\n\n        };\n        Iterable<FragmentTypeEnum> queryResult = (Iterable)calc.calculate();\n        assert queryResult != null;\n        for(FragmentTypeEnum item : queryResult) {\n          result.add(new DefaultChildNodeSubstituteAction(item, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n            public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n              FragmentTypeEnum type = ((FragmentTypeEnum)this.getParameterObject());\n              SNode fragment = null;\n              if(type == FragmentTypeEnum.replace_single || type == FragmentTypeEnum.replace_selection || type == FragmentTypeEnum.replace_all) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFReplaceFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFReplacerParamFun\");\n                }\n              } else\n              if(type == FragmentTypeEnum.remove_single || type == FragmentTypeEnum.remove_selection || type == FragmentTypeEnum.remove_all) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFRemoveFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFRemoverParamFun\");\n                }\n              } else\n              if(type == FragmentTypeEnum.insert_at_start || type == FragmentTypeEnum.insert_at_end || type == FragmentTypeEnum.insert_before || type == FragmentTypeEnum.insert_after) {\n                fragment = SConceptOperations.createNewNode(\"jetbrains.mps.ypath.structure.GFInsertFunFragment\", null);\n                SPropertyOperations.set(fragment, \"fragmentType\", type.getValue());\n                if((SNodeOperations.getAncestor(_context.getParentNode(), \"jetbrains.mps.ypath.structure.GenericParamFeature\", false, false) != null)) {\n                  SLinkOperations.setNewChild(fragment, \"fragmentFun\", \"jetbrains.mps.ypath.structure.GFInserterParamFun\");\n                }\n              }\n              return fragment;\n            }\n\n            public String getMatchingText(String pattern) {\n              return ((FragmentTypeEnum)this.getParameterObject()).getName();\n            }\n\n          });\n        }\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1180011230210(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.VisitChildrenExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41179,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1180011230210(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.VisitChildrenExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1168893677147(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          return TreePathAspectUtil.getTreePathAspects(_context.getSourceNode(), operationContext.getScope());\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpaExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathAdapterExpression\");\n            SLinkOperations.setTarget(tpaExp, \"expression\", _context.getSourceNode(), true);\n            SLinkOperations.setTarget(tpaExp, \"treepathAspect\", ((SNode)this.getParameterObject()), false);\n            return tpaExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \":\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"[OBSOLETE] cast to treepath expression\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41180,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1168893677147(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          return TreePathAspectUtil.getTreePathAspects(_context.getSourceNode(), operationContext.getScope());\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpaExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathAdapterExpression\");\n            SLinkOperations.setTarget(tpaExp, \"expression\", _context.getSourceNode(), true);\n            SLinkOperations.setTarget(tpaExp, \"treepathAspect\", ((SNode)this.getParameterObject()), false);\n            return tpaExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \":\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"[OBSOLETE] cast to treepath expression\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1198013650231(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          List<Triplet> res = ListOperations.<Triplet>createList();\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          if((tpoe == null)) {\n            return res;\n          }\n          SNode nodeType = SLinkOperations.getTarget(TypeChecker.getInstance().getTypeOf(_context.getSourceNode()), \"nodeType\", true);\n          {\n            ICursor<TraversalAxis> _zCursor3 = CursorFactory.createCursor(TraversalAxis.getConstants());\n            try {\n              while(_zCursor3.moveToNext()) {\n                TraversalAxis axis = _zCursor3.getCurrent();\n                ListOperations.addElement(res, new Triplet(axis, null, null));\n                {\n                  ICursor<SNode> _zCursor4 = CursorFactory.createCursor(TreePath_Behavior.call_getFeature_1184591220431(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), nodeType));\n                  try {\n                    while(_zCursor4.moveToNext()) {\n                      SNode feat = _zCursor4.getCurrent();\n                      if(TraversalAxisUtil.isAcceptableFeatureForAxis(feat, axis)) {\n                        if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                          ListOperations.addElement(res, new Triplet(axis, feat, null));\n                        } else\n                        if(SNodeOperations.isInstanceOf(feat, \"jetbrains.mps.ypath.structure.IParamFeature\")) {\n                          {\n                            ICursor<SNode> _zCursor5 = CursorFactory.createCursor(IParamFeature_Behavior.call_getParameterObjects_1197461148674(feat, nodeType));\n                            try {\n                              while(_zCursor5.moveToNext()) {\n                                SNode pw = _zCursor5.getCurrent();\n                                ListOperations.addElement(res, new Triplet(axis, feat, pw));\n                              }\n                            } finally {\n                              _zCursor5.release();\n                            }\n                          }\n                        } else\n                        {\n                          ListOperations.addElement(res, new Triplet(axis, feat, null));\n                        }\n                      }\n                    }\n                  } finally {\n                    _zCursor4.release();\n                  }\n                }\n              }\n            } finally {\n              _zCursor3.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Triplet> parameterObjects = (Iterable<Triplet>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Triplet parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode op = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mps.ypath.structure.IterateOperation\", null);\n            SPropertyOperations.set(SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.IterateOperation\"), \"axis\", axis.getValue());\n            if((feat != null)) {\n              SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"usedFeature\", feat, false);\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                /*\n                  SPropertyOperations.set(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"useDefault\", \"\" + (true));\n                */\n              } else\n              if((pw != null)) {\n                SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"paramObject\", pw, true);\n              }\n            }\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \" *\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return TraversalAxisUtil.getOperationSign(axis) + suffix;\n          }\n\n          public String getDescriptionText(String text) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \"all\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"default\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\") + \" \" + SPropertyOperations.getString(feat, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return \"iterate \" + axis.getName() + \" @\" + suffix;\n          }\n\n        });\n      }\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n          SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n          SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.WhereOperation\");\n          return tpoExp;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"[\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"where condition\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate3(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode mnko = SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.MatchKindOperation\");\n            SLinkOperations.setTarget(SLinkOperations.getTarget(mnko, \"nodeKindOccurrence\", true), \"nodeKind\", ((SNode)this.getParameterObject()), false);\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \"[ \" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match node kind\";\n          }\n\n        });\n      }\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate4(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode mdpo = SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.MatchDefaultPropertyOperation\");\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \"[[ \" + SPropertyOperations.getString(SNodeOperations.getParent(((SNode)this.getParameterObject()), null, false, false), \"name\") + \".\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match default property\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41181,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1198013650231(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          List<Triplet> res = ListOperations.<Triplet>createList();\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          if((tpoe == null)) {\n            return res;\n          }\n          SNode nodeType = SLinkOperations.getTarget(TypeChecker.getInstance().getTypeOf(_context.getSourceNode()), \"nodeType\", true);\n          {\n            ICursor<TraversalAxis> _zCursor3 = CursorFactory.createCursor(TraversalAxis.getConstants());\n            try {\n              while(_zCursor3.moveToNext()) {\n                TraversalAxis axis = _zCursor3.getCurrent();\n                ListOperations.addElement(res, new Triplet(axis, null, null));\n                {\n                  ICursor<SNode> _zCursor4 = CursorFactory.createCursor(TreePath_Behavior.call_getFeature_1184591220431(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), nodeType));\n                  try {\n                    while(_zCursor4.moveToNext()) {\n                      SNode feat = _zCursor4.getCurrent();\n                      if(TraversalAxisUtil.isAcceptableFeatureForAxis(feat, axis)) {\n                        if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                          ListOperations.addElement(res, new Triplet(axis, feat, null));\n                        } else\n                        if(SNodeOperations.isInstanceOf(feat, \"jetbrains.mps.ypath.structure.IParamFeature\")) {\n                          {\n                            ICursor<SNode> _zCursor5 = CursorFactory.createCursor(IParamFeature_Behavior.call_getParameterObjects_1197461148674(feat, nodeType));\n                            try {\n                              while(_zCursor5.moveToNext()) {\n                                SNode pw = _zCursor5.getCurrent();\n                                ListOperations.addElement(res, new Triplet(axis, feat, pw));\n                              }\n                            } finally {\n                              _zCursor5.release();\n                            }\n                          }\n                        } else\n                        {\n                          ListOperations.addElement(res, new Triplet(axis, feat, null));\n                        }\n                      }\n                    }\n                  } finally {\n                    _zCursor4.release();\n                  }\n                }\n              }\n            } finally {\n              _zCursor3.release();\n            }\n          }\n          return res;\n        }\n\n      };\n      Iterable<Triplet> parameterObjects = (Iterable<Triplet>)calculable.calculate();\n      assert parameterObjects != null;\n      for(Triplet parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode op = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.mps.ypath.structure.IterateOperation\", null);\n            SPropertyOperations.set(SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.IterateOperation\"), \"axis\", axis.getValue());\n            if((feat != null)) {\n              SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"usedFeature\", feat, false);\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                /*\n                  SPropertyOperations.set(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"useDefault\", \"\" + (true));\n                */\n              } else\n              if((pw != null)) {\n                SLinkOperations.setTarget(SLinkOperations.getTarget(tpoExp, \"operation\", true), \"paramObject\", pw, true);\n              }\n            }\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \" *\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return TraversalAxisUtil.getOperationSign(axis) + suffix;\n          }\n\n          public String getDescriptionText(String text) {\n            TraversalAxis axis = (TraversalAxis)((Triplet)this.getParameterObject()).first();\n            SNode feat = (SNode)((Triplet)this.getParameterObject()).second();\n            SNode pw = (SNode)((Triplet)this.getParameterObject()).third();\n            String suffix = \"\";\n            if((feat == null)) {\n              suffix = \"all\";\n            } else\n            {\n              if(SPropertyOperations.getBoolean(feat, \"default\")) {\n                suffix = \"default\";\n              } else\n              if((pw != null)) {\n                suffix = SPropertyOperations.getString(pw, \"name\") + \" \" + SPropertyOperations.getString(feat, \"name\");\n              } else\n              {\n                suffix = SPropertyOperations.getString(feat, \"name\");\n              }\n            }\n            return \"iterate \" + axis.getName() + \" @\" + suffix;\n          }\n\n        });\n      }\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n          SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n          SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.WhereOperation\");\n          return tpoExp;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"[\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"where condition\";\n        }\n\n      });\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate3(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode mnko = SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.MatchKindOperation\");\n            SLinkOperations.setTarget(SLinkOperations.getTarget(mnko, \"nodeKindOccurrence\", true), \"nodeKind\", ((SNode)this.getParameterObject()), false);\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \"[ \" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match node kind\";\n          }\n\n        });\n      }\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.ypath.structure.TreePathOperationExpression\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          SNode tpoe = SNodeOperations.getAncestor(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\", true, false);\n          return SequenceOperations.toList(SequenceOperations.where(SNodeOperations.getDescendants(ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe), null, false), new zPredicate4(null, null)));\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode tpoExp = SNodeOperations.replaceWithNewChild(_context.getSourceNode(), \"jetbrains.mps.ypath.structure.TreePathOperationExpression\");\n            SLinkOperations.setTarget(tpoExp, \"expression\", _context.getSourceNode(), true);\n            SNode mdpo = SLinkOperations.setNewChild(tpoExp, \"operation\", \"jetbrains.mps.ypath.structure.MatchDefaultPropertyOperation\");\n            return tpoExp;\n          }\n\n          public String getMatchingText(String text) {\n            return \"[[ \" + SPropertyOperations.getString(SNodeOperations.getParent(((SNode)this.getParameterObject()), null, false, false), \"name\") + \".\" + SPropertyOperations.getString(((SNode)this.getParameterObject()), \"name\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"match default property\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1187360495057(final IOperationContext operationContext, final RTActionsBuilderContext _parameterObject) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _parameterObject.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_parameterObject.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_parameterObject.getModel(), \"jetbrains.accounting.money.structure.MoneyGetCurrencyMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_parameterObject.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _parameterObject.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _parameterObject.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". currency\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"get currency\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _parameterObject.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_parameterObject.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_parameterObject.getModel(), \"jetbrains.accounting.money.structure.MoneyIsZeroMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_parameterObject.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _parameterObject.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _parameterObject.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". isZero\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"compare to zero\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _parameterObject.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_parameterObject.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_parameterObject.getModel(), \"jetbrains.accounting.money.structure.MoneyGetAmountMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_parameterObject.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _parameterObject.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _parameterObject.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". amount\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"get amount\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41182,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1187360495057(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_context.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.accounting.money.structure.MoneyGetCurrencyMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_context.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _context.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _context.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". currency\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"get currency\";\n        }\n\n      });\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_context.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.accounting.money.structure.MoneyIsZeroMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_context.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _context.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _context.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". isZero\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"compare to zero\";\n        }\n\n      });\n    }\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Expression\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          if(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_context.getSourceNode()), \"jetbrains.accounting.money.structure.MoneyType\")) {\n            SNode mgcmc = SModelOperations.createNewNode(_context.getModel(), \"jetbrains.accounting.money.structure.MoneyGetAmountMethodCall\", null);\n            SNodeOperations.replaceWithAnother(_context.getSourceNode(), mgcmc);\n            SLinkOperations.setTarget(mgcmc, \"instance\", _context.getSourceNode(), true);\n            return mgcmc;\n          }\n          return _context.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". amount\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"get amount\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1197638405577(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          return SConceptOperations.getAllSubConcepts(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.BinaryExpression\"), _context.getModel(), operationContext.getScope());\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode target = _context.getSourceNode();\n            while(true) {\n              if(SNodeOperations.isInstanceOf(SNodeOperations.getParent(target, null, false, false), \"jetbrains.mps.nanoj.structure.BinaryExpression\")) {\n                SNode concept = SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(target, null, false, false));\n                if(SConceptPropertyOperations.getInteger(((SNode)this.getParameterObject()), \"priority\") < SConceptPropertyOperations.getInteger(concept, \"priority\")) {\n                  target = SNodeOperations.getParent(target, null, false, false);\n                } else\n                {\n                  break;\n                }\n              } else\n              {\n                break;\n              }\n            }\n            SNode result = SConceptOperations.createNewNode(NameUtil.nodeFQName(((SNode)this.getParameterObject())), null);\n            SNodeOperations.replaceWithAnother(target, result);\n            SLinkOperations.setTarget(result, \"leftPart\", target, true);\n            return result;\n          }\n\n          public String getMatchingText(String text) {\n            return SConceptPropertyOperations.getString(((SNode)this.getParameterObject()), \"sign\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"binary operation\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","id":41183,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1197638405577(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      Calculable calculable = new Calculable() {\n\n        public Object calculate() {\n          return SConceptOperations.getAllSubConcepts(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.BinaryExpression\"), _context.getModel(), operationContext.getScope());\n        }\n\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>)calculable.calculate();\n      assert parameterObjects != null;\n      for(SNode parameter : parameterObjects) {\n        result.add(new AbstractRTransformHintSubstituteAction(parameter, _context.getSourceNode()) {\n\n          public SNode doSubstitute(String pattern) {\n            SNode target = _context.getSourceNode();\n            while(true) {\n              if(SNodeOperations.isInstanceOf(SNodeOperations.getParent(target, null, false, false), \"jetbrains.mps.nanoj.structure.BinaryExpression\")) {\n                SNode concept = SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(target, null, false, false));\n                if(SConceptPropertyOperations.getInteger(((SNode)this.getParameterObject()), \"priority\") < SConceptPropertyOperations.getInteger(concept, \"priority\")) {\n                  target = SNodeOperations.getParent(target, null, false, false);\n                } else\n                {\n                  break;\n                }\n              } else\n              {\n                break;\n              }\n            }\n            SNode result = SConceptOperations.createNewNode(NameUtil.nodeFQName(((SNode)this.getParameterObject())), null);\n            SNodeOperations.replaceWithAnother(target, result);\n            SLinkOperations.setTarget(result, \"leftPart\", target, true);\n            return result;\n          }\n\n          public String getMatchingText(String text) {\n            return SConceptPropertyOperations.getString(((SNode)this.getParameterObject()), \"sign\");\n          }\n\n          public String getDescriptionText(String text) {\n            return \"binary operation\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_LocalVariableDeclaration_1197638405464(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41184,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_LocalVariableDeclaration_1197638405464(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197638405388(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Expression\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          int value = Integer.parseInt(pattern);\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.NumberExpression\", null);\n          SPropertyOperations.set(result, \"number\", \"\" + (value));\n          return result;\n        }\n\n        public boolean hasSubstitute() {\n          return true;\n        }\n\n        public boolean canSubstitute_internal(String pattern) {\n          return _PrecompiledPatterns.REGEXP.matcher(pattern).matches();\n        }\n\n      });\n    }\n    return result;\n  }","id":41185,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Expression_1197638405388(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Expression\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            int value = Integer.parseInt(pattern);\n            SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.NumberExpression\", null);\n            SPropertyOperations.set(result, \"number\", \"\" + (value));\n            return result;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern) {\n            return _PrecompiledPatterns.REGEXP.matcher(pattern).matches();\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterDeclaration_1197638405485(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.ParameterDeclaration\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.ParameterDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41186,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ParameterDeclaration_1197638405485(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.ParameterDeclaration\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.ParameterDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_FieldDeclaration_1197638405506(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.FieldDeclaration\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.FieldDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41187,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_FieldDeclaration_1197638405506(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.FieldDeclaration\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Type\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.FieldDeclaration\", null);\n          SLinkOperations.setTarget(result, \"type\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197638405443(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Statement\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Expression\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.ExpressionStatement\", null);\n          SLinkOperations.setTarget(result, \"expr\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41188,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197638405443(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Statement\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Expression\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.ExpressionStatement\", null);\n          SLinkOperations.setTarget(result, \"expr\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197638405422(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.Statement\", operationContext.getScope());\n      ConceptDeclaration wrappedConcept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.LocalVariableDeclarationStatement\", null);\n          SLinkOperations.setTarget(result, \"declaration\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","id":41189,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_Statement_1197638405422(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.Statement\", operationContext.getScope());\n      AbstractConceptDeclaration wrappedConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.LocalVariableDeclaration\", operationContext.getScope());\n      IChildNodeSetter setter = new AbstractChildNodeSetter() {\n\n        public SNode wrapNode(SNode nodeToWrap, SModel model) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.nanoj.structure.LocalVariableDeclarationStatement\", null);\n          SLinkOperations.setTarget(result, \"declaration\", nodeToWrap, true);\n          return result;\n        }\n\n        public SNode doExecute(SNode pn, SNode oc, SNode nc, IScope sc) {\n          SNode wrappedNode = this.wrapNode(nc, nc.getModel());\n          _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedNode, operationContext.getScope());\n          return wrappedNode;\n        }\n\n      };\n      result.addAll(ModelActions.createChildSubstituteActions(_context.getParentNode(), _context.getCurrentTargetNode(), wrappedConcept, setter, operationContext));\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1197638405527(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode dotConceptInstance = SConceptOperations.createNewNode(\"jetbrains.mps.nanoj.structure.DotExpression\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), dotConceptInstance);\n          SLinkOperations.setTarget(dotConceptInstance, \"leftPart\", _context.getSourceNode(), true);\n          return dotConceptInstance;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". dot\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41190,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_Expression_1197638405527(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"null\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode dotConceptInstance = SConceptOperations.createNewNode(\"jetbrains.mps.nanoj.structure.DotExpression\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), dotConceptInstance);\n          SLinkOperations.setTarget(dotConceptInstance, \"leftPart\", _context.getSourceNode(), true);\n          return dotConceptInstance;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \". dot\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ExpressionDotOperation_1197638405562(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.nanoj.structure.ClassAccess\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41191,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_ExpressionDotOperation_1197638405562(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.nanoj.structure.ClassAccess\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_PropertyValueExpression_1197109326624(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.PlusOperation\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode newNode = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.PlusOperation\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), newNode);\n          SLinkOperations.setTarget(newNode, \"left\", _context.getSourceNode(), true);\n          return newNode;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"+\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"plus operation\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41192,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_PropertyValueExpression_1197109326624(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.PlusOperation\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SNode newNode = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.PlusOperation\", null);\n          SNodeOperations.replaceWithAnother(_context.getSourceNode(), newNode);\n          SLinkOperations.setTarget(newNode, \"left\", _context.getSourceNode(), true);\n          return newNode;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"+\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"plus operation\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1197476868571(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.IntLiteral\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode newNode = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.IntLiteral\", null);\n          SPropertyOperations.set(newNode, \"value\", \"\" + (Integer.parseInt(pattern)));\n          return newNode;\n        }\n\n        public boolean hasSubstitute() {\n          return true;\n        }\n\n        public boolean canSubstitute_internal(String pattern) {\n          return _PrecompiledPatterns.REGEXP.matcher(pattern).matches();\n        }\n\n        public String getMatchingText(String pattern) {\n          return pattern;\n        }\n\n      });\n    }\n    return result;\n  }","id":41193,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1197476868571(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.IntLiteral\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode newNode = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.IntLiteral\", null);\n            SPropertyOperations.set(newNode, \"value\", \"\" + (Integer.parseInt(pattern)));\n            return newNode;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern) {\n            return _PrecompiledPatterns.REGEXP.matcher(pattern).matches();\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1196869262792(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", null);\n          SPropertyOperations.set(result, \"value\", \"\" + (true));\n          return result;\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"true literal\";\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"true\";\n        }\n\n      });\n    }\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", operationContext.getScope());\n      result.add(new DefaultSimpleSubstituteAction(concept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n        public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n          SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", null);\n          SPropertyOperations.set(result, \"value\", \"\" + (false));\n          return result;\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"false literal\";\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"false\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41194,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1196869262792(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (true));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"true literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"true\";\n          }\n\n        });\n      }\n    }\n    {\n      AbstractConceptDeclaration outputConcept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", operationContext.getScope());\n      SNode childConcept = (SNode)_context.getChildConcept();\n      if(outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName((SNode)BaseAdapter.fromAdapter(outputConcept)))) {\n        result.add(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SModelOperations.createNewNode(model, \"jetbrains.mps.buildlanguage.structure.BooleanLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (false));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"false literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"false\";\n          }\n\n        });\n      }\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_ICommented_1201259672003(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.ICommented\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SPropertyOperations.set(_context.getSourceNode(), \"shortDescription\", \"\");\n          return _context.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"//\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"comment\";\n        }\n\n      });\n    }\n    return result;\n  }","id":41195,"modified_method":"public static List<INodeSubstituteAction> rightTransform_ActionsFactory_ICommented_1201259672003(final IOperationContext operationContext, final RTActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      AbstractConceptDeclaration concept = SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.ICommented\", operationContext.getScope());\n      result.add(new AbstractRTransformHintSubstituteAction(BaseAdapter.fromAdapter(concept), _context.getSourceNode()) {\n\n        public SNode doSubstitute(String pattern) {\n          SPropertyOperations.set(_context.getSourceNode(), \"shortDescription\", \"\");\n          return _context.getSourceNode();\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"//\";\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"comment\";\n        }\n\n      });\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1201708832142(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.TagetReferencePropertyValueExpression\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.CallReference\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = SModelUtil_new.findConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.StringLiteral\", operationContext.getScope());\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","id":41196,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_PropertyValueExpression_1201708832142(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = new ArrayList<INodeSubstituteAction>();\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.TagetReferencePropertyValueExpression\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.CallReference\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    {\n      ConceptDeclaration conceptToAdd = ((ConceptDeclaration)SModelUtil_new.findAbstractConceptDeclaration(\"jetbrains.mps.buildlanguage.structure.StringLiteral\", operationContext.getScope()));\n      List<INodeSubstituteAction> defaultActions = ChildSubstituteActionsHelper.createDefaultActions(conceptToAdd, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext);\n      result.addAll(defaultActions);\n    }\n    return result;\n  }","commit_id":"021b4a00c634cb1c92ef20275ba4e5ac5c7fa48c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (dep instanceof ModuleClassLoader) {\n        if (dep == this) continue;\n\n        if (((ModuleClassLoader) dep).mySupport.canFindClass(name)) {\n          //here it will load with self, with any values as two last parameters\n          return Class.forName(name, false, dep);\n        }\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (!(dep instanceof ModuleClassLoader)) {\n        try {\n          return Class.forName(name, false, dep);\n        } catch (ClassNotFoundException e) {\n          //ignore\n        }\n      }\n    }\n\n    boolean contains = getDependencyClassLoaders().contains(getParent());\n    if (!contains) throw new ClassNotFoundException(name);\n\n    return loadFromParent(name);\n  }","id":41197,"modified_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (dep instanceof ModuleClassLoader) {\n        if (dep == this) continue;\n\n        if (((ModuleClassLoader) dep).mySupport.canFindClass(name)) {\n          //here it will load with self, with any values as two last parameters\n          return Class.forName(name, false, dep);\n        }\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (!(dep instanceof ModuleClassLoader)) {\n        try {\n          return Class.forName(name, false, dep);\n        } catch (ClassNotFoundException e) {\n          //ignore\n        }\n      }\n    }\n\n    return getDependencyClassLoaders().contains(getParent()) ? null : loadFromParent(name);\n  }","commit_id":"045957e5cb284a4a317ceb6c0e0f8a51e179ccb4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    List<IClassLoadingModule> queue = new ArrayList<IClassLoadingModule>();\n    for (IClassLoadingModule m : myModule.getClassLoadingDependencies()) {\n      if (m.equals(myModule)) continue;\n      if (!m.canLoad()) continue;\n\n      if (m.canLoadFromSelf() && m.canFindClass(name)) {\n        //here it will load with self, with any values as two last parameters\n        return m.getClassLoader().loadFromSelf(name);\n      } else {\n        queue.add(m);\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (IClassLoadingModule m : queue) {\n      try {\n        return m.getClassLoader().loadFromParent(name);\n      } catch (ClassNotFoundException e) {\n        //ignore\n      }\n    }\n    return loadFromParent(name);\n  }","id":41198,"modified_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    List<IClassLoadingModule> queue = new ArrayList<IClassLoadingModule>();\n    for (IClassLoadingModule m : myModule.getClassLoadingDependencies()) {\n      if (m.equals(myModule)) continue;\n      if (!m.canLoad()) continue;\n\n      if (m.canLoadFromSelf() && m.canFindClass(name)) {\n        //here it will load with self, with any values as two last parameters\n        return m.getClassLoader().loadFromSelf(name);\n      } else {\n        queue.add(m);\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    Set<ClassLoader> processedParentClassLoaders = new HashSet<ClassLoader>();\n    for (IClassLoadingModule m : queue) {\n      try {\n        ModuleClassLoader classLoader = m.getClassLoader();\n        if (processedParentClassLoaders.contains(classLoader.getParent())) {\n          continue;\n        }\n        processedParentClassLoaders.add(classLoader.getParent());\n        return classLoader.loadFromParent(name);\n      } catch (ClassNotFoundException e) {\n        //ignore\n      }\n    }\n    return processedParentClassLoaders.contains(getParent()) ? null : loadFromParent(name);\n  }","commit_id":"84e26aadeb318a37b5d6fe1e0b779986c2714ab2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (dep instanceof ModuleClassLoader) {\n        if (dep == this) continue;\n\n        if (((ModuleClassLoader) dep).mySupport.canFindClass(name)) {\n          //here it will load with self, with any values as two last parameters\n          return Class.forName(name, false, dep);\n        }\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (!(dep instanceof ModuleClassLoader)) {\n        try {\n          return Class.forName(name, false, dep);\n        } catch (ClassNotFoundException e) {\n          //ignore\n        }\n      }\n    }\n\n    return getDependencyClassLoaders().contains(getParent()) ? null : loadFromParent(name);\n  }","id":41199,"modified_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (dep instanceof ModuleClassLoader) {\n        if (dep == this) continue;\n\n        if (((ModuleClassLoader) dep).mySupport.canFindClass(name)) {\n          //here it will load with self, with any values as two last parameters\n          return Class.forName(name, false, dep);\n        }\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (ClassLoader dep : getDependencyClassLoaders()) {\n      if (!(dep instanceof ModuleClassLoader)) {\n        try {\n          return Class.forName(name, false, dep);\n        } catch (ClassNotFoundException e) {\n          //ignore\n        }\n      }\n    }\n\n    boolean contains = getDependencyClassLoaders().contains(getParent());\n    if (!contains) throw new ClassNotFoundException(name);\n\n    return loadFromParent(name);\n  }","commit_id":"1b829b85fde4af1d6e33f11a6444f5d7afad8ae4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    List<IClassLoadingModule> queue = new ArrayList<IClassLoadingModule>();\n    for (IClassLoadingModule m : myModule.getClassLoadingDependencies()) {\n      if (m.equals(myModule)) continue;\n      if (!m.canLoad()) continue;\n\n      if (m.canLoadFromSelf() && m.canFindClass(name)) {\n        //here it will load with self, with any values as two last parameters\n        return m.getClassLoader().loadFromSelf(name);\n      } else {\n        queue.add(m);\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    for (IClassLoadingModule m : queue) {\n      try {\n        return m.getClassLoader().loadFromParent(name);\n      } catch (ClassNotFoundException e) {\n        //ignore\n      }\n    }\n    return loadFromParent(name);\n  }","id":41200,"modified_method":"private Class<?> findInSelfAndDependencies(String name) throws ClassNotFoundException {\n    //from self\n    Class c = loadFromSelf(name);\n    if (c != null) {\n      return c;\n    }\n\n    //from dependencies (try modules only)\n    List<IClassLoadingModule> queue = new ArrayList<IClassLoadingModule>();\n    for (IClassLoadingModule m : myModule.getClassLoadingDependencies()) {\n      if (m.equals(myModule)) continue;\n      if (!m.canLoad()) continue;\n\n      if (m.canLoadFromSelf() && m.canFindClass(name)) {\n        //here it will load with self, with any values as two last parameters\n        return m.getClassLoader().loadFromSelf(name);\n      } else {\n        queue.add(m);\n      }\n    }\n\n    //from dependencies (try parent class loaders also)\n    Set<ClassLoader> processedParentClassLoaders = new HashSet<ClassLoader>();\n    for (IClassLoadingModule m : queue) {\n      try {\n        ModuleClassLoader classLoader = m.getClassLoader();\n        if (processedParentClassLoaders.contains(classLoader.getParent())) {\n          continue;\n        }\n        processedParentClassLoaders.add(classLoader.getParent());\n        return classLoader.loadFromParent(name);\n      } catch (ClassNotFoundException e) {\n        //ignore\n      }\n    }\n    return processedParentClassLoaders.contains(getParent()) ? null : loadFromParent(name);\n  }","commit_id":"fecb3a57672990743e8d6d4080e254ee2aec9d24","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testParse128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41201,"modified_method":"@Test\n    public void testParse128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41202,"modified_method":"@Test\n    public void testParse126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        TextFrame textFrame = (TextFrame)FrameBuilder.text(\"\").asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(10);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":41203,"modified_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        WebSocketFrame textFrame = FrameBuilder.text(\"\").asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(10);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParseEmptyTextCase1_1_1()\n    {\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(0));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",0,pActual.getPayload());\n    }","id":41204,"modified_method":"@Test\n    public void testParseEmptyTextCase1_1_1()\n    {\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(0));\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41205,"modified_method":"@Test\n    public void testParse65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65535ByteTextCase1_1_6()\n    {\n        // Debug.enableDebugLogging(Parser.class);\n        // Debug.enableDebugLogging(TextPayloadParser.class);\n\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41206,"modified_method":"@Test\n    public void testParse65535ByteTextCase1_1_6()\n    {\n        // Debug.enableDebugLogging(Parser.class);\n        // Debug.enableDebugLogging(TextPayloadParser.class);\n\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41207,"modified_method":"@Test\n    public void testParse125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame pActual = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        ByteBufferAssert.assertSize(\"TextFrame.payload\",length,pActual.getPayload());\n    }","id":41208,"modified_method":"@Test\n    public void testParse127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"85982199e71dabce9c606a2cb4c07efcbfd267a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGameOver()\n    {\n        String expectedReason = \"Game Over\";\n\n        byte utf[] = expectedReason.getBytes(StringUtil.__UTF8_CHARSET);\n        ByteBuffer payload = ByteBuffer.allocate(utf.length + 2);\n        payload.putChar((char)StatusCode.NORMAL);\n        payload.put(utf,0,utf.length);\n        payload.flip();\n\n        ByteBuffer buf = ByteBuffer.allocate(24);\n        buf.put((byte)(0x80 | OpCode.CLOSE.getCode())); // fin + close\n        buf.put((byte)(0x80 | payload.remaining()));\n        MaskedByteBuffer.putMask(buf);\n        MaskedByteBuffer.putPayload(buf,payload);\n        buf.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(CloseFrame.class,1);\n        CloseFrame close = (CloseFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"CloseFrame.statusCode\",close.getStatusCode(),is(StatusCode.NORMAL));\n        Assert.assertThat(\"CloseFrame.data\",close.getReason(),is(expectedReason));\n    }","id":41209,"modified_method":"@Test\n    public void testGameOver()\n    {\n        String expectedReason = \"Game Over\";\n\n        byte utf[] = expectedReason.getBytes(StringUtil.__UTF8_CHARSET);\n        ByteBuffer payload = ByteBuffer.allocate(utf.length + 2);\n        payload.putChar((char)StatusCode.NORMAL);\n        payload.put(utf,0,utf.length);\n        payload.flip();\n\n        ByteBuffer buf = ByteBuffer.allocate(24);\n        buf.put((byte)(0x80 | OpCode.CLOSE.getCode())); // fin + close\n        buf.put((byte)(0x80 | payload.remaining()));\n        MaskedByteBuffer.putMask(buf);\n        MaskedByteBuffer.putPayload(buf,payload);\n        buf.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.CLOSE,1);\n        CloseInfo close = new CloseInfo(capture.getFrames().get(0));\n        Assert.assertThat(\"CloseFrame.statusCode\",close.getStatusCode(),is(StatusCode.NORMAL));\n        Assert.assertThat(\"CloseFrame.data\",close.getReason(),is(expectedReason));\n    }","commit_id":"3c8206e6bfebe004fe13fa6cf73ae058471f3aa1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            TextFrame txt = (TextFrame)FrameBuilder.text().payload(message.getBytes()).asFrame();\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            txt.setMask(mask);\n\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            gen.generate(out,txt);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,1);\n\n        TextFrame txt = (TextFrame)capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadUTF8(),is(message));\n    }","id":41210,"modified_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            WebSocketFrame txt = FrameBuilder.text().payload(message.getBytes()).asFrame();\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            txt.setMask(mask);\n\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            gen.generate(out,txt);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","commit_id":"3c8206e6bfebe004fe13fa6cf73ae058471f3aa1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_InputStream()\n    {\n        AnnotatedBinaryStreamSocket socket = new AnnotatedBinaryStreamSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(new CloseFrame(StatusCode.NORMAL));\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEventRegex(1,\"^onBinary\\\\(.*InputStream.*\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","id":41211,"modified_method":"@Test\n    public void testAnnotated_InputStream()\n    {\n        AnnotatedBinaryStreamSocket socket = new AnnotatedBinaryStreamSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEventRegex(1,\"^onBinary\\\\(.*InputStream.*\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_Frames()\n    {\n        AnnotatedFramesSocket socket = new AnnotatedFramesSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(new PingFrame(StringUtil.getUtf8Bytes(\"PING\")));\n        driver.onFrame(FrameBuilder.text().payload(\"Text Me\").asFrame());\n        driver.onFrame(FrameBuilder.binary().payload(StringUtil.getUtf8Bytes(\"Hello Bin\")).asFrame());\n        driver.onFrame(new CloseFrame(StatusCode.SHUTDOWN));\n\n        socket.capture.assertEventCount(6);\n        socket.capture.assertEventStartsWith(0,\"onConnect(\");\n        socket.capture.assertEventStartsWith(1,\"onFrame(Ping\");\n        socket.capture.assertEventStartsWith(2,\"onFrame(Text\");\n        socket.capture.assertEventStartsWith(3,\"onFrame(Binary\");\n        socket.capture.assertEventStartsWith(4,\"onFrame(Close\");\n        socket.capture.assertEventStartsWith(5,\"onClose(1001,\");\n    }","id":41212,"modified_method":"@Test\n    public void testAnnotated_Frames()\n    {\n        AnnotatedFramesSocket socket = new AnnotatedFramesSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.ping(\"PING\").asFrame());\n        driver.onFrame(FrameBuilder.text().payload(\"Text Me\").asFrame());\n        driver.onFrame(FrameBuilder.binary().payload(StringUtil.getUtf8Bytes(\"Hello Bin\")).asFrame());\n        driver.onFrame(FrameBuilder.close(StatusCode.SHUTDOWN).asFrame());\n\n        socket.capture.assertEventCount(6);\n        socket.capture.assertEventStartsWith(0,\"onConnect(\");\n        socket.capture.assertEventStartsWith(1,\"onFrame(Ping\");\n        socket.capture.assertEventStartsWith(2,\"onFrame(Text\");\n        socket.capture.assertEventStartsWith(3,\"onFrame(Binary\");\n        socket.capture.assertEventStartsWith(4,\"onFrame(Close\");\n        socket.capture.assertEventStartsWith(5,\"onClose(1001,\");\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAdapter_ConnectClose()\n    {\n        AdapterConnectCloseSocket socket = new AdapterConnectCloseSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(new CloseFrame(StatusCode.NORMAL));\n\n        socket.capture.assertEventCount(2);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketClose\");\n    }","id":41213,"modified_method":"@Test\n    public void testAdapter_ConnectClose()\n    {\n        AdapterConnectCloseSocket socket = new AdapterConnectCloseSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(2);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketClose\");\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_ByteArray()\n    {\n        AnnotatedBinaryArraySocket socket = new AnnotatedBinaryArraySocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(new CloseFrame(StatusCode.NORMAL));\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEvent(1,\"onBinary([11],0,11)\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","id":41214,"modified_method":"@Test\n    public void testAnnotated_ByteArray()\n    {\n        AnnotatedBinaryArraySocket socket = new AnnotatedBinaryArraySocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEvent(1,\"onBinary([11],0,11)\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testListener_Text()\n    {\n        ListenerBasicSocket socket = new ListenerBasicSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.text(\"Hello World\").asFrame());\n        driver.onFrame(new CloseFrame(StatusCode.NORMAL));\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketText(\\\"Hello World\\\")\");\n        socket.capture.assertEventStartsWith(2,\"onWebSocketClose(1000,\");\n    }","id":41215,"modified_method":"@Test\n    public void testListener_Text()\n    {\n        ListenerBasicSocket socket = new ListenerBasicSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.text(\"Hello World\").asFrame());\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketText(\\\"Hello World\\\")\");\n        socket.capture.assertEventStartsWith(2,\"onWebSocketClose(1000,\");\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private BinaryFrame makeBinaryFrame(String content, boolean fin)\n    {\n        BinaryFrame bin = (BinaryFrame)FrameBuilder.binary().fin(fin).payload((content.getBytes(StringUtil.__UTF8_CHARSET))).asFrame();\n        return bin;\n    }","id":41216,"modified_method":"private WebSocketFrame makeBinaryFrame(String content, boolean fin)\n    {\n        return FrameBuilder.binary().fin(fin).payload((content.getBytes(StringUtil.__UTF8_CHARSET))).asFrame();\n    }","commit_id":"cbfe922fe1370d1a02bed10c2469d7e2b84e0543","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public int getNonce(int id, NONCE_TYPE type) throws RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"INSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\",\n        DBUtils.Nonce.TABLE_NAME,\n        DBUtils.Nonce.NONCE_ID_COLUMN, DBUtils.Nonce.ID_COLUMN, DBUtils.Nonce.NONCE_EXPIRES_AT_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      int nonce = NonceUtils.getNonce();\n      ps.setInt(1, nonce);\n      ps.setInt(2, id);\n      if (type.equals(NONCE_TYPE.SESSION)) {\n        ps.setTimestamp(3, new java.sql.Timestamp(System.currentTimeMillis() + SESSION_EXPIRATION_MILLS));\n      } else if (type.equals(NONCE_TYPE.ACTIVATION)) {\n        ps.setTimestamp(3, new java.sql.Timestamp(System.currentTimeMillis() + ACTIVATION_EXPIRATION_MILLIS));\n      } else {\n        throw new RuntimeException(\"Unknown nonce type\");\n      }\n      ps.executeUpdate();\n\n      return nonce;\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n  }","id":41217,"modified_method":"@Override\n  public int getNonce(int id, NONCE_TYPE type) {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    int nonce= -1;\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"INSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\",\n        DBUtils.Nonce.TABLE_NAME,\n        DBUtils.Nonce.NONCE_ID_COLUMN, DBUtils.Nonce.ID_COLUMN, DBUtils.Nonce.NONCE_EXPIRES_AT_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      nonce = NonceUtils.getNonce();\n      ps.setInt(1, nonce);\n      ps.setInt(2, id);\n      if (type.equals(NONCE_TYPE.SESSION)) {\n        ps.setTimestamp(3, new java.sql.Timestamp(System.currentTimeMillis() + SESSION_EXPIRATION_MILLS));\n      } else if (type.equals(NONCE_TYPE.ACTIVATION)) {\n        ps.setTimestamp(3, new java.sql.Timestamp(System.currentTimeMillis() + ACTIVATION_EXPIRATION_MILLIS));\n      } else {\n        throw new RuntimeException(\"Unknown nonce type\");\n      }\n      ps.executeUpdate();\n\n\n\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps);\n      return nonce;\n    }\n  }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int getId(int nonce, NONCE_TYPE type) throws RuntimeException, StaleNonceException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.Nonce.ID_COLUMN,\n        DBUtils.Nonce.NONCE_EXPIRES_AT_COLUMN,\n        DBUtils.Nonce.TABLE_NAME,\n        DBUtils.Nonce.NONCE_ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, nonce);\n      ResultSet rs = ps.executeQuery();\n\n      int id = -1;\n      int count = 0;\n      while (rs.next()) {\n        id = rs.getInt(1);\n        Timestamp t = rs.getTimestamp(2);\n        if (t.getTime() < System.currentTimeMillis()) {\n          throw new StaleNonceException(\"Older timestamp\");\n        }\n        count++;\n        if (count > 1) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple nonce with same  ID\");\n        }\n      }\n      return id;\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n  }","id":41218,"modified_method":"@Override\n  public int getId(int nonce, NONCE_TYPE type) throws StaleNonceException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    int id = -1;\n\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.Nonce.ID_COLUMN,\n        DBUtils.Nonce.NONCE_EXPIRES_AT_COLUMN,\n        DBUtils.Nonce.TABLE_NAME,\n        DBUtils.Nonce.NONCE_ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, nonce);\n      ResultSet rs = ps.executeQuery();\n\n      int count = 0;\n      while (rs.next()) {\n        id = rs.getInt(1);\n        Timestamp t = rs.getTimestamp(2);\n        if (t.getTime() < System.currentTimeMillis()) {\n          throw new StaleNonceException(\"Older timestamp\");\n        }\n        count++;\n        if (count > 1) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple nonce with same  ID\");\n        }\n      }\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps);\n      return id;\n    }\n }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public VPC getVPC(int accountId, int vpcId) throws RuntimeException, ConfigurationException {\n    VPC vpc = null;\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s WHERE %s = ? and %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN, //WHERE\n        DBUtils.VPC.VPC_ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      ps.setInt(2, vpcId);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n      }\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpc;\n  }","id":41219,"modified_method":"@Override\n  public VPC getVPC(int accountId, int vpcId) throws ConfigurationException {\n    VPC vpc = null;\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s WHERE %s = ? and %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN, //WHERE\n        DBUtils.VPC.VPC_ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      ps.setInt(2, vpcId);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n      }\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpc;\n  }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws RuntimeException, ConfigurationException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.VPC_ID_COLUMN,\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.NAME_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.AccountTable.TABLE_NAME, //JOIN\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.API_KEY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, apiKey);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n      }\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","id":41220,"modified_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws ConfigurationException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.VPC_ID_COLUMN,\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.NAME_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.AccountTable.TABLE_NAME, //JOIN\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.API_KEY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, apiKey);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n      }\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n    throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format(\"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n        DBUtils.VPCRole.TABLE_NAME,\n        DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n        DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5, overrides);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":41221,"modified_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n    throws ConfigurationException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format(\"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n        DBUtils.VPCRole.TABLE_NAME,\n        DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n        DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5, overrides);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps);\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(int accountId) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n      }\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","id":41222,"modified_method":"@Override\n  public List<VPC> getVPC(int accountId) throws ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n      }\n    } catch (SQLException e) {\n      Throwables.propagate(e);\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","commit_id":"bb8712e2eed143d794742e613004d70ae08689fe","url":"https://github.com/caskdata/cdap"},{"original_method":"public byte[] getDotImage(int hashCode, String content, String extension, boolean dot) throws IOException\n    {\n        File dfile = getTempFile(hashCode, \"dot\", dot);\n        if (!dfile.exists()) {\n            FileWriter fwriter = new FileWriter(dfile);\n            fwriter.write(content);\n            fwriter.flush();\n            fwriter.close();\n        }\n\n        File ofile = getTempFile(hashCode, extension, dot);\n        if (!ofile.exists()) {\n            Runtime rt = Runtime.getRuntime();\n            String[] command = new String[5];\n            command[0] = dot ? this.dotPath : this.neatoPath;\n            command[1] = \"-T\" + extension;\n            command[2] = dfile.getAbsolutePath();\n            command[3] = \"-o\";\n            command[4] = ofile.getAbsolutePath();\n            Process p = rt.exec(command);\n            try {\n                int i = 0;\n                int max = 10;\n                for (i = 0; i < max; i++) {\n                    Thread.sleep(1000);\n                    try {\n                        p.exitValue();\n                        break;\n                    } catch (IllegalThreadStateException e) {\n                    }\n                }\n                // No more than 10 seconds to generate graph\n                // Force killing\n                if (i >= max) {\n                    p.destroy();\n                }\n            } catch (InterruptedException e) {\n                mLogger.error(\"Error while generating image from dot\", e);\n            }\n\n            if (p.exitValue() != 0) {\n                BufferedReader os = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                StringBuffer error = new StringBuffer();\n                while (os.ready()) {\n                    error.append(os.readLine());\n                }\n                mLogger.error(\"Error while generating image from dot: \" + error.toString());\n            }\n        }\n        FileInputStream fis = new FileInputStream(ofile);\n        try {\n            byte[] result = new byte[(int) ofile.length()];\n            fis.read(result);\n            return result;\n        } finally {\n            fis.close();\n        }\n    }","id":41223,"modified_method":"public byte[] getDotImage(int hashCode, String content, String extension, boolean dot) throws IOException\n    {\n        File dfile = getTempFile(hashCode, \"dot\", dot);\n        if (!dfile.exists()) {\n            FileWriter fwriter = new FileWriter(dfile);\n            fwriter.write(content);\n            fwriter.flush();\n            fwriter.close();\n        }\n\n        File ofile = getTempFile(hashCode, extension, dot);\n        if (!ofile.exists()) {\n            Runtime rt = Runtime.getRuntime();\n            String[] command = new String[5];\n            command[0] = dot ? this.dotPath : this.neatoPath;\n            command[1] = \"-T\" + extension;\n            command[2] = dfile.getAbsolutePath();\n            command[3] = \"-o\";\n            command[4] = ofile.getAbsolutePath();\n            Process p = rt.exec(command);\n            int exitValue = -1;\n            try {\n                int i = 0;\n                int max = 10;\n                for (i = 0; i < max; i++) {\n                    Thread.sleep(1000);\n                    try {\n                        // exitValue() throws an IllegalThreadStateException if the process is still running. \n                        exitValue = p.exitValue();\n                        break;\n                    } catch (IllegalThreadStateException e) {\n                    }\n                }\n                // No more than 10 seconds to generate graph\n                // Force killing\n                if (i >= max) {\n                    p.destroy();\n                }\n            } catch (InterruptedException e) {\n                mLogger.error(\"Error while generating image from dot\", e);\n            }\n\n            if (exitValue != 0) {\n                BufferedReader os = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                StringBuffer error = new StringBuffer();\n                while (os.ready()) {\n                    error.append(os.readLine());\n                }\n                mLogger.error(\"Error while generating image from dot: \" + error.toString());\n            }\n        }\n        FileInputStream fis = new FileInputStream(ofile);\n        try {\n            byte[] result = new byte[(int) ofile.length()];\n            fis.read(result);\n            return result;\n        } finally {\n            fis.close();\n        }\n    }","commit_id":"4a0b997c7411d16ad8cb0782387ab1989e9fa05a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String execute(OutputInterpreter interpreter) {\n        String[] command = _command.toArray(new String[_command.size()]);\n\n        if (_logger.isDebugEnabled()) {\n            _logger.debug(\"Executing: \" + buildCommandLine(command));\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.redirectErrorStream(true);\n            if(_workDir != null) \n            \tpb.directory(new File(_workDir));\n            \n            _process = pb.start();\n            if (_process == null) {\n                _logger.warn(\"Unable to execute: \" + buildCommandLine(command));\n                return \"Unable to execute the command: \" + command[0];\n            }\n\n            BufferedReader ir = new BufferedReader(new InputStreamReader(_process.getInputStream()));\n\n            _thread = Thread.currentThread();\n            ScheduledFuture<String> future = null;\n            if (_timeout > 0) {\n                future = s_executors.schedule(this, _timeout, TimeUnit.MILLISECONDS);\n            }\n\n            Task task = null;\n            if (interpreter != null && interpreter.drain()) {\n                task = new Task(interpreter, ir);\n                s_executors.execute(task);\n            }\n\n            while (true) {\n                try {\n                    if (_process.waitFor() == 0) {\n                        _logger.debug(\"Execution is successful.\");\n                        if (interpreter != null) {\n                            return interpreter.drain() ? task.getResult() : interpreter.interpret(ir);\n                        } else {\n                            // null return is ok apparently\n                            return (_process.exitValue() == 0) ? \"Ok\" : \"Failed, exit code \" + _process.exitValue();\n                        }\n                    } else {\n                        break;\n                    }\n                } catch (InterruptedException e) {\n                    if (!_isTimeOut) {\n                        /*\n                         * This is not timeout, we are interrupted by others,\n                         * continue\n                         */\n                        _logger.debug(\"We are interrupted but it's not a timeout, just continue\");\n                        continue;\n                    }\n\n                    TimedOutLogger log = new TimedOutLogger(_process);\n                    Task timedoutTask = new Task(log, ir);\n\n                    timedoutTask.run();\n                    if (!_passwordCommand) {\n                        _logger.warn(\"Timed out: \" + buildCommandLine(command) + \".  Output is: \" + timedoutTask.getResult());\n                    } else {\n                        _logger.warn(\"Timed out: \" + buildCommandLine(command));\n                    }\n\n                    return ERR_TIMEOUT;\n                } finally {\n                    if (future != null) {\n                        future.cancel(false);\n                    }\n                    Thread.interrupted();\n                }\n            }\n\n            _logger.debug(\"Exit value is \" + _process.exitValue());\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(_process.getInputStream()), 128);\n\n            String error;\n            if (interpreter != null) {\n                error = interpreter.processError(reader);\n            }\n            else {\n                error = \"Non zero exit code : \" + _process.exitValue();\n            }\n            \n            if (_logger.isDebugEnabled()) {\n                _logger.debug(error);\n            }\n            return error;\n        } catch (SecurityException ex) {\n            _logger.warn(\"Security Exception....not running as root?\", ex);\n            StringWriter writer = new StringWriter();\n            ex.printStackTrace(new PrintWriter(writer));\n            return writer.toString();\n        } catch (Exception ex) {\n            _logger.warn(\"Exception: \" + buildCommandLine(command), ex);\n            StringWriter writer = new StringWriter();\n            ex.printStackTrace(new PrintWriter(writer));\n            return writer.toString();\n        } finally {\n            if (_process != null) {\n                try {\n                    _process.getErrorStream().close();\n                } catch (IOException ex) {\n                }\n                try {\n                    _process.getOutputStream().close();\n                } catch (IOException ex) {\n                }\n                try {\n                    _process.getInputStream().close();\n                } catch (IOException ex) {\n                }\n                _process.destroy();\n            }\n        }\n    }","id":41224,"modified_method":"public String execute(OutputInterpreter interpreter) {\n        String[] command = _command.toArray(new String[_command.size()]);\n\n        if (_logger.isDebugEnabled()) {\n            _logger.debug(\"Executing: \" + buildCommandLine(command));\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.redirectErrorStream(true);\n            if(_workDir != null) \n            \tpb.directory(new File(_workDir));\n            \n            _process = pb.start();\n            if (_process == null) {\n                _logger.warn(\"Unable to execute: \" + buildCommandLine(command));\n                return \"Unable to execute the command: \" + command[0];\n            }\n\n            BufferedReader ir = new BufferedReader(new InputStreamReader(_process.getInputStream()));\n\n            _thread = Thread.currentThread();\n            ScheduledFuture<String> future = null;\n            if (_timeout > 0) {\n                future = s_executors.schedule(this, _timeout, TimeUnit.MILLISECONDS);\n            }\n\n            Task task = null;\n            if (interpreter != null && interpreter.drain()) {\n                task = new Task(interpreter, ir);\n                s_executors.execute(task);\n            }\n\n            while (true) {\n                try {\n                    if (_process.waitFor() == 0) {\n                        _logger.debug(\"Execution is successful.\");\n                        if (interpreter != null) {\n                            return interpreter.drain() ? task.getResult() : interpreter.interpret(ir);\n                        } else {\n                            // null return exitValue apparently\n                            return String.valueOf(_process.exitValue());\n                        }\n                    } else {\n                        break;\n                    }\n                } catch (InterruptedException e) {\n                    if (!_isTimeOut) {\n                        /*\n                         * This is not timeout, we are interrupted by others,\n                         * continue\n                         */\n                        _logger.debug(\"We are interrupted but it's not a timeout, just continue\");\n                        continue;\n                    }\n\n                    TimedOutLogger log = new TimedOutLogger(_process);\n                    Task timedoutTask = new Task(log, ir);\n\n                    timedoutTask.run();\n                    if (!_passwordCommand) {\n                        _logger.warn(\"Timed out: \" + buildCommandLine(command) + \".  Output is: \" + timedoutTask.getResult());\n                    } else {\n                        _logger.warn(\"Timed out: \" + buildCommandLine(command));\n                    }\n\n                    return ERR_TIMEOUT;\n                } finally {\n                    if (future != null) {\n                        future.cancel(false);\n                    }\n                    Thread.interrupted();\n                }\n            }\n\n            _logger.debug(\"Exit value is \" + _process.exitValue());\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(_process.getInputStream()), 128);\n\n            String error;\n            if (interpreter != null) {\n                error = interpreter.processError(reader);\n            }\n            else {\n                error = String.valueOf(_process.exitValue());\n            }\n            \n            if (_logger.isDebugEnabled()) {\n                _logger.debug(error);\n            }\n            return error;\n        } catch (SecurityException ex) {\n            _logger.warn(\"Security Exception....not running as root?\", ex);\n            StringWriter writer = new StringWriter();\n            ex.printStackTrace(new PrintWriter(writer));\n            return writer.toString();\n        } catch (Exception ex) {\n            _logger.warn(\"Exception: \" + buildCommandLine(command), ex);\n            StringWriter writer = new StringWriter();\n            ex.printStackTrace(new PrintWriter(writer));\n            return writer.toString();\n        } finally {\n            if (_process != null) {\n                try {\n                    _process.getErrorStream().close();\n                } catch (IOException ex) {\n                }\n                try {\n                    _process.getOutputStream().close();\n                } catch (IOException ex) {\n                }\n                try {\n                    _process.getInputStream().close();\n                } catch (IOException ex) {\n                }\n                _process.destroy();\n            }\n        }\n    }","commit_id":"3a999e70af73281a7b682f5c408a036645cd79f6","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected Pair<VolumeVO, String> createVolumeFromSnapshot(VolumeVO volume, SnapshotVO snapshot, long virtualsize) {\n        VolumeVO createdVolume = null;\n        Long volumeId = volume.getId();\n\n        String volumeFolder = null;\n\n        // Create the Volume object and save it so that we can return it to the user\n        Account account = _accountDao.findById(volume.getAccountId());\n\n        final HashSet<StoragePool> poolsToAvoid = new HashSet<StoragePool>();\n        StoragePoolVO pool = null;\n        boolean success = false;\n        Set<Long> podsToAvoid = new HashSet<Long>();\n        Pair<HostPodVO, Long> pod = null;\n        String volumeUUID = null;\n        String details = null;\n\n        DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n        DataCenterVO dc = _dcDao.findById(volume.getDataCenterId());\n        DiskProfile dskCh = new DiskProfile(volume, diskOffering, snapshot.getHypervisorType());\n\n        int retry = 0;\n        // Determine what pod to store the volume in\n        while ((pod = _agentMgr.findPod(null, null, dc, account.getId(), podsToAvoid)) != null) {\n            podsToAvoid.add(pod.first().getId());\n            // Determine what storage pool to store the volume in\n            while ((pool = findStoragePool(dskCh, dc, pod.first(), null, null, null, null, poolsToAvoid)) != null) {\n                poolsToAvoid.add(pool);\n                volumeFolder = pool.getPath();\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Attempting to create volume from snapshotId: \" + snapshot.getId() + \" on storage pool \" + pool.getName());\n                }\n\n                // Get the newly created VDI from the snapshot.\n                // This will return a null volumePath if it could not be created\n                Pair<String, String> volumeDetails = createVDIFromSnapshot(UserContext.current().getCallerUserId(), snapshot, pool);\n\n                volumeUUID = volumeDetails.first();\n                details = volumeDetails.second();\n\n                if (volumeUUID != null) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Volume with UUID \" + volumeUUID + \" was created on storage pool \" + pool.getName());\n                    }\n                    success = true;\n                    break; // break out of the \"find storage pool\" loop\n                } else {\n                    retry++;\n                    if (retry >= 3) {\n                        _volsDao.expunge(volumeId);\n                        String msg = \"Unable to create volume from snapshot \" + snapshot.getId() + \" after retrying 3 times, due to \" + details;\n                        s_logger.debug(msg);\n                        throw new CloudRuntimeException(msg);\n\n                    }\n                }\n\n                s_logger.warn(\"Unable to create volume on pool \" + pool.getName() + \", reason: \" + details);\n            }\n\n            if (success) {\n                break; // break out of the \"find pod\" loop\n            }\n        }\n\n        if (!success) {\n            _volsDao.expunge(volumeId);\n            String msg = \"Unable to create volume from snapshot \" + snapshot.getId() + \" due to \" + details;\n            s_logger.debug(msg);\n            throw new CloudRuntimeException(msg);\n\n        }\n        // Update the volume in the database\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        createdVolume = _volsDao.findById(volumeId);\n\n        if (success) {\n            // Increment the number of volumes\n            _accountMgr.incrementResourceCount(account.getId(), ResourceType.volume);\n\n            createdVolume.setStatus(AsyncInstanceCreateStatus.Created);\n            createdVolume.setPodId(pod.first().getId());\n            createdVolume.setPoolId(pool.getId());\n            createdVolume.setPoolType(pool.getPoolType());\n            createdVolume.setFolder(volumeFolder);\n            createdVolume.setPath(volumeUUID);\n            createdVolume.setDomainId(account.getDomainId());\n            createdVolume.setState(Volume.State.Ready);\n        } else {\n            createdVolume.setStatus(AsyncInstanceCreateStatus.Corrupted);\n            createdVolume.setState(Volume.State.Destroy);\n        }\n\n        _volsDao.update(volumeId, createdVolume);\n        txn.commit();\n        return new Pair<VolumeVO, String>(createdVolume, details);\n    }","id":41225,"modified_method":"@DB\n    protected Pair<VolumeVO, String> createVolumeFromSnapshot(VolumeVO volume, SnapshotVO snapshot, long virtualsize) {\n        VolumeVO createdVolume = null;\n        Long volumeId = volume.getId();\n\n        String volumeFolder = null;\n\n        // Create the Volume object and save it so that we can return it to the user\n        Account account = _accountDao.findById(volume.getAccountId());\n\n        final HashSet<StoragePool> poolsToAvoid = new HashSet<StoragePool>();\n        StoragePoolVO pool = null;\n        boolean success = false;\n        Set<Long> podsToAvoid = new HashSet<Long>();\n        Pair<HostPodVO, Long> pod = null;\n        String volumeUUID = null;\n        String details = null;\n\n        DiskOfferingVO diskOffering = _diskOfferingDao.findByIdIncludingRemoved(volume.getDiskOfferingId());\n        DataCenterVO dc = _dcDao.findById(volume.getDataCenterId());\n        DiskProfile dskCh = new DiskProfile(volume, diskOffering, snapshot.getHypervisorType());\n\n        int retry = 0;\n        // Determine what pod to store the volume in\n        while ((pod = _agentMgr.findPod(null, null, dc, account.getId(), podsToAvoid)) != null) {\n            podsToAvoid.add(pod.first().getId());\n            // Determine what storage pool to store the volume in\n            while ((pool = findStoragePool(dskCh, dc, pod.first(), null, null, null, null, poolsToAvoid)) != null) {\n                poolsToAvoid.add(pool);\n                volumeFolder = pool.getPath();\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Attempting to create volume from snapshotId: \" + snapshot.getId() + \" on storage pool \" + pool.getName());\n                }\n\n                // Get the newly created VDI from the snapshot.\n                // This will return a null volumePath if it could not be created\n                Pair<String, String> volumeDetails = createVDIFromSnapshot(UserContext.current().getCallerUserId(), snapshot, pool);\n\n                volumeUUID = volumeDetails.first();\n                details = volumeDetails.second();\n\n                if (volumeUUID != null) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Volume with UUID \" + volumeUUID + \" was created on storage pool \" + pool.getName());\n                    }\n                    success = true;\n                    break; // break out of the \"find storage pool\" loop\n                } else {\n                    retry++;\n                    if (retry >= 3) {\n                        _volsDao.expunge(volumeId);\n                        String msg = \"Unable to create volume from snapshot \" + snapshot.getId() + \" after retrying 3 times, due to \" + details;\n                        s_logger.debug(msg);\n                        throw new CloudRuntimeException(msg);\n\n                    }\n                }\n\n                s_logger.warn(\"Unable to create volume on pool \" + pool.getName() + \", reason: \" + details);\n            }\n\n            if (success) {\n                break; // break out of the \"find pod\" loop\n            }\n        }\n\n        if (!success) {\n            _volsDao.expunge(volumeId);\n            String msg = \"Unable to create volume from snapshot \" + snapshot.getId() + \" due to \" + details;\n            s_logger.debug(msg);\n            throw new CloudRuntimeException(msg);\n\n        }\n        // Update the volume in the database\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        createdVolume = _volsDao.findById(volumeId);\n\n        if (success) {\n            // Increment the number of volumes\n            _accountMgr.incrementResourceCount(account.getId(), ResourceType.volume);\n\n            createdVolume.setStatus(AsyncInstanceCreateStatus.Created);\n            createdVolume.setPodId(pod.first().getId());\n            createdVolume.setPoolId(pool.getId());\n            createdVolume.setPoolType(pool.getPoolType());\n            createdVolume.setFolder(volumeFolder);\n            createdVolume.setPath(volumeUUID);\n            createdVolume.setDomainId(account.getDomainId());\n            createdVolume.setState(Volume.State.Ready);\n        } else {\n            createdVolume.setStatus(AsyncInstanceCreateStatus.Corrupted);\n            createdVolume.setState(Volume.State.Destroy);\n        }\n\n        _volsDao.update(volumeId, createdVolume);\n        txn.commit();\n        return new Pair<VolumeVO, String>(createdVolume, details);\n    }","commit_id":"bae62f844d6d9d4a7db8147ea0246d9dafbf05a3","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public VolumeVO createVolume(VolumeVO volume, VMInstanceVO vm, VMTemplateVO template, DataCenterVO dc, HostPodVO pod, Long clusterId,\n            ServiceOfferingVO offering, DiskOfferingVO diskOffering, List<StoragePoolVO> avoids, long size, HypervisorType hyperType) {\n        StoragePoolVO pool = null;\n        final HashSet<StoragePool> avoidPools = new HashSet<StoragePool>(avoids);\n\n        if (diskOffering != null && diskOffering.isCustomized()) {\n            diskOffering.setDiskSize(size);\n        }\n        DiskProfile dskCh = null;\n        if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {\n            dskCh = createDiskCharacteristics(volume, template, dc, offering);\n        } else {\n            dskCh = createDiskCharacteristics(volume, template, dc, diskOffering);\n        }\n\n        dskCh.setHyperType(hyperType);\n\n        VolumeTO created = null;\n        int retry = _retry;\n        while (--retry >= 0) {\n            created = null;\n\n            long podId = pod.getId();\n            pod = _podDao.findById(podId);\n            if (pod == null) {\n                s_logger.warn(\"Unable to find pod \" + podId + \" when create volume \" + volume.getName());\n                break;\n            }\n\n            pool = findStoragePool(dskCh, dc, pod, clusterId, offering, vm, template, avoidPools);\n            if (pool == null) {\n                s_logger.warn(\"Unable to find storage poll when create volume \" + volume.getName());\n                break;\n            }\n\n            avoidPools.add(pool);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Trying to create \" + volume + \" on \" + pool);\n            }\n\n            CreateCommand cmd = null;\n            VMTemplateStoragePoolVO tmpltStoredOn = null;\n            if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {\n                tmpltStoredOn = _tmpltMgr.prepareTemplateForCreate(template, pool);\n                if (tmpltStoredOn == null) {\n                    continue;\n                }\n                cmd = new CreateCommand(dskCh, tmpltStoredOn.getLocalDownloadPath(), new StorageFilerTO(pool));\n            } else {\n                cmd = new CreateCommand(dskCh, new StorageFilerTO(pool));\n            }\n\n            try {\n                Answer answer = sendToPool(pool, cmd);\n                if (answer != null && answer.getResult()) {\n                    created = ((CreateAnswer) answer).getVolume();\n                    break;\n                }\n            } catch (StorageUnavailableException e) {\n                s_logger.debug(\"Storage unavailable for \" + pool.getId());\n            }\n\n            s_logger.debug(\"Retrying the create because it failed on pool \" + pool);\n        }\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        if (created == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to create a volume for \" + volume);\n            }\n            volume.setStatus(AsyncInstanceCreateStatus.Failed);\n            volume.setState(Volume.State.Destroy);\n            _volsDao.persist(volume);\n            _volsDao.remove(volume.getId());\n            volume = null;\n\n        } else {\n            volume.setStatus(AsyncInstanceCreateStatus.Created);\n            volume.setFolder(pool.getPath());\n            volume.setPath(created.getPath());\n            volume.setSize(created.getSize());\n            volume.setPoolType(pool.getPoolType());\n            volume.setPoolId(pool.getId());\n            volume.setPodId(pod.getId());\n            volume.setState(Volume.State.Ready);\n            _volsDao.persist(volume);\n            UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(),\n                    volume.getId(), volume.getName(), diskOffering.getId(), null, dskCh.getSize());\n            _usageEventDao.persist(usageEvent);\n\n        }\n        txn.commit();\n        return volume;\n    }","id":41226,"modified_method":"@Override\n    @DB\n    public VolumeVO createVolume(VolumeVO volume, VMInstanceVO vm, VMTemplateVO template, DataCenterVO dc, HostPodVO pod, Long clusterId,\n            ServiceOfferingVO offering, DiskOfferingVO diskOffering, List<StoragePoolVO> avoids, long size, HypervisorType hyperType) {\n        StoragePoolVO pool = null;\n        final HashSet<StoragePool> avoidPools = new HashSet<StoragePool>(avoids);\n\n        if (diskOffering != null && diskOffering.isCustomized()) {\n            diskOffering.setDiskSize(size);\n        }\n        DiskProfile dskCh = null;\n        if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {\n            dskCh = createDiskCharacteristics(volume, template, dc, offering);\n        } else {\n            dskCh = createDiskCharacteristics(volume, template, dc, diskOffering);\n        }\n\n        dskCh.setHyperType(hyperType);\n\n        VolumeTO created = null;\n        int retry = _retry;\n        while (--retry >= 0) {\n            created = null;\n\n            long podId = pod.getId();\n            pod = _podDao.findById(podId);\n            if (pod == null) {\n                s_logger.warn(\"Unable to find pod \" + podId + \" when create volume \" + volume.getName());\n                break;\n            }\n\n            pool = findStoragePool(dskCh, dc, pod, clusterId, offering, vm, template, avoidPools);\n            if (pool == null) {\n                s_logger.warn(\"Unable to find storage poll when create volume \" + volume.getName());\n                break;\n            }\n\n            avoidPools.add(pool);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Trying to create \" + volume + \" on \" + pool);\n            }\n\n            CreateCommand cmd = null;\n            VMTemplateStoragePoolVO tmpltStoredOn = null;\n            if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {\n                tmpltStoredOn = _tmpltMgr.prepareTemplateForCreate(template, pool);\n                if (tmpltStoredOn == null) {\n                    continue;\n                }\n                cmd = new CreateCommand(dskCh, tmpltStoredOn.getLocalDownloadPath(), new StorageFilerTO(pool));\n            } else {\n                cmd = new CreateCommand(dskCh, new StorageFilerTO(pool));\n            }\n\n            try {\n                Answer answer = sendToPool(pool, cmd);\n                if (answer != null && answer.getResult()) {\n                    created = ((CreateAnswer) answer).getVolume();\n                    break;\n                }\n            } catch (StorageUnavailableException e) {\n                s_logger.debug(\"Storage unavailable for \" + pool.getId());\n            }\n\n            s_logger.debug(\"Retrying the create because it failed on pool \" + pool);\n        }\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        if (created == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to create a volume for \" + volume);\n            }\n            volume.setStatus(AsyncInstanceCreateStatus.Failed);\n            volume.setState(Volume.State.Destroy);\n            _volsDao.persist(volume);\n            _volsDao.remove(volume.getId());\n            volume = null;\n\n        } else {\n            volume.setStatus(AsyncInstanceCreateStatus.Created);\n            volume.setFolder(pool.getPath());\n            volume.setPath(created.getPath());\n            volume.setSize(created.getSize());\n            volume.setPoolType(pool.getPoolType());\n            volume.setPoolId(pool.getId());\n            volume.setPodId(pod.getId());\n            volume.setState(Volume.State.Ready);\n            _volsDao.persist(volume);\n            \n\n        }\n        txn.commit();\n        return volume;\n    }","commit_id":"bae62f844d6d9d4a7db8147ea0246d9dafbf05a3","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_VOLUME_CREATE, eventDescription = \"creating volume\", create = true)\n    public VolumeVO allocVolume(CreateVolumeCmd cmd) throws ResourceAllocationException {\n        // FIXME: some of the scheduled event stuff might be missing here...\n        Account account = UserContext.current().getCaller();\n        String accountName = cmd.getAccountName();\n        Long domainId = cmd.getDomainId();\n        Account targetAccount = null;\n        if ((account == null) || isAdmin(account.getType())) {\n            // Admin API call\n            if ((domainId != null) && (accountName != null)) {\n                if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Unable to create volume in domain \" + domainId + \", permission denied.\");\n                }\n\n                targetAccount = _accountDao.findActiveAccount(accountName, domainId);\n            } else {\n                targetAccount = account;\n            }\n\n            // If the account is null, this means that the accountName and domainId passed in were invalid\n            if (targetAccount == null) {\n                throw new InvalidParameterValueException(\"Unable to find account with name: \" + accountName + \" and domain ID: \" + domainId);\n            }\n        } else {\n            targetAccount = account;\n        }\n\n        // check if the volume can be created for the user\n        // Check that the resource limit for volumes won't be exceeded\n        if (_accountMgr.resourceLimitExceeded(targetAccount, ResourceType.volume)) {\n            ResourceAllocationException rae = new ResourceAllocationException(\"Maximum number of volumes for account: \"\n                    + targetAccount.getAccountName() + \" has been exceeded.\");\n            rae.setResourceType(\"volume\");\n            throw rae;\n        }\n\n        Long zoneId = null;\n        Long diskOfferingId = null;\n        Long size = null;\n\n        // validate input parameters before creating the volume\n        if (cmd.getSnapshotId() == null && cmd.getDiskOfferingId() == null) {\n            throw new InvalidParameterValueException(\"Either disk Offering Id or snapshot Id must be passed whilst creating volume\");\n        }\n\n        if (cmd.getSnapshotId() == null) {\n            zoneId = cmd.getZoneId();\n            if ((zoneId == null)) {\n                throw new InvalidParameterValueException(\"Missing parameter, zoneid must be specified.\");\n            }\n\n            diskOfferingId = cmd.getDiskOfferingId();\n            size = cmd.getSize();\n            if (diskOfferingId == null) {\n                throw new InvalidParameterValueException(\n                        \"Missing parameter(s),either a positive volume size or a valid disk offering id must be specified.\");\n            }\n            // Check that the the disk offering is specified\n            DiskOfferingVO diskOffering = _diskOfferingDao.findById(diskOfferingId);\n            if ((diskOffering == null) || !DiskOfferingVO.Type.Disk.equals(diskOffering.getType())) {\n                throw new InvalidParameterValueException(\"Please specify a valid disk offering.\");\n            }\n\n            if ((diskOffering.isCustomized() && size == null)) {\n                throw new InvalidParameterValueException(\"This disk offering requires a custom size specified\");\n            }\n\n            if (!diskOffering.isCustomized() && size != null) {\n                throw new InvalidParameterValueException(\"This disk offering does not allow custom size\");\n            }\n\n            if (diskOffering.getDomainId() == null) {\n                // do nothing as offering is public\n            } else {\n                _configMgr.checkDiskOfferingAccess(account, diskOffering);\n            }\n\n            if (!validateVolumeSizeRange(diskOffering.getDiskSize() / 1024)) {// convert size from mb to gb for validation\n                throw new InvalidParameterValueException(\"Invalid size for custom volume creation: \" + size + \" ,max volume size is:\"\n                        + _maxVolumeSizeInGb);\n            }\n\n            if (diskOffering.getDiskSize() > 0) {\n                size = (diskOffering.getDiskSize() * 1024 * 1024);// the disk offering size is in MB, which needs to be converted into bytes\n            } else {\n                if (!validateVolumeSizeRange(size)) {\n                    throw new InvalidParameterValueException(\"Invalid size for custom volume creation: \" + size + \" ,max volume size is:\"\n                            + _maxVolumeSizeInGb);\n                }\n                size = (size * 1024 * 1024 * 1024);// custom size entered is in GB, to be converted to bytes\n            }\n        } else {\n            DiskOfferingVO privOffering = null;\n            Long snapshotId = cmd.getSnapshotId();\n            Snapshot snapshotCheck = _snapshotDao.findById(snapshotId);\n            diskOfferingId = cmd.getDiskOfferingId();\n            if (snapshotCheck == null) {\n                throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId);\n            }\n\n            if(diskOfferingId == null) {\n                throw new InvalidParameterValueException(\"Please specify a valid private disk offering\");\n            } else {\n                privOffering = _diskOfferingDao.findById(diskOfferingId);\n                if(privOffering == null) {\n                    throw new InvalidParameterValueException(\"Please specify a valid private disk offering\");\n                } else {\n                    if(!privOffering.isCustomized())\n                        throw new InvalidParameterValueException(\"Please specify a valid private disk offering\");\n                }\n            }\n            \n            VolumeVO vol = _volsDao.findByIdIncludingRemoved(snapshotCheck.getVolumeId());\n            zoneId = vol.getDataCenterId();\n            size = vol.getSize(); //we maintain size from org vol ; disk offering is used for tags purposes\n\n            if (account != null) {\n                if (isAdmin(account.getType())) {\n                    Account snapshotOwner = _accountDao.findById(snapshotCheck.getAccountId());\n                    if (!_domainDao.isChildDomain(account.getDomainId(), snapshotOwner.getDomainId())) {\n                        throw new PermissionDeniedException(\"Unable to create volume from snapshot with id \" + snapshotId\n                                + \", permission denied.\");\n                    }\n                } else if (account.getId() != snapshotCheck.getAccountId()) {\n                    throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId + \" for this account\");\n                }\n            }\n        }\n\n        // Check that there is a shared primary storage pool in the specified zone\n        List<StoragePoolVO> storagePools = _storagePoolDao.listByDataCenterId(zoneId);\n        boolean sharedPoolExists = false;\n        for (StoragePoolVO storagePool : storagePools) {\n            if (storagePool.isShared()) {\n                sharedPoolExists = true;\n            }\n        }\n\n        // Check that there is at least one host in the specified zone\n        List<HostVO> hosts = _hostDao.listByDataCenter(zoneId);\n        if (hosts.isEmpty()) {\n            throw new InvalidParameterValueException(\"Please add a host in the specified zone before creating a new volume.\");\n        }\n\n        if (!sharedPoolExists) {\n            throw new InvalidParameterValueException(\"Please specify a zone that has at least one shared primary storage pool.\");\n        }\n\n        String userSpecifiedName = cmd.getVolumeName();\n        if (userSpecifiedName == null) {\n            userSpecifiedName = getRandomVolumeName();\n        }\n\n        VolumeVO volume = new VolumeVO(userSpecifiedName, -1, -1, -1, -1, new Long(-1), null, null, 0, Volume.VolumeType.DATADISK);\n        volume.setPoolId(null);\n        volume.setDataCenterId(zoneId);\n        volume.setPodId(null);\n        volume.setAccountId(targetAccount.getId());\n        volume.setDomainId(((account == null) ? Domain.ROOT_DOMAIN : account.getDomainId()));\n        volume.setDiskOfferingId(diskOfferingId);\n        volume.setSize(size);\n        volume.setStorageResourceType(StorageResourceType.STORAGE_POOL);\n        volume.setInstanceId(null);\n        volume.setUpdated(new Date());\n        volume.setStatus(AsyncInstanceCreateStatus.Creating);\n        volume.setDomainId((account == null) ? Domain.ROOT_DOMAIN : account.getDomainId());\n        volume.setState(Volume.State.Allocated);\n        volume = _volsDao.persist(volume);\n        UserContext.current().setEventDetails(\"Volume Id: \"+volume.getId());\n        return volume;\n    }","id":41227,"modified_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_VOLUME_CREATE, eventDescription = \"creating volume\", create = true)\n    public VolumeVO allocVolume(CreateVolumeCmd cmd) throws ResourceAllocationException {\n        // FIXME: some of the scheduled event stuff might be missing here...\n        Account account = UserContext.current().getCaller();\n        String accountName = cmd.getAccountName();\n        Long domainId = cmd.getDomainId();\n        Account targetAccount = null;\n        if ((account == null) || isAdmin(account.getType())) {\n            // Admin API call\n            if ((domainId != null) && (accountName != null)) {\n                if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Unable to create volume in domain \" + domainId + \", permission denied.\");\n                }\n\n                targetAccount = _accountDao.findActiveAccount(accountName, domainId);\n            } else {\n                targetAccount = account;\n            }\n\n            // If the account is null, this means that the accountName and domainId passed in were invalid\n            if (targetAccount == null) {\n                throw new InvalidParameterValueException(\"Unable to find account with name: \" + accountName + \" and domain ID: \" + domainId);\n            }\n        } else {\n            targetAccount = account;\n        }\n\n        // check if the volume can be created for the user\n        // Check that the resource limit for volumes won't be exceeded\n        if (_accountMgr.resourceLimitExceeded(targetAccount, ResourceType.volume)) {\n            ResourceAllocationException rae = new ResourceAllocationException(\"Maximum number of volumes for account: \"\n                    + targetAccount.getAccountName() + \" has been exceeded.\");\n            rae.setResourceType(\"volume\");\n            throw rae;\n        }\n\n        Long zoneId = null;\n        Long diskOfferingId = null;\n        Long size = null;\n\n        // validate input parameters before creating the volume\n        if ((cmd.getSnapshotId() == null && cmd.getDiskOfferingId() == null) || (cmd.getSnapshotId() != null && cmd.getDiskOfferingId() != null)) {\n            throw new InvalidParameterValueException(\"Either disk Offering Id or snapshot Id must be passed whilst creating volume\");\n        }\n\n        if (cmd.getSnapshotId() == null) {\n            zoneId = cmd.getZoneId();\n            if ((zoneId == null)) {\n                throw new InvalidParameterValueException(\"Missing parameter, zoneid must be specified.\");\n            }\n\n            diskOfferingId = cmd.getDiskOfferingId();\n            size = cmd.getSize();\n            if (diskOfferingId == null) {\n                throw new InvalidParameterValueException(\n                        \"Missing parameter(s),either a positive volume size or a valid disk offering id must be specified.\");\n            }\n            // Check that the the disk offering is specified\n            DiskOfferingVO diskOffering = _diskOfferingDao.findById(diskOfferingId);\n            if ((diskOffering == null) || !DiskOfferingVO.Type.Disk.equals(diskOffering.getType())) {\n                throw new InvalidParameterValueException(\"Please specify a valid disk offering.\");\n            }\n\n            if ((diskOffering.isCustomized() && size == null)) {\n                throw new InvalidParameterValueException(\"This disk offering requires a custom size specified\");\n            }\n\n            if (!diskOffering.isCustomized() && size != null) {\n                throw new InvalidParameterValueException(\"This disk offering does not allow custom size\");\n            }\n\n            if (diskOffering.getDomainId() == null) {\n                // do nothing as offering is public\n            } else {\n                _configMgr.checkDiskOfferingAccess(account, diskOffering);\n            }\n\n            if (!validateVolumeSizeRange(diskOffering.getDiskSize() / 1024)) {// convert size from mb to gb for validation\n                throw new InvalidParameterValueException(\"Invalid size for custom volume creation: \" + size + \" ,max volume size is:\"\n                        + _maxVolumeSizeInGb);\n            }\n\n            if (diskOffering.getDiskSize() > 0) {\n                size = (diskOffering.getDiskSize() * 1024 * 1024);// the disk offering size is in MB, which needs to be converted into bytes\n            } else {\n                if (!validateVolumeSizeRange(size)) {\n                    throw new InvalidParameterValueException(\"Invalid size for custom volume creation: \" + size + \" ,max volume size is:\"\n                            + _maxVolumeSizeInGb);\n                }\n                size = (size * 1024 * 1024 * 1024);// custom size entered is in GB, to be converted to bytes\n            }\n        } else {\n            Long snapshotId = cmd.getSnapshotId();\n            Snapshot snapshotCheck = _snapshotDao.findById(snapshotId);\n             \n            if (snapshotCheck == null) {\n                throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId);\n            }\n            \n            VolumeVO vol = _volsDao.findByIdIncludingRemoved(snapshotCheck.getVolumeId());\n            zoneId = vol.getDataCenterId();\n            size = vol.getSize(); //we maintain size from org vol ; disk offering is used for tags purposes\n            diskOfferingId = vol.getDiskOfferingId();\n            \n            if (account != null) {\n                if (isAdmin(account.getType())) {\n                    Account snapshotOwner = _accountDao.findById(snapshotCheck.getAccountId());\n                    if (!_domainDao.isChildDomain(account.getDomainId(), snapshotOwner.getDomainId())) {\n                        throw new PermissionDeniedException(\"Unable to create volume from snapshot with id \" + snapshotId\n                                + \", permission denied.\");\n                    }\n                } else if (account.getId() != snapshotCheck.getAccountId()) {\n                    throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId + \" for this account\");\n                }\n            }\n        }\n\n        // Check that there is a shared primary storage pool in the specified zone\n        List<StoragePoolVO> storagePools = _storagePoolDao.listByDataCenterId(zoneId);\n        boolean sharedPoolExists = false;\n        for (StoragePoolVO storagePool : storagePools) {\n            if (storagePool.isShared()) {\n                sharedPoolExists = true;\n            }\n        }\n\n        // Check that there is at least one host in the specified zone\n        List<HostVO> hosts = _hostDao.listByDataCenter(zoneId);\n        if (hosts.isEmpty()) {\n            throw new InvalidParameterValueException(\"Please add a host in the specified zone before creating a new volume.\");\n        }\n\n        if (!sharedPoolExists) {\n            throw new InvalidParameterValueException(\"Please specify a zone that has at least one shared primary storage pool.\");\n        }\n\n        String userSpecifiedName = cmd.getVolumeName();\n        if (userSpecifiedName == null) {\n            userSpecifiedName = getRandomVolumeName();\n        }\n\n        VolumeVO volume = new VolumeVO(userSpecifiedName, -1, -1, -1, -1, new Long(-1), null, null, 0, Volume.VolumeType.DATADISK);\n        volume.setPoolId(null);\n        volume.setDataCenterId(zoneId);\n        volume.setPodId(null);\n        volume.setAccountId(targetAccount.getId());\n        volume.setDomainId(((account == null) ? Domain.ROOT_DOMAIN : account.getDomainId()));\n        volume.setDiskOfferingId(diskOfferingId);\n        volume.setSize(size);\n        volume.setStorageResourceType(StorageResourceType.STORAGE_POOL);\n        volume.setInstanceId(null);\n        volume.setUpdated(new Date());\n        volume.setStatus(AsyncInstanceCreateStatus.Creating);\n        volume.setDomainId((account == null) ? Domain.ROOT_DOMAIN : account.getDomainId());\n        volume.setState(Volume.State.Allocated);\n        volume = _volsDao.persist(volume);\n        UserContext.current().setEventDetails(\"Volume Id: \"+volume.getId());\n        \n        UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(),\n                volume.getId(), volume.getName(), diskOfferingId, null, size);\n        \n        _usageEventDao.persist(usageEvent);\n        \n        return volume;\n    }","commit_id":"bae62f844d6d9d4a7db8147ea0246d9dafbf05a3","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected VolumeVO createVolumeFromSnapshot(VolumeVO volume, long snapshotId) {\n\n        // By default, assume failure.\n        VolumeVO createdVolume = null;\n        SnapshotVO snapshot = _snapshotDao.findById(snapshotId); // Precondition: snapshot is not null and not removed.\n        Long origVolumeId = snapshot.getVolumeId();\n        VolumeVO originalVolume = _volsDao.findById(origVolumeId); // NOTE: Original volume could be destroyed and removed.\n\n        Pair<VolumeVO, String> volumeDetails = createVolumeFromSnapshot(volume, snapshot, originalVolume.getSize());\n        createdVolume = volumeDetails.first();\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        // Create an event\n        Long templateId = originalVolume.getTemplateId();\n        ;\n        Long diskOfferingId = volume.getDiskOfferingId();\n\n        if (createdVolume.getPath() != null) {\n            Long offeringId = null;\n            if (diskOfferingId != null) {\n                DiskOfferingVO offering = _diskOfferingDao.findById(diskOfferingId);\n                if (offering != null && (offering.getType() == DiskOfferingVO.Type.Disk)) {\n                    offeringId = offering.getId();\n                }\n            }\n\n            UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(),\n                    volume.getId(), volume.getName(), offeringId, templateId, createdVolume.getSize());\n            _usageEventDao.persist(usageEvent);\n        }\n        txn.commit();\n        return createdVolume;\n    }","id":41228,"modified_method":"@DB\n    protected VolumeVO createVolumeFromSnapshot(VolumeVO volume, long snapshotId) {\n\n        // By default, assume failure.\n        VolumeVO createdVolume = null;\n        SnapshotVO snapshot = _snapshotDao.findById(snapshotId); // Precondition: snapshot is not null and not removed.\n        Long origVolumeId = snapshot.getVolumeId();\n        VolumeVO originalVolume = _volsDao.findById(origVolumeId); // NOTE: Original volume could be destroyed and removed.\n\n        Pair<VolumeVO, String> volumeDetails = createVolumeFromSnapshot(volume, snapshot, originalVolume.getSize());\n        createdVolume = volumeDetails.first();\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        // Create an event\n        Long templateId = originalVolume.getTemplateId();\n        ;\n        Long diskOfferingId = originalVolume.getDiskOfferingId();\n\n        if (createdVolume.getPath() != null) {\n            Long offeringId = null;\n            if (diskOfferingId != null) {\n                DiskOfferingVO offering = _diskOfferingDao.findById(diskOfferingId);\n                if (offering != null && (offering.getType() == DiskOfferingVO.Type.Disk)) {\n                    offeringId = offering.getId();\n                }\n            }\n\n            UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(),\n                    volume.getId(), volume.getName(), offeringId, templateId, createdVolume.getSize());\n            _usageEventDao.persist(usageEvent);\n        }\n        txn.commit();\n        return createdVolume;\n    }","commit_id":"bae62f844d6d9d4a7db8147ea0246d9dafbf05a3","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Handles a node lost service event. Add a lost service entry to the right\n     * node\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void nodeLostService(long nodeid, String ip, String svcName, long t) {\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n        RTCNode rtcN = (RTCNode) m_map.get(key);\n        if (rtcN == null) {\n            // oops! got a lost/regained service for a node that is not known?\n            log().info(\"Received a nodeLostService event for an unknown/irrelevant node: \" + key.toString());\n            return;\n        }\n\n        // inform node\n        rtcN.nodeLostService(t);\n\n    }","id":41229,"modified_method":"/**\n     * Handles a node lost service event. Add a lost service entry to the right\n     * node\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void nodeLostService(long nodeid, String ip, String svcName, long t) {\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n        RTCNode rtcN = m_map.getRTCNode(key);\n        if (rtcN == null) {\n            // oops! got a lost/regained service for a node that is not known?\n            log().info(\"Received a nodeLostService event for an unknown/irrelevant node: \" + key.toString());\n            return;\n        }\n\n        // inform node\n        rtcN.nodeLostService(t);\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete a node/ip/service to the specified category.\n     * \n     * Note: This will not delete the service, it will just remove the node from\n     * the category.\n     * \n     * @param nodeid\n     *            the nodeid to be added\n     * @param ip\n     *            the interface to be added\n     * @param svcname\n     *            the service to be added\n     * @param cat\n     *            the category to which this node is to be added to\n     */\n    private void delNodeIpSvcToCategory(long nodeid, String ip, String svcname, RTCCategory cat) {\n        //\n        // check if the node is already part of the tree, if yes,\n        // simply remove the current category information\n        //\n\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcname);\n        RTCNode rtcN = (RTCNode) m_map.get(key);\n        if (rtcN != null) {\n\n            String catlabel = cat.getLabel();\n\n            // get nodes in this category\n            List catNodes = cat.getNodes();\n\n            // check if the category contains this node\n            Long tmpNodeid = new Long(rtcN.getNodeID());\n            int nIndex = catNodes.indexOf(tmpNodeid);\n            if (nIndex != -1) {\n                // remove from the category\n                catNodes.remove(nIndex);\n                log().info(\"Removing node from category: \" + catlabel);\n\n                // let the node know that this category is out\n                rtcN.removeCategory(catlabel);\n            }\n        }\n\n        // allow for gc\n        rtcN = null;\n    }","id":41230,"modified_method":"/**\n     * Poplulates nodes from the database. For each category in the categories\n     * list, this reads the services and outage tables to get the initial data,\n     * creates 'RTCNode' objects that are added to the map and and to the\n     * appropriate category.\n     * @param dbConn\n     *            the database connection.\n     * \n     * @throws SQLException\n     *             if the database read fails due to an SQL error\n     * @throws FilterParseException\n     *             if filtering the data against the category rule fails due to\n     *             the rule being incorrect\n     * @throws RTCException\n     *             if the database read or filtering the data against the\n     *             category rule fails for some reason\n     */\n    private void populateNodesFromDB(String query, Object[] args) throws SQLException, FilterParseException, RTCException {\n\n    \tfinal String getOutagesInWindow = \n    \t\t\t\"select \" + \n    \t\t\t\"       ifsvc.nodeid as nodeid, \" + \n    \t\t\t\"       ifsvc.ipAddr as ipaddr, \" + \n    \t\t\t\"       s.servicename as servicename, \" + \n    \t\t\t\"       o.ifLostService as ifLostService, \" + \n    \t\t\t\"       o.ifRegainedService as ifRegainedService \" + \n    \t\t\t\"  from \" + \n    \t\t\t\"       ifservices ifsvc \" + \n    \t\t\t\"  join \" + \n    \t\t\t\"       service s on (ifsvc.serviceid = s.serviceid) \" + \n    \t\t\t\"left outer  join \" + \n    \t\t\t\"       outages o on \" +\n    \t\t\t\"          (\" + \n    \t\t\t\"            o.nodeid = ifsvc.nodeid \" + \n    \t\t\t\"            and o.ipaddr = ifsvc.ipaddr \" + \n    \t\t\t\"            and o.serviceid = ifsvc.serviceid \" + \n    \t\t\t\"            and \" +\n    \t\t\t\"            (\" + \n    \t\t\t\"               o.ifLostService > ? \" + \n    \t\t\t\"               OR  o.ifRegainedService > ? \" + \n    \t\t\t\"               OR  o.ifRegainedService is null \" +\n    \t\t\t\"            )\" +\n    \t\t\t\"          ) \" +\n    \t\t\t\"order by \" + \n    \t\t\t\"       ifsvc.nodeid, ifsvc.ipAddr, ifsvc.serviceid, o.ifLostService \" +\n    \t\t\t(query == null ? \"\" : \"where \"+query);\n    \t\n\t\tlong window = (new Date()).getTime() - RTCManager.getRollingWindow();\n\t\tTimestamp windowTS = new Timestamp(window);\n    \t\n    \tRowCallbackHandler rowHandler = new RTCNodeProcessor();\n\n    \tObject[] sqlArgs = createArgs(windowTS, windowTS, args);\n    \t\n    \tJdbcTemplate template = new JdbcTemplate(getConnectionFactory());\n    \ttemplate.query(getOutagesInWindow, sqlArgs, rowHandler);\n    \t\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add a lost service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void interfaceDown(long nodeid, String ip, long t) {\n        String key = Long.toString(nodeid) + ip;\n        List nodesList = (List) m_map.get(key);\n        if (nodesList == null) {\n            // nothing to do - node/ip probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeLostService(t);\n        }\n    }","id":41231,"modified_method":"/**\n     * Add a lost service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void interfaceDown(long nodeid, String ip, long t) {\n        List nodesList = m_map.getRTCNodes(nodeid, ip);\n        if (nodesList == null) {\n            // nothing to do - node/ip probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeLostService(t);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the 'ismanaged' status for the nodeid, ipaddr combination\n     * \n     * @param nodeid\n     *            the nodeid of the interface\n     * @param ip\n     *            the interface for which the status is required\n     * @param svc\n     *            the service for which status is required\n     * \n     * @return the 'status' from the ifservices table\n     */\n    private char getServiceStatus(long nodeid, String ip, String svc) {\n        //\n        // check the 'status' flag\n        //\n        char status = '\\0';\n        ResultSet statusRS = null;\n\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n\n            // Prepare statement to get the 'status' flag for a\n            // nodeid/IP/service\n            PreparedStatement svcStatusGetStmt = dbConn.prepareStatement(RTCConstants.DB_GET_SERVICE_STATUS);\n\n            svcStatusGetStmt.setLong(1, nodeid);\n            svcStatusGetStmt.setString(2, ip);\n            svcStatusGetStmt.setString(3, svc);\n            statusRS = svcStatusGetStmt.executeQuery();\n            if (statusRS.next()) {\n                String statusStr = statusRS.getString(1);\n                status = statusStr.charAt(0);\n            }\n\n            // close statement\n            svcStatusGetStmt.close();\n        } catch (SQLException ipe) {\n            log().warn(\"Error reading status for: \" + nodeid + \"/\" + ip + \"/\" + svc, ipe);\n\n            status = '\\0';\n        } finally {\n            try {\n                if (statusRS != null)\n                    statusRS.close();\n            } catch (Exception e) {\n                if (log().isDebugEnabled())\n                    log().debug(\"Exception while closing the service status result set\", e);\n            }\n\n            try {\n                if (dbConn != null)\n                    dbConn.close();\n            } catch (SQLException e) {\n                ThreadCategory.getInstance(getClass()).warn(\"Exception closing JDBC connection\", e);\n            }\n\n        }\n\n        return status;\n    }","id":41232,"modified_method":"/**\n     * Get the 'ismanaged' status for the nodeid, ipaddr combination\n     * \n     * @param nodeid\n     *            the nodeid of the interface\n     * @param ip\n     *            the interface for which the status is required\n     * @param svc\n     *            the service for which status is required\n     * \n     * @return the 'status' from the ifservices table\n     */\n    private char getServiceStatus(long nodeid, String ip, String svc) {\n    \t\n    \tJdbcTemplate template = new JdbcTemplate(getConnectionFactory());\n    \tString status= (String)template.queryForObject(RTCConstants.DB_GET_SERVICE_STATUS, new Object[] { new Long(nodeid), ip, svc }, String.class);\n\n    \tif (status == null) return '\\0';\n    \treturn status.charAt(0);\n    \t\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Update the categories for a node. This method will update the categories\n     * for all interfaces on a node.\n     * \n     * @param nodeid\n     *            the nodeid on which SNMP service was added\n     * \n     * @throws SQLException\n     *             if the database read fails due to an SQL error\n     * @throws FilterParseException\n     *             if filtering the data against the category rule fails due to\n     *             the rule being incorrect\n     * @throws RTCException\n     *             if the database read or filtering the data against the\n     *             category rule fails for some reason\n     */\n    public synchronized void rtcNodeRescan(long nodeid) throws SQLException, FilterParseException, RTCException {\n        // Get a new database connection\n        java.sql.Connection dbConn = null;\n        ResultSet ipRS = null;\n        try {\n            try {\n                dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            } catch (SQLException ex) {\n                log().warn(\"Failed to get database connection\", ex);\n                throw new UndeclaredThrowableException(ex);\n            }\n\n            // Prepare the statement to get the IP addresses assigned to a node.\n            PreparedStatement nodeIPsGetStmt = dbConn.prepareStatement(RTCConstants.SQL_DB_NODE_IPADDRS);\n\n            // get IP addresses for this node\n\n            nodeIPsGetStmt.setString(1, String.valueOf(nodeid));\n\n            ipRS = nodeIPsGetStmt.executeQuery();\n            while (ipRS.next()) {\n                // Call the method to rescan the node and IP address\n                rtcNodeIpRescan(nodeid, ipRS.getString(1));\n            }\n        }\n\n        finally {\n            try {\n                if (ipRS != null)\n                    ipRS.close();\n            } catch (Exception e) {\n                if (log().isDebugEnabled())\n                    log().debug(\"Exception while closing the get node IPs result set - node: \" + nodeid, e);\n            }\n        }\n    }","id":41233,"modified_method":"/**\n     * Update the categories for a node. This method will update the categories\n     * for all interfaces on a node.\n     * \n     * @param nodeid\n     *            the nodeid on which SNMP service was added\n     * \n     * @throws SQLException\n     *             if the database read fails due to an SQL error\n     * @throws FilterParseException\n     *             if filtering the data against the category rule fails due to\n     *             the rule being incorrect\n     * @throws RTCException\n     *             if the database read or filtering the data against the\n     *             category rule fails for some reason\n     */\n    public synchronized void rtcNodeRescan(long nodeid) throws SQLException, FilterParseException, RTCException {\n    \t\n    \tfor (Iterator it = m_categories.values().iterator(); it.hasNext();) {\n\t\t\tRTCCategory cat = (RTCCategory) it.next();\n\t\t\tcat.deleteNode(nodeid);\n\t\t}\n    \t\n    \tm_map.deleteNode(nodeid);\n    \t\n    \tpopulateNodesFromDB(\"ifsvc.nodeid = ?\", new Object[] { new Long(nodeid) });\n    \t\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add a lost service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void nodeDown(long nodeid, long t) {\n        Long key = new Long(nodeid);\n        List nodesList = (List) m_map.get(key);\n        if (nodesList == null) {\n            // nothing to do - node probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeLostService(t);\n        }\n    }","id":41234,"modified_method":"/**\n     * Add a lost service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param t\n     *            the time at which service was lost\n     */\n    public synchronized void nodeDown(long nodeid, long t) {\n    \tList nodesList = m_map.getRTCNodes(nodeid);\n        if (nodesList == null) {\n            // nothing to do - node probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeLostService(t);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add a regained service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void interfaceUp(long nodeid, String ip, long t) {\n        String key = Long.toString(nodeid) + ip;\n        List nodesList = (List) m_map.get(key);\n        if (nodesList == null) {\n            // nothing to do - node/ip probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeRegainedService(t);\n        }\n    }","id":41235,"modified_method":"/**\n     * Add a regained service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void interfaceUp(long nodeid, String ip, long t) {\n        List nodesList = m_map.getRTCNodes(nodeid, ip);\n        if (nodesList == null) {\n            // nothing to do - node/ip probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeRegainedService(t);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Handles a node gained service event. Add a new entry to the map and the\n     * categories on a 'serviceGained' event\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * \n     */\n    public synchronized void nodeGainedService(long nodeid, String ip, String svcName) {\n        //\n        // check the 'status' flag for the service\n        //\n        char svcStatus = getServiceStatus(nodeid, ip, svcName);\n\n        //\n        // Include only service status 'A' and where service is not SNMP\n        //\n        if (svcStatus != 'A') {\n            if (log().isInfoEnabled())\n                log().info(\"nodeGainedSvc: \" + nodeid + \"/\" + ip + \"/\" + svcName + \" IGNORED because status is not active: \" + svcStatus);\n        } else {\n            if (log().isDebugEnabled())\n                log().debug(\"nodeGainedSvc: \" + nodeid + \"/\" + ip + \"/\" + svcName + \"/\" + svcStatus);\n\n            // I ran into problems with adding new services, so I just ripped\n            // all that out and added\n            // a call to the rescan method. -T\n\n            // Hrm - since the rules can be based on things other than the\n            // service name\n            // we really need to rescan every time a new service is discovered.\n            // For\n            // example, if I have a category where the rule is \"ipaddr =\n            // 10.1.1.1 & isHTTP\"\n            // yet I only have ICMP in the service list, the node will not be\n            // added when\n            // HTTP is discovered, because it is not in the services list.\n            // \n            // This is mainly useful when SNMP is discovered on a node.\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"rtcN : Rescanning services on : \" + ip);\n            }\n            try {\n                rtcNodeIpRescan(nodeid, ip);\n            } catch (FilterParseException ex) {\n                log().warn(\"Failed to unmarshall database config\", ex);\n                throw new UndeclaredThrowableException(ex);\n            } catch (SQLException ex) {\n                log().warn(\"Failed to get database connection\", ex);\n                throw new UndeclaredThrowableException(ex);\n            } catch (RTCException ex) {\n                log().warn(\"Failed to get database connection\", ex);\n                throw new UndeclaredThrowableException(ex);\n            }\n\n        }\n\n    }","id":41236,"modified_method":"/**\n     * Handles a node gained service event. Add a new entry to the map and the\n     * categories on a 'serviceGained' event\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * \n     */\n    public synchronized void nodeGainedService(long nodeid, String ip, String svcName) {\n        //\n        // check the 'status' flag for the service\n        //\n        char svcStatus = getServiceStatus(nodeid, ip, svcName);\n\n        //\n        // Include only service status 'A' and where service is not SNMP\n        //\n        if (svcStatus != 'A') {\n            if (log().isInfoEnabled())\n                log().info(\"nodeGainedSvc: \" + nodeid + \"/\" + ip + \"/\" + svcName + \" IGNORED because status is not active: \" + svcStatus);\n        } else {\n            if (log().isDebugEnabled())\n                log().debug(\"nodeGainedSvc: \" + nodeid + \"/\" + ip + \"/\" + svcName + \"/\" + svcStatus);\n\n            // I ran into problems with adding new services, so I just ripped\n            // all that out and added\n            // a call to the rescan method. -T\n\n            // Hrm - since the rules can be based on things other than the\n            // service name\n            // we really need to rescan every time a new service is discovered.\n            // For\n            // example, if I have a category where the rule is \"ipaddr =\n            // 10.1.1.1 & isHTTP\"\n            // yet I only have ICMP in the service list, the node will not be\n            // added when\n            // HTTP is discovered, because it is not in the services list.\n            // \n            // This is mainly useful when SNMP is discovered on a node.\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"rtcN : Rescanning services on : \" + ip);\n            }\n            try {\n                rtcNodeRescan(nodeid);\n            } catch (FilterParseException ex) {\n                log().warn(\"Failed to unmarshall database config\", ex);\n                throw new UndeclaredThrowableException(ex);\n            } catch (SQLException ex) {\n                log().warn(\"Failed to get database connection\", ex);\n                throw new UndeclaredThrowableException(ex);\n            } catch (RTCException ex) {\n                log().warn(\"Failed to get database connection\", ex);\n                throw new UndeclaredThrowableException(ex);\n            }\n\n        }\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Remove node from the map and the categories on a 'serviceDeleted' event.\n     * \n     * @param nodeid\n     *            the nodeid on which service was deleted\n     * @param ip\n     *            the ip on which service was deleted\n     * @param svcName\n     *            the service that was deleted\n     */\n    public synchronized void serviceDeleted(long nodeid, String ip, String svcName) {\n        // create lookup key\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n\n        // lookup the node\n        RTCNode rtcN = (RTCNode) m_map.get(key);\n        if (rtcN == null) {\n            log().warn(\"Received a \" + EventConstants.SERVICE_DELETED_EVENT_UEI + \" event for an unknown node: \" + key.toString());\n\n            return;\n        }\n\n        //\n        // Go through from all the categories this node belongs to\n        // and delete the service\n        //\n        List categories = rtcN.getCategories();\n        ListIterator catIter = categories.listIterator();\n        while (catIter.hasNext()) {\n            String catlabel = (String) catIter.next();\n\n            RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n\n            // get nodes in this category\n            List catNodes = cat.getNodes();\n\n            // check if the category contains this node\n            Long tmpNodeid = new Long(rtcN.getNodeID());\n            int nIndex = catNodes.indexOf(tmpNodeid);\n            if (nIndex != -1) {\n                // remove from the category if it is the only service left.\n                if (m_map.getServiceCount(nodeid, catlabel) == 1) {\n                    catNodes.remove(nIndex);\n                    log().info(\"Removing node from category: \" + catlabel);\n                }\n\n                // let the node know that this category is out\n                catIter.remove();\n            }\n        }\n\n        // finally remove from map\n\n        m_map.remove(key);\n        m_map.delete(rtcN.getNodeID(), rtcN);\n        m_map.delete(rtcN.getNodeID(), rtcN.getIP(), rtcN);\n\n        // allow for gc\n        rtcN = null;\n\n    }","id":41237,"modified_method":"/**\n     * Remove node from the map and the categories on a 'serviceDeleted' event.\n     * \n     * @param nodeid\n     *            the nodeid on which service was deleted\n     * @param ip\n     *            the ip on which service was deleted\n     * @param svcName\n     *            the service that was deleted\n     */\n    public synchronized void serviceDeleted(long nodeid, String ip, String svcName) {\n        // create lookup key\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n\n        // lookup the node\n        RTCNode rtcN = m_map.getRTCNode(key);\n        if (rtcN == null) {\n            log().warn(\"Received a \" + EventConstants.SERVICE_DELETED_EVENT_UEI + \" event for an unknown node: \" + key.toString());\n\n            return;\n        }\n\n        //\n        // Go through from all the categories this node belongs to\n        // and delete the service\n        //\n        List categories = rtcN.getCategories();\n        ListIterator catIter = categories.listIterator();\n        while (catIter.hasNext()) {\n            String catlabel = (String) catIter.next();\n\n            RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n\n            // get nodes in this category\n            List catNodes = cat.getNodes();\n\n            // check if the category contains this node\n            Long tmpNodeid = new Long(rtcN.getNodeID());\n            int nIndex = catNodes.indexOf(tmpNodeid);\n            if (nIndex != -1) {\n                // remove from the category if it is the only service left.\n                if (m_map.getServiceCount(nodeid, catlabel) == 1) {\n                    catNodes.remove(nIndex);\n                    log().info(\"Removing node from category: \" + catlabel);\n                }\n\n                // let the node know that this category is out\n                catIter.remove();\n            }\n        }\n\n        // finally remove from map\n        \n        m_map.delete(rtcN);\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor. Parses categories from the categories.xml and populates them\n     * with 'RTCNode' objects created from data read from the database (services\n     * and outage tables)\n     * \n     * @exception SQLException\n     *                if there is an error reading initial data from the\n     *                database\n     * @exception FilterParseException\n     *                if a rule in the categories.xml was incorrect\n     * @exception RTCException\n     *                if the initialization/data reading does not go through\n     */\n    public DataManager() throws SAXException, IOException, SQLException, FilterParseException, RTCException {\n\t\t\t\n    \t// read the categories.xml to get all the categories\n    \tcreateCategoriesMap();\n\n    \tif (m_categories == null || m_categories.isEmpty()) {\n    \t\tthrow new RTCException(\"No categories found in categories.xml\");\n    \t}\n\n    \tif (log().isDebugEnabled())\n    \t\tlog().debug(\"Number of categories read: \" + m_categories.size());\n\n    \t// create data holder\n    \tm_map = new RTCHashMap(30000);\n\n    \t// Populate the nodes initially from the database\n    \tpopulateNodesFromDB();\n\n    }","id":41238,"modified_method":"/**\n     * Constructor. Parses categories from the categories.xml and populates them\n     * with 'RTCNode' objects created from data read from the database (services\n     * and outage tables)\n     * \n     * @exception SQLException\n     *                if there is an error reading initial data from the\n     *                database\n     * @exception FilterParseException\n     *                if a rule in the categories.xml was incorrect\n     * @exception RTCException\n     *                if the initialization/data reading does not go through\n     */\n    public DataManager() throws SAXException, IOException, SQLException, FilterParseException, RTCException {\n\t\t\t\n    \t// read the categories.xml to get all the categories\n    \tcreateCategoriesMap();\n\n    \tif (m_categories == null || m_categories.isEmpty()) {\n    \t\tthrow new RTCException(\"No categories found in categories.xml\");\n    \t}\n\n    \tif (log().isDebugEnabled())\n    \t\tlog().debug(\"Number of categories read: \" + m_categories.size());\n\n    \t// create data holder\n    \tm_map = new RTCHashMap(30000);\n\n    \t// Populate the nodes initially from the database\n    \tpopulateNodesFromDB(null, null);\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add a regained service entry to the right node.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void nodeRegainedService(long nodeid, String ip, String svcName, long t) {\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n        RTCNode rtcN = (RTCNode) m_map.get(key);\n        if (rtcN == null) {\n            // oops! got a lost/regained service for a node that is not known?\n            log().info(\"Received a nodeRegainedService event for an unknown/irrelevant node: \" + key.toString());\n            return;\n        }\n\n        // inform node\n        rtcN.nodeRegainedService(t);\n    }","id":41239,"modified_method":"/**\n     * Add a regained service entry to the right node.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service name\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void nodeRegainedService(long nodeid, String ip, String svcName, long t) {\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n        RTCNode rtcN = m_map.getRTCNode(key);\n        if (rtcN == null) {\n            // oops! got a lost/regained service for a node that is not known?\n            log().info(\"Received a nodeRegainedService event for an unknown/irrelevant node: \" + key.toString());\n            return;\n        }\n\n        // inform node\n        rtcN.nodeRegainedService(t);\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Reparent an interface. This effectively means updating the nodelist of\n     * the categories and the map\n     * \n     * Use the ip/oldnodeid combination to get all nodes that will be affected -\n     * for each of these nodes, remove the old entry and add a new one with new\n     * keys to the map\n     * \n     * <em>Note:<\/em> Each of these nodes could belong to more than one\n     * category. However, category rule evaluation is done based ONLY on the IP -\n     * therefore changing the nodeID on the node should update the categories\n     * appropriately\n     * \n     * @param ip\n     *            the interface to reparent\n     * @param oldNodeId\n     *            the node that the ip belonged to earlier\n     * @param newNodeId\n     *            the node that the ip now belongs to\n     */\n    public synchronized void interfaceReparented(String ip, long oldNodeId, long newNodeId) {\n        // get all RTCNodes with the ip/oldNodeId\n        String key = Long.toString(oldNodeId) + ip;\n        List nodesList = (List) m_map.get(key);\n        if (nodesList == null) {\n            // nothing to do - simply means ip does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // get the key for this node\n            RTCNodeKey rtcnKey = new RTCNodeKey(rtcN.getNodeID(), rtcN.getIP(), rtcN.getSvcName());\n\n            // remove the node pointed to by this key from the map\n            m_map.remove(rtcnKey);\n\n            // remove this node from the list pointed to\n            // by the nodeid key\n            m_map.delete(oldNodeId, rtcN);\n\n            // remove from current list pointed to by the iterator\n            listIter.remove();\n\n            //\n            // !!!!!NOTE!!!!!!!\n            // This node could belong to more than one\n            // category. However, category rule evaluation is done\n            // based ONLY on the IP - therefore there is no need to\n            // re-evaluate the validity against the rule\n            //\n\n            // change the nodeid on the RTCNode\n            rtcN.setNodeID(newNodeId);\n\n            // get the new key for this node\n            rtcnKey.setNodeID(newNodeId);\n\n            // add new node to the map\n            m_map.put(rtcnKey, rtcN);\n\n            // add to the nodeid map\n            m_map.add(newNodeId, rtcN);\n\n            // add to the nodeid/ip map\n            m_map.add(newNodeId, ip, rtcN);\n\n            // remove old nodeid from the categories it belonged to\n            // and the new nodeid\n            Iterator catIter = rtcN.getCategories().listIterator();\n            while (catIter.hasNext()) {\n                String catlabel = (String) catIter.next();\n\n                RTCCategory rtcCat = (RTCCategory) m_categories.get(catlabel);\n                rtcCat.deleteNode(oldNodeId);\n                rtcCat.addNode(newNodeId);\n            }\n\n        }\n    }","id":41240,"modified_method":"/**\n     * Reparent an interface. This effectively means updating the nodelist of\n     * the categories and the map\n     * \n     * Use the ip/oldnodeid combination to get all nodes that will be affected -\n     * for each of these nodes, remove the old entry and add a new one with new\n     * keys to the map\n     * \n     * <em>Note:<\/em> Each of these nodes could belong to more than one\n     * category. However, category rule evaluation is done based ONLY on the IP -\n     * therefore changing the nodeID on the node should update the categories\n     * appropriately\n     * \n     * @param ip\n     *            the interface to reparent\n     * @param oldNodeId\n     *            the node that the ip belonged to earlier\n     * @param newNodeId\n     *            the node that the ip now belongs to\n     */\n    public synchronized void interfaceReparented(String ip, long oldNodeId, long newNodeId) {\n        // get all RTCNodes with the ip/oldNodeId\n    \tList nodesList = m_map.getRTCNodes(oldNodeId, ip);\n        if (nodesList == null) {\n            // nothing to do - simply means ip does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list - make a copy as we modify it as we iterate\n        ListIterator listIter = new LinkedList(nodesList).listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // remove the node with the oldnode id from the map\n            m_map.delete(rtcN);\n\n            // change the nodeid on the RTCNode\n            rtcN.setNodeID(newNodeId);\n\n            // now add the node with the new nodeid\n            m_map.add(rtcN);\n\n            // remove old nodeid from the categories it belonged to\n            // and the new nodeid\n            Iterator catIter = rtcN.getCategories().listIterator();\n            while (catIter.hasNext()) {\n                String catlabel = (String) catIter.next();\n\n                RTCCategory rtcCat = (RTCCategory) m_categories.get(catlabel);\n                rtcCat.deleteNode(oldNodeId);\n                rtcCat.addNode(newNodeId);\n            }\n\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addRTCNode(RTCNode rtcN) {\n\t\t// Add node to the map\n\t\tm_map.put(new RTCNodeKey(rtcN.getNodeID(), rtcN.getIP(), rtcN.getSvcName()), rtcN);\n\n\t\t// node key map\n\t\tm_map.add(rtcN.getNodeID(), rtcN);\n\n\t\t// node and ip key map\n\t\tm_map.add(rtcN.getNodeID(), rtcN.getIP(), rtcN);\n\t}","id":41241,"modified_method":"private void addRTCNode(RTCNode rtcN) {\n\t\tm_map.add(rtcN);\n\t}","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add a regained service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void nodeUp(long nodeid, long t) {\n        Long key = new Long(nodeid);\n        List nodesList = (List) m_map.get(key);\n        if (nodesList == null) {\n            // nothing to do - node probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeRegainedService(t);\n        }\n    }","id":41242,"modified_method":"/**\n     * Add a regained service entry to the right nodes.\n     * \n     * @param nodeid\n     *            the node id\n     * @param t\n     *            the time at which service was regained\n     */\n    public synchronized void nodeUp(long nodeid, long t) {\n    \tList nodesList = m_map.getRTCNodes(nodeid);\n        if (nodesList == null) {\n            // nothing to do - node probably does not belong\n            // to any of the categories\n            return;\n        }\n\n        // iterate through this list\n        ListIterator listIter = nodesList.listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = (RTCNode) listIter.next();\n\n            // inform node\n            rtcN.nodeRegainedService(t);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * If it is a assetInfoChanged method, update RTC\n     */\n    private void handleAssetInfoChangedEvent(long nodeid) throws SQLException, FilterParseException, RTCException {\n        Category log = ThreadCategory.getInstance(DataUpdater.class);\n\n        DataManager dataMgr = RTCManager.getDataManager();\n\n        dataMgr.rtcNodeRescan(nodeid);\n\n        if (log.isDebugEnabled())\n            log.debug(m_event.getUei() + \" rescanned: \" + nodeid);\n\n    }","id":41243,"modified_method":"/**\n     * If it is a assetInfoChanged method, update RTC\n     */\n    private void handleAssetInfoChangedEvent(long nodeid) {\n        Category log = ThreadCategory.getInstance(DataUpdater.class);\n\n        DataManager dataMgr = RTCManager.getDataManager();\n\n        dataMgr.assetInfoChanged(nodeid);\n\n        if (log.isDebugEnabled())\n            log.debug(m_event.getUei() + \" rescanned: \" + nodeid);\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete the node from list with nodeid as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param rtcN\n     *            the RTCNode to delete\n     */\n    public void delete(long nodeid, RTCNode rtcN) {\n        Long key = new Long(nodeid);\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.remove(rtcN);\n        }\n    }","id":41244,"modified_method":"/**\n     * Delete the node from list with nodeid as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param rtcN\n     *            the RTCNode to delete\n     */\n    private void delete(long nodeid, RTCNode rtcN) {\n        Long key = new Long(nodeid);\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.remove(rtcN);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Default constructor\n     */\n    public RTCHashMap() {\n        super();\n    }","id":41245,"modified_method":"/**\n     * Default constructor\n     */\n    public RTCHashMap() {\n    \tm_map = new HashMap();\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * constructor\n     */\n    public RTCHashMap(int initialCapacity) {\n        super(initialCapacity);\n    }","id":41246,"modified_method":"/**\n     * constructor\n     */\n    public RTCHashMap(int initialCapacity) {\n        m_map = new HashMap(initialCapacity);\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value (uptime) for a category in the last 'rollingWindow'\n     * starting at current time\n     * \n     * @param catLabel\n     *            the category to which the node should belong to\n     * @param curTime\n     *            the current time\n     * @param rollingWindow\n     *            the window for which value is to be calculated\n     * \n     * @return the value(uptime) for the node\n     */\n    public double getValue(String catLabel, long curTime, long rollingWindow) {\n        // the value (uptime)\n        double value = 0.0;\n\n        // total outage time\n        long outageTime = 0;\n\n        // number of entries for this node\n        int count = 0;\n\n        // downtime for a node\n        long downTime = 0;\n\n        // get all nodes in the hashtable\n        Set keys = keySet();\n        Iterator keyIter = keys.iterator();\n        while (keyIter.hasNext()) {\n            // get only values of nodeids\n            Object key = keyIter.next();\n            if (!(key instanceof Long)) {\n                continue;\n            }\n\n            List valList = (List) get((Long) key);\n            if (valList == null || valList.size() == 0)\n                continue;\n\n            Iterator valIter = valList.iterator();\n            while (valIter.hasNext()) {\n                RTCNode node = (RTCNode) valIter.next();\n                downTime = node.getDownTime(catLabel, curTime, rollingWindow);\n                if (downTime < 0)\n                // node does not belong to category\n                // or RTCConstants.SERVICE_NOT_FOUND_VALUE\n                // or node / interface / service unmanaged\n                {\n                    continue;\n                }\n\n                outageTime += downTime;\n\n                count++;\n\n            }\n\n        }\n\n        double dOut = outageTime * 1.0;\n        double dRoll = rollingWindow * 1.0;\n\n        if (count > 0) {\n            value = 100 * (1 - (dOut / (dRoll * count)));\n        } else {\n            value = 100.0;\n        }\n\n        return value;\n    }","id":41247,"modified_method":"/**\n     * Get the value (uptime) for a category in the last 'rollingWindow'\n     * starting at current time\n     * \n     * @param catLabel\n     *            the category to which the node should belong to\n     * @param curTime\n     *            the current time\n     * @param rollingWindow\n     *            the window for which value is to be calculated\n     * \n     * @return the value(uptime) for the node\n     */\n    public double getValue(String catLabel, long curTime, long rollingWindow) {\n        // the value (uptime)\n        double value = 0.0;\n\n        // total outage time\n        long outageTime = 0;\n\n        // number of entries for this node\n        int count = 0;\n\n        // downtime for a node\n        long downTime = 0;\n\n        // get all nodes in the hashtable\n        List nodes = getNodeIDs();\n        Iterator it = nodes.iterator();\n        while (it.hasNext()) {\n            // get only values of nodeids\n            Long key = (Long)it.next();\n            List valList = getRTCNodes(key.longValue());\n            if (valList == null || valList.size() == 0)\n                continue;\n\n            Iterator valIter = valList.iterator();\n            while (valIter.hasNext()) {\n                RTCNode node = (RTCNode) valIter.next();\n                downTime = node.getDownTime(catLabel, curTime, rollingWindow);\n                if (downTime < 0)\n                // node does not belong to category\n                // or RTCConstants.SERVICE_NOT_FOUND_VALUE\n                // or node / interface / service unmanaged\n                {\n                    continue;\n                }\n\n                outageTime += downTime;\n\n                count++;\n\n            }\n\n        }\n\n        double dOut = outageTime * 1.0;\n        double dRoll = rollingWindow * 1.0;\n\n        if (count > 0) {\n            value = 100 * (1 - (dOut / (dRoll * count)));\n        } else {\n            value = 100.0;\n        }\n\n        return value;\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the count of services for a node in the context of the the specified\n     * category\n     * \n     * @param nodeid\n     *            the node for which servicecount is needed\n     * @param catLabel\n     *            the category to which the node should belong to\n     * \n     * @return the service count for the nodeid in the context of the specfied\n     *         category\n     */\n    public int getServiceCount(long nodeid, String catLabel) {\n        // the count\n        int count = 0;\n\n        // get nodeslist\n        List nodesList = (List) get(new Long(nodeid));\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.belongsTo(catLabel))\n                count++;\n\n        }\n\n        return count;\n    }","id":41248,"modified_method":"/**\n     * Get the count of services for a node in the context of the the specified\n     * category\n     * \n     * @param nodeid\n     *            the node for which servicecount is needed\n     * @param catLabel\n     *            the category to which the node should belong to\n     * \n     * @return the service count for the nodeid in the context of the specfied\n     *         category\n     */\n    public int getServiceCount(long nodeid, String catLabel) {\n        // the count\n        int count = 0;\n\n        // get nodeslist\n        List nodesList = getRTCNodes(nodeid);\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.belongsTo(catLabel))\n                count++;\n\n        }\n\n        return count;\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add the node with nodeid as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    public void add(long nodeid, RTCNode rtcN) {\n        Long key = new Long(nodeid);\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.add(rtcN);\n        } else {\n            // add current node to list\n            nodesList = new ArrayList();\n            nodesList.add(rtcN);\n\n            // add list to map\n            put(key, nodesList);\n        }\n    }","id":41249,"modified_method":"/**\n     * Add the node with nodeid as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    private void add(long nodeid, RTCNode rtcN) {\n        Long key = new Long(nodeid);\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.add(rtcN);\n        } else {\n            // add current node to list\n            nodesList = new ArrayList();\n            nodesList.add(rtcN);\n\n            // add list to map\n            put(key, nodesList);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add the rtc node with nodeid and ip as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param ip\n     *            the ip\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    public void add(long nodeid, String ip, RTCNode rtcN) {\n        String key = Long.toString(nodeid) + ip;\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.add(rtcN);\n        } else {\n            // add current node to list\n            nodesList = new ArrayList();\n            nodesList.add(rtcN);\n\n            // add list to map\n            put(key, nodesList);\n        }\n    }","id":41250,"modified_method":"/**\n     * Add the rtc node with nodeid and ip as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param ip\n     *            the ip\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    private void add(long nodeid, String ip, RTCNode rtcN) {\n        String key = Long.toString(nodeid) + ip;\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.add(rtcN);\n        } else {\n            // add current node to list\n            nodesList = new ArrayList();\n            nodesList.add(rtcN);\n\n            // add list to map\n            put(key, nodesList);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Check if this IP has already been validated for this category\n     * \n     * @param nodeid\n     *            the node id whose interface is to be validated\n     * @param ip\n     *            the ip to be validated\n     * @param catLabel\n     *            the category whose rule this ip is to pass\n     * \n     * @return true if ip has already been validated, false otherwise\n     */\n    public boolean isIpValidated(long nodeid, String ip, String catLabel) {\n        List nodesList = (List) get(Long.toString(nodeid) + ip);\n        if (nodesList == null) {\n            return false;\n        }\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n            if (node.belongsTo(catLabel)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }","id":41251,"modified_method":"/**\n     * Check if this IP has already been validated for this category\n     * \n     * @param nodeid\n     *            the node id whose interface is to be validated\n     * @param ip\n     *            the ip to be validated\n     * @param catLabel\n     *            the category whose rule this ip is to pass\n     * \n     * @return true if ip has already been validated, false otherwise\n     */\n    public boolean isIpValidated(long nodeid, String ip, String catLabel) {\n        List nodesList = getRTCNodes(nodeid, ip);\n        if (nodesList == null) {\n            return false;\n        }\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n            if (node.belongsTo(catLabel)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * constructor\n     */\n    public RTCHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }","id":41252,"modified_method":"/**\n     * constructor\n     */\n    public RTCHashMap(int initialCapacity, float loadFactor) {\n    \tm_map = new HashMap(initialCapacity, loadFactor);\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete the rtc node from list with nodeid and ip as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param ip\n     *            the ip\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    public void delete(long nodeid, String ip, RTCNode rtcN) {\n        String key = Long.toString(nodeid) + ip;\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.remove(rtcN);\n        }\n    }","id":41253,"modified_method":"/**\n     * Delete the rtc node from list with nodeid and ip as key\n     * \n     * @param nodeid\n     *            the nodeid\n     * @param ip\n     *            the ip\n     * @param rtcN\n     *            the RTCNode to add\n     */\n    private void delete(long nodeid, String ip, RTCNode rtcN) {\n        String key = Long.toString(nodeid) + ip;\n\n        List nodesList = (List) get(key);\n        if (nodesList != null) {\n            nodesList.remove(rtcN);\n        }\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value (uptime) for the a node that belongs to the category in the\n     * last 'rollingWindow' starting at current time\n     * \n     * @param nodeid\n     *            the node for which value is to be calculated\n     * @param catLabel\n     *            the category to which the node should belong to\n     * @param curTime\n     *            the current time\n     * @param rollingWindow\n     *            the window for which value is to be calculated\n     * \n     * @return the value(uptime) for the node\n     */\n    public double getValue(long nodeid, String catLabel, long curTime, long rollingWindow) {\n        // the value (uptime)\n        double value = 0.0;\n\n        // total outage time\n        long outageTime = 0;\n\n        // number of entries for this node\n        int count = 0;\n\n        // downtime for a node\n        long downTime = 0;\n\n        // get nodeslist\n        List nodesList = (List) get(new Long(nodeid));\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.getNodeID() == nodeid) {\n                downTime = node.getDownTime(catLabel, curTime, rollingWindow);\n                if (downTime < 0)\n                // node does not belong to category\n                // or RTCConstants.SERVICE_NOT_FOUND_VALUE\n                // or node / interface / service unmanaged\n                {\n                    continue;\n                }\n\n                outageTime += downTime;\n\n                count++;\n\n            }\n        }\n\n        double dOut = outageTime * 1.0;\n        double dRoll = rollingWindow * 1.0;\n\n        if (count > 0) {\n            value = 100 * (1 - (dOut / (dRoll * count)));\n        } else {\n            value = 100.0;\n        }\n\n        return value;\n    }","id":41254,"modified_method":"/**\n     * Get the value (uptime) for the a node that belongs to the category in the\n     * last 'rollingWindow' starting at current time\n     * \n     * @param nodeid\n     *            the node for which value is to be calculated\n     * @param catLabel\n     *            the category to which the node should belong to\n     * @param curTime\n     *            the current time\n     * @param rollingWindow\n     *            the window for which value is to be calculated\n     * \n     * @return the value(uptime) for the node\n     */\n    public double getValue(long nodeid, String catLabel, long curTime, long rollingWindow) {\n        // the value (uptime)\n        double value = 0.0;\n\n        // total outage time\n        long outageTime = 0;\n\n        // number of entries for this node\n        int count = 0;\n\n        // downtime for a node\n        long downTime = 0;\n\n        // get nodeslist\n        List nodesList = getRTCNodes(nodeid);\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.getNodeID() == nodeid) {\n                downTime = node.getDownTime(catLabel, curTime, rollingWindow);\n                if (downTime < 0)\n                // node does not belong to category\n                // or RTCConstants.SERVICE_NOT_FOUND_VALUE\n                // or node / interface / service unmanaged\n                {\n                    continue;\n                }\n\n                outageTime += downTime;\n\n                count++;\n\n            }\n        }\n\n        double dOut = outageTime * 1.0;\n        double dRoll = rollingWindow * 1.0;\n\n        if (count > 0) {\n            value = 100 * (1 - (dOut / (dRoll * count)));\n        } else {\n            value = 100.0;\n        }\n\n        return value;\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the count of services currently down for a node in the context of the\n     * the specified category\n     * \n     * @param nodeid\n     *            the node for which servicecount is needed\n     * @param catLabel\n     *            the category to which the node should belong to\n     * \n     * @return the service down count for the nodeid in the context of the\n     *         specfied category\n     */\n    public int getServiceDownCount(long nodeid, String catLabel) {\n        // the count\n        int count = 0;\n\n        // get nodeslist\n        List nodesList = (List) get(new Long(nodeid));\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.belongsTo(catLabel) && node.isServiceCurrentlyDown()) {\n                count++;\n            }\n        }\n\n        return count;\n    }","id":41255,"modified_method":"/**\n     * Get the count of services currently down for a node in the context of the\n     * the specified category\n     * \n     * @param nodeid\n     *            the node for which servicecount is needed\n     * @param catLabel\n     *            the category to which the node should belong to\n     * \n     * @return the service down count for the nodeid in the context of the\n     *         specfied category\n     */\n    public int getServiceDownCount(long nodeid, String catLabel) {\n        // the count\n        int count = 0;\n\n        // get nodeslist\n        List nodesList = getRTCNodes(nodeid);\n        Iterator iter = nodesList.iterator();\n        while (iter.hasNext()) {\n            RTCNode node = (RTCNode) iter.next();\n\n            if (node.belongsTo(catLabel) && node.isServiceCurrentlyDown()) {\n                count++;\n            }\n        }\n\n        return count;\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service\n     */\n    public RTCNode(long nodeid, String ip, String svcName) {\n        m_nodeID = nodeid;\n\n        setIP(ip);\n\n        m_svcName = svcName;\n\n        m_svcTimesList = new RTCNodeSvcTimesList();\n        m_categories = new ArrayList();\n    }","id":41256,"modified_method":"/**\n     * Constructor.\n     * \n     * @param nodeid\n     *            the node id\n     * @param ip\n     *            the IP address\n     * @param svcName\n     *            the service\n     */\n    public RTCNode(long nodeid, String ip, String svcName) {\n        m_nodeID = nodeid;\n\n        m_ip = ip;\n\n        m_svcName = svcName;\n\n        m_svcTimesList = new RTCNodeSvcTimesList();\n        m_categories = new ArrayList();\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Default constructor. Initializes all values\n     */\n    public RTCNode() {\n        m_nodeID = -1;\n\n        m_ip = null;\n\n        m_svcName = null;\n\n        m_svcTimesList = new RTCNodeSvcTimesList();\n        m_categories = new ArrayList();\n    }","id":41257,"modified_method":"/**\n     * Default constructor. Initializes all values\n     */\n    public RTCNode() {\n    \tthis(-1, null, null);\n    }","commit_id":"96c03f48ff4adbd0c27fc41e6bdb0c664146f541","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected HttpMethod execute(UMOEvent event, HttpMethod httpMethod, boolean closeConnection) throws Exception\n    {\n\n        //todo set connection timeout buffer etc\n        try {\n            URI uri = event.getEndpoint().getEndpointURI().getUri();\n\n            try {\n                processCookies(event);\n                client.executeMethod(getHostConfig(uri), httpMethod);\n            } catch(Exception e) {\n                logger.error(e, e);\n            }\n            return httpMethod;\n        } catch (Exception e) {\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        } finally {\n            if (httpMethod != null && closeConnection)\n                httpMethod.releaseConnection();\n        }\n    }","id":41258,"modified_method":"protected HttpMethod execute(UMOEvent event, HttpMethod httpMethod, boolean closeConnection)\n            throws Exception\n    {\n        // TODO set connection timeout buffer etc\n        try {\n            URI uri = event.getEndpoint().getEndpointURI().getUri();\n\n            try {\n                processCookies(event);\n                client.executeMethod(getHostConfig(uri), httpMethod);\n            }\n            catch (Exception e) {\n                logger.error(e, e);\n            }\n            return httpMethod;\n        }\n        catch (Exception e) {\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        }\n        finally {\n            if (httpMethod != null && closeConnection) {\n                httpMethod.releaseConnection();\n            }\n        }\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage receive(UMOEndpointURI endpointUri, long timeout) throws Exception\n    {\n\n            if (endpointUri == null)\n                return null;\n\n            HttpMethod httpMethod = new GetMethod(endpointUri.getAddress());\n            httpMethod.setDoAuthentication(true);\n            if (endpointUri.getUserInfo() != null) {\n                // Add User Creds\n                StringBuffer header = new StringBuffer();\n                header.append(\"Basic \");\n                header.append(new BASE64Encoder().encode(endpointUri.getUserInfo().getBytes()));\n                httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n            }\n         try {\n            HttpClient client = new HttpClient();\n\n            client.executeMethod(httpMethod);\n            //httpMethod.execute(state, connection);\n\n            if (httpMethod.getStatusCode() == HttpStatus.SC_OK) {\n                return (UMOMessage) receiveTransformer.transform(httpMethod);\n            } else {\n                throw new ReceiveException(new Message(\"http\", 3, httpMethod.getStatusLine().toString()),\n                                           endpointUri,\n                                           timeout);\n            }\n        } catch (ReceiveException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ReceiveException(endpointUri, timeout, e);\n        } finally {\n            if (httpMethod != null)\n                httpMethod.releaseConnection();\n        }\n    }","id":41259,"modified_method":"public UMOMessage receive(UMOEndpointURI endpointUri, long timeout) throws Exception\n    {\n        if (endpointUri == null) {\n            return null;\n        }\n\n        HttpMethod httpMethod = new GetMethod(endpointUri.getAddress());\n        httpMethod.setDoAuthentication(true);\n        if (endpointUri.getUserInfo() != null) {\n            // Add User Creds\n            // TODO take encodings into account\n            StringBuffer header = new StringBuffer(64);\n            header.append(\"Basic \");\n            header.append(new String(Base64.encodeBase64(endpointUri.getUserInfo().getBytes())));\n            httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n        }\n        try {\n            HttpClient client = new HttpClient();\n            client.executeMethod(httpMethod);\n\n            if (httpMethod.getStatusCode() == HttpStatus.SC_OK) {\n                return (UMOMessage)receiveTransformer.transform(httpMethod);\n            }\n            else {\n                throw new ReceiveException(\n                        new Message(\"http\", 3, httpMethod.getStatusLine().toString()), endpointUri,\n                        timeout);\n            }\n        }\n        catch (ReceiveException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new ReceiveException(endpointUri, timeout, e);\n        }\n        finally {\n            httpMethod.releaseConnection();\n        }\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HostConfiguration getHostConfig(URI uri) throws URISyntaxException\n    {\n        Protocol protocol = Protocol.getProtocol(uri.getScheme().toLowerCase());\n\n        String host = uri.getHost();\n        int port = uri.getPort();\n        HostConfiguration config = new HostConfiguration();\n        config.setHost(host, port, protocol);\n        if(!Utility.isEmpty(connector.getProxyHostname())) {\n            //add proxy support\n            config.setProxy(connector.getProxyHostname(), connector.getProxyPort());\n        }\n        return config;\n    }","id":41260,"modified_method":"protected HostConfiguration getHostConfig(URI uri) throws URISyntaxException\n    {\n        Protocol protocol = Protocol.getProtocol(uri.getScheme().toLowerCase());\n\n        String host = uri.getHost();\n        int port = uri.getPort();\n        HostConfiguration config = new HostConfiguration();\n        config.setHost(host, port, protocol);\n        if (!StringUtils.isEmpty(connector.getProxyHostname())) {\n            // add proxy support\n            config.setProxy(connector.getProxyHostname(), connector.getProxyPort());\n        }\n        return config;\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void writeRequest(final HttpRequest request) throws IOException {\n        if (request == null) {\n            return;\n        }\n        ResponseWriter writer = new ResponseWriter(this.out, encoding);\n        writer.println(request.getRequestLine().toString());\n        Iterator item = request.getHeaderIterator();\n        while (item.hasNext()) {\n            Header header = (Header) item.next();\n            writer.print(header.toExternalForm());\n        }\n        writer.println();\n        writer.flush();\n\n        OutputStream outsream = this.out;\n        InputStream content = request.getBody();\n        if (content != null) {\n\n            Header transferenc = request.getFirstHeader(\"Transfer-Encoding\");\n            if (transferenc != null) {\n                request.removeHeaders(\"Content-Length\");\n                if (transferenc.getValue().indexOf(\"chunked\") != -1) {\n                    outsream = new ChunkedOutputStream(outsream);\n                }\n            }\n            byte[] tmp = new byte[4096];\n            int i = 0;\n            while ((i = content.read(tmp)) >= 0) {\n                outsream.write(tmp, 0, i);\n            }\n            if (outsream instanceof ChunkedOutputStream) {\n                ((ChunkedOutputStream)outsream).finish();\n            }\n        }\n        outsream.flush();\n    }","id":41261,"modified_method":"public void writeRequest(final HttpRequest request) throws IOException\n    {\n        if (request == null) {\n            return;\n        }\n        ResponseWriter writer = new ResponseWriter(this.out, encoding);\n        writer.println(request.getRequestLine().toString());\n        Iterator item = request.getHeaderIterator();\n        while (item.hasNext()) {\n            Header header = (Header)item.next();\n            writer.print(header.toExternalForm());\n        }\n        writer.println();\n        writer.flush();\n\n        OutputStream outstream = this.out;\n        InputStream content = request.getBody();\n        if (content != null) {\n\n            Header transferenc = request.getFirstHeader(HttpConstants.HEADER_TRANSFER_ENCODING);\n            if (transferenc != null) {\n                request.removeHeaders(HttpConstants.HEADER_CONTENT_LENGTH);\n                if (transferenc.getValue().indexOf(HttpConstants.TRANSFER_ENCODING_CHUNKED) != -1) {\n                    outstream = new ChunkedOutputStream(outstream);\n                }\n            }\n\n            IOUtils.copy(content, outstream);\n\n            if (outstream instanceof ChunkedOutputStream) {\n                ((ChunkedOutputStream)outstream).finish();\n            }\n        }\n\n        outstream.flush();\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"public HttpRequest readRequest() throws IOException {\n       String line = null;\n        try {\n            do {\n                line = HttpParser.readLine(in, encoding);\n            } while (line != null && line.length() == 0);\n\n            if (line == null) {\n                setKeepAlive(false);\n                return null;\n            }\n            HttpRequest request = new HttpRequest(\n                    RequestLine.parseLine(line),\n                    HttpParser.parseHeaders(this.in, encoding),\n                    this.in);\n            return request;\n        } catch (IOException e) {\n            System.out.println(line);\n            close();\n            throw e;\n        }\n    }","id":41262,"modified_method":"public HttpRequest readRequest() throws IOException\n    {\n        String line = null;\n        try {\n            do {\n                line = HttpParser.readLine(in, encoding);\n            }\n            while (line != null && line.length() == 0);\n\n            if (line == null) {\n                setKeepAlive(false);\n                return null;\n            }\n            HttpRequest request = new HttpRequest(RequestLine.parseLine(line),\n                    HttpParser.parseHeaders(this.in, encoding), this.in);\n            return request;\n        }\n        catch (IOException e) {\n            close();\n            throw e;\n        }\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void writeResponse(final HttpResponse response) throws IOException {\n        if (response == null) {\n            return;\n        }\n        setKeepAlive(response.isKeepAlive());\n        ResponseWriter writer = new ResponseWriter(this.out, encoding);\n        OutputStream outsream = this.out;\n\n        writer.println(response.getStatusLine());\n        Iterator item = response.getHeaderIterator();\n        while (item.hasNext()) {\n            Header header = (Header) item.next();\n            writer.print(header.toExternalForm());\n\n        }\n        writer.println();\n        writer.flush();\n\n        InputStream content = response.getBody();\n        if (content != null) {\n            Header transferenc = response.getFirstHeader(HttpConstants.HEADER_TRANSFER_ENCODING);\n            if (transferenc != null) {\n                response.removeHeaders(HttpConstants.HEADER_CONTENT_LENGTH);\n                if (transferenc.getValue().indexOf(\"chunked\") != -1) {\n                    outsream = new ChunkedOutputStream(outsream);\n\n                    byte[] tmp = new byte[4096];\n                    int i = 0;\n                    while ((i = content.read(tmp)) >= 0) {\n                        outsream.write(tmp, 0, i);\n                    }\n                    if (outsream instanceof ChunkedOutputStream) {\n                        ((ChunkedOutputStream) outsream).finish();\n                    }\n                }\n            } else {\n                /**\n                 * read the content when needed to embed content-length\n                 */\n                byte[] tmp = new byte[4096];\n                int i = 0;\n                while ((i = content.read(tmp)) >= 0) {\n                    //assert socket.isClosed()==false;\n                    outsream.write(tmp, 0, i);\n                }\n            }\n        }\n        outsream.flush();\n    }","id":41263,"modified_method":"public void writeResponse(final HttpResponse response) throws IOException\n    {\n        if (response == null) {\n            return;\n        }\n        setKeepAlive(response.isKeepAlive());\n        ResponseWriter writer = new ResponseWriter(this.out, encoding);\n        OutputStream outstream = this.out;\n\n        writer.println(response.getStatusLine());\n        Iterator item = response.getHeaderIterator();\n        while (item.hasNext()) {\n            Header header = (Header)item.next();\n            writer.print(header.toExternalForm());\n\n        }\n        writer.println();\n        writer.flush();\n\n        InputStream content = response.getBody();\n        if (content != null) {\n            Header transferenc = response.getFirstHeader(HttpConstants.HEADER_TRANSFER_ENCODING);\n            if (transferenc != null) {\n                response.removeHeaders(HttpConstants.HEADER_CONTENT_LENGTH);\n                if (transferenc.getValue().indexOf(HttpConstants.TRANSFER_ENCODING_CHUNKED) != -1) {\n                    outstream = new ChunkedOutputStream(outstream);\n                }\n            }\n\n            IOUtils.copy(content, outstream);\n\n            if (outstream instanceof ChunkedOutputStream) {\n                ((ChunkedOutputStream)outstream).finish();\n            }\n        }\n\n        outstream.flush();\n    }","commit_id":"85e87eb03b9a6465ae882c88fd2172b625942e7c","url":"https://github.com/mulesoft/mule"},{"original_method":"@SuppressWarnings({\"ThrowableInstanceNeverThrown\"})\n    @Override\n    public void run() {\n        try {\n            boolean first = true;\n            while(true) {\n                if(first) {\n                    first = false;\n                } else {\n                    if(noReconnect)\n                        return; // exit\n                }\n\n                listener.status(\"Locating server among \" + candidateUrls);\n                Throwable firstError=null;\n                String port=null;\n\n                for (URL url : candidateUrls) {\n                    String s = url.toExternalForm();\n                    if(!s.endsWith(\"/\"))    s+='/';\n                    URL salURL = new URL(s+\"tcpSlaveAgentListener/\");\n\n                    // find out the TCP port\n                    HttpURLConnection con = (HttpURLConnection)salURL.openConnection();\n                    if (con instanceof HttpURLConnection && credentials != null) {\n                        String encoding = new sun.misc.BASE64Encoder().encode(credentials.getBytes());\n                        con.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                    }\n                    try {\n                        try {\n                            con.setConnectTimeout(30000);\n                            con.setReadTimeout(60000);\n                            con.connect();\n                        } catch (IOException x) {\n                            if (firstError == null) {\n                                firstError = new IOException(\"Failed to connect to \" + salURL + \": \" + x.getMessage()).initCause(x);\n                            }\n                            continue;\n                        }\n                        port = con.getHeaderField(\"X-Hudson-JNLP-Port\");\n                        if(con.getResponseCode()!=200) {\n                            if(firstError==null)\n                                firstError = new Exception(salURL+\" is invalid: \"+con.getResponseCode()+\" \"+con.getResponseMessage());\n                            continue;\n                        }\n                        if(port ==null) {\n                            if(firstError==null)\n                                firstError = new Exception(url+\" is not Hudson\");\n                            continue;\n                        }\n                    } finally {\n                        con.disconnect();\n                    }\n\n                    // this URL works. From now on, only try this URL\n                    hudsonUrl = url;\n                    firstError = null;\n                    candidateUrls = Collections.singletonList(hudsonUrl);\n                    break;\n                }\n\n                if(firstError!=null) {\n                    listener.error(firstError);\n                    return;\n                }\n\n                Socket s = connect(port);\n\n                listener.status(\"Handshaking\");\n\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                BufferedInputStream in = new BufferedInputStream(s.getInputStream());\n\n                dos.writeUTF(\"Protocol:JNLP2-connect\");\n                Properties props = new Properties();\n                props.put(\"Secret-Key\", secretKey);\n                props.put(\"Node-Name\", slaveName);\n                if (cookie!=null)\n                    props.put(\"Cookie\", cookie);\n                ByteArrayOutputStream o = new ByteArrayOutputStream();\n                props.store(o, null);\n                dos.writeUTF(o.toString(\"UTF-8\"));\n\n                String greeting = readLine(in);\n                if (greeting.startsWith(\"Unknown protocol\")) {\n                    LOGGER.info(\"The server didn't understand the v2 handshake. Falling back to v1 handshake\");\n                    s.close();\n                    s = connect(port);\n                    in = new BufferedInputStream(s.getInputStream());\n                    dos = new DataOutputStream(s.getOutputStream());\n\n                    dos.writeUTF(\"Protocol:JNLP-connect\");\n                    dos.writeUTF(secretKey);\n                    dos.writeUTF(slaveName);\n\n                    greeting = readLine(in); // why, oh why didn't I use DataOutputStream when writing to the network?\n                    if (!greeting.equals(GREETING_SUCCESS)) {\n                        onConnectionRejected(greeting);\n                        continue;\n                    }\n                } else {\n                    if (greeting.equals(GREETING_SUCCESS)) {\n                        Properties responses = readResponseHeaders(in);\n                        cookie = responses.getProperty(\"Cookie\");\n                    } else {\n                        onConnectionRejected(greeting);\n                        continue;\n                    }\n                }\n\n                final Channel channel = new Channel(\"channel\", executor,\n                        in,\n                        new BufferedOutputStream(s.getOutputStream()));\n                \n                listener.status(\"Connected\");\n                channel.join();\n                listener.status(\"Terminated\");\n                listener.onDisconnect();\n\n                if(noReconnect)\n                    return; // exit\n                // try to connect back to the server every 10 secs.\n                waitForServerToBack();\n            }\n        } catch (Throwable e) {\n            listener.error(e);\n        }\n    }","id":41264,"modified_method":"@SuppressWarnings({\"ThrowableInstanceNeverThrown\"})\n    @Override\n    public void run() {\n        try {\n            boolean first = true;\n            while(true) {\n                if(first) {\n                    first = false;\n                } else {\n                    if(noReconnect)\n                        return; // exit\n                }\n\n                listener.status(\"Locating server among \" + candidateUrls);\n                Throwable firstError=null;\n                String port=null;\n\n                for (URL url : candidateUrls) {\n                    String s = url.toExternalForm();\n                    if(!s.endsWith(\"/\"))    s+='/';\n                    URL salURL = new URL(s+\"tcpSlaveAgentListener/\");\n\n                    // find out the TCP port\n                    HttpURLConnection con = (HttpURLConnection)salURL.openConnection();\n                    if (con instanceof HttpURLConnection && credentials != null) {\n                        String encoding = new String(new Base64().encodeBase64(credentials.getBytes()));\n                        con.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                    }\n                    try {\n                        try {\n                            con.setConnectTimeout(30000);\n                            con.setReadTimeout(60000);\n                            con.connect();\n                        } catch (IOException x) {\n                            if (firstError == null) {\n                                firstError = new IOException(\"Failed to connect to \" + salURL + \": \" + x.getMessage()).initCause(x);\n                            }\n                            continue;\n                        }\n                        port = con.getHeaderField(\"X-Hudson-JNLP-Port\");\n                        if(con.getResponseCode()!=200) {\n                            if(firstError==null)\n                                firstError = new Exception(salURL+\" is invalid: \"+con.getResponseCode()+\" \"+con.getResponseMessage());\n                            continue;\n                        }\n                        if(port ==null) {\n                            if(firstError==null)\n                                firstError = new Exception(url+\" is not Hudson\");\n                            continue;\n                        }\n                    } finally {\n                        con.disconnect();\n                    }\n\n                    // this URL works. From now on, only try this URL\n                    hudsonUrl = url;\n                    firstError = null;\n                    candidateUrls = Collections.singletonList(hudsonUrl);\n                    break;\n                }\n\n                if(firstError!=null) {\n                    listener.error(firstError);\n                    return;\n                }\n\n                Socket s = connect(port);\n\n                listener.status(\"Handshaking\");\n\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                BufferedInputStream in = new BufferedInputStream(s.getInputStream());\n\n                dos.writeUTF(\"Protocol:JNLP2-connect\");\n                Properties props = new Properties();\n                props.put(\"Secret-Key\", secretKey);\n                props.put(\"Node-Name\", slaveName);\n                if (cookie!=null)\n                    props.put(\"Cookie\", cookie);\n                ByteArrayOutputStream o = new ByteArrayOutputStream();\n                props.store(o, null);\n                dos.writeUTF(o.toString(\"UTF-8\"));\n\n                String greeting = readLine(in);\n                if (greeting.startsWith(\"Unknown protocol\")) {\n                    LOGGER.info(\"The server didn't understand the v2 handshake. Falling back to v1 handshake\");\n                    s.close();\n                    s = connect(port);\n                    in = new BufferedInputStream(s.getInputStream());\n                    dos = new DataOutputStream(s.getOutputStream());\n\n                    dos.writeUTF(\"Protocol:JNLP-connect\");\n                    dos.writeUTF(secretKey);\n                    dos.writeUTF(slaveName);\n\n                    greeting = readLine(in); // why, oh why didn't I use DataOutputStream when writing to the network?\n                    if (!greeting.equals(GREETING_SUCCESS)) {\n                        onConnectionRejected(greeting);\n                        continue;\n                    }\n                } else {\n                    if (greeting.equals(GREETING_SUCCESS)) {\n                        Properties responses = readResponseHeaders(in);\n                        cookie = responses.getProperty(\"Cookie\");\n                    } else {\n                        onConnectionRejected(greeting);\n                        continue;\n                    }\n                }\n\n                final Channel channel = new Channel(\"channel\", executor,\n                        in,\n                        new BufferedOutputStream(s.getOutputStream()));\n                \n                listener.status(\"Connected\");\n                channel.join();\n                listener.status(\"Terminated\");\n                listener.onDisconnect();\n\n                if(noReconnect)\n                    return; // exit\n                // try to connect back to the server every 10 secs.\n                waitForServerToBack();\n            }\n        } catch (Throwable e) {\n            listener.error(e);\n        }\n    }","commit_id":"3803a3e3825b07848e0abda20dca4339c8042b60","url":"https://github.com/kohsuke/hudson"},{"original_method":"public FullDuplexHttpStream(URL target) throws IOException {\n        this.target = target;\n\n        String authorization = null;\n        if (target.getUserInfo() != null) {\n        \tauthorization = new BASE64Encoder().encode(target.getUserInfo().getBytes());\n        }\n\n        CrumbData crumbData = new CrumbData();\n\n        UUID uuid = UUID.randomUUID(); // so that the server can correlate those two connections\n\n        // server->client\n        HttpURLConnection con = (HttpURLConnection) target.openConnection();\n        con.setDoOutput(true); // request POST to avoid caching\n        con.setRequestMethod(\"POST\");\n        con.addRequestProperty(\"Session\", uuid.toString());\n        con.addRequestProperty(\"Side\",\"download\");\n        if (authorization != null) {\n            con.addRequestProperty(\"Authorization\", \"Basic \" + authorization);\n        }\n        if(crumbData.isValid) {\n            con.addRequestProperty(crumbData.crumbName, crumbData.crumb);\n        }\n        con.getOutputStream().close();\n        input = con.getInputStream();\n        // make sure we hit the right URL\n        if(con.getHeaderField(\"Hudson-Duplex\")==null)\n            throw new IOException(target+\" doesn't look like Hudson\");\n\n        // client->server uses chunked encoded POST for unlimited capacity. \n        con = (HttpURLConnection) target.openConnection();\n        con.setDoOutput(true); // request POST\n        con.setRequestMethod(\"POST\");\n        con.setChunkedStreamingMode(0);\n        con.setRequestProperty(\"Content-type\",\"application/octet-stream\");\n        con.addRequestProperty(\"Session\", uuid.toString());\n        con.addRequestProperty(\"Side\",\"upload\");\n        if (authorization != null) {\n        \tcon.addRequestProperty (\"Authorization\", \"Basic \" + authorization);\n        }\n\n        if(crumbData.isValid) {\n            con.addRequestProperty(crumbData.crumbName, crumbData.crumb);\n        }\n        output = con.getOutputStream();\n    }","id":41265,"modified_method":"public FullDuplexHttpStream(URL target) throws IOException {\n        this.target = target;\n\n        String authorization = null;\n        if (target.getUserInfo() != null) {\n        \tauthorization = new String(new Base64().encodeBase64(target.getUserInfo().getBytes()));\n        }\n\n        CrumbData crumbData = new CrumbData();\n\n        UUID uuid = UUID.randomUUID(); // so that the server can correlate those two connections\n\n        // server->client\n        HttpURLConnection con = (HttpURLConnection) target.openConnection();\n        con.setDoOutput(true); // request POST to avoid caching\n        con.setRequestMethod(\"POST\");\n        con.addRequestProperty(\"Session\", uuid.toString());\n        con.addRequestProperty(\"Side\",\"download\");\n        if (authorization != null) {\n            con.addRequestProperty(\"Authorization\", \"Basic \" + authorization);\n        }\n        if(crumbData.isValid) {\n            con.addRequestProperty(crumbData.crumbName, crumbData.crumb);\n        }\n        con.getOutputStream().close();\n        input = con.getInputStream();\n        // make sure we hit the right URL\n        if(con.getHeaderField(\"Hudson-Duplex\")==null)\n            throw new IOException(target+\" doesn't look like Hudson\");\n\n        // client->server uses chunked encoded POST for unlimited capacity. \n        con = (HttpURLConnection) target.openConnection();\n        con.setDoOutput(true); // request POST\n        con.setRequestMethod(\"POST\");\n        con.setChunkedStreamingMode(0);\n        con.setRequestProperty(\"Content-type\",\"application/octet-stream\");\n        con.addRequestProperty(\"Session\", uuid.toString());\n        con.addRequestProperty(\"Side\",\"upload\");\n        if (authorization != null) {\n        \tcon.addRequestProperty (\"Authorization\", \"Basic \" + authorization);\n        }\n\n        if(crumbData.isValid) {\n            con.addRequestProperty(crumbData.crumbName, crumbData.crumb);\n        }\n        output = con.getOutputStream();\n    }","commit_id":"3803a3e3825b07848e0abda20dca4339c8042b60","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Parses the connection arguments from JNLP file given in the URL.\n     */\n    public List<String> parseJnlpArguments() throws ParserConfigurationException, SAXException, IOException, InterruptedException {\n        while (true) {\n            try {\n                URLConnection con = slaveJnlpURL.openConnection();\n                if (con instanceof HttpURLConnection && slaveJnlpCredentials != null) {\n                    HttpURLConnection http = (HttpURLConnection) con;\n                    String userPassword = slaveJnlpCredentials;\n                    String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n                    http.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n                con.connect();\n\n                if (con instanceof HttpURLConnection) {\n                    HttpURLConnection http = (HttpURLConnection) con;\n                    if(http.getResponseCode()>=400)\n                        // got the error code. report that (such as 401)\n                        throw new IOException(\"Failed to load \"+slaveJnlpURL+\": \"+http.getResponseCode()+\" \"+http.getResponseMessage());\n                }\n\n                Document dom;\n\n                // check if this URL points to a .jnlp file\n                String contentType = con.getHeaderField(\"Content-Type\");\n                if(contentType==null || !contentType.startsWith(\"application/x-java-jnlp-file\")) {\n                    // load DOM anyway, but if it fails to parse, that's probably because this is not an XML file to begin with.\n                    try {\n                        dom = loadDom(slaveJnlpURL, con);\n                    } catch (SAXException e) {\n                        throw new IOException(slaveJnlpURL+\" doesn't look like a JNLP file; content type was \"+contentType);\n                    } catch (IOException e) {\n                        throw new IOException(slaveJnlpURL+\" doesn't look like a JNLP file; content type was \"+contentType);\n                    }\n                } else {\n                    dom = loadDom(slaveJnlpURL, con);\n                }\n\n                // exec into the JNLP launcher, to fetch the connection parameter through JNLP.\n                NodeList argElements = dom.getElementsByTagName(\"argument\");\n                List<String> jnlpArgs = new ArrayList<String>();\n                for( int i=0; i<argElements.getLength(); i++ )\n                        jnlpArgs.add(argElements.item(i).getTextContent());\n                if (slaveJnlpCredentials != null) {\n                    jnlpArgs.add(\"-credentials\");\n                    jnlpArgs.add(slaveJnlpCredentials);\n                }\n                // force a headless mode\n                jnlpArgs.add(\"-headless\");\n                return jnlpArgs;\n            } catch (SSLHandshakeException e) {\n                if(e.getMessage().contains(\"PKIX path building failed\")) {\n                    // invalid SSL certificate. One reason this happens is when the certificate is self-signed\n                    IOException x = new IOException(\"Failed to validate a server certificate. If you are using a self-signed certificate, you can use the -noCertificateCheck option to bypass this check.\");\n                    x.initCause(e);\n                    throw x;\n                } else\n                    throw e;\n            } catch (IOException e) {\n                System.err.println(\"Failing to obtain \"+slaveJnlpURL);\n                e.printStackTrace(System.err);\n                System.err.println(\"Waiting 10 seconds before retry\");\n                Thread.sleep(10*1000);\n                // retry\n            }\n        }\n    }","id":41266,"modified_method":"/**\n     * Parses the connection arguments from JNLP file given in the URL.\n     */\n    public List<String> parseJnlpArguments() throws ParserConfigurationException, SAXException, IOException, InterruptedException {\n        while (true) {\n            try {\n                URLConnection con = slaveJnlpURL.openConnection();\n                if (con instanceof HttpURLConnection && slaveJnlpCredentials != null) {\n                    HttpURLConnection http = (HttpURLConnection) con;\n                    String userPassword = slaveJnlpCredentials;\n                    String encoding = new String(new Base64().encodeBase64(userPassword.getBytes()));\n                    http.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n                con.connect();\n\n                if (con instanceof HttpURLConnection) {\n                    HttpURLConnection http = (HttpURLConnection) con;\n                    if(http.getResponseCode()>=400)\n                        // got the error code. report that (such as 401)\n                        throw new IOException(\"Failed to load \"+slaveJnlpURL+\": \"+http.getResponseCode()+\" \"+http.getResponseMessage());\n                }\n\n                Document dom;\n\n                // check if this URL points to a .jnlp file\n                String contentType = con.getHeaderField(\"Content-Type\");\n                if(contentType==null || !contentType.startsWith(\"application/x-java-jnlp-file\")) {\n                    // load DOM anyway, but if it fails to parse, that's probably because this is not an XML file to begin with.\n                    try {\n                        dom = loadDom(slaveJnlpURL, con);\n                    } catch (SAXException e) {\n                        throw new IOException(slaveJnlpURL+\" doesn't look like a JNLP file; content type was \"+contentType);\n                    } catch (IOException e) {\n                        throw new IOException(slaveJnlpURL+\" doesn't look like a JNLP file; content type was \"+contentType);\n                    }\n                } else {\n                    dom = loadDom(slaveJnlpURL, con);\n                }\n\n                // exec into the JNLP launcher, to fetch the connection parameter through JNLP.\n                NodeList argElements = dom.getElementsByTagName(\"argument\");\n                List<String> jnlpArgs = new ArrayList<String>();\n                for( int i=0; i<argElements.getLength(); i++ )\n                        jnlpArgs.add(argElements.item(i).getTextContent());\n                if (slaveJnlpCredentials != null) {\n                    jnlpArgs.add(\"-credentials\");\n                    jnlpArgs.add(slaveJnlpCredentials);\n                }\n                // force a headless mode\n                jnlpArgs.add(\"-headless\");\n                return jnlpArgs;\n            } catch (SSLHandshakeException e) {\n                if(e.getMessage().contains(\"PKIX path building failed\")) {\n                    // invalid SSL certificate. One reason this happens is when the certificate is self-signed\n                    IOException x = new IOException(\"Failed to validate a server certificate. If you are using a self-signed certificate, you can use the -noCertificateCheck option to bypass this check.\");\n                    x.initCause(e);\n                    throw x;\n                } else\n                    throw e;\n            } catch (IOException e) {\n                System.err.println(\"Failing to obtain \"+slaveJnlpURL);\n                e.printStackTrace(System.err);\n                System.err.println(\"Waiting 10 seconds before retry\");\n                Thread.sleep(10*1000);\n                // retry\n            }\n        }\n    }","commit_id":"3803a3e3825b07848e0abda20dca4339c8042b60","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected void addEncodedFileContent(ConfigRevision rev, SerializerHelper helper) {\n        String content = rev.getConfigContent().getContentsString();\n        helper.add(CONTENTS, Base64.encode(content.getBytes()));\n        helper.add(CONTENTS_ENC64, Boolean.TRUE);\n        if (!rev.getConfigContent().isBinary()) {\n            helper.add(MACRO_START, rev.getConfigContent().getDelimStart());\n            helper.add(MACRO_END, rev.getConfigContent().getDelimEnd());\n        }\n    }","id":41267,"modified_method":"protected void addEncodedFileContent(ConfigRevision rev, SerializerHelper helper) {\n        String content = rev.getConfigContent().getContentsString();\n        try {\n            helper.add(CONTENTS, new String(Base64.encodeBase64(content.getBytes(\"UTF-8\")),\n                    \"UTF-8\"));\n        }\n         catch (UnsupportedEncodingException e) {\n             String msg = \"Following errors were encountered \" +\n                     \"when creating the config file.\\n\" + e.getMessage();\n                 throw new FaultException(1023, \"ConfgFileError\", msg);\n        }\n        helper.add(CONTENTS_ENC64, Boolean.TRUE);\n        if (!rev.getConfigContent().isBinary()) {\n            helper.add(MACRO_START, rev.getConfigContent().getDelimStart());\n            helper.add(MACRO_END, rev.getConfigContent().getDelimEnd());\n        }\n    }","commit_id":"9bc0fb332afbd027ebecf0749b1a264444ef60c4","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Sets the headers so that the connection will authenticate using \n     * HTTP Basic Authentication using the username and password passed\n     * set at publish time.\n     * \n     * @param connection\n     *            Must be an instance of HttpURLConnection\n     * @param rd\n     *            The calling channel's ChannelRuntimeData.\n     */\n    public void sendLocalData(Object connection, ChannelRuntimeData rd) {\n        HttpURLConnection modified_connection = (HttpURLConnection) connection;\n\n        // encode and set the authentication credentials\n        modified_connection.setRequestProperty(AUTHORIZATIONHDR,\n                AUTHORIZATIONTYPE\n                        + (new BASE64Encoder()).encode(usernameandpassword\n                                .getBytes()));\n\n        // all done. This will be sent with the request now.\n    }","id":41268,"modified_method":"/**\n     * Sets the headers so that the connection will authenticate using \n     * HTTP Basic Authentication using the username and password passed\n     * set at publish time.\n     * \n     * @param connection\n     *            Must be an instance of HttpURLConnection\n     * @param rd\n     *            The calling channel's ChannelRuntimeData.\n     */\n    public void sendLocalData(Object connection, ChannelRuntimeData rd) {\n        HttpURLConnection modified_connection = (HttpURLConnection) connection;\n\n        // encode and set the authentication credentials\n        modified_connection.setRequestProperty(AUTHORIZATIONHDR, AUTHORIZATIONTYPE\n                + new String(Base64.encodeBase64(usernameandpassword.getBytes())));\n\n        // all done. This will be sent with the request now.\n    }","commit_id":"9c16bb8b1f1ce4eee0e67b12570eb0ed5a4baa1f","url":"https://github.com/Jasig/uPortal"},{"original_method":"public String merge(String siteId, Element root, String archivePath,\n      String fromSiteId, Map attachmentNames, Map userIdTrans,\n      Set userListAllowImport)\n  {\n    // buffer for the results log\n    StringBuffer results = new StringBuffer();\n    // populate SyllabusItem\n    int syDataCount = 0;\n    SyllabusItem syItem = null;\n    if (siteId != null && siteId.trim().length() > 0)\n    {\n      try\n      {\n        NodeList allChildrenNodes = root.getChildNodes();\n        int length = allChildrenNodes.getLength();\n        for (int i = 0; i < length; i++)\n        {\n          Node siteNode = allChildrenNodes.item(i);\n          if (siteNode.getNodeType() == Node.ELEMENT_NODE)\n          {\n            Element siteElement = (Element) siteNode;\n            if (siteElement.getTagName().equals(SITE_ARCHIVE))\n            {\n//sakai2              NodeList pageNodes = siteElement.getChildNodes();\n//              int lengthPageNodes = pageNodes.getLength();\n//              for (int p = 0; p < lengthPageNodes; p++)\n//              {\n//                Node pageNode = pageNodes.item(p);\n//                if (pageNode.getNodeType() == Node.ELEMENT_NODE)\n//                {\n//                  Element pageElement = (Element) pageNode;\n//                  if (pageElement.getTagName().equals(PAGE_ARCHIVE))\n//                  {\n//                    NodeList syllabusNodes = pageElement.getChildNodes();\n              \t\t\tNodeList syllabusNodes = siteElement.getChildNodes();\n                    int lengthSyllabusNodes = syllabusNodes.getLength();\n                    for (int sn = 0; sn < lengthSyllabusNodes; sn++)\n                    {\n                      Node syNode = syllabusNodes.item(sn);\n                      if (syNode.getNodeType() == Node.ELEMENT_NODE)\n                      {\n                        Element syElement = (Element) syNode;\n                        if (syElement.getTagName().equals(SYLLABUS))\n                        {\n                          //create a page and all syllabus tool to the page\n//sakai2                          String page = addSyllabusToolToPage(siteId,pageElement\n//                              .getAttribute(PAGE_NAME));\n//                          SyllabusItem syllabusItem = syllabusManager\n//                          .createSyllabusItem(UserDirectoryService\n//                              .getCurrentUser().getId(), page, syElement\n//                              .getAttribute(SYLLABUS_REDIRECT_URL));\n                          String page = addSyllabusToolToPage(siteId,siteElement\n                            .getAttribute(SITE_NAME));\n//sakai2                          SyllabusItem syllabusItem = syllabusManager\n//                          .createSyllabusItem(UserDirectoryService\n//                              .getCurrentUser().getId(), page, syElement\n//                              .getAttribute(SYLLABUS_REDIRECT_URL));\n//sakai2 add--\n                          SyllabusItem syllabusItem = syllabusManager.getSyllabusItemByContextId(page);\n                          if(syllabusItem == null)\n                          {\n                            syllabusItem = syllabusManager\n                              .createSyllabusItem(UserDirectoryService\n                                  .getCurrentUser().getId(), page, syElement\n                                  .getAttribute(SYLLABUS_REDIRECT_URL));\n                          } \n                          //added htripath: get imported redirecturl, even if syllabus item is existing.\n                          else{\n                            if (syElement.getAttribute(SYLLABUS_REDIRECT_URL) !=null){\n                              syllabusItem.setRedirectURL(syElement.getAttribute(SYLLABUS_REDIRECT_URL));\n                              syllabusManager.saveSyllabusItem(syllabusItem) ;\n                            }                            \n                          }\n                          //\n                          NodeList allSyllabiNodes = syElement.getChildNodes();\n                          int lengthSyllabi = allSyllabiNodes.getLength();\n                          for (int j = 0; j < lengthSyllabi; j++)\n                          {\n                            Node child2 = allSyllabiNodes.item(j);\n                            if (child2.getNodeType() == Node.ELEMENT_NODE)\n                            {\n\n                              Element syDataElement = (Element) child2;\n                              if (syDataElement.getTagName().equals(\n                                  SYLLABUS_DATA))\n                              {\n                              \tList attachStringList = new ArrayList();\n                              \t\n                                syDataCount = syDataCount + 1;\n                                SyllabusData syData = new SyllabusDataImpl();\n                                syData.setView(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_VIEW));\n                                syData.setTitle(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_TITLE));\n                                syData.setStatus(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_STATUS));\n                                syData\n                                    .setEmailNotification(syDataElement\n                                        .getAttribute(SYLLABUS_DATA_EMAIL_NOTIFICATION));\n\n                                NodeList allAssetNodes = syDataElement\n                                    .getChildNodes();\n                                int lengthSyData = allAssetNodes.getLength();\n                                for (int k = 0; k < lengthSyData; k++)\n                                {\n                                  Node child3 = allAssetNodes.item(k);\n                                  if (child3.getNodeType() == Node.ELEMENT_NODE)\n                                  {\n                                    Element assetEle = (Element) child3;\n                                    if (assetEle.getTagName().equals(\n                                        SYLLABUS_DATA_ASSET))\n                                    {\n                                      String charset = trimToNull(assetEle.getAttribute(\"charset\"));\n                                      if (charset == null) charset = \"UTF-8\";\n                                      \n                                      String body = trimToNull(assetEle.getAttribute(\"syllabus_body-html\"));\n                                      if (body != null)\n                                      {\n                                        try\n                                        {\n                                          byte[] decoded = Base64.decode(body);\n                                          body = new String(decoded, charset);\n                                        }\n                                        catch (Exception e)\n                                        {\n                                          logger.warn(\"Decode Syllabus: \" + e);\n                                        }\n                                      }\n                                      \n                                      if (body == null) body = \"\";\n                                      \n                                      String ret;\n                                      ret = trimToNull(body);\n                                      \n                                      syData.setAsset(ret);\n/*decode\n                                      NodeList assetStringNodes = assetEle\n                                          .getChildNodes();\n                                      int lengthAssetNodes = assetStringNodes\n                                          .getLength();\n                                      for (int l = 0; l < lengthAssetNodes; l++)\n                                      {\n                                        Node child4 = assetStringNodes.item(l);\n                                        if (child4.getNodeType() == Node.TEXT_NODE)\n                                        {\n                                          Text textNode = (Text) child4;\n                                          syData.setAsset(textNode.getData());\n                                        }\n                                      }*/\n                                    }\n                                    if (assetEle.getTagName().equals(\n                                        SYLLABUS_ATTACHMENT))\n                                    {\n                                    \tElement attachElement = (Element) child3;\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString oldUrl = attachElement.getAttribute(\"relative-url\");\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (oldUrl.startsWith(\"/content/attachment/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString newUrl = (String) attachmentNames.get(oldUrl);\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (newUrl != null)\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t////if (newUrl.startsWith(\"/attachment/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t////newUrl = \"/content\".concat(newUrl);\n\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachElement.setAttribute(\"relative-url\", Validator\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachStringList.add(Validator.escapeQuestionMark(newUrl));\n\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (oldUrl.startsWith(\"/content/group/\" + fromSiteId + \"/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString newUrl = \"/content/group/\" + siteId\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ oldUrl.substring(15 + fromSiteId.length());\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachElement.setAttribute(\"relative-url\", Validator\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachStringList.add(Validator.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n                                    }\n                                  }\n                                }\n\n                                int initPosition = syllabusManager\n                                    .findLargestSyllabusPosition(syllabusItem)\n                                    .intValue() + 1;\n                                syData = syllabusManager\n                                    .createSyllabusDataObject(\n                                        syData.getTitle(), (new Integer(\n                                            initPosition)), syData.getAsset(),\n                                        syData.getView(), syData.getStatus(),\n                                        syData.getEmailNotification());\n                            \t\tSet attachSet = new TreeSet();\n                            \t\tfor(int m=0; m<attachStringList.size(); m++)\n                            \t\t{\n                            \t\t\tContentResource cr = ContentHostingService.getResource((String)attachStringList.get(m));\n                            \t\t\tResourceProperties rp = cr.getProperties();\n//                            \t\t\tSyllabusAttachment tempAttach = syllabusManager.createSyllabusAttachmentObject(\n//                            \t\t\t\t\t(String)attachStringList.get(m),rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\tSyllabusAttachment tempAttach = syllabusManager.createSyllabusAttachmentObject(\n                          \t\t\t\t\tcr.getId(),rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\ttempAttach.setName(rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\ttempAttach.setSize(rp.getProperty(ResourceProperties.PROP_CONTENT_LENGTH));\n                            \t\t\ttempAttach.setType(rp.getProperty(ResourceProperties.PROP_CONTENT_TYPE));\n                            \t\t\ttempAttach.setUrl(cr.getUrl());\n                            \t\t\ttempAttach.setAttachmentId(cr.getId());\n                            \t\t\t\n                            \t\t\tattachSet.add(tempAttach);\n                            \t\t}\n                            \t\tsyData.setAttachments(attachSet);\n                                \n                                syllabusManager.addSyllabusToSyllabusItem(\n                                    syllabusItem, syData);\n\n                              }\n                            }\n                          }\n\n                        }\n                      }\n                    }\n//sakai2                  }\n//sakai2                }\n//sakai2              }\n            }\n          }\n\n        }\n        results.append(\"merging syllabus \" + siteId + \" (\" + syDataCount\n            + \") syllabus items.\\n\");\n\n      }\n      catch (DOMException e)\n      {\n        logger.error(e.getMessage(), e);\n        results.append(\"merging \" + getLabel()\n            + \" failed during xml parsing.\\n\");\n\n      }\n      catch (Exception e)\n      {\n        logger.error(e.getMessage(), e);\n        results.append(\"merging \" + getLabel() + \" failed.\\n\");\n      }\n    }\n\n    return results.toString();\n  }","id":41269,"modified_method":"public String merge(String siteId, Element root, String archivePath,\n      String fromSiteId, Map attachmentNames, Map userIdTrans,\n      Set userListAllowImport)\n  {\n    // buffer for the results log\n    StringBuffer results = new StringBuffer();\n    // populate SyllabusItem\n    int syDataCount = 0;\n    SyllabusItem syItem = null;\n    if (siteId != null && siteId.trim().length() > 0)\n    {\n      try\n      {\n        NodeList allChildrenNodes = root.getChildNodes();\n        int length = allChildrenNodes.getLength();\n        for (int i = 0; i < length; i++)\n        {\n          Node siteNode = allChildrenNodes.item(i);\n          if (siteNode.getNodeType() == Node.ELEMENT_NODE)\n          {\n            Element siteElement = (Element) siteNode;\n            if (siteElement.getTagName().equals(SITE_ARCHIVE))\n            {\n//sakai2              NodeList pageNodes = siteElement.getChildNodes();\n//              int lengthPageNodes = pageNodes.getLength();\n//              for (int p = 0; p < lengthPageNodes; p++)\n//              {\n//                Node pageNode = pageNodes.item(p);\n//                if (pageNode.getNodeType() == Node.ELEMENT_NODE)\n//                {\n//                  Element pageElement = (Element) pageNode;\n//                  if (pageElement.getTagName().equals(PAGE_ARCHIVE))\n//                  {\n//                    NodeList syllabusNodes = pageElement.getChildNodes();\n              \t\t\tNodeList syllabusNodes = siteElement.getChildNodes();\n                    int lengthSyllabusNodes = syllabusNodes.getLength();\n                    for (int sn = 0; sn < lengthSyllabusNodes; sn++)\n                    {\n                      Node syNode = syllabusNodes.item(sn);\n                      if (syNode.getNodeType() == Node.ELEMENT_NODE)\n                      {\n                        Element syElement = (Element) syNode;\n                        if (syElement.getTagName().equals(SYLLABUS))\n                        {\n                          //create a page and all syllabus tool to the page\n//sakai2                          String page = addSyllabusToolToPage(siteId,pageElement\n//                              .getAttribute(PAGE_NAME));\n//                          SyllabusItem syllabusItem = syllabusManager\n//                          .createSyllabusItem(UserDirectoryService\n//                              .getCurrentUser().getId(), page, syElement\n//                              .getAttribute(SYLLABUS_REDIRECT_URL));\n                          String page = addSyllabusToolToPage(siteId,siteElement\n                            .getAttribute(SITE_NAME));\n//sakai2                          SyllabusItem syllabusItem = syllabusManager\n//                          .createSyllabusItem(UserDirectoryService\n//                              .getCurrentUser().getId(), page, syElement\n//                              .getAttribute(SYLLABUS_REDIRECT_URL));\n//sakai2 add--\n                          SyllabusItem syllabusItem = syllabusManager.getSyllabusItemByContextId(page);\n                          if(syllabusItem == null)\n                          {\n                            syllabusItem = syllabusManager\n                              .createSyllabusItem(UserDirectoryService\n                                  .getCurrentUser().getId(), page, syElement\n                                  .getAttribute(SYLLABUS_REDIRECT_URL));\n                          } \n                          //added htripath: get imported redirecturl, even if syllabus item is existing.\n                          else{\n                            if (syElement.getAttribute(SYLLABUS_REDIRECT_URL) !=null){\n                              syllabusItem.setRedirectURL(syElement.getAttribute(SYLLABUS_REDIRECT_URL));\n                              syllabusManager.saveSyllabusItem(syllabusItem) ;\n                            }                            \n                          }\n                          //\n                          NodeList allSyllabiNodes = syElement.getChildNodes();\n                          int lengthSyllabi = allSyllabiNodes.getLength();\n                          for (int j = 0; j < lengthSyllabi; j++)\n                          {\n                            Node child2 = allSyllabiNodes.item(j);\n                            if (child2.getNodeType() == Node.ELEMENT_NODE)\n                            {\n\n                              Element syDataElement = (Element) child2;\n                              if (syDataElement.getTagName().equals(\n                                  SYLLABUS_DATA))\n                              {\n                              \tList attachStringList = new ArrayList();\n                              \t\n                                syDataCount = syDataCount + 1;\n                                SyllabusData syData = new SyllabusDataImpl();\n                                syData.setView(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_VIEW));\n                                syData.setTitle(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_TITLE));\n                                syData.setStatus(syDataElement\n                                    .getAttribute(SYLLABUS_DATA_STATUS));\n                                syData\n                                    .setEmailNotification(syDataElement\n                                        .getAttribute(SYLLABUS_DATA_EMAIL_NOTIFICATION));\n\n                                NodeList allAssetNodes = syDataElement\n                                    .getChildNodes();\n                                int lengthSyData = allAssetNodes.getLength();\n                                for (int k = 0; k < lengthSyData; k++)\n                                {\n                                  Node child3 = allAssetNodes.item(k);\n                                  if (child3.getNodeType() == Node.ELEMENT_NODE)\n                                  {\n                                    Element assetEle = (Element) child3;\n                                    if (assetEle.getTagName().equals(\n                                        SYLLABUS_DATA_ASSET))\n                                    {\n                                      String charset = trimToNull(assetEle.getAttribute(\"charset\"));\n                                      if (charset == null) charset = \"UTF-8\";\n                                      \n                                      String body = trimToNull(assetEle.getAttribute(\"syllabus_body-html\"));\n                                      if (body != null)\n                                      {\n                                        try\n                                        {\n                                          byte[] decoded = Base64.decodeBase64(body.getBytes(\"UTF-8\"));\n                                          body = new String(decoded, charset);\n                                        }\n                                        catch (Exception e)\n                                        {\n                                          logger.warn(\"Decode Syllabus: \" + e);\n                                        }\n                                      }\n                                      \n                                      if (body == null) body = \"\";\n                                      \n                                      String ret;\n                                      ret = trimToNull(body);\n                                      \n                                      syData.setAsset(ret);\n/*decode\n                                      NodeList assetStringNodes = assetEle\n                                          .getChildNodes();\n                                      int lengthAssetNodes = assetStringNodes\n                                          .getLength();\n                                      for (int l = 0; l < lengthAssetNodes; l++)\n                                      {\n                                        Node child4 = assetStringNodes.item(l);\n                                        if (child4.getNodeType() == Node.TEXT_NODE)\n                                        {\n                                          Text textNode = (Text) child4;\n                                          syData.setAsset(textNode.getData());\n                                        }\n                                      }*/\n                                    }\n                                    if (assetEle.getTagName().equals(\n                                        SYLLABUS_ATTACHMENT))\n                                    {\n                                    \tElement attachElement = (Element) child3;\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString oldUrl = attachElement.getAttribute(\"relative-url\");\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (oldUrl.startsWith(\"/content/attachment/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString newUrl = (String) attachmentNames.get(oldUrl);\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (newUrl != null)\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t////if (newUrl.startsWith(\"/attachment/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t////newUrl = \"/content\".concat(newUrl);\n\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachElement.setAttribute(\"relative-url\", Validator\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachStringList.add(Validator.escapeQuestionMark(newUrl));\n\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (oldUrl.startsWith(\"/content/group/\" + fromSiteId + \"/\"))\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString newUrl = \"/content/group/\" + siteId\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ oldUrl.substring(15 + fromSiteId.length());\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachElement.setAttribute(\"relative-url\", Validator\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattachStringList.add(Validator.escapeQuestionMark(newUrl));\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n                                    }\n                                  }\n                                }\n\n                                int initPosition = syllabusManager\n                                    .findLargestSyllabusPosition(syllabusItem)\n                                    .intValue() + 1;\n                                syData = syllabusManager\n                                    .createSyllabusDataObject(\n                                        syData.getTitle(), (new Integer(\n                                            initPosition)), syData.getAsset(),\n                                        syData.getView(), syData.getStatus(),\n                                        syData.getEmailNotification());\n                            \t\tSet attachSet = new TreeSet();\n                            \t\tfor(int m=0; m<attachStringList.size(); m++)\n                            \t\t{\n                            \t\t\tContentResource cr = ContentHostingService.getResource((String)attachStringList.get(m));\n                            \t\t\tResourceProperties rp = cr.getProperties();\n//                            \t\t\tSyllabusAttachment tempAttach = syllabusManager.createSyllabusAttachmentObject(\n//                            \t\t\t\t\t(String)attachStringList.get(m),rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\tSyllabusAttachment tempAttach = syllabusManager.createSyllabusAttachmentObject(\n                          \t\t\t\t\tcr.getId(),rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\ttempAttach.setName(rp.getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n                            \t\t\ttempAttach.setSize(rp.getProperty(ResourceProperties.PROP_CONTENT_LENGTH));\n                            \t\t\ttempAttach.setType(rp.getProperty(ResourceProperties.PROP_CONTENT_TYPE));\n                            \t\t\ttempAttach.setUrl(cr.getUrl());\n                            \t\t\ttempAttach.setAttachmentId(cr.getId());\n                            \t\t\t\n                            \t\t\tattachSet.add(tempAttach);\n                            \t\t}\n                            \t\tsyData.setAttachments(attachSet);\n                                \n                                syllabusManager.addSyllabusToSyllabusItem(\n                                    syllabusItem, syData);\n\n                              }\n                            }\n                          }\n\n                        }\n                      }\n                    }\n//sakai2                  }\n//sakai2                }\n//sakai2              }\n            }\n          }\n\n        }\n        results.append(\"merging syllabus \" + siteId + \" (\" + syDataCount\n            + \") syllabus items.\\n\");\n\n      }\n      catch (DOMException e)\n      {\n        logger.error(e.getMessage(), e);\n        results.append(\"merging \" + getLabel()\n            + \" failed during xml parsing.\\n\");\n\n      }\n      catch (Exception e)\n      {\n        logger.error(e.getMessage(), e);\n        results.append(\"merging \" + getLabel() + \" failed.\\n\");\n      }\n    }\n\n    return results.toString();\n  }","commit_id":"588b88d7a363120c5fb0e89ca9371994c506877e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String archive(String siteId, Document doc, Stack stack, String arg3,\n      List attachments)\n  {\n\n    StringBuffer results = new StringBuffer();\n\n    try\n    {\n      int syDataCount = 0;\n      results.append(\"archiving \" + getLabel() + \" context \"\n          + Entity.SEPARATOR + siteId + Entity.SEPARATOR\n          + SiteService.MAIN_CONTAINER + \".\\n\");\n      // start with an element with our very own (service) name\n      Element element = doc.createElement(SyllabusService.class.getName());\n      ((Element) stack.peek()).appendChild(element);\n      stack.push(element);\n      if (siteId != null && siteId.trim().length() > 0)\n      {\n        Element siteElement = doc.createElement(SITE_ARCHIVE);\n        siteElement.setAttribute(SITE_NAME, SiteService.getSite(siteId).getId());\n        siteElement.setAttribute(SITE_ID, SiteService.getSite(siteId)\n            .getTitle());\n//sakai2        Iterator pageIter = getSyllabusPages(siteId);\n//        if (pageIter != null)\n//        {\n//          while (pageIter.hasNext())\n//          {\n//            String page = (String) pageIter.next();\n//            if (page != null)\n//            {\n//              Element pageElement = doc.createElement(PAGE_ARCHIVE);\n//              pageElement.setAttribute(PAGE_ID, page);\n//sakai2              pageElement.setAttribute(PAGE_NAME, SiteService.getSite(siteId)\n//sakai2                  .getPage(page).getTitle());\n//sakai2              SyllabusItem syllabusItem = syllabusManager\n//                  .getSyllabusItemByContextId(page);\n   \t\t\t\t\t\tSyllabusItem syllabusItem = syllabusManager\n   \t\t\t\t\t\t.getSyllabusItemByContextId(siteId);\n              if (syllabusItem != null)\n              {\n                Element syllabus = doc.createElement(SYLLABUS);\n                syllabus.setAttribute(SYLLABUS_ID, syllabusItem\n                    .getSurrogateKey().toString());\n                syllabus.setAttribute(SYLLABUS_USER_ID, syllabusItem\n                    .getUserId());\n                syllabus.setAttribute(SYLLABUS_CONTEXT_ID, syllabusItem\n                    .getContextId());\n                syllabus.setAttribute(SYLLABUS_REDIRECT_URL, syllabusItem\n                    .getRedirectURL());\n\n                Set syllabi = syllabusManager\n                    .getSyllabiForSyllabusItem(syllabusItem);\n\n                if (syllabi != null && !syllabi.isEmpty())\n                {\n                  Iterator syllabiIter = syllabi.iterator();\n                  while (syllabiIter.hasNext())\n                  {\n                    SyllabusData syllabusData = (SyllabusData) syllabiIter\n                        .next();\n                    if (syllabusData != null)\n                    {\n                      syDataCount++;\n                      Element syllabus_data = doc.createElement(SYLLABUS_DATA);\n                      syllabus_data.setAttribute(SYLLABUS_DATA_ID, syllabusData\n                          .getSyllabusId().toString());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_POSITION,\n                          syllabusData.getPosition().toString());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_TITLE,\n                          syllabusData.getTitle());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_VIEW,\n                          syllabusData.getView());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_STATUS,\n                          syllabusData.getStatus());\n                      syllabus_data.setAttribute(\n                          SYLLABUS_DATA_EMAIL_NOTIFICATION, syllabusData\n                              .getEmailNotification());\n                      Element asset = doc.createElement(SYLLABUS_DATA_ASSET);\n\n                      try\n                      {\n                        String encoded = Base64.encode(syllabusData.getAsset().getBytes());\n                        asset.setAttribute(\"syllabus_body-html\", encoded);\n                      }\n                      catch(Exception e)\n                      {\n                        logger.warn(\"Encode Syllabus - \" + e);\n                      }\n                      \n                      \n                      syllabus_data.appendChild(asset);\n                      syllabus.appendChild(syllabus_data);\n\n                    }\n                  }\n//sakai2                }\n//                pageElement.appendChild(syllabus);\n//              }\n//              siteElement.appendChild(pageElement);\n//            }\n\n            //sakai2\n            siteElement.appendChild(syllabus);      \n          }\n          results.append(\"archiving \" + getLabel() + \": (\" + syDataCount\n              + \") syllabys items archived successfully.\\n\");\n        }\n        else\n        {\n          results.append(\"archiving \" + getLabel()\n              + \": empty syllabus archived.\\n\");\n        }\n        ((Element) stack.peek()).appendChild(siteElement);\n        stack.push(siteElement);\n      }\n      stack.pop();\n\n    }\n    catch (DOMException e)\n    {\n      logger.error(e.getMessage(), e);\n    }\n    catch (IdUnusedException e)\n    {\n      logger.error(e.getMessage(), e);\n    }\n    return results.toString();\n  }","id":41270,"modified_method":"public String archive(String siteId, Document doc, Stack stack, String arg3,\n      List attachments)\n  {\n\n    StringBuffer results = new StringBuffer();\n\n    try\n    {\n      int syDataCount = 0;\n      results.append(\"archiving \" + getLabel() + \" context \"\n          + Entity.SEPARATOR + siteId + Entity.SEPARATOR\n          + SiteService.MAIN_CONTAINER + \".\\n\");\n      // start with an element with our very own (service) name\n      Element element = doc.createElement(SyllabusService.class.getName());\n      ((Element) stack.peek()).appendChild(element);\n      stack.push(element);\n      if (siteId != null && siteId.trim().length() > 0)\n      {\n        Element siteElement = doc.createElement(SITE_ARCHIVE);\n        siteElement.setAttribute(SITE_NAME, SiteService.getSite(siteId).getId());\n        siteElement.setAttribute(SITE_ID, SiteService.getSite(siteId)\n            .getTitle());\n//sakai2        Iterator pageIter = getSyllabusPages(siteId);\n//        if (pageIter != null)\n//        {\n//          while (pageIter.hasNext())\n//          {\n//            String page = (String) pageIter.next();\n//            if (page != null)\n//            {\n//              Element pageElement = doc.createElement(PAGE_ARCHIVE);\n//              pageElement.setAttribute(PAGE_ID, page);\n//sakai2              pageElement.setAttribute(PAGE_NAME, SiteService.getSite(siteId)\n//sakai2                  .getPage(page).getTitle());\n//sakai2              SyllabusItem syllabusItem = syllabusManager\n//                  .getSyllabusItemByContextId(page);\n   \t\t\t\t\t\tSyllabusItem syllabusItem = syllabusManager\n   \t\t\t\t\t\t.getSyllabusItemByContextId(siteId);\n              if (syllabusItem != null)\n              {\n                Element syllabus = doc.createElement(SYLLABUS);\n                syllabus.setAttribute(SYLLABUS_ID, syllabusItem\n                    .getSurrogateKey().toString());\n                syllabus.setAttribute(SYLLABUS_USER_ID, syllabusItem\n                    .getUserId());\n                syllabus.setAttribute(SYLLABUS_CONTEXT_ID, syllabusItem\n                    .getContextId());\n                syllabus.setAttribute(SYLLABUS_REDIRECT_URL, syllabusItem\n                    .getRedirectURL());\n\n                Set syllabi = syllabusManager\n                    .getSyllabiForSyllabusItem(syllabusItem);\n\n                if (syllabi != null && !syllabi.isEmpty())\n                {\n                  Iterator syllabiIter = syllabi.iterator();\n                  while (syllabiIter.hasNext())\n                  {\n                    SyllabusData syllabusData = (SyllabusData) syllabiIter\n                        .next();\n                    if (syllabusData != null)\n                    {\n                      syDataCount++;\n                      Element syllabus_data = doc.createElement(SYLLABUS_DATA);\n                      syllabus_data.setAttribute(SYLLABUS_DATA_ID, syllabusData\n                          .getSyllabusId().toString());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_POSITION,\n                          syllabusData.getPosition().toString());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_TITLE,\n                          syllabusData.getTitle());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_VIEW,\n                          syllabusData.getView());\n                      syllabus_data.setAttribute(SYLLABUS_DATA_STATUS,\n                          syllabusData.getStatus());\n                      syllabus_data.setAttribute(\n                          SYLLABUS_DATA_EMAIL_NOTIFICATION, syllabusData\n                              .getEmailNotification());\n                      Element asset = doc.createElement(SYLLABUS_DATA_ASSET);\n\n                      try\n                      {\n                        String encoded = new String(Base64.encodeBase64(syllabusData.getAsset().getBytes()),\"UTF-8\");\n                        asset.setAttribute(\"syllabus_body-html\", encoded);\n                      }\n                      catch(Exception e)\n                      {\n                        logger.warn(\"Encode Syllabus - \" + e);\n                      }\n                      \n                      \n                      syllabus_data.appendChild(asset);\n                      syllabus.appendChild(syllabus_data);\n\n                    }\n                  }\n//sakai2                }\n//                pageElement.appendChild(syllabus);\n//              }\n//              siteElement.appendChild(pageElement);\n//            }\n\n            //sakai2\n            siteElement.appendChild(syllabus);      \n          }\n          results.append(\"archiving \" + getLabel() + \": (\" + syDataCount\n              + \") syllabys items archived successfully.\\n\");\n        }\n        else\n        {\n          results.append(\"archiving \" + getLabel()\n              + \": empty syllabus archived.\\n\");\n        }\n        ((Element) stack.peek()).appendChild(siteElement);\n        stack.push(siteElement);\n      }\n      stack.pop();\n\n    }\n    catch (DOMException e)\n    {\n      logger.error(e.getMessage(), e);\n    }\n    catch (IdUnusedException e)\n    {\n      logger.error(e.getMessage(), e);\n    }\n    return results.toString();\n  }","commit_id":"588b88d7a363120c5fb0e89ca9371994c506877e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void testSingleWrite() throws IOException {\n        byte[] ds = getDataSet(65536);\n        String master = Base64.encode(ds);\n\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        OutputStream o = BinarySafeStream.wrap(buf);\n        o.write(ds,0,ds.length);\n        o.close();\n        assertEquals(buf.toString(),master);\n    }","id":41271,"modified_method":"public void testSingleWrite() throws IOException {\n        byte[] ds = getDataSet(65536);\n        String master = new String(Base64.encodeBase64(ds));\n\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        OutputStream o = BinarySafeStream.wrap(buf);\n        o.write(ds,0,ds.length);\n        o.close();\n        assertEquals(buf.toString(),master);\n    }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void testChunkedWrites() throws IOException {\n        byte[] ds = getDataSet(65536);\n        String master = Base64.encode(ds);\n\n        Random r = new Random(0);\n        for( int i=0; i<16; i++) {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            OutputStream o = BinarySafeStream.wrap(buf);\n            randomCopy(r,new ByteArrayInputStream(ds),o,false);\n            assertEquals(buf.toString(),master);\n        }\n    }","id":41272,"modified_method":"public void testChunkedWrites() throws IOException {\n        byte[] ds = getDataSet(65536);\n        String master = new String(Base64.encodeBase64(ds));\n\n        Random r = new Random(0);\n        for( int i=0; i<16; i++) {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            OutputStream o = BinarySafeStream.wrap(buf);\n            randomCopy(r,new ByteArrayInputStream(ds),o,false);\n            assertEquals(buf.toString(),master);\n        }\n    }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void _testRoundtrip(boolean flush) throws IOException {\n        byte[] dataSet = getDataSet(65536);\n        Random r = new Random(0);\n        String master = Base64.encode(dataSet);\n\n        for(int i=0; i<16; i++) {\n            if(dump)\n                System.out.println(\"test started\");\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            randomCopy(r,new ByteArrayInputStream(dataSet), BinarySafeStream.wrap(buf), flush);\n\n            decodeByMaster(buf.toString(),dataSet);\n\n            if(dump)\n                System.out.println(\"------\");\n\n            ByteArrayOutputStream dst = new ByteArrayOutputStream();\n            randomCopy(r,BinarySafeStream.wrap(new ByteArrayInputStream(buf.toByteArray())), dst,flush);\n\n            byte[] result = dst.toByteArray();\n            if(!Arrays.equals(dataSet, result)) {\n                String msg = print(result, 0, result.length);\n                for( int j=0; j<result.length; j++ )\n                    assertEquals(\"offset \"+j+\" at \"+msg,result[j],dataSet[j]);\n                fail(msg);\n            }\n\n            if(dump)\n                System.out.println(\"------\");\n        }\n    }","id":41273,"modified_method":"private void _testRoundtrip(boolean flush) throws IOException {\n        byte[] dataSet = getDataSet(65536);\n        Random r = new Random(0);\n\n        for(int i=0; i<16; i++) {\n            if(dump)\n                System.out.println(\"test started\");\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            randomCopy(r,new ByteArrayInputStream(dataSet), BinarySafeStream.wrap(buf), flush);\n\n            decodeByMaster(buf.toString(),dataSet);\n\n            if(dump)\n                System.out.println(\"------\");\n\n            ByteArrayOutputStream dst = new ByteArrayOutputStream();\n            randomCopy(r,BinarySafeStream.wrap(new ByteArrayInputStream(buf.toByteArray())), dst,flush);\n\n            byte[] result = dst.toByteArray();\n            if(!Arrays.equals(dataSet, result)) {\n                String msg = print(result, 0, result.length);\n                for( int j=0; j<result.length; j++ )\n                    assertEquals(\"offset \"+j+\" at \"+msg,result[j],dataSet[j]);\n                fail(msg);\n            }\n\n            if(dump)\n                System.out.println(\"------\");\n        }\n    }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Decodes by the JDK base64 code and make sure the encoded string looks correct.\n     */\n    private void decodeByMaster(String s, byte[] dataSet) throws IOException {\n        int ptr=0;\n\n        for( int i=0; i<s.length(); i+=4 ) {\n            byte[] buf = Base64.decode(s.substring(i,i+4));\n            for (int j = 0; j < buf.length; j++) {\n                if(buf[j]!=dataSet[ptr])\n                    fail(\"encoding error at offset \"+ptr);\n                ptr++;\n            }\n        }\n    }","id":41274,"modified_method":"/**\n     * Decodes by the JDK base64 code and make sure the encoded string looks correct.\n     */\n    private void decodeByMaster(String s, byte[] dataSet) throws IOException {\n        int ptr=0;\n\n        for( int i=0; i<s.length(); i+=4 ) {\n            byte[] buf = Base64.decodeBase64(s.substring(i,i+4).getBytes());\n            for (int j = 0; j < buf.length; j++) {\n                if(buf[j]!=dataSet[ptr])\n                    fail(\"encoding error at offset \"+ptr);\n                ptr++;\n            }\n        }\n    }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Infer the root DN.\n     *\n     * @return null if not found.\n     */\n    private String inferRootDN(String server) {\n        try {\n            Hashtable<String,String> props = new Hashtable<String,String>();\n            if(managerDN!=null) {\n                props.put(Context.SECURITY_PRINCIPAL,managerDN);\n                props.put(Context.SECURITY_CREDENTIALS,getManagerPassword());\n            }\n            DirContext ctx = LdapCtxFactory.getLdapCtxInstance(getServerUrl()+'/', props);\n            Attributes atts = ctx.getAttributes(\"\");\n            Attribute a = atts.get(\"defaultNamingContext\");\n            if(a!=null) // this entry is available on Active Directory. See http://msdn2.microsoft.com/en-us/library/ms684291(VS.85).aspx\n                return a.toString();\n            \n            a = atts.get(\"namingcontexts\");\n            if(a==null) {\n                LOGGER.warning(\"namingcontexts attribute not found in root DSE of \"+server);\n                return null;\n            }\n            return a.get().toString();\n        } catch (NamingException e) {\n            LOGGER.log(Level.WARNING,\"Failed to connect to LDAP to infer Root DN for \"+server,e);\n            return null;\n        }\n    }","id":41275,"modified_method":"/**\n     * Infer the root DN.\n     *\n     * @return null if not found.\n     */\n    private String inferRootDN(String server) {\n        try {\n            Hashtable<String,String> props = new Hashtable<String,String>();\n            if(managerDN!=null) {\n                props.put(Context.SECURITY_PRINCIPAL,managerDN);\n                props.put(Context.SECURITY_CREDENTIALS,getManagerPassword());\n            }\n            props.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n            props.put(Context.PROVIDER_URL, getServerUrl()+'/');\n\n            DirContext ctx = new InitialDirContext(props);\n            Attributes atts = ctx.getAttributes(\"\");\n            Attribute a = atts.get(\"defaultNamingContext\");\n            if(a!=null) // this entry is available on Active Directory. See http://msdn2.microsoft.com/en-us/library/ms684291(VS.85).aspx\n                return a.toString();\n            \n            a = atts.get(\"namingcontexts\");\n            if(a==null) {\n                LOGGER.warning(\"namingcontexts attribute not found in root DSE of \"+server);\n                return null;\n            }\n            return a.get().toString();\n        } catch (NamingException e) {\n            LOGGER.log(Level.WARNING,\"Failed to connect to LDAP to infer Root DN for \"+server,e);\n            return null;\n        }\n    }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"public FormValidation doServerCheck(\n                @QueryParameter final String server,\n        \t\t@QueryParameter final String managerDN,\n        \t\t@QueryParameter final String managerPassword) {\n\n            if(!Hudson.getInstance().hasPermission(Hudson.ADMINISTER))\n                return FormValidation.ok();\n\n            try {\n                Hashtable<String,String> props = new Hashtable<String,String>();\n                if(managerDN!=null && managerDN.trim().length() > 0  && !\"undefined\".equals(managerDN)) {\n                    props.put(Context.SECURITY_PRINCIPAL,managerDN);\n                }\n                if(managerPassword!=null && managerPassword.trim().length() > 0 && !\"undefined\".equals(managerPassword)) {\n                    props.put(Context.SECURITY_CREDENTIALS,managerPassword);\n                }\n                DirContext ctx = LdapCtxFactory.getLdapCtxInstance(addPrefix(server)+'/', props);\n                ctx.getAttributes(\"\");\n                return FormValidation.ok();   // connected\n            } catch (NamingException e) {\n                // trouble-shoot\n                Matcher m = Pattern.compile(\"(ldaps://)?([^:]+)(?:\\\\:(\\\\d+))?\").matcher(server.trim());\n                if(!m.matches())\n                    return FormValidation.error(\"Syntax of server field is SERVER or SERVER:PORT or ldaps://SERVER[:PORT]\");\n\n                try {\n                    InetAddress adrs = InetAddress.getByName(m.group(2));\n                    int port = m.group(1)!=null ? 636 : 389;\n                    if(m.group(3)!=null)\n                        port = Integer.parseInt(m.group(3));\n                    Socket s = new Socket(adrs,port);\n                    s.close();\n                } catch (UnknownHostException x) {\n                    return FormValidation.error(\"Unknown host: \"+x.getMessage());\n                } catch (IOException x) {\n                    return FormValidation.error(\"Unable to connect to \"+server+\" : \"+x.getMessage());\n                }\n\n                // otherwise we don't know what caused it, so fall back to the general error report\n                // getMessage() alone doesn't offer enough\n                return FormValidation.error(\"Unable to connect to \"+server+\": \"+e);\n            } catch (NumberFormatException x) {\n                // The getLdapCtxInstance method throws this if it fails to parse the port number\n                return FormValidation.error(\"Invalid port number\");\n            }\n        }","id":41276,"modified_method":"public FormValidation doServerCheck(\n                @QueryParameter final String server,\n        \t\t@QueryParameter final String managerDN,\n        \t\t@QueryParameter final String managerPassword) {\n\n            if(!Hudson.getInstance().hasPermission(Hudson.ADMINISTER))\n                return FormValidation.ok();\n\n            try {\n                Hashtable<String,String> props = new Hashtable<String,String>();\n                if(managerDN!=null && managerDN.trim().length() > 0  && !\"undefined\".equals(managerDN)) {\n                    props.put(Context.SECURITY_PRINCIPAL,managerDN);\n                }\n                if(managerPassword!=null && managerPassword.trim().length() > 0 && !\"undefined\".equals(managerPassword)) {\n                    props.put(Context.SECURITY_CREDENTIALS,managerPassword);\n                }\n                props.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n                props.put(Context.PROVIDER_URL, addPrefix(server)+'/');\n\n                DirContext ctx = new InitialDirContext(props);\n                ctx.getAttributes(\"\");\n                return FormValidation.ok();   // connected\n            } catch (NamingException e) {\n                // trouble-shoot\n                Matcher m = Pattern.compile(\"(ldaps://)?([^:]+)(?:\\\\:(\\\\d+))?\").matcher(server.trim());\n                if(!m.matches())\n                    return FormValidation.error(\"Syntax of server field is SERVER or SERVER:PORT or ldaps://SERVER[:PORT]\");\n\n                try {\n                    InetAddress adrs = InetAddress.getByName(m.group(2));\n                    int port = m.group(1)!=null ? 636 : 389;\n                    if(m.group(3)!=null)\n                        port = Integer.parseInt(m.group(3));\n                    Socket s = new Socket(adrs,port);\n                    s.close();\n                } catch (UnknownHostException x) {\n                    return FormValidation.error(\"Unknown host: \"+x.getMessage());\n                } catch (IOException x) {\n                    return FormValidation.error(\"Unable to connect to \"+server+\" : \"+x.getMessage());\n                }\n\n                // otherwise we don't know what caused it, so fall back to the general error report\n                // getMessage() alone doesn't offer enough\n                return FormValidation.error(\"Unable to connect to \"+server+\": \"+e);\n            } catch (NumberFormatException x) {\n                // The getLdapCtxInstance method throws this if it fails to parse the port number\n                return FormValidation.error(\"Invalid port number\");\n            }\n        }","commit_id":"e259abec4a114dea56fc8adcc55022d613b50774","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static void testContains() {\n        LazyRemovalSet<Address> cache=new LazyRemovalSet<Address>(5, 0);\n        Address a=Util.createRandomAddress(\"A\"),\n          b=new ProxyAddress(Util.createRandomAddress(\"X\"), Util.createRandomAddress(\"B\")),\n          c=Util.createRandomAddress(\"C\"),\n          d=new ProxyAddress(Util.createRandomAddress(\"Y\"), Util.createRandomAddress(\"D\"));\n        cache.add(a,b,c,d);\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 4;\n        assert cache.contains(a);\n        assert cache.contains(b);\n        assert cache.contains(d);\n        assert cache.contains(d);\n        cache.retainAll(Arrays.asList(a,c));\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 4;\n        cache.removeMarkedElements();\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 2;\n    }","id":41277,"modified_method":"public static void testContains() {\n        LazyRemovalSet<Address> cache=new LazyRemovalSet<Address>(5, 0);\n        Address a=Util.createRandomAddress(\"A\"),\n          b=Util.createRandomAddress(\"B\"),\n          c=Util.createRandomAddress(\"C\"),\n          d=Util.createRandomAddress(\"D\");\n        cache.add(a,b,c,d);\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 4;\n        assert cache.contains(a);\n        assert cache.contains(b);\n        assert cache.contains(d);\n        assert cache.contains(d);\n        cache.retainAll(Arrays.asList(a,c));\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 4;\n        cache.removeMarkedElements();\n        System.out.println(\"cache = \" + cache);\n        assert cache.size() == 2;\n    }","commit_id":"c1a6dfdf0d8266e1465e6e79ba498b907de27ced","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void testWriteAddress() throws IOException, IllegalAccessException, InstantiationException {\n        Address uuid=UUID.randomUUID();\n        _testWriteAddress(uuid);\n\n        ((UUID)uuid).setAdditionalData(\"Bela Ban\".getBytes());\n        _testWriteAddress(uuid);\n\n        Address addr=new IpAddress(7500);\n        _testWriteAddress(addr);\n\n        addr=new IpAddress(\"127.0.0.1\", 5678);\n        _testWriteAddress(addr);\n\n        ((IpAddress)addr).setAdditionalData(\"Bela Ban\".getBytes());\n        _testWriteAddress(addr);\n        \n        addr=new ProxyAddress(Util.createRandomAddress(\"A\"), Util.createRandomAddress(\"B\"));\n        _testWriteAddress(addr);\n    }","id":41278,"modified_method":"public static void testWriteAddress() throws IOException, IllegalAccessException, InstantiationException {\n        Address uuid=UUID.randomUUID();\n        _testWriteAddress(uuid);\n\n        ((UUID)uuid).setAdditionalData(\"Bela Ban\".getBytes());\n        _testWriteAddress(uuid);\n\n        Address addr=new IpAddress(7500);\n        _testWriteAddress(addr);\n\n        addr=new IpAddress(\"127.0.0.1\", 5678);\n        _testWriteAddress(addr);\n\n        ((IpAddress)addr).setAdditionalData(\"Bela Ban\".getBytes());\n        _testWriteAddress(addr);\n    }","commit_id":"c1a6dfdf0d8266e1465e6e79ba498b907de27ced","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void testRelayHeader() throws Exception {\n        RELAY.RelayHeader hdr=new RELAY.RelayHeader(RELAY.RelayHeader.Type.DISSEMINATE);\n        _testSize(hdr);\n\n        hdr=new RELAY.RelayHeader(RELAY.RelayHeader.Type.DISSEMINATE, Util.createRandomAddress(\"A\"));\n        _testSize(hdr);\n    }","id":41279,"modified_method":"public static void testRelayHeader() throws Exception {\n        RELAY.RelayHeader hdr=RELAY.RelayHeader.create(RELAY.RelayHeader.Type.FORWARD);\n        _testSize(hdr);\n\n        hdr=RELAY.RelayHeader.createDisseminateHeader(Util.createRandomAddress(\"A\"));\n        _testSize(hdr);\n\n        Map<Address,String> uuid_cache=new HashMap<Address,String>();\n        uuid_cache.put(Util.createRandomAddress(\"A\"), \"A\");\n        uuid_cache.put(Util.createRandomAddress(\"B\"), \"B\");\n        uuid_cache.put(Util.createRandomAddress(\"B\"), \"B\");\n        hdr=RELAY.RelayHeader.create(RELAY.RelayHeader.Type.UUIDS);\n        _testSize(hdr);\n    }","commit_id":"c00ccae45a5225271e00456362a4420f87aa052e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void process(StreamEvent event) throws OperationException {\n    // Input is a String, need to split it by whitespace\n    byte [] rawInput = Bytes.toBytes(event.getBody());\n    String inputString = new String(rawInput);\n\n    String [] words = inputString.split(\"\\\\s+\");\n    List<String> wordList = new ArrayList<String>(words.length);\n\n    long sumOfLengths = 0;\n    long wordCount = 0;\n\n    // We have an array of words, now remove all non-alpha characters\n    for (String word : words) {\n      word = word.replaceAll(\"[^A-Za-z]\", \"\");\n      if (!word.isEmpty()) {\n        // emit every word that remains\n        wordOutput.emit(word);\n        wordList.add(word);\n        sumOfLengths += word.length();\n        wordCount++;\n      }\n    }\n\n    // Count other word statistics (word length, total words seen)\n    this.wordStatsTable.write(\n      new Increment(TOTALS_ROW,\n                    new byte[][] { TOTAL_LENGTH,  TOTAL_WORDS },\n                    new long[]   { sumOfLengths,  wordCount}));\n\n    // Send the list of words to the associater\n    wordListOutput.emit(wordList);\n    \n  }","id":41280,"modified_method":"public void process(StreamEvent event) throws OperationException {\n    // Input is a String, need to split it by whitespace\n    String inputString = Charset.forName(\"UTF-8\")\n      .decode(event.getBody()).toString();\n\n    String [] words = inputString.split(\"\\\\s+\");\n    List<String> wordList = new ArrayList<String>(words.length);\n\n    long sumOfLengths = 0;\n    long wordCount = 0;\n\n    // We have an array of words, now remove all non-alpha characters\n    for (String word : words) {\n      word = word.replaceAll(\"[^A-Za-z]\", \"\");\n      if (!word.isEmpty()) {\n        // emit every word that remains\n        wordOutput.emit(word);\n        wordList.add(word);\n        sumOfLengths += word.length();\n        wordCount++;\n      }\n    }\n\n    // Count other word statistics (word length, total words seen)\n    this.wordStatsTable.write(\n      new Increment(TOTALS_ROW,\n                    new byte[][] { TOTAL_LENGTH,  TOTAL_WORDS },\n                    new long[]   { sumOfLengths,  wordCount}));\n\n    // Send the list of words to the associater\n    wordListOutput.emit(wordList);\n    \n  }","commit_id":"e16020a15d6295df9c173496070128db323ae619","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Execute a transaction method given a complete URI.\n   * @param method the transaction method\n   * @param headers HTTP header values to send\n   * @param uri the URI\n   * @return the HTTP response code\n   * @throws IOException\n   */\n  @SuppressWarnings(\"deprecation\")\n  public int executeURI(HttpMethod method, Header[] headers, String uri)\n      throws IOException {\n    method.setURI(new URI(uri));\n    if (headers != null) {\n      for (Header header: headers) {\n        method.addRequestHeader(header);\n      }\n    }\n    long startTime = System.currentTimeMillis();\n    int code = httpClient.executeMethod(method);\n    long endTime = System.currentTimeMillis();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(method.getName() + \" \" + uri + \" \" + code + \" \" +\n        method.getStatusText() + \" in \" + (endTime - startTime) + \" ms\");\n    }\n    return code;\n  }","id":41281,"modified_method":"/**\n   * Execute a transaction method given a complete URI.\n   * @param method the transaction method\n   * @param headers HTTP header values to send\n   * @param uri a properly urlencoded URI\n   * @return the HTTP response code\n   * @throws IOException\n   */\n  public int executeURI(HttpMethod method, Header[] headers, String uri)\n      throws IOException {\n    method.setURI(new URI(uri, true));\n    if (headers != null) {\n      for (Header header: headers) {\n        method.addRequestHeader(header);\n      }\n    }\n    long startTime = System.currentTimeMillis();\n    int code = httpClient.executeMethod(method);\n    long endTime = System.currentTimeMillis();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(method.getName() + \" \" + uri + \" \" + code + \" \" +\n        method.getStatusText() + \" in \" + (endTime - startTime) + \" ms\");\n    }\n    return code;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Execute a transaction method given only the path. Will select at random\n   * one of the members of the supplied cluster definition and iterate through\n   * the list until a transaction can be successfully completed. The\n   * definition of success here is a complete HTTP transaction, irrespective\n   * of result code.  \n   * @param cluster the cluster definition\n   * @param method the transaction method\n   * @param headers HTTP header values to send\n   * @param path the path\n   * @return the HTTP response code\n   * @throws IOException\n   */\n  @SuppressWarnings(\"deprecation\")\n  public int executePathOnly(Cluster cluster, HttpMethod method,\n      Header[] headers, String path) throws IOException {\n    IOException lastException;\n    if (cluster.nodes.size() < 1) {\n      throw new IOException(\"Cluster is empty\");\n    }\n    int start = (int)Math.round((cluster.nodes.size() - 1) * Math.random());\n    int i = start;\n    do {\n      cluster.lastHost = cluster.nodes.get(i);\n      try {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http://\");\n        sb.append(cluster.lastHost);\n        sb.append(path);\n        URI uri = new URI(sb.toString());\n        return executeURI(method, headers, uri.toString());\n      } catch (IOException e) {\n        lastException = e;\n      }\n    } while (++i != start && i < cluster.nodes.size());\n    throw lastException;\n  }","id":41282,"modified_method":"/**\n   * Execute a transaction method given only the path. Will select at random\n   * one of the members of the supplied cluster definition and iterate through\n   * the list until a transaction can be successfully completed. The\n   * definition of success here is a complete HTTP transaction, irrespective\n   * of result code.  \n   * @param cluster the cluster definition\n   * @param method the transaction method\n   * @param headers HTTP header values to send\n   * @param path the properly urlencoded path\n   * @return the HTTP response code\n   * @throws IOException\n   */\n  public int executePathOnly(Cluster cluster, HttpMethod method,\n      Header[] headers, String path) throws IOException {\n    IOException lastException;\n    if (cluster.nodes.size() < 1) {\n      throw new IOException(\"Cluster is empty\");\n    }\n    int start = (int)Math.round((cluster.nodes.size() - 1) * Math.random());\n    int i = start;\n    do {\n      cluster.lastHost = cluster.nodes.get(i);\n      try {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http://\");\n        sb.append(cluster.lastHost);\n        sb.append(path);\n        URI uri = new URI(sb.toString(), true);\n        return executeURI(method, headers, uri.toString());\n      } catch (IOException e) {\n        lastException = e;\n      }\n    } while (++i != start && i < cluster.nodes.size());\n    throw lastException;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Constructor\n   * @param table\n   * @param rowspec\n   * @param versions\n   * @throws IOException\n   */\n  public RowResource(String table, String rowspec, String versions)\n      throws IOException {\n    super();\n    this.tableName = table;\n    this.rowspec = new RowSpec(URLDecoder.decode(rowspec,\n      HConstants.UTF8_ENCODING));\n    if (versions != null) {\n      this.rowspec.setMaxVersions(Integer.valueOf(versions));\n    }\n    this.cacheControl = new CacheControl();\n    this.cacheControl.setMaxAge(servlet.getMaxAge(tableName));\n    this.cacheControl.setNoTransform(false);    \n  }","id":41283,"modified_method":"/**\n   * Constructor\n   * @param table\n   * @param rowspec\n   * @param versions\n   * @throws IOException\n   */\n  public RowResource(String table, String rowspec, String versions)\n      throws IOException {\n    super();\n    this.tableName = table;\n    this.rowspec = new RowSpec(rowspec);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"new RowResource: table=\" + this.tableName + \"rowspec=\" +\n        this.rowspec);\n    }\n    if (versions != null) {\n      this.rowspec.setMaxVersions(Integer.valueOf(versions));\n    }\n    this.cacheControl = new CacheControl();\n    this.cacheControl.setMaxAge(servlet.getMaxAge(tableName));\n    this.cacheControl.setNoTransform(false);    \n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"private int parseColumns(final String path, int i)\n      throws IllegalArgumentException {\n    if (i >= path.length()) {\n      return i;\n    }\n    try {\n      char c;\n      StringBuilder column = new StringBuilder();\n      boolean hasColon = false;\n      while (i < path.length() && (c = path.charAt(i)) != '/') {\n        if (c == ',') {\n          if (column.length() < 1) {\n            throw new IllegalArgumentException(\"invalid path\");\n          }\n          if (!hasColon) {\n            column.append(':');\n          }\n          this.columns.add(Bytes.toBytes(column.toString()));\n          column = new StringBuilder();\n          hasColon = false;\n          i++;\n          continue;\n        }\n        if (c == ':') {\n          hasColon = true;\n        }\n        column.append(c);\n        i++;\n      }\n      i++;\n      // trailing list entry\n      if (column.length() > 1) {\n        if (!hasColon) {\n          column.append(':');\n        }\n        this.columns.add(Bytes.toBytes(column.toString()));\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    }\n    return i;\n  }","id":41284,"modified_method":"private int parseColumns(final String path, int i)\n      throws IllegalArgumentException {\n    if (i >= path.length()) {\n      return i;\n    }\n    try {\n      char c;\n      StringBuilder column = new StringBuilder();\n      while (i < path.length() && (c = path.charAt(i)) != '/') {\n        if (c == ',') {\n          if (column.length() < 1) {\n            throw new IllegalArgumentException(\"invalid path\");\n          }\n          String s = URLDecoder.decode(column.toString(),\n            HConstants.UTF8_ENCODING);\n          if (!s.contains(\":\")) {\n            this.columns.add(Bytes.toBytes(s + \":\"));\n          } else {\n            this.columns.add(Bytes.toBytes(s));\n          }\n          column.setLength(0);\n          i++;\n          continue;\n        }\n        column.append(c);\n        i++;\n      }\n      i++;\n      // trailing list entry\n      if (column.length() > 1) {\n        String s = URLDecoder.decode(column.toString(),\n          HConstants.UTF8_ENCODING);\n        if (!s.contains(\":\")) {\n          this.columns.add(Bytes.toBytes(s + \":\"));\n        } else {\n          this.columns.add(Bytes.toBytes(s));\n        }\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    } catch (UnsupportedEncodingException e) {\n      // shouldn't happen\n      throw new RuntimeException(e);\n    }\n    return i;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"private int parseTimestamp(final String path, int i)\n      throws IllegalArgumentException {\n    if (i >= path.length()) {\n      return i;\n    }\n    long time0 = 0, time1 = 0;\n    try {\n      char c = 0;\n      StringBuilder stamp = new StringBuilder();\n      while (i < path.length()) {\n        c = path.charAt(i);\n        if (c == '/' || c == ',') {\n          break;\n        }\n        stamp.append(c);\n        i++;\n      }\n      try {\n        time0 = Long.valueOf(stamp.toString());\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(e);\n      }\n      if (c == ',') {\n        stamp = new StringBuilder();\n        i++;\n        while (i < path.length() && ((c = path.charAt(i)) != '/')) {\n          stamp.append(c);\n          i++;\n        }\n        try {\n          time1 = Long.valueOf(stamp.toString());\n        } catch (NumberFormatException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n      if (c == '/') {\n        i++;\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    }\n    if (time1 != 0) {\n      startTime = time0;\n      endTime = time1;\n    } else {\n      endTime = time0;\n    }\n    return i;\n  }","id":41285,"modified_method":"private int parseTimestamp(final String path, int i)\n      throws IllegalArgumentException {\n    if (i >= path.length()) {\n      return i;\n    }\n    long time0 = 0, time1 = 0;\n    try {\n      char c = 0;\n      StringBuilder stamp = new StringBuilder();\n      while (i < path.length()) {\n        c = path.charAt(i);\n        if (c == '/' || c == ',') {\n          break;\n        }\n        stamp.append(c);\n        i++;\n      }\n      try {\n        time0 = Long.valueOf(URLDecoder.decode(stamp.toString(),\n          HConstants.UTF8_ENCODING));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(e);\n      }\n      if (c == ',') {\n        stamp = new StringBuilder();\n        i++;\n        while (i < path.length() && ((c = path.charAt(i)) != '/')) {\n          stamp.append(c);\n          i++;\n        }\n        try {\n          time1 = Long.valueOf(URLDecoder.decode(stamp.toString(),\n            HConstants.UTF8_ENCODING));\n        } catch (NumberFormatException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n      if (c == '/') {\n        i++;\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    } catch (UnsupportedEncodingException e) {\n      // shouldn't happen\n      throw new RuntimeException(e);\n    }\n    if (time1 != 0) {\n      startTime = time0;\n      endTime = time1;\n    } else {\n      endTime = time0;\n    }\n    return i;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"private int parseQueryParams(final String path, int i) {\n    while (i < path.length()) {\n      char c = path.charAt(i);\n      if (c != '?' && c != '&') {\n        break;\n      }\n      if (++i > path.length()) {\n        break;\n      }\n      char what = path.charAt(i);\n      if (++i > path.length()) {\n        break;\n      }\n      c = path.charAt(i);\n      if (c != '=') {\n        throw new IllegalArgumentException(\"malformed query parameter\");\n      }\n      if (++i > path.length()) {\n        break;\n      }\n      switch (what) {\n      case 'm': {\n        StringBuilder sb = new StringBuilder();\n        while (i <= path.length()) {\n          c = path.charAt(i);\n          if (c < '0' || c > '9') {\n            i--;\n            break;\n          }\n          sb.append(c);\n        }\n        maxVersions = Integer.valueOf(sb.toString());\n      } break;\n      case 'n': {\n        StringBuilder sb = new StringBuilder();\n        while (i <= path.length()) {\n          c = path.charAt(i);\n          if (c < '0' || c > '9') {\n            i--;\n            break;\n          }\n          sb.append(c);\n        }\n        maxValues = Integer.valueOf(sb.toString());\n      } break;\n      default:\n        throw new IllegalArgumentException(\"unknown parameter '\" + c + \"'\");\n      }\n    }\n    return i;\n  }","id":41286,"modified_method":"private int parseQueryParams(final String path, int i) {\n    if (i >= path.length()) {\n      return i;\n    }\n    StringBuilder query = new StringBuilder();\n    try {\n      query.append(URLDecoder.decode(path.substring(i), \n        HConstants.UTF8_ENCODING));\n    } catch (UnsupportedEncodingException e) {\n      // should not happen\n      throw new RuntimeException(e);\n    }\n    i += query.length();\n    int j = 0;\n    while (j < query.length()) {\n      char c = query.charAt(j);\n      if (c != '?' && c != '&') {\n        break;\n      }\n      if (++j > query.length()) {\n        throw new IllegalArgumentException(\"malformed query parameter\");\n      }\n      char what = query.charAt(j);\n      if (++j > query.length()) {\n        break;\n      }\n      c = query.charAt(j);\n      if (c != '=') {\n        throw new IllegalArgumentException(\"malformed query parameter\");\n      }\n      if (++j > query.length()) {\n        break;\n      }\n      switch (what) {\n      case 'm': {\n        StringBuilder sb = new StringBuilder();\n        while (j <= query.length()) {\n          c = query.charAt(i);\n          if (c < '0' || c > '9') {\n            j--;\n            break;\n          }\n          sb.append(c);\n        }\n        maxVersions = Integer.valueOf(sb.toString());\n      } break;\n      case 'n': {\n        StringBuilder sb = new StringBuilder();\n        while (j <= query.length()) {\n          c = query.charAt(i);\n          if (c < '0' || c > '9') {\n            j--;\n            break;\n          }\n          sb.append(c);\n        }\n        maxValues = Integer.valueOf(sb.toString());\n      } break;\n      default:\n        throw new IllegalArgumentException(\"unknown parameter '\" + c + \"'\");\n      }\n    }\n    return i;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"private int parseRowKeys(final String path, int i)\n      throws IllegalArgumentException {\n    StringBuilder startRow = new StringBuilder();\n    StringBuilder endRow = null;\n    try {\n      char c;\n      boolean doEndRow = false;\n      while (i < path.length() && (c = path.charAt(i)) != '/') {\n        if (c == ',') {\n          doEndRow = true;\n          i++;\n          break;\n        }\n        startRow.append(c);\n        i++;\n      }\n      i++;\n      this.row = Bytes.toBytes(startRow.toString());\n      if (doEndRow) {\n        endRow = new StringBuilder();\n        while ((c = path.charAt(i)) != '/') {\n          endRow.append(c);\n          i++;\n        }\n        i++;\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    }\n    // HBase does not support wildcards on row keys so we will emulate a\n    // suffix glob by synthesizing appropriate start and end row keys for\n    // table scanning\n    if (startRow.charAt(startRow.length() - 1) == '*') {\n      if (endRow != null)\n        throw new IllegalArgumentException(\"invalid path: start row \"+\n          \"specified with wildcard\");\n      this.row = Bytes.toBytes(startRow.substring(0, \n                   startRow.lastIndexOf(\"*\")));\n      this.endRow = new byte[this.row.length + 1];\n      System.arraycopy(this.row, 0, this.endRow, 0, this.row.length);\n      this.endRow[this.row.length] = (byte)255;\n    } else {\n      this.row = Bytes.toBytes(startRow.toString());\n      if (endRow != null) {\n        this.endRow = Bytes.toBytes(endRow.toString());\n      }\n    }\n    return i;\n  }","id":41287,"modified_method":"private int parseRowKeys(final String path, int i)\n      throws IllegalArgumentException {\n    String startRow = null, endRow = null;\n    try {\n      StringBuilder sb = new StringBuilder();\n      char c;\n      while (i < path.length() && (c = path.charAt(i)) != '/') {\n        sb.append(c);\n        i++;\n      }\n      i++;\n      startRow = sb.toString();\n      int idx = startRow.indexOf(',');\n      if (idx != -1) {\n        startRow = URLDecoder.decode(startRow.substring(0, idx),\n          HConstants.UTF8_ENCODING);\n        endRow = URLDecoder.decode(startRow.substring(idx + 1),\n          HConstants.UTF8_ENCODING);\n      } else {\n        startRow = URLDecoder.decode(startRow, HConstants.UTF8_ENCODING);\n      }\n    } catch (IndexOutOfBoundsException e) {\n      throw new IllegalArgumentException(e);\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n    // HBase does not support wildcards on row keys so we will emulate a\n    // suffix glob by synthesizing appropriate start and end row keys for\n    // table scanning\n    if (startRow.charAt(startRow.length() - 1) == '*') {\n      if (endRow != null)\n        throw new IllegalArgumentException(\"invalid path: start row \"+\n          \"specified with wildcard\");\n      this.row = Bytes.toBytes(startRow.substring(0, \n        startRow.lastIndexOf(\"*\")));\n      this.endRow = new byte[this.row.length + 1];\n      System.arraycopy(this.row, 0, this.endRow, 0, this.row.length);\n      this.endRow[this.row.length] = (byte)255;\n    } else {\n      this.row = Bytes.toBytes(startRow.toString());\n      if (endRow != null) {\n        this.endRow = Bytes.toBytes(endRow.toString());\n      }\n    }\n    return i;\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"Response getValueXML(String table, String row, String column)\n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    Response response = client.get(path.toString(), MIMETYPE_XML);\n    return response;\n  }","id":41288,"modified_method":"Response getValueXML(String table, String row, String column)\n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    return getValueXML(path.toString());\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"Response putValuePB(String table, String row, String column, String value)\n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    RowModel rowModel = new RowModel(row);\n    rowModel.addCell(new CellModel(Bytes.toBytes(column),\n      Bytes.toBytes(value)));\n    CellSetModel cellSetModel = new CellSetModel();\n    cellSetModel.addRow(rowModel);\n    Response response = client.put(path.toString(), MIMETYPE_PROTOBUF,\n      cellSetModel.createProtobufOutput());\n    Thread.yield();\n    return response;\n  }","id":41289,"modified_method":"Response putValuePB(String table, String row, String column, String value)\n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    return putValuePB(path.toString(), table, row, column, value);\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"public void testNoSuchCF() throws IOException, JAXBException {\n    final String goodPath = \"/\" + TABLE + \"/\" + ROW_1 + \"/\" + CFA+\":\";\n    final String badPath = \"/\" + TABLE + \"/\" + ROW_1 + \"/\" + \"BAD\";\n    Response response = client.post(goodPath, MIMETYPE_BINARY,\n      Bytes.toBytes(VALUE_1));\n    assertEquals(response.getCode(), 200);\n    assertEquals(client.get(goodPath, MIMETYPE_BINARY).getCode(), 200);\n    assertEquals(client.get(badPath, MIMETYPE_BINARY).getCode(), 404);\n    assertEquals(client.get(goodPath, MIMETYPE_BINARY).getCode(), 200);\n  }","id":41290,"modified_method":"public void doTestNoSuchCF() throws IOException, JAXBException {\n    final String goodPath = \"/\" + TABLE + \"/\" + ROW_1 + \"/\" + CFA+\":\";\n    final String badPath = \"/\" + TABLE + \"/\" + ROW_1 + \"/\" + \"BAD\";\n    Response response = client.post(goodPath, MIMETYPE_BINARY,\n      Bytes.toBytes(VALUE_1));\n    assertEquals(response.getCode(), 200);\n    assertEquals(client.get(goodPath, MIMETYPE_BINARY).getCode(), 200);\n    assertEquals(client.get(badPath, MIMETYPE_BINARY).getCode(), 404);\n    assertEquals(client.get(goodPath, MIMETYPE_BINARY).getCode(), 200);\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"public void testRowResource() throws Exception {\n    doTestDelete();\n    doTestSingleCellGetPutXML();\n    doTestSingleCellGetPutPB();\n    doTestSingleCellGetPutBinary();\n    doTestSingleCellGetJSON();\n    doTestURLEncodedKey();\n    doTestMultiCellGetPutXML();\n    doTestMultiCellGetPutPB();\n  }","id":41291,"modified_method":"public void testRowResource() throws Exception {\n    doTestDelete();\n    doTestSingleCellGetPutXML();\n    doTestSingleCellGetPutPB();\n    doTestSingleCellGetPutBinary();\n    doTestSingleCellGetJSON();\n    doTestURLEncodedKey();\n    doTestNoSuchCF();\n    doTestMultiCellGetPutXML();\n    doTestMultiCellGetPutPB();\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"void doTestURLEncodedKey() throws IOException, JAXBException {\n    String encodedKey = URLEncoder.encode(\"http://www.google.com/\", \n      HConstants.UTF8_ENCODING);\n    Response response;\n    response = putValueXML(TABLE, encodedKey, COLUMN_1, VALUE_1);\n    assertEquals(response.getCode(), 200);\n    response = putValuePB(TABLE, encodedKey, COLUMN_2, VALUE_2);\n    assertEquals(response.getCode(), 200);\n    checkValuePB(TABLE, encodedKey, COLUMN_1, VALUE_1);\n    checkValueXML(TABLE, encodedKey, COLUMN_2, VALUE_2);\n  }","id":41292,"modified_method":"public void doTestURLEncodedKey() throws IOException, JAXBException {\n    String urlKey = \"http://example.com/foo\";\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(TABLE);\n    path.append('/');\n    path.append(URLEncoder.encode(urlKey, HConstants.UTF8_ENCODING));\n    path.append('/');\n    path.append(COLUMN_1);\n    Response response;\n    response = putValueXML(path.toString(), TABLE, urlKey, COLUMN_1,\n      VALUE_1);\n    assertEquals(response.getCode(), 200);\n    checkValueXML(path.toString(), TABLE, urlKey, COLUMN_1, VALUE_1);\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"Response putValueXML(String table, String row, String column, String value)\n      throws IOException, JAXBException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    RowModel rowModel = new RowModel(row);\n    rowModel.addCell(new CellModel(Bytes.toBytes(column),\n      Bytes.toBytes(value)));\n    CellSetModel cellSetModel = new CellSetModel();\n    cellSetModel.addRow(rowModel);\n    StringWriter writer = new StringWriter();\n    marshaller.marshal(cellSetModel, writer);\n    Response response = client.put(path.toString(), MIMETYPE_XML,\n      Bytes.toBytes(writer.toString()));\n    Thread.yield();\n    return response;\n  }","id":41293,"modified_method":"Response putValueXML(String table, String row, String column, String value)\n      throws IOException, JAXBException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    return putValueXML(path.toString(), table, row, column, value);\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"Response getValuePB(String table, String row, String column) \n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    Response response = client.get(path.toString(), MIMETYPE_PROTOBUF); \n    return response;\n  }","id":41294,"modified_method":"Response getValuePB(String table, String row, String column) \n      throws IOException {\n    StringBuilder path = new StringBuilder();\n    path.append('/');\n    path.append(table);\n    path.append('/');\n    path.append(row);\n    path.append('/');\n    path.append(column);\n    return getValuePB(path.toString());\n  }","commit_id":"38641ec1966f7a17408cdb4103b5dff90bdc85cd","url":"https://github.com/apache/hbase"},{"original_method":"private static void setupOpenListener(HttpOpenListener listener, ModelControllerClient modelControllerClient, ConsoleMode consoleMode, String consoleSlot, ControlledProcessStateService controlledProcessStateService, int securePort, SecurityRealm securityRealm) {\n        CanonicalPathHandler canonicalPathHandler = new CanonicalPathHandler();\n        listener.setRootHandler(canonicalPathHandler);\n\n        PathHandler pathHandler = new PathHandler();\n        HttpHandler current = pathHandler;\n        if (securePort > 0) {\n            current = new SinglePortConfidentialityHandler(current, securePort);\n        }\n        canonicalPathHandler.setNext(current);\n\n        ResourceHandler consoleHandler = null;\n        try {\n            consoleHandler = consoleMode.createConsoleHandler(consoleSlot);\n        } catch (ModuleLoadException e) {\n            ROOT_LOGGER.consoleModuleNotFound(consoleSlot == null ? \"main\" : consoleSlot);\n        }\n\n        try {\n            pathHandler.addPath(ErrorContextHandler.ERROR_CONTEXT, new BlockingHandler(new ErrorContextHandler(consoleSlot)));\n        } catch (ModuleLoadException e) {\n            ROOT_LOGGER.error(consoleSlot == null ? \"main\" : consoleSlot);\n        }\n\n        ManagementRootConsoleRedirectHandler rootConsoleRedirectHandler = new ManagementRootConsoleRedirectHandler(consoleHandler);\n        DomainApiCheckHandler domainApiHandler = new DomainApiCheckHandler(modelControllerClient, controlledProcessStateService);\n        pathHandler.setDefaultHandler(rootConsoleRedirectHandler);\n        if (consoleHandler != null) {\n            pathHandler.addPath(consoleHandler.getContext(), new BlockingHandler(consoleHandler));\n        }\n        pathHandler.addPath(DomainApiCheckHandler.PATH, secureDomainAccess(domainApiHandler, securityRealm));\n\n    }","id":41295,"modified_method":"private static void setupOpenListener(HttpOpenListener listener, ModelControllerClient modelControllerClient, ConsoleMode consoleMode, String consoleSlot, ControlledProcessStateService controlledProcessStateService, int securePort, SecurityRealm securityRealm) {\n        CanonicalPathHandler canonicalPathHandler = new CanonicalPathHandler();\n        listener.setRootHandler(canonicalPathHandler);\n\n        PathHandler pathHandler = new PathHandler();\n        HttpHandler current = pathHandler;\n        if (securePort > 0) {\n            current = new SinglePortConfidentialityHandler(current, securePort);\n        }\n        canonicalPathHandler.setNext(current);\n\n        ResourceHandler consoleHandler = null;\n        try {\n            consoleHandler = consoleMode.createConsoleHandler(consoleSlot);\n        } catch (ModuleLoadException e) {\n            ROOT_LOGGER.consoleModuleNotFound(consoleSlot == null ? \"main\" : consoleSlot);\n        }\n\n        try {\n            pathHandler.addPath(ErrorContextHandler.ERROR_CONTEXT, new BlockingHandler(new ErrorContextHandler(consoleSlot)));\n        } catch (ModuleLoadException e) {\n            ROOT_LOGGER.error(consoleSlot == null ? \"main\" : consoleSlot);\n        }\n\n        ManagementRootConsoleRedirectHandler rootConsoleRedirectHandler = new ManagementRootConsoleRedirectHandler(consoleHandler);\n        DomainApiCheckHandler domainApiHandler = new DomainApiCheckHandler(modelControllerClient, controlledProcessStateService);\n        pathHandler.setDefaultHandler(rootConsoleRedirectHandler);\n        if (consoleHandler != null) {\n            HttpHandler readinessHandler = new RedirectReadinessHandler(securityRealm, new BlockingHandler(consoleHandler),\n                    ErrorContextHandler.ERROR_CONTEXT);\n            pathHandler.addPath(consoleHandler.getContext(), readinessHandler);\n        }\n\n        HttpHandler readinessHandler = new DmrFailureReadinessHandler(securityRealm, secureDomainAccess(domainApiHandler, securityRealm), ErrorContextHandler.ERROR_CONTEXT);\n        pathHandler.addPath(DomainApiCheckHandler.PATH, readinessHandler);\n    }","commit_id":"23324745c66f2e54aef61d6829d0eff831f04786","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Environment(Settings settings) {\n        this.settings = settings;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = PathUtils.get(cleanPath(settings.get(\"path.home\")));\n        } else {\n            throw new IllegalStateException(\"path.home is not configured\");\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = PathUtils.get(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = homeFile.resolve(\"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = PathUtils.get(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = homeFile.resolve(\"plugins\");\n        }\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new Path[dataPaths.length];\n            dataWithClusterFiles = new Path[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = PathUtils.get(dataPaths[i]);\n                dataWithClusterFiles[i] = dataFiles[i].resolve(ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new Path[]{homeFile.resolve(\"data\")};\n            dataWithClusterFiles = new Path[]{homeFile.resolve(\"data\").resolve(ClusterName.clusterNameFromSettings(settings).value())};\n        }\n        String[] repoPaths = settings.getAsArray(\"path.repo\");\n        if (repoPaths.length > 0) {\n            repoFiles = new Path[repoPaths.length];\n            for (int i = 0; i < repoPaths.length; i++) {\n                repoFiles[i] = PathUtils.get(repoPaths[i]);\n            }\n        } else {\n            repoFiles = new Path[0];\n        }\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = PathUtils.get(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = homeFile.resolve(\"logs\");\n        }\n\n        if (settings.get(\"pidfile\") != null) {\n            pidFile = PathUtils.get(cleanPath(settings.get(\"pidfile\")));\n        } else {\n            pidFile = null;\n        }\n    }","id":41296,"modified_method":"public Environment(Settings settings) {\n        this.settings = settings;\n        final Path homeFile;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = PathUtils.get(cleanPath(settings.get(\"path.home\")));\n        } else {\n            throw new IllegalStateException(\"path.home is not configured\");\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = PathUtils.get(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = homeFile.resolve(\"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = PathUtils.get(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = homeFile.resolve(\"plugins\");\n        }\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new Path[dataPaths.length];\n            dataWithClusterFiles = new Path[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = PathUtils.get(dataPaths[i]);\n                dataWithClusterFiles[i] = dataFiles[i].resolve(ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new Path[]{homeFile.resolve(\"data\")};\n            dataWithClusterFiles = new Path[]{homeFile.resolve(\"data\").resolve(ClusterName.clusterNameFromSettings(settings).value())};\n        }\n        String[] repoPaths = settings.getAsArray(\"path.repo\");\n        if (repoPaths.length > 0) {\n            repoFiles = new Path[repoPaths.length];\n            for (int i = 0; i < repoPaths.length; i++) {\n                repoFiles[i] = PathUtils.get(repoPaths[i]);\n            }\n        } else {\n            repoFiles = new Path[0];\n        }\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = PathUtils.get(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = homeFile.resolve(\"logs\");\n        }\n\n        if (settings.get(\"pidfile\") != null) {\n            pidFile = PathUtils.get(cleanPath(settings.get(\"pidfile\")));\n        } else {\n            pidFile = null;\n        }\n\n        binFile = homeFile.resolve(\"bin\");\n        libFile = homeFile.resolve(\"lib\");\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Node(Settings preparedSettings, boolean loadConfigSettings) {\n        final Settings pSettings = settingsBuilder().put(preparedSettings)\n                .put(Client.CLIENT_TYPE_SETTING, CLIENT_TYPE).build();\n        Tuple<Settings, Environment> tuple = InternalSettingsPreparer.prepareSettings(pSettings, loadConfigSettings);\n        tuple = new Tuple<>(TribeService.processSettings(tuple.v1()), tuple.v2());\n\n        // The only place we can actually fake the version a node is running on:\n        Version version = pSettings.getAsVersion(\"tests.mock.version\", Version.CURRENT);\n\n        ESLogger logger = Loggers.getLogger(Node.class, tuple.v1().get(\"name\"));\n        logger.info(\"version[{}], pid[{}], build[{}/{}]\", version, JvmInfo.jvmInfo().pid(), Build.CURRENT.hashShort(), Build.CURRENT.timestamp());\n\n        logger.info(\"initializing ...\");\n\n        if (logger.isDebugEnabled()) {\n            Environment env = tuple.v2();\n            logger.debug(\"using home [{}], config [{}], data [{}], logs [{}], plugins [{}]\",\n                    env.homeFile(), env.configFile(), Arrays.toString(env.dataFiles()), env.logsFile(), env.pluginsFile());\n        }\n\n        this.pluginsService = new PluginsService(tuple.v1(), tuple.v2());\n        this.settings = pluginsService.updatedSettings();\n        // create the environment based on the finalized (processed) view of the settings\n        this.environment = new Environment(this.settings());\n\n        final NodeEnvironment nodeEnvironment;\n        try {\n            nodeEnvironment = new NodeEnvironment(this.settings, this.environment);\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"Failed to created node environment\", ex);\n        }\n\n        final ThreadPool threadPool = new ThreadPool(settings);\n\n        boolean success = false;\n        try {\n            ModulesBuilder modules = new ModulesBuilder();\n            modules.add(new Version.Module(version));\n            modules.add(new PageCacheRecyclerModule(settings));\n            modules.add(new CircuitBreakerModule(settings));\n            modules.add(new BigArraysModule(settings));\n            modules.add(new PluginsModule(settings, pluginsService));\n            modules.add(new SettingsModule(settings));\n            modules.add(new NodeModule(this));\n            modules.add(new NetworkModule());\n            modules.add(new ScriptModule(settings));\n            modules.add(new EnvironmentModule(environment));\n            modules.add(new NodeEnvironmentModule(nodeEnvironment));\n            modules.add(new ClusterNameModule(settings));\n            modules.add(new ThreadPoolModule(threadPool));\n            modules.add(new DiscoveryModule(settings));\n            modules.add(new ClusterModule(settings));\n            modules.add(new RestModule(settings));\n            modules.add(new TransportModule(settings));\n            if (settings.getAsBoolean(HTTP_ENABLED, true)) {\n                modules.add(new HttpServerModule(settings));\n            }\n            modules.add(new IndicesModule(settings));\n            modules.add(new SearchModule(settings));\n            modules.add(new ActionModule(false));\n            modules.add(new MonitorModule(settings));\n            modules.add(new GatewayModule());\n            modules.add(new NodeClientModule());\n            modules.add(new ShapeModule());\n            modules.add(new PercolatorModule());\n            modules.add(new ResourceWatcherModule());\n            modules.add(new RepositoriesModule());\n            modules.add(new TribeModule());\n\n            injector = modules.createInjector();\n\n            client = injector.getInstance(Client.class);\n            threadPool.setNodeSettingsService(injector.getInstance(NodeSettingsService.class));\n            success = true;\n        } finally {\n            if (!success) {\n                nodeEnvironment.close();\n                ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS);\n            }\n        }\n\n        logger.info(\"initialized\");\n    }","id":41297,"modified_method":"public Node(Settings preparedSettings, boolean loadConfigSettings) {\n        final Settings pSettings = settingsBuilder().put(preparedSettings)\n                .put(Client.CLIENT_TYPE_SETTING, CLIENT_TYPE).build();\n        Tuple<Settings, Environment> tuple = InternalSettingsPreparer.prepareSettings(pSettings, loadConfigSettings);\n        tuple = new Tuple<>(TribeService.processSettings(tuple.v1()), tuple.v2());\n\n        // The only place we can actually fake the version a node is running on:\n        Version version = pSettings.getAsVersion(\"tests.mock.version\", Version.CURRENT);\n\n        ESLogger logger = Loggers.getLogger(Node.class, tuple.v1().get(\"name\"));\n        logger.info(\"version[{}], pid[{}], build[{}/{}]\", version, JvmInfo.jvmInfo().pid(), Build.CURRENT.hashShort(), Build.CURRENT.timestamp());\n\n        logger.info(\"initializing ...\");\n\n        if (logger.isDebugEnabled()) {\n            Environment env = tuple.v2();\n            logger.debug(\"using config [{}], data [{}], logs [{}], plugins [{}]\",\n                    env.configFile(), Arrays.toString(env.dataFiles()), env.logsFile(), env.pluginsFile());\n        }\n\n        this.pluginsService = new PluginsService(tuple.v1(), tuple.v2());\n        this.settings = pluginsService.updatedSettings();\n        // create the environment based on the finalized (processed) view of the settings\n        this.environment = new Environment(this.settings());\n\n        final NodeEnvironment nodeEnvironment;\n        try {\n            nodeEnvironment = new NodeEnvironment(this.settings, this.environment);\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"Failed to created node environment\", ex);\n        }\n\n        final ThreadPool threadPool = new ThreadPool(settings);\n\n        boolean success = false;\n        try {\n            ModulesBuilder modules = new ModulesBuilder();\n            modules.add(new Version.Module(version));\n            modules.add(new PageCacheRecyclerModule(settings));\n            modules.add(new CircuitBreakerModule(settings));\n            modules.add(new BigArraysModule(settings));\n            modules.add(new PluginsModule(settings, pluginsService));\n            modules.add(new SettingsModule(settings));\n            modules.add(new NodeModule(this));\n            modules.add(new NetworkModule());\n            modules.add(new ScriptModule(settings));\n            modules.add(new EnvironmentModule(environment));\n            modules.add(new NodeEnvironmentModule(nodeEnvironment));\n            modules.add(new ClusterNameModule(settings));\n            modules.add(new ThreadPoolModule(threadPool));\n            modules.add(new DiscoveryModule(settings));\n            modules.add(new ClusterModule(settings));\n            modules.add(new RestModule(settings));\n            modules.add(new TransportModule(settings));\n            if (settings.getAsBoolean(HTTP_ENABLED, true)) {\n                modules.add(new HttpServerModule(settings));\n            }\n            modules.add(new IndicesModule(settings));\n            modules.add(new SearchModule(settings));\n            modules.add(new ActionModule(false));\n            modules.add(new MonitorModule(settings));\n            modules.add(new GatewayModule());\n            modules.add(new NodeClientModule());\n            modules.add(new ShapeModule());\n            modules.add(new PercolatorModule());\n            modules.add(new ResourceWatcherModule());\n            modules.add(new RepositoriesModule());\n            modules.add(new TribeModule());\n\n            injector = modules.createInjector();\n\n            client = injector.getInstance(Client.class);\n            threadPool.setNodeSettingsService(injector.getInstance(NodeSettingsService.class));\n            success = true;\n        } finally {\n            if (!success) {\n                nodeEnvironment.close();\n                ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS);\n            }\n        }\n\n        logger.info(\"initialized\");\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"Path binDir(Environment env) {\n            return env.homeFile().resolve(\"bin\").resolve(name);\n        }","id":41298,"modified_method":"Path binDir(Environment env) {\n            return env.binFile().resolve(name);\n        }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLocalPluginInstallWithBinOnly_7152() throws Exception {\n        String pluginName = \"plugin-test\";\n        Tuple<Settings, Environment> initialSettings = buildInitialSettings();\n        Environment env = initialSettings.v2();\n        Path binDir = env.homeFile().resolve(\"bin\");\n        if (!Files.exists(binDir)) {\n            Files.createDirectories(binDir);\n        }\n        Path pluginBinDir = binDir.resolve(pluginName);\n        try {\n            PluginManager pluginManager = pluginManager(getPluginUrlForResource(\"plugin_with_bin_only.zip\"), initialSettings);\n            pluginManager.downloadAndExtract(pluginName);\n            Path[] plugins = pluginManager.getListInstalledPlugins();\n            assertThat(plugins.length, is(1));\n            assertDirectoryExists(pluginBinDir);\n        } finally {\n            // we need to clean up the copied dirs\n            IOUtils.rm(pluginBinDir);\n        }\n    }","id":41299,"modified_method":"@Test\n    public void testLocalPluginInstallWithBinOnly_7152() throws Exception {\n        String pluginName = \"plugin-test\";\n        Tuple<Settings, Environment> initialSettings = buildInitialSettings();\n        Environment env = initialSettings.v2();\n        Path binDir = env.binFile();\n        if (!Files.exists(binDir)) {\n            Files.createDirectories(binDir);\n        }\n        Path pluginBinDir = binDir.resolve(pluginName);\n        try {\n            PluginManager pluginManager = pluginManager(getPluginUrlForResource(\"plugin_with_bin_only.zip\"), initialSettings);\n            pluginManager.downloadAndExtract(pluginName);\n            Path[] plugins = pluginManager.getListInstalledPlugins();\n            assertThat(plugins.length, is(1));\n            assertDirectoryExists(pluginBinDir);\n        } finally {\n            // we need to clean up the copied dirs\n            IOUtils.rm(pluginBinDir);\n        }\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLocalPluginInstallWithBinAndConfig() throws Exception {\n        String pluginName = \"plugin-test\";\n        Tuple<Settings, Environment> initialSettings = buildInitialSettings();\n        Environment env = initialSettings.v2();\n        Path binDir = env.homeFile().resolve(\"bin\");\n        if (!Files.exists(binDir)) {\n            Files.createDirectories(binDir);\n        }\n        Path pluginBinDir = binDir.resolve(pluginName);\n        Path configDir = env.configFile();\n        if (!Files.exists(configDir)) {\n            Files.createDirectories(configDir);\n        }\n        Path pluginConfigDir =configDir.resolve(pluginName);\n        try {\n\n            PluginManager pluginManager = pluginManager(getPluginUrlForResource(\"plugin_with_bin_and_config.zip\"), initialSettings);\n\n            pluginManager.downloadAndExtract(pluginName);\n\n            Path[] plugins = pluginManager.getListInstalledPlugins();\n\n            assertThat(plugins, arrayWithSize(1));\n            assertDirectoryExists(pluginBinDir);\n            assertDirectoryExists(pluginConfigDir);\n            Path toolFile = pluginBinDir.resolve(\"tool\");\n            assertFileExists(toolFile);\n\n            // check that the file is marked executable, without actually checking that we can execute it.\n            PosixFileAttributeView view = Files.getFileAttributeView(toolFile, PosixFileAttributeView.class);\n            // the view might be null, on e.g. windows, there is nothing to check there!\n            if (view != null) {\n                PosixFileAttributes attributes = view.readAttributes();\n                assertTrue(\"unexpected permissions: \" + attributes.permissions(),\n                           attributes.permissions().contains(PosixFilePermission.OWNER_EXECUTE));\n                assertTrue(\"unexpected permissions: \" + attributes.permissions(),\n                        attributes.permissions().contains(PosixFilePermission.OWNER_READ));\n            }\n        } finally {\n            // we need to clean up the copied dirs\n            IOUtils.rm(pluginBinDir, pluginConfigDir);\n        }\n    }","id":41300,"modified_method":"@Test\n    public void testLocalPluginInstallWithBinAndConfig() throws Exception {\n        String pluginName = \"plugin-test\";\n        Tuple<Settings, Environment> initialSettings = buildInitialSettings();\n        Environment env = initialSettings.v2();\n        Path binDir = env.binFile();\n        if (!Files.exists(binDir)) {\n            Files.createDirectories(binDir);\n        }\n        Path pluginBinDir = binDir.resolve(pluginName);\n        Path configDir = env.configFile();\n        if (!Files.exists(configDir)) {\n            Files.createDirectories(configDir);\n        }\n        Path pluginConfigDir =configDir.resolve(pluginName);\n        try {\n\n            PluginManager pluginManager = pluginManager(getPluginUrlForResource(\"plugin_with_bin_and_config.zip\"), initialSettings);\n\n            pluginManager.downloadAndExtract(pluginName);\n\n            Path[] plugins = pluginManager.getListInstalledPlugins();\n\n            assertThat(plugins, arrayWithSize(1));\n            assertDirectoryExists(pluginBinDir);\n            assertDirectoryExists(pluginConfigDir);\n            Path toolFile = pluginBinDir.resolve(\"tool\");\n            assertFileExists(toolFile);\n\n            // check that the file is marked executable, without actually checking that we can execute it.\n            PosixFileAttributeView view = Files.getFileAttributeView(toolFile, PosixFileAttributeView.class);\n            // the view might be null, on e.g. windows, there is nothing to check there!\n            if (view != null) {\n                PosixFileAttributes attributes = view.readAttributes();\n                assertTrue(\"unexpected permissions: \" + attributes.permissions(),\n                           attributes.permissions().contains(PosixFilePermission.OWNER_EXECUTE));\n                assertTrue(\"unexpected permissions: \" + attributes.permissions(),\n                        attributes.permissions().contains(PosixFilePermission.OWNER_READ));\n            }\n        } finally {\n            // we need to clean up the copied dirs\n            IOUtils.rm(pluginBinDir, pluginConfigDir);\n        }\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** returns dynamic Permissions to configured paths */\n    static Permissions createPermissions(Environment environment) throws IOException {\n        // TODO: improve test infra so we can reduce permissions where read/write\n        // is not really needed...\n        Permissions policy = new Permissions();\n        addPath(policy, environment.tmpFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.homeFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.configFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.logsFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.pluginsFile(), \"read,readlink,write,delete\");\n        for (Path path : environment.dataFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        for (Path path : environment.dataWithClusterFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        for (Path path : environment.repoFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        if (environment.pidFile() != null) {\n            addPath(policy, environment.pidFile().getParent(), \"read,readlink,write,delete\");\n        }\n        return policy;\n    }","id":41301,"modified_method":"/** returns dynamic Permissions to configured paths */\n    static Permissions createPermissions(Environment environment) throws IOException {\n        Permissions policy = new Permissions();\n        // read-only dirs\n        addPath(policy, environment.binFile(), \"read,readlink\");\n        addPath(policy, environment.libFile(), \"read,readlink\");\n        addPath(policy, environment.tmpFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.configFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.logsFile(), \"read,readlink,write,delete\");\n        addPath(policy, environment.pluginsFile(), \"read,readlink,write,delete\");\n        for (Path path : environment.dataFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        for (Path path : environment.dataWithClusterFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        for (Path path : environment.repoFiles()) {\n            addPath(policy, path, \"read,readlink,write,delete\");\n        }\n        if (environment.pidFile() != null) {\n            addPath(policy, environment.pidFile().getParent(), \"read,readlink,write,delete\");\n        }\n        return policy;\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** test generated permissions */\n    public void testGeneratedPermissions() throws Exception {\n        Path path = createTempDir();\n        // make a fake ES home and ensure we only grant permissions to that.\n        Path esHome = path.resolve(\"esHome\");\n        Settings.Builder settingsBuilder = Settings.builder();\n        settingsBuilder.put(\"path.home\", esHome.toString());\n        Settings settings = settingsBuilder.build();\n\n        Path fakeTmpDir = createTempDir();\n        String realTmpDir = System.getProperty(\"java.io.tmpdir\");\n        Permissions permissions;\n        try {\n            System.setProperty(\"java.io.tmpdir\", fakeTmpDir.toString());\n            Environment environment = new Environment(settings);\n            permissions = Security.createPermissions(environment);\n        } finally {\n            System.setProperty(\"java.io.tmpdir\", realTmpDir);\n        }\n      \n        // the fake es home\n        assertTrue(permissions.implies(new FilePermission(esHome.toString(), \"read\")));\n        // its parent\n        assertFalse(permissions.implies(new FilePermission(path.toString(), \"read\")));\n        // some other sibling\n        assertFalse(permissions.implies(new FilePermission(path.resolve(\"other\").toString(), \"read\")));\n        // double check we overwrote java.io.tmpdir correctly for the test\n        assertFalse(permissions.implies(new FilePermission(realTmpDir.toString(), \"read\")));\n    }","id":41302,"modified_method":"/** test generated permissions */\n    public void testGeneratedPermissions() throws Exception {\n        Path path = createTempDir();\n        // make a fake ES home and ensure we only grant permissions to that.\n        Path esHome = path.resolve(\"esHome\");\n        Settings.Builder settingsBuilder = Settings.builder();\n        settingsBuilder.put(\"path.home\", esHome.toString());\n        Settings settings = settingsBuilder.build();\n\n        Path fakeTmpDir = createTempDir();\n        String realTmpDir = System.getProperty(\"java.io.tmpdir\");\n        Permissions permissions;\n        try {\n            System.setProperty(\"java.io.tmpdir\", fakeTmpDir.toString());\n            Environment environment = new Environment(settings);\n            permissions = Security.createPermissions(environment);\n        } finally {\n            System.setProperty(\"java.io.tmpdir\", realTmpDir);\n        }\n      \n        // the fake es home\n        assertFalse(permissions.implies(new FilePermission(esHome.toString(), \"read\")));\n        // its parent\n        assertFalse(permissions.implies(new FilePermission(path.toString(), \"read\")));\n        // some other sibling\n        assertFalse(permissions.implies(new FilePermission(path.resolve(\"other\").toString(), \"read\")));\n        // double check we overwrote java.io.tmpdir correctly for the test\n        assertFalse(permissions.implies(new FilePermission(realTmpDir.toString(), \"read\")));\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** test generated permissions for all configured paths */\n    public void testEnvironmentPaths() throws Exception {\n        Path path = createTempDir();\n\n        Settings.Builder settingsBuilder = Settings.builder();\n        settingsBuilder.put(\"path.home\", path.resolve(\"home\").toString());\n        settingsBuilder.put(\"path.conf\", path.resolve(\"conf\").toString());\n        settingsBuilder.put(\"path.plugins\", path.resolve(\"plugins\").toString());\n        settingsBuilder.putArray(\"path.data\", path.resolve(\"data1\").toString(), path.resolve(\"data2\").toString());\n        settingsBuilder.put(\"path.logs\", path.resolve(\"logs\").toString());\n        settingsBuilder.put(\"pidfile\", path.resolve(\"test.pid\").toString());\n        Settings settings = settingsBuilder.build();\n\n        Path fakeTmpDir = createTempDir();\n        String realTmpDir = System.getProperty(\"java.io.tmpdir\");\n        Permissions permissions;\n        Environment environment;\n        try {\n            System.setProperty(\"java.io.tmpdir\", fakeTmpDir.toString());\n            environment = new Environment(settings);\n            permissions = Security.createPermissions(environment);\n        } finally {\n            System.setProperty(\"java.io.tmpdir\", realTmpDir);\n        }\n\n        // check that all directories got permissions:\n        // homefile: this is needed unless we break out rules for \"lib\" dir.\n        // TODO: make read-only\n        assertTrue(permissions.implies(new FilePermission(environment.homeFile().toString(), \"read,readlink,write,delete\")));\n        // config file\n        // TODO: make read-only\n        assertTrue(permissions.implies(new FilePermission(environment.configFile().toString(), \"read,readlink,write,delete\")));\n        // plugins: r/w, TODO: can this be minimized?\n        assertTrue(permissions.implies(new FilePermission(environment.pluginsFile().toString(), \"read,readlink,write,delete\")));\n        // data paths: r/w\n        for (Path dataPath : environment.dataFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        for (Path dataPath : environment.dataWithClusterFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        // logs: r/w\n        assertTrue(permissions.implies(new FilePermission(environment.logsFile().toString(), \"read,readlink,write,delete\")));\n        // temp dir: r/w\n        assertTrue(permissions.implies(new FilePermission(fakeTmpDir.toString(), \"read,readlink,write,delete\")));\n        // double check we overwrote java.io.tmpdir correctly for the test\n        assertFalse(permissions.implies(new FilePermission(realTmpDir.toString(), \"read\")));\n        // PID file: r/w\n        assertTrue(permissions.implies(new FilePermission(environment.pidFile().toString(), \"read,readlink,write,delete\")));\n    }","id":41303,"modified_method":"/** test generated permissions for all configured paths */\n    public void testEnvironmentPaths() throws Exception {\n        Path path = createTempDir();\n\n        Settings.Builder settingsBuilder = Settings.builder();\n        settingsBuilder.put(\"path.home\", path.resolve(\"home\").toString());\n        settingsBuilder.put(\"path.conf\", path.resolve(\"conf\").toString());\n        settingsBuilder.put(\"path.plugins\", path.resolve(\"plugins\").toString());\n        settingsBuilder.putArray(\"path.data\", path.resolve(\"data1\").toString(), path.resolve(\"data2\").toString());\n        settingsBuilder.put(\"path.logs\", path.resolve(\"logs\").toString());\n        settingsBuilder.put(\"pidfile\", path.resolve(\"test.pid\").toString());\n        Settings settings = settingsBuilder.build();\n\n        Path fakeTmpDir = createTempDir();\n        String realTmpDir = System.getProperty(\"java.io.tmpdir\");\n        Permissions permissions;\n        Environment environment;\n        try {\n            System.setProperty(\"java.io.tmpdir\", fakeTmpDir.toString());\n            environment = new Environment(settings);\n            permissions = Security.createPermissions(environment);\n        } finally {\n            System.setProperty(\"java.io.tmpdir\", realTmpDir);\n        }\n\n        // check that all directories got permissions:\n        assertTrue(permissions.implies(new FilePermission(environment.binFile().toString(), \"read\")));\n        assertTrue(permissions.implies(new FilePermission(environment.libFile().toString(), \"read\")));\n        // config file\n        // TODO: make read-only\n        assertTrue(permissions.implies(new FilePermission(environment.configFile().toString(), \"read,readlink,write,delete\")));\n        // plugins: r/w, TODO: can this be minimized?\n        assertTrue(permissions.implies(new FilePermission(environment.pluginsFile().toString(), \"read,readlink,write,delete\")));\n        // data paths: r/w\n        for (Path dataPath : environment.dataFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        for (Path dataPath : environment.dataWithClusterFiles()) {\n            assertTrue(permissions.implies(new FilePermission(dataPath.toString(), \"read,readlink,write,delete\")));\n        }\n        // logs: r/w\n        assertTrue(permissions.implies(new FilePermission(environment.logsFile().toString(), \"read,readlink,write,delete\")));\n        // temp dir: r/w\n        assertTrue(permissions.implies(new FilePermission(fakeTmpDir.toString(), \"read,readlink,write,delete\")));\n        // double check we overwrote java.io.tmpdir correctly for the test\n        assertFalse(permissions.implies(new FilePermission(realTmpDir.toString(), \"read\")));\n        // PID file: r/w\n        assertTrue(permissions.implies(new FilePermission(environment.pidFile().toString(), \"read,readlink,write,delete\")));\n    }","commit_id":"052cf1446f9caea16454e0db5860e8e694c61119","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void setUp() throws Exception {\n        c = new Config();\n        c.addPath(TEST_CONF_LOCATION + \"/default\");\n        c.addPath(TEST_CONF_LOCATION);\n        c.parseFiles();\n    }","id":41304,"modified_method":"public void setUp() throws Exception {\n        c = new Config();\n\n        // create test config path\n        String confPath = \"/tmp/\" + TestUtils.randomString() + \"/conf\";\n        String defaultPath = confPath + \"/default\";\n        new File(defaultPath).mkdirs();\n\n        // copy test configuration files over\n        FileUtils.copyURLToFile(TestUtils.findTestData(\"conf/rhn.conf\"), new File(confPath,\n                \"rhn.conf\"));\n        FileUtils.copyURLToFile(TestUtils.findTestData(\"conf/default/rhn_web.conf\"),\n                new File(defaultPath, \"rhn_web.conf\"));\n        FileUtils.copyURLToFile(TestUtils.findTestData(\"conf/default/rhn_prefix.conf\"),\n                new File(defaultPath, \"rhn_prefix.conf\"));\n        FileUtils.copyURLToFile(TestUtils\n                .findTestData(\"conf/default/bug154517.conf.rpmsave\"),\n                new File(defaultPath, \"bug154517.conf.rpmsave\"));\n\n        c.addPath(confPath);\n        c.addPath(defaultPath);\n        c.parseFiles();\n    }","commit_id":"dd0b273d4c5863dd42e83499294468be849f4463","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);\n        for (ProcessorType processorType : getOutputs()) {\n            // The outputs should be the SendProcessor\n            SendProcessor processor = (SendProcessor) processorType.createProcessor(routeContext);\n            loadBalancer.addProcessor(processor);\n        }\n\n        return loadBalancer;\n    }","id":41305,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);\n        for (ProcessorType processorType : getOutputs()) {\n            // The outputs should be the SendProcessor\n            Processor processor = processorType.createProcessor(routeContext);\n            processor = processorType.wrapProcessorInInterceptors(routeContext, processor);\n            loadBalancer.addProcessor((SendProcessor)processor);\n        }\n\n        return loadBalancer;\n    }","commit_id":"02a9e3507b7c7afd2dc8e90153a1dc1721022617","url":"https://github.com/apache/camel"},{"original_method":"public AOPProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {\n        super(tryProcessor, catchClauses, finallyProcessor);\n    }","id":41306,"modified_method":"public AOPProcessor(Processor tryProcessor, List<Processor> catchClauses, Processor finallyProcessor) {\n        super(tryProcessor, catchClauses, finallyProcessor);\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Whether this catch processor handles the exception it have caught\n     *\n     * @param exchange  the current exchange\n     * @return <tt>true<\/tt> if this processor handles it, <tt>false<\/tt> otherwise.\n     */\n    public boolean handles(Exchange exchange) {\n        if (handled == null) {\n            // handle by default\n            return true;\n        }\n\n        return handled.matches(exchange);\n    }","id":41307,"modified_method":"/**\n     * Whether this catch processor handles the exception it have caught\n     *\n     * @param exchange  the current exchange\n     * @return <tt>true<\/tt> if this processor handles it, <tt>false<\/tt> otherwise.\n     */\n    protected boolean handles(Exchange exchange) {\n        if (handled == null) {\n            // handle by default\n            return true;\n        }\n\n        return handled.matches(exchange);\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Returns with the exception that is caught by this processor.\n     * \n     * This method traverses exception causes, so sometimes the exception\n     * returned from this method might be one of causes of the parameter\n     * passed.\n     *\n     * @param exchange  the current exchange\n     * @param exception the thrown exception\n     * @return Throwable that this processor catches. <tt>null<\/tt> if nothing matches.\n     */\n    public Throwable catches(Exchange exchange, Throwable exception) {\n        // use the exception iterator to walk the caused by hierarchy\n        Iterator<Throwable> it = ObjectHelper.createExceptionIterator(exception);\n        while (it.hasNext()) {\n            Throwable e = it.next();\n            // see if we catch this type\n            for (Class<?> type : exceptions) {\n                if (type.isInstance(e) && matchesWhen(exchange)) {\n                    return e;\n                }\n            }\n        }\n\n        // not found\n        return null;\n    }","id":41308,"modified_method":"/**\n     * Returns with the exception that is caught by this processor.\n     *\n     * This method traverses exception causes, so sometimes the exception\n     * returned from this method might be one of causes of the parameter\n     * passed.\n     *\n     * @param exchange  the current exchange\n     * @param exception the thrown exception\n     * @return Throwable that this processor catches. <tt>null<\/tt> if nothing matches.\n     */\n    protected Throwable catches(Exchange exchange, Throwable exception) {\n        // use the exception iterator to walk the caused by hierarchy\n        Iterator<Throwable> it = ObjectHelper.createExceptionIterator(exception);\n        while (it.hasNext()) {\n            Throwable e = it.next();\n            // see if we catch this type\n            for (Class<?> type : exceptions) {\n                if (type.isInstance(e) && matchesWhen(exchange)) {\n                    return e;\n                }\n            }\n        }\n\n        // not found\n        return null;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        // parent must be a try\n        if (!(getParent() instanceof TryDefinition)) {\n            throw new IllegalArgumentException(\"This doFinally should have a doTry as its parent on \" + this);\n        }\n\n        // do finally does mandate a child processor\n        return this.createChildProcessor(routeContext, true);\n    }","id":41309,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        // parent must be a try\n        if (!(getParent() instanceof TryDefinition)) {\n            throw new IllegalArgumentException(\"This doFinally should have a doTry as its parent on \" + this);\n        }\n\n        // do finally does mandate a child processor\n        return new FinallyProcessor(this.createChildProcessor(routeContext, false));\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        Processor tryProcessor = createOutputsProcessor(routeContext, getOutputsWithoutCatches());\n        if (tryProcessor == null) {\n            throw new IllegalArgumentException(\"Definition has no children on \" + this);\n        }\n\n        Processor finallyProcessor = null;\n        if (finallyClause != null) {\n            finallyProcessor = createProcessor(routeContext, finallyClause);\n        }\n\n        List<CatchProcessor> catchProcessors = new ArrayList<CatchProcessor>();\n        if (catchClauses != null) {\n            for (CatchDefinition catchClause : catchClauses) {\n                catchProcessors.add(catchClause.createProcessor(routeContext));\n            }\n        }\n\n        // must have either a catch or finally\n        if (finallyClause == null && catchClauses == null) {\n            throw new IllegalArgumentException(\"doTry must have one or more catch or finally blocks on \" + this);\n        }\n\n        return new TryProcessor(tryProcessor, catchProcessors, finallyProcessor);\n    }","id":41310,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        Processor tryProcessor = createOutputsProcessor(routeContext, getOutputsWithoutCatches());\n        if (tryProcessor == null) {\n            throw new IllegalArgumentException(\"Definition has no children on \" + this);\n        }\n\n        List<Processor> catchProcessors = new ArrayList<Processor>();\n        if (catchClauses != null) {\n            for (CatchDefinition catchClause : catchClauses) {\n                catchProcessors.add(createProcessor(routeContext, catchClause));\n            }\n        }\n\n        FinallyDefinition finallyDefinition = finallyClause;\n        if (finallyDefinition == null) {\n            finallyDefinition = new FinallyDefinition();\n            finallyDefinition.setParent(this);\n        }\n        Processor finallyProcessor = createProcessor(routeContext, finallyDefinition);\n\n        // must have either a catch or finally\n        if (finallyClause == null && catchClauses == null) {\n            throw new IllegalArgumentException(\"doTry must have one or more catch or finally blocks on \" + this);\n        }\n\n        return new TryProcessor(tryProcessor, catchProcessors, finallyProcessor);\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public boolean hasNext() {\n        return tryProcessor != null;\n    }","id":41311,"modified_method":"public boolean hasNext() {\n        return tryProcessor != null || catchClauses != null && !catchClauses.isEmpty() || finallyProcessor != null;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"protected boolean continueRouting(Iterator<AsyncProcessor> it, Exchange exchange) {\n        Object stop = exchange.getProperty(Exchange.ROUTE_STOP);\n        if (stop != null) {\n            boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);\n            if (doStop) {\n                LOG.debug(\"Exchange is marked to stop routing: {}\", exchange);\n                return false;\n            }\n        }\n\n        // continue if there are more processors to route\n        return it.hasNext();\n    }","id":41312,"modified_method":"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n        Object stop = exchange.getProperty(Exchange.ROUTE_STOP);\n        if (stop != null) {\n            boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);\n            if (doStop) {\n                LOG.debug(\"Exchange is marked to stop routing: {}\", exchange);\n                return false;\n            }\n        }\n\n        // continue if there are more processors to route\n        return it.hasNext();\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"protected boolean process(final Exchange exchange, final AsyncCallback callback,\n                              final AsyncProcessor processor, final Iterator<AsyncProcessor> processors) {\n        // this does the actual processing so log at trace level\n        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n\n        // implement asynchronous routing logic in callback so we can have the callback being\n        // triggered and then continue routing where we left\n        boolean sync = AsyncProcessorHelper.process(processor, exchange, new AsyncCallback() {\n            public void done(boolean doneSync) {\n                // we only have to handle async completion of the pipeline\n                if (doneSync) {\n                    return;\n                }\n\n                // continue processing the try .. catch .. finally asynchronously\n                while (continueRouting(processors, exchange)) {\n                    ExchangeHelper.prepareOutToIn(exchange);\n\n                    // process the next processor\n                    AsyncProcessor processor = processors.next();\n                    doneSync = process(exchange, callback, processor, processors);\n\n                    if (!doneSync) {\n                        LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        // the remainder of the try .. catch .. finally will be completed async\n                        // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                        return;\n                    }\n                }\n\n                ExchangeHelper.prepareOutToIn(exchange);\n                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                callback.done(false);\n            }\n        });\n\n        return sync;\n    }","id":41313,"modified_method":"protected boolean process(final Exchange exchange, final AsyncCallback callback,\n                              final Iterator<Processor> processors, final AsyncProcessor processor,\n                              final Object lastHandled) {\n        // this does the actual processing so log at trace level\n        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n\n        // implement asynchronous routing logic in callback so we can have the callback being\n        // triggered and then continue routing where we left\n        boolean sync = AsyncProcessorHelper.process(processor, exchange, new AsyncCallback() {\n            public void done(boolean doneSync) {\n                // we only have to handle async completion of the pipeline\n                if (doneSync) {\n                    return;\n                }\n\n                // continue processing the try .. catch .. finally asynchronously\n                while (continueRouting(processors, exchange)) {\n                    ExchangeHelper.prepareOutToIn(exchange);\n\n                    // process the next processor\n                    AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                    doneSync = process(exchange, callback, processors, processor, lastHandled);\n\n                    if (!doneSync) {\n                        LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        // the remainder of the try .. catch .. finally will be completed async\n                        // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                        return;\n                    }\n                }\n\n                ExchangeHelper.prepareOutToIn(exchange);\n                exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                callback.done(false);\n            }\n        });\n\n        return sync;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public TryProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {\n        this.tryProcessor = AsyncProcessorConverterHelper.convert(tryProcessor);\n        this.catchProcessor = new DoCatchProcessor(catchClauses);\n        this.finallyProcessor = new DoFinallyProcessor(finallyProcessor);\n    }","id":41314,"modified_method":"public TryProcessor(Processor tryProcessor, List<Processor> catchClauses, Processor finallyProcessor) {\n        this.tryProcessor = tryProcessor;\n        this.catchClauses = catchClauses;\n        this.finallyProcessor = finallyProcessor;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"protected void doStop() throws Exception {\n        ServiceHelper.stopServices(finallyProcessor, catchProcessor, tryProcessor);\n        processors.clear();\n    }","id":41315,"modified_method":"protected void doStop() throws Exception {\n        ServiceHelper.stopServices(tryProcessor, catchClauses, finallyProcessor);\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        Iterator<AsyncProcessor> processors = getProcessors().iterator();\n\n        while (continueRouting(processors, exchange)) {\n            ExchangeHelper.prepareOutToIn(exchange);\n\n            // process the next processor\n            AsyncProcessor processor = processors.next();\n            boolean sync = process(exchange, callback, processor, processors);\n\n            // continue as long its being processed synchronously\n            if (!sync) {\n                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                // the remainder of the try .. catch .. finally will be completed async\n                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                return false;\n            }\n\n            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        }\n\n        ExchangeHelper.prepareOutToIn(exchange);\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n        callback.done(true);\n        return true;\n    }","id":41316,"modified_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        Iterator<Processor> processors = next().iterator();\n\n        Object lastHandled = exchange.getProperty(Exchange.EXCEPTION_HANDLED);\n        exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);\n\n        while (continueRouting(processors, exchange)) {\n            ExchangeHelper.prepareOutToIn(exchange);\n\n            // process the next processor\n            Processor processor = processors.next();\n            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n            boolean sync = process(exchange, callback, processors, async, lastHandled);\n\n            // continue as long its being processed synchronously\n            if (!sync) {\n                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                // the remainder of the try .. catch .. finally will be completed async\n                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                return false;\n            }\n\n            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        }\n\n        ExchangeHelper.prepareOutToIn(exchange);\n        exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n        callback.done(true);\n        return true;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"protected void doStart() throws Exception {\n        processors = new ArrayList<AsyncProcessor>();\n        processors.add(tryProcessor);\n        processors.add(catchProcessor);\n        processors.add(finallyProcessor);\n        ServiceHelper.startServices(tryProcessor, catchProcessor, finallyProcessor);\n    }","id":41317,"modified_method":"protected void doStart() throws Exception {\n        ServiceHelper.startServices(tryProcessor, catchClauses, finallyProcessor);\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public String toString() {\n        String finallyText = (finallyProcessor == null) ? \"\" : \" Finally {\" + finallyProcessor + \"}\";\n        return \"Try {\" + tryProcessor + \"} \" + (catchProcessor != null ? catchProcessor : \"\") + finallyText;\n    }","id":41318,"modified_method":"public String toString() {\n        String catchText = catchClauses == null || catchClauses.isEmpty() ? \"\": \" Catches {\" + catchClauses + \"}\";\n        String finallyText = (finallyProcessor == null) ? \"\" : \" Finally {\" + finallyProcessor + \"}\";\n        return \"Try {\" + tryProcessor + \"}\" + catchText + finallyText;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public List<Processor> next() {\n        if (!hasNext()) {\n            return null;\n        }\n        List<Processor> answer = new ArrayList<Processor>();\n        if (tryProcessor != null) {\n            answer.add(tryProcessor);\n        }\n        if (catchProcessor != null) {\n            answer.add(catchProcessor);\n        }\n        if (finallyProcessor != null) {\n            answer.add(finallyProcessor);\n        }\n        return answer;\n    }","id":41319,"modified_method":"public List<Processor> next() {\n        if (!hasNext()) {\n            return null;\n        }\n        List<Processor> answer = new ArrayList<Processor>();\n        if (tryProcessor != null) {\n            answer.add(tryProcessor);\n        }\n        if (catchClauses != null) {\n            answer.addAll(catchClauses);\n        }\n        if (finallyProcessor != null) {\n            answer.add(finallyProcessor);\n        }\n        return answer;\n    }","commit_id":"66939043e3acc33f522440166c819cd62cf98c9b","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        int redeliveryCounter = 0;\n        long redeliveryDelay = 0;\n\n        do {\n            if (redeliveryCounter > 0) {\n                // Figure out how long we should wait to resend this message.\n                redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);\n                sleep(redeliveryDelay);\n            }\n\n            try {\n                output.process(exchange);\n                return;\n            } catch (Throwable e) {\n                if (customProcessorForException(exchange, e)) {\n                    return;\n                }\n                logger.log(\"On delivery attempt: \" + redeliveryCounter + \" caught: \" + e, e);\n            }\n            redeliveryCounter = incrementRedeliveryCounter(exchange);\n        } while (redeliveryPolicy.shouldRedeliver(redeliveryCounter));\n\n        // now lets send to the dead letter queue\n        deadLetter.process(exchange);\n    }","id":41320,"modified_method":"public void process(Exchange exchange) throws Exception {\n        int redeliveryCounter = 0;\n        long redeliveryDelay = 0;\n\n        // default behaviour which can be overloaded on a per exception basis\n        RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy;\n        Processor failureProcessor = deadLetter;\n\n        do {\n            if (redeliveryCounter > 0) {\n                // Figure out how long we should wait to resend this message.\n                redeliveryDelay = currentRedeliveryPolicy.getRedeliveryDelay(redeliveryDelay);\n                sleep(redeliveryDelay);\n            }\n\n            try {\n                output.process(exchange);\n                return;\n            } catch (Throwable e) {\n                logger.log(\"On delivery attempt: \" + redeliveryCounter + \" caught: \" + e, e);\n                redeliveryCounter = incrementRedeliveryCounter(exchange, e);\n\n\n                ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);\n                if (exceptionPolicy != null) {\n                    currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(currentRedeliveryPolicy);\n                    Processor processor = exceptionPolicy.getErrorHandler();\n                    if (processor != null) {\n                        failureProcessor = processor;\n                    }\n                }\n            }\n        } while (currentRedeliveryPolicy.shouldRedeliver(redeliveryCounter));\n\n        // now lets send to the dead letter queue\n        failureProcessor.process(exchange);\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Increments the redelivery counter and adds the redelivered flag if the\n     * message has been redelivered\n     */\n    protected int incrementRedeliveryCounter(Exchange exchange) {\n        Message in = exchange.getIn();\n        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);\n        int next = 1;\n        if (counter != null) {\n            next = counter + 1;\n        }\n        in.setHeader(REDELIVERY_COUNTER, next);\n        in.setHeader(REDELIVERED, true);\n        return next;\n    }","id":41321,"modified_method":"/**\n     * Increments the redelivery counter and adds the redelivered flag if the\n     * message has been redelivered\n     */\n    protected int incrementRedeliveryCounter(Exchange exchange, Throwable e) {\n        Message in = exchange.getIn();\n        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);\n        int next = 1;\n        if (counter != null) {\n            next = counter + 1;\n        }\n        in.setHeader(REDELIVERY_COUNTER, next);\n        in.setHeader(REDELIVERED, true);\n        exchange.setException(e);\n        return next;\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"protected void configure(ErrorHandlerSupport handler) {\n        Set<Map.Entry<List<Class>, Processor>> entries = exceptionHandlers.entrySet();\n        for (Map.Entry<List<Class>, Processor> entry : entries) {\n            configure(handler, entry.getKey(), entry.getValue());\n        }\n    }","id":41322,"modified_method":"protected void configure(ErrorHandlerSupport handler) {\n        for (ExceptionType exception : exceptions) {\n            handler.addExceptionPolicy(exception);\n        }\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"protected Processor getProcessorForException(Exchange exchange, Throwable exception) {\n        Set<Map.Entry<Class,Processor>> entries = exceptionHandlers.entrySet();\n        for (Map.Entry<Class, Processor> entry : entries) {\n            Class type = entry.getKey();\n            if (type.isInstance(exception)) {\n                return entry.getValue();\n            }\n        }\n        return null;\n    }","id":41323,"modified_method":"protected ExceptionType getExceptionPolicy(Exchange exchange, Throwable exception) {\n        Set<Map.Entry<Class, ExceptionType>> entries = exceptionPolicices.entrySet();\n        for (Map.Entry<Class, ExceptionType> entry : entries) {\n            Class type = entry.getKey();\n            if (type.isInstance(exception)) {\n                return entry.getValue();\n            }\n        }\n        return null;\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Attempts to invoke the handler for this particular exception if one is available\n     * @param exchange\n     * @param exception\n     * @return\n     */\n    protected boolean customProcessorForException(Exchange exchange, Throwable exception) throws Exception {\n        Processor processor = getProcessorForException(exchange, exception);\n        if (processor != null) {\n            exchange.setException(exception);\n            processor.process(exchange);\n            return true;\n        }\n        return false;\n    }","id":41324,"modified_method":"/**\n     * Attempts to invoke the handler for this particular exception if one is available\n     *\n     * @param exchange\n     * @param exception\n     * @return\n     */\n    protected boolean customProcessorForException(Exchange exchange, Throwable exception) throws Exception {\n        ExceptionType policy = getExceptionPolicy(exchange, exception);\n        Processor processor = policy.getErrorHandler();\n        if (processor != null) {\n            processor.process(exchange);\n            return true;\n        }\n        return false;\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {\n        // lets attach a processor to an error handler\n        Processor errorHandler = routeContext.createProcessor(this);\n        ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();\n        builder.addErrorHandlers(getExceptionClasses(), errorHandler);\n    }","id":41325,"modified_method":"public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {\n        // lets attach a processor to an error handler\n        errorHandler = routeContext.createProcessor(this);\n        ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();\n        builder.addErrorHandlers(this);\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String toString() {\n        return \"Error[ \" + getExceptionClasses() + \" -> \" + getOutputs() + \"]\";\n    }","id":41326,"modified_method":"@Override\n    public String toString() {\n        return \"Exception[ \" + getExceptionClasses() + \" -> \" + getOutputs() + \"]\";\n    }","commit_id":"8b4bf60cd9adc643ef8f92a5eced4f4bdd4df7fa","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {\n        Expression objectExpression = pexp.getObjectExpression();\n        ClassNode objectExpressionType = getType(objectExpression);\n        final Reference<ClassNode> rType = new Reference<ClassNode>(objectExpressionType);\n        ClassCodeVisitorSupport receiverMemoizer = new ClassCodeVisitorSupport() {\n            @Override\n            protected SourceUnit getSourceUnit() {\n                return null;\n            }\n\n            public void visitField(final FieldNode node) {\n                if (visitor!=null) visitor.visitField(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            public void visitMethod(final MethodNode node) {\n                if (visitor!=null) visitor.visitMethod(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            @Override\n            public void visitProperty(final PropertyNode node) {\n                if (visitor!=null) visitor.visitProperty(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n        };\n        boolean exists = super.existsProperty(pexp, checkForReadOnly, receiverMemoizer);\n        if (exists) {\n            objectExpression.putNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER, rType.get());\n            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(objectExpressionType, ClassHelper.LIST_TYPE)) {\n                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));\n            }\n        }\n        return exists;\n    }","id":41327,"modified_method":"@Override\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {\n        Expression objectExpression = pexp.getObjectExpression();\n        ClassNode objectExpressionType = getType(objectExpression);\n        final Reference<ClassNode> rType = new Reference<ClassNode>(objectExpressionType);\n        ClassCodeVisitorSupport receiverMemoizer = new ClassCodeVisitorSupport() {\n            @Override\n            protected SourceUnit getSourceUnit() {\n                return null;\n            }\n\n            public void visitField(final FieldNode node) {\n                if (visitor!=null) visitor.visitField(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            public void visitMethod(final MethodNode node) {\n                if (visitor!=null) visitor.visitMethod(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            @Override\n            public void visitProperty(final PropertyNode node) {\n                if (visitor!=null) visitor.visitProperty(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n        };\n        boolean exists = super.existsProperty(pexp, checkForReadOnly, receiverMemoizer);\n        if (exists) {\n            if (objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER)==null) {\n                objectExpression.putNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER, rType.get());\n            }\n            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(objectExpressionType, ClassHelper.LIST_TYPE)) {\n                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));\n            }\n        }\n        return exists;\n    }","commit_id":"699c76444d5b470a9ccc6ba8067a3b8f47b82c68","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void makeCall(final Expression origin, final Expression receiver, final Expression message, final Expression arguments, final MethodCallerMultiAdapter adapter, final boolean safe, final boolean spreadSafe, final boolean implicitThis) {\n        ClassNode dynamicCallReturnType = origin.getNodeMetaData(StaticTypesMarker.DYNAMIC_RESOLUTION);\n        if (dynamicCallReturnType !=null) {\n            StaticTypesWriterController staticController = (StaticTypesWriterController) controller;\n            if (origin instanceof MethodCallExpression) {\n                ((MethodCallExpression) origin).setMethodTarget(null);\n            }\n            InvocationWriter dynamicInvocationWriter = staticController.getRegularInvocationWriter();\n            dynamicInvocationWriter.\n                    makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n            return;\n        }\n        Object implicitReceiver = origin.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);\n        ClassNode propertyOwnerType = origin.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);\n        if (implicitThis && implicitReceiver==null && origin instanceof MethodCallExpression) {\n            implicitReceiver = ((MethodCallExpression) origin).getObjectExpression().getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);\n        }\n        if (implicitReceiver !=null && implicitThis) {\n            String[] propertyPath = ((String) implicitReceiver).split(\"\\\\.\");\n            // GROOVY-6021\n            PropertyExpression pexp = new PropertyExpression(new VariableExpression(\"this\", CLOSURE_TYPE), propertyPath[0]);\n            pexp.setImplicitThis(true);\n            for (int i=1; i<propertyPath.length;i++) {\n                pexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, CLOSURE_TYPE);\n                pexp = new PropertyExpression(pexp, propertyPath[i]);\n            }\n            pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, implicitReceiver);\n            if (propertyOwnerType!=null) {\n                pexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, propertyOwnerType);\n            }\n            origin.removeNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);\n            if (origin instanceof PropertyExpression) {\n                PropertyExpression rewritten = new PropertyExpression(\n                        pexp,\n                        ((PropertyExpression) origin).getProperty(),\n                        ((PropertyExpression) origin).isSafe()\n                );\n                rewritten.setSpreadSafe(((PropertyExpression) origin).isSpreadSafe());\n                rewritten.setImplicitThis(false);\n                rewritten.visit(controller.getAcg());\n                return;\n            }\n            makeCall(origin, pexp, message, arguments, adapter, safe, spreadSafe, false);\n            return;\n        }\n        // if call is spread safe, replace it with a for in loop\n        if (spreadSafe && origin instanceof MethodCallExpression) {\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            TypeChooser typeChooser = controller.getTypeChooser();\n            OperandStack operandStack = controller.getOperandStack();\n            ClassNode classNode = controller.getClassNode();\n            int counter = labelCounter.incrementAndGet();\n\n            // create an empty arraylist\n            VariableExpression result = new VariableExpression(\n                    \"spreadresult\" + counter,\n                    StaticCompilationVisitor.ARRAYLIST_CLASSNODE\n            );\n            ConstructorCallExpression cce = new ConstructorCallExpression(StaticCompilationVisitor.ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);\n            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);\n            DeclarationExpression declr = new DeclarationExpression(\n                    result,\n                    Token.newSymbol(\"=\", origin.getLineNumber(), origin.getColumnNumber()),\n                    cce\n            );\n            declr.visit(controller.getAcg());\n            // if (receiver != null)\n            receiver.visit(controller.getAcg());\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(receiver, classNode));\n            Parameter iterator = new Parameter(componentType, \"for$it$\" + counter);\n            VariableExpression iteratorAsVar = new VariableExpression(iterator);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    iteratorAsVar,\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            newMCE.setMethodTarget(origMCE.getMethodTarget());\n            newMCE.setSafe(true);\n            MethodCallExpression add = new MethodCallExpression(\n                    result,\n                    \"add\",\n                    newMCE\n            );\n            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);\n            // for (e in receiver) { result.add(e?.method(arguments) }\n            ForStatement stmt = new ForStatement(\n                    iterator,\n                    receiver,\n                    new ExpressionStatement(add)\n            );\n            stmt.visit(controller.getAcg());\n            // else { empty list }\n            mv.visitLabel(ifnull);\n\n            // end of if/else\n            // return result list\n            result.visit(controller.getAcg());\n        } else if (safe && origin instanceof MethodCallExpression) {\n            // wrap call in an IFNULL check\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            OperandStack operandStack = controller.getOperandStack();\n            int counter = labelCounter.incrementAndGet();\n            // if (receiver != null)\n            ExpressionAsVariableSlot slot = new ExpressionAsVariableSlot(controller, receiver);\n            slot.visit(controller.getAcg());\n            operandStack.box();\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    new VariableSlotLoader(slot.getType(), slot.getIndex(), controller.getOperandStack()),\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            MethodNode methodTarget = origMCE.getMethodTarget();\n            newMCE.setMethodTarget(methodTarget);\n            newMCE.setSafe(false);\n            newMCE.setImplicitThis(origMCE.isImplicitThis());\n            newMCE.setSourcePosition(origMCE);\n            newMCE.visit(controller.getAcg());\n            compileStack.removeVar(slot.getIndex());\n            ClassNode returnType = operandStack.getTopOperand();\n            if (ClassHelper.isPrimitiveType(returnType) && !ClassHelper.VOID_TYPE.equals(returnType)) {\n                operandStack.box();\n            }\n            Label endof = compileStack.createLocalLabel(\"endof_\" + counter);\n            mv.visitJumpInsn(GOTO, endof);\n            mv.visitLabel(ifnull);\n            // else { null }\n            mv.visitInsn(ACONST_NULL);\n            mv.visitLabel(endof);\n        } else {\n            if ((adapter == AsmClassGenerator.getGroovyObjectField\n                    || adapter == AsmClassGenerator.getField ) && origin instanceof AttributeExpression) {\n                String pname = ((PropertyExpression) origin).getPropertyAsString();\n                CallSiteWriter callSiteWriter = controller.getCallSiteWriter();\n                if (pname!=null && callSiteWriter instanceof StaticTypesCallSiteWriter) {\n                    StaticTypesCallSiteWriter stcsw = (StaticTypesCallSiteWriter) callSiteWriter;\n                    TypeChooser typeChooser = controller.getTypeChooser();\n                    if (stcsw.makeGetField(receiver, typeChooser.resolveType(receiver, controller.getClassNode()), pname, false, true)) {\n                        return;\n                    }\n                }\n            }\n            super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n        }\n    }","id":41328,"modified_method":"@Override\n    public void makeCall(final Expression origin, final Expression receiver, final Expression message, final Expression arguments, final MethodCallerMultiAdapter adapter, final boolean safe, final boolean spreadSafe, final boolean implicitThis) {\n        ClassNode dynamicCallReturnType = origin.getNodeMetaData(StaticTypesMarker.DYNAMIC_RESOLUTION);\n        if (dynamicCallReturnType !=null) {\n            StaticTypesWriterController staticController = (StaticTypesWriterController) controller;\n            if (origin instanceof MethodCallExpression) {\n                ((MethodCallExpression) origin).setMethodTarget(null);\n            }\n            InvocationWriter dynamicInvocationWriter = staticController.getRegularInvocationWriter();\n            dynamicInvocationWriter.\n                    makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n            return;\n        }\n        if (tryImplicitReceiver(origin, message, arguments, adapter, safe, spreadSafe, implicitThis)) {\n            return;\n        }\n        // if call is spread safe, replace it with a for in loop\n        if (spreadSafe && origin instanceof MethodCallExpression) {\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            TypeChooser typeChooser = controller.getTypeChooser();\n            OperandStack operandStack = controller.getOperandStack();\n            ClassNode classNode = controller.getClassNode();\n            int counter = labelCounter.incrementAndGet();\n\n            // create an empty arraylist\n            VariableExpression result = new VariableExpression(\n                    \"spreadresult\" + counter,\n                    StaticCompilationVisitor.ARRAYLIST_CLASSNODE\n            );\n            ConstructorCallExpression cce = new ConstructorCallExpression(StaticCompilationVisitor.ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);\n            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);\n            DeclarationExpression declr = new DeclarationExpression(\n                    result,\n                    Token.newSymbol(\"=\", origin.getLineNumber(), origin.getColumnNumber()),\n                    cce\n            );\n            declr.visit(controller.getAcg());\n            // if (receiver != null)\n            receiver.visit(controller.getAcg());\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(receiver, classNode));\n            Parameter iterator = new Parameter(componentType, \"for$it$\" + counter);\n            VariableExpression iteratorAsVar = new VariableExpression(iterator);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    iteratorAsVar,\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            newMCE.setMethodTarget(origMCE.getMethodTarget());\n            newMCE.setSafe(true);\n            MethodCallExpression add = new MethodCallExpression(\n                    result,\n                    \"add\",\n                    newMCE\n            );\n            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);\n            // for (e in receiver) { result.add(e?.method(arguments) }\n            ForStatement stmt = new ForStatement(\n                    iterator,\n                    receiver,\n                    new ExpressionStatement(add)\n            );\n            stmt.visit(controller.getAcg());\n            // else { empty list }\n            mv.visitLabel(ifnull);\n\n            // end of if/else\n            // return result list\n            result.visit(controller.getAcg());\n        } else if (safe && origin instanceof MethodCallExpression) {\n            // wrap call in an IFNULL check\n            MethodVisitor mv = controller.getMethodVisitor();\n            CompileStack compileStack = controller.getCompileStack();\n            OperandStack operandStack = controller.getOperandStack();\n            int counter = labelCounter.incrementAndGet();\n            // if (receiver != null)\n            ExpressionAsVariableSlot slot = new ExpressionAsVariableSlot(controller, receiver);\n            slot.visit(controller.getAcg());\n            operandStack.box();\n            Label ifnull = compileStack.createLocalLabel(\"ifnull_\" + counter);\n            mv.visitJumpInsn(IFNULL, ifnull);\n            operandStack.remove(1); // receiver consumed by if()\n            Label nonull = compileStack.createLocalLabel(\"nonull_\" + counter);\n            mv.visitLabel(nonull);\n            MethodCallExpression origMCE = (MethodCallExpression) origin;\n            MethodCallExpression newMCE = new MethodCallExpression(\n                    new VariableSlotLoader(slot.getType(), slot.getIndex(), controller.getOperandStack()),\n                    origMCE.getMethodAsString(),\n                    origMCE.getArguments()\n            );\n            MethodNode methodTarget = origMCE.getMethodTarget();\n            newMCE.setMethodTarget(methodTarget);\n            newMCE.setSafe(false);\n            newMCE.setImplicitThis(origMCE.isImplicitThis());\n            newMCE.setSourcePosition(origMCE);\n            newMCE.visit(controller.getAcg());\n            compileStack.removeVar(slot.getIndex());\n            ClassNode returnType = operandStack.getTopOperand();\n            if (ClassHelper.isPrimitiveType(returnType) && !ClassHelper.VOID_TYPE.equals(returnType)) {\n                operandStack.box();\n            }\n            Label endof = compileStack.createLocalLabel(\"endof_\" + counter);\n            mv.visitJumpInsn(GOTO, endof);\n            mv.visitLabel(ifnull);\n            // else { null }\n            mv.visitInsn(ACONST_NULL);\n            mv.visitLabel(endof);\n        } else {\n            if ((adapter == AsmClassGenerator.getGroovyObjectField\n                    || adapter == AsmClassGenerator.getField ) && origin instanceof AttributeExpression) {\n                String pname = ((PropertyExpression) origin).getPropertyAsString();\n                CallSiteWriter callSiteWriter = controller.getCallSiteWriter();\n                if (pname!=null && callSiteWriter instanceof StaticTypesCallSiteWriter) {\n                    StaticTypesCallSiteWriter stcsw = (StaticTypesCallSiteWriter) callSiteWriter;\n                    TypeChooser typeChooser = controller.getTypeChooser();\n                    if (stcsw.makeGetField(receiver, typeChooser.resolveType(receiver, controller.getClassNode()), pname, false, true)) {\n                        return;\n                    }\n                }\n            }\n            super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);\n        }\n    }","commit_id":"699c76444d5b470a9ccc6ba8067a3b8f47b82c68","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        if (leftExpression instanceof PropertyExpression) {\n            // check that property exists\n            PropertyExpression pexp = (PropertyExpression) leftExpression;\n            if (!existsProperty(pexp)) {\n                Expression objectExpression = pexp.getObjectExpression();\n                addStaticTypeError(\"No such property: \" + pexp.getPropertyAsString() +\n                        \" for class: \" + findCurrentInstanceOfClass(objectExpression, objectExpression.getType()), leftExpression);\n                return;\n            }\n        }\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            addStaticTypeError(\"tbd...\", expression);\n            resultType = lType;\n        }\n        // todo : if assignment of a primitive to an object (def, Object, whatever),\n        // the type inference engine should return an Object (not a primitive type)\n        storeType(expression, resultType);\n        if (isAssignment(op)) {\n            typeCheckAssignment(expression, leftExpression, lType, rightExpression, resultType);\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","id":41329,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        if (leftExpression instanceof PropertyExpression) {\n            // check that property exists\n            PropertyExpression pexp = (PropertyExpression) leftExpression;\n            if (!existsProperty(pexp)) {\n                Expression objectExpression = pexp.getObjectExpression();\n                addStaticTypeError(\"No such property: \" + pexp.getPropertyAsString() +\n                        \" for class: \" + findCurrentInstanceOfClass(objectExpression, objectExpression.getType()), leftExpression);\n                return;\n            }\n        }\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            addStaticTypeError(\"tbd...\", expression);\n            resultType = lType;\n        }\n        // todo : if assignment of a primitive to an object (def, Object, whatever),\n        // the type inference engine should return an Object (not a primitive type)\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            typeCheckAssignment(expression, leftExpression, lType, rightExpression, resultType);\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","commit_id":"65d31fb340d8196bf0f9d27020ca9eee068e5114","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.INFERRED_TYPE, cn);\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","id":41330,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE, firstCommonSuperType(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE, firstCommonSuperType(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","commit_id":"65d31fb340d8196bf0f9d27020ca9eee068e5114","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.INFERRED_TYPE, cn);\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","id":41331,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE, firstCommonSuperType(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.DECLARATION_INFERRED_TYPE, firstCommonSuperType(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","commit_id":"d39989e7934fd1c25d4a269283b0a8cca8a5f812","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        if (leftExpression instanceof PropertyExpression) {\n            // check that property exists\n            PropertyExpression pexp = (PropertyExpression) leftExpression;\n            if (!existsProperty(pexp)) {\n                Expression objectExpression = pexp.getObjectExpression();\n                addStaticTypeError(\"No such property: \" + pexp.getPropertyAsString() +\n                        \" for class: \" + findCurrentInstanceOfClass(objectExpression, objectExpression.getType()), leftExpression);\n                return;\n            }\n        }\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            addStaticTypeError(\"tbd...\", expression);\n            resultType = lType;\n        }\n        // todo : if assignment of a primitive to an object (def, Object, whatever),\n        // the type inference engine should return an Object (not a primitive type)\n        storeType(expression, resultType);\n        if (isAssignment(op)) {\n            typeCheckAssignment(expression, leftExpression, lType, rightExpression, resultType);\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","id":41332,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        if (leftExpression instanceof PropertyExpression) {\n            // check that property exists\n            PropertyExpression pexp = (PropertyExpression) leftExpression;\n            if (!existsProperty(pexp)) {\n                Expression objectExpression = pexp.getObjectExpression();\n                addStaticTypeError(\"No such property: \" + pexp.getPropertyAsString() +\n                        \" for class: \" + findCurrentInstanceOfClass(objectExpression, objectExpression.getType()), leftExpression);\n                return;\n            }\n        }\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            addStaticTypeError(\"tbd...\", expression);\n            resultType = lType;\n        }\n        // todo : if assignment of a primitive to an object (def, Object, whatever),\n        // the type inference engine should return an Object (not a primitive type)\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            typeCheckAssignment(expression, leftExpression, lType, rightExpression, resultType);\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","commit_id":"d39989e7934fd1c25d4a269283b0a8cca8a5f812","url":"https://github.com/apache/groovy"},{"original_method":"private static boolean isStaticallyCompiled(ClassNode node) {\n        if (!node.getAnnotations(COMPILE_STATIC_ANNOTATION).isEmpty()) return true;\n        if (node instanceof InnerClassNode) {\n            return isStaticallyCompiled(node.getOuterClass());\n        }\n        return false;\n    }","id":41333,"modified_method":"public static boolean isStaticallyCompiled(AnnotatedNode node) {\n        if (node.getNodeMetaData(STATIC_COMPILE_NODE)!=null) return true;\n        if (node instanceof MethodNode) {\n            return isStaticallyCompiled(node.getDeclaringClass());\n        }\n        if (node instanceof InnerClassNode) {\n            return isStaticallyCompiled(((InnerClassNode)node).getOuterClass());\n        }\n        return false;\n    }","commit_id":"f94c83e40aad29ada1af3a24e123e807c1af80e1","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visit(final ASTNode[] nodes, final SourceUnit source) {\n        BinaryExpressionTransformer transformer = new BinaryExpressionTransformer(source);\n        List<ClassNode> classes = source.getAST().getClasses();\n        for (ClassNode classNode : classes) {\n            classNode.putNodeMetaData(WriterControllerFactory.class, factory);\n        }\n        super.visit(nodes, source);\n        for (ClassNode classNode : classes) {\n            transformer.visitClass(classNode);\n        }\n    }","id":41334,"modified_method":"@Override\n    public void visit(final ASTNode[] nodes, final SourceUnit source) {\n        BinaryExpressionTransformer transformer = new BinaryExpressionTransformer(source);\n\n        AnnotatedNode node = (AnnotatedNode) nodes[1];\n        StaticTypeCheckingVisitor visitor;\n        if (node instanceof ClassNode) {\n            ClassNode classNode = (ClassNode) node;\n            classNode.putNodeMetaData(WriterControllerFactory.class, factory);\n            node.putNodeMetaData(STATIC_COMPILE_NODE, Boolean.TRUE);\n            visitor = newVisitor(source, classNode, null);\n            visitor.visitClass(classNode);\n        } else if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode)node;\n            methodNode.putNodeMetaData(STATIC_COMPILE_NODE, Boolean.TRUE);\n            ClassNode declaringClass = methodNode.getDeclaringClass();\n            if (declaringClass.getNodeMetaData(WriterControllerFactory.class)==null) {\n                declaringClass.putNodeMetaData(WriterControllerFactory.class, factory);\n            }\n            visitor = newVisitor(source, declaringClass, null);\n            visitor.setMethodsToBeVisited(Collections.singleton(methodNode));\n            visitor.visitMethod(methodNode);\n        } else {\n            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + \"Unimplemented node type\", node.getLineNumber(), node.getColumnNumber()));\n        }\n        super.visit(nodes, source);\n        if (node instanceof ClassNode) {\n            transformer.visitClass((ClassNode)node);\n        } else if (node instanceof MethodNode) {\n            transformer.visitMethod((MethodNode)node);\n        }\n    }","commit_id":"f94c83e40aad29ada1af3a24e123e807c1af80e1","url":"https://github.com/apache/groovy"},{"original_method":"private void updateStaticCompileFlag(final MethodNode mn) {\n        ClassNode classNode = getClassNode();\n        if (classNode.implementsInterface(ClassHelper.GENERATED_CLOSURE_Type)) {\n            classNode = classNode.getOuterClass();\n        }\n        isInStaticallyCheckedMethod = mn != null && (\n                !mn.getAnnotations(COMPILE_STATIC_ANNOTATION).isEmpty() ||\n                        !classNode.getAnnotations(COMPILE_STATIC_ANNOTATION).isEmpty() ||\n                        classNode.getNodeMetaData(STATIC_COMPILE_NODE) != null);\n/*        if (isInStaticallyCheckedMethod) {\n            System.out.println(\"Entering statically compiled method: \"+mn.getDeclaringClass()+\"#\"+mn);\n        } else if (mn!=null) {\n            System.out.println(\"Entering dynamically compiled method: \"+mn.getDeclaringClass()+\"#\"+mn);\n        }*/\n    }","id":41335,"modified_method":"private void updateStaticCompileFlag(final MethodNode mn) {\n        ClassNode classNode = getClassNode();\n        AnnotatedNode node = mn;\n        if (classNode.implementsInterface(ClassHelper.GENERATED_CLOSURE_Type)) {\n            node = classNode.getOuterClass();\n        }\n\n        isInStaticallyCheckedMethod = mn != null && StaticCompilationVisitor.isStaticallyCompiled(node);\n\n      if (isInStaticallyCheckedMethod) {\n            System.out.println(\"Entering statically compiled method: \"+mn.getDeclaringClass()+\"#\"+mn);\n        }/* else if (mn!=null) {\n            System.out.println(\"Entering dynamically compiled method: \"+mn.getDeclaringClass()+\"#\"+mn);\n        }*/\n    }","commit_id":"f94c83e40aad29ada1af3a24e123e807c1af80e1","url":"https://github.com/apache/groovy"},{"original_method":"public ExpandingArrayList<VariantDatum> map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final ExpandingArrayList<VariantDatum> mapList = new ExpandingArrayList<VariantDatum>();\n\n        if( tracker == null ) { // For some reason RodWalkers get map calls with null trackers\n            return mapList;\n        }\n\n        final double annotationValues[] = new double[annotationKeys.size()];\n\n        for( final VariantContext vc : tracker.getVariantContexts(ref, inputNames, null, context.getLocation(), false, false) ) {\n            if( vc != null && vc.isSNP() ) {\n                if( !vc.isFiltered() || IGNORE_ALL_INPUT_FILTERS || (ignoreInputFilterSet != null && ignoreInputFilterSet.containsAll(vc.getFilters())) ) {\n                    int iii = 0;\n                    for( final String key : annotationKeys ) {\n                        annotationValues[iii++] = VariantGaussianMixtureModel.decodeAnnotation( key, vc, true );\n                    }\n\n                    final VariantDatum variantDatum = new VariantDatum();\n                    variantDatum.annotations = annotationValues;\n                    variantDatum.isTransition = VariantContextUtils.getSNPSubstitutionType(vc).compareTo(BaseUtils.BaseSubstitutionType.TRANSITION) == 0;\n\n                    variantDatum.qual = vc.getPhredScaledQual();\n\n                    final DbSNPFeature dbsnp = DbSNPHelper.getFirstRealSNP(tracker.getReferenceMetaData(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME));\n                    final VariantContext vcHapMap = tracker.getVariantContext(ref, \"hapmap\", null, context.getLocation(), false);\n                    final VariantContext vc1KG = tracker.getVariantContext(ref, \"1kg\", null, context.getLocation(), false);\n\n                    variantDatum.isKnown = (dbsnp!=null);\n                    variantDatum.weight = WEIGHT_NOVELS;                   \n                    if( vcHapMap != null ) {\n                        variantDatum.weight = WEIGHT_HAPMAP;\n                    } else if( vc1KG != null ) {\n                        variantDatum.weight = WEIGHT_1KG;\n                    } else if( dbsnp != null ) {\n                        variantDatum.weight = WEIGHT_DBSNP;\n                    }\n\n                    if( variantDatum.weight > 0.0 && variantDatum.qual > QUAL_THRESHOLD ) {\n                        mapList.add( variantDatum );\n                    }\n                }\n            }\n        }\n\n        return mapList;\n    }","id":41336,"modified_method":"public ExpandingArrayList<VariantDatum> map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final ExpandingArrayList<VariantDatum> mapList = new ExpandingArrayList<VariantDatum>();\n\n        if( tracker == null ) { // For some reason RodWalkers get map calls with null trackers\n            return mapList;\n        }\n\n        final double annotationValues[] = new double[annotationKeys.size()];\n\n        for( final VariantContext vc : tracker.getVariantContexts(ref, inputNames, null, context.getLocation(), false, false) ) {\n            if( vc != null && vc.isSNP() ) {\n                if( !vc.isFiltered() || IGNORE_ALL_INPUT_FILTERS || (ignoreInputFilterSet != null && ignoreInputFilterSet.containsAll(vc.getFilters())) ) {\n                    int iii = 0;\n                    for( final String key : annotationKeys ) {\n                        annotationValues[iii++] = theModel.decodeAnnotation( key, vc, true );\n                    }\n\n                    final VariantDatum variantDatum = new VariantDatum();\n                    variantDatum.annotations = annotationValues;\n                    variantDatum.isTransition = VariantContextUtils.getSNPSubstitutionType(vc).compareTo(BaseUtils.BaseSubstitutionType.TRANSITION) == 0;\n\n                    variantDatum.qual = vc.getPhredScaledQual();\n\n                    final DbSNPFeature dbsnp = DbSNPHelper.getFirstRealSNP(tracker.getReferenceMetaData(DbSNPHelper.STANDARD_DBSNP_TRACK_NAME));\n                    final VariantContext vcHapMap = tracker.getVariantContext(ref, \"hapmap\", null, context.getLocation(), false);\n                    final VariantContext vc1KG = tracker.getVariantContext(ref, \"1kg\", null, context.getLocation(), false);\n\n                    variantDatum.isKnown = (dbsnp!=null);\n                    variantDatum.weight = WEIGHT_NOVELS;                   \n                    if( vcHapMap != null ) {\n                        variantDatum.weight = WEIGHT_HAPMAP;\n                    } else if( vc1KG != null ) {\n                        variantDatum.weight = WEIGHT_1KG;\n                    } else if( dbsnp != null ) {\n                        variantDatum.weight = WEIGHT_DBSNP;\n                    }\n\n                    if( variantDatum.weight > 0.0 && variantDatum.qual > QUAL_THRESHOLD ) {\n                        mapList.add( variantDatum );\n                    }\n                }\n            }\n        }\n\n        return mapList;\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone( ExpandingArrayList<VariantDatum> reduceSum ) {\n\n        final VariantDataManager dataManager = new VariantDataManager( reduceSum, annotationKeys );\n        reduceSum.clear(); // Don't need this ever again, clean up some memory\n\n        logger.info( \"There are \" + dataManager.numVariants + \" variants with > 0 clustering weight and \" + dataManager.numAnnotations + \" annotations.\" );\n        logger.info( \"The annotations are: \" + annotationKeys );\n\n        dataManager.normalizeData(); // Each data point is now [ (x - mean) / standard deviation ]\n\n        // Create either the Gaussian Mixture Model or the Nearest Neighbors model and run it\n        VariantGaussianMixtureModel theModel;\n        switch (OPTIMIZATION_MODEL) {\n            case GAUSSIAN_MIXTURE_MODEL:\n                theModel = new VariantGaussianMixtureModel( dataManager, MAX_GAUSSIANS, MAX_ITERATIONS, FORCE_INDEPENDENT,\n                                                            STD_THRESHOLD, SHRINKAGE, DIRICHLET_PARAMETER );\n                break;\n            //case K_NEAREST_NEIGHBORS:\n            //    theModel = new VariantNearestNeighborsModel( dataManager, TARGET_TITV, NUM_KNN );\n            //    break;\n            default:\n                throw new StingException( \"Variant Optimization Model is unrecognized. Implemented options are GAUSSIAN_MIXTURE_MODEL and K_NEAREST_NEIGHBORS\" );\n        }\n        \n        theModel.run( CLUSTER_FILE );\n\n/*\n        theModel.outputClusterReports( CLUSTER_FILENAME );\n\n        for( final String annotation : annotationKeys ) {\n            // Execute Rscript command to plot the optimization curve\n            // Print out the command line to make it clear to the user what is being executed and how one might modify it\n            final String rScriptCommandLine = PATH_TO_RSCRIPT + \" \" + PATH_TO_RESOURCES + \"plot_ClusterReport.R\" + \" \" + CLUSTER_FILENAME + \".\" + annotation + \".dat \" + annotation;\n            logger.info( rScriptCommandLine );\n\n            // Execute the RScript command to plot the table of truth values\n            try {\n                Runtime.getRuntime().exec( rScriptCommandLine );\n            } catch ( IOException e ) {\n                Utils.warnUser(\"Unable to execute the RScript command because of [\" + e.getMessage() + \"].  While not critical to the calculations themselves, the script outputs a report that is extremely useful for confirming that the clustering proceded as expected.  We highly recommend trying to rerun the script manually if possible.\");\n            }\n        }\n*/\n    }","id":41337,"modified_method":"public void onTraversalDone( ExpandingArrayList<VariantDatum> reduceSum ) {\n\n        final VariantDataManager dataManager = new VariantDataManager( reduceSum, annotationKeys );\n        reduceSum.clear(); // Don't need this ever again, clean up some memory\n\n        logger.info( \"There are \" + dataManager.numVariants + \" variants with > 0 clustering weight and \" + dataManager.numAnnotations + \" annotations.\" );\n        logger.info( \"The annotations are: \" + annotationKeys );\n\n        dataManager.normalizeData(); // Each data point is now [ (x - mean) / standard deviation ]\n\n        // Create either the Gaussian Mixture Model or the Nearest Neighbors model and run it\n        switch (OPTIMIZATION_MODEL) {\n            case GAUSSIAN_MIXTURE_MODEL:\n                theModel = new VariantGaussianMixtureModel( dataManager, MAX_GAUSSIANS, MAX_ITERATIONS, FORCE_INDEPENDENT,\n                                                            STD_THRESHOLD, SHRINKAGE, DIRICHLET_PARAMETER );\n                break;\n            //case K_NEAREST_NEIGHBORS:\n            //    theModel = new VariantNearestNeighborsModel( dataManager, TARGET_TITV, NUM_KNN );\n            //    break;\n            default:\n                throw new StingException( \"Variant Optimization Model is unrecognized. Implemented options are GAUSSIAN_MIXTURE_MODEL and K_NEAREST_NEIGHBORS\" );\n        }\n        \n        theModel.run( CLUSTER_FILE );\n\n/*\n        theModel.outputClusterReports( CLUSTER_FILENAME );\n\n        for( final String annotation : annotationKeys ) {\n            // Execute Rscript command to plot the optimization curve\n            // Print out the command line to make it clear to the user what is being executed and how one might modify it\n            final String rScriptCommandLine = PATH_TO_RSCRIPT + \" \" + PATH_TO_RESOURCES + \"plot_ClusterReport.R\" + \" \" + CLUSTER_FILENAME + \".\" + annotation + \".dat \" + annotation;\n            logger.info( rScriptCommandLine );\n\n            // Execute the RScript command to plot the table of truth values\n            try {\n                Runtime.getRuntime().exec( rScriptCommandLine );\n            } catch ( IOException e ) {\n                Utils.warnUser(\"Unable to execute the RScript command because of [\" + e.getMessage() + \"].  While not critical to the calculations themselves, the script outputs a report that is extremely useful for confirming that the clustering proceded as expected.  We highly recommend trying to rerun the script manually if possible.\");\n            }\n        }\n*/\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static double decodeAnnotation( final String annotationKey, final VariantContext vc, final boolean jitter ) {\n        double value;\n        //if( annotationKey.equals(\"AB\") && !vc.getAttributes().containsKey(annotationKey) ) {\n        //    value = (0.5 - 0.005) + (0.01 * rand.nextDouble()); // HomVar calls don't have an allele balance\n        //}\n        if( jitter && annotationKey.equalsIgnoreCase(\"HRUN\") ) { // HRun values must be jittered a bit to work in this GMM\n            value = Double.parseDouble( (String)vc.getAttribute( annotationKey ) );\n            value += -0.25 + 0.5 * rand.nextDouble();\n        } else if( annotationKey.equals(\"QUAL\") ) {\n            value = vc.getPhredScaledQual();\n        } else {\n            try {\n                value = Double.parseDouble( (String)vc.getAttribute( annotationKey ) );\n            } catch( Exception e ) {\n                throw new StingException(\"No double value detected for annotation = \" + annotationKey +\n                        \" in variant at \" + VariantContextUtils.getLocation(vc) + \", reported annotation value = \" + vc.getAttribute( annotationKey ) );\n            }\n        }\n        return value;\n    }","id":41338,"modified_method":"public double decodeAnnotation( final String annotationKey, final VariantContext vc, final boolean jitter ) {\n        double value;\n        //if( annotationKey.equals(\"AB\") && !vc.getAttributes().containsKey(annotationKey) ) {\n        //    value = (0.5 - 0.005) + (0.01 * rand.nextDouble()); // HomVar calls don't have an allele balance\n        //}\n        if( jitter && annotationKey.equalsIgnoreCase(\"HRUN\") ) { // HRun values must be jittered a bit to work in this GMM\n            value = Double.parseDouble( (String)vc.getAttribute( annotationKey ) );\n            value += -0.25 + 0.5 * rand.nextDouble();\n        } else if( annotationKey.equals(\"QUAL\") ) {\n            value = vc.getPhredScaledQual();\n        } else {\n            try {\n                value = Double.parseDouble( (String)vc.getAttribute( annotationKey ) );\n            } catch( Exception e ) {\n                throw new StingException(\"No double value detected for annotation = \" + annotationKey +\n                        \" in variant at \" + VariantContextUtils.getLocation(vc) + \", reported annotation value = \" + vc.getAttribute( annotationKey ) );\n            }\n        }\n        return value;\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testVariantRecalibrator() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\", \"f2790e2f4f3c23df800c18aaa39b3fde\" );\n        \n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            String md5 = entry.getValue();\n            String clusterFile = clusterFiles.get(vcf);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, clusterFile);\n            if ( clusterFile != null ) {\n                WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                        \"-R \" + b36KGReference +\n                                \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                                \" -T VariantRecalibrator\" +\n                                \" -B:input,VCF \" + vcf +\n                                \" -L 1:40,000,000-100,000,000\" +\n                                \" --ignore_filter GATK_STANDARD\" +\n                                \" --ignore_filter HARD_TO_VALIDATE\" +\n                                \" -clusterFile \" + clusterFile +\n                                \" -titv 2.07\" +\n                                \" -o %s\" +\n                                \" -tranchesFile %s\" +\n                                \" -reportDatFile %s\",                                \n                        3, // two output file\n                        Arrays.asList(md5, \"d979864c46ae237f52f1002f0ec19b16\",\"ab438d03e276a053d7534056f62c83f3\"));\n                List<File> result = executeTest(\"testVariantRecalibrator\", spec).getFirst();\n                inputVCFFiles.put(vcf, result.get(0).getAbsolutePath());\n                tranchesFiles.put(vcf, result.get(1).getAbsolutePath());\n            }\n        }\n\n\n    }","id":41339,"modified_method":"@Test\n    public void testVariantRecalibrator() {\n        HashMap<String, List<String>> e = new HashMap<String, List<String>>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\",\n                Arrays.asList(\"ad0868adddb2e837b4fc08f140e4d9c3\", \"937080353c7e03e11f8a70fc0004bf76\",\"5b89fa5a4edf0080d64230d4103d2b8d\")); // Each test checks the md5 of three output files\n        e.put( validationDataLocation + \"lowpass.N3.chr1.raw.0.vcf\",\n                Arrays.asList(\"054d3228acfd6b02d24bfcf2fbd280a0\", \"f7c5c6cff9dd5280b25e24e0591e4cb0\",\"1de1473db5720b882edf1381fa3dd039\")); // Each test checks the md5 of three output files\n\n        for ( Map.Entry<String, List<String>> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            List<String> md5s = entry.getValue();\n            String clusterFile = clusterFiles.get(vcf);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, clusterFile);\n            if ( clusterFile != null ) {\n                WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                        \"-R \" + b36KGReference +\n                                \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                                \" -B:hapmap,VCF \" + validationDataLocation + \"CEU_hapmap_nogt_23.vcf\" +\n                                \" -T VariantRecalibrator\" +\n                                \" -B:input,VCF \" + vcf +\n                                \" -L 1:40,000,000-100,000,000\" +\n                                \" --ignore_filter GATK_STANDARD\" +\n                                \" --ignore_filter HARD_TO_VALIDATE\" +\n                                \" -clusterFile \" + clusterFile +\n                                \" -titv 2.07\" +\n                                \" -o %s\" +\n                                \" -tranchesFile %s\" +\n                                \" -reportDatFile %s\",                                \n                        3, // two output file\n                        md5s);\n                List<File> result = executeTest(\"testVariantRecalibrator\", spec).getFirst();\n                inputVCFFiles.put(vcf, result.get(0).getAbsolutePath());\n                tranchesFiles.put(vcf, result.get(1).getAbsolutePath());\n            }\n        }\n\n\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testApplyVariantCuts() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\", \"d30eafb642a80a00bd82fb4140b5277e\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            String md5 = entry.getValue();\n            String inputVCFFile = inputVCFFiles.get(vcf);\n            String tranchesFile = tranchesFiles.get(vcf);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, inputVCFFile);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, tranchesFile);\n            if ( inputVCFFile != null && tranchesFile != null ) {\n                WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                        \"-R \" + b36KGReference +\n                                \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                                \" -T ApplyVariantCuts\" +\n                                \" -L 1:40,000,000-100,000,000\" +\n                                \" -B:input,VCF \" + inputVCFFile +\n                                \" -o %s\" +\n                                \" -tranchesFile \" + tranchesFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                List<File> result = executeTest(\"testApplyVariantCuts\", spec).getFirst();\n            }\n        }\n    }","id":41340,"modified_method":"@Test\n    public void testApplyVariantCuts() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\", \"841deca1cb30a5a081cfbaa6f663e22a\" );\n        e.put( validationDataLocation + \"lowpass.N3.chr1.raw.0.vcf\", \"6234259e75fd7c1db31566dde1c55a82\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            String md5 = entry.getValue();\n            String inputVCFFile = inputVCFFiles.get(vcf);\n            String tranchesFile = tranchesFiles.get(vcf);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, inputVCFFile);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", vcf, tranchesFile);\n            if ( inputVCFFile != null && tranchesFile != null ) {\n                WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                        \"-R \" + b36KGReference +\n                                \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                                \" -T ApplyVariantCuts\" +\n                                \" -L 1:40,000,000-100,000,000\" +\n                                \" -B:input,VCF \" + inputVCFFile +\n                                \" -o %s\" +\n                                \" -tranchesFile \" + tranchesFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testApplyVariantCuts\", spec);\n            }\n        }\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testGenerateVariantClusters() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\", \"79727fb46bb60be30eae2666e4f792b6\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    \"-R \" + b36KGReference +\n                            \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                            \" -T GenerateVariantClusters\" +\n                            \" -B:input,VCF \" + vcf +\n                            \" -L 1:1-100,000,000\" +\n                            \" --ignore_filter GATK_STANDARD\" +\n                            \" -an QD -an HRun -an SB\" +\n                            \" -weightDBSNP 1.0\" +\n                            \" -clusterFile %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            List<File> result = executeTest(\"testGenerateVariantClusters\", spec).getFirst();\n            clusterFiles.put(vcf, result.get(0).getAbsolutePath());\n        }\n    }","id":41341,"modified_method":"@Test\n    public void testGenerateVariantClusters() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\", \"cb3e8d9072d478243c3f9d0ee09fef3b\" );\n        e.put( validationDataLocation + \"lowpass.N3.chr1.raw.0.vcf\", \"0d4fee916a886ca98c286d3b7fed0ff6\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String vcf = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    \"-R \" + b36KGReference +\n                            \" --DBSNP \" + GATKDataLocation + \"dbsnp_129_b36.rod\" +\n                            \" -B:hapmap,VCF \" + validationDataLocation + \"CEU_hapmap_nogt_23.vcf\" +\n                            \" -weightDBSNP 1.0 -weightHapMap 1.0\" +\n                            \" -T GenerateVariantClusters\" +\n                            \" -B:input,VCF \" + vcf +\n                            \" -L 1:1-100,000,000\" +\n                            \" --ignore_filter GATK_STANDARD\" +\n                            \" -an QD -an HRun -an SB\" +\n                            \" -clusterFile %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            List<File> result = executeTest(\"testGenerateVariantClusters\", spec).getFirst();\n            clusterFiles.put(vcf, result.get(0).getAbsolutePath());\n        }\n    }","commit_id":"469bbaa240b28ed5b688aa9bec20f509b6002e5e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n\n        String genotypeHeader = \"\";\n        if (!genotypeFieldsToTake.isEmpty()) {\n            Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), variants);\n            TreeSet<String> vcfSamples = new TreeSet<String>(SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE));\n            samples.addAll(vcfSamples);\n            \n            StringBuilder sb = new StringBuilder();\n            sb.append(\"\\t\");\n            for (final String sample : samples) {\n                for (final String gf : genotypeFieldsToTake) {\n                    sb.append(sample+\".\"+gf+\"\\t\");\n                }\n            }\n            genotypeHeader = sb.toString();\n        }\n        // print out the header\n        out.println(Utils.join(\"\\t\", fieldsToTake) + genotypeHeader);\n    }","id":41342,"modified_method":"public void initialize() {\n\n        if ( !genotypeFieldsToTake.isEmpty() ) {\n            Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), variants);\n            TreeSet<String> vcfSamples = new TreeSet<String>(SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE));\n            samples.addAll(vcfSamples);\n\n            // optimization: if there are no samples, we don't have to worry about any genotype fields\n            if ( samples.isEmpty() )\n                genotypeFieldsToTake.clear();\n        }\n\n        // print out the header\n        if ( moltenizeOutput ) {\n            out.println(\"RecordID\\tSample\\tVariable\\tValue\");\n        } else {\n            final String baseHeader = Utils.join(\"\\t\", fieldsToTake);\n            final String genotypeHeader = createGenotypeHeader(genotypeFieldsToTake, samples);\n            final String separator = (!baseHeader.isEmpty() && !genotypeHeader.isEmpty()) ? \"\\t\" : \"\";\n            out.println(baseHeader + separator + genotypeHeader);\n        }\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public boolean isDone() {\n        boolean done = MAX_RECORDS != -1 && nRecords >= MAX_RECORDS;\n        if ( done) logger.warn(\"isDone() will return true to leave after \" + nRecords + \" records\");\n        return done ;\n    }","id":41343,"modified_method":"@Override\n    public boolean isDone() {\n        return (MAX_RECORDS != -1 && nRecords >= MAX_RECORDS);\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Utility function that returns the list of values for each field in fields from vc.\n     *\n     * @param vc the VariantContext whose field values we can to capture\n     * @param fields a non-null list of fields to capture from VC\n     * @param genotypeFields a (possibly) null) list of fields to capture from each genotype\n     * @param samples set of samples in vc, can be null in case of sites-only file\n     * @param allowMissingData if false, then throws a UserException if any field isn't found in vc.  Otherwise provides a value of NA\n     * @param splitMultiAllelic  if true, multiallelic variants are to be split into multiple records\n     * @return List of lists of field values\n     */\n    private static List<List<String>> extractFields(VariantContext vc, List<String> fields, List<String> genotypeFields,\n                                                    Set<String> samples, boolean allowMissingData, boolean splitMultiAllelic) {\n        \n        final int numRecordsToProduce = splitMultiAllelic ? vc.getAlternateAlleles().size() : 1;\n        final List<List<String>> records = new ArrayList<List<String>>(numRecordsToProduce);\n\n        int numFields = fields.size();\n        final boolean addGenotypeFields = (genotypeFields != null && !genotypeFields.isEmpty() && samples != null && !samples.isEmpty());\n        if (addGenotypeFields)\n            numFields += genotypeFields.size()*samples.size();\n\n        for ( int i = 0; i < numRecordsToProduce; i++ )\n            records.add(new ArrayList<String>(numFields));\n\n        for ( String field : fields ) {\n\n            if ( splitMultiAllelic && field.equals(\"ALT\") ) { // we need to special case the ALT field when splitting out multi-allelic records\n                addFieldValue(splitAltAlleles(vc), records);\n            } else if ( getters.containsKey(field) ) {\n                addFieldValue(getters.get(field).get(vc), records);\n            } else if ( vc.hasAttribute(field) ) {\n                addFieldValue(vc.getAttribute(field, null), records);\n            } else if ( isWildCard(field) ) {\n                Set<String> wildVals = new HashSet<String>();\n                for ( Map.Entry<String,Object> elt : vc.getAttributes().entrySet()) {\n                    if ( elt.getKey().startsWith(field.substring(0, field.length() - 1)) ) {\n                        wildVals.add(elt.getValue().toString());\n                    }\n                }\n\n                String val = MISSING_DATA;\n                if ( wildVals.size() > 0 ) {\n                    List<String> toVal = new ArrayList<String>(wildVals);\n                    Collections.sort(toVal);\n                    val = Utils.join(\",\", toVal);\n                }\n\n                addFieldValue(val, records);\n            } else if ( ! allowMissingData ) {\n                throw new UserException(String.format(\"Missing field %s in vc %s at %s\", field, vc.getSource(), vc));\n            } else {\n                addFieldValue(MISSING_DATA, records);\n            }\n        }\n\n        if (addGenotypeFields) {\n            for (final String sample : samples) {\n                for (final String gf : genotypeFields) {\n                    if (vc.hasGenotype(sample) && vc.getGenotype(sample).hasAttribute(gf))\n                        addFieldValue(vc.getGenotype(sample).getAttribute(gf),records);\n                    else\n                        addFieldValue(MISSING_DATA, records);\n                }\n            }\n        }\n        return records;\n    }","id":41344,"modified_method":"/**\n     * Utility function that returns the list of values for each field in fields from vc.\n     *\n     * @param vc                the VariantContext whose field values we can to capture\n     * @param fields            a non-null list of fields to capture from VC\n     * @param genotypeFields    a (possibly null) list of fields to capture from each genotype\n     * @param samples           list of samples in vc\n     * @param allowMissingData  if false, then throws a UserException if any field isn't found in vc.  Otherwise provides a value of NA\n     * @param splitMultiAllelic if true, multiallelic variants are to be split into multiple records\n     * @return List of lists of field values\n     */\n    private static List<List<String>> extractFields(final VariantContext vc,\n                                                    final List<String> fields,\n                                                    final List<String> genotypeFields,\n                                                    final List<String> samples,\n                                                    final boolean allowMissingData,\n                                                    final boolean splitMultiAllelic) {\n        \n        final int numRecordsToProduce = splitMultiAllelic ? vc.getAlternateAlleles().size() : 1;\n        final List<List<String>> records = new ArrayList<List<String>>(numRecordsToProduce);\n\n        int numFields = fields.size();\n        final boolean addGenotypeFields = genotypeFields != null && !genotypeFields.isEmpty();\n        if ( addGenotypeFields )\n            numFields += genotypeFields.size() * samples.size();\n\n        for ( int i = 0; i < numRecordsToProduce; i++ )\n            records.add(new ArrayList<String>(numFields));\n\n        for ( String field : fields ) {\n\n            if ( splitMultiAllelic && field.equals(\"ALT\") ) { // we need to special case the ALT field when splitting out multi-allelic records\n                addFieldValue(splitAltAlleles(vc), records);\n            } else if ( getters.containsKey(field) ) {\n                addFieldValue(getters.get(field).get(vc), records);\n            } else if ( vc.hasAttribute(field) ) {\n                addFieldValue(vc.getAttribute(field, null), records);\n            } else if ( isWildCard(field) ) {\n                Set<String> wildVals = new HashSet<String>();\n                for ( Map.Entry<String,Object> elt : vc.getAttributes().entrySet()) {\n                    if ( elt.getKey().startsWith(field.substring(0, field.length() - 1)) ) {\n                        wildVals.add(elt.getValue().toString());\n                    }\n                }\n\n                String val = MISSING_DATA;\n                if ( wildVals.size() > 0 ) {\n                    List<String> toVal = new ArrayList<String>(wildVals);\n                    Collections.sort(toVal);\n                    val = Utils.join(\",\", toVal);\n                }\n\n                addFieldValue(val, records);\n            } else if ( ! allowMissingData ) {\n                throw new UserException(String.format(\"Missing field %s in vc %s at %s\", field, vc.getSource(), vc));\n            } else {\n                addFieldValue(MISSING_DATA, records);\n            }\n        }\n\n        if ( addGenotypeFields ) {\n            for ( final String sample : samples ) {\n                for ( final String gf : genotypeFields ) {\n                    if ( vc.hasGenotype(sample) && vc.getGenotype(sample).hasAttribute(gf) )\n                        addFieldValue(vc.getGenotype(sample).getAttribute(gf), records);\n                    else\n                        addFieldValue(MISSING_DATA, records);\n                }\n            }\n        }\n\n        return records;\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null ) // RodWalkers can make funky map calls\n            return 0;\n\n        for ( VariantContext vc : tracker.getValues(variants, context.getLocation())) {\n            if ( showFiltered || vc.isNotFiltered() ) {\n                for ( final List<String> record : extractFields(vc, fieldsToTake, genotypeFieldsToTake, samples,\n                        ALLOW_MISSING_DATA, splitMultiAllelic) )\n                    out.println(Utils.join(\"\\t\", record));\n            }\n        }\n        \n        return 1;\n    }","id":41345,"modified_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( tracker == null ) // RodWalkers can make funky map calls\n            return 0;\n\n        for ( VariantContext vc : tracker.getValues(variants, context.getLocation())) {\n            nRecords++;\n            if ( showFiltered || vc.isNotFiltered() ) {\n                for ( final List<String> record : extractFields(vc, fieldsToTake, genotypeFieldsToTake, samples, ALLOW_MISSING_DATA, splitMultiAllelic) ) {\n                    if ( moltenizeOutput )\n                        emitMoltenizedOutput(record);\n                    else\n                        out.println(Utils.join(\"\\t\", record));\n                }\n            }\n        }\n        \n        return 1;\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true)\n    public void testMultiAllelicOneRecord() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableMultiAllelicCmd(\"\"),\n                Arrays.asList(\"13dd36c08be6c800f23988e6000d963e\"));\n        executeTest(\"testMultiAllelicOneRecord\", spec).getFirst();\n    }","id":41346,"modified_method":"@Test(enabled = true)\n    public void testMultiAllelicOneRecord() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableMultiAllelicCmd(\"\"),\n                Arrays.asList(\"13dd36c08be6c800f23988e6000d963e\"));\n        executeTest(\"testMultiAllelicOneRecord\", spec);\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true)\n    public void testMultiAllelicSplitRecords() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableMultiAllelicCmd(\" -SMA\"),\n                Arrays.asList(\"17a0fc80409d2fc00ad2bbb94b3a346b\"));\n        executeTest(\"testMultiAllelicSplitRecords\", spec).getFirst();\n    }","id":41347,"modified_method":"@Test(enabled = true)\n    public void testMultiAllelicSplitRecords() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableMultiAllelicCmd(\" -SMA\"),\n                Arrays.asList(\"17a0fc80409d2fc00ad2bbb94b3a346b\"));\n        executeTest(\"testMultiAllelicSplitRecords\", spec);\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true)\n    public void testComplexVariantsToTable() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableCmd(\" -AMD\"),\n                Arrays.asList(\"e8f771995127b727fb433da91dd4ee98\"));\n        executeTest(\"testComplexVariantsToTable\", spec).getFirst();\n    }","id":41348,"modified_method":"@Test(enabled = true)\n    public void testComplexVariantsToTable() {\n        WalkerTestSpec spec = new WalkerTestSpec(variantsToTableCmd(\" -AMD\"),\n                Arrays.asList(\"e8f771995127b727fb433da91dd4ee98\"));\n        executeTest(\"testComplexVariantsToTable\", spec);\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private String variantsToTableCmd(String moreArgs) {\n        return \"-R \" + hg18Reference +\n                \" --variant:vcf \" + testDir + \"/soap_gatk_annotated.vcf\" +\n                \" -T VariantsToTable\" +\n                \" -F CHROM -F POS -F ID -F REF -F ALT -F QUAL -F FILTER -F TRANSITION -F DP -F SB -F set -F RankSumP -F refseq.functionalClass*\" +\n                \" -L chr1 -o %s\" + moreArgs;\n    }","id":41349,"modified_method":"private String variantsToTableCmd(String moreArgs) {\n        return \"-R \" + hg18Reference +\n                \" --variant:vcf \" + testDir + \"soap_gatk_annotated.vcf\" +\n                \" -T VariantsToTable\" +\n                \" -F CHROM -F POS -F ID -F REF -F ALT -F QUAL -F FILTER -F TRANSITION -F DP -F SB -F set -F RankSumP -F refseq.functionalClass*\" +\n                \" -L chr1 -o %s\" + moreArgs;\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"private String variantsToTableMultiAllelicCmd(String moreArgs) {\n        return \"-R \" + b37KGReference +\n                \" --variant \" + testDir + \"/multiallelic.vcf\" +\n                \" -T VariantsToTable\" +\n                \" -F CHROM -F POS -F ID -F REF -F ALT -F QUAL -F MULTI-ALLELIC -F AC -F AF\" +\n                \" -o %s\" + moreArgs;\n    }","id":41350,"modified_method":"private String variantsToTableMultiAllelicCmd(String moreArgs) {\n        return \"-R \" + b37KGReference +\n                \" --variant \" + testDir + \"multiallelic.vcf\" +\n                \" -T VariantsToTable\" +\n                \" -F CHROM -F POS -F ID -F REF -F ALT -F QUAL -F MULTI-ALLELIC -F AC -F AF\" +\n                \" -o %s\" + moreArgs;\n    }","commit_id":"2f151b24f5626328a804e9b9dfae7cc4fb5caef5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(reference, null));\n\t}","id":41351,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path, or a fully\n\t * qualified URL (starting with http:// or https://).\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path, or\n\t *            a fully qualified http url.\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location)\n\t{\n\t\treturn new HeaderContributor(new CSSHeaderContributor(location, null));\n\t}","id":41352,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(returnLocationWithContextPath(location));\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptReferenceHeaderContributor(scope, path));\n\t}","id":41353,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a reference to a css file that should be contributed to the page\n\t * header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addCssReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new CSSReferenceHeaderContributor(scope, path, null));\n\t}","id":41354,"modified_method":"/**\n\t * Adds a reference to a css file that should be contributed to the page\n\t * header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addCssReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a reference to a javascript file that should be contributed to the\n\t * page header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addJavaScriptReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new JavaScriptReferenceHeaderContributor(scope, path));\n\t}","id":41355,"modified_method":"/**\n\t * Adds a reference to a javascript file that should be contributed to the\n\t * page header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addJavaScriptReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(ResourceReference reference, final String media)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(reference, media));\n\t}","id":41356,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final ResourceReference reference,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(reference, media);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptReferenceHeaderContributor(reference));\n\t}","id":41357,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(scope, path, media));\n\t}","id":41358,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(scope, path, null));\n\t}","id":41359,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a JavaScript file that lives in the web\n\t * application directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final String location)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptHeaderContributor(location));\n\t}","id":41360,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a JavaScript file that lives in the web\n\t * application directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final String location)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderJavascriptReference(returnLocationWithContextPath(location));\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path, or a fully\n\t * qualified URL (starting with http:// or https://).\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path, or\n\t *            a fully qualified http url.\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location, final String media)\n\t{\n\t\treturn new HeaderContributor(new CSSHeaderContributor(location, media));\n\t}","id":41361,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location, final String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(returnLocationWithContextPath(location), media);\n\t\t\t}\n\t\t});\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.IHeaderResponse#renderCSSReference(wicket.markup.html.ResourceReference)\n\t */\n\tpublic final void renderCSSReference(ResourceReference reference)\n\t{\n\t\tif (wasRendered(reference) == false)\n\t\t{\n\t\t\tfinal CharSequence url = RequestCycle.get().urlFor(reference);\n\t\t\tresponse.write(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\");\n\t\t\tresponse.write(url);\n\t\t\tresponse.println(\"\\\"><\/link>\");\n\t\t\tmarkRendered(reference);\n\t\t}\n\t}","id":41362,"modified_method":"/**\n\t * @see wicket.markup.html.IHeaderResponse#renderCSSReference(wicket.markup.html.ResourceReference)\n\t */\n\tpublic final void renderCSSReference(ResourceReference reference)\n\t{\n\t\tCharSequence url = RequestCycle.get().urlFor(reference);\n\t\trenderCSSReference(url.toString(), null);\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.IHeaderResponse#renderJavascriptReference(wicket.markup.html.ResourceReference)\n\t */\n\tpublic final void renderJavascriptReference(ResourceReference reference)\n\t{\n\t\tif (wasRendered(reference) == false)\n\t\t{\n\t\t\tJavascriptUtils.writeJavascriptUrl(getResponse(), RequestCycle.get().urlFor(reference));\n\t\t\tmarkRendered(reference);\n\t\t}\n\t}","id":41363,"modified_method":"/**\n\t * @see wicket.markup.html.IHeaderResponse#renderJavascriptReference(wicket.markup.html.ResourceReference)\n\t */\n\tpublic final void renderJavascriptReference(ResourceReference reference)\n\t{\n\t\tCharSequence url = RequestCycle.get().urlFor(reference);\n\t\trenderJavascriptReference(url.toString());\n\t}","commit_id":"fd17ac37e36652ed9afaea963792cafe4d4f540e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#onComponentTag(wicket.markup.ComponentTag)\n\t */\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\tcheckComponentTag(tag, \"applet\");\n\t\ttag.put(\"code\", HostApplet.class.getName());\n\t\tfinal String jarName = appletClass.getName() + \".jar\";\n\t\tfinal ResourceReference jarResourceReference = new ResourceReference(jarName)\n\t\t{\n\t\t\tprotected Resource newResource()\n\t\t\t{\n\t\t\t\t// Create JAR resource\n\t\t\t\tfinal JarResourceFactory factory = new JarResourceFactory();\n\t\t\t\tfactory.addClassClosures(classes);\n\t\t\t\treturn factory.getResource();\n\t\t\t}\n\t\t};\n\n\t\tfinal String jarResourceUrl = getRequestCycle().urlFor(jarResourceReference);\n\t\tfinal String codebase = Strings.beforeLastPathComponent(jarResourceUrl, '/') + '/';\n\t\ttag.put(\"codebase\", codebase);\n\t\ttag.put(\"archive\", jarName);\n\t\ttag.put(\"name\", getPageRelativePath().replace(':', '_'));\n\t\tfinal int width = getWidth();\n\t\tif (width != -1)\n\t\t{\n\t\t\ttag.put(\"width\", width);\n\t\t}\n\t\tfinal int height = getHeight();\n\t\tif (height != -1)\n\t\t{\n\t\t\ttag.put(\"height\", height);\n\t\t}\n\t\ttag.setType(XmlTag.OPEN);\n\t\tsuper.onComponentTag(tag);\n\t}","id":41364,"modified_method":"/**\n\t * @see wicket.Component#onComponentTag(wicket.markup.ComponentTag)\n\t */\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\tcheckComponentTag(tag, \"applet\");\n\t\ttag.put(\"code\", HostApplet.class.getName());\n\t\tfinal String jarName = appletClass.getName() + \".jar\";\n\t\tfinal ResourceReference jarResourceReference = new ResourceReference(jarName)\n\t\t{\n\t\t\tprotected Resource newResource()\n\t\t\t{\n\t\t\t\t// Create JAR resource\n\t\t\t\tfinal JarResourceFactory factory = new JarResourceFactory();\n\t\t\t\tfactory.addClassClosures(classes);\n\t\t\t\treturn factory.getResource();\n\t\t\t}\n\t\t};\n\n\t\tfinal String jarResourceUrl = getRequestCycle().urlFor(jarResourceReference).toString();\n\t\tfinal String codebase = Strings.beforeLastPathComponent(jarResourceUrl, '/') + '/';\n\t\ttag.put(\"codebase\", codebase);\n\t\ttag.put(\"archive\", jarName);\n\t\ttag.put(\"name\", getPageRelativePath().replace(':', '_'));\n\t\tfinal int width = getWidth();\n\t\tif (width != -1)\n\t\t{\n\t\t\ttag.put(\"width\", width);\n\t\t}\n\t\tfinal int height = getHeight();\n\t\tif (height != -1)\n\t\t{\n\t\t\ttag.put(\"height\", height);\n\t\t}\n\t\ttag.setType(XmlTag.OPEN);\n\t\tsuper.onComponentTag(tag);\n\t}","commit_id":"02772b55a64d1072b27b4685d9fd38e0c5941477","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testResourceReferenceWithParamsUrl() throws Exception\n\t{\n\t\ttester.setupRequestAndResponse();\n\t\tWebRequestCycle cycle = tester.createRequestCycle();\n\n\t\tResourceReference rr = new ResourceReference(\"test\");\n\t\tCharSequence url = cycle.urlFor(rr, new ValueMap(\"param=value\", \"\"));\n\t\tassertEquals(\"resources/org.apache.wicket.Application/test?param=value\", url);\n\n\t\trr = new ResourceReference(SharedResourceUrlTest.class, \"test\");\n\t\turl = cycle.urlFor(rr, new ValueMap(\"param=value\", \"\"));\n\t\tassertEquals(\"resources/org.apache.wicket.SharedResourceUrlTest/test?param=value\", url);\n\t}","id":41365,"modified_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testResourceReferenceWithParamsUrl() throws Exception\n\t{\n\t\tResourceReference rr = new PackageResourceReference(\"test\");\n\t\tCharSequence url = tester.getRequestCycle().urlFor(rr,\n\t\t\tnew PageParameters(\"param=value\", \"\")).toString();\n\t\tassertEquals(\"wicket/resource/org.apache.wicket.Application/test?param=value\", url);\n\n\t\trr = new PackageResourceReference(SharedResourceUrlTest.class, \"test\");\n\t\turl = tester.getRequestCycle().urlFor(rr, new PageParameters(\"param=value\", \"\")).toString();\n\t\tassertEquals(\"wicket/resource/org.apache.wicket.SharedResourceUrlTest/test?param=value\", url);\n\t}","commit_id":"c74ea40ee8ca0e66391d61f23c452c8f9d37c48a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testResourceReferenceUrl() throws Exception\n\t{\n\t\ttester.setupRequestAndResponse();\n\t\tWebRequestCycle cycle = tester.createRequestCycle();\n\n\t\tResourceReference rr = new ResourceReference(\"test\");\n\t\tCharSequence url = cycle.urlFor(rr);\n\t\tassertEquals(\"resources/org.apache.wicket.Application/test\", url);\n\n\t\trr = new ResourceReference(SharedResourceUrlTest.class, \"test\");\n\t\turl = cycle.urlFor(rr);\n\t\tassertEquals(\"resources/org.apache.wicket.SharedResourceUrlTest/test\", url);\n\t}","id":41366,"modified_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testResourceReferenceUrl() throws Exception\n\t{\n\t\tResourceReference rr = new PackageResourceReference(\"test\");\n\t\tCharSequence url = tester.getRequestCycle().urlFor(rr).toString();\n\t\tassertEquals(\"wicket/resource/org.apache.wicket.Application/test\", url);\n\n\t\trr = new PackageResourceReference(SharedResourceUrlTest.class, \"test\");\n\t\turl = tester.getRequestCycle().urlFor(rr).toString();\n\t\tassertEquals(\"wicket/resource/org.apache.wicket.SharedResourceUrlTest/test\", url);\n\t}","commit_id":"c74ea40ee8ca0e66391d61f23c452c8f9d37c48a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptReferenceHeaderContributor(reference));\n\t}","id":41367,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a reference to a javascript file that should be contributed to the\n\t * page header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addJavaScriptReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new JavaScriptReferenceHeaderContributor(scope, path));\n\t}","id":41368,"modified_method":"/**\n\t * Adds a reference to a javascript file that should be contributed to the\n\t * page header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addJavaScriptReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a JavaScript file that lives in the web\n\t * application directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final String location)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptHeaderContributor(location));\n\t}","id":41369,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a JavaScript file that lives in the web\n\t * application directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final String location)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderJavascriptReference(returnLocationWithContextPath(location));\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a reference to a css file that should be contributed to the page\n\t * header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addCssReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new CSSReferenceHeaderContributor(scope, path, null));\n\t}","id":41370,"modified_method":"/**\n\t * Adds a reference to a css file that should be contributed to the page\n\t * header.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t */\n\tpublic final void addCssReference(final Class scope, final String path)\n\t{\n\t\taddContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(ResourceReference reference, final String media)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(reference, media));\n\t}","id":41371,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final ResourceReference reference,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(reference, media);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location, final String media)\n\t{\n\t\treturn new HeaderContributor(new CSSHeaderContributor(location, media));\n\t}","id":41372,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location, final String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(returnLocationWithContextPath(location), media);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new JavaScriptReferenceHeaderContributor(scope, path));\n\t}","id":41373,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a java script file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forJavaScript(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderJavascriptReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(scope, path, null));\n\t}","id":41374,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(reference, null));\n\t}","id":41375,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param reference\n\t * \n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final ResourceReference reference)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new CSSReferenceHeaderContributor(scope, path, media));\n\t}","id":41376,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in a package.\n\t * \n\t * @param scope\n\t *            The scope of the package resource (typically the class of the\n\t *            caller, or a class that lives in the package where the\n\t *            resource lives).\n\t * @param path\n\t *            The path\n\t * @param media\n\t *            The media type for this CSS (\"print\", \"screen\", etc.)\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final Class scope, final String path,\n\t\t\tfinal String media)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tCompressedResourceReference reference = new CompressedResourceReference(scope, path);\n\t\t\t\tresponse.renderCSSReference(reference);\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location)\n\t{\n\t\treturn new HeaderContributor(new CSSHeaderContributor(location, null));\n\t}","id":41377,"modified_method":"/**\n\t * Returns a new instance of {@link HeaderContributor} with a header\n\t * contributor that references a CSS file that lives in the web application\n\t * directory and that is addressed relative to the context path.\n\t * \n\t * @param location\n\t *            The location of the css file relative to the context path\n\t * @return the new header contributor instance\n\t */\n\tpublic static final HeaderContributor forCss(final String location)\n\t{\n\t\treturn new HeaderContributor(new IHeaderContributor()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void renderHead(IHeaderResponse response)\n\t\t\t{\n\t\t\t\tresponse.renderCSSReference(returnLocationWithContextPath(location));\n\t\t\t}\n\t\t});\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see wicket.markup.html.IHeaderResponse#renderCSSReference(wicket.markup.html.ResourceReference)\r\n\t */\r\n\tpublic final void renderCSSReference(ResourceReference reference)\r\n\t{\r\n\t\tif (wasRendered(reference) == false)\r\n\t\t{\r\n\t\t\tfinal CharSequence url = RequestCycle.get().urlFor(reference);\r\n\t\t\tresponse.write(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\");\r\n\t\t\tresponse.write(url);\r\n\t\t\tresponse.println(\"\\\"><\/link>\");\r\n\t\t\tmarkRendered(reference);\r\n\t\t}\r\n\t}","id":41378,"modified_method":"/**\r\n\t * @see wicket.markup.html.IHeaderResponse#renderCSSReference(wicket.markup.html.ResourceReference)\r\n\t */\r\n\tpublic final void renderCSSReference(ResourceReference reference)\r\n\t{\n\t\tCharSequence url = RequestCycle.get().urlFor(reference);\r\n\t\trenderCSSReference(url.toString(), null);\r\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see wicket.markup.html.IHeaderResponse#renderJavascriptReference(wicket.markup.html.ResourceReference)\r\n\t */\r\n\tpublic final void renderJavascriptReference(ResourceReference reference)\r\n\t{\r\n\t\tif (wasRendered(reference) == false)\r\n\t\t{\r\n\t\t\tJavascriptUtils.writeJavascriptUrl(getResponse(), RequestCycle.get().urlFor(reference));\r\n\t\t\tmarkRendered(reference);\r\n\t\t}\r\n\t}","id":41379,"modified_method":"/**\r\n\t * @see wicket.markup.html.IHeaderResponse#renderJavascriptReference(wicket.markup.html.ResourceReference)\r\n\t */\r\n\tpublic final void renderJavascriptReference(ResourceReference reference)\r\n\t{\n\t\tCharSequence url = RequestCycle.get().urlFor(reference);\r\n\t\trenderJavascriptReference(url.toString());\r\n\t}","commit_id":"f3c1a31ddb79bd6b811ef7c1b0a76ad665afff82","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param validator\n\t *            The form validator to add to the formValidators Object (which\n\t *            may be an array of IFormValidators or a single instance, for\n\t *            efficiency)\n\t */\n\tprivate void formValidators_add(final IFormValidator validator)\n\t{\n\t\tif (this.formValidators == null)\n\t\t{\n\t\t\tthis.formValidators = validator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Get current list size\n\t\t\tfinal int size = formValidators_size();\n\n\t\t\t// Create array that holds size + 1 elements\n\t\t\tfinal IFormValidator[] validators = new IFormValidator[size + 1];\n\n\t\t\t// Loop through existing validators copying them\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tvalidators[i] = formValidators_get(i);\n\t\t\t}\n\n\t\t\t// Add new validator to the end\n\t\t\tvalidators[size] = validator;\n\n\t\t\t// Save new validator list\n\t\t\tthis.formValidators = validators;\n\t\t}\n\t}","id":41380,"modified_method":"/**\n\t * @param validator\n\t *            The form validator to add to the formValidators Object (which\n\t *            may be an array of IFormValidators or a single instance, for\n\t *            efficiency)\n\t */\n\tprivate void formValidators_add(final IFormValidator validator)\n\t{\n\t\tif (formValidators == null)\n\t\t{\n\t\t\tformValidators = validator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Get current list size\n\t\t\tfinal int size = formValidators_size();\n\n\t\t\t// Create array that holds size + 1 elements\n\t\t\tfinal IFormValidator[] validators = new IFormValidator[size + 1];\n\n\t\t\t// Loop through existing validators copying them\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tvalidators[i] = formValidators_get(i);\n\t\t\t}\n\n\t\t\t// Add new validator to the end\n\t\t\tvalidators[size] = validator;\n\n\t\t\t// Save new validator list\n\t\t\tformValidators = validators;\n\t\t}\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the method used to submit the form. Defaults to 'post'. Override\n\t * this if you have a requirement to alter this behavior.\n\t * \n\t * @return the method used to submit the form.\n\t */\n\tprotected String getMethod()\n\t{\n\t\treturn METHOD_POST;\n\t}","id":41381,"modified_method":"/**\n\t * Gets the method used to submit the form. Defaults to either what is\n\t * explicitly defined in the markup or 'post'. Override this if you have a\n\t * requirement to alter this behavior.\n\t * \n\t * @return the method used to submit the form.\n\t */\n\tprotected String getMethod()\n\t{\n\t\tString method = getMarkupAttributes().getString(\"method\");\n\t\treturn (method != null) ? method : METHOD_POST;\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"private final IFormValidator formValidators_remove(int index)\n\t{\n\t\tif (formValidators instanceof IFormValidator)\n\t\t{\n\t\t\tif (index == 0)\n\t\t\t{\n\t\t\t\tfinal IFormValidator removed = (IFormValidator)formValidators;\n\t\t\t\tformValidators = null;\n\t\t\t\treturn removed;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfinal IFormValidator[] validators = (IFormValidator[])formValidators;\n\t\t\tfinal IFormValidator removed = validators[index];\n\t\t\t// check if we can collapse array of 1 element into a single object\n\t\t\tif (validators.length == 2)\n\t\t\t{\n\t\t\t\tformValidators = validators[1 - index];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFormValidator[] newValidators = new IFormValidator[validators.length - 1];\n\t\t\t\tint j = 0;\n\t\t\t\tfor (int i = 0; i < validators.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i != index)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewValidators[j++] = validators[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.formValidators = newValidators;\n\t\t\t}\n\t\t\treturn removed;\n\t\t}\n\t}","id":41382,"modified_method":"private final IFormValidator formValidators_remove(int index)\n\t{\n\t\tif (formValidators instanceof IFormValidator)\n\t\t{\n\t\t\tif (index == 0)\n\t\t\t{\n\t\t\t\tfinal IFormValidator removed = (IFormValidator)formValidators;\n\t\t\t\tformValidators = null;\n\t\t\t\treturn removed;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfinal IFormValidator[] validators = (IFormValidator[])formValidators;\n\t\t\tfinal IFormValidator removed = validators[index];\n\t\t\t// check if we can collapse array of 1 element into a single object\n\t\t\tif (validators.length == 2)\n\t\t\t{\n\t\t\t\tformValidators = validators[1 - index];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFormValidator[] newValidators = new IFormValidator[validators.length - 1];\n\t\t\t\tint j = 0;\n\t\t\t\tfor (int i = 0; i < validators.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i != index)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewValidators[j++] = validators[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tformValidators = newValidators;\n\t\t\t}\n\t\t\treturn removed;\n\t\t}\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Checks if the specified form component visible and is attached to a page\n\t * \n\t * @param fc\n\t *            form component\n\t * \n\t * @return true if the form component and all its parents are visible and\n\t *         there component is in page's hierarchy\n\t */\n\tprivate boolean isFormComponentVisibleInPage(FormComponent fc)\n\t{\n\t\tif (fc == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Argument `fc` cannot be null\");\n\t\t}\n\t\tComponent c = fc;\n\t\tComponent last = fc;\n\t\twhile (c != null)\n\t\t{\n\t\t\tif (c.isRenderAllowed() && c.isVisible())\n\t\t\t{\n\t\t\t\tlast = c;\n\t\t\t\tc = c.getParent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn last == this.findPage();\n\t}","id":41383,"modified_method":"/**\n\t * Checks if the specified form component visible and is attached to a page\n\t * \n\t * @param fc\n\t *            form component\n\t * \n\t * @return true if the form component and all its parents are visible and\n\t *         there component is in page's hierarchy\n\t */\n\tprivate boolean isFormComponentVisibleInPage(FormComponent fc)\n\t{\n\t\tif (fc == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Argument `fc` cannot be null\");\n\t\t}\n\t\tComponent c = fc;\n\t\tComponent last = fc;\n\t\twhile (c != null)\n\t\t{\n\t\t\tif (c.isRenderAllowed() && c.isVisible())\n\t\t\t{\n\t\t\t\tlast = c;\n\t\t\t\tc = c.getParent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn last == findPage();\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Append an additional hidden input tag to support anchor tags that can\n\t * submit a form.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t */\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tif (isRootForm())\n\t\t{\n\t\t\t// get the hidden field id\n\t\t\tString nameAndId = getHiddenFieldId();\n\n\t\t\t// render the hidden field\n\t\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(\n\t\t\t\t\t\"<div style=\\\"display:none\\\"><input type=\\\"hidden\\\" name=\\\"\").append(nameAndId)\n\t\t\t\t\t.append(\"\\\" id=\\\"\").append(nameAndId).append(\"\\\" /><\/div>\");\n\t\t\tgetResponse().write(buffer);\n\n\t\t\t// if a default button was set, handle the rendering of that\n\t\t\tif (defaultButton != null && defaultButton.isVisibleInHierarchy() &&\n\t\t\t\t\tdefaultButton.isEnabled())\n\t\t\t{\n\t\t\t\tappendDefaultButtonField(markupStream, openTag);\n\t\t\t}\n\t\t}\n\n\t\t// do the rest of the processing\n\t\tsuper.onComponentTagBody(markupStream, openTag);\n\t}","id":41384,"modified_method":"/**\n\t * Append an additional hidden input tag to support anchor tags that can\n\t * submit a form.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t */\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tif (isRootForm())\n\t\t{\n\t\t\t// get the hidden field id\n\t\t\tString nameAndId = getHiddenFieldId();\n\n\t\t\t// render the hidden field\n\t\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(\n\t\t\t\t\t\"<div style=\\\"display:none\\\"><input type=\\\"hidden\\\" name=\\\"\").append(nameAndId)\n\t\t\t\t\t.append(\"\\\" id=\\\"\").append(nameAndId).append(\"\\\" />\");\n\t\t\tString method = getMethod().toLowerCase();\n\t\t\t// if it's a get, did put the parameters in the action attribute,\n\t\t\t// and have to write the url parameters as hidden fields\n\t\t\tif (method.equals(\"get\"))\n\t\t\t{\n\t\t\t\tString url = urlFor(IFormSubmitListener.INTERFACE).toString();\n\t\t\t\tint i = url.indexOf('?');\n\t\t\t\tString[] params = ((i > -1) ? url.substring(i + 1) : url).split(\"&\");\n\t\t\t\tfor (int j = 0; j < params.length; j++)\n\t\t\t\t{\n\t\t\t\t\tString[] pair = params[j].split(\"=\");\n\t\t\t\t\tbuffer.append(\"<input type=\\\"hidden\\\" name=\\\"\").append(pair[0]).append(\n\t\t\t\t\t\t\t\"\\\" value=\\\"\").append(pair.length > 1 ? pair[1] : \"\").append(\"\\\" />\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer.append(\"<\/div>\");\n\t\t\tgetResponse().write(buffer);\n\n\t\t\t// if a default button was set, handle the rendering of that\n\t\t\tif (defaultButton != null && defaultButton.isVisibleInHierarchy() &&\n\t\t\t\t\tdefaultButton.isEnabled())\n\t\t\t{\n\t\t\t\tappendDefaultButtonField(markupStream, openTag);\n\t\t\t}\n\t\t}\n\n\t\t// do the rest of the processing\n\t\tsuper.onComponentTagBody(markupStream, openTag);\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The number of form validators in the formValidators Object (which\n\t *         may be an array of IFormValidators or a single instance, for\n\t *         efficiency)\n\t */\n\tprivate int formValidators_size()\n\t{\n\t\tif (this.formValidators == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (this.formValidators instanceof IFormValidator[])\n\t\t{\n\t\t\treturn ((IFormValidator[])formValidators).length;\n\t\t}\n\t\treturn 1;\n\t}","id":41385,"modified_method":"/**\n\t * @return The number of form validators in the formValidators Object (which\n\t *         may be an array of IFormValidators or a single instance, for\n\t *         efficiency)\n\t */\n\tprivate int formValidators_size()\n\t{\n\t\tif (formValidators == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (formValidators instanceof IFormValidator[])\n\t\t{\n\t\t\treturn ((IFormValidator[])formValidators).length;\n\t\t}\n\t\treturn 1;\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets form validator from formValidators Object (which may be an array of\n\t * IFormValidators or a single instance, for efficiency) at the given index\n\t * \n\t * @param index\n\t *            The index of the validator to get\n\t * @return The form validator\n\t */\n\tprivate IFormValidator formValidators_get(int index)\n\t{\n\t\tif (this.formValidators == null)\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (this.formValidators instanceof IFormValidator[])\n\t\t{\n\t\t\treturn ((IFormValidator[])formValidators)[index];\n\t\t}\n\t\treturn (IFormValidator)formValidators;\n\t}","id":41386,"modified_method":"/**\n\t * Gets form validator from formValidators Object (which may be an array of\n\t * IFormValidators or a single instance, for efficiency) at the given index\n\t * \n\t * @param index\n\t *            The index of the validator to get\n\t * @return The form validator\n\t */\n\tprivate IFormValidator formValidators_get(int index)\n\t{\n\t\tif (formValidators == null)\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (formValidators instanceof IFormValidator[])\n\t\t{\n\t\t\treturn ((IFormValidator[])formValidators)[index];\n\t\t}\n\t\treturn (IFormValidator)formValidators;\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.Component#onComponentTag(ComponentTag)\n\t */\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\tsuper.onComponentTag(tag);\n\n\t\tcheckComponentTag(tag, \"form\");\n\n\t\tif (isRootForm())\n\t\t{\n\t\t\ttag.put(\"method\", getMethod());\n\t\t\ttag.put(\"action\", Strings.replaceAll(urlFor(IFormSubmitListener.INTERFACE), \"&\",\n\t\t\t\t\t\"&amp;\"));\n\n\t\t\tif (multiPart)\n\t\t\t{\n\t\t\t\ttag.put(\"enctype\", \"multipart/form-data\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// sanity check\n\t\t\t\tString enctype = (String)tag.getAttributes().get(\"enctype\");\n\t\t\t\tif (\"multipart/form-data\".equalsIgnoreCase(enctype))\n\t\t\t\t{\n\t\t\t\t\t// though not set explicitly in Java, this is a multipart\n\t\t\t\t\t// form\n\t\t\t\t\tsetMultiPart(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttag.setName(\"div\");\n\t\t\ttag.remove(\"method\");\n\t\t\ttag.remove(\"action\");\n\t\t\ttag.remove(\"enctype\");\n\t\t}\n\t}","id":41387,"modified_method":"/**\n\t * @see org.apache.wicket.Component#onComponentTag(ComponentTag)\n\t */\n\tprotected void onComponentTag(final ComponentTag tag)\n\t{\n\t\tsuper.onComponentTag(tag);\n\n\t\tcheckComponentTag(tag, \"form\");\n\n\t\tif (isRootForm())\n\t\t{\n\t\t\tString method = getMethod().toLowerCase();\n\t\t\ttag.put(\"method\", method);\n\t\t\tString url = urlFor(IFormSubmitListener.INTERFACE).toString();\n\t\t\tif (method.equals(\"get\"))\n\t\t\t{\n\t\t\t\tint i = url.indexOf('?');\n\t\t\t\tString action = (i > -1) ? url.substring(0, i) : \"\";\n\t\t\t\ttag.put(\"action\", action);\n\t\t\t\t// alternatively, we could just put an empty string here, so\n\t\t\t\t// that mounted paths stay in good order. I decided against this\n\t\t\t\t// as I'm not sure whether that could have side effects with\n\t\t\t\t// other encoders\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttag.put(\"action\", Strings.replaceAll(url, \"&\", \"&amp;\"));\n\t\t\t}\n\n\t\t\tif (multiPart)\n\t\t\t{\n\t\t\t\ttag.put(\"enctype\", \"multipart/form-data\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// sanity check\n\t\t\t\tString enctype = (String)tag.getAttributes().get(\"enctype\");\n\t\t\t\tif (\"multipart/form-data\".equalsIgnoreCase(enctype))\n\t\t\t\t{\n\t\t\t\t\t// though not set explicitly in Java, this is a multipart\n\t\t\t\t\t// form\n\t\t\t\t\tsetMultiPart(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttag.setName(\"div\");\n\t\t\ttag.remove(\"method\");\n\t\t\ttag.remove(\"action\");\n\t\t\ttag.remove(\"enctype\");\n\t\t}\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the default button. If set (not null), a hidden submit button will\n\t * be rendered right after the form tag, so that when users press enter in a\n\t * textfield, this button's action will be selected. If no default button is\n\t * set (so unset by calling this method with null), nothing additional is\n\t * rendered.\n\t * <p>\n\t * WARNING: note that this is a best effort only. Unfortunately having a\n\t * 'default' button in a form is ill defined in the standards, and of course\n\t * IE has it's own way of doing things.\n\t * <\/p>\n\t * There can be only one default button per form hierarchy. So if you set\n\t * default button on a nested form, it will actually delegate the call to\n\t * root form. <\/b>\n\t * \n\t * @param button\n\t *            The button to set as the default button, or null when you want\n\t *            to 'unset' any previously set default button\n\t */\n\tpublic final void setDefaultButton(Button button)\n\t{\n\t\tif (isRootForm())\n\t\t{\n\t\t\tthis.defaultButton = button;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgetRootForm().setDefaultButton(button);\n\t\t}\n\t}","id":41388,"modified_method":"/**\n\t * Sets the default button. If set (not null), a hidden submit button will\n\t * be rendered right after the form tag, so that when users press enter in a\n\t * textfield, this button's action will be selected. If no default button is\n\t * set (so unset by calling this method with null), nothing additional is\n\t * rendered.\n\t * <p>\n\t * WARNING: note that this is a best effort only. Unfortunately having a\n\t * 'default' button in a form is ill defined in the standards, and of course\n\t * IE has it's own way of doing things.\n\t * <\/p>\n\t * There can be only one default button per form hierarchy. So if you set\n\t * default button on a nested form, it will actually delegate the call to\n\t * root form. <\/b>\n\t * \n\t * @param button\n\t *            The button to set as the default button, or null when you want\n\t *            to 'unset' any previously set default button\n\t */\n\tpublic final void setDefaultButton(Button button)\n\t{\n\t\tif (isRootForm())\n\t\t{\n\t\t\tdefaultButton = button;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgetRootForm().setDefaultButton(button);\n\t\t}\n\t}","commit_id":"44353ac4c2bffbe696f82313d280786a4625abaf","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n    public ServiceBuilder newBuilder(FrontendFactory.Style s) {\n        DataBinding dataBinding;\n        final String dbn = getDatabindingName();\n        if (ToolConstants.JAXB_DATABINDING.equals(dbn)) {\n            dataBinding = new JAXBDataBinding();\n        } else if (ToolConstants.AEGIS_DATABINDING.equals(dbn)) {\n            dataBinding = new AegisDatabinding();\n        } else {\n            throw new ToolException(\"Unsupported databinding: \" + s);\n        }\n        AbstractServiceFactory builder = null;\n        if (Style.Jaxws.equals(s)) {\n            builder = new JaxwsServiceBuilder();\n        } else if (Style.Simple.equals(s)) {\n            builder = new SimpleServiceBuilder();\n        } else {\n            throw new ToolException(\"Unsupported frontend style: \" + s);\n        }\n        builder.setDataBinding(dataBinding);\n        builder.setServiceClass(serviceClass);\n        return builder;\n    }","id":41389,"modified_method":"@Override\n    public ServiceBuilder newBuilder(FrontendFactory.Style s) {\n        DataBinding dataBinding;\n        final String dbn = getDatabindingName();\n        if (ToolConstants.JAXB_DATABINDING.equals(dbn)) {\n            dataBinding = new JAXBDataBinding();\n        } else if (ToolConstants.AEGIS_DATABINDING.equals(dbn)) {\n            dataBinding = new AegisDatabinding();\n        } else {\n            throw new ToolException(\"Unsupported databinding: \" + dbn);\n        }\n        AbstractServiceFactory builder = null;\n        if (Style.Jaxws.equals(s)) {\n            builder = new JaxwsServiceBuilder();\n        } else if (Style.Simple.equals(s)) {\n            builder = new SimpleServiceBuilder();\n        } else {\n            throw new ToolException(\"Unsupported frontend style: \" + s);\n        }\n        builder.setDataBinding(dataBinding);\n        builder.setServiceClass(serviceClass);\n        return builder;\n    }","commit_id":"300a2ac586a0c624abe4d7ce6850540072a273ed","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public ServiceBuilder getServiceBuilder() throws ToolException {\n        Object beanFilesParameter = context.get(ToolConstants.CFG_BEAN_CONFIG);\n        List<String> beanDefinitions = new ArrayList<String>();\n        if (beanFilesParameter != null) {\n            if (beanFilesParameter instanceof String) {\n                beanDefinitions.add((String)beanFilesParameter);\n            } else if (beanFilesParameter instanceof List) {\n                // is there a better way to avoid the warning?\n                beanDefinitions.addAll((List<String>)beanFilesParameter);\n            } else {\n                String list[] = (String[])beanFilesParameter;\n                for (String b : list) {\n                    beanDefinitions.add(b);\n                }\n            }\n        }\n        ServiceBuilderFactory builderFactory = ServiceBuilderFactory.getInstance(beanDefinitions);\n        Class<?> clz = getServiceClass();\n        context.put(Class.class, clz);\n        if (clz.isInterface()) {\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.TRUE);\n            context.put(ToolConstants.SEI_CLASS, clz.getName());\n        } else {\n            context.put(ToolConstants.IMPL_CLASS, clz.getName());\n            if (clz.getInterfaces().length == 1) {\n                context.put(ToolConstants.SEI_CLASS, clz.getInterfaces()[0].getName());\n            }\n            // TODO: if it is simple frontend, and the impl class implements\n            // multiple interfaces\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.FALSE);\n        }\n        builderFactory.setServiceClass(clz);\n        builderFactory.setDatabindingName(getDataBindingName());\n        // The service class determines the frontend, so no need to pass it in\n        // twice.\n        ServiceBuilder builder = builderFactory.newBuilder();\n\n        builder.validate();\n\n        builder.setTransportId(getTransportId());\n        builder.setBus(getBus());\n        builder.setBindingId(getBindingId());\n\n        return builder;\n    }","id":41390,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public ServiceBuilder getServiceBuilder() throws ToolException {\n        Object beanFilesParameter = context.get(ToolConstants.CFG_BEAN_CONFIG);\n        List<String> beanDefinitions = new ArrayList<String>();\n        if (beanFilesParameter != null) {\n            if (beanFilesParameter instanceof String) {\n                beanDefinitions.add((String)beanFilesParameter);\n            } else if (beanFilesParameter instanceof List) {\n                // is there a better way to avoid the warning?\n                beanDefinitions.addAll((List<String>)beanFilesParameter);\n            } else {\n                String list[] = (String[])beanFilesParameter;\n                for (String b : list) {\n                    beanDefinitions.add(b);\n                }\n            }\n        }\n\n        \n        ServiceBuilderFactory builderFactory \n            = ServiceBuilderFactory.getInstance(beanDefinitions,\n                                                getDataBindingName());\n        Class<?> clz = getServiceClass();\n        context.put(Class.class, clz);\n        if (clz.isInterface()) {\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.TRUE);\n            context.put(ToolConstants.SEI_CLASS, clz.getName());\n        } else {\n            context.put(ToolConstants.IMPL_CLASS, clz.getName());\n            if (clz.getInterfaces().length == 1) {\n                context.put(ToolConstants.SEI_CLASS, clz.getInterfaces()[0].getName());\n            }\n            // TODO: if it is simple frontend, and the impl class implements\n            // multiple interfaces\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.FALSE);\n        }\n        builderFactory.setServiceClass(clz);\n        builderFactory.setDatabindingName(getDataBindingName());\n        // The service class determines the frontend, so no need to pass it in\n        // twice.\n        ServiceBuilder builder = builderFactory.newBuilder();\n\n        builder.validate();\n\n        builder.setTransportId(getTransportId());\n        builder.setBus(getBus());\n        builder.setBindingId(getBindingId());\n\n        return builder;\n    }","commit_id":"300a2ac586a0c624abe4d7ce6850540072a273ed","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public ServiceBuilder getServiceBuilder() throws ToolException {\n        Object beanFilesParameter = context.get(ToolConstants.CFG_BEAN_CONFIG);\n        List<String> beanDefinitions = new ArrayList<String>();\n        if (beanFilesParameter != null) {\n            if (beanFilesParameter instanceof String) {\n                beanDefinitions.add((String)beanFilesParameter);\n            } else if (beanFilesParameter instanceof List) {\n                // is there a better way to avoid the warning?\n                beanDefinitions.addAll((List<String>)beanFilesParameter);\n            } else {\n                String list[] = (String[]) beanFilesParameter;\n                for (String b : list) {\n                    beanDefinitions.add(b);\n                }\n            }\n        }\n        \n        ServiceBuilderFactory builderFactory = ServiceBuilderFactory.getInstance(beanDefinitions);\n        Class<?> clz = getServiceClass();\n        context.put(Class.class, clz);\n        if (clz.isInterface()) {\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.TRUE);\n            context.put(ToolConstants.SEI_CLASS, clz.getName());\n        } else {\n            context.put(ToolConstants.IMPL_CLASS, clz.getName());\n            if (clz.getInterfaces().length == 1) {\n                context.put(ToolConstants.SEI_CLASS, clz.getInterfaces()[0].getName());\n            }\n            //TODO: if it is simple frontend, and the impl class implments \n            //multiple interfaces\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.FALSE); \n        }\n        builderFactory.setServiceClass(clz);\n        builderFactory.setDatabindingName(getDataBindingName());\n        // The service class determines the frontend, so no need to pass it in twice.\n        ServiceBuilder builder = builderFactory.newBuilder();\n\n        builder.validate();\n\n        if (context.get(ToolConstants.CFG_ADDRESS) != null) {\n            String address = (String)context.get(ToolConstants.CFG_ADDRESS);\n            builder.setAddress(address);\n        } else {\n            builder.setAddress(DEFAULT_ADDRESS);\n        }\n        builder.setTransportId(getTransportId());\n        builder.setBus(getBus());\n        builder.setBindingId(getBindingId());\n\n        return builder;\n    }","id":41391,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public ServiceBuilder getServiceBuilder() throws ToolException {\n        Object beanFilesParameter = context.get(ToolConstants.CFG_BEAN_CONFIG);\n        List<String> beanDefinitions = new ArrayList<String>();\n        if (beanFilesParameter != null) {\n            if (beanFilesParameter instanceof String) {\n                beanDefinitions.add((String)beanFilesParameter);\n            } else if (beanFilesParameter instanceof List) {\n                // is there a better way to avoid the warning?\n                beanDefinitions.addAll((List<String>)beanFilesParameter);\n            } else {\n                String list[] = (String[]) beanFilesParameter;\n                for (String b : list) {\n                    beanDefinitions.add(b);\n                }\n            }\n        }\n        \n        ServiceBuilderFactory builderFactory \n            = ServiceBuilderFactory.getInstance(beanDefinitions,\n                                                getDataBindingName());\n        Class<?> clz = getServiceClass();\n        context.put(Class.class, clz);\n        if (clz.isInterface()) {\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.TRUE);\n            context.put(ToolConstants.SEI_CLASS, clz.getName());\n        } else {\n            context.put(ToolConstants.IMPL_CLASS, clz.getName());\n            if (clz.getInterfaces().length == 1) {\n                context.put(ToolConstants.SEI_CLASS, clz.getInterfaces()[0].getName());\n            }\n            //TODO: if it is simple frontend, and the impl class implments \n            //multiple interfaces\n            context.put(ToolConstants.GEN_FROM_SEI, Boolean.FALSE); \n        }\n        builderFactory.setServiceClass(clz);\n        builderFactory.setDatabindingName(getDataBindingName());\n        // The service class determines the frontend, so no need to pass it in twice.\n        ServiceBuilder builder = builderFactory.newBuilder();\n\n        builder.validate();\n\n        if (context.get(ToolConstants.CFG_ADDRESS) != null) {\n            String address = (String)context.get(ToolConstants.CFG_ADDRESS);\n            builder.setAddress(address);\n        } else {\n            builder.setAddress(DEFAULT_ADDRESS);\n        }\n        builder.setTransportId(getTransportId());\n        builder.setBus(getBus());\n        builder.setBindingId(getBindingId());\n\n        return builder;\n    }","commit_id":"300a2ac586a0c624abe4d7ce6850540072a273ed","url":"https://github.com/apache/cxf"},{"original_method":"public static ServiceBuilderFactory getInstance(List<String> beanDefinitions) {\n        ServiceBuilderFactory factory;\n        if (beanDefinitions == null || beanDefinitions.isEmpty()) {\n            factory = new DefaultServiceBuilderFactory();\n        } else {\n            factory = new SpringServiceBuilderFactory(beanDefinitions);\n        }\n        return factory;\n    }","id":41392,"modified_method":"public static ServiceBuilderFactory getInstance(List<String> beanDefinitions,\n                                                    String db) {\n        ServiceBuilderFactory factory;\n        if (beanDefinitions == null || beanDefinitions.isEmpty()) {\n            if (ToolConstants.JAXB_DATABINDING.equals(db)\n                || ToolConstants.AEGIS_DATABINDING.equals(db)) {\n                factory = new DefaultServiceBuilderFactory();\n            } else {\n                factory = new SpringServiceBuilderFactory(beanDefinitions);\n            }\n        } else {\n            factory = new SpringServiceBuilderFactory(beanDefinitions);\n        }\n        return factory;\n    }","commit_id":"300a2ac586a0c624abe4d7ce6850540072a273ed","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This is factored out to permit use in a unit test.\n     * \n     * @param bus\n     * @return\n     */\n    public static ApplicationContext getApplicationContext(List<String> additionalFilePathnames) {\n        BusApplicationContext busApplicationContext = BusFactory.getDefaultBus()\n            .getExtension(BusApplicationContext.class);\n        GenericApplicationContext appContext = new GenericApplicationContext(busApplicationContext);\n        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(appContext);\n        reader.loadBeanDefinitions(new ClassPathResource(\"META-INF/cxf/java2wsbeans.xml\"));\n        for (String pathname : additionalFilePathnames) {\n            try {\n                reader.loadBeanDefinitions(new FileSystemResource(pathname));\n            } catch (BeanDefinitionStoreException bdse) {\n                throw new ToolException(\"Unable to open bean definition file \" + pathname, bdse.getCause());\n            }\n        }\n\n        return appContext;\n    }","id":41393,"modified_method":"/**\n     * This is factored out to permit use in a unit test.\n     * \n     * @param bus\n     * @return\n     */\n    public static ApplicationContext getApplicationContext(List<String> additionalFilePathnames) {\n        BusApplicationContext busApplicationContext = BusFactory.getDefaultBus()\n            .getExtension(BusApplicationContext.class);\n        GenericApplicationContext appContext = new GenericApplicationContext(busApplicationContext);\n        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(appContext);\n        List<URL> urls = ClassLoaderUtils.getResources(\"META-INF/cxf/java2wsbeans.xml\", \n                                                       SpringServiceBuilderFactory.class);\n        for (URL url : urls) {\n            reader.loadBeanDefinitions(new UrlResource(url));\n        }\n        \n        for (String pathname : additionalFilePathnames) {\n            try {\n                reader.loadBeanDefinitions(new FileSystemResource(pathname));\n            } catch (BeanDefinitionStoreException bdse) {\n                throw new ToolException(\"Unable to open bean definition file \" + pathname, bdse.getCause());\n            }\n        }\n\n        return appContext;\n    }","commit_id":"300a2ac586a0c624abe4d7ce6850540072a273ed","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory)\n    {\n        super.prepareBeanFactory(beanFactory);\n\n        registerEditors(beanFactory);\n\n        addBeanPostProcessors(beanFactory,\n                              new MuleContextPostProcessor(muleContext),\n                              new GlobalNamePostProcessor(),\n                              new PostRegistrationActionsPostProcessor((MuleRegistryHelper) muleContext.getRegistry()),\n                              new DiscardedOptionalBeanPostProcessor(optionalObjectsController, (DefaultListableBeanFactory) beanFactory),\n                              new LifecycleStatePostProcessor(muleContext.getLifecycleManager().getState())\n        );\n\n        if (useNewParsingMechanism)\n        {\n            addBeanFactoryPostProcessor(new MuleObjectCreationBeanDefinitionRegistryPostProcessor(beanDefinitionRegistry -> {\n\n                applicationModel.executeOnEveryMuleComponentTree(componentModel -> {\n                    if (componentModel.isRoot())\n                    {\n                        beanDefinitionFactory.resolveComponentRecursively(applicationModel.getRootComponentModel(), componentModel, beanDefinitionRegistry,\n                                                                          (resolvedComponentModel, registry) -> {\n                                                                              if (resolvedComponentModel.isRoot())\n                                                                              {\n                                                                                  String nameAttribute = resolvedComponentModel.getNameAttribute();\n                                                                                  if (resolvedComponentModel.getIdentifier().equals(CONFIGURATION_IDENTIFIER))\n                                                                                  {\n                                                                                      nameAttribute = OBJECT_MULE_CONFIGURATION;\n                                                                                  }\n                                                                                  registry.registerBeanDefinition(nameAttribute, resolvedComponentModel.getBeanDefinition());\n                                                                              }\n                                                                          }, null);\n                    }\n                });\n            }));\n        }\n\n        beanFactory.registerSingleton(OBJECT_MULE_CONTEXT, muleContext);\n    }","id":41394,"modified_method":"@Override\n    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory)\n    {\n        super.prepareBeanFactory(beanFactory);\n\n        registerEditors(beanFactory);\n\n        addBeanPostProcessors(beanFactory,\n                              new MuleContextPostProcessor(muleContext),\n                              new GlobalNamePostProcessor(),\n                              new PostRegistrationActionsPostProcessor((MuleRegistryHelper) muleContext.getRegistry()),\n                              new DiscardedOptionalBeanPostProcessor(optionalObjectsController, (DefaultListableBeanFactory) beanFactory),\n                              new LifecycleStatePostProcessor(muleContext.getLifecycleManager().getState())\n        );\n\n        beanFactory.registerSingleton(OBJECT_MULE_CONTEXT, muleContext);\n    }","commit_id":"0e137599887184514865a9281f4a3b2176cea988","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException\n    {\n        BeanDefinitionReader beanDefinitionReader = createBeanDefinitionReader(beanFactory);\n        // Communicate mule context to parsers\n        try\n        {\n            currentMuleContext.set(muleContext);\n            beanDefinitionReader.loadBeanDefinitions(getConfigResources());\n        }\n        finally\n        {\n            currentMuleContext.remove();\n        }\n    }","id":41395,"modified_method":"@Override\n    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException\n    {\n        BeanDefinitionReader beanDefinitionReader = createBeanDefinitionReader(beanFactory);\n        // Communicate mule context to parsers\n        try\n        {\n            currentMuleContext.set(muleContext);\n            if (useNewParsingMechanism)\n            {\n                applicationModel.executeOnEveryMuleComponentTree(componentModel -> {\n                    if (componentModel.isRoot())\n                    {\n                        beanDefinitionFactory.resolveComponentRecursively(applicationModel.getRootComponentModel(), componentModel, beanFactory,\n                                                                          (resolvedComponentModel, registry) -> {\n                                                                              if (resolvedComponentModel.isRoot())\n                                                                              {\n                                                                                  String nameAttribute = resolvedComponentModel.getNameAttribute();\n                                                                                  if (resolvedComponentModel.getIdentifier().equals(CONFIGURATION_IDENTIFIER))\n                                                                                  {\n                                                                                      nameAttribute = OBJECT_MULE_CONFIGURATION;\n                                                                                  }\n                                                                                  registry.registerBeanDefinition(nameAttribute, resolvedComponentModel.getBeanDefinition());\n                                                                              }\n                                                                          }, null);\n                    }\n                });\n            }\n            else\n            {\n                beanDefinitionReader.loadBeanDefinitions(getConfigResources());\n            }\n        }\n        finally\n        {\n            currentMuleContext.remove();\n        }\n    }","commit_id":"0e137599887184514865a9281f4a3b2176cea988","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addToCache(FilteringNode node, boolean duplicate) {\n    Object delegate = node.getDelegate();\n    Object[] delegates = myBaseStructure.getChildElements(delegate);\n    if (delegates == null || delegates.length == 0 || duplicate) {\n      myLeaves.add(node);\n    } else {\n      ArrayList<FilteringNode> nodes = new ArrayList<FilteringNode>(delegates.length);\n      for (Object d : delegates) {\n        FilteringNode n = new FilteringNode(node, d);\n        boolean isDuplicate = myDescriptors2Nodes.containsKey(d);\n        myDescriptors2Nodes.put(d, n);\n        nodes.add(n);\n        addToCache(n, isDuplicate);\n      }\n      myNodesCache.put(node, nodes);\n    }\n  }","id":41396,"modified_method":"private void addToCache(FilteringNode node, boolean duplicate) {\n    Object delegate = node.getDelegate();\n    Object[] delegates = myBaseStructure.getChildElements(delegate);\n    if (delegates == null || delegates.length == 0 || duplicate) {\n      myLeaves.add(node);\n    } else {\n      ArrayList<FilteringNode> nodes = new ArrayList<FilteringNode>(delegates.length);\n      for (Object d : delegates) {\n        FilteringNode n = new FilteringNode(node, d);\n        boolean isDuplicate = myDescriptors2Nodes.containsKey(d);\n        if (!isDuplicate) {\n          myDescriptors2Nodes.put(d, n);\n          nodes.add(n);\n          addToCache(n, isDuplicate);\n        }\n      }\n      myNodesCache.put(node, nodes);\n    }\n  }","commit_id":"59fe05cb32c5b8bb388392e8ebc72253e83b6a58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the\r\n\t * {@link #getCapHeight() cap height}) to the baseline. Note the same TextBounds instance is used for all methods that return\r\n\t * TextBounds. */\r\n\tpublic TextBounds getBounds (CharSequence str) {\r\n\t\treturn getBounds(str, 0, str.length());\r\n\t}","id":41397,"modified_method":"/** Returns the bounds of the specified text. Note the returned TextBounds instance is reused.\r\n\t * @see #getBounds(CharSequence, int, int, TextBounds) */\r\n\tpublic TextBounds getBounds (CharSequence str) {\r\n\t\treturn getBounds(str, 0, str.length());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a string, which may contain newlines (\\n), at the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline of the last line). Note the\r\n\t *         same TextBounds instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds drawMultiLine (SpriteBatch spriteBatch, CharSequence str, float x, float y) {\r\n\t\treturn drawMultiLine(spriteBatch, str, x, y, 0, HAlignment.LEFT);\r\n\t}","id":41398,"modified_method":"/** Draws a string, which may contain newlines (\\n), at the specified position.\r\n\t * @see BitmapFontCache#addMultiLineText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds drawMultiLine (SpriteBatch spriteBatch, CharSequence str, float x, float y) {\r\n\t\treturn drawMultiLine(spriteBatch, str, x, y, 0, HAlignment.LEFT);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped to keep it\r\n\t * within a rectangle of the specified width, and aligned horizontally within that rectangle.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline of the last line). Note the\r\n\t *         same TextBounds instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds drawWrapped (SpriteBatch spriteBatch, CharSequence str, float x, float y, float wrapWidth,\r\n\t\tHAlignment alignment) {\r\n\t\tif (wrapWidth <= 0) wrapWidth = Integer.MAX_VALUE;\r\n\t\tfloat batchColor = spriteBatch.color;\r\n\t\tfloat down = this.data.down;\r\n\t\tint start = 0;\r\n\t\tint numLines = 0;\r\n\t\tint length = str.length();\r\n\t\tfloat maxWidth = 0;\r\n\t\twhile (start < length) {\r\n\t\t\tint newLine = BitmapFont.indexOf(str, '\\n', start);\r\n\t\t\t// Eat whitespace at start of line.\r\n\t\t\twhile (start < newLine) {\r\n\t\t\t\tif (!BitmapFont.isWhitespace(str.charAt(start))) break;\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\tint lineEnd = start + computeVisibleGlyphs(str, start, newLine, wrapWidth);\r\n\t\t\tint nextStart = lineEnd + 1;\r\n\t\t\tif (lineEnd < newLine) {\r\n\t\t\t\t// Find char to break on.\r\n\t\t\t\twhile (lineEnd > start) {\r\n\t\t\t\t\tif (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;\r\n\t\t\t\t\tlineEnd--;\r\n\t\t\t\t}\r\n\t\t\t\tif (lineEnd == start) {\r\n\t\t\t\t\tif (nextStart > start + 1) nextStart--;\r\n\t\t\t\t\tlineEnd = nextStart; // If no characters to break, show all.\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnextStart = lineEnd;\r\n\t\t\t\t\t// Eat whitespace at end of line.\r\n\t\t\t\t\twhile (lineEnd > start) {\r\n\t\t\t\t\t\tif (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;\r\n\t\t\t\t\t\tlineEnd--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\tnextStart = lineEnd + 1;\r\n\t\t\tif (lineEnd > start) {\r\n\t\t\t\tfloat xOffset = 0;\r\n\t\t\t\tif (alignment != HAlignment.LEFT) {\r\n\t\t\t\t\tfloat lineWidth = getBounds(str, start, lineEnd).width;\r\n\t\t\t\t\txOffset = wrapWidth - lineWidth;\r\n\t\t\t\t\tif (alignment == HAlignment.CENTER) xOffset /= 2;\r\n\t\t\t\t}\r\n\t\t\t\tfloat lineWidth = draw(spriteBatch, str, x + xOffset, y, start, lineEnd).width;\r\n\t\t\t\tmaxWidth = Math.max(maxWidth, lineWidth);\r\n\t\t\t}\r\n\t\t\tstart = nextStart;\r\n\t\t\ty += down;\r\n\t\t\tnumLines++;\r\n\t\t}\r\n\t\tspriteBatch.setColor(batchColor);\r\n\t\ttextBounds.width = maxWidth;\r\n\t\ttextBounds.height = data.capHeight + (numLines - 1) * data.lineHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41399,"modified_method":"/** Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\r\n\t * specified width.\r\n\t * @see BitmapFontCache#addWrappedText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds drawWrapped (SpriteBatch spriteBatch, CharSequence str, float x, float y, float wrapWidth,\r\n\t\tHAlignment alignment) {\r\n\t\tTextBounds bounds = cache.setWrappedText(str, x, y, wrapWidth, alignment);\r\n\t\tcache.draw(spriteBatch);\r\n\t\treturn bounds;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Constructs a new BitmapFont from the given {@link BitmapFontData} and {@link TextureRegion}. If the TextureRegion is null,\r\n\t * the image path is read from the BitmapFontData. The dispose() method will not dispose the texture of the region if the\r\n\t * region is != null.\r\n\t * @param data\r\n\t * @param region\r\n\t * @param integer */\r\n\tpublic BitmapFont (BitmapFontData data, TextureRegion region, boolean integer) {\r\n\t\tthis.region = region == null ? new TextureRegion(new Texture(Gdx.files.internal(data.imagePath), false)) : region;\r\n\t\tthis.flipped = data.flipped;\r\n\t\tthis.integer = integer;\r\n\t\tthis.data = data;\r\n\t\tload(data);\r\n\t\townsTexture = region == null;\r\n\t}","id":41400,"modified_method":"/** Constructs a new BitmapFont from the given {@link BitmapFontData} and {@link TextureRegion}. If the TextureRegion is null,\r\n\t * the image path is read from the BitmapFontData. The dispose() method will not dispose the texture of the region if the\r\n\t * region is != null.\r\n\t * @param data\r\n\t * @param region\r\n\t * @param integer */\r\n\tpublic BitmapFont (BitmapFontData data, TextureRegion region, boolean integer) {\r\n\t\tthis.region = region == null ? new TextureRegion(new Texture(Gdx.files.internal(data.imagePath), false)) : region;\r\n\t\tthis.flipped = data.flipped;\r\n\t\tthis.data = data;\r\n\t\tthis.integer = integer;\r\n\t\tcache.setUseIntegerPositions(integer);\r\n\t\tload(data);\r\n\t\townsTexture = region == null;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the color of this font. Changing the returned color will have no affect, {@link #setColor(Color)} or\r\n\t * {@link #setColor(float, float, float, float)} must be used. */\r\n\tpublic Color getColor () {\r\n\t\tint intBits = NumberUtils.floatToIntColor(color);\r\n\t\tColor color = this.tempColor;\r\n\t\tcolor.r = (intBits & 0xff) / 255f;\r\n\t\tcolor.g = ((intBits >>> 8) & 0xff) / 255f;\r\n\t\tcolor.b = ((intBits >>> 16) & 0xff) / 255f;\r\n\t\tcolor.a = ((intBits >>> 24) & 0xff) / 255f;\r\n\t\treturn color;\r\n\t}","id":41401,"modified_method":"/** Returns the color of this font. Changing the returned color will have no affect, {@link #setColor(Color)} or\r\n\t * {@link #setColor(float, float, float, float)} must be used. */\r\n\tpublic Color getColor () {\r\n\t\treturn cache.getColor();\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param character\r\n\t * @return whether the given character is contained in this font. */\r\n\tpublic boolean containsCharacter (char character) {\r\n\t\treturn data.getGlyph(character) != null;\r\n\t}","id":41402,"modified_method":"/** @return true if the character is contained in this font. */\r\n\tpublic boolean containsCharacter (char character) {\r\n\t\treturn data.getGlyph(character) != null;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a string at the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline). Note the same TextBounds\r\n\t *         instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds draw (SpriteBatch spriteBatch, CharSequence str, float x, float y) {\r\n\t\treturn draw(spriteBatch, str, x, y, 0, str.length());\r\n\t}","id":41403,"modified_method":"/** Draws a string at the specified position.\r\n\t * @see BitmapFontCache#addText(CharSequence, float, float, int, int) */\r\n\tpublic TextBounds draw (SpriteBatch spriteBatch, CharSequence str, float x, float y) {\r\n\t\treturn draw(spriteBatch, str, x, y, 0, str.length());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the size of the specified string, which may contain newlines and is wrapped to keep it within a rectangle of the\r\n\t * specified width. The height is the distance from the top of most capital letters in the font (the {@link #getCapHeight() cap\r\n\t * height}) to the baseline of the last line of text. Note the same TextBounds instance is used for all methods that return\r\n\t * TextBounds. */\r\n\tpublic TextBounds getWrappedBounds (CharSequence str, float wrapWidth) {\r\n\t\treturn getWrappedBounds(str, wrapWidth, this.textBounds);\r\n\t}","id":41404,"modified_method":"/** Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width.\r\n\t * @see #getWrappedBounds(CharSequence, float, TextBounds) */\r\n\tpublic TextBounds getWrappedBounds (CharSequence str, float wrapWidth) {\r\n\t\treturn getWrappedBounds(str, wrapWidth, cache.getBounds());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setColor (float color) {\r\n\t\tthis.color = color;\r\n\t}","id":41405,"modified_method":"public void setColor (float color) {\r\n\t\tcache.setColor(color);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setScale (float scaleX, float scaleY) {\r\n\t\tdata.lineHeight = data.lineHeight / this.data.scaleX * scaleX;\r\n\t\tdata.spaceWidth = data.spaceWidth / this.data.scaleX * scaleX;\r\n\t\tdata.xHeight = data.xHeight / this.data.scaleY * scaleY;\r\n\t\tdata.capHeight = data.capHeight / this.data.scaleY * scaleY;\r\n\t\tdata.ascent = data.ascent / this.data.scaleY * scaleY;\r\n\t\tdata.descent = data.descent / this.data.scaleY * scaleY;\r\n\t\tdata.down = data.down / this.data.scaleY * scaleY;\r\n\t\tdata.scaleX = scaleX;\r\n\t\tdata.scaleY = scaleY;\r\n\t}","id":41406,"modified_method":"public void setScale (float scaleX, float scaleY) {\r\n\t\tBitmapFontData data = this.data;\r\n\t\tfloat x = scaleX / data.scaleX;\r\n\t\tfloat y = scaleY / data.scaleY;\r\n\t\tdata.lineHeight = data.lineHeight * x;\r\n\t\tdata.spaceWidth = data.spaceWidth * x;\r\n\t\tdata.xHeight = data.xHeight * y;\r\n\t\tdata.capHeight = data.capHeight * y;\r\n\t\tdata.ascent = data.ascent * y;\r\n\t\tdata.descent = data.descent * y;\r\n\t\tdata.down = data.down * y;\r\n\t\tdata.scaleX = scaleX;\r\n\t\tdata.scaleY = scaleY;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setColor (Color tint) {\r\n\t\tthis.color = tint.toFloatBits();\r\n\t}","id":41407,"modified_method":"public void setColor (Color color) {\r\n\t\tcache.setColor(color);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Computes the glyph advances for the given character sequence and stores them in the provided {@link FloatArray}. The\r\n\t * FloatArray is cleared. This will add an additional element at the end.\r\n\t * @param str the character sequence\r\n\t * @param glyphAdvances the glyph advances output array.\r\n\t * @param glyphPositions the glyph positions output array. */\r\n\tpublic void computeGlyphAdvancesAndPositions (CharSequence str, FloatArray glyphAdvances, FloatArray glyphPositions) {\r\n\t\tglyphAdvances.clear();\r\n\t\tglyphPositions.clear();\r\n\t\tint index = 0;\r\n\t\tint end = str.length();\r\n\t\tfloat width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\t\tif (data.scaleX == 1) {\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\tglyphAdvances.add(g.xadvance);\r\n\t\t\t\t\tglyphPositions.add(width);\r\n\t\t\t\t\twidth += g.xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tglyphAdvances.add(0);\r\n\t\t\tglyphPositions.add(width);\r\n\t\t} else {\r\n\t\t\tfloat scaleX = this.data.scaleX;\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\tfloat xadvance = g.xadvance * scaleX;\r\n\t\t\t\t\tglyphAdvances.add(xadvance);\r\n\t\t\t\t\tglyphPositions.add(width);\r\n\t\t\t\t\twidth += xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tglyphAdvances.add(0);\r\n\t\t\tglyphPositions.add(width);\r\n\t\t}\r\n\t}","id":41408,"modified_method":"/** Computes the glyph advances for the given character sequence and stores them in the provided {@link FloatArray}. The float\r\n\t * arrays are cleared. An additional element is added at the end.\r\n\t * @param glyphAdvances the glyph advances output array.\r\n\t * @param glyphPositions the glyph positions output array. */\r\n\tpublic void computeGlyphAdvancesAndPositions (CharSequence str, FloatArray glyphAdvances, FloatArray glyphPositions) {\r\n\t\tglyphAdvances.clear();\r\n\t\tglyphPositions.clear();\r\n\t\tint index = 0;\r\n\t\tint end = str.length();\r\n\t\tfloat width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\t\tBitmapFontData data = this.data;\r\n\t\tif (data.scaleX == 1) {\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\tglyphAdvances.add(g.xadvance);\r\n\t\t\t\t\tglyphPositions.add(width);\r\n\t\t\t\t\twidth += g.xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tglyphAdvances.add(0);\r\n\t\t\tglyphPositions.add(width);\r\n\t\t} else {\r\n\t\t\tfloat scaleX = this.data.scaleX;\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\tfloat xadvance = g.xadvance * scaleX;\r\n\t\t\t\t\tglyphAdvances.add(xadvance);\r\n\t\t\t\t\tglyphPositions.add(width);\r\n\t\t\t\t\twidth += xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tglyphAdvances.add(0);\r\n\t\t\tglyphPositions.add(width);\r\n\t\t}\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Specifies whether to use integer positions or not. Default is to use them so filtering doesn't kick in as badly.\r\n\t * @param use */\r\n\tpublic void setUseIntegerPositions (boolean use) {\r\n\t\tthis.integer = use;\r\n\t}","id":41409,"modified_method":"/** Specifies whether to use integer positions or not. Default is to use them so filtering doesn't kick in as badly. */\r\n\tpublic void setUseIntegerPositions (boolean integer) {\r\n\t\tthis.integer = integer;\r\n\t\tcache.setUseIntegerPositions(integer);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the\r\n\t * {@link #getCapHeight() cap height}) to the baseline. */\r\n\tpublic TextBounds getBounds (CharSequence str, TextBounds textBounds) {\r\n\t\treturn getBounds(str, 0, str.length());\r\n\t}","id":41410,"modified_method":"/** Returns the bounds of the specified text.\r\n\t * @see #getBounds(CharSequence, int, int, TextBounds) */\r\n\tpublic TextBounds getBounds (CharSequence str, TextBounds textBounds) {\r\n\t\treturn getBounds(str, 0, str.length(), textBounds);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the number of glyphs from the substring that can be rendered in the specified width.\r\n\t * @param start The first character of the string.\r\n\t * @param end The last character of the string (exclusive). */\r\n\tpublic int computeVisibleGlyphs (CharSequence str, int start, int end, float availableWidth) {\r\n\t\tint index = start;\r\n\t\tfloat width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\r\n\t\tif (data.scaleX == 1) {\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tif ((width + g.xadvance) - availableWidth > 0.001f) break;\r\n\t\t\t\t\twidth += g.xadvance;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfloat scaleX = this.data.scaleX;\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tfloat xadvance = g.xadvance * scaleX;\r\n\t\t\t\t\tif ((width + xadvance) - availableWidth > 0.001f) break;\r\n\t\t\t\t\twidth += xadvance;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn index - start;\r\n\t}","id":41411,"modified_method":"/** Returns the number of glyphs from the substring that can be rendered in the specified width.\r\n\t * @param start The first character of the string.\r\n\t * @param end The last character of the string (exclusive). */\r\n\tpublic int computeVisibleGlyphs (CharSequence str, int start, int end, float availableWidth) {\r\n\t\tBitmapFontData data = this.data;\r\n\t\tint index = start;\r\n\t\tfloat width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\r\n\t\tif (data.scaleX == 1) {\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tif ((width + g.xadvance) - availableWidth > 0.001f) break;\r\n\t\t\t\t\twidth += g.xadvance;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfloat scaleX = this.data.scaleX;\r\n\t\t\tfor (; index < end; index++) {\r\n\t\t\t\tchar ch = str.charAt(index);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tif (lastGlyph != null) width += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tfloat xadvance = g.xadvance * scaleX;\r\n\t\t\t\t\tif ((width + xadvance) - availableWidth > 0.001f) break;\r\n\t\t\t\t\twidth += xadvance;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn index - start;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\r\n\t * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\r\n\tpublic void setFixedWidthGlyphs (CharSequence glyphs) {\r\n\t\tint maxAdvance = 0;\r\n\t\tfor (int index = 0, end = glyphs.length(); index < end; index++) {\r\n\t\t\tGlyph g = data.getGlyph(glyphs.charAt(index));\r\n\t\t\tif (g != null && g.xadvance > maxAdvance) maxAdvance = g.xadvance;\r\n\t\t}\r\n\t\tfor (int index = 0, end = glyphs.length(); index < end; index++) {\r\n\t\t\tGlyph g = data.getGlyph(glyphs.charAt(index));\r\n\t\t\tif (g == null) continue;\r\n\t\t\tg.xoffset += (maxAdvance - g.xadvance) / 2;\r\n\t\t\tg.xadvance = maxAdvance;\r\n\t\t\tg.kerning = null;\r\n\t\t}\r\n\t}","id":41412,"modified_method":"/** Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\r\n\t * centering a score or loading percentage text, it will not jump around as different numbers are shown. */\r\n\tpublic void setFixedWidthGlyphs (CharSequence glyphs) {\r\n\t\tBitmapFontData data = this.data;\r\n\t\tint maxAdvance = 0;\r\n\t\tfor (int index = 0, end = glyphs.length(); index < end; index++) {\r\n\t\t\tGlyph g = data.getGlyph(glyphs.charAt(index));\r\n\t\t\tif (g != null && g.xadvance > maxAdvance) maxAdvance = g.xadvance;\r\n\t\t}\r\n\t\tfor (int index = 0, end = glyphs.length(); index < end; index++) {\r\n\t\t\tGlyph g = data.getGlyph(glyphs.charAt(index));\r\n\t\t\tif (g == null) continue;\r\n\t\t\tg.xoffset += (maxAdvance - g.xadvance) / 2;\r\n\t\t\tg.xadvance = maxAdvance;\r\n\t\t\tg.kerning = null;\r\n\t\t}\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the size of the specified substring. The height is the distance from the top of most capital letters in the font\r\n\t * (the {@link #getCapHeight() cap height}) to the baseline. Note the same TextBounds instance is used for all methods that\r\n\t * return TextBounds.\r\n\t * @param start The first character of the string.\r\n\t * @param end The last character of the string (exclusive). */\r\n\tpublic TextBounds getBounds (CharSequence str, int start, int end) {\r\n\t\treturn getBounds(str, start, end, this.textBounds);\r\n\t}","id":41413,"modified_method":"/** Returns the bounds of the specified text. Note the returned TextBounds instance is reused.\r\n\t * @see #getBounds(CharSequence, int, int, TextBounds) */\r\n\tpublic TextBounds getBounds (CharSequence str, int start, int end) {\r\n\t\treturn getBounds(str, start, end, cache.getBounds());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the size of the specified string, which may contain newlines. The height is the distance from the top of most\r\n\t * capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of the last line of text. Note the same\r\n\t * TextBounds instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds getMultiLineBounds (CharSequence str) {\r\n\t\treturn getMultiLineBounds(str, this.textBounds);\r\n\t}","id":41414,"modified_method":"/** Returns the bounds of the specified text, which may contain newlines.\r\n\t * @see #getMultiLineBounds(CharSequence, TextBounds) */\r\n\tpublic TextBounds getMultiLineBounds (CharSequence str) {\r\n\t\treturn getMultiLineBounds(str, cache.getBounds());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a string, which may contain newlines (\\n), at the specified position and alignment. Each line is aligned horizontally\r\n\t * within a rectangle of the specified width.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline of the last line). Note the\r\n\t *         same TextBounds instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds drawMultiLine (SpriteBatch spriteBatch, CharSequence str, float x, float y, float alignmentWidth,\r\n\t\tHAlignment alignment) {\r\n\t\tfloat batchColor = spriteBatch.color;\r\n\t\tfloat down = this.data.down;\r\n\t\tint start = 0;\r\n\t\tint numLines = 0;\r\n\t\tint length = str.length();\r\n\t\tfloat maxWidth = 0;\r\n\t\twhile (start < length) {\r\n\t\t\tint lineEnd = indexOf(str, '\\n', start);\r\n\t\t\tfloat xOffset = 0;\r\n\t\t\tif (alignment != HAlignment.LEFT) {\r\n\t\t\t\tfloat lineWidth = getBounds(str, start, lineEnd).width;\r\n\t\t\t\txOffset = alignmentWidth - lineWidth;\r\n\t\t\t\tif (alignment == HAlignment.CENTER) xOffset = xOffset / 2;\r\n\t\t\t}\r\n\t\t\tfloat lineWidth = draw(spriteBatch, str, x + xOffset, y, start, lineEnd).width;\r\n\t\t\tmaxWidth = Math.max(maxWidth, lineWidth);\r\n\t\t\tstart = lineEnd + 1;\r\n\t\t\ty += down;\r\n\t\t\tnumLines++;\r\n\t\t}\r\n\t\tspriteBatch.setColor(batchColor);\r\n\r\n\t\ttextBounds.width = maxWidth;\r\n\t\ttextBounds.height = data.capHeight + (numLines - 1) * data.lineHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41415,"modified_method":"/** Draws a string, which may contain newlines (\\n), at the specified position.\r\n\t * @see BitmapFontCache#addMultiLineText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds drawMultiLine (SpriteBatch spriteBatch, CharSequence str, float x, float y, float alignmentWidth,\r\n\t\tHAlignment alignment) {\r\n\t\tTextBounds bounds = cache.setMultiLineText(str, x, y, alignmentWidth, alignment);\r\n\t\tcache.draw(spriteBatch);\r\n\t\treturn bounds;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a substring at the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @param start The first character of the string to draw.\r\n\t * @param end The last character of the string to draw (exclusive).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline). Note the same TextBounds\r\n\t *         instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds draw (SpriteBatch spriteBatch, CharSequence str, float x, float y, int start, int end) {\r\n\t\tfloat batchColor = spriteBatch.color;\r\n\t\tspriteBatch.setColor(color);\r\n\t\tfinal Texture texture = region.getTexture();\r\n\t\ty += data.ascent;\r\n\t\tfloat startX = x;\r\n\t\tGlyph lastGlyph = null;\r\n\t\tif (data.scaleX == 1 && data.scaleY == 1) {\r\n\t\t\tif (integer) {\r\n\t\t\t\ty = Math.round(y);\r\n\t\t\t\tx = Math.round(x);\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\t\tx + lastGlyph.xoffset, y + lastGlyph.yoffset, //\r\n\t\t\t\t\t\tlastGlyph.width, lastGlyph.height, //\r\n\t\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\t\tx += lastGlyph.xadvance;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g == null) continue;\r\n\t\t\t\tx += lastGlyph.getKerning(ch);\r\n\t\t\t\tif (integer) x = Math.round(x);\r\n\t\t\t\tlastGlyph = g;\r\n\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\tx + lastGlyph.xoffset, y + lastGlyph.yoffset, //\r\n\t\t\t\t\tlastGlyph.width, lastGlyph.height, //\r\n\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\tx += g.xadvance;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfloat scaleX = this.data.scaleX, scaleY = this.data.scaleY;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\tif (!integer) {\r\n\t\t\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\t\t\tx + lastGlyph.xoffset * scaleX, //\r\n\t\t\t\t\t\t\ty + lastGlyph.yoffset * scaleY, //\r\n\t\t\t\t\t\t\tlastGlyph.width * scaleX, //\r\n\t\t\t\t\t\t\tlastGlyph.height * scaleY, //\r\n\t\t\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\t\t\tMath.round(x + lastGlyph.xoffset * scaleX), //\r\n\t\t\t\t\t\t\tMath.round(y + lastGlyph.yoffset * scaleY), //\r\n\t\t\t\t\t\t\tMath.round(lastGlyph.width * scaleX), //\r\n\t\t\t\t\t\t\tMath.round(lastGlyph.height * scaleY), //\r\n\t\t\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx += lastGlyph.xadvance * scaleX;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g == null) continue;\r\n\t\t\t\tx += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\tlastGlyph = g;\r\n\t\t\t\tif (!integer) {\r\n\t\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\t\tx + lastGlyph.xoffset * scaleX, //\r\n\t\t\t\t\t\ty + lastGlyph.yoffset * scaleY, //\r\n\t\t\t\t\t\tlastGlyph.width * scaleX, //\r\n\t\t\t\t\t\tlastGlyph.height * scaleY, //\r\n\t\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tspriteBatch.draw(texture, //\r\n\t\t\t\t\t\tMath.round(x + lastGlyph.xoffset * scaleX), //\r\n\t\t\t\t\t\tMath.round(y + lastGlyph.yoffset * scaleY), //\r\n\t\t\t\t\t\tMath.round(lastGlyph.width * scaleX), //\r\n\t\t\t\t\t\tMath.round(lastGlyph.height * scaleY), //\r\n\t\t\t\t\t\tlastGlyph.u, lastGlyph.v, lastGlyph.u2, lastGlyph.v2);\r\n\t\t\t\t}\r\n\t\t\t\tx += g.xadvance * scaleX;\r\n\t\t\t}\r\n\t\t}\r\n\t\tspriteBatch.setColor(batchColor);\r\n\t\ttextBounds.width = x - startX;\r\n\t\ttextBounds.height = data.capHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41416,"modified_method":"/** Draws a string at the specified position.\r\n\t * @see BitmapFontCache#addText(CharSequence, float, float, int, int) */\r\n\tpublic TextBounds draw (SpriteBatch spriteBatch, CharSequence str, float x, float y, int start, int end) {\r\n\t\tTextBounds bounds = cache.setText(str, x, y);\r\n\t\tcache.draw(spriteBatch);\r\n\t\treturn bounds;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Returns the size of the specified substring. The height is the distance from the top of most capital letters in the font\r\n\t * (the {@link #getCapHeight() cap height}) to the baseline. Note the same TextBounds instance is used for all methods that\r\n\t * return TextBounds.\r\n\t * @param start The first character of the string.\r\n\t * @param end The last character of the string (exclusive). */\r\n\tpublic TextBounds getBounds (CharSequence str, int start, int end, TextBounds textBounds) {\r\n\t\tint width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\t\twhile (start < end) {\r\n\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\tif (lastGlyph != null) {\r\n\t\t\t\twidth = lastGlyph.xadvance;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (start < end) {\r\n\t\t\tchar ch = str.charAt(start++);\r\n\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\tif (g != null) {\r\n\t\t\t\twidth += lastGlyph.getKerning(ch);\r\n\t\t\t\tlastGlyph = g;\r\n\t\t\t\twidth += g.xadvance;\r\n\t\t\t}\r\n\t\t}\r\n\t\ttextBounds.width = width * data.scaleX;\r\n\t\ttextBounds.height = data.capHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41417,"modified_method":"/** Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the\r\n\t * {@link #getCapHeight() cap height}) to the baseline.\r\n\t * @param start The first character of the string.\r\n\t * @param end The last character of the string (exclusive). */\r\n\tpublic TextBounds getBounds (CharSequence str, int start, int end, TextBounds textBounds) {\r\n\t\tBitmapFontData data = this.data;\r\n\t\tint width = 0;\r\n\t\tGlyph lastGlyph = null;\r\n\t\twhile (start < end) {\r\n\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\tif (lastGlyph != null) {\r\n\t\t\t\twidth = lastGlyph.xadvance;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (start < end) {\r\n\t\t\tchar ch = str.charAt(start++);\r\n\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\tif (g != null) {\r\n\t\t\t\twidth += lastGlyph.getKerning(ch);\r\n\t\t\t\tlastGlyph = g;\r\n\t\t\t\twidth += g.xadvance;\r\n\t\t\t}\r\n\t\t}\r\n\t\ttextBounds.width = width * data.scaleX;\r\n\t\ttextBounds.height = data.capHeight;\r\n\t\treturn textBounds;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped to keep it\r\n\t * within a rectangle of the specified width.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link #getCapHeight() cap height}).\r\n\t * @return The bounds of the rendered string (the height is the distance from y to the baseline of the last line). Note the\r\n\t *         same TextBounds instance is used for all methods that return TextBounds. */\r\n\tpublic TextBounds drawWrapped (SpriteBatch spriteBatch, CharSequence str, float x, float y, float wrapWidth) {\r\n\t\treturn drawWrapped(spriteBatch, str, x, y, wrapWidth, HAlignment.LEFT);\r\n\t}","id":41418,"modified_method":"/** Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\r\n\t * specified width.\r\n\t * @see BitmapFontCache#addWrappedText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds drawWrapped (SpriteBatch spriteBatch, CharSequence str, float x, float y, float wrapWidth) {\r\n\t\treturn drawWrapped(spriteBatch, str, x, y, wrapWidth, HAlignment.LEFT);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setColor (float r, float g, float b, float a) {\r\n\t\tint intBits = (int)(255 * a) << 24 | (int)(255 * b) << 16 | (int)(255 * g) << 8 | (int)(255 * r);\r\n\t\tcolor = NumberUtils.intToFloatColor(intBits);\r\n\t}","id":41419,"modified_method":"public void setColor (float r, float g, float b, float a) {\r\n\t\tcache.setColor(r, g, b, a);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void addText (CharSequence str, float x, float y, int start, int end) {\r\n\t\tint glyphCount = end - start;\r\n\t\tint vertexCount = idx + glyphCount * 20;\r\n\t\tif (vertices == null || vertices.length < vertexCount) {\r\n\t\t\tfloat[] newVertices = new float[vertexCount];\r\n\t\t\tSystem.arraycopy(vertices, 0, newVertices, 0, idx);\r\n\t\t\tvertices = newVertices;\r\n\t\t}\r\n\t\taddToCache(str, x, y, start, end);\r\n\t}","id":41420,"modified_method":"/** Adds glyphs for the the specified text.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @param start The first character of the string to draw.\r\n\t * @param end The last character of the string to draw (exclusive).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline). */\r\n\tpublic TextBounds addText (CharSequence str, float x, float y, int start, int end) {\r\n\t\trequire(end - start);\r\n\t\ty += font.data.ascent;\r\n\t\ttextBounds.width = addToCache(str, x, y, start, end);\r\n\t\ttextBounds.height = font.data.capHeight;\r\n\t\treturn textBounds;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a string, which may contain newlines (\\n), with the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */\r\n\tpublic TextBounds setMultiLineText (CharSequence str, float x, float y) {\r\n\t\treturn setMultiLineText(str, x, y, 0, HAlignment.LEFT);\r\n\t}","id":41421,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\\n).\r\n\t * @see #addMultiLineText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds setMultiLineText (CharSequence str, float x, float y) {\r\n\t\tclear();\r\n\t\treturn addMultiLineText(str, x, y, 0, HAlignment.LEFT);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a string with the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline). */\r\n\tpublic TextBounds setText (CharSequence str, float x, float y) {\r\n\t\treturn setText(str, x, y, 0, str.length());\r\n\t}","id":41422,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text.\r\n\t * @see #addText(CharSequence, float, float, int, int) */\r\n\tpublic TextBounds setText (CharSequence str, float x, float y) {\r\n\t\tclear();\r\n\t\treturn addText(str, x, y, 0, str.length());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"private float addToCache (CharSequence str, float x, float y, int start, int end) {\r\n\t\tfloat startX = x;\r\n\t\tBitmapFont font = this.font;\r\n\t\tGlyph lastGlyph = null;\r\n\t\tif (font.data.scaleX == 1 && font.data.scaleY == 1) {\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = font.data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\taddGlyph(lastGlyph, x + lastGlyph.xoffset, y + lastGlyph.yoffset, lastGlyph.width, lastGlyph.height);\r\n\t\t\t\t\tx += lastGlyph.xadvance;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = font.data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tx += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\taddGlyph(lastGlyph, x + g.xoffset, y + g.yoffset, g.width, g.height);\r\n\t\t\t\t\tx += g.xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfloat scaleX = font.data.scaleX, scaleY = font.data.scaleY;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = font.data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\taddGlyph(lastGlyph, //\r\n\t\t\t\t\t\tx + lastGlyph.xoffset * scaleX, //\r\n\t\t\t\t\t\ty + lastGlyph.yoffset * scaleY, //\r\n\t\t\t\t\t\tlastGlyph.width * scaleX, //\r\n\t\t\t\t\t\tlastGlyph.height * scaleY);\r\n\t\t\t\t\tx += lastGlyph.xadvance * scaleX;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = font.data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tx += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\taddGlyph(lastGlyph, //\r\n\t\t\t\t\t\tx + g.xoffset * scaleX, //\r\n\t\t\t\t\t\ty + g.yoffset * scaleY, //\r\n\t\t\t\t\t\tg.width * scaleX, //\r\n\t\t\t\t\t\tg.height * scaleY);\r\n\t\t\t\t\tx += g.xadvance * scaleX;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn x - startX;\r\n\t}","id":41423,"modified_method":"private float addToCache (CharSequence str, float x, float y, int start, int end) {\r\n\t\tfloat startX = x;\r\n\t\tBitmapFont font = this.font;\r\n\t\tGlyph lastGlyph = null;\r\n\t\tBitmapFontData data = font.data;\r\n\t\tif (data.scaleX == 1 && data.scaleY == 1) {\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\taddGlyph(lastGlyph, x + lastGlyph.xoffset, y + lastGlyph.yoffset, lastGlyph.width, lastGlyph.height);\r\n\t\t\t\t\tx += lastGlyph.xadvance;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tx += lastGlyph.getKerning(ch);\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\taddGlyph(lastGlyph, x + g.xoffset, y + g.yoffset, g.width, g.height);\r\n\t\t\t\t\tx += g.xadvance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfloat scaleX = data.scaleX, scaleY = data.scaleY;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tlastGlyph = data.getGlyph(str.charAt(start++));\r\n\t\t\t\tif (lastGlyph != null) {\r\n\t\t\t\t\taddGlyph(lastGlyph, //\r\n\t\t\t\t\t\tx + lastGlyph.xoffset * scaleX, //\r\n\t\t\t\t\t\ty + lastGlyph.yoffset * scaleY, //\r\n\t\t\t\t\t\tlastGlyph.width * scaleX, //\r\n\t\t\t\t\t\tlastGlyph.height * scaleY);\r\n\t\t\t\t\tx += lastGlyph.xadvance * scaleX;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tchar ch = str.charAt(start++);\r\n\t\t\t\tGlyph g = data.getGlyph(ch);\r\n\t\t\t\tif (g != null) {\r\n\t\t\t\t\tx += lastGlyph.getKerning(ch) * scaleX;\r\n\t\t\t\t\tlastGlyph = g;\r\n\t\t\t\t\taddGlyph(lastGlyph, //\r\n\t\t\t\t\t\tx + g.xoffset * scaleX, //\r\n\t\t\t\t\t\ty + g.yoffset * scaleY, //\r\n\t\t\t\t\t\tg.width * scaleX, //\r\n\t\t\t\t\t\tg.height * scaleY);\r\n\t\t\t\t\tx += g.xadvance * scaleX;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn x - startX;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped to keep it\r\n\t * within a rectangle of the specified width.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */\r\n\tpublic TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth) {\r\n\t\treturn setWrappedText(str, x, y, wrapWidth, HAlignment.LEFT);\r\n\t}","id":41424,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\\n) and is automatically\r\n\t * wrapped within the specified width.\r\n\t * @see #addWrappedText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth) {\r\n\t\tclear();\r\n\t\treturn addWrappedText(str, x, y, wrapWidth, HAlignment.LEFT);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a substring with the specified position.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @param start The first character of the string to draw.\r\n\t * @param end The last character of the string to draw (exclusive).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline). */\r\n\tpublic TextBounds setText (CharSequence str, float x, float y, int start, int end) {\r\n\t\treset(end - start);\r\n\t\ty += font.data.ascent;\r\n\t\ttextBounds.width = addToCache(str, x, y, start, end);\r\n\t\ttextBounds.height = font.data.capHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41425,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text.\r\n\t * @see #addText(CharSequence, float, float, int, int) */\r\n\tpublic TextBounds setText (CharSequence str, float x, float y, int start, int end) {\r\n\t\tclear();\r\n\t\treturn addText(str, x, y, start, end);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Color getColor () {\r\n\t\tfloat floatBits = color;\r\n\t\tint intBits = NumberUtils.floatToIntColor(color);\r\n\t\tColor color = tmpColor;\r\n\t\tcolor.r = (intBits & 0xff) / 255f;\r\n\t\tcolor.g = ((intBits >>> 8) & 0xff) / 255f;\r\n\t\tcolor.b = ((intBits >>> 16) & 0xff) / 255f;\r\n\t\tcolor.a = ((intBits >>> 24) & 0xff) / 255f;\r\n\t\treturn color;\r\n\t}","id":41426,"modified_method":"public Color getColor () {\r\n\t\tfloat floatBits = color;\r\n\t\tint intBits = NumberUtils.floatToIntColor(color);\r\n\t\tColor color = tempColor;\r\n\t\tcolor.r = (intBits & 0xff) / 255f;\r\n\t\tcolor.g = ((intBits >>> 8) & 0xff) / 255f;\r\n\t\tcolor.b = ((intBits >>> 16) & 0xff) / 255f;\r\n\t\tcolor.a = ((intBits >>> 24) & 0xff) / 255f;\r\n\t\treturn color;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void addText (CharSequence str, float x, float y) {\r\n\t\taddText(str, x, y, 0, str.length());\r\n\t}","id":41427,"modified_method":"/** Adds glyphs for the specified text.\r\n\t * @see #addText(CharSequence, float, float, int, int) */\r\n\tpublic TextBounds addText (CharSequence str, float x, float y) {\r\n\t\treturn addText(str, x, y, 0, str.length());\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void addGlyph (Glyph glyph, float x, float y, float width, float height) {\r\n\t\tfloat x2 = x + width;\r\n\t\tfloat y2 = y + height;\r\n\t\tfinal float u = glyph.u;\r\n\t\tfinal float u2 = glyph.u2;\r\n\t\tfinal float v = glyph.v;\r\n\t\tfinal float v2 = glyph.v2;\r\n\r\n\t\tfinal float[] vertices = this.vertices;\r\n\r\n\t\tif (integer) {\r\n\t\t\tx = Math.round(x);\r\n\t\t\ty = Math.round(y);\r\n\t\t\tx2 = Math.round(x2);\r\n\t\t\ty2 = Math.round(y2);\r\n\t\t}\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","id":41428,"modified_method":"private void addGlyph (Glyph glyph, float x, float y, float width, float height) {\r\n\t\tfloat x2 = x + width;\r\n\t\tfloat y2 = y + height;\r\n\t\tfinal float u = glyph.u;\r\n\t\tfinal float u2 = glyph.u2;\r\n\t\tfinal float v = glyph.v;\r\n\t\tfinal float v2 = glyph.v2;\r\n\r\n\t\tfinal float[] vertices = this.vertices;\r\n\r\n\t\tif (integer) {\r\n\t\t\tx = Math.round(x);\r\n\t\t\ty = Math.round(y);\r\n\t\t\tx2 = Math.round(x2);\r\n\t\t\ty2 = Math.round(y2);\r\n\t\t}\r\n\r\n\t\tint idx = this.idx;\r\n\t\tthis.idx += 20;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v;\r\n\r\n\t\tvertices[idx++] = x;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y2;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v2;\r\n\r\n\t\tvertices[idx++] = x2;\r\n\t\tvertices[idx++] = y;\r\n\t\tvertices[idx++] = color;\r\n\t\tvertices[idx++] = u2;\r\n\t\tvertices[idx++] = v;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a string, which may contain newlines (\\n), with the specified position and alignment. Each line is aligned\r\n\t * horizontally within a rectangle of the specified width.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */\r\n\tpublic TextBounds setMultiLineText (CharSequence str, float x, float y, float alignmentWidth, HAlignment alignment) {\r\n\t\tBitmapFont font = this.font;\r\n\r\n\t\tint length = str.length();\r\n\t\treset(length);\r\n\r\n\t\ty += font.data.ascent;\r\n\t\tfloat down = font.data.down;\r\n\r\n\t\tfloat maxWidth = 0;\r\n\t\tfloat startY = y;\r\n\t\tint start = 0;\r\n\t\tint numLines = 0;\r\n\t\twhile (start < length) {\r\n\t\t\tint lineEnd = BitmapFont.indexOf(str, '\\n', start);\r\n\t\t\tfloat xOffset = 0;\r\n\t\t\tif (alignment != HAlignment.LEFT) {\r\n\t\t\t\tfloat lineWidth = font.getBounds(str, start, lineEnd).width;\r\n\t\t\t\txOffset = alignmentWidth - lineWidth;\r\n\t\t\t\tif (alignment == HAlignment.CENTER) xOffset /= 2;\r\n\t\t\t}\r\n\t\t\tfloat lineWidth = addToCache(str, x + xOffset, y, start, lineEnd);\r\n\t\t\tmaxWidth = Math.max(maxWidth, lineWidth);\r\n\t\t\tstart = lineEnd + 1;\r\n\t\t\ty += down;\r\n\t\t\tnumLines++;\r\n\t\t}\r\n\t\ttextBounds.width = maxWidth;\r\n\t\ttextBounds.height = font.data.capHeight + (numLines - 1) * font.data.lineHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41429,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\\n).\r\n\t * @see #addMultiLineText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds setMultiLineText (CharSequence str, float x, float y, float alignmentWidth, HAlignment alignment) {\r\n\t\tclear();\r\n\t\treturn addMultiLineText(str, x, y, alignmentWidth, alignment);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void clear () {\r\n\t\tx = 0;\r\n\t\ty = 0;\r\n\t\tidx = 0;\r\n\t}","id":41430,"modified_method":"/** Removes all glyphs in the cache. */\r\n\tpublic void clear () {\r\n\t\tx = 0;\r\n\t\ty = 0;\r\n\t\tidx = 0;\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Caches a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped to keep it\r\n\t * within a rectangle of the specified width, and aligned horizontally within that rectangle.\r\n\t * @param x The x position for the left most character.\r\n\t * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).\r\n\t * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */\r\n\tpublic TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth, HAlignment alignment) {\r\n\t\tBitmapFont font = this.font;\r\n\r\n\t\tint length = str.length();\r\n\t\treset(length);\r\n\r\n\t\ty += font.data.ascent;\r\n\t\tfloat down = font.data.down;\r\n\r\n\t\tif (wrapWidth <= 0) wrapWidth = Integer.MAX_VALUE;\r\n\t\tfloat maxWidth = 0;\r\n\t\tint start = 0;\r\n\t\tint numLines = 0;\r\n\t\twhile (start < length) {\r\n\t\t\tint newLine = BitmapFont.indexOf(str, '\\n', start);\r\n\t\t\t// Eat whitespace at start of line.\r\n\t\t\twhile (start < newLine) {\r\n\t\t\t\tif (!BitmapFont.isWhitespace(str.charAt(start))) break;\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\tint lineEnd = start + font.computeVisibleGlyphs(str, start, newLine, wrapWidth);\r\n\t\t\tint nextStart = lineEnd + 1;\r\n\t\t\tif (lineEnd < newLine) {\r\n\t\t\t\t// Find char to break on.\r\n\t\t\t\twhile (lineEnd > start) {\r\n\t\t\t\t\tif (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;\r\n\t\t\t\t\tlineEnd--;\r\n\t\t\t\t}\r\n\t\t\t\tif (lineEnd == start) {\r\n\t\t\t\t\tif (nextStart > start + 1) nextStart--;\r\n\t\t\t\t\tlineEnd = nextStart; // If no characters to break, show all.\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnextStart = lineEnd;\r\n\t\t\t\t\t// Eat whitespace at end of line.\r\n\t\t\t\t\twhile (lineEnd > start) {\r\n\t\t\t\t\t\tif (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;\r\n\t\t\t\t\t\tlineEnd--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (lineEnd > start) {\r\n\t\t\t\tfloat xOffset = 0;\r\n\t\t\t\tif (alignment != HAlignment.LEFT) {\r\n\t\t\t\t\tfloat lineWidth = font.getBounds(str, start, lineEnd).width;\r\n\t\t\t\t\txOffset = wrapWidth - lineWidth;\r\n\t\t\t\t\tif (alignment == HAlignment.CENTER) xOffset /= 2;\r\n\t\t\t\t}\r\n\t\t\t\tfloat lineWidth = addToCache(str, x + xOffset, y, start, lineEnd);\r\n\t\t\t\tmaxWidth = Math.max(maxWidth, lineWidth);\r\n\t\t\t}\r\n\t\t\tstart = nextStart;\r\n\t\t\ty += down;\r\n\t\t\tnumLines++;\r\n\t\t}\r\n\t\ttextBounds.width = maxWidth;\r\n\t\ttextBounds.height = font.data.capHeight + (numLines - 1) * font.data.lineHeight;\r\n\t\treturn textBounds;\r\n\t}","id":41431,"modified_method":"/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\\n) and is automatically\r\n\t * wrapped within the specified width.\r\n\t * @see #addWrappedText(CharSequence, float, float, float, HAlignment) */\r\n\tpublic TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth, HAlignment alignment) {\r\n\t\tclear();\r\n\t\treturn addWrappedText(str, x, y, wrapWidth, alignment);\r\n\t}","commit_id":"e720fc041df12ac5f4b2639fb5db2e303c090805","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n\t * Generate a randomised URL for the given URL but with a much longer key (22 chars vs 6 chars).\n\t * Store it and return it or null if errors.\n\t * \n\t * @param url - the long URL\n\t * @param secure - if a longer key is required.\n\t * @return the shortened URL, or null if errors.\n\t */\n\tpublic String shorten(String url, boolean secure) {\n\t\t\n\t\t//check values\n\t\tif(StringUtils.isBlank(url)){\n\t\t\tlog.error(\"URL was empty, aborting...\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\t//check if a key already exists for this url\n\t\tString key = getExistingKey(url);\n\t\tif(key != null) {\n\t\t\t//log\n\t\t\tlog.info(\"Returning existing key: \" + key);\n\t\t\t\n\t\t\t//post event\n\t\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_EXISTS, PREFIX+key, false);\n\t\t\t\n\t\t\t//make actual url and return it\n\t\t\treturn generateActualUrl(key);\n\t\t}\n\t\t\n\t\t//or generate a new one\n\t\tString newKey = generateKey(secure);\n\t\t\n\t\t//if not unique, recalculate\n\t\tint attempts = 0;\n\t\twhile (!isKeyUnique(newKey)) {\n\t\t\t//if this is the second or greater pass through, we had a collision. log it.\n\t\t\tif(attempts > 0){\n\t\t\t\tlog.warn(\"Collision detected for record: \" + newKey + \" and attempt: \" + attempts + \". Regenerating...\");\n\t\t\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_COLLISION, newKey, false);\n\t\t\t}\n\t\t\tnewKey = generateKey(secure);\n\t\t\tattempts++;\n\t\t}\n\t\t\n\t\t//new key created so post event\n\t\tif(log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Created:\" + newKey + \" for URL: \" + url);\n\t\t}\n\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_OK, PREFIX + newKey, true);\n\t\t\n\t\t//save \n\t\tif(!saveNewShortenedUrl(newKey, url)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//make actual url and return it\n\t\treturn generateActualUrl(newKey);\n\t}","id":41432,"modified_method":"/**\n\t * Generate a randomised URL for the given URL but with a much longer key (22 chars vs 6 chars).\n\t * Store it and return it or null if errors.\n\t * \n\t * @param url - the long URL\n\t * @param secure - if a longer key is required.\n\t * @return the shortened URL, or null if errors.\n\t */\n\tpublic String shorten(String url, boolean secure) {\n\t\t\n\t\t//check values\n\t\tif(StringUtils.isBlank(url)){\n\t\t\tlog.warn(\"URL was empty, aborting...\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\t//check if a key already exists for this url\n\t\tString key = getExistingKey(url);\n\t\tif(key != null) {\n\t\t\t//log\n\t\t\tlog.debug(\"Returning existing key: \" + key);\n\t\t\t\n\t\t\t//post event\n\t\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_EXISTS, PREFIX+key, false);\n\t\t\t\n\t\t\t//make actual url and return it\n\t\t\treturn generateActualUrl(key);\n\t\t}\n\t\t\n\t\t//or generate a new one\n\t\tString newKey = generateKey(secure);\n\t\t\n\t\t//if not unique, recalculate\n\t\tint attempts = 0;\n\t\twhile (!isKeyUnique(newKey)) {\n\t\t\t//if this is the second or greater pass through, we had a collision. log it.\n\t\t\tif(attempts > 0){\n\t\t\t\tlog.warn(\"Collision detected for record: \" + newKey + \" and attempt: \" + attempts + \". Regenerating...\");\n\t\t\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_COLLISION, newKey, false);\n\t\t\t}\n\t\t\tnewKey = generateKey(secure);\n\t\t\tattempts++;\n\t\t}\n\t\t\n\t\tlog.debug(\"Created:\" + newKey + \" for URL: \" + url);\n\t\tpostEvent(ShortenedUrlService.EVENT_CREATE_OK, PREFIX + newKey, true);\n\t\t\n\t\t//save \n\t\tif(!saveNewShortenedUrl(newKey, url)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//make actual url and return it\n\t\treturn generateActualUrl(newKey);\n\t}","commit_id":"0631f01283d387b62f7aba8bf7cc195d8649b315","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Save entry\n\t * @param key\n\t * @param url\n\t * @return\n\t */\n\tprivate boolean saveNewShortenedUrl(final String key, final String url) {\n\t\t\n\t\ttry {\n\t\t\t//add to db\n\t\t\tRandomisedUrl randomisedUrl = new RandomisedUrl(key, url);\n\t\t\tgetHibernateTemplate().save(randomisedUrl);\n\t\t\tlog.info(\"RandomisedUrl saved as: \" + key);\n\t\t\t\n\t\t\t//and put it in the cache, both ways\n\t\t\taddToCache(key, url);\n\t\t\taddToCache(url, key);\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"RandomisedUrl save failed. \" + e.getClass() + \": \" + e.getMessage());\n\t\t\treturn false;\n\t\t}\n\t}","id":41433,"modified_method":"/**\n\t * Save entry\n\t * @param key\n\t * @param url\n\t * @return\n\t */\n\tprivate boolean saveNewShortenedUrl(final String key, final String url) {\n\t\t\n\t\ttry {\n\t\t\t//add to db\n\t\t\tRandomisedUrl randomisedUrl = new RandomisedUrl(key, url);\n\t\t\tgetHibernateTemplate().save(randomisedUrl);\n\t\t\tlog.debug(\"RandomisedUrl saved as: \" + key);\n\t\t\t\n\t\t\t//and put it in the cache, both ways\n\t\t\taddToCache(key, url);\n\t\t\taddToCache(url, key);\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"RandomisedUrl save failed. \" + e.getClass() + \": \" + e.getMessage());\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"0631f01283d387b62f7aba8bf7cc195d8649b315","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Checks if a key already exists for a given url, if so returns it else returns null\n\t * @param url\n\t * @return\n\t */\n\tprivate String getExistingKey(final String url) {\n\t\t\n\t\t//first check cache\n\t\tif(cache.containsKey(url)){\n\t\t\tlog.debug(\"Fetching key from cache for URL: \" + url);\n\t\t\treturn (String)cache.get(url);\n\t\t}\n\t\t\n\t\t//then check db\n\t\tRandomisedUrl randomisedUrl = null;\n\t\t\n\t\tHibernateCallback hcb = new HibernateCallback() {\n\t  \t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t  \t\t\tQuery q = session.getNamedQuery(QUERY_GET_KEY);\n\t  \t\t\tq.setParameter(URL, url, Hibernate.STRING);\n\t  \t\t\tq.setMaxResults(1);\n\t  \t\t\treturn q.uniqueResult();\n\t\t\t}\n\t\t};\n\t\n\t\t//will be either a RandomisedUrl or null\n\t\trandomisedUrl = (RandomisedUrl) getHibernateTemplate().execute(hcb);\t\n\t\tif(randomisedUrl == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//add to cache\n\t\tString key = randomisedUrl.getKey();\n\t\taddToCache(url, key);\n\t\n\t\treturn key;\n\t}","id":41434,"modified_method":"/**\n\t * Checks if a key already exists for a given url, if so returns it else returns null\n\t * @param url\n\t * @return\n\t */\n\tprivate String getExistingKey(final String url) {\n\n\t\tif (StringUtils.isBlank(url)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//first check cache\n\t\tString value = (String) cache.get(url);\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\t//then check db\n\t\tRandomisedUrl randomisedUrl = null;\n\t\t\n\t\tHibernateCallback hcb = new HibernateCallback() {\n\t  \t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t  \t\t\tQuery q = session.getNamedQuery(QUERY_GET_KEY);\n\t  \t\t\tq.setParameter(URL, url, Hibernate.STRING);\n\t  \t\t\tq.setMaxResults(1);\n\t  \t\t\treturn q.uniqueResult();\n\t\t\t}\n\t\t};\n\t\n\t\t//will be either a RandomisedUrl or null\n\t\trandomisedUrl = (RandomisedUrl) getHibernateTemplate().execute(hcb);\t\n\t\tif(randomisedUrl == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//add to cache\n\t\tString key = randomisedUrl.getKey();\n\t\taddToCache(url, key);\n\t\n\t\treturn key;\n\t}","commit_id":"0631f01283d387b62f7aba8bf7cc195d8649b315","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n  \t * Encodes a full URL.\n  \t * \n  \t * @param rawUrl the URL to encode.\n  \t */\n  \tprivate String encodeUrl(String rawUrl) {\n  \t\t\n  \t\tString encodedUrl = null;\n  \t\t\n  \t\ttry {\n\t  \t\tURL url = new URL(rawUrl);\n\t  \t\tURI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef());\n\t  \t\tencodedUrl = uri.toURL().toString();\n  \t\t} catch (Exception e) {\n\t  \t\tlog.debug(\"Error encoding url: \" + rawUrl +\". \" + e.getClass() + \": \" + e.getMessage());\n\t\t}\n  \t\t\n  \t\treturn encodedUrl;\n  \t}","id":41435,"modified_method":"/**\n  \t * Encodes a full URL.\n  \t * \n  \t * @param rawUrl the URL to encode.\n  \t */\n  \tprivate String encodeUrl(String rawUrl) {\n  \t\tif (StringUtils.isBlank(rawUrl)) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tString encodedUrl = null;\n  \t\t\n  \t\ttry {\n\t  \t\tURL url = new URL(rawUrl);\n\t  \t\tURI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef());\n\t  \t\tencodedUrl = uri.toASCIIString();\n  \t\t} catch (Exception e) {\n  \t\t\tlog.warn(\"encoding url: \" + rawUrl + \", \" + e.getMessage(), e);\n\t\t}\n  \t\t\n  \t\treturn encodedUrl;\n  \t}","commit_id":"0631f01283d387b62f7aba8bf7cc195d8649b315","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Gets the original URL for the given shortened URL.\n\t * This is used by the RandomisedUrlService servlet to translate short URLs back into their original URLs. \n\t * \n\t * @param key - the key value, eg 6whjq\n\t * @return the original URL mapped to this record or null if errors\n\t */\n\tpublic String resolve(final String key) {\n\t\t\n\t\t//first check cache\n\t\tif(cache.containsKey(key)){\n\t\t\tlog.debug(\"Fetching url from cache for key: \" + key);\n\t\t\treturn (String)cache.get(key);\n\t\t}\n\t\t\n\t\t//then check db\n\t\tRandomisedUrl randomisedUrl = null;\n\t\t\n\t\tHibernateCallback hcb = new HibernateCallback() {\n\t  \t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t  \t\t\tQuery q = session.getNamedQuery(QUERY_GET_URL);\n\t  \t\t\tq.setParameter(KEY, key, Hibernate.STRING);\n\t  \t\t\tq.setMaxResults(1);\n\t  \t\t\treturn q.uniqueResult();\n\t\t\t}\n\t\t};\n\t\n\t\t//will be either a RandomisedUrl or null\n\t\trandomisedUrl = (RandomisedUrl) getHibernateTemplate().execute(hcb);\n\t\tif(randomisedUrl == null) {\n\t\t\t//log\n\t\t\tlog.warn(\"Request for invalid record: \" + key);\n\t\t\t\n\t\t\t//post failure event\n\t\t\tpostEvent(ShortenedUrlService.EVENT_GET_URL_BAD, PREFIX+key, false);\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//log\n\t\tlog.info(\"Request for valid record: \" + key);\n\t\t\n\t\t//post success event\n\t\tpostEvent(ShortenedUrlService.EVENT_GET_URL_OK, PREFIX+key, false);\n\t\t\n\t\t//add to cache\n\t\tString url = randomisedUrl.getUrl();\n\t\t\n\t\t//SHORTURL-39 encode it, reutn null if failure\n\t\tString encodedUrl = encodeUrl(url);\n\t\tif(StringUtils.isBlank(encodedUrl)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlog.debug(\"Encoded URL: \" + encodedUrl);\n\t\t\n\t\taddToCache(key, encodedUrl);\n\t\t\n\t\treturn encodedUrl;\n\t}","id":41436,"modified_method":"/**\n\t * Gets the encoded URL for the given shortened URL.\n\t * This is used by the RandomisedUrlService servlet to translate short URLs back into their original URLs. \n\t * \n\t * @param key - the key value, eg 6whjq\n\t * @return the original encoded URL mapped to this record or null if errors\n\t */\n\tpublic String resolve(final String key) {\n\t\t\n\t\tif (StringUtils.isBlank(key)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//first check cache\n\t\tString value = (String) cache.get(key);\n\t\tif (value != null) {\n\t\t\treturn encodeUrl(value);\n\t\t}\n\t\t\n\t\t//then check db\n\t\tRandomisedUrl randomisedUrl = null;\n\t\t\n\t\tHibernateCallback hcb = new HibernateCallback() {\n\t  \t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t  \t\t\tQuery q = session.getNamedQuery(QUERY_GET_URL);\n\t  \t\t\tq.setParameter(KEY, key, Hibernate.STRING);\n\t  \t\t\tq.setMaxResults(1);\n\t  \t\t\treturn q.uniqueResult();\n\t\t\t}\n\t\t};\n\t\n\t\t//will be either a RandomisedUrl or null\n\t\trandomisedUrl = (RandomisedUrl) getHibernateTemplate().execute(hcb);\n\t\tif(randomisedUrl == null) {\n\t\t\t//log\n\t\t\tlog.warn(\"Request for invalid record: \" + key);\n\t\t\t\n\t\t\t//post failure event\n\t\t\tpostEvent(ShortenedUrlService.EVENT_GET_URL_BAD, PREFIX+key, false);\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//log\n\t\tlog.debug(\"Request for valid record: \" + key);\n\t\t\n\t\t//post success event\n\t\tpostEvent(ShortenedUrlService.EVENT_GET_URL_OK, PREFIX+key, false);\n\t\t\n\t\t//add to cache\n\t\tString url = randomisedUrl.getUrl();\n\t\taddToCache(key, url);\n\n\t\tString encodedUrl = encodeUrl(url);\n\t\tif(StringUtils.isBlank(encodedUrl)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlog.debug(\"URL: \" + encodedUrl);\n\t\t\n\t\treturn encodedUrl;\n\t}","commit_id":"0631f01283d387b62f7aba8bf7cc195d8649b315","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private Object[] getFromCache(Object[] keyValues, Date dateValue) throws KettleValueException\n    {\n    \tif (data.cacheKeyRowMeta==null) return null; // There is nothing in the cache: don't look\n    \t\n    \tbyte[] key = RowMeta.extractData(data.cacheKeyRowMeta, keyValues);\n        byte[] value = data.cache.get(key);\n        if (value!=null) \n        {\n            Object[] row = RowMeta.getRow(data.cacheValueRowMeta, value);\n            \n            // See if the dateValue is between the from and to date ranges...\n            // The last 2 values are from and to\n            long time = dateValue.getTime();\n            long from = ((Date)row[row.length-2]).getTime(); \n            long to   = ((Date)row[row.length-1]).getTime(); \n            if (time>=from && time<to) // sanity check to see if we have the right version\n            {\n                if (log.isRowLevel()) logRowlevel(\"Cache hit: key=\"+data.cacheKeyRowMeta.getString(keyValues)+\"  values=\"+data.cacheValueRowMeta.getString(row));\n                return row;\n            }\n        }\n        return null;\n    }","id":41437,"modified_method":"private Object[] getFromCache(Object[] keyValues, Date dateValue) throws KettleValueException\n    {\r\n        if (data.cacheValueRowMeta==null)\r\n        {\r\n        \t// nothing in the cache yet, no lookup was ever performed\r\n        \tif (data.returnRowMeta==null) return null; \r\n        \t\r\n            data.cacheValueRowMeta = data.returnRowMeta.clone();\r\n        }\r\n    \t\n    \tbyte[] key = RowMeta.extractData(data.cacheKeyRowMeta, keyValues);\n        byte[] value = data.cache.get(key);\n        if (value!=null) \n        {\n            Object[] row = RowMeta.getRow(data.cacheValueRowMeta, value);\n            \n            // See if the dateValue is between the from and to date ranges...\n            // The last 2 values are from and to\n            long time = dateValue.getTime();\n            long from = ((Date)row[row.length-2]).getTime(); \n            long to   = ((Date)row[row.length-1]).getTime(); \n            if (time>=from && time<to) // sanity check to see if we have the right version\n            {\n                if (log.isRowLevel()) logRowlevel(\"Cache hit: key=\"+data.cacheKeyRowMeta.getString(keyValues)+\"  values=\"+data.cacheValueRowMeta.getString(row));\n                return row;\n            }\n        }\n        return null;\n    }","commit_id":"e792bee3bd52d1ed8c6b6d949d21a5116dd7e978","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Adds a row to the cache\n     * In case we are doing updates, we need to store the complete rows from the database.\n     * These are the values we need to store\n     * \n     * Key:\n     *   - natural key fields\n     * Value:\n     *   - Technical key\n     *   - lookup fields / extra fields (allows us to compare or retrieve)\n     *   - Date_from\n     *   - Date_to\n     * \n     * @param keyValues\n     * @param returnValues\n     * @throws KettleValueException \n     */\n\tprivate void addToCache(Object[] keyValues, Object[] returnValues) throws KettleValueException\n    {\n        // Caching...\n        //\n        if (data.cacheKeyRowMeta==null)\n        {\n        \t// KEY : the natural key(s)\n            //\n            data.cacheKeyRowMeta = new RowMeta();\n            for (int i=0;i<data.keynrs.length;i++)\n            {\n                ValueMetaInterface key = getInputRowMeta().getValueMeta(data.keynrs[i]);\n                data.cacheKeyRowMeta.addValueMeta( key.clone());\n            }\n            \n            data.cache = new ByteArrayHashMap(meta.getCacheSize()>0 ? meta.getCacheSize() : 5000, data.cacheKeyRowMeta);\n        \n            data.cacheValueRowMeta = data.returnRowMeta.clone();\n            \n            /*\n            // VALUE : tk, version, fields, from date, to date \n            //\n            data.cacheValueRowMeta = new RowMeta();\n            data.cacheValueRowMeta.addValueMeta( new ValueMeta(meta.getKeyField(), ValueMetaInterface.TYPE_INTEGER) );\n            data.cacheValueRowMeta.addValueMeta( new ValueMeta(meta.getVersionField(), ValueMetaInterface.TYPE_INTEGER) );\n            for (int i=0;i<data.fieldnrs.length;i++)\n            {\n                ValueMetaInterface v = data.outputRowMeta.getValueMeta(data.fieldnrs[i]);\n                data.cacheValueRowMeta.addValueMeta(v);\n            }\n            data.cacheValueRowMeta.addValueMeta( new ValueMeta(meta.getDateFrom(), ValueMetaInterface.TYPE_DATE) );\n            data.cacheValueRowMeta.addValueMeta( new ValueMeta(meta.getDateTo(), ValueMetaInterface.TYPE_DATE) );\n            */\n        }\n\n        // store it in the cache if needed.\n\t\tbyte[] keyPart = RowMeta.extractData(data.cacheKeyRowMeta, keyValues);\n\t\tbyte[] valuePart = RowMeta.extractData(data.cacheValueRowMeta, returnValues);\n        data.cache.put(keyPart, valuePart);\n        \n        // check if the size is not too big...\n        // Allow for a buffer overrun of 20% and then remove those 20% in one go.\n        // Just to keep performance in track.\n        //\n        int tenPercent = meta.getCacheSize()/10;\n        if (meta.getCacheSize()>0 && data.cache.size()>meta.getCacheSize()+tenPercent)\n        {\n            // Which cache entries do we delete here?\n            // We delete those with the lowest technical key...\n            // Those would arguably be the \"oldest\" dimension entries.\n            // Oh well... Nothing is going to be perfect here...\n            // \n            // Getting the lowest 20% requires some kind of sorting algorithm and I'm not sure we want to do that.\n            // Sorting is slow and even in the best case situation we need to do 2 passes over the cache entries...\n            //\n            // Perhaps we should get 20% random values and delete everything below the lowest but one TK.\n            //\n            List<byte[]> keys = data.cache.getKeys();\n            int sizeBefore = keys.size();\n            List<Long> samples = new ArrayList<Long>();\n            \n            // Take 10 sample technical keys....\n            int stepsize=keys.size()/5;\n            if (stepsize<1) stepsize=1; //make shure we have no endless loop\n            for (int i=0;i<keys.size();i+=stepsize)\n            {\n                byte[] key = (byte[]) keys.get(i);\n                byte[] value = data.cache.get(key);\n                if (value!=null)\n                {\n                    Object[] values = RowMeta.getRow(data.cacheValueRowMeta, value);\n                    Long tk = data.cacheValueRowMeta.getInteger(values, 0);\n                    samples.add(tk);\n                }\n            }\n            // Sort these 5 elements...\n            Collections.sort(samples);\n            \n            // What is the smallest?\n            // Take the second, not the fist in the list, otherwise we would be removing a single entry = not good.\n            if (samples.size()>1) {\n            \tdata.smallestCacheKey = samples.get(1);\n            } else { // except when there is only one sample\n            \tdata.smallestCacheKey = samples.get(0);\n            }\n            \n            // Remove anything in the cache <= smallest.\n            // This makes it almost single pass...\n            // This algorithm is not 100% correct, but I guess it beats sorting the whole cache all the time.\n            //\n            for (int i=0;i<keys.size();i++)\n            {\n                byte[] key = (byte[]) keys.get(i);\n                byte[] value = data.cache.get(key);\n                if (value!=null)\n                {\n                    Object[] values = RowMeta.getRow(data.cacheValueRowMeta, value);\n                    long tk = data.cacheValueRowMeta.getInteger(values, 0).longValue();\n                    if (tk<=data.smallestCacheKey)\n                    {\n                        data.cache.remove(key); // this one has to go.\n                    }\n                }\n            }\n            \n            int sizeAfter = data.cache.size();\n            logDetailed(\"Reduced the lookup cache from \"+sizeBefore+\" to \"+sizeAfter+\" rows.\");\n        }\n        \n        if (log.isRowLevel()) logRowlevel(\"Cache store: key=\"+keyValues+\"    values=\"+returnValues);\n    }","id":41438,"modified_method":"/**\n     * Adds a row to the cache\n     * In case we are doing updates, we need to store the complete rows from the database.\n     * These are the values we need to store\n     * \n     * Key:\n     *   - natural key fields\n     * Value:\n     *   - Technical key\n     *   - lookup fields / extra fields (allows us to compare or retrieve)\n     *   - Date_from\n     *   - Date_to\n     * \n     * @param keyValues\n     * @param returnValues\n     * @throws KettleValueException \n     */\n\tprivate void addToCache(Object[] keyValues, Object[] returnValues) throws KettleValueException\n    {\r\n        if (data.cacheValueRowMeta==null)\r\n        {\n            data.cacheValueRowMeta = data.returnRowMeta.clone();\n        }\n\n        // store it in the cache if needed.\n\t\tbyte[] keyPart = RowMeta.extractData(data.cacheKeyRowMeta, keyValues);\n\t\tbyte[] valuePart = RowMeta.extractData(data.cacheValueRowMeta, returnValues);\n        data.cache.put(keyPart, valuePart);\n        \n        // check if the size is not too big...\n        // Allow for a buffer overrun of 20% and then remove those 20% in one go.\n        // Just to keep performance in track.\n        //\n        int tenPercent = meta.getCacheSize()/10;\n        if (meta.getCacheSize()>0 && data.cache.size()>meta.getCacheSize()+tenPercent)\n        {\n            // Which cache entries do we delete here?\n            // We delete those with the lowest technical key...\n            // Those would arguably be the \"oldest\" dimension entries.\n            // Oh well... Nothing is going to be perfect here...\n            // \n            // Getting the lowest 20% requires some kind of sorting algorithm and I'm not sure we want to do that.\n            // Sorting is slow and even in the best case situation we need to do 2 passes over the cache entries...\n            //\n            // Perhaps we should get 20% random values and delete everything below the lowest but one TK.\n            //\n            List<byte[]> keys = data.cache.getKeys();\n            int sizeBefore = keys.size();\n            List<Long> samples = new ArrayList<Long>();\n            \n            // Take 10 sample technical keys....\n            int stepsize=keys.size()/5;\n            if (stepsize<1) stepsize=1; //make shure we have no endless loop\n            for (int i=0;i<keys.size();i+=stepsize)\n            {\n                byte[] key = (byte[]) keys.get(i);\n                byte[] value = data.cache.get(key);\n                if (value!=null)\n                {\n                    Object[] values = RowMeta.getRow(data.cacheValueRowMeta, value);\n                    Long tk = data.cacheValueRowMeta.getInteger(values, 0);\n                    samples.add(tk);\n                }\n            }\n            // Sort these 5 elements...\n            Collections.sort(samples);\n            \n            // What is the smallest?\n            // Take the second, not the fist in the list, otherwise we would be removing a single entry = not good.\n            if (samples.size()>1) {\n            \tdata.smallestCacheKey = samples.get(1);\n            } else { // except when there is only one sample\n            \tdata.smallestCacheKey = samples.get(0);\n            }\n            \n            // Remove anything in the cache <= smallest.\n            // This makes it almost single pass...\n            // This algorithm is not 100% correct, but I guess it beats sorting the whole cache all the time.\n            //\n            for (int i=0;i<keys.size();i++)\n            {\n                byte[] key = (byte[]) keys.get(i);\n                byte[] value = data.cache.get(key);\n                if (value!=null)\n                {\n                    Object[] values = RowMeta.getRow(data.cacheValueRowMeta, value);\n                    long tk = data.cacheValueRowMeta.getInteger(values, 0).longValue();\n                    if (tk<=data.smallestCacheKey)\n                    {\n                        data.cache.remove(key); // this one has to go.\n                    }\n                }\n            }\n            \n            int sizeAfter = data.cache.size();\n            logDetailed(\"Reduced the lookup cache from \"+sizeBefore+\" to \"+sizeAfter+\" rows.\");\n        }\n        \n        if (log.isRowLevel()) logRowlevel(\"Cache store: key=\"+keyValues+\"    values=\"+returnValues);\n    }","commit_id":"e792bee3bd52d1ed8c6b6d949d21a5116dd7e978","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private synchronized Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n        Object[] outputRow = new Object[data.outputRowMeta.size()];\n        \n        Object[] lookupRow = new Object[data.lookupRowMeta.size()];\n\t\tObject[] returnRow = null;\n        \n\t\tLong technicalKey;\n\t\tLong valueVersion;\n\t\tDate valueDate    = null;\n\t\tDate valueDateFrom = null;\n\t\tDate valueDateTo   = null;\n\n        // Determine \"Now\" once, the first time we get here...\n\t\tif (data.valueDateNow==null && meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = rowMeta.getDate(row, data.datefieldnr);\n\t\t}\n\t\t\n        // Construct the \n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlookupRow[i] = row[data.keynrs[i]];\n\t\t\t}\n\t\t\tcatch(Exception e) // TODO : remove exception??\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+rowMeta.size(),rowMeta.getString(row))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0) valueDate = rowMeta.getDate(row, data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n        lookupRow[meta.getKeyStream().length]=valueDate;  // ? >= date_from\n        lookupRow[meta.getKeyStream().length+1]=valueDate; // ? < date_to\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+data.lookupRowMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        \n\t\tif (meta.getCacheSize()>=0)\n        {\n            returnRow=getFromCache(lookupRow, valueDate);\n        }\n        \n        if (returnRow==null)\n        {\n            data.db.setValues(data.lookupRowMeta, lookupRow, data.prepStatementLookup);\n            returnRow=data.db.getLookup(data.prepStatementLookup);\n            data.returnRowMeta = data.db.getReturnRowMeta();\n            \n            linesInput++;\n            \n            if (returnRow!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lookupRow, returnRow);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (returnRow==null)\n\t\t\t{\n                returnRow=new Object[data.returnRowMeta.size()];\n                returnRow[0] = data.notFoundTk; \n\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    returnRow[returnRow.length-2] = data.min_date;\n                    returnRow[returnRow.length-1] = data.max_date;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\t// add.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\t// if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (returnRow==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+data.lookupRowMeta.getString(lookupRow)+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = data.min_date;\n\t\t\t\tvalueDateTo   = data.max_date;\n\t\t\t\tvalueVersion  = new Long(1L);     // Versions always start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\ttechnicalKey=null; // Set to null to flag auto-increment usage\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\ttechnicalKey = dimInsert(getInputRowMeta(), row, technicalKey, true, valueVersion, valueDateFrom, valueDateTo); \n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n                int returnIndex=0;\n                \n                returnRow[returnIndex] = technicalKey;\n                returnIndex++;\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    addToCache(lookupRow, values);\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey = data.returnRowMeta.getInteger(returnRow, 0);\n\t\t\t\tvalueVersion = data.returnRowMeta.getInteger(returnRow, 1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = meta.getMinDate();\n\t\t\t\tvalueDateTo   = meta.getMaxDate();\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n                    ValueMetaInterface v1  = data.outputRowMeta.getValueMeta(data.fieldnrs[i]);\n                    Object valueData1 = row[data.fieldnrs[i]]; \n                    ValueMetaInterface v2  = data.returnRowMeta.getValueMeta(i+2);\n                    Object valueData2 = returnRow[i+2];\n                        \n\t\t\t\t\tcmp = v1.compare(valueData1, v2, valueData2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdimUpdate(rowMeta, row, technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lookupRow, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = data.max_date; //$NON-NLS-1$\n\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=new Long(0L); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n                        technicalKey = data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n\t\t\t\t\t}\n\n\t\t\t\t\tdimInsert( rowMeta, row, technicalKey, false, valueVersion, valueDateFrom, valueDateTo ); \n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lookupRow, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdimPunchThrough( rowMeta, row );\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n\t\t\t\treturnRow[0] = technicalKey;\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n        \n        \n        // Copy the results to the output row...\n        //\n        // First copy the input row values to the output...\n        for (int i=0;i<rowMeta.size();i++) outputRow[i] = row[i];\n\n        int outputIndex = rowMeta.size();\n        int inputIndex = 0;\n        \n        // Then the technical key...\n        outputRow[outputIndex] = returnRow[inputIndex];\n        outputIndex++;\n        inputIndex++;\n        //skip the version        \n        inputIndex++;\n        \n        // Then get the \"extra fields\"...\n        // don't return date from-to fields, they can be returned when explicitely specified in lookup fields.\n        while (inputIndex<returnRow.length && outputIndex<outputRow.length)\n\t\t{\n\t\t\toutputRow[outputIndex] = returnRow[inputIndex];\n            outputIndex++;\n            inputIndex++;\n\t\t}\n\n        // Finaly, check the date range!\n        /*\n         * TODO: WTF is this??? \n         * [May be it makes sense to keep the return date from-to fields within min/max range, but even then the code below is wrong].\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n         */\n        \n        return outputRow;\n\t}","id":41439,"modified_method":"private synchronized Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n        Object[] outputRow = new Object[data.outputRowMeta.size()];\n        \n        Object[] lookupRow = new Object[data.lookupRowMeta.size()];\n\t\tObject[] returnRow = null;\n        \n\t\tLong technicalKey;\n\t\tLong valueVersion;\n\t\tDate valueDate    = null;\n\t\tDate valueDateFrom = null;\n\t\tDate valueDateTo   = null;\n\n        // Determine \"Now\" once, the first time we get here...\n\t\tif (data.valueDateNow==null && meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = rowMeta.getDate(row, data.datefieldnr);\n\t\t}\n\t\t\n        // Construct the \n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlookupRow[i] = row[data.keynrs[i]];\n\t\t\t}\n\t\t\tcatch(Exception e) // TODO : remove exception??\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+rowMeta.size(),rowMeta.getString(row))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0) valueDate = rowMeta.getDate(row, data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n        lookupRow[meta.getKeyStream().length]=valueDate;  // ? >= date_from\n        lookupRow[meta.getKeyStream().length+1]=valueDate; // ? < date_to\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+data.lookupRowMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        \n\t\tif (meta.getCacheSize()>=0)\n        {\n            returnRow=getFromCache(lookupRow, valueDate);\n        }\n        \n        if (returnRow==null)\n        {\n            data.db.setValues(data.lookupRowMeta, lookupRow, data.prepStatementLookup);\n            returnRow=data.db.getLookup(data.prepStatementLookup);\n            data.returnRowMeta = data.db.getReturnRowMeta();\n            \n            linesInput++;\n            \n            if (returnRow!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lookupRow, returnRow);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (returnRow==null)\n\t\t\t{\n                returnRow=new Object[data.returnRowMeta.size()];\n                returnRow[0] = data.notFoundTk; \n\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    returnRow[returnRow.length-2] = data.min_date;\n                    returnRow[returnRow.length-1] = data.max_date;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\t// add.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\t// if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (returnRow==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+data.lookupRowMeta.getString(lookupRow)+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = data.min_date;\n\t\t\t\tvalueDateTo   = data.max_date;\n\t\t\t\tvalueVersion  = new Long(1L);     // Versions always start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\ttechnicalKey=null; // Set to null to flag auto-increment usage\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\ttechnicalKey = dimInsert(getInputRowMeta(), row, technicalKey, true, valueVersion, valueDateFrom, valueDateTo); \n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n                int returnIndex=0;\n                \n                returnRow[returnIndex] = technicalKey;\n                returnIndex++;\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    if (values!=null)\r\n                    {\r\n                    \taddToCache(lookupRow, values);\r\n                    }\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey = data.returnRowMeta.getInteger(returnRow, 0);\n\t\t\t\tvalueVersion = data.returnRowMeta.getInteger(returnRow, 1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = meta.getMinDate();\n\t\t\t\tvalueDateTo   = meta.getMaxDate();\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n                    ValueMetaInterface v1  = data.outputRowMeta.getValueMeta(data.fieldnrs[i]);\n                    Object valueData1 = row[data.fieldnrs[i]]; \n                    ValueMetaInterface v2  = data.returnRowMeta.getValueMeta(i+2);\n                    Object valueData2 = returnRow[i+2];\n                        \n\t\t\t\t\tcmp = v1.compare(valueData1, v2, valueData2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdimUpdate(rowMeta, row, technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lookupRow, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = data.max_date; //$NON-NLS-1$\n\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=new Long(0L); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n                        technicalKey = data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n\t\t\t\t\t}\n\n\t\t\t\t\tdimInsert( rowMeta, row, technicalKey, false, valueVersion, valueDateFrom, valueDateTo ); \n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lookupRow, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdimPunchThrough( rowMeta, row );\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n\t\t\t\treturnRow[0] = technicalKey;\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n        \n        \n        // Copy the results to the output row...\n        //\n        // First copy the input row values to the output...\n        for (int i=0;i<rowMeta.size();i++) outputRow[i] = row[i];\n\n        int outputIndex = rowMeta.size();\n        int inputIndex = 0;\n        \n        // Then the technical key...\n        outputRow[outputIndex] = returnRow[inputIndex];\n        outputIndex++;\n        inputIndex++;\n        //skip the version        \n        inputIndex++;\n        \n        // Then get the \"extra fields\"...\n        // don't return date from-to fields, they can be returned when explicitely specified in lookup fields.\n        while (inputIndex<returnRow.length && outputIndex<outputRow.length)\n\t\t{\n\t\t\toutputRow[outputIndex] = returnRow[inputIndex];\n            outputIndex++;\n            inputIndex++;\n\t\t}\n\n        // Finaly, check the date range!\n        /*\n         * TODO: WTF is this??? \n         * [May be it makes sense to keep the return date from-to fields within min/max range, but even then the code below is wrong].\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n         */\n        \n        return outputRow;\n\t}","commit_id":"e792bee3bd52d1ed8c6b6d949d21a5116dd7e978","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n    {\n        meta=(DimensionLookupMeta)smi;\n        data=(DimensionLookupData)sdi;\n\n        Object[] r=getRow();       // Get row from input rowset & set row busy!\n        if (r==null)  // no more input to be expected...\n        {\n            setOutputDone();  // signal end to receiver(s)\n            return false;\n        }\n\n        if (first)\n        {\n            first=false;\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTableName());\n            \n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n                        \n            // Lookup values\n            data.keynrs = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                //logDetailed(\"Lookup values key[\"+i+\"] --> \"+key[i]+\", row==null?\"+(row==null));\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0) // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n            }\n\n            // Return values\n            data.fieldnrs = new int[meta.getFieldStream().length];\n            for (int i=0;meta.getFieldStream()!=null && i<meta.getFieldStream().length;i++)\n            {\n                data.fieldnrs[i]=data.outputRowMeta.indexOfValue(meta.getFieldStream()[i]);\n                if ((data.fieldnrs[i] < 0)) \n                {\n                  throw new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\", meta.getFieldStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n            }\n\n            if (meta.getDateField()!=null && meta.getDateField().length()>0)\n            { \n                data.datefieldnr = getInputRowMeta().indexOfValue(meta.getDateField());\n            }\n            else \n            {\n                data.datefieldnr=-1;\n            } \n\n            data.notFoundTk = new Long( (long)meta.getDatabaseMeta().getNotFoundTK(isAutoIncrement()) );\n            // if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) data.notFoundTk.setName(meta.getKeyRename());\n\n            if (meta.getDateField()!=null && data.datefieldnr>=0)\n            {\n                data.valueDateNow = getInputRowMeta().getDate(r, data.datefieldnr);\n            }\n            else\n            {\n                data.valueDateNow = new Date(System.currentTimeMillis()); // System date... //$NON-NLS-1$\n            }\n                        \n            determineTechKeyCreation();\n            if (getCopy()==0) checkDimZero();\n            \n            setDimLookup(data.outputRowMeta);\n        }\n        \n        try\n        {\n            Object[] outputRow = lookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n            putRow(data.outputRowMeta, outputRow);       // copy row to output rowset(s);\n            \n            if (checkFeedback(linesRead)) logBasic(Messages.getString(\"DimensionLookup.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n        }\n        catch(KettleException e)\n        {\n            logError(Messages.getString(\"DimensionLookup.Log.StepCanNotContinueForErrors\", e.getMessage())); //$NON-NLS-1$ //$NON-NLS-2$\n            logError(Const.getStackTracker(e)); //$NON-NLS-1$ //$NON-NLS-2$\n            setErrors(1);\n            stopAll();\n            setOutputDone();  // signal end to receiver(s)\n            return false;\n        }\n    \n        return true;\n    }","id":41440,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n    {\n        meta=(DimensionLookupMeta)smi;\n        data=(DimensionLookupData)sdi;\n\n        Object[] r=getRow();       // Get row from input rowset & set row busy!\n        if (r==null)  // no more input to be expected...\n        {\n            setOutputDone();  // signal end to receiver(s)\n            return false;\n        }\n\n        if (first)\n        {\n            first=false;\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTableName());\n            \n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n                        \n            // Lookup values\n            data.keynrs = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                //logDetailed(\"Lookup values key[\"+i+\"] --> \"+key[i]+\", row==null?\"+(row==null));\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0) // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n            }\n\n            // Return values\n            data.fieldnrs = new int[meta.getFieldStream().length];\n            for (int i=0;meta.getFieldStream()!=null && i<meta.getFieldStream().length;i++)\n            {\n                data.fieldnrs[i]=data.outputRowMeta.indexOfValue(meta.getFieldStream()[i]);\n                if ((data.fieldnrs[i] < 0)) \n                {\n                  throw new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\", meta.getFieldStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n            }\r\n            \r\n            // Caching...\r\n            //\r\n            if (data.cacheKeyRowMeta==null)\r\n            {\r\n            \t// KEY : the natural key(s)\r\n                //\r\n                data.cacheKeyRowMeta = new RowMeta();\r\n                for (int i=0;i<data.keynrs.length;i++)\r\n                {\r\n                    ValueMetaInterface key = getInputRowMeta().getValueMeta(data.keynrs[i]);\r\n                    data.cacheKeyRowMeta.addValueMeta( key.clone());\r\n                }\r\n                \r\n                data.cache = new ByteArrayHashMap(meta.getCacheSize()>0 ? meta.getCacheSize() : 5000, data.cacheKeyRowMeta);\r\n            }\n\n            if (meta.getDateField()!=null && meta.getDateField().length()>0)\n            { \n                data.datefieldnr = getInputRowMeta().indexOfValue(meta.getDateField());\n            }\n            else \n            {\n                data.datefieldnr=-1;\n            } \n\n            data.notFoundTk = new Long( (long)meta.getDatabaseMeta().getNotFoundTK(isAutoIncrement()) );\n            // if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) data.notFoundTk.setName(meta.getKeyRename());\n\n            if (meta.getDateField()!=null && data.datefieldnr>=0)\n            {\n                data.valueDateNow = getInputRowMeta().getDate(r, data.datefieldnr);\n            }\n            else\n            {\n                data.valueDateNow = new Date(System.currentTimeMillis()); // System date... //$NON-NLS-1$\n            }\n                        \n            determineTechKeyCreation();\n            if (getCopy()==0) checkDimZero();\n            \n            setDimLookup(data.outputRowMeta);\n        }\n        \n        try\n        {\n            Object[] outputRow = lookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n            putRow(data.outputRowMeta, outputRow);       // copy row to output rowset(s);\n            \n            if (checkFeedback(linesRead)) logBasic(Messages.getString(\"DimensionLookup.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n        }\n        catch(KettleException e)\n        {\n            logError(Messages.getString(\"DimensionLookup.Log.StepCanNotContinueForErrors\", e.getMessage())); //$NON-NLS-1$ //$NON-NLS-2$\n            logError(Const.getStackTracker(e)); //$NON-NLS-1$ //$NON-NLS-2$\n            setErrors(1);\n            stopAll();\n            setOutputDone();  // signal end to receiver(s)\n            return false;\n        }\n    \n        return true;\n    }","commit_id":"e792bee3bd52d1ed8c6b6d949d21a5116dd7e978","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Keys:\n     *   - natural key fields\n     * Values:\n     *   - Technical key\n     *   - lookup fields / extra fields (allows us to compare or retrieve)\n     *   - Date_from\n     *   - Date_to\n     *   \n     * @param row The input row\n     * @param technicalKey the technical key value\n     * @param valueDateFrom the start of valid date range\n     * @param valueDateTo the end of the valid date range\n     * @return the values to store in the cache as a row.\n     */\n    private Object[] getCacheValues(RowMetaInterface rowMeta, Object[] row, Long technicalKey, Long valueVersion, Date valueDateFrom, Date valueDateTo)\n    {\n        Object[] cacheValues = new Object[data.cacheValueRowMeta.size()];\n        int cacheIndex = 0;\n        \n        cacheValues[cacheIndex] = technicalKey;\n        cacheIndex++;\n        \n        cacheValues[cacheIndex] = valueVersion;\n        cacheIndex++;\n        \n        for (int i=0;i<data.fieldnrs.length;i++)\n        {\n            cacheValues[cacheIndex] = row[ data.fieldnrs[i] ];\n            cacheIndex++;\n        }\n\n        cacheValues[cacheIndex] = valueDateFrom;\n        cacheIndex++;\n        \n        cacheValues[cacheIndex] = valueDateTo;\n        cacheIndex++;\n        \n        return cacheValues;\n    }","id":41441,"modified_method":"/**\n     * Keys:\n     *   - natural key fields\n     * Values:\n     *   - Technical key\n     *   - lookup fields / extra fields (allows us to compare or retrieve)\n     *   - Date_from\n     *   - Date_to\n     *   \n     * @param row The input row\n     * @param technicalKey the technical key value\n     * @param valueDateFrom the start of valid date range\n     * @param valueDateTo the end of the valid date range\n     * @return the values to store in the cache as a row.\n     */\n    private Object[] getCacheValues(RowMetaInterface rowMeta, Object[] row, Long technicalKey, Long valueVersion, Date valueDateFrom, Date valueDateTo)\n    {\r\n    \tif (data.cacheValueRowMeta==null) return null; // nothing is in the cache.\r\n    \t\n        Object[] cacheValues = new Object[data.cacheValueRowMeta.size()];\n        int cacheIndex = 0;\n        \n        cacheValues[cacheIndex] = technicalKey;\n        cacheIndex++;\n        \n        cacheValues[cacheIndex] = valueVersion;\n        cacheIndex++;\n        \n        for (int i=0;i<data.fieldnrs.length;i++)\n        {\n            cacheValues[cacheIndex] = row[ data.fieldnrs[i] ];\n            cacheIndex++;\n        }\n\n        cacheValues[cacheIndex] = valueDateFrom;\n        cacheIndex++;\n        \n        cacheValues[cacheIndex] = valueDateTo;\n        cacheIndex++;\n        \n        return cacheValues;\n    }","commit_id":"e792bee3bd52d1ed8c6b6d949d21a5116dd7e978","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private List<String> installLinux(List<String> urls, String saveAs) {\n\n        log.info(\"Installing from package manager couchbase-server version: {}\", getVersion());\n\n        String apt = chainGroup(\n                \"export DEBIAN_FRONTEND=noninteractive\",\n                \"which apt-get\",\n                sudo(\"apt-get update\"),\n                sudo(\"apt-get install -y libssl0.9.8\"),\n                sudo(format(\"dpkg -i %s\", saveAs)));\n\n        String yum = chainGroup(\n                \"which yum\",\n                sudo(\"yum check-update\"),\n                sudo(\"yum install -y pkgconfig\"),\n                // RHEL requires openssl version 098\n                sudo(\"[ -f /etc/redhat-release ] && (grep -i \\\"red hat\\\" /etc/redhat-release && yum install -y openssl098e) || :\"),\n                sudo(format(\"rpm --install %s\", saveAs)));\n\n        return ImmutableList.<String>builder()\n                .add(INSTALL_CURL)\n                .addAll(BashCommands.commandsToDownloadUrlsAs(urls, saveAs))\n                .add(alternatives(apt, yum))\n                .build();\n    }","id":41442,"modified_method":"private List<String> installLinux(List<String> urls, String saveAs) {\n\n        log.info(\"Installing from package manager couchbase-server version: {}\", getVersion());\n\n        String apt = chainGroup(\n                \"export DEBIAN_FRONTEND=noninteractive\",\n                \"which apt-get\",\n                sudo(\"apt-get update\"),\n                sudo(\"apt-get install -y libssl0.9.8\"),\n                sudo(format(\"dpkg -i %s\", saveAs)));\n\n        String yum = chainGroup(\n                \"which yum\",\n                // The following prevents failure on RHEL AWS nodes:\n                // https://forums.aws.amazon.com/thread.jspa?threadID=100509\n                ok(sudo(\"sed -i.bk s/^enabled=1$/enabled=0/ /etc/yum/pluginconf.d/subscription-manager.conf\")),\n                ok(sudo(\"yum check-update\")),\n                sudo(\"yum install -y pkgconfig\"),\n                // RHEL requires openssl version 098\n                sudo(\"[ -f /etc/redhat-release ] && (grep -i \\\"red hat\\\" /etc/redhat-release && sudo yum install -y openssl098e) || :\"),\n                sudo(format(\"rpm --install %s\", saveAs)));\n\n        return ImmutableList.<String>builder()\n                .add(INSTALL_CURL)\n                .addAll(BashCommands.commandsToDownloadUrlsAs(urls, saveAs))\n                .add(alternatives(apt, yum))\n                .build();\n    }","commit_id":"48c22178417698c7891a4cd29ebc78d5d1db2ec9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        //FIXME needs time for http server to initialize\n        Time.sleep(Duration.TEN_SECONDS);\n        newScript(LAUNCHING)\n                .body.append(\n                sudo(\"/etc/init.d/couchbase-server start\"),\n                couchbaseCli(\"cluster-init\") +\n                        getCouchbaseHostnameAndPort() +\n                        \" --cluster-init-username=\" + getUsername() +\n                        \" --cluster-init-password=\" + getPassword() +\n                        \" --cluster-init-port=\" + getWebPort() +\n                        \" --cluster-init-ramsize=\" + getClusterInitRamSize())\n                .execute();\n    }","id":41443,"modified_method":"@Override\n    public void launch() {\n        newScript(LAUNCHING)\n                .body.append(\n                sudo(\"/etc/init.d/couchbase-server start\"),\n                \"for i in {0..120}\\n\" +\n                \"do\\n\" +\n                \"    if [ $i -eq 120 ]; then echo REST API unavailable after 120 seconds, failing; exit 1; fi;\\n\" +\n                \"    curl -s \" + String.format(\"http://%s:%s\", getHostname(), getWebPort()) + \" > /dev/null && echo REST API available after $i seconds && break\\n\" +\n                \"    sleep 1\\n\" +\n                \"done\\n\" +\n                couchbaseCli(\"cluster-init\") +\n                        getCouchbaseHostnameAndPort() +\n                        \" --cluster-init-username=\" + getUsername() +\n                        \" --cluster-init-password=\" + getPassword() +\n                        \" --cluster-init-port=\" + getWebPort() +\n                        \" --cluster-init-ramsize=\" + getClusterInitRamSize())\n                .execute();\n    }","commit_id":"48c22178417698c7891a4cd29ebc78d5d1db2ec9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        Entity cbNode = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER);\n        Entities.waitForServiceUp(cbNode, Duration.ONE_HOUR);\n        DependentConfiguration.waitInTaskForAttributeReady(cbNode, CouchbaseCluster.IS_CLUSTER_INITIALIZED, Predicates.equalTo(true));\n        try {\n            // Even once the bucket has published its API URL, it can still take a couple of seconds for it to become available\n            Thread.sleep(10 * 1000);\n        } catch (InterruptedException e) {\n            // no-op\n        }\n        if (cbNode instanceof CouchbaseCluster) {\n            Optional<Entity> cbClusterNode = Iterables.tryFind(cbNode.getAttribute(CouchbaseCluster.GROUP_MEMBERS), new Predicate<Entity>() {\n\n                @Override\n                public boolean apply(@Nullable Entity entity) {\n                    if (entity instanceof CouchbaseNode && Boolean.TRUE.equals(entity.getAttribute(CouchbaseNode.IS_IN_CLUSTER))) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            if (cbClusterNode.isPresent()) {\n                cbNode = cbClusterNode.get();\n            } else {\n                throw new IllegalArgumentException(format(\"The cluster %s does not contain any suitable Couchbase nodes to connect to..\", cbNode.getId()));\n            }\n\n        }\n        String hostname = cbNode.getAttribute(CouchbaseNode.HOSTNAME);\n        String webPort = cbNode.getAttribute(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT).toString();\n\n\n        String username = cbNode.getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME);\n        String password = cbNode.getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD);\n\n        String bucketName = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER_BUCKET);\n        String pool = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER_POOL);\n        String pretty = entity.getConfig(CouchbaseSyncGateway.PRETTY) ? \"-pretty\" : \"\";\n        String verbose = entity.getConfig(CouchbaseSyncGateway.VERBOSE) ? \"-verbose\" : \"\";\n\n        String adminRestApiPort = entity.getConfig(CouchbaseSyncGateway.ADMIN_REST_API_PORT).iterator().next().toString();\n        String syncRestApiPort = entity.getConfig(CouchbaseSyncGateway.SYNC_REST_API_PORT).iterator().next().toString();\n\n        String serverWebAdminUrl = format(\"http://%s:%s@%s:%s\", username, password, hostname, webPort);\n        String options = format(\"-url %s -bucket %s -adminInterface 0.0.0.0:%s -interface 0.0.0.0:%s -pool %s %s %s\",\n                serverWebAdminUrl, bucketName, adminRestApiPort, syncRestApiPort, pool, pretty, verbose);\n\n        newScript(ImmutableMap.of(\"usePidFile\", true), LAUNCHING)\n                .body.append(format(\"/opt/couchbase-sync-gateway/bin/sync_gateway %s \", options) + \"> out.log 2> err.log < /dev/null &\")\n                .failOnNonZeroResultCode()\n                .execute();\n    }","id":41444,"modified_method":"@Override\n    public void launch() {\n        Entity cbNode = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER);\n        Entities.waitForServiceUp(cbNode, Duration.ONE_HOUR);\n        DependentConfiguration.waitInTaskForAttributeReady(cbNode, CouchbaseCluster.IS_CLUSTER_INITIALIZED, Predicates.equalTo(true));\n        // Even once the bucket has published its API URL, it can still take a couple of seconds for it to become available\n        Time.sleep(10 * 1000);\n        if (cbNode instanceof CouchbaseCluster) {\n            Optional<Entity> cbClusterNode = Iterables.tryFind(cbNode.getAttribute(CouchbaseCluster.GROUP_MEMBERS), new Predicate<Entity>() {\n\n                @Override\n                public boolean apply(@Nullable Entity entity) {\n                    if (entity instanceof CouchbaseNode && Boolean.TRUE.equals(entity.getAttribute(CouchbaseNode.IS_IN_CLUSTER))) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            if (cbClusterNode.isPresent()) {\n                cbNode = cbClusterNode.get();\n            } else {\n                throw new IllegalArgumentException(format(\"The cluster %s does not contain any suitable Couchbase nodes to connect to..\", cbNode.getId()));\n            }\n\n        }\n        String hostname = cbNode.getAttribute(CouchbaseNode.HOSTNAME);\n        String webPort = cbNode.getAttribute(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT).toString();\n\n\n        String username = cbNode.getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME);\n        String password = cbNode.getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD);\n\n        String bucketName = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER_BUCKET);\n        String pool = entity.getConfig(CouchbaseSyncGateway.COUCHBASE_SERVER_POOL);\n        String pretty = entity.getConfig(CouchbaseSyncGateway.PRETTY) ? \"-pretty\" : \"\";\n        String verbose = entity.getConfig(CouchbaseSyncGateway.VERBOSE) ? \"-verbose\" : \"\";\n\n        String adminRestApiPort = entity.getConfig(CouchbaseSyncGateway.ADMIN_REST_API_PORT).iterator().next().toString();\n        String syncRestApiPort = entity.getConfig(CouchbaseSyncGateway.SYNC_REST_API_PORT).iterator().next().toString();\n\n        String serverWebAdminUrl = format(\"http://%s:%s@%s:%s\", username, password, hostname, webPort);\n        String options = format(\"-url %s -bucket %s -adminInterface 0.0.0.0:%s -interface 0.0.0.0:%s -pool %s %s %s\",\n                serverWebAdminUrl, bucketName, adminRestApiPort, syncRestApiPort, pool, pretty, verbose);\n\n        newScript(ImmutableMap.of(\"usePidFile\", true), LAUNCHING)\n                .body.append(format(\"/opt/couchbase-sync-gateway/bin/sync_gateway %s \", options) + \"> out.log 2> err.log < /dev/null &\")\n                .failOnNonZeroResultCode()\n                .execute();\n    }","commit_id":"48c22178417698c7891a4cd29ebc78d5d1db2ec9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void install() {\n        log.info(\"Installing {}\", entity);\n        List<String> commands = ImmutableList.<String>builder()\n                .add(ifExecutableElse0(\"zypper\", chainGroup( // SLES 11 not supported, would require building from source\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_11.4 erlang_suse_11\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_12.3 erlang_suse_12\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_13.1 erlang_suse_13\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_11.4 db_suse_11\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_12.3 db_suse_12\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_13.1 db_suse_13\"))))\n                .add(installPackage( // NOTE only 'port' states the version of Erlang used, maybe remove this constraint?\n                        ImmutableMap.of(\n                                \"apt\", \"erlang-nox erlang-dev\",\n                                \"port\", \"erlang@\"+getErlangVersion()+\"+ssl\"),\n                        \"erlang\"))\n                .add(installPackage(\"couchdb\"))\n                .add(ifExecutableElse0(\"service\", sudo(\"service couchdb stop\")))\n                .build();\n\n        newScript(INSTALLING)\n                .body.append(commands)\n                .execute();\n    }","id":41445,"modified_method":"@Override\n    public void install() {\n        log.info(\"Installing {}\", entity);\n        List<String> commands = ImmutableList.<String>builder()\n                .add(ifExecutableElse0(\"zypper\", chainGroup( // SLES 11 not supported, would require building from source\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_11.4 erlang_suse_11\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_12.3 erlang_suse_12\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_13.1 erlang_suse_13\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_11.4 db_suse_11\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_12.3 db_suse_12\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/server:/database/openSUSE_13.1 db_suse_13\")))))\n                .add(installPackage( // NOTE only 'port' states the version of Erlang used, maybe remove this constraint?\n                        ImmutableMap.of(\n                                \"apt\", \"erlang-nox erlang-dev\",\n                                \"port\", \"erlang@\"+getErlangVersion()+\"+ssl\"),\n                        \"erlang\"))\n                .add(installPackage(\"couchdb\"))\n                .add(ifExecutableElse0(\"service\", sudo(\"service couchdb stop\")))\n                .build();\n\n        newScript(INSTALLING)\n                .body.append(commands)\n                .execute();\n    }","commit_id":"9069f9b93e1c745e77a399c6c39efc17d7a8d26d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        List<String> urls = resolver.getTargets();\n        String saveAs = resolver.getFilename();\n        setExpandedInstallDir(getInstallDir()+\"/\"+resolver.getUnpackedDirectoryName(format(\"rabbitmq_server-%s\", getVersion())));\n        \n        List<String> commands = ImmutableList.<String>builder()\n                .add(ifExecutableElse0(\"zypper\", chainGroup(\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/SLE_11_SP3 erlang_sles_11\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_11.4 erlang_suse_11\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_12.3 erlang_suse_12\"),\n                        sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_13.1 erlang_suse_13\"))))\n                .add(installPackage( // NOTE only 'port' states the version of Erlang used, maybe remove this constraint?\n                        ImmutableMap.of(\n                                \"apt\", \"erlang-nox erlang-dev\",\n                                \"port\", \"erlang@\"+getErlangVersion()+\"+ssl\"),\n                        \"erlang\"))\n                .addAll(commandsToDownloadUrlsAs(urls, saveAs))\n                .add(installExecutable(\"tar\"))\n                .add(format(\"tar xvzf %s\",saveAs))\n                .build();\n\n        newScript(INSTALLING).\n                failOnNonZeroResultCode().\n                body.append(commands).execute();\n    }","id":41446,"modified_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        List<String> urls = resolver.getTargets();\n        String saveAs = resolver.getFilename();\n        setExpandedInstallDir(getInstallDir()+\"/\"+resolver.getUnpackedDirectoryName(format(\"rabbitmq_server-%s\", getVersion())));\n\n        List<String> commands = ImmutableList.<String>builder()\n                .add(ifExecutableElse0(\"zypper\", chainGroup(\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/SLE_11_SP3 erlang_sles_11\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_11.4 erlang_suse_11\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_12.3 erlang_suse_12\")),\n                        ok(sudo(\"zypper --non-interactive addrepo http://download.opensuse.org/repositories/devel:/languages:/erlang/openSUSE_13.1 erlang_suse_13\")))))\n                .add(installPackage( // NOTE only 'port' states the version of Erlang used, maybe remove this constraint?\n                        ImmutableMap.of(\n                                \"apt\", \"erlang-nox erlang-dev\",\n                                \"port\", \"erlang@\"+getErlangVersion()+\"+ssl\"),\n                        \"erlang\"))\n                .addAll(commandsToDownloadUrlsAs(urls, saveAs))\n                .add(installExecutable(\"tar\"))\n                .add(format(\"tar xvzf %s\",saveAs))\n                .build();\n\n        newScript(INSTALLING).\n                failOnNonZeroResultCode().\n                body.append(commands).execute();\n    }","commit_id":"9069f9b93e1c745e77a399c6c39efc17d7a8d26d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false);\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","id":41447,"modified_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false).object();\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","commit_id":"e57a6c3d2bf52ea6f42c42d7d3e529a444f78bdd","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false);\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","id":41448,"modified_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false).object();\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","commit_id":"20df1e6155ec8ef667cfeaf51c6e1461ad8f5784","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false);\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","id":41449,"modified_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    int numTrainingIterations = 10;\n\n    String serializedPath = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-numTrainingIterations\")) {\n        numTrainingIterations = Integer.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      // TODO: do something with the remaining args, such as set the Options flags...\n      // TODO: allow for different languages; by default this does English\n      // TODO: since Options and buildTrainTransformer are used in so\n      // many different places, it would make sense to factor that out\n      Options op = new Options();\n      CompositeTreeTransformer transformer = LexicalizedParser.buildTrainTransformer(op);\n      BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n      transformer.addTransformer(basicTransformer);\n      \n      System.err.println(\"Loading training trees from \" + trainTreebankPath);\n      Treebank trainTreebank = op.tlpParams.memoryTreebank();;\n      trainTreebank.loadPath(trainTreebankPath, trainTreebankFilter);\n      trainTreebank = trainTreebank.transform(transformer);\n      System.err.println(\"Read in \" + trainTreebank.size() + \" trees from \" + trainTreebankPath);\n\n      HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n      List<Tree> binarizedTrees = Generics.newArrayList();\n      for (Tree tree : trainTreebank) {\n        Trees.convertToCoreLabels(tree);\n        tree.percolateHeadAnnotations(binaryHeadFinder);\n        binarizedTrees.add(tree);\n      }\n\n      // TODO: allow different feature factories, such as for different languages\n      FeatureFactory featureFactory = new BasicFeatureFactory();\n\n      Index<Transition> transitionIndex = new HashIndex<Transition>();\n      Index<String> featureIndex = new HashIndex<String>();\n      for (Tree tree : binarizedTrees) {\n        List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n        transitionIndex.addAll(transitions);\n\n        State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n        for (Transition transition : transitions) {\n          Set<String> features = featureFactory.featurize(state);\n          featureIndex.addAll(features);\n          state = transition.apply(state);\n        }\n      }\n\n      System.err.println(\"Number of unique features: \" + featureIndex.size());\n      System.err.println(\"Number of transitions: \" + transitionIndex.size());\n      System.err.println(\"Feature space will be \" + (featureIndex.size() * transitionIndex.size()));\n      \n      double[][] featureWeights = new double[transitionIndex.size()][featureIndex.size()];\n\n      parser = new ShiftReduceParser(transitionIndex, featureIndex, featureWeights, op, featureFactory);\n\n      for (int i = 0; i < numTrainingIterations; ++i) {\n        int numCorrect = 0;\n        int numWrong = 0;\n        for (Tree tree : binarizedTrees) {\n          List<Transition> transitions = CreateTransitionSequence.createTransitionSequence(tree);\n          State state = ShiftReduceParser.initialStateFromGoldTagTree(tree);\n          for (Transition transition : transitions) {\n            int transitionNum = transitionIndex.indexOf(transition);\n            Set<String> features = featureFactory.featurize(state);\n            int predictedNum = parser.findHighestScoringTransition(state, features, false).object();\n            Transition predicted = transitionIndex.get(predictedNum);\n            if (transitionNum == predictedNum) {\n              numCorrect++;\n            } else {\n              numWrong++;\n              for (String feature : features) {\n                int featureNum = featureIndex.indexOf(feature);\n                // TODO: allow weighted features, weighted training, etc\n                featureWeights[predictedNum][featureNum] -= 1.0;\n                featureWeights[transitionNum][featureNum] += 1.0;\n              }\n            }\n            state = transition.apply(state);\n          }\n        }\n        System.err.println(\"Iteration \" + i + \" complete\");\n        System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      }\n\n      if (serializedPath != null) {\n        try {\n          IOUtils.writeObjectToFile(parser, serializedPath);\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n\n    if (serializedPath != null && parser == null) {\n      try {\n        parser = IOUtils.readObjectFromFile(serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      } catch (ClassNotFoundException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      parser.op.setOptions(\"-forceTags\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","commit_id":"ebc6df2f60791d5964b426dc19e491fd2ca1bca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public InternalAddition_ActionGroup() {\n    super(\"Internal\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.LoadNonStubModels_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.OptimizeImportsInGlobalScope_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModulePersistenceGlobally_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.FindDuplicatedStubs_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":41450,"modified_method":"public InternalAddition_ActionGroup() {\n    super(\"Internal\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.LoadNonStubModels_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.OptimizeImportsInGlobalScope_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModulePersistenceGlobally_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceGlobally_Action\");\n      InternalAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.FindDuplicatedStubs_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void stage_6_1_regeneration(MPSProject p) {\n    ProjectOperationContext poc = ProjectOperationContext.get(p.getProject());\n    new MakeActionImpl(poc, new MakeActionParameters(poc, null, null, p.getModules(), null), true).executeAction();\n  }","id":41451,"modified_method":"public static void stageRegeneration(MPSProject p) {\n    ProjectOperationContext poc = ProjectOperationContext.get(p.getProject());\n    new MakeActionImpl(poc, new MakeActionParameters(poc, null, null, p.getModules(), null), true).executeAction();\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void stage_2_5_fixDependenciesEverywhere(MPSProject p) {\n    for (SModelDescriptor model : p.getProjectModels()) {\n      if (!(model instanceof EditableSModelDescriptor)) continue;\n      if (model.getModule() == null) continue;\n      new MissingDependenciesFixer(ProjectOperationContext.get(p.getProject()), model).fix(false);\n    }\n    ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());\n  }","id":41452,"modified_method":"public static void stageFixDependencies(MPSProject p) {\n    for (Language lang : p.getProjectModules(Language.class)) {\n      lang.addUsedDevkit(LanguageDesign_DevKit.MODULE_REFERENCE);\n      lang.save();\n    }\n    for (Language l : p.getProjectModules(Language.class)) {\n      for (SModelDescriptor aspect : l.getAspectModelDescriptors()) {\n        aspect.getSModel().addDevKit(GeneralPurpose_DevKit.MODULE_REFERENCE);\n      }\n    }\n    for (Language l : p.getProjectModules(Language.class)) {\n      for (SModelDescriptor aspect : l.getAspectModelDescriptors()) {\n        aspect.getSModel().deleteDevKit(LanguageDesign_DevKit.MODULE_REFERENCE);\n      }\n    }\n    for (Language l : p.getProjectModules(Language.class)) {\n      for (SModelDescriptor aspect : l.getAspectModelDescriptors()) {\n        SModel sModel = aspect.getSModel();\n        if (sModel.importedDevkits().contains(BootstrapLanguages_DevKit.MODULE_REFERENCE)) {\n          sModel.deleteDevKit(BootstrapLanguages_DevKit.MODULE_REFERENCE);\n        }\n      }\n    }\n    for (SModelDescriptor model : p.getProjectModels()) {\n      if (!(model instanceof EditableSModelDescriptor)) continue;\n      if (model.getModule() == null) continue;\n      new MissingDependenciesFixer(ProjectOperationContext.get(p.getProject()), model).fix(false);\n    }\n    SModelRepository.getInstance().saveAll();\n    ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void stage_5_1_migrations(MPSProject p) {\n\n  }","id":41453,"modified_method":"public static void stageLanguageMigrations(MPSProject p) {\n    List<SNodePointer> scripts = new ArrayList<SNodePointer>();\n    scripts.add(getScript(\"jetbrains.mps.lang.core\", \"ConvertAttributes\"));\n    executeScripts(p.getProject(), scripts);\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void migrate() {\n    MigrationState msComponent = myProject.getComponent(MigrationState.class);\n    MPSProject mpsProject = myProject.getComponent(MPSProject.class);\n\n    if (msComponent.getMigrationState() == MState.INITIAL) {\n      stage_1_1_invalidateCaches();\n      msComponent.setMigrationState(MState.CACHES_INVALIDATED);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.CACHES_INVALIDATED) {\n      stage_2_1_addLanguageDesingDevKitToLanguages(mpsProject);\n      stage_2_2_addGeneralPurposeDevKitToLanguageModels(mpsProject);\n      stage_2_3_removeLanguageDesignDevKitFromModels(mpsProject);\n      stage_2_4_removeBootstrapLanguagesDevKitFromLanguageModels(mpsProject);\n      stage_2_5_fixDependenciesEverywhere(mpsProject);\n\n      msComponent.setMigrationState(MState.LANGUAGES_DEPS_CORRECTED);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_DEPS_CORRECTED) {\n      stage_3_1_updateLanguageAccessories(mpsProject);\n      stage_3_2_reResolveStubRefs(mpsProject);\n      stage_3_3_optimizeImports(mpsProject);\n\n      msComponent.setMigrationState(MState.STUBS_CONVERTED);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.STUBS_CONVERTED) {\n      stage_4_1_convertAttributes(mpsProject);\n\n      msComponent.setMigrationState(MState.ATTRIBUTES_CONVERTED);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.ATTRIBUTES_CONVERTED) {\n      stage_5_1_migrations(mpsProject);\n\n      msComponent.setMigrationState(MState.LANGUAGES_MIGRATION);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_MIGRATION) {\n      stage_6_1_regeneration(mpsProject);\n\n      msComponent.setMigrationState(MState.REGENERATION);\n      ApplicationManager.getApplication().restart();\n    }\n\n    if (msComponent.getMigrationState() == MState.REGENERATION) {\n      msComponent.setMigrationState(MState.DONE);\n    }\n  }","id":41454,"modified_method":"public void migrate() {\n    MigrationState msComponent = myProject.getComponent(MigrationState.class);\n    MPSProject mpsProject = myProject.getComponent(MPSProject.class);\n\n    if (msComponent.getMigrationState() == MState.INITIAL) {\n      stageUpgradePersistence(mpsProject);\n      msComponent.setMigrationState(MState.PERSISTENCE_UPGRADED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.PERSISTENCE_UPGRADED) {\n      stageFixDependencies(mpsProject);\n      msComponent.setMigrationState(MState.LANGUAGES_DEPS_CORRECTED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_DEPS_CORRECTED) {\n      stageStubsMigration(mpsProject);\n      msComponent.setMigrationState(MState.STUBS_CONVERTED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.STUBS_CONVERTED) {\n      stageLanguageMigrations(mpsProject);\n      msComponent.setMigrationState(MState.LANGUAGES_MIGRATION);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_MIGRATION) {\n      stageRegeneration(mpsProject);\n      msComponent.setMigrationState(MState.REGENERATION);\n    }\n\n    if (msComponent.getMigrationState() == MState.REGENERATION) {\n      msComponent.setMigrationState(MState.DONE);\n    }\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static int stage_3_2_reResolveStubRefs(MPSProject p) {\n    int i = 0;\n    Map<String, SModelReference> cache = new HashMap<String, SModelReference>();\n    for (SModelDescriptor d : p.getProject().getComponent(ProjectScope.class).getModelDescriptors()) {\n      if (!(d instanceof EditableSModelDescriptor)) continue;\n      if (!(SModelStereotype.isUserModel(d))) continue;\n      if (d == null) continue;\n\n      IModule module = d.getModule();\n      if (module == null) continue;\n\n      Set<SModelReference> toRemove = new HashSet<SModelReference>();\n      for (SNode node : d.getSModel().nodes()) {\n        for (SReference ref : node.getReferences()) {\n          SModelId modelId = ref.getTargetSModelReference().getSModelId();\n          SNodeId nodeId = ref.getTargetNodeId();\n\n          if (modelId instanceof SModelId.RegularSModelId) continue;\n          if (ref.getTargetNode() != null) continue;\n\n          String oldId = ((SModelId.ForeignSModelId) modelId).getId();\n          SModelReference replacement = null;\n\n          SModelReference cachedReplacement = cache.get(oldId);\n          if (cachedReplacement != null && module.getScope().getModelDescriptor(cachedReplacement) != null) {\n            replacement = cachedReplacement;\n          } else {\n            for (SModelDescriptor md : module.getScope().getModelDescriptors()) {\n              SModelReference mdRef = md.getSModelReference();\n              SModelId mdId = mdRef.getSModelId();\n              if (mdId instanceof SModelId.RegularSModelId) continue;\n              if (!(matches(oldId, ((SModelId.ForeignSModelId) mdId).getId()))) continue;\n              if (md.getSModel().getNodeById(nodeId) == null) continue;\n\n              replacement = md.getSModelReference();\n              cache.put(oldId, replacement);\n              break;\n            }\n          }\n\n          if (replacement != null) {\n            toRemove.add(ref.getTargetSModelReference());\n\n            SModelReference mr = replacement;\n            d.getSModel().addModelImport(mr, false);\n            ref.setTargetSModelReference(mr);\n\n            i++;\n          }\n        }\n      }\n      for (SModelReference ref : toRemove) {\n        d.getSModel().deleteModelImport(ref);\n      }\n    }\n    return i;\n  }","id":41455,"modified_method":"public static int reResolveStubRefs(MPSProject p) {\n    int i = 0;\n    Map<String, SModelReference> cache = new HashMap<String, SModelReference>();\n    for (SModelDescriptor d : p.getProject().getComponent(ProjectScope.class).getModelDescriptors()) {\n      if (!(d instanceof EditableSModelDescriptor)) continue;\n      if (!(SModelStereotype.isUserModel(d))) continue;\n      if (d == null) continue;\n\n      IModule module = d.getModule();\n      if (module == null) continue;\n\n      Set<SModelReference> toRemove = new HashSet<SModelReference>();\n      for (SNode node : d.getSModel().nodes()) {\n        for (SReference ref : node.getReferences()) {\n          SModelId modelId = ref.getTargetSModelReference().getSModelId();\n          SNodeId nodeId = ref.getTargetNodeId();\n\n          if (modelId instanceof SModelId.RegularSModelId) continue;\n          if (ref.getTargetNode() != null) continue;\n\n          String oldId = ((SModelId.ForeignSModelId) modelId).getId();\n          SModelReference replacement = null;\n\n          SModelReference cachedReplacement = cache.get(oldId);\n          if (cachedReplacement != null && module.getScope().getModelDescriptor(cachedReplacement) != null) {\n            replacement = cachedReplacement;\n          } else {\n            for (SModelDescriptor md : module.getScope().getModelDescriptors()) {\n              SModelReference mdRef = md.getSModelReference();\n              SModelId mdId = mdRef.getSModelId();\n              if (mdId instanceof SModelId.RegularSModelId) continue;\n              if (!(matches(oldId, ((SModelId.ForeignSModelId) mdId).getId()))) continue;\n              if (md.getSModel().getNodeById(nodeId) == null) continue;\n\n              replacement = md.getSModelReference();\n              cache.put(oldId, replacement);\n              break;\n            }\n          }\n\n          if (replacement != null) {\n            toRemove.add(ref.getTargetSModelReference());\n\n            SModelReference mr = replacement;\n            d.getSModel().addModelImport(mr, false);\n            ref.setTargetSModelReference(mr);\n\n            i++;\n          }\n        }\n      }\n      for (SModelReference ref : toRemove) {\n        d.getSModel().deleteModelImport(ref);\n      }\n    }\n    return i;\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void adjustRegularGroups() {\n    insertGroupIntoAnother(InternalAddition_ActionGroup.ID, ToolsInternal_ActionGroup.ID, null);\n    insertGroupIntoAnother(MakeAddition_ActionGroup.ID, ToolsInternal_ActionGroup.ID, null);\n    insertGroupIntoAnother(Migrations20_ActionGroup.ID, ToolsAddition_ActionGroup.ID, ToolsAddition_ActionGroup.LABEL_ID_migrationGroup);\n    insertGroupIntoAnother(StubsAddition_ActionGroup.ID, Migrations20_ActionGroup.ID, null);\n    insertGroupIntoAnother(ToolsAddition_ActionGroup.ID, Tools_ActionGroup.ID, Tools_ActionGroup.LABEL_ID_migration20);\n    insertGroupIntoAnother(ImportsAddition_ActionGroup.ID, Migrations20_ActionGroup.ID, null);\n    insertGroupIntoAnother(PersistenceAddition_ActionGroup.ID, Migrations20_ActionGroup.ID, null);\n  }","id":41456,"modified_method":"public void adjustRegularGroups() {\n    insertGroupIntoAnother(InternalAddition_ActionGroup.ID, ToolsInternal_ActionGroup.ID, null);\n    insertGroupIntoAnother(MakeAddition_ActionGroup.ID, ToolsInternal_ActionGroup.ID, null);\n    insertGroupIntoAnother(Migrations20_ActionGroup.ID, ToolsAddition_ActionGroup.ID, ToolsAddition_ActionGroup.LABEL_ID_migrationGroup);\n    insertGroupIntoAnother(PersistenceAddition_ActionGroup.ID, Migrations20_ActionGroup.ID, null);\n    insertGroupIntoAnother(ToolsAddition_ActionGroup.ID, Tools_ActionGroup.ID, Tools_ActionGroup.LABEL_ID_migration20);\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddGeneralPurposeDevKitToLanguageModels_Action());\n    addAction(new AddLanguageDesignDevKitToLanguages_Action());\n    addAction(new BuildAllBehaviors_Action());\n    addAction(new BuildAllConstraints_Action());\n    addAction(new BuildAllGenerators_Action());\n    addAction(new BuildAllLanguageDescriptors_Action());\n    addAction(new BuildAllStructures_Action());\n    addAction(new FindDuplicatedStubs_Action());\n    addAction(new FixDependenciesEverywhere_Action());\n    addAction(new FixVirtualPackages_Action());\n    addAction(new LoadNonStubModels_Action());\n    addAction(new Migration20_Action());\n    addAction(new OptimizeImportsInGlobalScope_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new ReResolveStubRefs_Action());\n    addAction(new RemoveBootstrapLanguagesDevKitFromLanguageModels_Action());\n    addAction(new RemoveLanguageDesignDevKitFromModels_Action());\n    addAction(new UpdateLanguageAccessories_Action());\n    addAction(new UpgradeModelPersistenceGlobally_Action());\n    addAction(new UpgradeModelPersistenceInModel_Action());\n    addAction(new UpgradeModelPersistenceInModule_Action());\n    addAction(new UpgradeModelPersistenceInProject_Action());\n    addAction(new UpgradeModulePersistenceGlobally_Action());\n    addAction(new UpgradeModulePersistenceInProject_Action());\n    // groups \n    addGroup(new ImportsAddition_ActionGroup());\n    addGroup(new InternalAddition_ActionGroup());\n    addGroup(new MakeAddition_ActionGroup());\n    addGroup(new Migrations20_ActionGroup());\n    addGroup(new PersistenceAddition_ActionGroup());\n    addGroup(new StubsAddition_ActionGroup());\n    addGroup(new ToolsAddition_ActionGroup());\n  }","id":41457,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new BuildAllBehaviors_Action());\n    addAction(new BuildAllConstraints_Action());\n    addAction(new BuildAllGenerators_Action());\n    addAction(new BuildAllLanguageDescriptors_Action());\n    addAction(new BuildAllStructures_Action());\n    addAction(new FindDuplicatedStubs_Action());\n    addAction(new FixModuleDependencies_Action());\n    addAction(new LoadNonStubModels_Action());\n    addAction(new MigrateStubs_Action());\n    addAction(new Migration20_Action());\n    addAction(new OptimizeImportsInGlobalScope_Action());\n    addAction(new UpgradeModelPersistenceGlobally_Action());\n    addAction(new UpgradeModelPersistenceInModel_Action());\n    addAction(new UpgradeModelPersistenceInModule_Action());\n    addAction(new UpgradeModulePersistenceGlobally_Action());\n    addAction(new UpgradePersistence_Action());\n    // groups \n    addGroup(new InternalAddition_ActionGroup());\n    addGroup(new MakeAddition_ActionGroup());\n    addGroup(new Migrations20_ActionGroup());\n    addGroup(new PersistenceAddition_ActionGroup());\n    addGroup(new ToolsAddition_ActionGroup());\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Migrations20_ActionGroup() {\n    super(\"Migrations 2.0\", ID);\n    this.setIsInternal(false);\n    this.setPopup(true);\n    try {\n      Migrations20_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.FixVirtualPackages_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":41458,"modified_method":"public Migrations20_ActionGroup() {\n    super(\"Migrations 2.0\", ID);\n    this.setIsInternal(false);\n    this.setPopup(true);\n    try {\n      Migrations20_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradePersistence_Action\");\n      Migrations20_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.FixModuleDependencies_Action\");\n      Migrations20_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.MigrateStubs_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PersistenceAddition_ActionGroup() {\n    super(\"PersistenceAddition\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      PersistenceAddition_ActionGroup.this.addSeparator();\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceGlobally_Action\");\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceInProject_Action\");\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceInModule_Action\");\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceInModel_Action\");\n      PersistenceAddition_ActionGroup.this.addSeparator();\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModulePersistenceInProject_Action\");\n      PersistenceAddition_ActionGroup.this.addSeparator();\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":41459,"modified_method":"public PersistenceAddition_ActionGroup() {\n    super(\"Persistence\", ID);\n    this.setIsInternal(false);\n    this.setPopup(true);\n    try {\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceInModule_Action\");\n      PersistenceAddition_ActionGroup.this.addAction(\"jetbrains.mps.ide.migration.actions.UpgradeModelPersistenceInModel_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void upgradePersistenceInProject(Project project, Frame mainFrame) {\n    MPSProject p = project.getComponent(MPSProject.class);\n    upgradePersistenceInUnit(project.getComponent(ProjectScope.class), \"Project \" + p.getProjectFile().toString(), mainFrame);\n  }","id":41460,"modified_method":"public void upgradePersistenceInProject(Project project, JFrame mainFrame) {\n    MPSProject p = project.getComponent(MPSProject.class);\n    upgradePersistenceInUnit(project.getComponent(ProjectScope.class), \"Project \" + p.getProjectFile().toString(), mainFrame);\n  }","commit_id":"a8e9f35879b492e45942eaff083b75674e2870ca","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\tMBCategory category = getCategory(portletRequest);\n\n\t\tif (isSubscribed(portletRequest, category)) {\n\t\t\tkey = \"unsubscribe\";\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","id":41461,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\ttry {\n\t\t\tMBCategory category = ActionUtil.getCategory(portletRequest);\n\n\t\t\tif (isSubscribed(portletRequest, category)) {\n\t\t\t\tkey = \"unsubscribe\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\tportletRequest, MBPortletKeys.MESSAGE_BOARDS_ADMIN,\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tportletURL.setParameter(\n\t\t\tActionRequest.ACTION_NAME, \"/message_boards/edit_category\");\n\n\t\tMBCategory category = getCategory(portletRequest);\n\n\t\tif (isSubscribed(portletRequest, category)) {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"redirect\", PortalUtil.getCurrentURL(portletRequest));\n\t\tportletURL.setParameter(\n\t\t\t\"mbCategoryId\", String.valueOf(category.getCategoryId()));\n\n\t\treturn portletURL.toString();\n\t}","id":41462,"modified_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\tportletRequest, MBPortletKeys.MESSAGE_BOARDS_ADMIN,\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tportletURL.setParameter(\n\t\t\tActionRequest.ACTION_NAME, \"/message_boards/edit_category\");\n\n\t\tMBCategory category = null;\n\n\t\ttry {\n\t\t\tcategory = ActionUtil.getCategory(portletRequest);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isSubscribed(portletRequest, category)) {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"redirect\", PortalUtil.getCurrentURL(portletRequest));\n\t\tportletURL.setParameter(\n\t\t\t\"mbCategoryId\", String.valueOf(category.getCategoryId()));\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isShow(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\treturn MBCategoryPermission.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tgetCategory(portletRequest), ActionKeys.SUBSCRIBE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\n\t\treturn false;\n\t}","id":41463,"modified_method":"@Override\n\tpublic boolean isShow(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tMBGroupServiceSettings mbGroupServiceSettings =\n\t\t\t\tMBGroupServiceSettings.getInstance(\n\t\t\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\t\tif (!mbGroupServiceSettings.isEmailMessageAddedEnabled() &&\n\t\t\t\t!mbGroupServiceSettings.isEmailMessageUpdatedEnabled()) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tMBCategory category = ActionUtil.getCategory(portletRequest);\n\n\t\t\treturn MBCategoryPermission.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(), category,\n\t\t\t\tActionKeys.SUBSCRIBE);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\tif (isShow(portletRequest)) {\n\t\t\tkey = \"unsubscribe\";\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","id":41464,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\ttry {\n\t\t\tWikiNode node = ActionUtil.getNode(portletRequest);\n\n\t\t\tif (isSubscribed(portletRequest, node)) {\n\t\t\t\tkey = \"unsubscribe\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isSubscribed(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tboolean subscribed = false;\n\n\t\ttry {\n\t\t\tWikiNode node = ActionUtil.getNode(portletRequest);\n\n\t\t\tsubscribed = _subscriptionLocalService.isSubscribed(\n\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\tWikiNode.class.getName(), node.getNodeId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn subscribed;\n\t}","id":41465,"modified_method":"protected boolean isSubscribed(\n\t\tPortletRequest portletRequest, WikiNode node) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\treturn _subscriptionLocalService.isSubscribed(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\tWikiNode.class.getName(), node.getNodeId());\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tWikiNode node = ActionUtil.getNode(portletRequest);\n\n\t\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\t\tportletRequest, WikiPortletKeys.WIKI_ADMIN,\n\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"/wiki/edit_node\");\n\n\t\t\tif (isSubscribed(portletRequest)) {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t\t}\n\n\t\t\tportletURL.setParameter(\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tportletURL.setParameter(\"nodeId\", String.valueOf(node.getNodeId()));\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","id":41466,"modified_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tWikiNode node = ActionUtil.getNode(portletRequest);\n\n\t\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\t\tportletRequest, WikiPortletKeys.WIKI_ADMIN,\n\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"/wiki/edit_node\");\n\n\t\t\tif (isSubscribed(portletRequest, node)) {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t\t}\n\n\t\t\tportletURL.setParameter(\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tportletURL.setParameter(\"nodeId\", String.valueOf(node.getNodeId()));\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tWikiPage page = ActionUtil.getPage(portletRequest);\n\n\t\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\t\tportletRequest, WikiPortletKeys.WIKI_ADMIN,\n\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"/wiki/edit_page\");\n\n\t\t\tif (isSubscribed(portletRequest)) {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t\t}\n\n\t\t\tportletURL.setParameter(\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tportletURL.setParameter(\"nodeId\", String.valueOf(page.getNodeId()));\n\t\t\tportletURL.setParameter(\"title\", page.getTitle());\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","id":41467,"modified_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tWikiPage page = ActionUtil.getPage(portletRequest);\n\n\t\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\t\tportletRequest, WikiPortletKeys.WIKI_ADMIN,\n\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"/wiki/edit_page\");\n\n\t\t\tif (isSubscribed(portletRequest, page)) {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t\t}\n\n\t\t\tportletURL.setParameter(\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tportletURL.setParameter(\"nodeId\", String.valueOf(page.getNodeId()));\n\t\t\tportletURL.setParameter(\"title\", page.getTitle());\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\tif (isSubscribed(portletRequest)) {\n\t\t\tkey = \"unsubscribe\";\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","id":41468,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\ttry {\n\t\t\tWikiPage page = ActionUtil.getPage(portletRequest);\n\n\t\t\tif (isSubscribed(portletRequest, page)) {\n\t\t\t\tkey = \"unsubscribe\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isSubscribed(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tboolean subscribed = false;\n\n\t\ttry {\n\t\t\tWikiPage page = ActionUtil.getPage(portletRequest);\n\n\t\t\tsubscribed = _subscriptionLocalService.isSubscribed(\n\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\tWikiNode.class.getName(), page.getNodeId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn subscribed;\n\t}","id":41469,"modified_method":"protected boolean isSubscribed(\n\t\tPortletRequest portletRequest, WikiPage page) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\treturn _subscriptionLocalService.isSubscribed(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\tWikiNode.class.getName(), page.getNodeId());\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isShow(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\treturn MBMessagePermission.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tgetMBMessage(portletRequest), ActionKeys.SUBSCRIBE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\n\t\treturn false;\n\t}","id":41470,"modified_method":"@Override\n\tpublic boolean isShow(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tMBGroupServiceSettings mbGroupServiceSettings =\n\t\t\t\tMBGroupServiceSettings.getInstance(\n\t\t\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\t\tif (!mbGroupServiceSettings.isEmailMessageAddedEnabled() &&\n\t\t\t\t!mbGroupServiceSettings.isEmailMessageUpdatedEnabled()) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBMessage message = messageDisplay.getMessage();\n\n\t\t\treturn MBMessagePermission.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(), message,\n\t\t\t\tActionKeys.SUBSCRIBE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\tportletRequest, MBPortletKeys.MESSAGE_BOARDS_ADMIN,\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tportletURL.setParameter(\n\t\t\tActionRequest.ACTION_NAME, \"/message_boards/edit_message\");\n\n\t\tMBMessage message = getMBMessage(portletRequest);\n\n\t\tif (isSubscribed(portletRequest, getMBMessage(portletRequest))) {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"redirect\", PortalUtil.getCurrentURL(portletRequest));\n\t\tportletURL.setParameter(\n\t\t\t\"messageId\", String.valueOf(message.getMessageId()));\n\n\t\treturn portletURL.toString();\n\t}","id":41471,"modified_method":"@Override\n\tpublic String getURL(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse) {\n\n\t\tPortletURL portletURL = PortalUtil.getControlPanelPortletURL(\n\t\t\tportletRequest, MBPortletKeys.MESSAGE_BOARDS_ADMIN,\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tportletURL.setParameter(\n\t\t\tActionRequest.ACTION_NAME, \"/message_boards/edit_message\");\n\n\t\tMBMessage message = null;\n\n\t\ttry {\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tmessage = messageDisplay.getMessage();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isSubscribed(portletRequest, message)) {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.UNSUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(Constants.CMD, Constants.SUBSCRIBE);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"redirect\", PortalUtil.getCurrentURL(portletRequest));\n\t\tportletURL.setParameter(\n\t\t\t\"messageId\", String.valueOf(message.getMessageId()));\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\tMBMessage message = getMBMessage(portletRequest);\n\n\t\tif (isSubscribed(portletRequest, message)) {\n\t\t\tkey = \"unsubscribe\";\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","id":41472,"modified_method":"@Override\n\tpublic String getMessage(PortletRequest portletRequest) {\n\t\tString key = \"subscribe\";\n\n\t\ttry {\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBMessage message = messageDisplay.getMessage();\n\n\t\t\tif (isSubscribed(portletRequest, message)) {\n\t\t\t\tkey = \"unsubscribe\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn LanguageUtil.get(\n\t\t\tgetResourceBundle(getLocale(portletRequest)), key);\n\t}","commit_id":"6f66646e58350951a66cc541f7879ae01b0418d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletConfigurationIcon create(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBCategory category = messageDisplay.getCategory();\n\n\t\t\tlong categoryId = MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID;\n\n\t\t\tif (category != null) {\n\t\t\t\tcategoryId = category.getCategoryId();\n\t\t\t}\n\n\t\t\tif (MBCategoryPermission.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), categoryId,\n\t\t\t\t\tActionKeys.LOCK_THREAD)) {\n\n\t\t\t\tMBThread thread = messageDisplay.getThread();\n\n\t\t\t\tif (thread.isLocked()) {\n\t\t\t\t\treturn new UnlockThreadPortletConfigurationIcon(\n\t\t\t\t\t\tportletRequest, thread);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new LockThreadPortletConfigurationIcon(\n\t\t\t\t\t\tportletRequest, thread);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\n\t\treturn null;\n\t}","id":41473,"modified_method":"@Override\n\tpublic PortletConfigurationIcon create(PortletRequest portletRequest) {\n\t\ttry {\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBThread thread = messageDisplay.getThread();\n\n\t\t\treturn new ThreadLockPortletConfigurationIcon(\n\t\t\t\tportletRequest, thread);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"fe29ae8af9a4a2cccaf8815ce413c3616f6dc0e9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletConfigurationIcon create(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tMBGroupServiceSettings mbGroupServiceSettings =\n\t\t\t\tMBGroupServiceSettings.getInstance(\n\t\t\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\t\tif (!mbGroupServiceSettings.isEmailMessageAddedEnabled() &&\n\t\t\t\t!mbGroupServiceSettings.isEmailMessageUpdatedEnabled()) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBMessage message = messageDisplay.getMessage();\n\n\t\t\tif (MBMessagePermission.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), message,\n\t\t\t\t\tActionKeys.SUBSCRIBE)) {\n\n\t\t\t\tif (_subscriptionLocalService.isSubscribed(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\t\tMBThread.class.getName(), message.getThreadId())) {\n\n\t\t\t\t\treturn new UnsubscribeThreadPortletConfigurationIcon(\n\t\t\t\t\t\tportletRequest, message);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new SubscribeThreadPortletConfigurationIcon(\n\t\t\t\t\t\tportletRequest, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\n\t\treturn null;\n\t}","id":41474,"modified_method":"@Override\n\tpublic PortletConfigurationIcon create(PortletRequest portletRequest) {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tMBGroupServiceSettings mbGroupServiceSettings =\n\t\t\t\tMBGroupServiceSettings.getInstance(\n\t\t\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\t\tif (!mbGroupServiceSettings.isEmailMessageAddedEnabled() &&\n\t\t\t\t!mbGroupServiceSettings.isEmailMessageUpdatedEnabled()) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tMBMessageDisplay messageDisplay = ActionUtil.getMessageDisplay(\n\t\t\t\tportletRequest);\n\n\t\t\tMBMessage message = messageDisplay.getMessage();\n\n\t\t\tboolean subscribed = _subscriptionLocalService.isSubscribed(\n\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\tMBThread.class.getName(), message.getThreadId());\n\n\t\t\treturn new ThreadSubscriptionPortletConfigurationIcon(\n\t\t\t\tportletRequest, message, subscribed);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"fe29ae8af9a4a2cccaf8815ce413c3616f6dc0e9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static PsiType captureReturnType(PsiMethodCallExpression call,\n                                          PsiMethod method,\n                                          PsiType ret,\n                                          JavaResolveResult result, \n                                          LanguageLevel languageLevel) {\n    PsiSubstitutor substitutor = result instanceof MethodCandidateInfo && !PsiPolyExpressionUtil.isMethodCallTypeDependsOnInference(call, method)\n                                 ? ((MethodCandidateInfo)result).getSiteSubstitutor()\n                                 : result.getSubstitutor();\n    PsiType substitutedReturnType = substitutor.substitute(ret);\n    if (substitutedReturnType == null) {\n      return TypeConversionUtil.erasure(ret);\n    }\n\n    if (InferenceSession.wasUncheckedConversionPerformed(call)) {\n      // 18.5.2\n      // if unchecked conversion was necessary, then this substitution provides the parameter types of the invocation type, \n      // while the return type and thrown types are given by the erasure of m's type (without applying ').\n      //due to https://bugs.openjdk.java.net/browse/JDK-8135087 erasure is called on substitutedReturnType and not on ret type itself as by spec\n      return TypeConversionUtil.erasure(substitutedReturnType);\n    }\n\n    //15.12.2.6. Method Invocation Type\n    // If unchecked conversion was necessary for the method to be applicable, \n    // the parameter types of the invocation type are the parameter types of the method's type,\n    // and the return type and thrown types are given by the erasures of the return type and thrown types of the method's type.\n    if ((!languageLevel.isAtLeast(LanguageLevel.JDK_1_8) && method.hasTypeParameters() ||\n         !method.hasTypeParameters() && JavaVersionService.getInstance().isAtLeast(call, JavaSdkVersion.JDK_1_8)) &&\n        result instanceof MethodCandidateInfo && ((MethodCandidateInfo)result).isApplicable()) {\n      final PsiType[] args = call.getArgumentList().getExpressionTypes();\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      final boolean varargs = ((MethodCandidateInfo)result).getApplicabilityLevel() == MethodCandidateInfo.ApplicabilityLevel.VARARGS;\n      for (int i = 0; i < args.length; i++) {\n        final PsiType parameterType = substitutor.substitute(PsiTypesUtil.getParameterType(parameters, i, varargs));\n        final PsiType expressionType = args[i];\n        if (expressionType != null && parameterType != null && JavaGenericsUtil.isRawToGeneric(parameterType, expressionType)) {\n          return TypeConversionUtil.erasure(substitutedReturnType);\n        }\n      }\n    }\n\n    if (PsiUtil.isRawSubstitutor(method, substitutor)) {\n      final PsiType returnTypeErasure = TypeConversionUtil.erasure(ret);\n      if (Comparing.equal(TypeConversionUtil.erasure(substitutedReturnType), returnTypeErasure)) {\n        return returnTypeErasure;\n      }\n    }\n    return PsiUtil.captureToplevelWildcards(substitutedReturnType, call);\n  }","id":41475,"modified_method":"public static PsiType captureReturnType(PsiMethodCallExpression call,\n                                          PsiMethod method,\n                                          PsiType ret,\n                                          JavaResolveResult result, \n                                          LanguageLevel languageLevel) {\n    PsiSubstitutor substitutor = result.getSubstitutor();\n    PsiType substitutedReturnType = substitutor.substitute(ret);\n    if (substitutedReturnType == null) {\n      return TypeConversionUtil.erasure(ret);\n    }\n\n    if (InferenceSession.wasUncheckedConversionPerformed(call)) {\n      // 18.5.2\n      // if unchecked conversion was necessary, then this substitution provides the parameter types of the invocation type, \n      // while the return type and thrown types are given by the erasure of m's type (without applying ').\n      //due to https://bugs.openjdk.java.net/browse/JDK-8135087 erasure is called on substitutedReturnType and not on ret type itself as by spec\n      return TypeConversionUtil.erasure(substitutedReturnType);\n    }\n\n    //15.12.2.6. Method Invocation Type\n    // If unchecked conversion was necessary for the method to be applicable, \n    // the parameter types of the invocation type are the parameter types of the method's type,\n    // and the return type and thrown types are given by the erasures of the return type and thrown types of the method's type.\n    if ((!languageLevel.isAtLeast(LanguageLevel.JDK_1_8) && method.hasTypeParameters() ||\n         !method.hasTypeParameters() && JavaVersionService.getInstance().isAtLeast(call, JavaSdkVersion.JDK_1_8)) &&\n        result instanceof MethodCandidateInfo && ((MethodCandidateInfo)result).isApplicable()) {\n      final PsiType[] args = call.getArgumentList().getExpressionTypes();\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      final boolean varargs = ((MethodCandidateInfo)result).getApplicabilityLevel() == MethodCandidateInfo.ApplicabilityLevel.VARARGS;\n      for (int i = 0; i < args.length; i++) {\n        final PsiType parameterType = substitutor.substitute(PsiTypesUtil.getParameterType(parameters, i, varargs));\n        final PsiType expressionType = args[i];\n        if (expressionType != null && parameterType != null && JavaGenericsUtil.isRawToGeneric(parameterType, expressionType)) {\n          return TypeConversionUtil.erasure(substitutedReturnType);\n        }\n      }\n    }\n\n    if (PsiUtil.isRawSubstitutor(method, substitutor)) {\n      final PsiType returnTypeErasure = TypeConversionUtil.erasure(ret);\n      if (Comparing.equal(TypeConversionUtil.erasure(substitutedReturnType), returnTypeErasure)) {\n        return returnTypeErasure;\n      }\n    }\n    return PsiUtil.captureToplevelWildcards(substitutedReturnType, call);\n  }","commit_id":"951cdba7658d3a14469a4b93a6c771215002d2fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * a = S & a <: T imply S <: T\n   *           or\n   * a = S & T <: a imply T <: S\n   */\n  private void upDown(List<PsiType> eqBounds, List<PsiType> upperBounds) {\n    for (PsiType upperBound : upperBounds) {\n      for (PsiType eqBound : eqBounds) {\n        if (!upperBound.equals(eqBound)) {\n          addConstraint(new SubtypingConstraint(eqBound, upperBound, true));\n        }\n      }\n    }\n  }","id":41476,"modified_method":"/**\n   * a = S & a <: T imply S <: T\n   *           or\n   * a = S & T <: a imply T <: S\n   */\n  private void upDown(List<PsiType> eqBounds, List<PsiType> upperBounds) {\n    for (PsiType upperBound : upperBounds) {\n      for (PsiType eqBound : eqBounds) {\n        if (!upperBound.equals(eqBound)) {\n          addConstraint(new SubtypingConstraint(upperBound, eqBound, true));\n        }\n      }\n    }\n  }","commit_id":"c20b88c7535089564808f75b10f75a970d9a9d05","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * S <: a & a <: T imply S <: T\n   */\n  private void upperLower(List<PsiType> upperBounds, List<PsiType> lowerBounds) {\n    for (PsiType upperBound : upperBounds) {\n      for (PsiType lowerBound : lowerBounds) {\n        if (mySession.isProperType(upperBound) && mySession.isProperType(lowerBound)) continue;\n        if (!upperBound.equals(lowerBound)) {\n          addConstraint(new SubtypingConstraint(lowerBound, upperBound, true));\n        }\n      }\n    }\n  }","id":41477,"modified_method":"/**\n   * S <: a & a <: T imply S <: T\n   */\n  private void upperLower(List<PsiType> upperBounds, List<PsiType> lowerBounds) {\n    for (PsiType upperBound : upperBounds) {\n      for (PsiType lowerBound : lowerBounds) {\n        if (mySession.isProperType(upperBound) && mySession.isProperType(lowerBound)) continue;\n        if (!upperBound.equals(lowerBound)) {\n          addConstraint(new SubtypingConstraint(upperBound, lowerBound, true));\n        }\n      }\n    }\n  }","commit_id":"c20b88c7535089564808f75b10f75a970d9a9d05","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (myIsRefTypes) {\n      if (session.isProperType(myS) && session.isProperType(myT)) {\n        return TypeConversionUtil.isAssignable(myT, myS);\n      }\n      InferenceVariable inferenceVariable = session.getInferenceVariable(myS);\n      if (inferenceVariable != null) {\n        inferenceVariable.addBound(myT, InferenceBound.UPPER);\n        return true;\n      }\n      if (myS.equals(PsiType.NULL)) return true;\n      inferenceVariable = session.getInferenceVariable(myT);\n      if (inferenceVariable != null) {\n        inferenceVariable.addBound(myS, InferenceBound.LOWER);\n        return true;\n      }\n      if (myT instanceof PsiArrayType) {\n        if (!(myS instanceof PsiArrayType)) return false; //todo most specific array supertype\n        final PsiType tComponentType = ((PsiArrayType)myT).getComponentType();\n        final PsiType sComponentType = ((PsiArrayType)myS).getComponentType();\n        if (!(tComponentType instanceof PsiPrimitiveType) && !(sComponentType instanceof PsiPrimitiveType)) {\n          constraints.add(new SubtypingConstraint(tComponentType, sComponentType, true));\n          return true;\n        }\n        return sComponentType instanceof PsiPrimitiveType && sComponentType.equals(tComponentType);\n      }\n      if (myT instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult TResult = ((PsiClassType)myT).resolveGenerics();\n        final PsiClass CClass = TResult.getElement();\n        if (CClass != null) {\n          if (CClass instanceof PsiTypeParameter) {\n            if (myS instanceof PsiIntersectionType) {\n              for (PsiType conjunct : ((PsiIntersectionType)myS).getConjuncts()) {\n                if (myT.equals(conjunct)) return true;\n              }\n            }\n            //todo ((PsiTypeParameter)C).getLowerBound()\n            return false;\n          }\n  \n          if (!(myS instanceof PsiClassType)) return false;\n          PsiClassType.ClassResolveResult SResult = ((PsiClassType)myS).resolveGenerics();\n          PsiClass SClass = SResult.getElement();\n          if (SClass instanceof PsiAnonymousClass) {\n            final PsiClassType baseClassType = ((PsiAnonymousClass)SClass).getBaseClassType();\n            SResult = baseClassType.resolveGenerics();\n            SClass = SResult.getElement();\n          }\n          final PsiSubstitutor tSubstitutor = SClass != null ? TypeConversionUtil.getClassSubstitutor(SClass, CClass, TResult.getSubstitutor()) : null;\n          final PsiSubstitutor sSubstitutor = SResult.getSubstitutor();\n          if (tSubstitutor != null) {\n            for (PsiTypeParameter parameter : SClass.getTypeParameters()) {\n              final PsiType tSubstituted = tSubstitutor.substitute(parameter);\n              final PsiType sSubstituted = sSubstitutor.substitute(parameter);\n              if (tSubstituted != null && sSubstituted != null) {\n                constraints.add(new SubtypingConstraint(tSubstituted, sSubstituted, false));\n              }\n            }\n            return true;\n          }\n        }\n        return false;\n      }\n\n      if (myT instanceof PsiIntersectionType) {\n        for (PsiType conjunct : ((PsiIntersectionType)myT).getConjuncts()) {\n          constraints.add(new SubtypingConstraint(conjunct, myS, true));\n        }\n        return true;\n      }\n\n      if (myT.equals(PsiType.NULL)) return false;\n    } else {\n      if (myT instanceof PsiWildcardType) {\n        final PsiType tBound = ((PsiWildcardType)myT).getBound();\n        if (tBound == null) {\n          return true;\n        }\n        if (((PsiWildcardType)myT).isExtends()) {\n          if (tBound.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) {\n            return true;\n          }\n          if (myS instanceof PsiWildcardType) {\n            final PsiType sBound = ((PsiWildcardType)myS).getBound();\n            if (sBound != null && ((PsiWildcardType)myS).isExtends()) {\n              constraints.add(new SubtypingConstraint(tBound, sBound, true));\n              return true;\n            }\n          } else {\n            constraints.add(new SubtypingConstraint(tBound, myS, true));\n            return true;\n          }\n          return false;\n        } else {\n          if (myS instanceof PsiWildcardType) {\n            final PsiType sBound = ((PsiWildcardType)myS).getBound();\n            if (sBound != null && ((PsiWildcardType)myS).isSuper()) {\n              constraints.add(new SubtypingConstraint(sBound, tBound, true));\n              return true;\n            }\n          } else {\n            constraints.add(new SubtypingConstraint(myS, tBound, true));\n            return true;\n          }\n        }\n        return false;\n      } else {\n        if (myS instanceof PsiWildcardType) {\n          return false;\n        } else {\n          constraints.add(new SubtypingConstraint(myT, myS, true));\n          return true;\n        }\n      }\n    }\n    return true;\n  }","id":41478,"modified_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (myIsRefTypes) {\n      if (session.isProperType(myS) && session.isProperType(myT)) {\n        return TypeConversionUtil.isAssignable(myT, myS);\n      }\n      InferenceVariable inferenceVariable = session.getInferenceVariable(myS);\n      if (inferenceVariable != null) {\n        inferenceVariable.addBound(myT, InferenceBound.UPPER);\n        return true;\n      }\n      if (myS.equals(PsiType.NULL)) return true;\n      inferenceVariable = session.getInferenceVariable(myT);\n      if (inferenceVariable != null) {\n        inferenceVariable.addBound(myS, InferenceBound.LOWER);\n        return true;\n      }\n      if (myT instanceof PsiArrayType) {\n        if (!(myS instanceof PsiArrayType)) return false; //todo most specific array supertype\n        final PsiType tComponentType = ((PsiArrayType)myT).getComponentType();\n        final PsiType sComponentType = ((PsiArrayType)myS).getComponentType();\n        if (!(tComponentType instanceof PsiPrimitiveType) && !(sComponentType instanceof PsiPrimitiveType)) {\n          constraints.add(new SubtypingConstraint(tComponentType, sComponentType, true));\n          return true;\n        }\n        return sComponentType instanceof PsiPrimitiveType && sComponentType.equals(tComponentType);\n      }\n      if (myT instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult TResult = ((PsiClassType)myT).resolveGenerics();\n        final PsiClass CClass = TResult.getElement();\n        if (CClass != null) {\n          if (CClass instanceof PsiTypeParameter) {\n            if (myS instanceof PsiIntersectionType) {\n              for (PsiType conjunct : ((PsiIntersectionType)myS).getConjuncts()) {\n                if (myT.equals(conjunct)) return true;\n              }\n            }\n            //todo ((PsiTypeParameter)C).getLowerBound()\n            return false;\n          }\n  \n          if (!(myS instanceof PsiClassType)) return false;\n          PsiClassType.ClassResolveResult SResult = ((PsiClassType)myS).resolveGenerics();\n          PsiClass SClass = SResult.getElement();\n          final PsiSubstitutor tSubstitutor = TResult.getSubstitutor();\n          final PsiSubstitutor sSubstitutor = SClass != null ? TypeConversionUtil.getClassSubstitutor(CClass, SClass, SResult.getSubstitutor()) : null;\n          if (sSubstitutor != null) {\n            for (PsiTypeParameter parameter : CClass.getTypeParameters()) {\n              final PsiType tSubstituted = tSubstitutor.substitute(parameter);\n              final PsiType sSubstituted = sSubstitutor.substitute(parameter);\n              if (tSubstituted != null && sSubstituted != null) {\n                constraints.add(new SubtypingConstraint(tSubstituted, sSubstituted, false));\n              }\n            }\n            return true;\n          }\n        }\n        return false;\n      }\n\n      if (myT instanceof PsiIntersectionType) {\n        for (PsiType conjunct : ((PsiIntersectionType)myT).getConjuncts()) {\n          constraints.add(new SubtypingConstraint(conjunct, myS, true));\n        }\n        return true;\n      }\n\n      if (myT.equals(PsiType.NULL)) return false;\n    } else {\n      if (myT instanceof PsiWildcardType) {\n        final PsiType tBound = ((PsiWildcardType)myT).getBound();\n        if (tBound == null) {\n          return true;\n        }\n        if (((PsiWildcardType)myT).isExtends()) {\n          if (tBound.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) {\n            return true;\n          }\n          if (myS instanceof PsiWildcardType) {\n            final PsiType sBound = ((PsiWildcardType)myS).getBound();\n            if (sBound != null && ((PsiWildcardType)myS).isExtends()) {\n              constraints.add(new SubtypingConstraint(tBound, sBound, true));\n              return true;\n            }\n          } else {\n            constraints.add(new SubtypingConstraint(tBound, myS, true));\n            return true;\n          }\n          return false;\n        } else {\n          if (myS instanceof PsiWildcardType) {\n            final PsiType sBound = ((PsiWildcardType)myS).getBound();\n            if (sBound != null && ((PsiWildcardType)myS).isSuper()) {\n              constraints.add(new SubtypingConstraint(sBound, tBound, true));\n              return true;\n            }\n          } else {\n            constraints.add(new SubtypingConstraint(myS, tBound, true));\n            return true;\n          }\n        }\n        return false;\n      } else {\n        if (myS instanceof PsiWildcardType) {\n          return false;\n        } else {\n          constraints.add(new SubtypingConstraint(myT, myS, true));\n          return true;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"c20b88c7535089564808f75b10f75a970d9a9d05","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isRawToGeneric(PsiType lType, PsiType rType) {\n    if (lType instanceof PsiPrimitiveType || rType instanceof PsiPrimitiveType) return false;\n    if (lType.equals(rType)) return false;\n    if (lType instanceof PsiArrayType && rType instanceof PsiArrayType) {\n      return isRawToGeneric(((PsiArrayType)lType).getComponentType(), ((PsiArrayType)rType).getComponentType());\n    }\n    if (lType instanceof PsiArrayType || rType instanceof PsiArrayType) return false;\n\n    if (rType instanceof PsiIntersectionType) {\n      for (PsiType type : ((PsiIntersectionType)rType).getConjuncts()) {\n        if (isRawToGeneric(lType, type)) return true;\n      }\n      return false;\n    } else if (lType instanceof PsiIntersectionType) {\n      for (PsiType type : ((PsiIntersectionType)lType).getConjuncts()) {\n        if (isRawToGeneric(type, rType)) return true;\n      }\n      return false;\n    }\n\n    if (lType instanceof PsiCapturedWildcardType || rType instanceof PsiCapturedWildcardType) {\n      return false;\n    }\n\n    if (lType instanceof PsiWildcardType || rType instanceof PsiWildcardType) return false;\n\n    boolean isValidType = lType instanceof PsiClassType && rType instanceof PsiClassType;\n    if (!isValidType) {\n      LOG.error(\"Invalid types: rType =\" + rType + \", lType=\" + lType);\n    }\n    PsiClassType.ClassResolveResult lResolveResult = ((PsiClassType)lType).resolveGenerics();\n    PsiClassType.ClassResolveResult rResolveResult = ((PsiClassType)rType).resolveGenerics();\n    PsiClass lClass = lResolveResult.getElement();\n    PsiClass rClass = rResolveResult.getElement();\n    PsiSubstitutor lSubstitutor = lResolveResult.getSubstitutor();\n    PsiSubstitutor rSubstitutor = rResolveResult.getSubstitutor();\n    if (lClass == null || rClass == null) return false;\n    if (lClass instanceof PsiTypeParameter &&\n        !InheritanceUtil.isInheritorOrSelf(rClass, lClass, true)) return true;\n    PsiClass base;\n    if (!lClass.getManager().areElementsEquivalent(lClass, rClass)) {\n      if (lClass.isInheritor(rClass, true)) {\n        base = rClass;\n        lSubstitutor = TypeConversionUtil.getSuperClassSubstitutor(rClass, lClass, lSubstitutor);\n      }\n      else if (rClass.isInheritor(lClass, true)) {\n        base = lClass;\n        rSubstitutor = TypeConversionUtil.getSuperClassSubstitutor(lClass, rClass, rSubstitutor);\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      base = lClass;\n    }\n\n    LOG.assertTrue(lSubstitutor != null && rSubstitutor != null);\n    Iterator<PsiTypeParameter> it = PsiUtil.typeParametersIterator(base);\n    while (it.hasNext()) {\n      PsiTypeParameter parameter = it.next();\n      PsiType lTypeArg = lSubstitutor.substitute(parameter);\n      PsiType rTypeArg = rSubstitutor.substituteWithBoundsPromotion(parameter);\n      if (lTypeArg == null) continue;\n      if (rTypeArg == null) {\n        if (!(lTypeArg instanceof PsiWildcardType) ||\n            ((PsiWildcardType) lTypeArg).getBound() != null) return true; else continue;\n      }\n      if (isUncheckedTypeArgumentConversion(lTypeArg, rTypeArg)) return true;\n    }\n    return false;\n  }","id":41479,"modified_method":"private static boolean isRawToGeneric(PsiType lType, PsiType rType) {\n    if (lType instanceof PsiPrimitiveType || rType instanceof PsiPrimitiveType) return false;\n    if (lType.equals(rType)) return false;\n    if (lType instanceof PsiArrayType && rType instanceof PsiArrayType) {\n      return isRawToGeneric(((PsiArrayType)lType).getComponentType(), ((PsiArrayType)rType).getComponentType());\n    }\n    if (lType instanceof PsiArrayType || rType instanceof PsiArrayType) return false;\n\n    if (rType instanceof PsiIntersectionType) {\n      for (PsiType type : ((PsiIntersectionType)rType).getConjuncts()) {\n        if (isRawToGeneric(lType, type)) return true;\n      }\n      return false;\n    } else if (lType instanceof PsiIntersectionType) {\n      for (PsiType type : ((PsiIntersectionType)lType).getConjuncts()) {\n        if (isRawToGeneric(type, rType)) return true;\n      }\n      return false;\n    }\n\n    if (lType instanceof PsiCapturedWildcardType || rType instanceof PsiCapturedWildcardType) {\n      return false;\n    }\n\n    if (lType instanceof PsiWildcardType || rType instanceof PsiWildcardType) return false;\n\n    boolean isValidType = lType instanceof PsiClassType && rType instanceof PsiClassType;\n    if (!isValidType) {\n      LOG.error(\"Invalid types: rType =\" + rType + \", lType=\" + lType);\n    }\n    PsiClassType.ClassResolveResult lResolveResult = ((PsiClassType)lType).resolveGenerics();\n    PsiClassType.ClassResolveResult rResolveResult = ((PsiClassType)rType).resolveGenerics();\n    PsiClass lClass = lResolveResult.getElement();\n    PsiClass rClass = rResolveResult.getElement();\n\n    if (rClass instanceof PsiAnonymousClass) {\n      return isRawToGeneric(lType, ((PsiAnonymousClass)rClass).getBaseClassType());\n    }\n\n    PsiSubstitutor lSubstitutor = lResolveResult.getSubstitutor();\n    PsiSubstitutor rSubstitutor = rResolveResult.getSubstitutor();\n    if (lClass == null || rClass == null) return false;\n    if (lClass instanceof PsiTypeParameter &&\n        !InheritanceUtil.isInheritorOrSelf(rClass, lClass, true)) return true;\n    PsiClass base;\n    if (!lClass.getManager().areElementsEquivalent(lClass, rClass)) {\n      if (lClass.isInheritor(rClass, true)) {\n        base = rClass;\n        lSubstitutor = TypeConversionUtil.getSuperClassSubstitutor(rClass, lClass, lSubstitutor);\n      }\n      else if (rClass.isInheritor(lClass, true)) {\n        base = lClass;\n        rSubstitutor = TypeConversionUtil.getSuperClassSubstitutor(lClass, rClass, rSubstitutor);\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      base = lClass;\n    }\n\n    LOG.assertTrue(lSubstitutor != null && rSubstitutor != null);\n    Iterator<PsiTypeParameter> it = PsiUtil.typeParametersIterator(base);\n    while (it.hasNext()) {\n      PsiTypeParameter parameter = it.next();\n      PsiType lTypeArg = lSubstitutor.substitute(parameter);\n      PsiType rTypeArg = rSubstitutor.substituteWithBoundsPromotion(parameter);\n      if (lTypeArg == null) continue;\n      if (rTypeArg == null) {\n        if (!(lTypeArg instanceof PsiWildcardType) ||\n            ((PsiWildcardType) lTypeArg).getBound() != null) return true; else continue;\n      }\n      if (isUncheckedTypeArgumentConversion(lTypeArg, rTypeArg)) return true;\n    }\n    return false;\n  }","commit_id":"51a971ae6d5afa8569204e6e453d4987885301c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JavaResolveResult[] multiResolveConstructor(PsiClassType type, PsiExpressionList argumentList, PsiElement place) {\n    PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n    PsiClass aClass = classResolveResult.getElement();\n    if (aClass == null) {\n      return JavaResolveResult.EMPTY_ARRAY;\n    }\n    else {\n      final MethodResolverProcessor processor;\n      PsiSubstitutor substitutor;\n      if (argumentList.getParent() instanceof PsiAnonymousClass) {\n        final PsiAnonymousClass anonymous = (PsiAnonymousClass)argumentList.getParent();\n        processor = new MethodResolverProcessor(anonymous, argumentList, place);\n        aClass = anonymous.getBaseClassType().resolve();\n        if (aClass == null) return JavaResolveResult.EMPTY_ARRAY;\n        substitutor = TypeConversionUtil.getSuperClassSubstitutor(aClass, anonymous, classResolveResult.getSubstitutor());\n      }\n      else {\n        processor = new MethodResolverProcessor(aClass, argumentList, place);\n        substitutor = classResolveResult.getSubstitutor();\n      }\n\n      for (PsiMethod constructor : aClass.getConstructors()) {\n        if (!processor.execute(constructor, substitutor)) break;\n      }\n\n      return processor.getResult();\n    }\n  }","id":41480,"modified_method":"@NotNull\n  public JavaResolveResult[] multiResolveConstructor(PsiClassType type, PsiExpressionList argumentList, PsiElement place) {\n    PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n    PsiClass aClass = classResolveResult.getElement();\n    if (aClass == null) {\n      return JavaResolveResult.EMPTY_ARRAY;\n    }\n    else {\n      final MethodResolverProcessor processor;\n      PsiSubstitutor substitutor = classResolveResult.getSubstitutor();\n      if (argumentList.getParent() instanceof PsiAnonymousClass) {\n        final PsiAnonymousClass anonymous = (PsiAnonymousClass)argumentList.getParent();\n        processor = new MethodResolverProcessor(anonymous, argumentList, place);\n        aClass = anonymous.getBaseClassType().resolve();\n        if (aClass == null) return JavaResolveResult.EMPTY_ARRAY;\n        substitutor = substitutor.putAll(TypeConversionUtil.getSuperClassSubstitutor(aClass, anonymous, substitutor));\n      }\n      else {\n        processor = new MethodResolverProcessor(aClass, argumentList, place);\n      }\n\n      for (PsiMethod constructor : aClass.getConstructors()) {\n        if (!processor.execute(constructor, substitutor)) break;\n      }\n\n      return processor.getResult();\n    }\n  }","commit_id":"51a971ae6d5afa8569204e6e453d4987885301c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(MethodSignature method1, MethodSignature method2) {\n      if (!method1.getName().equals(method2.getName())) return false;\n      final PsiType[] parameterTypes1 = method1.getParameterTypes();\n      final PsiType[] parameterTypes2 = method2.getParameterTypes();\n      if (parameterTypes1.length != parameterTypes2.length) return false;\n      PsiSubstitutor superSubstitutor = getSuperMethodSignatureSubstitutorImpl(method1, method2);\n      if (superSubstitutor == null) superSubstitutor = method2.getSubstitutor();\n\n      for (int i = 0; i < parameterTypes1.length; i++) {\n        final PsiType type1 = TypeConversionUtil.erasure(method1.getSubstitutor().substitute(parameterTypes1[i]));\n        final PsiType type2 = TypeConversionUtil.erasure(superSubstitutor.substitute(parameterTypes2[i]));\n        if (!Comparing.equal(type1, type2)) return false;\n      }\n      return true;\n    }","id":41481,"modified_method":"public boolean equals(MethodSignature method1, MethodSignature method2) {\n      if (!method1.getName().equals(method2.getName())) return false;\n      final PsiType[] parameterTypes1 = method1.getParameterTypes();\n      final PsiType[] parameterTypes2 = method2.getParameterTypes();\n      if (parameterTypes1.length != parameterTypes2.length) return false;\n\n      final PsiSubstitutor substitutor1 = method1.getSubstitutor();\n      final PsiSubstitutor substitutor2 = method2.getSubstitutor();\n      for (int i = 0; i < parameterTypes1.length; i++) {\n        final PsiType type1 = TypeConversionUtil.erasure(substitutor1.substitute(parameterTypes1[i]));\n        final PsiType type2 = TypeConversionUtil.erasure(substitutor2.substitute(parameterTypes2[i]), substitutor2);\n        if (!Comparing.equal(type1, type2)) return false;\n      }\n      return true;\n    }","commit_id":"06cc701af376efe6eca43bda8bebc1ef329757ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isPrimitiveWrapper(final PsiType type) {\n     if (type==null) return false;\n     return isPrimitiveWrapper(type.getCanonicalText());\n   }","id":41482,"modified_method":"public static boolean isPrimitiveWrapper(final PsiType type) {\n    return type != null && isPrimitiveWrapper(type.getCanonicalText());\n  }","commit_id":"06cc701af376efe6eca43bda8bebc1ef329757ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiClassType typeParameterErasure(final PsiTypeParameter typeParameter) {\n    final PsiClassType[] extendsList = typeParameter.getExtendsList().getReferencedTypes();\n    if (extendsList.length > 0) {\n      final PsiClass psiClass = extendsList[0].resolve();\n      if (psiClass instanceof PsiTypeParameter) {\n        Set<PsiClass> visited = new HashSet<PsiClass>();\n        visited.add(psiClass);\n        return typeParameterErasureInner((PsiTypeParameter)psiClass, visited);\n      }\n      else if (psiClass != null) {\n        return typeParameter.getManager().getElementFactory().createType(psiClass);\n      }\n    }\n    return PsiType.getJavaLangObject(typeParameter.getManager(), typeParameter.getResolveScope());\n  }","id":41483,"modified_method":"private static PsiType typeParameterErasure(final PsiTypeParameter typeParameter, final PsiSubstitutor beforeSubstitutor) {\n    final PsiClassType[] extendsList = typeParameter.getExtendsList().getReferencedTypes();\n    if (extendsList.length > 0) {\n      final PsiClass psiClass = extendsList[0].resolve();\n      if (psiClass instanceof PsiTypeParameter) {\n        Set<PsiClass> visited = new HashSet<PsiClass>();\n        visited.add(psiClass);\n        final PsiTypeParameter boundTypeParameter = (PsiTypeParameter)psiClass;\n        if (beforeSubstitutor.getSubstitutionMap().containsKey(boundTypeParameter)) {\n          return erasure(beforeSubstitutor.substitute(boundTypeParameter));\n        }\n        return typeParameterErasureInner(boundTypeParameter, visited);\n      }\n      else if (psiClass != null) {\n        return typeParameter.getManager().getElementFactory().createType(psiClass);\n      }\n    }\n    return PsiType.getJavaLangObject(typeParameter.getManager(), typeParameter.getResolveScope());\n  }","commit_id":"06cc701af376efe6eca43bda8bebc1ef329757ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiType erasure(PsiType type) {\n    if (type == null) return null;\n    return type.accept(new PsiTypeVisitor<PsiType>() {\n      public PsiType visitClassType(PsiClassType classType) {\n        final PsiClass aClass = classType.resolve();\n        if (!(aClass instanceof PsiTypeParameter)) {\n          return classType.rawType();\n        }\n        else {\n          return typeParameterErasure((PsiTypeParameter)aClass);\n        }\n      }\n\n      public PsiType visitWildcardType(PsiWildcardType wildcardType) {\n        return wildcardType.getExtendsBound().accept(this);\n      }\n\n      public PsiType visitPrimitiveType(PsiPrimitiveType primitiveType) {\n        return primitiveType;\n      }\n\n      public PsiType visitEllipsisType(PsiEllipsisType ellipsisType) {\n        final PsiType componentType = ellipsisType.getComponentType();\n        final PsiType newComponentType = componentType.accept(this);\n        if (newComponentType == componentType) return ellipsisType;\n        return new PsiArrayType(newComponentType);\n      }\n\n      public PsiType visitArrayType(PsiArrayType arrayType) {\n        final PsiType componentType = arrayType.getComponentType();\n        final PsiType newComponentType = componentType.accept(this);\n        if (newComponentType == componentType) return arrayType;\n        return newComponentType.createArrayType();\n      }\n    });\n  }","id":41484,"modified_method":"public static PsiType erasure(PsiType type) {\n    return erasure(type, PsiSubstitutor.EMPTY);\n  }","commit_id":"06cc701af376efe6eca43bda8bebc1ef329757ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private <T> T computeForOverloadedCandidate(final Computable<T> computable, final PsiSubstitutor substitutor) {\n    Map<PsiElement, CurrentCandidateProperties> map = CURRENT_CANDIDATE.get();\n    if (map == null) {\n      map = ContainerUtil.createConcurrentWeakMap();\n      CURRENT_CANDIDATE.set(map);\n    }\n    final PsiElement argumentList = getMarkerList();\n    final CurrentCandidateProperties alreadyThere = map.put(argumentList,\n                                                            new CurrentCandidateProperties(this, substitutor, isVarargs(), true));\n    try {\n      return computable.compute();\n    }\n    finally {\n      if (alreadyThere == null) {\n        map.remove(argumentList);\n      } else {\n        map.put(argumentList, alreadyThere);\n      }\n    }\n  }","id":41485,"modified_method":"private <T> T computeForOverloadedCandidate(final Computable<T> computable,\n                                              final PsiSubstitutor substitutor,\n                                              boolean varargs, boolean applicabilityCheck) {\n    Map<PsiElement, CurrentCandidateProperties> map = CURRENT_CANDIDATE.get();\n    if (map == null) {\n      map = ContainerUtil.createConcurrentWeakMap();\n      CURRENT_CANDIDATE.set(map);\n    }\n    final PsiElement argumentList = getMarkerList();\n    final CurrentCandidateProperties alreadyThere =\n      map.put(argumentList, new CurrentCandidateProperties(this, substitutor, varargs, applicabilityCheck));\n    try {\n      return computable.compute();\n    }\n    finally {\n      if (alreadyThere == null) {\n        map.remove(argumentList);\n      } else {\n        map.put(argumentList, alreadyThere);\n      }\n    }\n  }","commit_id":"7b7e10ab0cd7d4c2ce108d481b28cce1c2d100cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * 15.12.2.2 Identify Matching Arity Methods Applicable by Strict Invocation\n   */\n  public int getPertinentApplicabilityLevelInner() {\n    if (myArgumentList == null || !PsiUtil.isLanguageLevel8OrHigher(myArgumentList)) {\n      return getApplicabilityLevel();\n    }\n\n    final PsiMethod method = getElement();\n    \n    if (isToInferApplicability()) {\n      if (!isOverloadCheck()) {\n        //ensure applicability check is performed\n        getSubstitutor(false);\n      }\n\n      //already performed checks, so if inference failed, error message should be saved  \n      if (myInferenceError != null || !isPotentiallyCompatible()) {\n        return ApplicabilityLevel.NOT_APPLICABLE;\n      }\n      return isVarargs() ? ApplicabilityLevel.VARARGS : ApplicabilityLevel.FIXED_ARITY;\n    }\n\n    final PsiSubstitutor substitutor = getSubstitutor(false);\n    @ApplicabilityLevelConstant int level = computeForOverloadedCandidate(new Computable<Integer>() {\n      @Override\n      public Integer compute() {\n        //arg types are calculated here without additional constraints:\n        //non-pertinent to applicability arguments of arguments would be skipped \n        PsiType[] argumentTypes = getArgumentTypes();\n        if (argumentTypes == null) {\n          return ApplicabilityLevel.NOT_APPLICABLE;\n        }\n\n        int level = PsiUtil.getApplicabilityLevel(method, substitutor, argumentTypes, myLanguageLevel);\n        if (!isVarargs() && level < ApplicabilityLevel.FIXED_ARITY) {\n          return ApplicabilityLevel.NOT_APPLICABLE;\n        }\n        return level;\n      }\n    }, substitutor);\n    if (level > ApplicabilityLevel.NOT_APPLICABLE && !isTypeArgumentsApplicable(new Computable<PsiSubstitutor>() {\n      @Override\n      public PsiSubstitutor compute() {\n        return substitutor;\n      }\n    })) {\n      level = ApplicabilityLevel.NOT_APPLICABLE;\n    }\n    return level;\n  }","id":41486,"modified_method":"/**\n   * 15.12.2.2 Identify Matching Arity Methods Applicable by Strict Invocation\n   */\n  public int getPertinentApplicabilityLevelInner() {\n    if (myArgumentList == null || !PsiUtil.isLanguageLevel8OrHigher(myArgumentList)) {\n      return getApplicabilityLevel();\n    }\n\n    final PsiMethod method = getElement();\n    \n    if (isToInferApplicability()) {\n      if (!isOverloadCheck()) {\n        //ensure applicability check is performed\n        getSubstitutor(false);\n      }\n\n      //already performed checks, so if inference failed, error message should be saved  \n      if (myInferenceError != null || !isPotentiallyCompatible()) {\n        return ApplicabilityLevel.NOT_APPLICABLE;\n      }\n      return isVarargs() ? ApplicabilityLevel.VARARGS : ApplicabilityLevel.FIXED_ARITY;\n    }\n\n    final PsiSubstitutor substitutor = getSubstitutor(false);\n    @ApplicabilityLevelConstant int level = computeForOverloadedCandidate(new Computable<Integer>() {\n      @Override\n      public Integer compute() {\n        //arg types are calculated here without additional constraints:\n        //non-pertinent to applicability arguments of arguments would be skipped \n        PsiType[] argumentTypes = getArgumentTypes();\n        if (argumentTypes == null) {\n          return ApplicabilityLevel.NOT_APPLICABLE;\n        }\n\n        int level = PsiUtil.getApplicabilityLevel(method, substitutor, argumentTypes, myLanguageLevel);\n        if (!isVarargs() && level < ApplicabilityLevel.FIXED_ARITY) {\n          return ApplicabilityLevel.NOT_APPLICABLE;\n        }\n        return level;\n      }\n    }, substitutor, isVarargs(), true);\n    if (level > ApplicabilityLevel.NOT_APPLICABLE && !isTypeArgumentsApplicable(new Computable<PsiSubstitutor>() {\n      @Override\n      public PsiSubstitutor compute() {\n        return substitutor;\n      }\n    })) {\n      level = ApplicabilityLevel.NOT_APPLICABLE;\n    }\n    return level;\n  }","commit_id":"7b7e10ab0cd7d4c2ce108d481b28cce1c2d100cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull ParameterTypeInferencePolicy policy,\n                                           @NotNull PsiExpression[] arguments, \n                                           boolean includeReturnConstraint) {\n    Map<PsiElement, CurrentCandidateProperties> map = CURRENT_CANDIDATE.get();\n    if (map == null) {\n      map = ContainerUtil.createConcurrentWeakMap();\n      CURRENT_CANDIDATE.set(map);\n    }\n    final PsiMethod method = getElement();\n    final PsiElement argumentList = getMarkerList();\n    final CurrentCandidateProperties alreadyThere =\n      map.put(argumentList, new CurrentCandidateProperties(this, super.getSubstitutor(), policy.isVarargsIgnored() || isVarargs(), !includeReturnConstraint));\n    try {\n      PsiTypeParameter[] typeParameters = method.getTypeParameters();\n\n      if (isRawSubstitution()) {\n        return JavaPsiFacade.getInstance(method.getProject()).getElementFactory().createRawSubstitutor(mySubstitutor, typeParameters);\n      }\n\n      final PsiElement parent = getParent();\n      if (parent == null) return PsiSubstitutor.EMPTY;\n      Project project = method.getProject();\n      JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n      return javaPsiFacade.getResolveHelper()\n        .inferTypeArguments(typeParameters, method.getParameterList().getParameters(), arguments, mySubstitutor, parent, policy, myLanguageLevel);\n    }\n    finally {\n      if (alreadyThere == null) {\n        map.remove(argumentList);\n      } else {\n        map.put(argumentList, alreadyThere);\n      }\n    }\n  }","id":41487,"modified_method":"@NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull final ParameterTypeInferencePolicy policy,\n                                           @NotNull final PsiExpression[] arguments,\n                                           boolean includeReturnConstraint) {\n    return computeForOverloadedCandidate(new Computable<PsiSubstitutor>() {\n      @Override\n      public PsiSubstitutor compute() {\n        final PsiMethod method = MethodCandidateInfo.this.getElement();\n        PsiTypeParameter[] typeParameters = method.getTypeParameters();\n\n        if (MethodCandidateInfo.this.isRawSubstitution()) {\n          return JavaPsiFacade.getInstance(method.getProject()).getElementFactory().createRawSubstitutor(mySubstitutor, typeParameters);\n        }\n\n        final PsiElement parent = MethodCandidateInfo.this.getParent();\n        if (parent == null) return PsiSubstitutor.EMPTY;\n        Project project = method.getProject();\n        JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n        return javaPsiFacade.getResolveHelper()\n          .inferTypeArguments(typeParameters, method.getParameterList().getParameters(), arguments, mySubstitutor, parent, policy,\n                              myLanguageLevel);\n      }\n    }, super.getSubstitutor(), policy.isVarargsIgnored() || isVarargs(), !includeReturnConstraint);\n  }","commit_id":"7b7e10ab0cd7d4c2ce108d481b28cce1c2d100cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void batch(List<Event> events) throws Exception {\n    List<WriteOperation> operations = new ArrayList<WriteOperation>(events.size());\n    EventSerializer serializer = new EventSerializer();\n    for (Event event : events) {\n      byte[] bytes = serializer.serialize(event);\n      if (bytes == null) {\n        LOG.warn(\"Could not serialize event: \" + event);\n        throw new Exception(\"Could not serialize event: \" + event);\n      }\n      String destination = event.getHeader(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.warn(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n      // construct the stream URO to use for the data fabric\n      String queueURI = FlowStream.buildStreamURI(destination);\n      operations.add(new QueueEnqueue(queueURI.getBytes(), bytes));\n    }\n    BatchOperationResult result = this.executor.execute(operations);\n    if (!result.isSuccess()) {\n      Exception e = new Exception(\"Failed to enqueue event(s). \" + result.getMessage());\n      LOG.error(e.getMessage(), e);\n      throw e;\n    }\n  }","id":41488,"modified_method":"@Override\n  protected void batch(List<Event> events) throws Exception {\n    List<WriteOperation> operations = new ArrayList<WriteOperation>(events.size());\n    EventSerializer serializer = new EventSerializer();\n    for (Event event : events) {\n      byte[] bytes = serializer.serialize(event);\n      if (bytes == null) {\n        LOG.warn(\"Could not serialize event: \" + event);\n        throw new Exception(\"Could not serialize event: \" + event);\n      }\n      String destination = event.getHeader(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.warn(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n      // construct the stream URO to use for the data fabric\n      String queueURI = FlowStream.buildStreamURI(destination).toString();\n      operations.add(new QueueEnqueue(queueURI.getBytes(), bytes));\n    }\n    BatchOperationResult result = this.executor.execute(operations);\n    if (!result.isSuccess()) {\n      Exception e = new Exception(\"Failed to enqueue event(s). \" + result.getMessage());\n      LOG.error(e.getMessage(), e);\n      throw e;\n    }\n  }","commit_id":"af2eac079123f324b89c06966fd688a4c5e19432","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void batch(List<Event> events) throws Exception {\n    List<WriteOperation> operations = new ArrayList<WriteOperation>(events.size());\n    TupleSerializer serializer = new TupleSerializer(false);\n    for (Event event : events) {\n      // convert the event into a tuple\n      Tuple tuple = new TupleBuilderImpl().\n          set(\"headers\", event.getHeaders()).\n          set(\"body\", event.getBody()).\n          create();\n      // and serialize it\n      byte[] bytes = serializer.serialize(tuple);\n      if (bytes == null) {\n        Exception e = new Exception(\"Could not serialize event: \" + event);\n        LOG.warn(\"Could not serialize event: \" + event, e);\n        throw e;\n      }\n      // figure out where to write it\n      String destination = event.getHeader(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.debug(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n      // construct the stream URI to use for the data fabric\n      String queueURI = FlowStream.buildStreamURI(destination);\n      operations.add(new QueueEnqueue(queueURI.getBytes(), bytes));\n      LOG.debug(\"Sending tuple to \" + queueURI + \", tuple = \" + event);\n\n    }\n    BatchOperationResult result = this.executor.execute(operations);\n    if (!result.isSuccess()) {\n      Exception e = new Exception(\"Failed to enqueue event(s). \" + result.getMessage());\n      LOG.error(e.getMessage(), e);\n      throw e;\n    }\n  }","id":41489,"modified_method":"@Override\n  protected void batch(List<Event> events) throws Exception {\n    List<WriteOperation> operations = new ArrayList<WriteOperation>(events.size());\n    TupleSerializer serializer = new TupleSerializer(false);\n    for (Event event : events) {\n      // convert the event into a tuple\n      Tuple tuple = new TupleBuilderImpl().\n          set(\"headers\", event.getHeaders()).\n          set(\"body\", event.getBody()).\n          create();\n      // and serialize it\n      byte[] bytes = serializer.serialize(tuple);\n      if (bytes == null) {\n        Exception e = new Exception(\"Could not serialize event: \" + event);\n        LOG.warn(\"Could not serialize event: \" + event, e);\n        throw e;\n      }\n      // figure out where to write it\n      String destination = event.getHeader(Constants.HEADER_DESTINATION_STREAM);\n      if (destination == null) {\n        LOG.debug(\"Enqueuing an event that has no destination. Using 'default' instead.\");\n        destination = \"default\";\n      }\n      // construct the stream URI to use for the data fabric\n      String queueURI = FlowStream.buildStreamURI(destination).toString();\n      operations.add(new QueueEnqueue(queueURI.getBytes(), bytes));\n      LOG.debug(\"Sending tuple to \" + queueURI + \", tuple = \" + event);\n\n    }\n    BatchOperationResult result = this.executor.execute(operations);\n    if (!result.isSuccess()) {\n      Exception e = new Exception(\"Failed to enqueue event(s). \" + result.getMessage());\n      LOG.error(e.getMessage(), e);\n      throw e;\n    }\n  }","commit_id":"af2eac079123f324b89c06966fd688a4c5e19432","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Consume the tuples in a queue and verify that the are events as created by\n   * createHttpPost() or createFlumeEvent()\n   *\n   * @param executor       The executor to use for access to the data fabric\n   * @param destination    The name of the flow (destination) that the events were sent to\n   * @param collectorName  The name of the collector that received the events\n   * @param tuplesExpected How many tuples should be read\n   * @throws Exception\n   */\n  static void consumeQueueAsTuples(OperationExecutor executor, String destination,\n                                   String collectorName, int tuplesExpected) throws Exception {\n    // address the correct queue\n    byte[] queueURI = FlowStream.buildStreamURI(destination).getBytes();\n    // one deserializer to reuse\n    TupleSerializer deserializer = new TupleSerializer(false);\n    // prepare the queue consumer\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(new QueuePartitioner.RandomPartitioner(), true);\n    QueueDequeue dequeue = new QueueDequeue(queueURI, consumer, config);\n    for (int remaining = tuplesExpected; remaining > 0; --remaining) {\n      // dequeue one event and remember its ack pointer\n      DequeueResult result = executor.execute(dequeue);\n      Assert.assertTrue(result.isSuccess());\n      QueueEntryPointer ackPointer = result.getEntryPointer();\n      // deserialize and verify the event\n      Tuple tuple = deserializer.deserialize(result.getValue());\n      Util.verifyTuple(tuple, collectorName, destination, null);\n      // message number should be in the header \"messageNumber\"\n      Map<String, String> headers = tuple.get(\"headers\");\n      LOG.info(\"Popped one event, message number: \" + headers.get(\"messageNumber\"));\n      // ack the event so that it disappers from the queue\n      QueueAck ack = new QueueAck(queueURI, ackPointer, consumer);\n      List<WriteOperation> operations = new ArrayList<WriteOperation>(1);\n      operations.add(ack);\n      Assert.assertTrue(executor.execute(operations).isSuccess());\n    }\n  }","id":41490,"modified_method":"/**\n   * Consume the tuples in a queue and verify that the are events as created by\n   * createHttpPost() or createFlumeEvent()\n   *\n   * @param executor       The executor to use for access to the data fabric\n   * @param destination    The name of the flow (destination) that the events were sent to\n   * @param collectorName  The name of the collector that received the events\n   * @param tuplesExpected How many tuples should be read\n   * @throws Exception\n   */\n  static void consumeQueueAsTuples(OperationExecutor executor, String destination,\n                                   String collectorName, int tuplesExpected) throws Exception {\n    // address the correct queue\n    byte[] queueURI = FlowStream.buildStreamURI(destination).toString().getBytes();\n    // one deserializer to reuse\n    TupleSerializer deserializer = new TupleSerializer(false);\n    // prepare the queue consumer\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(new QueuePartitioner.RandomPartitioner(), true);\n    QueueDequeue dequeue = new QueueDequeue(queueURI, consumer, config);\n    for (int remaining = tuplesExpected; remaining > 0; --remaining) {\n      // dequeue one event and remember its ack pointer\n      DequeueResult result = executor.execute(dequeue);\n      Assert.assertTrue(result.isSuccess());\n      QueueEntryPointer ackPointer = result.getEntryPointer();\n      // deserialize and verify the event\n      Tuple tuple = deserializer.deserialize(result.getValue());\n      Util.verifyTuple(tuple, collectorName, destination, null);\n      // message number should be in the header \"messageNumber\"\n      Map<String, String> headers = tuple.get(\"headers\");\n      LOG.info(\"Popped one event, message number: \" + headers.get(\"messageNumber\"));\n      // ack the event so that it disappers from the queue\n      QueueAck ack = new QueueAck(queueURI, ackPointer, consumer);\n      List<WriteOperation> operations = new ArrayList<WriteOperation>(1);\n      operations.add(ack);\n      Assert.assertTrue(executor.execute(operations).isSuccess());\n    }\n  }","commit_id":"af2eac079123f324b89c06966fd688a4c5e19432","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Consume the events in a queue and verify that they correspond to the format as created by\n   * createHttpPost() or createFlumeEvent()\n   *\n   * @param executor       The executor to use for access to the data fabric\n   * @param destination    The name of the flow (destination) that the events were sent to\n   * @param collectorName  The name of the collector that received the events\n   * @param eventsExpected How many events should be read\n   * @throws Exception\n   */\n  static void consumeQueueAsEvents(OperationExecutor executor, String destination,\n                                   String collectorName, int eventsExpected) throws Exception {\n    // address the correct queue\n    byte[] queueURI = FlowStream.buildStreamURI(destination).getBytes();\n    // one deserializer to reuse\n    EventSerializer deserializer = new EventSerializer();\n    // prepare the queue consumer\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(new QueuePartitioner.RandomPartitioner(), true);\n    QueueDequeue dequeue = new QueueDequeue(queueURI, consumer, config);\n    for (int remaining = eventsExpected; remaining > 0; --remaining) {\n      // dequeue one event and remember its ack pointer\n      DequeueResult result = executor.execute(dequeue);\n      Assert.assertTrue(result.isSuccess());\n      QueueEntryPointer ackPointer = result.getEntryPointer();\n      // deserialize and verify the event\n      Event event = deserializer.deserialize(result.getValue());\n      Util.verifyEvent(event, collectorName, destination, null);\n      // message number should be in the header \"messageNumber\"\n      LOG.info(\"Popped one event, message number: \" + event.getHeader(\"messageNumber\"));\n      // ack the event so that it disappers from the queue\n      QueueAck ack = new QueueAck(queueURI, ackPointer, consumer);\n      List<WriteOperation> operations = new ArrayList<WriteOperation>(1);\n      operations.add(ack);\n      Assert.assertTrue(executor.execute(operations).isSuccess());\n    }\n  }","id":41491,"modified_method":"/**\n   * Consume the events in a queue and verify that they correspond to the format as created by\n   * createHttpPost() or createFlumeEvent()\n   *\n   * @param executor       The executor to use for access to the data fabric\n   * @param destination    The name of the flow (destination) that the events were sent to\n   * @param collectorName  The name of the collector that received the events\n   * @param eventsExpected How many events should be read\n   * @throws Exception\n   */\n  static void consumeQueueAsEvents(OperationExecutor executor, String destination,\n                                   String collectorName, int eventsExpected) throws Exception {\n    // address the correct queue\n    byte[] queueURI = FlowStream.buildStreamURI(destination).toString().getBytes();\n    // one deserializer to reuse\n    EventSerializer deserializer = new EventSerializer();\n    // prepare the queue consumer\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(new QueuePartitioner.RandomPartitioner(), true);\n    QueueDequeue dequeue = new QueueDequeue(queueURI, consumer, config);\n    for (int remaining = eventsExpected; remaining > 0; --remaining) {\n      // dequeue one event and remember its ack pointer\n      DequeueResult result = executor.execute(dequeue);\n      Assert.assertTrue(result.isSuccess());\n      QueueEntryPointer ackPointer = result.getEntryPointer();\n      // deserialize and verify the event\n      Event event = deserializer.deserialize(result.getValue());\n      Util.verifyEvent(event, collectorName, destination, null);\n      // message number should be in the header \"messageNumber\"\n      LOG.info(\"Popped one event, message number: \" + event.getHeader(\"messageNumber\"));\n      // ack the event so that it disappers from the queue\n      QueueAck ack = new QueueAck(queueURI, ackPointer, consumer);\n      List<WriteOperation> operations = new ArrayList<WriteOperation>(1);\n      operations.add(ack);\n      Assert.assertTrue(executor.execute(operations).isSuccess());\n    }\n  }","commit_id":"af2eac079123f324b89c06966fd688a4c5e19432","url":"https://github.com/caskdata/cdap"},{"original_method":"private String getAssertionMessage(Object element, SNode concept) {\n    SNode conceptFromModelUtil = SModelUtil.findConceptDeclaration(NameUtil.nodeFQName(concept), GlobalScope.getInstance());\n    return \"Model descriptor is null for concept: \" +\n      concept + \"(\" + System.identityHashCode(concept) + \")  same concept from SModelUtil_new: \" +\n      conceptFromModelUtil + \"(\" + System.identityHashCode(conceptFromModelUtil) + \"), element: \" +\n      element + \"(\" + System.identityHashCode(element) + \"), myTopConcept: \" +\n      myTopConcept + \"(\" + System.identityHashCode(element) + \")\";\n  }","id":41492,"modified_method":"private String getAssertionMessage(Object element, SNode concept) {\n    String conceptFQName = NameUtil.nodeFQName(concept);\n    GlobalScope scope = GlobalScope.getInstance();\n    SNode conceptFromModelUtil = SModelUtil.findConceptDeclaration(conceptFQName, scope);\n\n    String languageFqName = NameUtil.namespaceFromConceptFQName(conceptFQName);\n    String conceptName = NameUtil.shortNameFromLongName(conceptFQName);\n    Language language = scope.getLanguage(new ModuleReference(languageFqName));\n    SNode conceptFromScope = null;\n    if (language != null) {\n      conceptFromScope = language.findConceptDeclaration(conceptName);\n    }\n\n    return \"Model descriptor is null for concept: \" +\n      concept + \"(\" + System.identityHashCode(concept) + \")  same concept from SModelUtil_new: \" +\n      conceptFromModelUtil + \"(\" + System.identityHashCode(conceptFromModelUtil) + \") same concept from Scope:\"\n      + conceptFromScope + \"(\" + System.identityHashCode(conceptFromScope) + \"), element: \" +\n      element + \"(\" + System.identityHashCode(element) + \"), myTopConcept: \" +\n      myTopConcept + \"(\" + System.identityHashCode(element) + \")\";\n  }","commit_id":"7462df0069059027057b566f97bb41b5e85afad5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public HidingByNameScope(SNode hidingRoot, SNode kind, @NotNull Scope scope, @NotNull Scope parentScope) {\n    // hiding root: all subconcepts of hidingRoot hide each other \n    this.scope = scope;\n    this.parentScope = parentScope;\n    this.hidingRootConceptFqName = NameUtil.nodeFQName(hidingRoot);\n    this.kindConceptFqName = NameUtil.nodeFQName(kind);\n    // todo: maybe lazy in getAvailableElements? \n    // todo: I need this micro optimizations? \n    Iterable<SNode> tmpResult = scope.getAvailableElements(null);\n    this.names = new HashSet<String>(Sequence.fromIterable(tmpResult).count());\n    for (SNode node : Sequence.fromIterable(tmpResult)) {\n      if (SNodeUtil.isInstanceOf(node, SConceptRepository.getInstance().getConcept(hidingRootConceptFqName))) {\n        SetSequence.fromSet(this.names).addElement(node.getName());\n      }\n    }\n  }","id":41493,"modified_method":"public HidingByNameScope(SNode hidingRoot, SNode kind, @NotNull Scope scope, @NotNull Scope parentScope) {\n    this(NameUtil.nodeFQName(hidingRoot), NameUtil.nodeFQName(kind), scope, parentScope);\n  }","commit_id":"7fe25a189e16e07b1cd2c6038b5b0c46986001b1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope forTypeVariables(Iterable<SNode> variables, Scope parentScope) {\n    // Hiding only other type variables \n    return new HidingByNameScope(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration\"), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration\"), new NamedElementsScope(variables), parentScope);\n  }","id":41494,"modified_method":"public static Scope forTypeVariables(Iterable<SNode> variables, Scope parentScope) {\n    // Hiding only other type variables \n    String typeVarConceptFQName = \"jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration\";\n    return new HidingByNameScope(typeVarConceptFQName, typeVarConceptFQName, new NamedElementsScope(variables), parentScope);\n  }","commit_id":"7fe25a189e16e07b1cd2c6038b5b0c46986001b1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IsInstanceCondition(AbstractConceptDeclaration conceptDeclaration) {\n    myConceptDeclaration = conceptDeclaration;\n    myConceptFqName = NameUtil.nodeFQName(myConceptDeclaration);\n  }","id":41495,"modified_method":"public IsInstanceCondition(AbstractConceptDeclaration conceptDeclaration) {\n    this(NameUtil.nodeFQName(conceptDeclaration));\n  }","commit_id":"6fe8c2c654ac248db8871c228aba647e80894d8c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getNodes(SModel model, final String conceptFqName) {\n    if (model == null) return new ArrayList<SNode>();\n    if (conceptFqName == null) {\n      return (List<SNode>) model.allNodes();\n    }\n\n    return model.allNodes(new Condition<SNode>() {\n      public boolean met(SNode node) {\n        return node.isInstanceOfConcept(conceptFqName);\n      }\n    });\n  }","id":41496,"modified_method":"public static List<SNode> getNodes(SModel model, final String conceptFqName) {\n    if (model == null) return new ArrayList<SNode>();\n    if (conceptFqName == null) {\n      return (List<SNode>) model.allNodes();\n    }\n\n    return model.allNodes(new IsInstanceCondition(conceptFqName));\n  }","commit_id":"6fe8c2c654ac248db8871c228aba647e80894d8c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean hasAccessLevel(String right, String username, String docname, XWikiContext context)\n        throws XWikiException\n    {\n        WikiReference wikiReference = new WikiReference(context.getDatabase());\n        DocumentReference document = resolveDocumentName(docname, wikiReference);\n        LOGGER.debug(\"hasAccessLevel() resolved document named [{}] into reference [{}]\", docname, document);\n        DocumentReference user = resolveUserName(username, wikiReference);\n\n        if (XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API\n            user = null;\n        }\n\n        return authorizationManager.hasAccess(Right.toRight(right), user, document);\n    }","id":41497,"modified_method":"@Override\n    public boolean hasAccessLevel(String rightName, String username, String docname, XWikiContext context)\n        throws XWikiException\n    {\n        WikiReference wikiReference = new WikiReference(context.getDatabase());\n        DocumentReference document = resolveDocumentName(docname, wikiReference);\n        LOGGER.debug(\"hasAccessLevel() resolved document named [{}] into reference [{}]\", docname, document);\n        DocumentReference user = resolveUserName(username, wikiReference);\n\n        if (XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API\n            user = null;\n        }\n\n        Right right = Right.toRight(rightName);\n\n        return !(user == null && needsAuth(right, context)) && authorizationManager.hasAccess(right, user, document);\n    }","commit_id":"246ed80543debdd2d7ba0ea6b686931da1b91e60","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        Right right = actionToRight(action);\n        EntityReference entityReference = doc.getDocumentReference();\n\n        LOGGER.debug(\"checkAccess for action \" + right + \" on entity \" + entityReference + '.');\n\n        DocumentReference userReference = authenticateUser(right, entityReference, context);\n        if (userReference == null) {\n            showLogin(context);\n            return false;\n        }\n        return authorizationManager.hasAccess(right, userReference, entityReference);\n    }","id":41498,"modified_method":"@Override\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        Right right = actionToRight(action);\n        EntityReference entityReference = doc.getDocumentReference();\n\n        LOGGER.debug(\"checkAccess for action \" + right + \" on entity \" + entityReference + '.');\n\n        DocumentReference userReference = authenticateUser(right, entityReference, context);\n        if (userReference == null) {\n            showLogin(context);\n            return false;\n        }\n\n        if (authorizationManager.hasAccess(right, userReference, entityReference)) {\n            return true;\n        }\n\n        // If the right has been denied, and we have guest user, redirect the user to login page\n        // unless the denied is on the login action, which could cause infinite redirection.\n        // FIXME: The hasAccessLevel is broken (do not allow document creator) on the delete action in the old\n        // implementation, so code that simply want to verify if a user can delete (but is not actually deleting)\n        // has to call checkAccess. This happen really often, and this why we should not redirect to login on failed\n        // delete, since it would prevent most user to do anything.\n        if (context.getUserReference() == null && !DELETE_ACTION.equals(action) && !LOGIN_ACTION.equals(action)) {\n            LOGGER.debug(\"Redirecting guest user to login, since it have been denied \" + right + \" on \"\n                + entityReference + '.');\n            showLogin(context);\n        }\n\n        return false;\n    }","commit_id":"f4a6dcbb4060605e34544b38ccd8eb072bb3e8b3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Check pre-condition for access.\n     *\n     * @param right the right being checked.\n     * @return true if pre-condition are fulfilled.\n     */\n    private boolean checkPreAccess(Right right)\n    {\n        if (right == Right.PROGRAM) {\n            if (renderingContext.isRestricted() || xcontextProvider.get().hasDroppedPermissions()) {\n                return false;\n            }\n        }\n\n        return true;\n    }","id":41499,"modified_method":"/**\n     * Check pre-condition for access.\n     *\n     * @param right the right being checked.\n     * @return true if pre-condition are fulfilled.\n     */\n    private boolean checkPreAccess(Right right)\n    {\n        if (right == Right.PROGRAM) {\n            if (this.renderingContext.isRestricted() || this.xcontextProvider.get().hasDroppedPermissions()) {\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public boolean hasAccess(Right right)\n    {\n        return hasAccess(right, getCurrentEntity());\n    }","id":41500,"modified_method":"@Override\n    public boolean hasAccess(Right right)\n    {\n        if (right == Right.PROGRAM) {\n            return hasAccess(right, getCurrentUser(right, null), null);\n        }\n\n        return hasAccess(right, getCurrentEntity());\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void checkAccess(Right right) throws AccessDeniedException\n    {\n        checkAccess(right, getCurrentEntity());\n    }","id":41501,"modified_method":"@Override\n    public void checkAccess(Right right) throws AccessDeniedException\n    {\n        if (right == Right.PROGRAM) {\n            checkAccess(right, getCurrentUser(right, null), null);\n        }\n\n        checkAccess(right, right == Right.PROGRAM ? null : getCurrentEntity());\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the current entity from context.\n     *\n     * @return the current sdoc or doc document reference, or the current wiki reference if no doc available.\n     */\n    private EntityReference getCurrentEntity()\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n        XWikiDocument doc = xcontext.getDoc();\n\n        if (doc != null) {\n            return doc.getDocumentReference();\n        }\n\n        return null;\n    }","id":41502,"modified_method":"/**\n     * Get the current entity from context.\n     *\n     * @return the current sdoc or doc document reference, or the current wiki reference if no doc available.\n     */\n    private EntityReference getCurrentEntity()\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n        XWikiDocument doc = xcontext.getDoc();\n\n        if (doc != null) {\n            return doc.getDocumentReference();\n        }\n\n        return null;\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public boolean hasAccess(Right right, EntityReference entity)\n    {\n        DocumentReference user = getCurrentUser(right);\n\n        return checkPreAccess(right) && authorizationManager.hasAccess(right, user, entity);\n    }","id":41503,"modified_method":"@Override\n    public boolean hasAccess(Right right, EntityReference entity)\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        return hasAccess(right, user, entity);\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void checkAccess(Right right, EntityReference entity) throws AccessDeniedException\n    {\n        DocumentReference user = getCurrentUser(right);\n\n        if (!checkPreAccess(right)) {\n            throw new AccessDeniedException(right, user, entity);\n        }\n\n        authorizationManager.checkAccess(right, user, entity);\n    }","id":41504,"modified_method":"@Override\n    public void checkAccess(Right right, EntityReference entity) throws AccessDeniedException\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        checkAccess(right, user, entity);\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the current user from context.\n     */\n    private DocumentReference getCurrentUser(Right right)\n    {\n        // Backward compatibility for the old way of assigning programming right.\n        if (right == Right.PROGRAM) {\n            XWikiDocument doc = getProgrammingDocument();\n            if (doc != null) {\n                return getContentAuthor(doc);\n            }\n        }\n\n        return this.xcontextProvider.get().getUserReference();\n    }","id":41505,"modified_method":"private DocumentReference getCurrentUser(Right right, EntityReference entity)\n    {\n        // Backward compatibility for the old way of assigning programming right.\n        if (right == Right.PROGRAM) {\n            XWikiDocument doc = entity == null ? getProgrammingDocument() : getDocument(entity);\n            if (doc != null) {\n                return getContentAuthor(doc);\n            }\n        }\n\n        return this.xcontextProvider.get().getUserReference();\n    }","commit_id":"184e0cbd033ebdbe9b3cebb2beeba29742e8c0ac","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Stops/Restores all currently playing sounds.\n     *\n     * @param isMute mute or not currently playing sounds\n     */\n    public void setMute(boolean mute)\n    {\n        this.mute = mute;\n\n        if (mute)\n        {\n            AudioNotifierService ans\n                = NotificationActivator.getAudioNotifier();\n\n            if ((ans != null) && (ans.isMute() != this.mute))\n                ans.setMute(this.mute);\n        }\n    }","id":41506,"modified_method":"/**\n     * Stops/Restores all currently playing sounds.\n     *\n     * @param mute mute or not currently playing sounds\n     */\n    public void setMute(boolean mute)\n    {\n        this.mute = mute;\n\n        if (mute)\n        {\n            AudioNotifierService ans\n                = NotificationActivator.getAudioNotifier();\n\n            if ((ans != null) && (ans.isMute() != this.mute))\n                ans.setMute(this.mute);\n        }\n    }","commit_id":"f65dc96da2a8f3095135af63f9fa8f973019ab4d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops the sound.\n     * @param data Additional data for the event.\n     */\n    public void stop(NotificationData data)\n    {\n        AudioNotifierService audioNotifService\n            = NotificationActivator.getAudioNotifier();\n\n        if (audioNotifService != null)\n        {\n            Iterator<Map.Entry<SCAudioClip, NotificationData>> i\n                = playedClips.entrySet().iterator();\n\n            while (i.hasNext())\n            {\n                Map.Entry<SCAudioClip, NotificationData> e = i.next();\n\n                if (e.getValue() == data)\n                {\n                    try\n                    {\n                        e.getKey().stop();\n                    }\n                    finally\n                    {\n                        i.remove();\n                    }\n                }\n            }\n        }\n    }","id":41507,"modified_method":"/**\n     * Stops the sound.\n     * @param data Additional data for the event.\n     */\n    public void stop(NotificationData data)\n    {\n        AudioNotifierService audioNotifService\n            = NotificationActivator.getAudioNotifier();\n\n        if (audioNotifService != null)\n        {\n            List<SCAudioClip> clipsToStop = new ArrayList<SCAudioClip>();\n\n            synchronized(playedClips)\n            {\n                Iterator<Map.Entry<SCAudioClip, NotificationData>> i\n                    = playedClips.entrySet().iterator();\n\n                while (i.hasNext())\n                {\n                    Map.Entry<SCAudioClip, NotificationData> e = i.next();\n\n                    if (e.getValue() == data)\n                    {\n                        clipsToStop.add(e.getKey());\n                        i.remove();\n                    }\n                }\n            }\n\n            for(SCAudioClip clip : clipsToStop)\n            {\n                try\n                {\n                    clip.stop();\n                }\n                catch(Throwable t)\n                {\n                    logger.error(\"Error stopping audio clip\", t);\n                }\n            }\n        }\n    }","commit_id":"f65dc96da2a8f3095135af63f9fa8f973019ab4d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Beeps the PC speaker.\n         *\n         * @return <tt>true<\/tt> if the playback was successful; otherwise,\n         * <tt>false<\/tt>\n         */\n        protected boolean runOnceInPlayThread()\n        {\n            try\n            {\n                Toolkit.getDefaultToolkit().beep();\n                return true;\n            }\n            catch (Throwable t)\n            {\n                if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n                else\n                    return false;\n            }\n        }","id":41508,"modified_method":"/**\n         * Beeps the PC speaker.\n         *\n         * @return <tt>true<\/tt> if the playback was successful; otherwise,\n         * <tt>false<\/tt>\n         */\n        protected boolean runOnceInPlayThread()\n        {\n            try\n            {\n                java.awt.Toolkit.getDefaultToolkit().beep();\n                return true;\n            }\n            catch (Throwable t)\n            {\n                if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n                else\n                    return false;\n            }\n        }","commit_id":"f65dc96da2a8f3095135af63f9fa8f973019ab4d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Plays the sound given by the containing <tt>soundFileDescriptor<\/tt>. The\n     * sound is played in loop if the loopInterval is defined.\n     * @param action The action to act upon.\n     * @param data Additional data for the event.\n     * @param device\n     */\n    private void play(\n            SoundNotificationAction action,\n            NotificationData data,\n            SCAudioClipDevice device)\n    {\n        AudioNotifierService audioNotifService\n            = NotificationActivator.getAudioNotifier();\n\n        if((audioNotifService == null)\n                || StringUtils.isNullOrEmpty(action.getDescriptor(), true))\n            return;\n\n        // this is hack, seen on some os (particularly seen on macosx with\n        // external devices).\n        // when playing notification in the call, can break the call and\n        // no further communicating can be done after the notification.\n        // So we skip playing notification if we have a call running\n        if(SCAudioClipDevice.PLAYBACK.equals(device))\n        {\n            UIService uiService = NotificationActivator.getUIService();\n\n            if(!uiService.getInProgressCalls().isEmpty())\n                return;\n        }\n\n        SCAudioClip audio = null;\n\n        switch (device)\n        {\n        case NOTIFICATION:\n        case PLAYBACK:\n            audio\n                = audioNotifService.createAudio(\n                        action.getDescriptor(),\n                        SCAudioClipDevice.PLAYBACK.equals(device));\n            break;\n\n        case PC_SPEAKER:\n            audio = new PCSpeakerClip();\n            break;\n        }\n\n        // it is possible that audio cannot be created\n        if(audio == null)\n            return;\n\n        playedClips.put(audio, data);\n\n        boolean played = false;\n\n        try\n        {\n            @SuppressWarnings(\"unchecked\")\n            Callable<Boolean> loopCondition\n                = (Callable<Boolean>)\n                    data.getExtra(\n                            NotificationData\n                                .SOUND_NOTIFICATION_HANDLER_LOOP_CONDITION_EXTRA);\n\n            audio.play(action.getLoopInterval(), loopCondition);\n            played = true;\n        }\n        finally\n        {\n            if (!played)\n                playedClips.remove(audio);\n        }\n    }","id":41509,"modified_method":"/**\n     * Plays the sound given by the containing <tt>soundFileDescriptor<\/tt>. The\n     * sound is played in loop if the loopInterval is defined.\n     * @param action The action to act upon.\n     * @param data Additional data for the event.\n     * @param device\n     */\n    private void play(\n            SoundNotificationAction action,\n            NotificationData data,\n            SCAudioClipDevice device)\n    {\n        AudioNotifierService audioNotifService\n            = NotificationActivator.getAudioNotifier();\n\n        if((audioNotifService == null)\n                || StringUtils.isNullOrEmpty(action.getDescriptor(), true))\n            return;\n\n        // this is hack, seen on some os (particularly seen on macosx with\n        // external devices).\n        // when playing notification in the call, can break the call and\n        // no further communicating can be done after the notification.\n        // So we skip playing notification if we have a call running\n        if(SCAudioClipDevice.PLAYBACK.equals(device))\n        {\n            UIService uiService = NotificationActivator.getUIService();\n\n            if(!uiService.getInProgressCalls().isEmpty())\n                return;\n        }\n\n        SCAudioClip audio = null;\n\n        switch (device)\n        {\n        case NOTIFICATION:\n        case PLAYBACK:\n            audio\n                = audioNotifService.createAudio(\n                        action.getDescriptor(),\n                        SCAudioClipDevice.PLAYBACK.equals(device));\n            break;\n\n        case PC_SPEAKER:\n            audio = new PCSpeakerClip();\n            break;\n        }\n\n        // it is possible that audio cannot be created\n        if(audio == null)\n            return;\n\n        synchronized(playedClips)\n        {\n            playedClips.put(audio, data);\n        }\n\n        boolean played = false;\n\n        try\n        {\n            @SuppressWarnings(\"unchecked\")\n            Callable<Boolean> loopCondition\n                = (Callable<Boolean>)\n                    data.getExtra(\n                            NotificationData\n                                .SOUND_NOTIFICATION_HANDLER_LOOP_CONDITION_EXTRA);\n\n            audio.play(action.getLoopInterval(), loopCondition);\n            played = true;\n        }\n        finally\n        {\n            synchronized(playedClips)\n            {\n                if (!played)\n                    playedClips.remove(audio);\n            }\n        }\n    }","commit_id":"f65dc96da2a8f3095135af63f9fa8f973019ab4d","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop() {\n        if (this.equals(getController().getParent())) {\n            getController().stop();\n        }\n        getCluster().stop();\n\n        clearLocations();\n        setAttribute(SERVICE_UP, false);\n    }","id":41510,"modified_method":"@Override\n    public void stop() {\n        List<Startable> tostop = Lists.newArrayList();\n        if (this.equals(getController().getParent())) tostop.add(getController());\n        tostop.add(getCluster());\n        \n        StartableMethods.stopSequentially(tostop);\n\n        clearLocations();\n        setAttribute(SERVICE_UP, false);\n    }","commit_id":"b773216a243bd95a2b93f57419739647403956fb","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getDisplayName() {\n    final String name = getMethodName();\n    final String clazz = StringUtil.getShortName(getClassName());\n    return clazz.length() > 0 ? clazz + \".\" + name : name;\n  }","id":41511,"modified_method":"public String getDisplayName() {\n    final String className = getClassName();\n    if (StringUtil.isEmpty(className)) return \"<unnamed>\";\n    MethodInfo singleInfo = null;\n    main : for (MethodInfo info : myParameterMap.values()) {\n      for (boolean b : info.paramFlags) {\n        if (b) {\n          if (singleInfo == null) {\n            singleInfo = info;\n            break;\n          }\n          else {\n            singleInfo = null;\n            break main;\n          }\n        }\n      }\n    }\n    final String name = singleInfo != null\n                        ? StringUtil.getShortName(className) + \".\" + singleInfo.methodName\n                        : StringUtil.getShortName(className);\n    return name + \" (\"+StringUtil.getPackageName(className)+\")\";\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"RedundantIfStatement\"})\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    final MethodParameterInjection that = (MethodParameterInjection)o;\n\n    if (!myClassName.equals(that.myClassName)) return false;\n    if (!myMethodSignature.equals(that.myMethodSignature)) return false;\n    if (myApplyInHierarchy != that.myApplyInHierarchy) return false;\n    if (!Arrays.equals(mySelection, that.mySelection)) return false;\n\n    return true;\n  }","id":41512,"modified_method":"@SuppressWarnings({\"RedundantIfStatement\"})\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    final MethodParameterInjection that = (MethodParameterInjection)o;\n\n    if (!myClassName.equals(that.myClassName)) return false;\n    if (!myParameterMap.equals(that.myParameterMap)) return false;\n    if (myApplyInHierarchy != that.myApplyInHierarchy) return false;\n\n    return true;\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void readExternalImpl(Element e) throws InvalidDataException {\n    setClassName(JDOMExternalizer.readString(e, \"CLASS\"));\n    setMethodSignature(JDOMExternalizer.readString(e, \"METHOD\"));\n    setApplyInHierarchy(JDOMExternalizer.readBoolean(e, \"APPLY_IN_HIERARCHY\"));\n\n    final JDOMExternalizableStringList list = new JDOMExternalizableStringList();\n    list.readExternal(e);\n    final Boolean[] booleans = new Boolean[list.size()];\n    ContainerUtil.map2Array(list, booleans, new Function<String, Boolean>() {\n      public Boolean fun(String s) {\n        return Boolean.valueOf(s);\n      }\n    });\n    mySelection = new boolean[booleans.length];\n    for (int i = 0; i < mySelection.length; i++) {\n      mySelection[i] = booleans[i];\n    }\n  }","id":41513,"modified_method":"protected void readExternalImpl(Element e) throws InvalidDataException {\n    setClassName(JDOMExternalizer.readString(e, \"CLASS\"));\n    setApplyInHierarchy(JDOMExternalizer.readBoolean(e, \"APPLY_IN_HIERARCHY\"));\n    readOldFormat(e);\n    final THashMap<String, String> map = new THashMap<String, String>();\n    JDOMExternalizer.readMap(e, map, null, \"SIGNATURES\");\n    for (String s : map.keySet()) {\n      myParameterMap.put(s, new MethodInfo(s, map.get(s)));\n    }\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + myClassName.hashCode();\n    result = 31 * result + myMethodSignature.hashCode();\n    result = 31 * result + (myApplyInHierarchy ? 0 : 1);\n    result = 31 * result + Arrays.hashCode(mySelection);\n    return result;\n  }","id":41514,"modified_method":"public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + myClassName.hashCode();\n    result = 31 * result + myParameterMap.hashCode();\n    result = 31 * result + (myApplyInHierarchy ? 0 : 1);\n    return result;\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void copyFrom(@NotNull MethodParameterInjection other) {\n    super.copyFrom(other);\n    myClassName = other.getClassName();\n    myMethodSignature = other.getMethodSignature();\n    mySelection = other.getSelection();\n    myApplyInHierarchy = other.isApplyInHierarchy();\n  }","id":41515,"modified_method":"public void copyFrom(@NotNull MethodParameterInjection other) {\n    super.copyFrom(other);\n    myClassName = other.getClassName();\n    myParameterMap.clear();\n    for (MethodInfo info : other.myParameterMap.values()) {\n      myParameterMap.put(info.methodSignature, info.copy());\n    }\n    myApplyInHierarchy = other.isApplyInHierarchy();\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isApplicable(@NotNull PsiLiteralExpression element) {\n    PsiElement e = element;\n    while (!(e.getParent() instanceof PsiExpressionList)) {\n      e = e.getParent();\n      if (!(e instanceof PsiExpression)) {\n        return false;\n      }\n    }\n\n    final PsiParameter parameter = PsiUtilEx.getParameterForArgument((PsiExpression)e);\n    if (parameter == null) {\n      return false;\n    }\n    final PsiElement _parent = parameter.getParent();\n    final PsiParameterList list;\n    if (_parent instanceof PsiParameterList) {\n      list = (PsiParameterList)_parent;\n    }\n    else {\n      return false;\n    }\n    if (mySelection.length != list.getParametersCount()) {\n      return false;\n    }\n    if (!mySelection[list.getParameterIndex(parameter)]) {\n      return false;\n    }\n    final PsiMethod method = PsiTreeUtil.getParentOfType(list, PsiMethod.class, true, true);\n    if (method == null || !myMethodName.equals(method.getName())) {\n      return false;\n    }\n    final PsiClass psiClass = method.getContainingClass();\n    if (psiClass == null) {\n      return false;\n    }\n    if (myClassName.equals(psiClass.getQualifiedName())) {\n      return true;\n    }\n    if (myApplyInHierarchy) {\n      final GlobalSearchScope scope = GlobalSearchScope.allScope(element.getProject());\n      final PsiClass baseClass = JavaPsiFacade.getInstance(element.getProject()).findClass(myClassName, scope);\n      if (baseClass != null && psiClass.isInheritor(baseClass, true)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":41516,"modified_method":"public boolean isApplicable(@NotNull PsiLiteralExpression element) {\n    PsiElement e = element;\n    while (!(e.getParent() instanceof PsiExpressionList)) {\n      e = e.getParent();\n      if (!(e instanceof PsiExpression)) {\n        return false;\n      }\n    }\n\n    final PsiParameter parameter = PsiUtilEx.getParameterForArgument((PsiExpression)e);\n    if (parameter == null) {\n      return false;\n    }\n    final PsiElement _parent = parameter.getParent();\n    final PsiParameterList list;\n    if (_parent instanceof PsiParameterList) {\n      list = (PsiParameterList)_parent;\n    }\n    else {\n      return false;\n    }\n    final PsiMethod method = PsiTreeUtil.getParentOfType(list, PsiMethod.class, true, true);\n    if (method == null) return false;\n    final String methodName = method.getName();\n    final int parameterIndex = list.getParameterIndex(parameter);\n    boolean found = false;\n    for (MethodInfo info : myParameterMap.values()) {\n      if (info.methodName.equals(methodName)\n          && info.paramFlags.length == list.getParametersCount()\n          && info.paramFlags[parameterIndex]) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) return false;\n    final PsiClass psiClass = method.getContainingClass();\n    if (psiClass == null) return false;\n    if (myClassName.equals(psiClass.getQualifiedName())) return true;\n    if (myApplyInHierarchy) {\n      final GlobalSearchScope scope = GlobalSearchScope.allScope(element.getProject());\n      final PsiClass baseClass = JavaPsiFacade.getInstance(element.getProject()).findClass(myClassName, scope);\n      if (baseClass != null && psiClass.isInheritor(baseClass, true)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void writeExternalImpl(Element e) throws WriteExternalException {\n    JDOMExternalizer.write(e, \"CLASS\", myClassName);\n    JDOMExternalizer.write(e, \"METHOD\", myMethodSignature);\n    JDOMExternalizer.write(e, \"APPLY_IN_HIERARCHY\", myApplyInHierarchy);\n\n    final Boolean[] booleans = new Boolean[mySelection.length];\n    for (int i = 0; i < mySelection.length; i++) {\n      booleans[i] = mySelection[i];\n    }\n    //noinspection MismatchedQueryAndUpdateOfCollection\n    final JDOMExternalizableStringList list = new JDOMExternalizableStringList();\n    list.addAll(ContainerUtil.map2List(booleans, new Function<Boolean, String>() {\n      public String fun(Boolean s) {\n        return s.toString();\n      }\n    }));\n    list.writeExternal(e);\n  }","id":41517,"modified_method":"protected void writeExternalImpl(Element e) throws WriteExternalException {\n    JDOMExternalizer.write(e, \"CLASS\", myClassName);\n    JDOMExternalizer.write(e, \"APPLY_IN_HIERARCHY\", myApplyInHierarchy);\n    final THashMap<String, String> map = new THashMap<String, String>();\n    for (String s : myParameterMap.keySet()) {\n      map.put(s, myParameterMap.get(s).getFlagsString());\n    }\n    JDOMExternalizer.writeMap(e, map, null, \"SIGNATURES\");\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(ActionEvent e) {\n      final TreeClassChooserFactory factory = TreeClassChooserFactory.getInstance(myProject);\n      final TreeClassChooser chooser = factory.createAllProjectScopeChooser(\"Select Class\");\n      chooser.showDialog();\n      final PsiClass psiClass = chooser.getSelectedClass();\n      if (psiClass != null) {\n        setClassName(psiClass.getQualifiedName());\n        updateTree();\n      }\n    }","id":41518,"modified_method":"public void actionPerformed(ActionEvent e) {\n      final TreeClassChooserFactory factory = TreeClassChooserFactory.getInstance(myProject);\n      final TreeClassChooser chooser = factory.createAllProjectScopeChooser(\"Select Class\");\n      chooser.showDialog();\n      final PsiClass psiClass = chooser.getSelectedClass();\n      if (psiClass != null) {\n        setPsiClass(psiClass.getQualifiedName());\n        updateParamTree();\n        updateTree();\n      }\n    }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String buildSignature(@Nullable PsiMethod method) {\n    if (method == null) {\n      return null;\n    }\n\n    final PsiParameterList list = method.getParameterList();\n    final PsiParameter[] parameters = list.getParameters();\n    final String s;\n    if (parameters.length > 0) {\n      // if there are no sources, parameter names are unknown. This trick gives the \"decompiled\" names\n      if (list instanceof ClsParameterListImpl && parameters[0].getName() == null) {\n        s = method.getName() + list.getText();\n      }\n      else {\n        s = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_PARAMETERS,\n                                       PsiFormatUtil.SHOW_TYPE | PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_FQ_CLASS_NAMES);\n      }\n    }\n    else {\n      s = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME, 0) + \"()\";\n    }\n    return s;\n  }","id":41519,"modified_method":"@NotNull\n  private static String buildSignature(@NotNull PsiMethod method) {\n    final PsiParameterList list = method.getParameterList();\n    final PsiParameter[] parameters = list.getParameters();\n    final String s;\n    if (parameters.length > 0) {\n      // if there are no sources, parameter names are unknown. This trick gives the \"decompiled\" names\n      if (list instanceof ClsParameterListImpl && parameters[0].getName() == null) {\n        s = method.getName() + list.getText();\n      }\n      else {\n        s = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_PARAMETERS,\n                                       PsiFormatUtil.SHOW_TYPE | PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_FQ_CLASS_NAMES);\n      }\n    }\n    else {\n      s = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME, 0) + \"()\";\n    }\n    return s;\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiType getClassType() {\n    final PsiDocumentManager dm = PsiDocumentManager.getInstance(myProject);\n    final PsiFile psiFile = dm.getPsiFile(myClassField.getEditorTextField().getDocument());\n    try {\n      assert psiFile != null;\n      return ((PsiTypeCodeFragment)psiFile).getType();\n    }\n    catch (PsiTypeCodeFragment.TypeSyntaxException e1) {\n      return null;\n    }\n    catch (PsiTypeCodeFragment.NoTypeException e1) {\n      return null;\n    }\n  }","id":41520,"modified_method":"@Nullable\n  private PsiType getClassType() {\n    final Document document = myClassField.getEditorTextField().getDocument();\n    final PsiDocumentManager dm = PsiDocumentManager.getInstance(myProject);\n    dm.commitDocument(document);\n    final PsiFile psiFile = dm.getPsiFile(document);\n    try {\n      assert psiFile != null;\n      return ((PsiTypeCodeFragment)psiFile).getType();\n    }\n    catch (PsiTypeCodeFragment.TypeSyntaxException e1) {\n      return null;\n    }\n    catch (PsiTypeCodeFragment.NoTypeException e1) {\n      return null;\n    }\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodParameterPanel(MethodParameterInjection injection, final Project project) {\n    super(injection, project);\n    $$$setupUI$$$(); // see IDEA-9987\n\n    myParamModel = (ParamModel)myParamsTable.getModel();\n    myParamModel.setSortable(false);\n    myParamModel.setItems(Collections.<Param>emptyList());\n\n    final TreeUpdateListener updateListener = new TreeUpdateListener();\n    myClassField = new ReferenceEditorWithBrowseButton(new BrowseClassListener(project), project, new Function<String, Document>() {\n      public Document fun(String s) {\n        final Document document = ReferenceEditorWithBrowseButton.createTypeDocument(s, PsiManager.getInstance(project));\n        document.addDocumentListener(updateListener);\n        return document;\n      }\n    }, \"\");\n    myClassPanel.add(myClassField, BorderLayout.CENTER);\n\n    myMethodField = new ReferenceEditorWithBrowseButton(new BrowseMethodListener(project), project, new Function<String, Document>() {\n      public Document fun(String s) {\n        final Document document = EditorFactory.getInstance().createDocument(s);\n        document.setReadOnly(true);\n        document.addDocumentListener(updateListener);\n        return document;\n      }\n    }, \"\");\n    myMethodPanel.add(myMethodField, BorderLayout.CENTER);\n\n    init(injection.copy());\n  }","id":41521,"modified_method":"public MethodParameterPanel(MethodParameterInjection injection, final Project project) {\n    super(injection, project);\n\n    myClassField = new ReferenceEditorWithBrowseButton(new BrowseClassListener(project), project, new Function<String, Document>() {\n      public Document fun(String s) {\n        final Document document = ReferenceEditorWithBrowseButton.createTypeDocument(s, PsiManager.getInstance(project));\n        document.addDocumentListener(new DocumentAdapter() {\n          @Override\n          public void documentChanged(final DocumentEvent e) {\n            updateParamTree();\n            updateTree();\n          }\n        });\n        return document;\n      }\n    }, \"\");\n    myClassPanel.add(myClassField, BorderLayout.CENTER);\n    myParamsTable.getTree().setShowsRootHandles(true);\n    myParamsTable.getTree().setCellRenderer(new ColoredTreeCellRenderer() {\n\n      public void customizeCellRenderer(final JTree tree,\n                                        final Object value,\n                                        final boolean selected,\n                                        final boolean expanded,\n                                        final boolean leaf,\n                                        final int row,\n                                        final boolean hasFocus) {\n\n        final Object o = ((DefaultMutableTreeNode)value).getUserObject();\n        setIcon(o instanceof PsiMethod ? Icons.METHOD_ICON : o instanceof PsiParameter ? Icons.PARAMETER_ICON : null);\n        final String name = o instanceof PsiMethod\n                            ? PsiFormatUtil.formatMethod((PsiMethod)o, PsiSubstitutor.EMPTY,\n                                                         PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_PARAMETERS, PsiFormatUtil.SHOW_NAME)\n                            : o instanceof PsiParameter\n                              ? PsiFormatUtil\n                                .formatVariable((PsiParameter)o, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_TYPE, PsiSubstitutor.EMPTY)\n                              : null;\n        final boolean missing = o instanceof PsiElement && !((PsiElement)o).isPhysical();\n        if (name != null) {\n          append(name, missing? SimpleTextAttributes.ERROR_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n\n    });\n    init(injection.copy());\n    PeerFactory.getInstance().getUIHelper().installTreeTableSpeedSearch(myParamsTable, new Convertor<TreePath, String>() {\n      @Nullable\n      public String convert(final TreePath o) {\n        final Object userObject = ((DefaultMutableTreeNode)o.getLastPathComponent()).getUserObject();\n        return userObject instanceof PsiNamedElement? ((PsiNamedElement)userObject).getName() : null;\n      }\n    });\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    myLanguagePanel = new LanguagePanel(myProject, myOrigInjection);\n    myParamsTable = new TableView<Param>(new ParamModel());\n  }","id":41522,"modified_method":"private void createUIComponents() {\n    myLanguagePanel = new LanguagePanel(myProject, myOrigInjection);\n    myRootNode = new DefaultMutableTreeNode(null, true);\n    myParamsTable = new MyView(new ListTreeTableModelOnColumns(myRootNode, createColumnInfos()));\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void resetImpl() {\n    setClassName(myOrigInjection.getClassName());\n    myMethod = makeMethod(myOrigInjection.getMethodSignature());\n    if (myMethod != null) {\n      setMethodName(myMethod.getName());\n    }\n    setSelection(myOrigInjection.getSelection());\n    myHierarchy.setSelected(myOrigInjection.isApplyInHierarchy());\n  }","id":41523,"modified_method":"protected void resetImpl() {\n    setPsiClass(myOrigInjection.getClassName());\n    myHierarchy.setSelected(myOrigInjection.isApplyInHierarchy());\n\n    rebuildTreeModel();\n    final THashMap<String, PsiMethod> map = new THashMap<String, PsiMethod>();\n    for (PsiMethod method : myData.keySet()) {\n      map.put(myData.get(method).getMethodSignature(), method);\n    }\n    for (MethodParameterInjection.MethodInfo info : myOrigInjection.getMethodInfos()) {\n      final PsiMethod method = map.get(info.getMethodSignature());\n      if (method != null) {\n        final MethodParameterInjection.MethodInfo curInfo = myData.get(method);\n        System.arraycopy(info.getParamFlags(), 0, curInfo.getParamFlags(), 0, Math.min(info.getParamFlags().length, curInfo.getParamFlags().length));\n      }\n      else {\n        final PsiMethod missingMethod = makeMethod(info.getMethodSignature());\n        myData.put(missingMethod, info.copy());\n      }\n    }\n    refreshTreeStructure();\n    final Enumeration enumeration = myRootNode.children();\n    while (enumeration.hasMoreElements()) {\n      PsiMethod method = (PsiMethod)((DefaultMutableTreeNode)enumeration.nextElement()).getUserObject();\n      assert myData.containsKey(method);\n    }\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setClassName(String name) {\n    myClassField.setText(name);\n    myMethod = null;\n    setMethodName(\"\");\n  }","id":41524,"modified_method":"private void setPsiClass(String name) {\n    myClassField.setText(name);\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateParameters() {\n    if (myMethod != null) {\n      final PsiParameterList list = myMethod.getParameterList();\n      final java.util.List<Param> params = ContainerUtil.map(list.getParameters(), new Function<PsiParameter, Param>() {\n        public Param fun(PsiParameter s) {\n          return new Param(list.getParameterIndex(s), s);\n        }\n      });\n      if (!myParamModel.getItems().equals(params)) {\n        myParamModel.setItems(params);\n      }\n    }\n    else {\n      myParamModel.setItems(Collections.<Param>emptyList());\n    }\n  }","id":41525,"modified_method":"private void updateParamTree() {\n    rebuildTreeModel();\n    refreshTreeStructure();\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void apply(MethodParameterInjection other) {\n    other.setClassName(getClassName());\n    other.setMethodSignature(buildSignature(myMethod));\n    other.setSelection(getSelection());\n    other.setApplyInHierarchy(myHierarchy.isSelected());\n  }","id":41526,"modified_method":"protected void apply(MethodParameterInjection other) {\n    other.setClassName(getClassName());\n    other.setApplyInHierarchy(myHierarchy.isSelected());\n    if (getClassType() != null) {\n      other.setMethodInfos(ContainerUtil.findAll(myData.values(), new Condition<MethodParameterInjection.MethodInfo>() {\n        public boolean value(final MethodParameterInjection.MethodInfo methodInfo) {\n          return methodInfo.isEnabled();\n        }\n      }));\n    }\n  }","commit_id":"c723cbd972ed0227334a1a67bd777afdc2a9f932","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void elementRenamedOrMoved(@NotNull final PsiElement newElement) {\n      if (StringUtil.isEmpty(myOldPackageName)) return;\n\n      final String newPackageName = getPackageName(newElement);\n      if (myModule == null) {\n        for (final Module module : ModuleManager.getInstance(newElement.getProject()).getModules()) {\n          updateForModule(module, myOldPackageName, newPackageName);\n        }\n      }\n      else {\n        updateForModule(myModule, myOldPackageName, newPackageName);\n      }\n    }","id":41527,"modified_method":"public void elementRenamedOrMoved(@NotNull final PsiElement newElement) {\n      if (StringUtil.isEmpty(myOldPackageName)) return;\n\n      final String newPackageName = getPackageName(newElement);\n      updatePackageName(newElement, newPackageName);\n    }","commit_id":"5bccdac308f160379f2e6a1e8b1214514d601171","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void updatePackage(final FlexRunConfiguration runConfiguration, final String newPackage) {\n    final FlexRunnerParameters params = runConfiguration.getRunnerParameters();\n    final boolean isFlexUnit = params instanceof FlexUnitRunnerParameters;\n\n    if (isFlexUnit) {\n      if (((FlexUnitRunnerParameters)params).getScope() == FlexUnitRunnerParameters.Scope.Package) {\n        ((FlexUnitRunnerParameters)params).setPackageName(newPackage);\n      }\n      else {\n        final String oldFqn = ((FlexUnitRunnerParameters)params).getClassName();\n        ((FlexUnitRunnerParameters)params).setClassName(\n          newPackage + (StringUtil.isEmpty(newPackage) ? \"\" : \".\") + StringUtil.getShortName(oldFqn));\n      }\n    }\n    else {\n      final String oldFqn = params.getMainClassName();\n      params.setMainClassName(newPackage + (StringUtil.isEmpty(newPackage) ? \"\" : \".\") + StringUtil.getShortName(oldFqn));\n    }\n  }","id":41528,"modified_method":"private static void updatePackage(final FlexRunConfiguration runConfiguration, final String newPackage) {\n    final FlexRunnerParameters params = runConfiguration.getRunnerParameters();\n    final boolean isFlexUnit = params instanceof FlexUnitRunnerParameters;\n\n    if (isFlexUnit) {\n      if (((FlexUnitRunnerParameters)params).getScope() == FlexUnitRunnerParameters.Scope.Package) {\n        ((FlexUnitRunnerParameters)params).setPackageName(newPackage);\n      }\n      else {\n        final String oldFqn = ((FlexUnitRunnerParameters)params).getClassName();\n        ((FlexUnitRunnerParameters)params).setClassName(StringUtil.getQualifiedName(newPackage, StringUtil.getShortName(oldFqn)));\n      }\n    }\n    else {\n      final String oldFqn = params.getMainClassName();\n      params.setMainClassName(StringUtil.getQualifiedName(newPackage, StringUtil.getShortName(oldFqn)));\n    }\n  }","commit_id":"5bccdac308f160379f2e6a1e8b1214514d601171","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected String checkV2(Language lang, Language motherTongue, String text) throws IOException {\n    return check(\"/v2/check\", lang, motherTongue, text);\n  }","id":41529,"modified_method":"protected String checkV2(Language lang, Language motherTongue, String text) throws IOException {\n    return check(\"/v2/check\", lang, motherTongue, text, \"\");\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private String checkV2(Language lang, String text) throws IOException {\n    return checkV2(lang, null, text);\n  }","id":41530,"modified_method":"private String checkV2(Language lang, String text) throws IOException {\n    return checkV2(lang, (Language)null, text);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"void runTestsV2() throws IOException, SAXException, ParserConfigurationException {\n    // no error:\n    String emptyResultPattern = \".*\\\"matches\\\":\\\\[\\\\].*\";\n    German german = new German();\n    String result1 = checkV2(german, \"\");\n    assertTrue(\"Got \" + result1 + \", expected \" + emptyResultPattern, result1.matches(emptyResultPattern));\n    String result2 = checkV2(german, \"Ein kleiner test\");\n    assertTrue(\"Got \" + result2 + \", expected \" + emptyResultPattern, result2.matches(emptyResultPattern));\n    // one error:\n    assertTrue(checkV2(german, \"ein kleiner test.\").contains(\"UPPERCASE_SENTENCE_START\"));\n    // two errors:\n    String result = checkV2(german, \"ein kleiner test. Und wieder Erwarten noch was: \\u00f6\\u00e4\\u00fc\\u00df.\");\n    assertTrue(\"Got result without 'UPPERCASE_SENTENCE_START': \" + result, result.contains(\"UPPERCASE_SENTENCE_START\"));\n    assertTrue(\"Got result without 'WIEDER_WILLEN': \" + result, result.contains(\"WIEDER_WILLEN\"));\n    assertTrue(\"Expected special chars, got: '\" + result + \"'\",\n            result.contains(\"\\u00f6\\u00e4\\u00fc\\u00df\"));   // special chars are intact\n    assertTrue(checkV2(german, \"bla <script>\").contains(\"<script>\"));  // no escaping of '<' and '>' needed, unlike in XML\n\n    // other tests for special characters\n    String germanSpecialChars = checkV2(german, \"ein kleiner test. Und wieder Erwarten noch was: + .\");\n    assertTrue(\"Expected special chars, got: '\" + germanSpecialChars + \"'\", germanSpecialChars.contains(\"+\"));\n    String romanianSpecialChars = checkV2(new Romanian(), \"bla bla   i cteva caractere speciale\");\n    assertTrue(\"Expected special chars, got: '\" + romanianSpecialChars + \"'\", romanianSpecialChars.contains(\"\"));\n    Polish polish = new Polish();\n    String polishSpecialChars = checkV2(polish, \"Mwia dugo, eby tylko mwi mwi dugo.\");\n    assertTrue(\"Expected special chars, got: '\" + polishSpecialChars+ \"'\", polishSpecialChars.contains(\"mwi\"));\n    // test http POST\n    assertTrue(checkByPOST(new Romanian(), \"greit greit\").contains(\"greit\"));\n    // test supported language listing\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + \"/Languages\");\n    String languagesXML = StringTools.streamToString((InputStream) url.getContent(), \"UTF-8\");\n    if (!languagesXML.contains(\"Romanian\") || !languagesXML.contains(\"English\")) {\n      fail(\"Error getting supported languages: \" + languagesXML);\n    }\n    if (!languagesXML.contains(\"abbr=\\\"de\\\"\") || !languagesXML.contains(\"abbrWithVariant=\\\"de-DE\\\"\")) {\n      fail(\"Error getting supported languages: \" + languagesXML);\n    }\n    // tests for \"&\" character\n    English english = new English();\n    assertTrue(checkV2(english, \"Me & you you\").contains(\"&\"));\n    // tests for mother tongue (copy from link {@link FalseFriendRuleTest})   \n    assertTrue(checkV2(english, german, \"We will berate you\").contains(\"BERATE\"));\n    assertTrue(checkV2(german, english, \"Man sollte ihn nicht so beraten.\").contains(\"BERATE\"));\n    assertTrue(checkV2(polish, english, \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n      \n    //tests for bitext\n    assertTrue(bitextCheck(polish, english, \"This is frivolous.\", \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n    assertTrue(!bitextCheck(polish, english, \"This is something else.\", \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n    \n    //test for no changed if no options set\n    String[] nothing = {};\n    assertEquals(checkV2(english, german, \"We will berate you\"), \n        checkWithOptionsV2(english, german, \"We will berate you\", nothing, nothing, false));\n    \n    //disabling\n    String[] disableAvsAn = {\"EN_A_VS_AN\"};\n    assertTrue(!checkWithOptionsV2(\n            english, german, \"This is an test\", nothing, disableAvsAn, false).contains(\"an test\"));\n\n    //enabling\n    assertTrue(checkWithOptionsV2(\n            english, german, \"This is an test\", disableAvsAn, nothing, false).contains(\"an test\"));\n    //should also mean _NOT_ disabling all other rules...\n    assertTrue(checkWithOptionsV2(\n            english, german, \"We will berate you\", disableAvsAn, nothing, false).contains(\"BERATE\"));\n    //..unless explicitly stated.\n    assertTrue(!checkWithOptionsV2(\n        english, german, \"We will berate you\", disableAvsAn, nothing, true).contains(\"BERATE\"));\n    \n    \n    //test if two rules get enabled as well\n    String[] twoRules = {\"EN_A_VS_AN\", \"BERATE\"};\n    \n    String resultEn = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", twoRules, nothing, false);\n    assertTrue(\"Result: \" + resultEn, resultEn.contains(\"EN_A_VS_AN\"));\n    assertTrue(\"Result: \" + resultEn, resultEn.contains(\"BERATE\"));\n\n    //check two disabled options\n    String result3 = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", nothing, twoRules, false);\n    assertFalse(\"Result: \" + result3, result3.contains(\"EN_A_VS_AN\"));\n    assertFalse(\"Result: \" + result3, result3.contains(\"BERATE\"));\n    \n    //two disabled, one enabled, so enabled wins\n    String result4 = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", disableAvsAn, twoRules, false);\n    assertTrue(\"Result: \" + result4, result4.contains(\"EN_A_VS_AN\"));\n    assertFalse(\"Result: \" + result4, result4.contains(\"BERATE\"));\n\n    //check disabling bitext rules:\n    String result5 = bitextCheckDisabled(polish, english, \"a\", \"To jest okropnie dugi tekst, naprawd!\", nothing);\n    assertTrue(\"Result: \" + result5, result5.contains(\"TRANSLATION_LENGTH\"));\n    assertFalse(\"Result: \" + result5, result5.contains(\"\\\"-2\\\"\"));\n\n    String[] disableTranslationLen = {\"TRANSLATION_LENGTH\"};\n    String result6 = bitextCheckDisabled(polish, english, \"a\", \"This is a very long text. Really!\", disableTranslationLen);\n    assertFalse(\"Result: \" + result6, result6.contains(\"TRANSLATION_LENGTH\"));\n  }","id":41531,"modified_method":"void runTestsV2() throws IOException, SAXException, ParserConfigurationException {\n    // no error:\n    String emptyResultPattern = \".*\\\"matches\\\":\\\\[\\\\].*\";\n    German german = new German();\n    String result1 = checkV2(german, \"\");\n    assertTrue(\"Got \" + result1 + \", expected \" + emptyResultPattern, result1.matches(emptyResultPattern));\n    String result2 = checkV2(german, \"Ein kleiner test\");\n    assertTrue(\"Got \" + result2 + \", expected \" + emptyResultPattern, result2.matches(emptyResultPattern));\n    // one error:\n    assertTrue(checkV2(german, \"ein kleiner test.\").contains(\"UPPERCASE_SENTENCE_START\"));\n    // two errors:\n    String result = checkV2(german, \"ein kleiner test. Und wieder Erwarten noch was: \\u00f6\\u00e4\\u00fc\\u00df.\");\n    assertTrue(\"Got result without 'UPPERCASE_SENTENCE_START': \" + result, result.contains(\"UPPERCASE_SENTENCE_START\"));\n    assertTrue(\"Got result without 'WIEDER_WILLEN': \" + result, result.contains(\"WIEDER_WILLEN\"));\n    assertTrue(\"Expected special chars, got: '\" + result + \"'\",\n            result.contains(\"\\u00f6\\u00e4\\u00fc\\u00df\"));   // special chars are intact\n    assertTrue(checkV2(german, \"bla <script>\").contains(\"<script>\"));  // no escaping of '<' and '>' needed, unlike in XML\n\n    // other tests for special characters\n    String germanSpecialChars = checkV2(german, \"ein kleiner test. Und wieder Erwarten noch was: + .\");\n    assertTrue(\"Expected special chars, got: '\" + germanSpecialChars + \"'\", germanSpecialChars.contains(\"+\"));\n    String romanianSpecialChars = checkV2(new Romanian(), \"bla bla   i cteva caractere speciale\");\n    assertTrue(\"Expected special chars, got: '\" + romanianSpecialChars + \"'\", romanianSpecialChars.contains(\"\"));\n    Polish polish = new Polish();\n    String polishSpecialChars = checkV2(polish, \"Mwia dugo, eby tylko mwi mwi dugo.\");\n    assertTrue(\"Expected special chars, got: '\" + polishSpecialChars+ \"'\", polishSpecialChars.contains(\"mwi\"));\n    // test http POST\n    assertTrue(checkByPOST(new Romanian(), \"greit greit\").contains(\"greit\"));\n    // test supported language listing\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + \"/Languages\");\n    String languagesXML = StringTools.streamToString((InputStream) url.getContent(), \"UTF-8\");\n    if (!languagesXML.contains(\"Romanian\") || !languagesXML.contains(\"English\")) {\n      fail(\"Error getting supported languages: \" + languagesXML);\n    }\n    if (!languagesXML.contains(\"abbr=\\\"de\\\"\") || !languagesXML.contains(\"abbrWithVariant=\\\"de-DE\\\"\")) {\n      fail(\"Error getting supported languages: \" + languagesXML);\n    }\n    // tests for \"&\" character\n    English english = new English();\n    assertTrue(checkV2(english, \"Me & you you\").contains(\"&\"));\n    // tests for mother tongue (copy from link {@link FalseFriendRuleTest})   \n    assertTrue(checkV2(english, german, \"We will berate you\").contains(\"BERATE\"));\n    assertTrue(checkV2(german, english, \"Man sollte ihn nicht so beraten.\").contains(\"BERATE\"));\n    assertTrue(checkV2(polish, english, \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n      \n    //tests for bitext\n    assertTrue(bitextCheck(polish, english, \"This is frivolous.\", \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n    assertTrue(!bitextCheck(polish, english, \"This is something else.\", \"To jest frywolne.\").contains(\"FRIVOLOUS\"));\n    \n    //test for no changed if no options set\n    String[] nothing = {};\n    assertEquals(checkV2(english, german, \"We will berate you\"), \n        checkWithOptionsV2(english, german, \"We will berate you\", nothing, nothing, false));\n    \n    //disabling\n    String[] disableAvsAn = {\"EN_A_VS_AN\"};\n    assertTrue(!checkWithOptionsV2(\n            english, german, \"This is an test\", nothing, disableAvsAn, false).contains(\"an test\"));\n\n    //enabling\n    assertTrue(checkWithOptionsV2(\n            english, german, \"This is an test\", disableAvsAn, nothing, false).contains(\"an test\"));\n    //should also mean _NOT_ disabling all other rules...\n    assertTrue(checkWithOptionsV2(\n            english, german, \"We will berate you\", disableAvsAn, nothing, false).contains(\"BERATE\"));\n    //..unless explicitly stated.\n    assertTrue(!checkWithOptionsV2(\n        english, german, \"We will berate you\", disableAvsAn, nothing, true).contains(\"BERATE\"));\n    \n    \n    //test if two rules get enabled as well\n    String[] twoRules = {\"EN_A_VS_AN\", \"BERATE\"};\n    \n    String resultEn = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", twoRules, nothing, false);\n    assertTrue(\"Result: \" + resultEn, resultEn.contains(\"EN_A_VS_AN\"));\n    assertTrue(\"Result: \" + resultEn, resultEn.contains(\"BERATE\"));\n\n    //check two disabled options\n    String result3 = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", nothing, twoRules, false);\n    assertFalse(\"Result: \" + result3, result3.contains(\"EN_A_VS_AN\"));\n    assertFalse(\"Result: \" + result3, result3.contains(\"BERATE\"));\n    \n    //two disabled, one enabled, so enabled wins\n    String result4 = checkWithOptionsV2(\n            english, german, \"This is an test. We will berate you.\", disableAvsAn, twoRules, false);\n    assertTrue(\"Result: \" + result4, result4.contains(\"EN_A_VS_AN\"));\n    assertFalse(\"Result: \" + result4, result4.contains(\"BERATE\"));\n\n    String result5 = checkV2(null, \"This is a test of the language detection.\");\n    assertTrue(\"Result: \" + result5, result5.contains(\"\\\"en-US\\\"\"));\n\n    String result6 = checkV2(null, \"This is a test of the language detection.\", \"&preferredVariants=de-DE,en-GB\");\n    assertTrue(\"Result: \" + result6, result6.contains(\"\\\"en-GB\\\"\"));\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private String check(String urlPrefix, Language lang, Language motherTongue, String text) throws IOException {\n    String urlOptions = urlPrefix + \"?language=\" + lang.getShortName();\n    urlOptions += \"&disabled=HUNSPELL_RULE&text=\" + URLEncoder.encode(text, \"UTF-8\"); // latin1 is not enough for languages like polish, romanian, etc\n    if (motherTongue != null) {\n      urlOptions += \"&motherTongue=\" + motherTongue.getShortName();\n    }\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + urlOptions);\n    return HTTPTools.checkAtUrl(url);\n  }","id":41532,"modified_method":"private String check(String urlPrefix, Language lang, Language motherTongue, String text, String parameters) throws IOException {\n    String urlOptions = urlPrefix + \"?language=\" + (lang == null ? \"auto\" : lang.getShortName());\n    urlOptions += \"&disabled=HUNSPELL_RULE&text=\" + URLEncoder.encode(text, \"UTF-8\"); // latin1 is not enough for languages like polish, romanian, etc\n    if (motherTongue != null) {\n      urlOptions += \"&motherTongue=\" + motherTongue.getShortName();\n    }\n    urlOptions += parameters;\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + urlOptions);\n    return HTTPTools.checkAtUrl(url);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private String checkWithOptions(Language lang, Language motherTongue, String text,\n                                  String[] enabledRules, String[] disabledRules, boolean useEnabledOnly) throws IOException {\n    return checkWithOptions(\"/\", lang, motherTongue, text, enabledRules, disabledRules, useEnabledOnly);\n  }","id":41533,"modified_method":"private String checkWithOptions(Language lang, Language motherTongue, String text,\n                                  String[] enabledRules, String[] disabledRules, boolean useEnabledOnly) throws IOException {\n    String urlOptions = \"/?language=\" + lang.getShortName();\n    urlOptions += \"&text=\" + URLEncoder.encode(text, \"UTF-8\"); // latin1 is not enough for languages like polish, romanian, etc\n    if (motherTongue != null) {\n      urlOptions += \"&motherTongue=\" + motherTongue.getShortName();\n    }\n    if (disabledRules.length > 0) {\n      urlOptions += \"&disabled=\" + StringUtils.join(disabledRules, \",\");\n    }\n    if (enabledRules.length > 0) {\n      urlOptions += \"&enabled=\" + StringUtils.join(enabledRules, \",\");\n    }\n    if (useEnabledOnly) {\n      urlOptions += \"&enabledOnly=yes\";\n    }\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + urlOptions);\n    return HTTPTools.checkAtUrl(url);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private String checkWithOptionsV2(Language lang, Language motherTongue, String text,\n                                  String[] enabledRules, String[] disabledRules, boolean useEnabledOnly) throws IOException {\n    return checkWithOptions(\"/v2/check\", lang, motherTongue, text, enabledRules, disabledRules, useEnabledOnly);\n  }","id":41534,"modified_method":"private String checkWithOptionsV2(Language lang, Language motherTongue, String text,\n                                  String[] enabledRules, String[] disabledRules, boolean useEnabledOnly) throws IOException {\n    String urlOptions = \"/v2/check?language=\" + lang.getShortName();\n    urlOptions += \"&text=\" + URLEncoder.encode(text, \"UTF-8\"); // latin1 is not enough for languages like polish, romanian, etc\n    if (motherTongue != null) {\n      urlOptions += \"&motherTongue=\" + motherTongue.getShortName();\n    }\n    if (disabledRules.length > 0) {\n      urlOptions += \"&disabledRules=\" + StringUtils.join(disabledRules, \",\");\n    }\n    if (enabledRules.length > 0) {\n      urlOptions += \"&enabledRules=\" + StringUtils.join(enabledRules, \",\");\n    }\n    if (useEnabledOnly) {\n      urlOptions += \"&enabledOnly=yes\";\n    }\n    URL url = new URL(\"http://localhost:\" + HTTPTools.getDefaultPort() + urlOptions);\n    return HTTPTools.checkAtUrl(url);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"protected String checkV1(Language lang, Language motherTongue, String text) throws IOException {\n    return check(\"/\", lang, motherTongue, text);\n  }","id":41535,"modified_method":"protected String checkV1(Language lang, Language motherTongue, String text) throws IOException {\n    return check(\"/\", lang, motherTongue, text, \"\");\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testTimeout() throws Exception {\n    HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort(), false);\n    config.setMaxCheckTimeMillis(1);\n    HTTPServer server = new HTTPServer(config, false);\n    try {\n      server.run();\n      try {\n        System.out.println(\"=== Testing timeout now, please ignore the following exception ===\");\n        checkV1(new GermanyGerman(), \"Einq Tesz miit fieln Fehlan, desshalb sehee laagnsam bee dr Rechtschriebprfung\");\n        fail(\"Check was expected to be stopped because it took too long\");\n      } catch (IOException expected) {\n        if (!expected.toString().contains(\" 503 \")) {\n          fail(\"Expected exception with error 503, got: \" + expected);\n        }\n      }\n      try {\n        System.out.println(\"=== Testing timeout now, please ignore the following exception ===\");\n        checkV2(new GermanyGerman(), \"Einq Tesz miit fieln Fehlan, desshalb sehee laagnsam bee dr Rechtschriebprfung\");\n        fail(\"Check was expected to be stopped because it took too long\");\n      } catch (IOException expected) {\n        if (!expected.toString().contains(\" 503 \")) {\n          fail(\"Expected exception with error 503, got: \" + expected);\n        }\n      }\n    } finally {\n      server.stop();\n    }\n  }","id":41536,"modified_method":"@Test\n  public void testTimeout() throws Exception {\n    HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort(), false);\n    config.setMaxCheckTimeMillis(1);\n    HTTPServer server = new HTTPServer(config, false);\n    try {\n      server.run();\n      try {\n        System.out.println(\"=== Testing timeout now, please ignore the following exception ===\");\n        checkV2(new GermanyGerman(), \"Einq Tesz miit fieln Fehlan, desshalb sehee laagnsam bee dr Rechtschriebprfung\");\n        fail(\"Check was expected to be stopped because it took too long\");\n      } catch (IOException expected) {\n        if (!expected.toString().contains(\" 503 \")) {\n          fail(\"Expected exception with error 503, got: \" + expected);\n        }\n      }\n    } finally {\n      server.stop();\n    }\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"Language detectLanguageOfString(String text, String fallbackLanguage, List<String> preferredVariants) {\n    Language lang = identifier.detectLanguage(text);\n    if (lang == null) {\n      lang = Languages.getLanguageForShortName(fallbackLanguage != null ? fallbackLanguage : \"en\");\n    }\n    if (preferredVariants.size() > 0) {\n      for (String preferredVariant : preferredVariants) {\n        if (!preferredVariant.contains(\"-\")) {\n          throw new IllegalArgumentException(\"Invalid format for 'preferredvariant', expected a dash as in 'en-GB': '\" + preferredVariant + \"'\");\n        }\n        String preferredVariantLang = preferredVariant.split(\"-\")[0];\n        if (preferredVariantLang.equals(lang.getShortName())) {\n          lang = Languages.getLanguageForShortName(preferredVariant);\n          if (lang == null) {\n            throw new IllegalArgumentException(\"Invalid 'prefereredvariant', no such language/variant found: '\" + preferredVariant + \"'\");\n          }\n        }\n      }\n    } else {\n      if (lang.getDefaultLanguageVariant() != null) {\n        lang = lang.getDefaultLanguageVariant();\n      }\n    }\n    return lang;\n  }","id":41537,"modified_method":"Language detectLanguageOfString(String text, String fallbackLanguage, List<String> preferredVariants) {\n    Language lang = identifier.detectLanguage(text);\n    if (lang == null) {\n      lang = Languages.getLanguageForShortName(fallbackLanguage != null ? fallbackLanguage : \"en\");\n    }\n    if (preferredVariants.size() > 0) {\n      for (String preferredVariant : preferredVariants) {\n        if (!preferredVariant.contains(\"-\")) {\n          throw new IllegalArgumentException(\"Invalid format for 'preferredVariants', expected a dash as in 'en-GB': '\" + preferredVariant + \"'\");\n        }\n        String preferredVariantLang = preferredVariant.split(\"-\")[0];\n        if (preferredVariantLang.equals(lang.getShortName())) {\n          lang = Languages.getLanguageForShortName(preferredVariant);\n          if (lang == null) {\n            throw new IllegalArgumentException(\"Invalid 'preferredVariants', no such language/variant found: '\" + preferredVariant + \"'\");\n          }\n        }\n      }\n    } else {\n      if (lang.getDefaultLanguageVariant() != null) {\n        lang = lang.getDefaultLanguageVariant();\n      }\n    }\n    return lang;\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"void checkText(String text, HttpExchange httpExchange, Map<String, String> parameters, int handleCount) throws Exception {\n    long timeStart = System.currentTimeMillis();\n    if (text.length() > config.maxTextLength) {\n      throw new TextTooLongException(\"Your text exceeds this server's limit of \" + config.maxTextLength +\n              \" characters (it's \" + text.length() + \" characters). Please submit a shorter text.\");\n    }\n    //print(\"Check start: \" + text.length() + \" chars, \" + langParam);\n    boolean autoDetectLanguage = getLanguageAutoDetect(parameters);\n    List<String> preferredVariants;\n    if (parameters.get(\"preferredvariants\") != null) {\n      preferredVariants = Arrays.asList(parameters.get(\"preferredvariants\").split(\",\\\\s*\"));\n      if (!autoDetectLanguage) {\n        throw new IllegalArgumentException(\"You specified 'preferredvariants' but you didn't specify 'autodetect=yes'\");\n      }\n    } else {\n      preferredVariants = Collections.emptyList();\n    }\n    Language lang = getLanguage(text, parameters.get(\"language\"), autoDetectLanguage, preferredVariants);\n    String motherTongueParam = parameters.get(\"motherTongue\");\n    Language motherTongue = motherTongueParam != null ? Languages.getLanguageForShortName(motherTongueParam) : null;\n    boolean useEnabledOnly = \"yes\".equals(parameters.get(\"enabledOnly\"));\n    String enabledParam = parameters.get(\"enabled\");\n    List<String> enabledRules = new ArrayList<>();\n    if (enabledParam != null) {\n      enabledRules.addAll(Arrays.asList(enabledParam.split(\",\")));\n    }\n\n    List<String> disabledRules = getCommaSeparatedStrings(\"disabled\", parameters);\n    List<CategoryId> enabledCategories = getCategoryIds(\"enabledCategories\", parameters);\n    List<CategoryId> disabledCategories = getCategoryIds(\"disabledCategories\", parameters);\n\n    if ((disabledRules.size() > 0 || disabledCategories.size() > 0) && useEnabledOnly) {\n      throw new IllegalArgumentException(\"You cannot specify disabled rules or categories using enabledOnly=yes\");\n    }\n\n    boolean useQuerySettings = enabledRules.size() > 0 || disabledRules.size() > 0 ||\n            enabledCategories.size() > 0 || disabledCategories.size() > 0;\n    QueryParams params = new QueryParams(enabledRules, disabledRules, enabledCategories, disabledCategories, useEnabledOnly, useQuerySettings);\n\n    Future<List<RuleMatch>> future = executorService.submit(new Callable<List<RuleMatch>>() {\n      @Override\n      public List<RuleMatch> call() throws Exception {\n        // use to fake OOM in thread for testing:\n        /*if (Math.random() < 0.1) {\n          throw new OutOfMemoryError();\n        }*/\n        return getRuleMatches(text, parameters, lang, motherTongue, params);\n      }\n    });\n    List<RuleMatch> matches;\n    if (config.maxCheckTimeMillis < 0) {\n      matches = future.get();\n    } else {\n      try {\n        matches = future.get(config.maxCheckTimeMillis, TimeUnit.MILLISECONDS);\n      } catch (ExecutionException e) {\n        if (e.getCause() != null && e.getCause() instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError)e.getCause();\n        } else {\n          throw e;\n        }\n      } catch (TimeoutException e) {\n        boolean cancelled = future.cancel(true);\n        throw new RuntimeException(\"Text checking took longer than allowed maximum of \" + config.maxCheckTimeMillis +\n                \" milliseconds (cancelled: \" + cancelled + \", handleCount: \" + handleCount +\n                \", language: \" + lang.getShortNameWithCountryAndVariant() +\n                \", \" + text.length() + \" characters of text)\", e);\n      }\n    }\n\n    setCommonHeaders(httpExchange, XML_CONTENT_TYPE, config.allowOriginUrl);\n    String xmlResponse = getResponse(text, lang, motherTongue, matches);\n    String messageSent = \"sent\";\n    String languageMessage = lang.getShortNameWithCountryAndVariant();\n    String referrer = httpExchange.getRequestHeaders().getFirst(\"Referer\");\n    try {\n      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, xmlResponse.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));\n    } catch (IOException exception) {\n      // the client is disconnected\n      messageSent = \"notSent: \" + exception.getMessage();\n    }\n    if (motherTongue != null) {\n      languageMessage += \" (mother tongue: \" + motherTongue.getShortNameWithCountryAndVariant() + \")\";\n    }\n    if (autoDetectLanguage) {\n      languageMessage += \"[auto]\";\n    }\n    String agent = parameters.get(\"useragent\") != null ? parameters.get(\"useragent\") : \"-\";\n    print(\"Check done: \" + text.length() + \" chars, \" + languageMessage + \", \" + referrer + \", \"\n            + \"handlers:\" + handleCount + \", \" + matches.size() + \" matches, \"\n            + (System.currentTimeMillis() - timeStart) + \"ms, agent:\" + agent\n            + \", \" + messageSent);\n  }","id":41538,"modified_method":"void checkText(String text, HttpExchange httpExchange, Map<String, String> parameters, int handleCount) throws Exception {\n    long timeStart = System.currentTimeMillis();\n    if (text.length() > config.maxTextLength) {\n      throw new TextTooLongException(\"Your text exceeds this server's limit of \" + config.maxTextLength +\n              \" characters (it's \" + text.length() + \" characters). Please submit a shorter text.\");\n    }\n    //print(\"Check start: \" + text.length() + \" chars, \" + langParam);\n    boolean autoDetectLanguage = getLanguageAutoDetect(parameters);\n    List<String> preferredVariants = getPreferredVariants(parameters);\n    Language lang = getLanguage(text, parameters, preferredVariants);\n    String motherTongueParam = parameters.get(\"motherTongue\");\n    Language motherTongue = motherTongueParam != null ? Languages.getLanguageForShortName(motherTongueParam) : null;\n    boolean useEnabledOnly = \"yes\".equals(parameters.get(\"enabledOnly\")) || \"true\".equals(parameters.get(\"enabledOnly\"));\n    List<String> enabledRules = getEnabledRuleIds(parameters);\n\n    List<String> disabledRules = getDisabledRuleIds(parameters);\n    List<CategoryId> enabledCategories = getCategoryIds(\"enabledCategories\", parameters);\n    List<CategoryId> disabledCategories = getCategoryIds(\"disabledCategories\", parameters);\n\n    if ((disabledRules.size() > 0 || disabledCategories.size() > 0) && useEnabledOnly) {\n      throw new IllegalArgumentException(\"You cannot specify disabled rules or categories using enabledOnly=yes\");\n    }\n\n    boolean useQuerySettings = enabledRules.size() > 0 || disabledRules.size() > 0 ||\n            enabledCategories.size() > 0 || disabledCategories.size() > 0;\n    QueryParams params = new QueryParams(enabledRules, disabledRules, enabledCategories, disabledCategories, useEnabledOnly, useQuerySettings);\n\n    Future<List<RuleMatch>> future = executorService.submit(new Callable<List<RuleMatch>>() {\n      @Override\n      public List<RuleMatch> call() throws Exception {\n        // use to fake OOM in thread for testing:\n        /*if (Math.random() < 0.1) {\n          throw new OutOfMemoryError();\n        }*/\n        return getRuleMatches(text, parameters, lang, motherTongue, params);\n      }\n    });\n    List<RuleMatch> matches;\n    if (config.maxCheckTimeMillis < 0) {\n      matches = future.get();\n    } else {\n      try {\n        matches = future.get(config.maxCheckTimeMillis, TimeUnit.MILLISECONDS);\n      } catch (ExecutionException e) {\n        if (e.getCause() != null && e.getCause() instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError)e.getCause();\n        } else {\n          throw e;\n        }\n      } catch (TimeoutException e) {\n        boolean cancelled = future.cancel(true);\n        throw new RuntimeException(\"Text checking took longer than allowed maximum of \" + config.maxCheckTimeMillis +\n                \" milliseconds (cancelled: \" + cancelled + \", handleCount: \" + handleCount +\n                \", language: \" + lang.getShortNameWithCountryAndVariant() +\n                \", \" + text.length() + \" characters of text)\", e);\n      }\n    }\n\n    setHeaders(httpExchange);\n    String xmlResponse = getResponse(text, lang, motherTongue, matches);\n    String messageSent = \"sent\";\n    String languageMessage = lang.getShortNameWithCountryAndVariant();\n    String referrer = httpExchange.getRequestHeaders().getFirst(\"Referer\");\n    try {\n      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, xmlResponse.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));\n    } catch (IOException exception) {\n      // the client is disconnected\n      messageSent = \"notSent: \" + exception.getMessage();\n    }\n    if (motherTongue != null) {\n      languageMessage += \" (mother tongue: \" + motherTongue.getShortNameWithCountryAndVariant() + \")\";\n    }\n    if (autoDetectLanguage) {\n      languageMessage += \"[auto]\";\n    }\n    String agent = parameters.get(\"useragent\") != null ? parameters.get(\"useragent\") : \"-\";\n    print(\"Check done: \" + text.length() + \" chars, \" + languageMessage + \", \" + referrer + \", \"\n            + \"handlers:\" + handleCount + \", \" + matches.size() + \" matches, \"\n            + (System.currentTimeMillis() - timeStart) + \"ms, agent:\" + agent\n            + \", \" + messageSent);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@NotNull\n  private List<String> getCommaSeparatedStrings(String paramName, Map<String, String> parameters) {\n    String disabledParam = parameters.get(paramName);\n    List<String> result = new ArrayList<>();\n    if (disabledParam != null) {\n      result.addAll(Arrays.asList(disabledParam.split(\",\")));\n    }\n    return result;\n  }","id":41539,"modified_method":"@NotNull\n  protected List<String> getCommaSeparatedStrings(String paramName, Map<String, String> parameters) {\n    String disabledParam = parameters.get(paramName);\n    List<String> result = new ArrayList<>();\n    if (disabledParam != null) {\n      result.addAll(Arrays.asList(disabledParam.split(\",\")));\n    }\n    return result;\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private Language getLanguage(String text, String langParam, boolean autoDetect, List<String> preferredVariants) {\n    Language lang;\n    if (autoDetect) {\n      lang = detectLanguageOfString(text, langParam, preferredVariants);\n    } else {\n      if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {\n        lang = config.getAfterTheDeadlineLanguage();\n      } else {\n        lang = Languages.getLanguageForShortName(langParam);\n      }\n    }\n    return lang;\n  }","id":41540,"modified_method":"protected abstract Language getLanguage(String text, Map<String, String> parameters, List<String> preferredVariants);","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private boolean getLanguageAutoDetect(Map<String, String> parameters) {\n    if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {\n      return \"true\".equals(parameters.get(\"guess\"));\n    } else {\n      boolean autoDetect = \"1\".equals(parameters.get(\"autodetect\")) || \"yes\".equals(parameters.get(\"autodetect\"));\n      if (parameters.get(\"language\") == null && !autoDetect) {\n        throw new IllegalArgumentException(\"Missing 'language' parameter. Specify language or use 'autodetect=yes' for auto-detecting the language of the input text.\");\n      }\n      return autoDetect;\n    }\n  }","id":41541,"modified_method":"protected abstract boolean getLanguageAutoDetect(Map<String, String> parameters);","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"V1TextChecker(HTTPServerConfig config, boolean internalServer) {\n    super(config, internalServer);\n    this.config = config;\n  }","id":41542,"modified_method":"V1TextChecker(HTTPServerConfig config, boolean internalServer) {\n    super(config, internalServer);\n  }","commit_id":"fa08763624fb1868e9861b0319486e5f3d974d8d","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void run() throws IOException, InterruptedException {\n\n    System.out.println(\"Commits per language in the last \" + PAST_DAYS + \" days\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()));\n    \n    final List<String> sortedLanguages = new ArrayList<>();\n    for (Language element : Language.REAL_LANGUAGES) {\n      sortedLanguages.add(element.getName());\n    }\n    Collections.sort(sortedLanguages);\n\n    final Calendar today = GregorianCalendar.getInstance();\n    final Calendar past = GregorianCalendar.getInstance();\n    past.add(Calendar.DAY_OF_MONTH, -PAST_DAYS);\n    \n    final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    final String todayString = dateFormat.format(today.getTime());\n    final String pastString = dateFormat.format(past.getTime());\n    \n    final Runtime runtime = Runtime.getRuntime();\n    for (final String langName : sortedLanguages) {\n      final Language lang = Language.getLanguageForName(langName);\n      final File xmlFile = new File(\".\", JLanguageTool.getDataBroker().getRulesDir() + File.separator + lang.getShortName() + File.separator + \"grammar.xml\");\n      final String command = \"svn log -q -r {\" + pastString + \"}:{\" + todayString + \"} src/\" + xmlFile;\n      final Process process = runtime.exec(command);\n      final InputStream inputStream = process.getInputStream();\n      final String output = StringTools.readStream(inputStream, \"utf-8\");\n      process.waitFor();\n      final int commits = getCommits(output);\n      System.out.println(commits + \"\\t\" + langName);\n    }\n  }","id":41543,"modified_method":"private void run() throws IOException, InterruptedException {\n\n    System.out.println(\"Commits per language in the last \" + PAST_DAYS + \" days\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()));\n    \n    final List<String> sortedLanguages = new ArrayList<>();\n    for (Language element : Language.REAL_LANGUAGES) {\n      sortedLanguages.add(element.getName());\n    }\n    Collections.sort(sortedLanguages);\n\n    final Calendar past = GregorianCalendar.getInstance();\n    past.add(Calendar.DAY_OF_MONTH, -PAST_DAYS);\n    \n    final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    final String pastString = dateFormat.format(past.getTime());\n    \n    final Runtime runtime = Runtime.getRuntime();\n    for (final String langName : sortedLanguages) {\n      final Language lang = Language.getLanguageForName(langName);\n      String langCode = lang.getShortName();\n      List<String> ruleFileNames = lang.getRuleFileNames();\n      int commits = 0;\n      for (String ruleFileName : ruleFileNames) {\n        final File xmlFile = new File(\"languagetool-language-modules/\" + langCode\n                + \"/src/main/resources/\" + ruleFileName);\n        final String command = \"git log --after=\" + pastString + \" \" + xmlFile;\n        final Process process = runtime.exec(command);\n        final InputStream inputStream = process.getInputStream();\n        final String output = StringTools.readStream(inputStream, \"utf-8\");\n        process.waitFor();\n        commits += getCommits(output);\n      }\n      System.out.println(commits + \"\\t\" + langName + (lang.isVariant() ? \" (including the parent language)\" : \"\"));\n    }\n  }","commit_id":"05bb803773c4b35f0b178c2f6844f197fe099675","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private int getCommits(String svnOutput) {\n    int count = 0;\n    try (Scanner scanner = new Scanner(svnOutput)) {\n      while (scanner.hasNextLine()) {\n        final String line = scanner.nextLine();\n        if (line.matches(\"^r\\\\d+.*\")) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }","id":41544,"modified_method":"private int getCommits(String svnOutput) {\n    int count = 0;\n    try (Scanner scanner = new Scanner(svnOutput)) {\n      while (scanner.hasNextLine()) {\n        final String line = scanner.nextLine();\n        if (line.startsWith(\"commit \")) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }","commit_id":"05bb803773c4b35f0b178c2f6844f197fe099675","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void run(File webRoot) throws IOException {\n    System.out.println(\"<b>Rules in LanguageTool \" + JLanguageTool.VERSION + \"<\/b><br />\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()) + \"<br /><br />\\n\");\n    System.out.println(\"<table class=\\\"tablesorter sortable\\\">\");\n    System.out.println(\"<thead>\");\n    System.out.println(\"<tr>\");\n    System.out.println(\"  <th valign='bottom' width=\\\"70\\\">Language<\/th>\");\n    System.out.println(\"  <th valign='bottom' align=\\\"left\\\" width=\\\"60\\\">XML<br/>rules<\/th>\");\n    System.out.println(\"  <th><\/th>\");\n    System.out.println(\"  <th align=\\\"left\\\" width=\\\"60\\\">Java<br/>rules<\/th>\");\n    System.out.println(\"  <th align=\\\"left\\\" width=\\\"60\\\">False<br/>friends<\/th>\");\n    System.out.println(\"  <th valign='bottom' width=\\\"65\\\">Auto-<br/>detected<\/th>\");\n    System.out.println(\"  <th valign='bottom' align=\\\"left\\\">Rule Maintainers<\/th>\");\n    System.out.println(\"<\/tr>\");\n    System.out.println(\"<\/thead>\");\n    System.out.println(\"<tbody>\");\n    final List<String> sortedLanguages = getSortedLanguages();\n\n    //setup false friends counting\n    final String falseFriendFile = JLanguageTool.getDataBroker().getRulesDir() + File.separator + \"false-friends.xml\";\n    final URL falseFriendUrl = this.getClass().getResource(falseFriendFile);\n    final String falseFriendRules = StringTools.readFile(Tools.getStream(falseFriendFile))\n      .replaceAll(\"(?s)<!--.*?-->\", \"\")\n      .replaceAll(\"(?s)<rules.*?>\", \"\");\n\n    int overallJavaCount = 0;\n    int langSpecificWebsiteCount = 0;\n    for (final String langName : sortedLanguages) {\n      final Language lang = Language.getLanguageForName(langName);\n      System.out.print(\"<tr>\");\n      final File langSpecificWebsite = new File(webRoot, lang.getShortName());\n      if (langSpecificWebsite.isDirectory()) {\n        System.out.print(\"<td valign=\\\"top\\\"><a href=\\\"../\" + lang.getShortName() + \"/\\\">\" + lang.getName() + \"<\/a><\/td>\");\n        langSpecificWebsiteCount++;\n      } else {\n        System.out.print(\"<td valign=\\\"top\\\">\" + lang.getName() + \"<\/td>\");\n      }\n      final String xmlFile = JLanguageTool.getDataBroker().getRulesDir() + File.separator + lang.getShortName() + File.separator + \"grammar.xml\";\n      final URL url = this.getClass().getResource(xmlFile);    \n      if (url == null) {\n        System.out.println(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        // count XML rules:\n        String xmlRules = StringTools.readFile(Tools.getStream(xmlFile));\n        xmlRules = xmlRules.replaceAll(\"(?s)<!--.*?-->\", \"\");\n        xmlRules = xmlRules.replaceAll(\"(?s)<rules.*?>\", \"\");\n        final int count = countXmlRules(xmlRules);\n        final int countInRuleGroup = countXmlRuleGroupRules(xmlRules);\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + (count + countInRuleGroup) + \"<\/td>\");\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" +\n            \"<a href=\\\"http://languagetool.svn.sourceforge.net/viewvc/languagetool/trunk/JLanguageTool/src/rules/\" + lang.getShortName() + \"/grammar.xml?content-type=text%2Fplain\" +\n            \"\\\">show<\/a>/\" +\n            \"<a href=\\\"http://community.languagetool.org/rule/list?lang=\" +\n            lang.getShortName() + \"\\\">browse<\/a>\" +\n            \"<\/td>\");\n      }\n\n      // count Java rules:\n      final File dir = new File(\"src/java/org/languagetool\" + \n              JLanguageTool.getDataBroker().getRulesDir() + \"/\" + lang.getShortName());\n      if (!dir.exists()) {\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        final File[] javaRules = dir.listFiles(new JavaFilter());\n        final int javaCount = javaRules.length - 1;   // minus 1: one is always \"<Language>Rule.java\"\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + javaCount + \"<\/td>\");\n        overallJavaCount++;\n      }\n\n      // false friends\n      if (falseFriendUrl == null) {\n        System.out.println(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        final int count = countFalseFriendRules(falseFriendRules, lang);\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + count + \"<\/td>\");\n\n        System.out.print(\"<td valign=\\\"top\\\">\" + (isAutoDetected(lang.getShortName()) ? \"yes\" : \"-\") + \"<\/td>\");\n        \n        // maintainer information:\n        final StringBuilder maintainerInfo = getMaintainerInfo(lang);\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"left\\\">\" + maintainerInfo.toString() + \"<\/td>\");\n      }\n      \n      System.out.println(\"<\/tr>\");    \n    }\n      \n    if (overallJavaCount == 0) {\n      throw new RuntimeException(\"No Java rules found - start this script from the LanguageTool directory so \" +\n              \"that the sources are at 'src/java/org/languagetool'\");\n    }\n    if (langSpecificWebsiteCount == 0) {\n      throw new RuntimeException(\"No language specific websites found - please let the web root parameter \" +\n              \"point to the 'www' directory (current value: '\" + webRoot + \"')\");\n    }\n\n    System.out.println(\"<\/tbody>\");\n    System.out.println(\"<\/table>\");\n  }","id":41545,"modified_method":"private void run(File webRoot) throws IOException {\n    System.out.println(\"<b>Rules in LanguageTool \" + JLanguageTool.VERSION + \"<\/b><br />\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()) + \"<br /><br />\\n\");\n    System.out.println(\"<table class=\\\"tablesorter sortable\\\">\");\n    System.out.println(\"<thead>\");\n    System.out.println(\"<tr>\");\n    System.out.println(\"  <th valign='bottom' width=\\\"70\\\">Language<\/th>\");\n    System.out.println(\"  <th valign='bottom' align=\\\"left\\\" width=\\\"60\\\">XML<br/>rules<\/th>\");\n    System.out.println(\"  <th width=\\\"120\\\"><\/th>\");\n    System.out.println(\"  <th align=\\\"left\\\" width=\\\"60\\\">Java<br/>rules<\/th>\");\n    System.out.println(\"  <th align=\\\"left\\\" width=\\\"60\\\">False<br/>friends<\/th>\");\n    System.out.println(\"  <th valign='bottom' width=\\\"65\\\">Auto-<br/>detected<\/th>\");\n    System.out.println(\"  <th valign='bottom' align=\\\"left\\\">Rule Maintainers<\/th>\");\n    System.out.println(\"<\/tr>\");\n    System.out.println(\"<\/thead>\");\n    System.out.println(\"<tbody>\");\n    final List<String> sortedLanguages = getSortedLanguages();\n\n    //setup false friends counting\n    final String falseFriendFile = JLanguageTool.getDataBroker().getRulesDir() + File.separator + \"false-friends.xml\";\n    final URL falseFriendUrl = this.getClass().getResource(falseFriendFile);\n    final String falseFriendRules = StringTools.readFile(Tools.getStream(falseFriendFile))\n      .replaceAll(\"(?s)<!--.*?-->\", \"\")\n      .replaceAll(\"(?s)<rules.*?>\", \"\");\n\n    int overallJavaCount = 0;\n    int langSpecificWebsiteCount = 0;\n    for (final String langName : sortedLanguages) {\n      final Language lang = Language.getLanguageForName(langName);\n      System.out.print(\"<tr>\");\n      final File langSpecificWebsite = new File(webRoot, lang.getShortName());\n      if (langSpecificWebsite.isDirectory()) {\n        System.out.print(\"<td valign=\\\"top\\\"><a href=\\\"../\" + lang.getShortName() + \"/\\\">\" + lang.getName() + \"<\/a><\/td>\");\n        langSpecificWebsiteCount++;\n      } else {\n        System.out.print(\"<td valign=\\\"top\\\">\" + lang.getName() + \"<\/td>\");\n      }\n      final String xmlFile = JLanguageTool.getDataBroker().getRulesDir() + File.separator + lang.getShortName() + File.separator + \"grammar.xml\";\n      final URL url = this.getClass().getResource(xmlFile);    \n      if (url == null) {\n        System.out.println(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        // count XML rules:\n        String xmlRules = StringTools.readFile(Tools.getStream(xmlFile));\n        xmlRules = xmlRules.replaceAll(\"(?s)<!--.*?-->\", \"\");\n        xmlRules = xmlRules.replaceAll(\"(?s)<rules.*?>\", \"\");\n        final int count = countXmlRules(xmlRules);\n        final int countInRuleGroup = countXmlRuleGroupRules(xmlRules);\n        final String ruleBase = \"http://languagetool.svn.sourceforge.net/viewvc/languagetool/trunk/JLanguageTool/src/rules/\";\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + (count + countInRuleGroup) + \"<\/td>\");\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" +\n            \"<a href=\\\"\" + ruleBase + lang.getShortName() + \"/grammar.xml\" + \"\\\">Show<\/a> / \" +\n            \"<a href=\\\"\" + ruleBase + lang.getShortName() + \"/grammar.xml?content-type=text%2Fplain\" + \"\\\">XML<\/a> / \" +\n            \"<a href=\\\"http://community.languagetool.org/rule/list?lang=\" + lang.getShortName() + \"\\\">Browse<\/a>\" +\n            \"<\/td>\");\n      }\n\n      // count Java rules:\n      final File dir = new File(\"src/java/org/languagetool\" + \n              JLanguageTool.getDataBroker().getRulesDir() + \"/\" + lang.getShortName());\n      if (!dir.exists()) {\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        final File[] javaRules = dir.listFiles(new JavaFilter());\n        final int javaCount = javaRules.length - 1;   // minus 1: one is always \"<Language>Rule.java\"\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + javaCount + \"<\/td>\");\n        overallJavaCount++;\n      }\n\n      // false friends\n      if (falseFriendUrl == null) {\n        System.out.println(\"<td valign=\\\"top\\\" align=\\\"right\\\">0<\/td>\");\n      } else {\n        final int count = countFalseFriendRules(falseFriendRules, lang);\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"right\\\">\" + count + \"<\/td>\");\n\n        System.out.print(\"<td valign=\\\"top\\\">\" + (isAutoDetected(lang.getShortName()) ? \"yes\" : \"-\") + \"<\/td>\");\n        \n        // maintainer information:\n        final StringBuilder maintainerInfo = getMaintainerInfo(lang);\n        System.out.print(\"<td valign=\\\"top\\\" align=\\\"left\\\">\" + maintainerInfo.toString() + \"<\/td>\");\n      }\n      \n      System.out.println(\"<\/tr>\");    \n    }\n      \n    if (overallJavaCount == 0) {\n      throw new RuntimeException(\"No Java rules found - start this script from the LanguageTool directory so \" +\n              \"that the sources are at 'src/java/org/languagetool'\");\n    }\n    if (langSpecificWebsiteCount == 0) {\n      throw new RuntimeException(\"No language specific websites found - please let the web root parameter \" +\n              \"point to the 'www' directory (current value: '\" + webRoot + \"')\");\n    }\n\n    System.out.println(\"<\/tbody>\");\n    System.out.println(\"<\/table>\");\n  }","commit_id":"79c140512d3419b9c44ac4d8ee097bfab0991d61","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setContents(List<String> contents)\n   {\n      if (!equal(this.contents, contents))\n      {\n         this.contents = contents;\n         updateWordCount();\n         updateContentHash();\n      }\n   }","id":41546,"modified_method":"public void setContents(List<String> contents)\n   {\n      if (!equal(this.contents, contents))\n      {\n         this.contents = new ArrayList<String>(contents);\n         updateWordCount();\n         updateContentHash();\n      }\n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setContents(List<String> contents)\n   {\n      this.contents = contents;\n   }","id":41547,"modified_method":"public void setContents(List<String> contents)\n   {\n      this.contents = new ArrayList<String>(contents);\n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HTextFlowHistory(HTextFlow textFlow)\n   {\n      this.revision = textFlow.getRevision();\n      this.contents = new ArrayList<String>(textFlow.getContents());\n      this.textFlow = textFlow;\n   }","id":41548,"modified_method":"public HTextFlowHistory(HTextFlow textFlow)\n   {\n      this.revision = textFlow.getRevision();\n      this.textFlow = textFlow;\n      this.setContents(textFlow.getContents());\n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setContents(List<String> contents)\n   {\n      this.contents = contents;\n   }","id":41549,"modified_method":"public void setContents(List<String> contents)\n   {\n      this.contents = new ArrayList<String>(contents);\n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setContents(List<String> contents)\n   {\n      this.contents = contents;\n   }","id":41550,"modified_method":"public void setContents(List<String> contents)\n   {\n      this.contents = new ArrayList<String>(contents);\n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HTextFlowTargetHistory(HTextFlowTarget target)\n   {\n      this.contents = new ArrayList<String>(target.getContents()); \n      this.lastChanged = target.getLastChanged();\n      this.lastModifiedBy = target.getLastModifiedBy();\n      this.state = target.getState();\n      this.textFlowRevision = target.getTextFlowRevision();\n      this.textFlowTarget = target;\n      this.versionNum = target.getVersionNum();\n   }","id":41551,"modified_method":"public HTextFlowTargetHistory(HTextFlowTarget target)\n   {\n      this.lastChanged = target.getLastChanged();\n      this.lastModifiedBy = target.getLastModifiedBy();\n      this.state = target.getState();\n      this.textFlowRevision = target.getTextFlowRevision();\n      this.textFlowTarget = target;\n      this.versionNum = target.getVersionNum();\n      this.setContents(target.getContents()); \n   }","commit_id":"26be2ddc622a0e87da23fb7f4f3235a2ada3e360","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Returns the appropriate locale for the given destination.<p>\n     * \n     * @param destination the destination path (parent must exist)\n     * @param properties the properties to check at first\n     * @return the locale\n     * @throws CmsException if something goes wrong\n     */\n    protected Locale getLocale(String destination, List properties) throws CmsException {        \n        String localeName = CmsProperty.get(I_CmsConstants.C_PROPERTY_LOCALE, properties).getValue();\n        if (localeName == null) {\n            localeName = m_cms.readPropertyObject(CmsResource.getParentFolder(destination), I_CmsConstants.C_PROPERTY_LOCALE, true).getValue();\n        }\n        if (localeName != null) {\n            if (localeName.indexOf(\",\") >= 0) {\n                localeName = localeName.substring(0, localeName.indexOf(\",\"));\n            }\n            return CmsLocaleManager.getLocale(localeName);\n        } else {            \n            return (Locale)OpenCms.getLocaleManager().getDefaultLocales(m_cms, CmsResource.getParentFolder(destination)).get(0);\n        }\n    }","id":41552,"modified_method":"/**\n     * Returns the appropriate locale for the given destination.<p>\n     * \n     * @param destination the destination path (parent must exist)\n     * @param properties the properties to check at first\n     * \n     * @return the locale\n     */\n    protected Locale getLocale(String destination, List properties) {        \n        String localeName = CmsProperty.get(I_CmsConstants.C_PROPERTY_LOCALE, properties).getValue();\n                \n        if (localeName != null) {\n            // locale was already set on the files properties\n            return (Locale)OpenCms.getLocaleManager().getAvailableLocales(localeName).get(0);\n        } \n        // locale not set in properties, read default locales\n        return (Locale)OpenCms.getLocaleManager().getDefaultLocales(m_cms, CmsResource.getParentFolder(destination)).get(0);        \n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initalizes the import.<p>\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected void openImportFile() throws CmsException {\n        // create the digest\n        createDigest();\n\n        // open the import resource\n        getImportResource();\n\n        // read the xml-config file\n        m_docXml = CmsImport.getXmlDocument(getFileBytes(I_CmsConstants.C_EXPORT_XMLFILENAME));\n\n        // try to read the export version number\n        try {\n            m_importVersion = Integer.parseInt(((Element)m_docXml.selectNodes(\"//\" + I_CmsConstants.C_EXPORT_TAG_VERSION).get(0)).getTextTrim());\n        } catch (Exception e) {\n            //ignore the exception, the export file has no version nummber (version 0).\n        }\n    }","id":41553,"modified_method":"/**\n     * Initalizes the import.<p>\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected void openImportFile() throws CmsException {\n        // create the digest\n        createDigest();\n\n        // open the import resource\n        getImportResource();\n\n        // read the xml-config file\n        m_docXml = CmsXmlUtils.unmarshalHelper(getFileBytes(I_CmsConstants.C_EXPORT_XMLFILENAME), null);\n\n        // try to read the export version number\n        try {\n            m_importVersion = Integer.parseInt(((Element)m_docXml.selectNodes(\"//\" + I_CmsConstants.C_EXPORT_TAG_VERSION).get(0)).getTextTrim());\n        } catch (Exception e) {\n            //ignore the exception, the export file has no version nummber (version 0).\n        }\n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Merges a single page.<p>\n     * \n     * @param resourcename the resource name of the page\n     * @throws Exception if something goes wrong\n     */\n    private void mergePageFile(String resourcename) throws Exception {\n        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Start merging \" + resourcename);\n        }\n        \n        // in OpenCms versions <5 node names have not been case sensitive. thus, nodes are read both in upper\n        // and lower case letters, or have to be tested for equality ignoring upper/lower case...\n        \n        // get the header file\n        CmsFile pagefile = m_cms.readFile(resourcename, CmsResourceFilter.IGNORE_EXPIRATION);\n        Document contentXml = CmsImport.getXmlDocument(pagefile.getContents());\n        \n        // get the <masterTemplate> node to check the content. this node contains the name of the template file.\n        String masterTemplateNodeName = \"//masterTemplate\";\n        Node masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName);\n        if (masterTemplateNode == null) {\n            masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName.toLowerCase());\n        }\n        if (masterTemplateNode == null) {\n            masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName.toUpperCase());\n        }        \n        \n        // there is only one <masterTemplate> allowed\n        String mastertemplate = null;    \n        if (masterTemplateNode != null) {\n            // get the name of the mastertemplate\n            mastertemplate = masterTemplateNode.getText().trim();\n        }\n        \n        // get the <ELEMENTDEF> nodes to check the content.\n        // this node contains the information for the body element.\n        String elementDefNodeName = \"//ELEMENTDEF\";\n        Node bodyNode = contentXml.selectSingleNode(elementDefNodeName);\n        if (bodyNode == null) {\n            bodyNode = contentXml.selectSingleNode(elementDefNodeName.toLowerCase());\n        }\n        \n        // there is only one <ELEMENTDEF> allowed\n        if (bodyNode != null) {\n            \n            String bodyclass = null;\n            String bodyname = null;\n            Map bodyparams = null;\n            \n            List nodes = ((Element)bodyNode).elements();            \n            for (int i = 0, n = nodes.size(); i < n; i++) {\n                \n                Node node = (Node) nodes.get(i);\n                \n                if (\"CLASS\".equalsIgnoreCase(node.getName())) {\n                    bodyclass = node.getText().trim();\n                } else if (\"TEMPLATE\".equalsIgnoreCase(node.getName())) {\n                    bodyname = node.getText().trim();\n                    if (!bodyname.startsWith(\"/\")) {\n                        bodyname = CmsResource.getFolderPath(resourcename) + bodyname;\n                    }\n                } else if (\"PARAMETER\".equalsIgnoreCase(node.getName())) {\n                    Element paramElement = (Element)node;\n                    if (bodyparams == null) {\n                        bodyparams = new HashMap();\n                    }\n                    bodyparams.put((paramElement.attribute(\"name\")).getText(), paramElement.getTextTrim());\n                }\n            }\n            \n            if (mastertemplate == null || bodyname == null) {\n                throw new CmsException(\"Could not merge page file '\" + resourcename + \"', mastertemplate=\" + mastertemplate + \", bodyname=\" + bodyname);\n            }\n            \n            // lock the resource, so that it can be manipulated\n            m_cms.lockResource(resourcename);\n            \n            // get all properties                               \n            List properties = m_cms.readPropertyObjects(resourcename, false);\n            \n            // now get the content of the bodyfile and insert it into the control file                   \n            CmsFile bodyfile = m_cms.readFile(bodyname, CmsResourceFilter.IGNORE_EXPIRATION);\n            \n            //get the encoding\n            String encoding = CmsProperty.get(I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, properties).getValue();\n            if (encoding == null) {\n                encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n            }\n                     \n            if (m_convertToXmlPage) {\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Start converting to XML\");\n                }\n                CmsXmlPage xmlPage = CmsXmlPageConverter.convertToXmlPage(m_cms, new String(bodyfile.getContents(), encoding), \"body\", getLocale(resourcename, properties), encoding); \n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"End converting to XML\");\n                }\n                \n                if (xmlPage != null) {\n                    pagefile.setContents(xmlPage.marshal());\n                    \n                    // set the type to xml page\n                    pagefile.setType(CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID);\n                }\n            }\n\n            // add the template and other required properties\n            CmsProperty newProperty = new CmsProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, mastertemplate, null);\n            // property lists must not contain equal properties\n            properties.remove(newProperty);            \n            properties.add(newProperty);\n            \n            // if set, add the bodyclass as property\n            if (bodyclass != null && !\"\".equals(bodyclass)) {\n                newProperty = new CmsProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, mastertemplate, null);\n                newProperty.setAutoCreatePropertyDefinition(true);\n                properties.remove(newProperty);            \n                properties.add(newProperty);\n            }\n            // if set, add bodyparams as properties\n            if (bodyparams != null) {\n                for (Iterator p = bodyparams.keySet().iterator(); p.hasNext();) {\n                    String key = (String)p.next();\n                    newProperty = new CmsProperty(key, (String)bodyparams.get(key), null);\n                    newProperty.setAutoCreatePropertyDefinition(true);\n                    properties.remove(newProperty);            \n                    properties.add(newProperty);\n                }\n            }\n            \n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"Start importing XML page\");\n            }\n            \n            // now import the resource\n            m_cms.importResource(resourcename, pagefile, pagefile.getContents(), properties);\n            \n            // finally delete the old body file, it is not needed anymore\n            m_cms.lockResource(bodyname);\n            m_cms.deleteResource(bodyname, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n            \n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"End importing XML page\");\n            }\n            \n            m_report.println(\" \" + m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK); \n            \n        } else {\n            \n            // there are more than one template nodes in this control file\n            // convert the resource into a plain text file\n            // lock the resource, so that it can be manipulated\n            m_cms.lockResource(resourcename);\n            // set the type to plain\n            pagefile.setType(CmsResourceTypePlain.C_RESOURCE_TYPE_ID);\n            // write all changes                     \n            m_cms.writeFile(pagefile);\n            // done, unlock the resource                   \n            m_cms.unlockResource(resourcename);\n            \n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(\"Cannot convert XML structure of \" + resourcename);\n            }\n            \n            m_report.println(\" \" + m_report.key(\"report.notconverted\"), I_CmsReport.C_FORMAT_OK);\n            \n        }\n        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"End merging \" + resourcename);\n        }\n        \n    }","id":41554,"modified_method":"/**\n     * Merges a single page.<p>\n     * \n     * @param resourcename the resource name of the page\n     * @throws Exception if something goes wrong\n     */\n    private void mergePageFile(String resourcename) throws Exception {\n        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"Start merging \" + resourcename);\n        }\n        \n        // in OpenCms versions <5 node names have not been case sensitive. thus, nodes are read both in upper\n        // and lower case letters, or have to be tested for equality ignoring upper/lower case...\n        \n        // get the header file\n        CmsFile pagefile = m_cms.readFile(resourcename, CmsResourceFilter.ALL);\n        Document contentXml = CmsXmlUtils.unmarshalHelper(pagefile.getContents(), null);\n        \n        // get the <masterTemplate> node to check the content. this node contains the name of the template file.\n        String masterTemplateNodeName = \"//masterTemplate\";\n        Node masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName);\n        if (masterTemplateNode == null) {\n            masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName.toLowerCase());\n        }\n        if (masterTemplateNode == null) {\n            masterTemplateNode = contentXml.selectSingleNode(masterTemplateNodeName.toUpperCase());\n        }        \n        \n        // there is only one <masterTemplate> allowed\n        String mastertemplate = null;    \n        if (masterTemplateNode != null) {\n            // get the name of the mastertemplate\n            mastertemplate = masterTemplateNode.getText().trim();\n        }\n        \n        // get the <ELEMENTDEF> nodes to check the content.\n        // this node contains the information for the body element.\n        String elementDefNodeName = \"//ELEMENTDEF\";\n        Node bodyNode = contentXml.selectSingleNode(elementDefNodeName);\n        if (bodyNode == null) {\n            bodyNode = contentXml.selectSingleNode(elementDefNodeName.toLowerCase());\n        }\n        \n        // there is only one <ELEMENTDEF> allowed\n        if (bodyNode != null) {\n            \n            String bodyclass = null;\n            String bodyname = null;\n            Map bodyparams = null;\n            \n            List nodes = ((Element)bodyNode).elements();            \n            for (int i = 0, n = nodes.size(); i < n; i++) {\n                \n                Node node = (Node) nodes.get(i);\n                \n                if (\"CLASS\".equalsIgnoreCase(node.getName())) {\n                    bodyclass = node.getText().trim();\n                } else if (\"TEMPLATE\".equalsIgnoreCase(node.getName())) {\n                    bodyname = node.getText().trim();\n                    if (!bodyname.startsWith(\"/\")) {\n                        bodyname = CmsResource.getFolderPath(resourcename) + bodyname;\n                    }\n                } else if (\"PARAMETER\".equalsIgnoreCase(node.getName())) {\n                    Element paramElement = (Element)node;\n                    if (bodyparams == null) {\n                        bodyparams = new HashMap();\n                    }\n                    bodyparams.put((paramElement.attribute(\"name\")).getText(), paramElement.getTextTrim());\n                }\n            }\n            \n            if (mastertemplate == null || bodyname == null) {\n                throw new CmsException(\"Could not merge page file '\" + resourcename + \"', mastertemplate=\" + mastertemplate + \", bodyname=\" + bodyname);\n            }\n            \n            // lock the resource, so that it can be manipulated\n            m_cms.lockResource(resourcename);\n            \n            // get all properties                               \n            List properties = m_cms.readPropertyObjects(resourcename, false);\n            \n            // now get the content of the bodyfile and insert it into the control file                   \n            CmsFile bodyfile = m_cms.readFile(bodyname, CmsResourceFilter.IGNORE_EXPIRATION);\n            \n            //get the encoding\n            String encoding = CmsProperty.get(I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, properties).getValue();\n            if (encoding == null) {\n                encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n            }\n                     \n            if (m_convertToXmlPage) {\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Start converting to XML\");\n                }\n                CmsXmlPage xmlPage = \n                    CmsXmlPageConverter.convertToXmlPage(\n                        m_cms, \n                        bodyfile.getContents(),\n                        getLocale(resourcename, properties), \n                        encoding);\n                \n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"End converting to XML\");\n                }\n                \n                if (xmlPage != null) {\n                    pagefile.setContents(xmlPage.marshal());\n                    \n                    // set the type to xml page\n                    pagefile.setType(CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID);\n                }\n            }\n\n            // add the template and other required properties\n            CmsProperty newProperty = new CmsProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, mastertemplate, null);\n            // property lists must not contain equal properties\n            properties.remove(newProperty);            \n            properties.add(newProperty);\n            \n            // if set, add the bodyclass as property\n            if (bodyclass != null && !\"\".equals(bodyclass)) {\n                newProperty = new CmsProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, mastertemplate, null);\n                newProperty.setAutoCreatePropertyDefinition(true);\n                properties.remove(newProperty);            \n                properties.add(newProperty);\n            }\n            // if set, add bodyparams as properties\n            if (bodyparams != null) {\n                for (Iterator p = bodyparams.keySet().iterator(); p.hasNext();) {\n                    String key = (String)p.next();\n                    newProperty = new CmsProperty(key, (String)bodyparams.get(key), null);\n                    newProperty.setAutoCreatePropertyDefinition(true);\n                    properties.remove(newProperty);            \n                    properties.add(newProperty);\n                }\n            }\n            \n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"Start importing XML page\");\n            }\n            \n            // now import the resource\n            m_cms.importResource(resourcename, pagefile, pagefile.getContents(), properties);\n            \n            // finally delete the old body file, it is not needed anymore\n            m_cms.lockResource(bodyname);\n            m_cms.deleteResource(bodyname, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n            \n            if (OpenCms.getLog(this).isDebugEnabled()) {\n                OpenCms.getLog(this).debug(\"End importing XML page\");\n            }\n            \n            m_report.println(\" \" + m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK); \n            \n        } else {\n            \n            // there are more than one template nodes in this control file\n            // convert the resource into a plain text file\n            // lock the resource, so that it can be manipulated\n            m_cms.lockResource(resourcename);\n            // set the type to plain\n            pagefile.setType(CmsResourceTypePlain.C_RESOURCE_TYPE_ID);\n            // write all changes                     \n            m_cms.writeFile(pagefile);\n            // done, unlock the resource                   \n            m_cms.unlockResource(resourcename);\n            \n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(\"Cannot convert XML structure of \" + resourcename);\n            }\n            \n            m_report.println(\" \" + m_report.key(\"report.notconverted\"), I_CmsReport.C_FORMAT_OK);\n            \n        }\n        \n        if (OpenCms.getLog(this).isDebugEnabled()) {\n            OpenCms.getLog(this).debug(\"End merging \" + resourcename);\n        }\n        \n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n      * Imports a resource (file or folder) into the cms.<p>\n      * \n      * @param source the path to the source-file\n      * @param destination the path to the destination-file in the cms\n      * @param type the resource-type of the file\n      * @param uuidstructure  the structure uuid of the resource\n      * @param uuidresource  the resource uuid of the resource\n      * @param datelastmodified the last modification date of the resource\n      * @param userlastmodified the user who made the last modifications to the resource\n      * @param datecreated the creation date of the resource\n      * @param usercreated the user who created \n      * @param flags the flags of the resource     \n      * @param properties a hashtable with properties for this resource\n      * @param writtenFilenames filenames of the files and folder which have actually been successfully written\n      *       not used when null\n      * @param fileCodes code of the written files (for the registry)\n      *       not used when null\n     * \n      * @return imported resource\n      */\n    private CmsResource importResource(String source, String destination, String type, String uuidstructure, String uuidresource, long datelastmodified, String userlastmodified, long datecreated, String usercreated, String flags, List properties, Vector writtenFilenames, Vector fileCodes) {\n\n        boolean success = true;\n        byte[] content = null;\n        String fullname = null;\n        CmsResource res = null;\n\n        try {\n            if (m_importingChannelData) {\n                // try to read an existing channel to get the channel id\n                String channelId = null;\n                try {\n                    if ((type.equalsIgnoreCase(CmsResourceTypeFolder.C_RESOURCE_TYPE_NAME)) && (!destination.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR))) {\n                        destination += I_CmsConstants.C_FOLDER_SEPARATOR;\n                    }\n                    CmsResource channel = m_cms.readResource(I_CmsConstants.C_ROOT + destination);\n                    channelId = m_cms.readPropertyObject(m_cms.getSitePath(channel), I_CmsConstants.C_PROPERTY_CHANNELID, false).getValue();\n                } catch (Exception e) {\n                    // ignore the exception, a new channel id will be generated\n                }\n                // TODO: CW: remove \n                /* if (channelId == null) {\n                    // the channel id does not exist, so generate a new one\n                    int newChannelId = org.opencms.db.CmsDbUtil.nextId(I_CmsConstants.C_TABLE_CHANNELID);\n                    channelId = \"\" + newChannelId;\n                }\n                properties.add(new CmsProperty(I_CmsConstants.C_PROPERTY_CHANNELID, channelId, null));\n                */\n                if (channelId != null) {\n                    properties.add(new CmsProperty(I_CmsConstants.C_PROPERTY_CHANNELID, channelId, null));\n                }\n            }\n            // get the file content\n            if (source != null) {\n                content = getFileBytes(source);\n            }\n            // get all required information to create a CmsResource\n            int resType = OpenCms.getResourceManager().getResourceType(type).getTypeId();\n            int size = 0;\n            if (content != null) {\n                size = content.length;\n            }\n            // get the required UUIDs         \n            CmsUUID curUser = m_cms.getRequestContext().currentUser().getId();\n            CmsUUID newUserlastmodified = new CmsUUID(userlastmodified);\n            CmsUUID newUsercreated = new CmsUUID(usercreated);\n            // check if user created and user lastmodified are valid users in this system.\n            // if not, set them to the current.\n            if (m_cms.readUser(newUserlastmodified).getId().equals(CmsUUID.getNullUUID())) {\n                newUserlastmodified = curUser;\n            }\n            if (m_cms.readUser(newUsercreated).getId().equals(CmsUUID.getNullUUID())) {\n                newUsercreated = curUser;\n            }\n            // get all UUIDs for the structure, resource and content        \n            CmsUUID newUuidstructure = new CmsUUID();\n            CmsUUID newUuidresource = new CmsUUID();\n            if (uuidstructure != null) {\n                newUuidstructure = new CmsUUID(uuidstructure);\n            }\n            if (uuidresource != null) {\n                newUuidresource = new CmsUUID(uuidresource);\n            }\n\n            // convert to xml page if wanted\n            if (m_convertToXmlPage \n                && (resType == A_CmsImport.C_RESOURCE_TYPE_PAGE_ID || resType == C_RESOURCE_TYPE_NEWPAGE_ID)) {\n                \n                if (content != null) {\n\n                    //get the encoding\n                    String encoding = null;                    \n                    encoding = CmsProperty.get(I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, properties).getValue();\n                    if (encoding == null) {\n                        encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n                    }                    \n                    \n                    CmsXmlPage xmlPage = CmsXmlPageConverter.convertToXmlPage(m_cms, new String(content, encoding), \"body\", getLocale(destination, properties), encoding);\n                    content = xmlPage.marshal();\n                }\n                resType = CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID;\n            }\n            \n            // create a new CmsResource                         \n            CmsResource resource = new CmsResource(\n                newUuidstructure, \n                newUuidresource, \n                destination,\n                resType,\n                CmsFolder.isFolderType(resType),\n                new Integer(flags).intValue(), \n                m_cms.getRequestContext().currentProject().getId(), \n                I_CmsConstants.C_STATE_NEW, \n                datelastmodified, \n                newUserlastmodified, \n                datecreated, \n                newUsercreated, \n                CmsResource.DATE_RELEASED_DEFAULT, \n                CmsResource.DATE_EXPIRED_DEFAULT, \n                1, size\n            );\n            \n            // import this resource in the VFS   \n            res = m_cms.importResource(m_importPath + destination, resource, content, properties);\n\n            if (res != null) {\n                if (A_CmsImport.C_RESOURCE_TYPE_PAGE_NAME.equals(type)) {\n                    m_importedPages.add(I_CmsConstants.C_FOLDER_SEPARATOR + destination);\n                }\n            }\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n        } catch (Exception exc) {\n            // an error while importing the file\n            success = false;\n            m_report.println(exc);\n            try {\n                // Sleep some time after an error so that the report output has a chance to keep up\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // \n            }\n        }\n\n        byte[] digestContent = {0 };\n        if (content != null) {\n            digestContent = m_digest.digest(content);\n        }\n        if (success && (fullname != null)) {\n            if (writtenFilenames != null) {\n                writtenFilenames.addElement(fullname);\n            }\n            if (fileCodes != null) {\n                fileCodes.addElement(new String(digestContent));\n            }\n        }\n\n        return res;\n    }","id":41555,"modified_method":"/**\n      * Imports a resource (file or folder) into the cms.<p>\n      * \n      * @param source the path to the source-file\n      * @param destination the path to the destination-file in the cms\n      * @param type the resource-type of the file\n      * @param uuidstructure  the structure uuid of the resource\n      * @param uuidresource  the resource uuid of the resource\n      * @param datelastmodified the last modification date of the resource\n      * @param userlastmodified the user who made the last modifications to the resource\n      * @param datecreated the creation date of the resource\n      * @param usercreated the user who created \n      * @param flags the flags of the resource     \n      * @param properties a hashtable with properties for this resource\n      * @param writtenFilenames filenames of the files and folder which have actually been successfully written\n      *       not used when null\n      * @param fileCodes code of the written files (for the registry)\n      *       not used when null\n     * \n      * @return imported resource\n      */\n    private CmsResource importResource(String source, String destination, String type, String uuidstructure, String uuidresource, long datelastmodified, String userlastmodified, long datecreated, String usercreated, String flags, List properties, Vector writtenFilenames, Vector fileCodes) {\n\n        boolean success = true;\n        byte[] content = null;\n        String fullname = null;\n        CmsResource res = null;\n\n        try {\n            if (m_importingChannelData) {\n                // try to read an existing channel to get the channel id\n                String channelId = null;\n                try {\n                    if ((type.equalsIgnoreCase(CmsResourceTypeFolder.C_RESOURCE_TYPE_NAME)) && (!destination.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR))) {\n                        destination += I_CmsConstants.C_FOLDER_SEPARATOR;\n                    }\n                    CmsResource channel = m_cms.readResource(I_CmsConstants.C_ROOT + destination);\n                    channelId = m_cms.readPropertyObject(m_cms.getSitePath(channel), I_CmsConstants.C_PROPERTY_CHANNELID, false).getValue();\n                } catch (Exception e) {\n                    // ignore the exception, a new channel id will be generated\n                }\n                if (channelId != null) {\n                    properties.add(new CmsProperty(I_CmsConstants.C_PROPERTY_CHANNELID, channelId, null));\n                }\n            }\n            // get the file content\n            if (source != null) {\n                content = getFileBytes(source);\n            }\n            // get all required information to create a CmsResource\n            int resType = OpenCms.getResourceManager().getResourceType(type).getTypeId();\n            int size = 0;\n            if (content != null) {\n                size = content.length;\n            }\n            // get the required UUIDs         \n            CmsUUID curUser = m_cms.getRequestContext().currentUser().getId();\n            CmsUUID newUserlastmodified = new CmsUUID(userlastmodified);\n            CmsUUID newUsercreated = new CmsUUID(usercreated);\n            // check if user created and user lastmodified are valid users in this system.\n            // if not, set them to the current.\n            if (m_cms.readUser(newUserlastmodified).getId().equals(CmsUUID.getNullUUID())) {\n                newUserlastmodified = curUser;\n            }\n            if (m_cms.readUser(newUsercreated).getId().equals(CmsUUID.getNullUUID())) {\n                newUsercreated = curUser;\n            }\n            // get all UUIDs for the structure, resource and content        \n            CmsUUID newUuidstructure = new CmsUUID();\n            CmsUUID newUuidresource = new CmsUUID();\n            if (uuidstructure != null) {\n                newUuidstructure = new CmsUUID(uuidstructure);\n            }\n            if (uuidresource != null) {\n                newUuidresource = new CmsUUID(uuidresource);\n            }\n\n            // convert to xml page if wanted\n            if (m_convertToXmlPage \n                && (resType == A_CmsImport.C_RESOURCE_TYPE_PAGE_ID || resType == C_RESOURCE_TYPE_NEWPAGE_ID)) {\n                \n                if (content != null) {\n\n                    //get the encoding\n                    String encoding = null;                    \n                    encoding = CmsProperty.get(I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, properties).getValue();\n                    if (encoding == null) {\n                        encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n                    }                    \n                    \n                    CmsXmlPage xmlPage = CmsXmlPageConverter.convertToXmlPage(\n                        m_cms, \n                        content, \n                        getLocale(destination, properties), \n                        encoding);\n                    \n                    content = xmlPage.marshal();\n                }\n                resType = CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID;\n            }\n            \n            // create a new CmsResource                         \n            CmsResource resource = new CmsResource(\n                newUuidstructure, \n                newUuidresource, \n                destination,\n                resType,\n                CmsFolder.isFolderType(resType),\n                new Integer(flags).intValue(), \n                m_cms.getRequestContext().currentProject().getId(), \n                I_CmsConstants.C_STATE_NEW, \n                datelastmodified, \n                newUserlastmodified, \n                datecreated, \n                newUsercreated, \n                CmsResource.DATE_RELEASED_DEFAULT, \n                CmsResource.DATE_EXPIRED_DEFAULT, \n                1, size\n            );\n            \n            // import this resource in the VFS   \n            res = m_cms.importResource(m_importPath + destination, resource, content, properties);\n\n            if (res != null) {\n                if (A_CmsImport.C_RESOURCE_TYPE_PAGE_NAME.equals(type)) {\n                    m_importedPages.add(I_CmsConstants.C_FOLDER_SEPARATOR + destination);\n                }\n            }\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n        } catch (Exception exc) {\n            // an error while importing the file\n            success = false;\n            m_report.println(exc);\n            try {\n                // Sleep some time after an error so that the report output has a chance to keep up\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // noop\n            }\n        }\n\n        byte[] digestContent = {0 };\n        if (content != null) {\n            digestContent = m_digest.digest(content);\n        }\n        if (success && (fullname != null)) {\n            if (writtenFilenames != null) {\n                writtenFilenames.addElement(fullname);\n            }\n            if (fileCodes != null) {\n                fileCodes.addElement(new String(digestContent));\n            }\n        }\n\n        return res;\n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Imports a resource (file or folder) into the cms.<p>\n     * \n     * @param source the path to the source-file\n     * @param destination the path to the destination-file in the cms\n     * @param resType the resource-type of the file\n     * @param uuidresource  the resource uuid of the resource\n     * @param datelastmodified the last modification date of the resource\n     * @param userlastmodified the user who made the last modifications to the resource\n     * @param datecreated the creation date of the resource\n     * @param usercreated the user who created \n     * @param datereleased the release date of the resource\n     * @param dateexpired the expire date of the resource\n     * @param flags the flags of the resource     \n     * @param properties a hashtable with properties for this resource\n     * \n     * @return imported resource\n     */\n    private CmsResource importResource(\n        String source, \n        String destination,         \n        int resType, \n        String uuidresource, \n        long datelastmodified, \n        String userlastmodified, \n        long datecreated, \n        String usercreated, \n        long datereleased, \n        long dateexpired, \n        String flags, \n        List properties) {\n\n        byte[] content = null;\n        CmsResource res = null;\n\n        try {\n            // get the file content\n            if (source != null) {\n                content = getFileBytes(source);\n            }\n            int size = 0;\n            if (content != null) {\n                size = content.length;\n            }\n\n            // get UUIDs for the user   \n            CmsUUID newUserlastmodified;\n            CmsUUID newUsercreated;\n            // check if user created and user lastmodified are valid users in this system.\n            // if not, use the current user\n            try {\n                newUserlastmodified = m_cms.readUser(userlastmodified).getId();\n            } catch (CmsException e) {\n                newUserlastmodified = m_cms.getRequestContext().currentUser().getId();\n                // datelastmodified = System.currentTimeMillis();\n            }\n\n            try {\n                newUsercreated = m_cms.readUser(usercreated).getId();\n            } catch (CmsException e) {\n                newUsercreated = m_cms.getRequestContext().currentUser().getId();\n                // datecreated = System.currentTimeMillis();\n            }\n\n            boolean isFolder = CmsFolder.isFolderType(resType);\n            \n            // get UUIDs for the resource and content        \n            CmsUUID newUuidresource = null;\n            if ((uuidresource != null) && (! isFolder)) {\n                // create a UUID from the provided string\n                newUuidresource = new CmsUUID(uuidresource);\n            } else {\n                // folders get always a new resource record UUID\n                newUuidresource = new CmsUUID();\n            }\n            \n            // extract the name of the resource form the destination\n            String resname = destination;\n            if (resname.endsWith(\"/\")) {\n                resname = resname.substring(0, resname.length() - 1);\n            }\n            if (resname.lastIndexOf(\"/\") > 0) {\n                resname = resname.substring(resname.lastIndexOf(\"/\") + 1, resname.length());\n            }\n\n            // convert to xml page if wanted\n            if (m_convertToXmlPage \n            && (resType == A_CmsImport.C_RESOURCE_TYPE_PAGE_ID \n                || resType == C_RESOURCE_TYPE_NEWPAGE_ID)) {\n                \n                if (content != null) {\n                    //get the encoding\n                    String encoding = null;                    \n                    encoding = CmsProperty.get(I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, properties).getValue();\n                    if (encoding == null) {\n                        encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n                    }  \n                    \n                    CmsXmlPage xmlPage = CmsXmlPageConverter.convertToXmlPage(m_cms, new String(content, encoding), \"body\", getLocale(destination, properties), encoding);                     \n                    content = xmlPage.marshal();\n                }\n                resType = CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID;\n            }\n            \n            // create a new CmsResource                         \n            CmsResource resource = new CmsResource(\n                new CmsUUID(), // structure ID is always a new UUID\n                newUuidresource, \n                destination,\n                resType,\n                isFolder,\n                new Integer(flags).intValue(), \n                m_cms.getRequestContext().currentProject().getId(), \n                I_CmsConstants.C_STATE_NEW, \n                datecreated,\n                newUsercreated, \n                datelastmodified, \n                newUserlastmodified, \n                datereleased, \n                dateexpired,\n                1, \n                size\n            );\n             \n            if (C_RESOURCE_TYPE_LINK_ID == resType) {\n                // store links for later conversion\n                m_report.print(m_report.key(\"report.storing_link\"), I_CmsReport.C_FORMAT_NOTE);\n                m_linkStorage.put(/* m_importPath + */destination, new String(content));\n                m_linkPropertyStorage.put(/* m_importPath + */destination, properties);                \n                res = resource;\n            } else {             \n                // import this resource in the VFS   \n                res = m_cms.importResource(/* m_importPath + */destination, resource, content, properties);\n            }\n\n            if (res != null) {\n                if (C_RESOURCE_TYPE_PAGE_ID == resType) {\n                    m_importedPages.add(/* I_CmsConstants.C_FOLDER_SEPARATOR + */destination);\n                }\n                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            }          \n        } catch (Exception exc) {\n            // an error while importing the file\n            m_report.println(exc);\n            try {\n                // Sleep some time after an error so that the report output has a chance to keep up\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // \n            }\n        }\n        return res;\n    }","id":41556,"modified_method":"/**\n     * Imports a resource (file or folder) into the cms.<p>\n     * \n     * @param source the path to the source-file\n     * @param destination the path to the destination-file in the cms\n     * @param resType the resource-type of the file\n     * @param uuidresource  the resource uuid of the resource\n     * @param datelastmodified the last modification date of the resource\n     * @param userlastmodified the user who made the last modifications to the resource\n     * @param datecreated the creation date of the resource\n     * @param usercreated the user who created \n     * @param datereleased the release date of the resource\n     * @param dateexpired the expire date of the resource\n     * @param flags the flags of the resource     \n     * @param properties a hashtable with properties for this resource\n     * \n     * @return imported resource\n     */\n    private CmsResource importResource(\n        String source, \n        String destination,         \n        int resType, \n        String uuidresource, \n        long datelastmodified, \n        String userlastmodified, \n        long datecreated, \n        String usercreated, \n        long datereleased, \n        long dateexpired, \n        String flags, \n        List properties) {\n\n        byte[] content = null;\n        CmsResource res = null;\n\n        try {\n            // get the file content\n            if (source != null) {\n                content = getFileBytes(source);\n            }\n            int size = 0;\n            if (content != null) {\n                size = content.length;\n            }\n\n            // get UUIDs for the user   \n            CmsUUID newUserlastmodified;\n            CmsUUID newUsercreated;\n            // check if user created and user lastmodified are valid users in this system.\n            // if not, use the current user\n            try {\n                newUserlastmodified = m_cms.readUser(userlastmodified).getId();\n            } catch (CmsException e) {\n                newUserlastmodified = m_cms.getRequestContext().currentUser().getId();\n                // datelastmodified = System.currentTimeMillis();\n            }\n\n            try {\n                newUsercreated = m_cms.readUser(usercreated).getId();\n            } catch (CmsException e) {\n                newUsercreated = m_cms.getRequestContext().currentUser().getId();\n                // datecreated = System.currentTimeMillis();\n            }\n\n            boolean isFolder = CmsFolder.isFolderType(resType);\n            \n            // get UUIDs for the resource and content        \n            CmsUUID newUuidresource = null;\n            if ((uuidresource != null) && (! isFolder)) {\n                // create a UUID from the provided string\n                newUuidresource = new CmsUUID(uuidresource);\n            } else {\n                // folders get always a new resource record UUID\n                newUuidresource = new CmsUUID();\n            }\n            \n            // extract the name of the resource form the destination\n            String resname = destination;\n            if (resname.endsWith(\"/\")) {\n                resname = resname.substring(0, resname.length() - 1);\n            }\n            if (resname.lastIndexOf(\"/\") > 0) {\n                resname = resname.substring(resname.lastIndexOf(\"/\") + 1, resname.length());\n            }\n            \n            // create a new CmsResource                         \n            CmsResource resource = new CmsResource(\n                new CmsUUID(), // structure ID is always a new UUID\n                newUuidresource, \n                destination,\n                resType,\n                isFolder,\n                new Integer(flags).intValue(), \n                m_cms.getRequestContext().currentProject().getId(), \n                I_CmsConstants.C_STATE_NEW, \n                datecreated,\n                newUsercreated, \n                datelastmodified, \n                newUserlastmodified, \n                datereleased, \n                dateexpired,\n                1, \n                size\n            );\n             \n            if (C_RESOURCE_TYPE_LINK_ID == resType) {\n                // store links for later conversion\n                m_report.print(m_report.key(\"report.storing_link\"), I_CmsReport.C_FORMAT_NOTE);\n                m_linkStorage.put(/* m_importPath + */destination, new String(content));\n                m_linkPropertyStorage.put(/* m_importPath + */destination, properties);                \n                res = resource;\n            } else {             \n                // import this resource in the VFS   \n                res = m_cms.importResource(/* m_importPath + */destination, resource, content, properties);\n            }\n\n            if (res != null) {\n                if (C_RESOURCE_TYPE_PAGE_ID == resType) {\n                    m_importedPages.add(/* I_CmsConstants.C_FOLDER_SEPARATOR + */destination);\n                }\n                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            }          \n        } catch (Exception exc) {\n            // an error while importing the file\n            m_report.println(exc);\n            try {\n                // Sleep some time after an error so that the report output has a chance to keep up\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // \n            }\n        }\n        return res;\n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Converts the contents of a page into an xml page.<p>\n     * \n     * @param cms the cms object\n     * @param content the content used with xml templates\n     * @param body the name of the default body element\n     * @param locale the locale of the body element(s)\n     * @param encoding the encoding to the xml page\n     * @return the xml page content or null if conversion failed\n     * @throws CmsException if something goes wrong\n     */\n    public static CmsXmlPage convertToXmlPage(CmsObject cms, String content, String body, Locale locale, String encoding) throws CmsException {\n        CmsXmlPage xmlPage = null;\n        \n        try {\n            xmlPage = new CmsXmlPage(locale, encoding);\n            Document page = CmsImport.getXmlDocument(content);\n            \n            Element xmltemplate = page.getRootElement();\n            if (xmltemplate == null || !\"XMLTEMPLATE\".equals(xmltemplate.getName())) {\n                throw new Exception(\"Element XMLTEMPLATE not found\");\n            }\n            \n            // get all edittemplate nodes\n            Iterator i = xmltemplate.elementIterator(\"edittemplate\");\n            boolean useEditTemplates = true;\n            if (!i.hasNext()) {\n                // no edittemplate nodes found, get the template nodes\n                i = xmltemplate.elementIterator(\"TEMPLATE\");\n                useEditTemplates = false;\n            }\n            \n            while (i.hasNext()) {\n                Element currentTemplate = (Element)i.next();\n                String bodyName = currentTemplate.attributeValue(\"name\");\n                if (bodyName == null || \"\".equals(bodyName)) {\n                    // no template name found, use the parameter body name\n                    bodyName = body;\n                }\n                String bodyContent = null;\n                \n                if (useEditTemplates) {\n                    // no content manipulation needed for edittemplates\n                    bodyContent = currentTemplate.getText();\n                } else {\n                    // parse content for TEMPLATEs\n                    if (currentTemplate != null) {\n                        StringBuffer contentBuffer = new StringBuffer();\n                        for (Iterator k = currentTemplate.nodeIterator(); k.hasNext();) {\n                            Node n = (Node)k.next();\n                            if (n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                                contentBuffer.append(n.getText());\n                                continue;\n                            } else if (n.getNodeType() == Node.ELEMENT_NODE) {\n                                if (\"LINK\".equals(n.getName())) {\n                                    contentBuffer.append(OpenCms.getSystemInfo().getOpenCmsContext());\n                                    contentBuffer.append(n.getText());\n                                    continue;\n                                } \n                            } \n                        }\n                        bodyContent = contentBuffer.toString();\n                    }\n                }\n            \n                if (bodyContent == null) {\n                    throw new Exception(\"Body content not found\");\n                }\n                \n                bodyContent = CmsStringUtil.substitute(bodyContent, I_CmsWpConstants.C_MACRO_OPENCMS_CONTEXT, OpenCms.getSystemInfo().getOpenCmsContext());\n                \n                if (!\"\".equals(bodyContent.trim())) {\n                    xmlPage.addValue(bodyName, locale);\n                    xmlPage.setStringValue(cms, bodyName, locale, bodyContent);\n                }\n            }\n            \n            return xmlPage;\n        } catch (Exception exc) {\n            throw new CmsException(exc.toString());\n        }\n    }","id":41557,"modified_method":"/**\n     * Converts the contents of a page into an xml page.<p>\n     * \n     * @param cms the cms object\n     * @param content the content used with xml templates\n     * @param locale the locale of the body element(s)\n     * @param encoding the encoding to the xml page\n     * @return the xml page content or null if conversion failed\n     * @throws CmsException if something goes wrong\n     */\n    public static CmsXmlPage convertToXmlPage(CmsObject cms, byte[] content, Locale locale, String encoding) throws CmsException {\n        \n        CmsXmlPage xmlPage = null;\n\n        try {\n            Document page = CmsXmlUtils.unmarshalHelper(content, null);            \n            \n            Element xmltemplate = page.getRootElement();\n            if (xmltemplate == null || !\"XMLTEMPLATE\".equals(xmltemplate.getName())) {\n                throw new Exception(\"Element XMLTEMPLATE not found\");\n            }\n            \n            // get all edittemplate nodes\n            Iterator i = xmltemplate.elementIterator(\"edittemplate\");\n            boolean useEditTemplates = true;\n            if (!i.hasNext()) {\n                // no edittemplate nodes found, get the template nodes\n                i = xmltemplate.elementIterator(\"TEMPLATE\");\n                useEditTemplates = false;\n            }\n            \n            // now create the XML page\n            xmlPage = new CmsXmlPage(locale, encoding);\n            \n            while (i.hasNext()) {\n                Element currentTemplate = (Element)i.next();\n                String bodyName = currentTemplate.attributeValue(\"name\");\n                if (bodyName == null || \"\".equals(bodyName)) {\n                    // no template name found, use the parameter body name\n                    bodyName = \"body\";\n                }\n                String bodyContent = null;\n                \n                if (useEditTemplates) {\n                    // no content manipulation needed for edittemplates\n                    bodyContent = currentTemplate.getText();\n                } else {\n                    // parse content for TEMPLATEs\n                    if (currentTemplate != null) {\n                        StringBuffer contentBuffer = new StringBuffer();\n                        for (Iterator k = currentTemplate.nodeIterator(); k.hasNext();) {\n                            Node n = (Node)k.next();\n                            if (n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                                contentBuffer.append(n.getText());\n                                continue;\n                            } else if (n.getNodeType() == Node.ELEMENT_NODE) {\n                                if (\"LINK\".equals(n.getName())) {\n                                    contentBuffer.append(OpenCms.getSystemInfo().getOpenCmsContext());\n                                    contentBuffer.append(n.getText());\n                                    continue;\n                                } \n                            } \n                        }\n                        bodyContent = contentBuffer.toString();\n                    }\n                }\n            \n                if (bodyContent == null) {\n                    throw new Exception(\"Body content not found\");\n                }\n                \n                bodyContent = CmsStringUtil.substitute(\n                    bodyContent, \n                    I_CmsWpConstants.C_MACRO_OPENCMS_CONTEXT, \n                    OpenCms.getSystemInfo().getOpenCmsContext());\n\n                if (!\"\".equals(bodyContent.trim())) {\n                    xmlPage.addValue(bodyName, locale);\n                    xmlPage.setStringValue(cms, bodyName, locale, bodyContent);\n                }\n            }\n            \n            return xmlPage;\n        } catch (Exception exc) {\n            throw new CmsException(exc.toString());\n        }\n    }","commit_id":"4fc80471a6eaff10e8566c6e9f61a805058a64ac","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void toggleContentPopup() {\n    if (myShouldNotShowPopup) {\n      myShouldNotShowPopup = false;\n      return;\n    }\n    BaseListPopupStep step = new BaseListPopupStep<Content>(null, myManager.getContents()) {\n      @Override\n      public PopupStep onChosen(Content selectedValue, boolean finalChoice) {\n        myManager.setSelectedContent(selectedValue, true, true);\n        return FINAL_CHOICE;\n      }\n\n      @NotNull\n      @Override\n      public String getTextFor(Content value) {\n        final String displayName = value.getTabName();\n        return displayName != null ? displayName : \"\";\n      }\n\n      @Override\n      public Icon getIconFor(Content aValue) {\n        return aValue.getPopupIcon();\n      }\n\n      @Override\n      public boolean isMnemonicsNavigationEnabled() {\n        return true;\n      }\n\n      @Override\n      public ListSeparator getSeparatorAbove(Content value) {\n        final String separator = value.getSeparator();\n        return separator != null ? new ListSeparator(separator) : super.getSeparatorAbove(value);\n      }\n    };\n\n    step.setDefaultOptionIndex(Arrays.asList(myManager.getContents()).indexOf(myManager.getSelectedContent()));\n    final ListPopup popup = new ListPopupImpl(step) {\n      @Override\n      public void cancel(InputEvent e) {\n        super.cancel(e);\n        if (e instanceof MouseEvent) {\n          final MouseEvent me = (MouseEvent)e;\n          final Component component = SwingUtilities.getDeepestComponentAt(e.getComponent(), me.getX(), me.getY());\n          if (UIUtil.isActionClick(me) && component instanceof ContentComboLabel &&\n              SwingUtilities.isDescendingFrom(component, ToolWindowContentUi.this)) {\n            myShouldNotShowPopup = true;\n          }\n        }\n      }\n    };\n    getCurrentLayout().showContentPopup(popup);\n  }","id":41558,"modified_method":"public void toggleContentPopup() {\n    if (myShouldNotShowPopup) {\n      myShouldNotShowPopup = false;\n      return;\n    }\n\n    final Content[] contents = myManager.getContents();\n    final AnAction[] actions = new AnAction[contents.length];\n    for (int i = 0; i < actions.length; i++) {\n      final Content content = contents[i];\n      if (content instanceof TabbedContent) {\n        final List<Pair<String, JComponent>> tabs = ((TabbedContent)content).getTabs();\n        final AnAction[] tabActions = new AnAction[tabs.size()];\n        for (int j = 0; j < tabActions.length; j++) {\n          final int index = j;\n          tabActions[j] = new DumbAwareAction(tabs.get(index).first) {\n            @Override\n            public void actionPerformed(@NotNull AnActionEvent e) {\n              ((TabbedContent)content).selectContent(index);\n            }\n          };\n        }\n        final DefaultActionGroup group = new DefaultActionGroup(tabActions);\n        group.getTemplatePresentation().setText(((TabbedContent)content).getTitlePrefix());\n        group.setPopup(true);\n        actions[i] = group;\n      } else {\n        actions[i] = new DumbAwareAction(content.getTabName()) {\n          @Override\n          public void actionPerformed(@NotNull AnActionEvent e) {\n            myManager.setSelectedContent(content, true, true);\n          }\n        };\n      }\n    }\n\n    final ListPopup popup = JBPopupFactory.getInstance().createActionGroupPopup(null, new DefaultActionGroup(actions),\n                                                                  DataManager.getInstance().getDataContext(myManager.getComponent()),\n                                                                  JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, true);\n    getCurrentLayout().showContentPopup(popup);\n  }","commit_id":"b719082c091f3e21e5818cadcb55c2127cd3e865","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rewriteModule()\n        throws MojoExecutionException\n    {\n        File moduleFile = new File( project.getBasedir(), project.getArtifactId() + \".iml\" );\n        try\n        {\n            Document document = readXmlDocument( moduleFile, \"module.xml\" );\n\n            Element module = document.getRootElement();\n\n            // TODO: how can we let the WAR/EJBs plugin hook in and provide this?\n            // TODO: merge in ejb-module, etc.\n            if ( \"war\".equals( project.getPackaging() ) )\n            {\n                addWebModule( module );\n            }\n            else if ( \"ejb\".equals( project.getPackaging() ) )\n            {\n                addEjbModule( module );\n            }\n            else if ( \"ear\".equals( project.getPackaging() ) )\n            {\n                addEarModule( module );\n            }\n\n            Element component = findComponent( module, \"NewModuleRootManager\" );\n            Element output = findElement( component, \"output\" );\n            output.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getOutputDirectory() ) );\n\n            Element outputTest = findElement( component, \"output-test\" );\n            outputTest.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getTestOutputDirectory() ) );\n\n            Element content = findElement( component, \"content\" );\n\n            removeOldElements( content, \"sourceFolder\" );\n\n            for ( Iterator i = executedProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, false );\n            }\n            for ( Iterator i = executedProject.getTestCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, true );\n            }\n\n            List resourceDirectory = new ArrayList();\n            for ( Iterator i = project.getBuild().getResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                resourceDirectory.add( resource.getDirectory() );\n            }\n\n            for ( Iterator i = project.getBuild().getTestResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                String directory = resource.getDirectory();\n                addSourceFolder( content, directory, true );\n            }\n\n            removeOldElements( content, \"excludeFolder\" );\n\n            //For excludeFolder\n            File target = new File( project.getBuild().getDirectory() );\n            File classes = new File( project.getBuild().getOutputDirectory() );\n            File testClasses = new File( project.getBuild().getTestOutputDirectory() );\n\n            List sourceFolders = content.elements( \"sourceFolder\" );\n\n            List filteredExcludes = new ArrayList();\n            filteredExcludes.addAll( getExcludedDirectories( target, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( classes, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( testClasses, filteredExcludes, sourceFolders ) );\n\n            if ( exclude != null )\n            {\n                String[] dirs = exclude.split( \"[,\\\\s]+\" );\n                for ( int i = 0; i < dirs.length; i++ )\n                {\n                    File excludedDir = new File( project.getBasedir(), dirs[i] );\n                    filteredExcludes.addAll( getExcludedDirectories( excludedDir, filteredExcludes, sourceFolders ) );\n                }\n            }\n\n            // even though we just ran all the directories in the filteredExcludes List through the intelligent\n            // getExcludedDirectories method, we never actually were guaranteed the order that they were added was\n            // in the order required to make the most optimized exclude list. In addition, the smart logic from\n            // that method is entirely skipped if the directory doesn't currently exist. A simple string matching\n            // will do pretty much the same thing and make the list more concise.\n            ArrayList actuallyExcluded = new ArrayList();\n            Collections.sort( filteredExcludes );\n            for ( Iterator i = filteredExcludes.iterator(); i.hasNext(); )\n            {\n                String dirToExclude = i.next().toString();\n                boolean addExclude = true;\n                for ( Iterator iterator = actuallyExcluded.iterator(); iterator.hasNext(); )\n                {\n                    String dir = (String) iterator.next();\n                    if ( dirToExclude.startsWith( dir ) )\n                    {\n                        addExclude = false;\n                        break;\n                    }\n                }\n\n                if ( addExclude )\n                {\n                    actuallyExcluded.add( dirToExclude );\n                    addExcludeFolder( content, dirToExclude );\n                }\n            }\n\n            removeOldDependencies( component );\n\n            List testClasspathElements = project.getTestArtifacts();\n            for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                Library library = findLibrary( a );\n                if ( library != null && library.isExclude() )\n                {\n                    continue;\n                }\n\n                String moduleName;\n                if ( useFullNames )\n                {\n                    moduleName = a.getGroupId() + ':' + a.getArtifactId() + ':' + a.getType() + ':' + a.getVersion();\n                }\n                else\n                {\n                    moduleName = a.getArtifactId();\n                }\n\n                Element dep = null;\n\n                for ( Iterator children = component.elementIterator( \"orderEntry\" ); children.hasNext(); )\n                {\n                    Element orderEntry = (Element) children.next();\n\n                    if ( orderEntry.attributeValue( \"type\" ).equals( \"module\" ) )\n                    {\n                        if ( orderEntry.attributeValue( \"module-name\" ).equals( moduleName ) )\n                        {\n                            dep = orderEntry;\n                            break;\n                        }\n                    }\n                    else if ( orderEntry.attributeValue( \"type\" ).equals( \"module-library\" ) )\n                    {\n                        Element lib = orderEntry.element( \"library\" );\n                        String name = lib.attributeValue( \"name\" );\n                        if ( name != null )\n                        {\n                            if ( name.equals( moduleName ) )\n                            {\n                                dep = orderEntry;\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            Element classesChild = lib.element( \"CLASSES\" );\n                            if ( classesChild != null )\n                            {\n                                Element rootChild = classesChild.element( \"root\" );\n                                if ( rootChild != null )\n                                {\n                                    String url = getLibraryUrl( a );\n                                    if ( url.equals( rootChild.getText() ) )\n                                    {\n                                        dep = orderEntry;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if ( dep == null )\n                {\n                    dep = createElement( component, \"orderEntry\" );\n                }\n\n                boolean isIdeaModule = false;\n                if ( linkModules )\n                {\n                    isIdeaModule = isReactorProject( a.getGroupId(), a.getArtifactId() );\n\n                    if ( isIdeaModule )\n                    {\n                        dep.addAttribute( \"type\", \"module\" );\n                        dep.addAttribute( \"module-name\", moduleName );\n                    }\n                }\n\n                if ( a.getFile() != null && !isIdeaModule )\n                {\n                    dep.addAttribute( \"type\", \"module-library\" );\n                    removeOldElements( dep, \"library\" );\n                    dep = createElement( dep, \"library\" );\n\n                    if ( dependenciesAsLibraries )\n                    {\n                        dep.addAttribute( \"name\", moduleName );\n                    }\n\n                    Element el = createElement( dep, \"CLASSES\" );\n                    if ( library != null && library.getSplitClasses().length > 0 )\n                    {\n                        dep.addAttribute( \"name\", moduleName );\n                        String[] libraryClasses = library.getSplitClasses();\n                        for ( int k = 0; k < libraryClasses.length; k++ )\n                        {\n                            String classpath = libraryClasses[k];\n                            extractMacro( classpath );\n                            Element classEl = createElement( el, \"root\" );\n                            classEl.addAttribute( \"url\", classpath );\n                        }\n                    }\n                    else\n                    {\n                        createElement( el, \"root\" ).addAttribute( \"url\", getLibraryUrl( a ) );\n                    }\n\n                    boolean usedSources = false;\n                    if ( library != null && library.getSplitSources().length > 0 )\n                    {\n                        Element sourcesElement = createElement( dep, \"SOURCES\" );\n                        usedSources = true;\n                        String[] sources = library.getSplitSources();\n                        for ( int k = 0; k < sources.length; k++ )\n                        {\n                            String source = sources[k];\n                            extractMacro( source );\n                            Element sourceEl = createElement( sourcesElement, \"root\" );\n                            sourceEl.addAttribute( \"url\", source );\n                        }\n                    }\n\n                    if ( !usedSources && downloadSources )\n                    {\n                        resolveClassifier( createElement( dep, \"SOURCES\" ), a, sourceClassifier );\n                    }\n\n                    if ( downloadJavadocs )\n                    {\n                        resolveClassifier( createElement( dep, \"JAVADOC\" ), a, javadocClassifier );\n                    }\n                }\n            }\n\n            for ( Iterator resourceDirs = resourceDirectory.iterator(); resourceDirs.hasNext(); )\n            {\n                String resourceDir = (String) resourceDirs.next();\n\n                getLog().info( \"Adding resource directory: \" + resourceDir );\n\n                addResources( component, resourceDir );\n            }\n\n            writeXmlDocument( moduleFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n    }","id":41559,"modified_method":"public void rewriteModule()\n        throws MojoExecutionException\n    {\n        File moduleFile = new File( project.getBasedir(), project.getArtifactId() + \".iml\" );\n        try\n        {\n            Document document = readXmlDocument( moduleFile, \"module.xml\" );\n\n            Element module = document.getRootElement();\n\n            // TODO: how can we let the WAR/EJBs plugin hook in and provide this?\n            // TODO: merge in ejb-module, etc.\n            if ( \"war\".equals( project.getPackaging() ) )\n            {\n                addWebModule( module );\n            }\n            else if ( \"ejb\".equals( project.getPackaging() ) )\n            {\n                addEjbModule( module );\n            }\n            else if ( \"ear\".equals( project.getPackaging() ) )\n            {\n                addEarModule( module );\n            }\n\n            Element component = findComponent( module, \"NewModuleRootManager\" );\n            Element output = findElement( component, \"output\" );\n            output.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getOutputDirectory() ) );\n\n            Element outputTest = findElement( component, \"output-test\" );\n            outputTest.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getTestOutputDirectory() ) );\n\n            Element content = findElement( component, \"content\" );\n\n            removeOldElements( content, \"sourceFolder\" );\n\n            for ( Iterator i = executedProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, false );\n            }\n            for ( Iterator i = executedProject.getTestCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, true );\n            }\n\n            for ( Iterator i = project.getBuild().getResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                String directory = resource.getDirectory();\n                if ( resource.getTargetPath() == null && resource.isFiltering() == false )\n                {\n                    addSourceFolder( content, directory, false );\n                }\n                else\n                {\n                    getLog().info(\n                        \"Not adding resource directory as it has an incompatible target path or filtering: \" +\n                            directory );\n                }\n            }\n\n            for ( Iterator i = project.getBuild().getTestResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                String directory = resource.getDirectory();\n                if ( resource.getTargetPath() == null && resource.isFiltering() == false )\n                {\n                    addSourceFolder( content, directory, true );\n                }\n                else\n                {\n                    getLog().info(\n                        \"Not adding test resource directory as it has an incompatible target path or filtering: \" +\n                            directory );\n                }\n            }\n\n            removeOldElements( content, \"excludeFolder\" );\n\n            //For excludeFolder\n            File target = new File( project.getBuild().getDirectory() );\n            File classes = new File( project.getBuild().getOutputDirectory() );\n            File testClasses = new File( project.getBuild().getTestOutputDirectory() );\n\n            List sourceFolders = content.elements( \"sourceFolder\" );\n\n            List filteredExcludes = new ArrayList();\n            filteredExcludes.addAll( getExcludedDirectories( target, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( classes, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( testClasses, filteredExcludes, sourceFolders ) );\n\n            if ( exclude != null )\n            {\n                String[] dirs = exclude.split( \"[,\\\\s]+\" );\n                for ( int i = 0; i < dirs.length; i++ )\n                {\n                    File excludedDir = new File( project.getBasedir(), dirs[i] );\n                    filteredExcludes.addAll( getExcludedDirectories( excludedDir, filteredExcludes, sourceFolders ) );\n                }\n            }\n\n            // even though we just ran all the directories in the filteredExcludes List through the intelligent\n            // getExcludedDirectories method, we never actually were guaranteed the order that they were added was\n            // in the order required to make the most optimized exclude list. In addition, the smart logic from\n            // that method is entirely skipped if the directory doesn't currently exist. A simple string matching\n            // will do pretty much the same thing and make the list more concise.\n            ArrayList actuallyExcluded = new ArrayList();\n            Collections.sort( filteredExcludes );\n            for ( Iterator i = filteredExcludes.iterator(); i.hasNext(); )\n            {\n                String dirToExclude = i.next().toString();\n                boolean addExclude = true;\n                for ( Iterator iterator = actuallyExcluded.iterator(); iterator.hasNext(); )\n                {\n                    String dir = (String) iterator.next();\n                    if ( dirToExclude.startsWith( dir ) )\n                    {\n                        addExclude = false;\n                        break;\n                    }\n                }\n\n                if ( addExclude )\n                {\n                    actuallyExcluded.add( dirToExclude );\n                    addExcludeFolder( content, dirToExclude );\n                }\n            }\n\n            removeOldDependencies( component );\n\n            List testClasspathElements = project.getTestArtifacts();\n            for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                Library library = findLibrary( a );\n                if ( library != null && library.isExclude() )\n                {\n                    continue;\n                }\n\n                String moduleName;\n                if ( useFullNames )\n                {\n                    moduleName = a.getGroupId() + ':' + a.getArtifactId() + ':' + a.getType() + ':' + a.getVersion();\n                }\n                else\n                {\n                    moduleName = a.getArtifactId();\n                }\n\n                Element dep = null;\n\n                for ( Iterator children = component.elementIterator( \"orderEntry\" ); children.hasNext(); )\n                {\n                    Element orderEntry = (Element) children.next();\n\n                    if ( orderEntry.attributeValue( \"type\" ).equals( \"module\" ) )\n                    {\n                        if ( orderEntry.attributeValue( \"module-name\" ).equals( moduleName ) )\n                        {\n                            dep = orderEntry;\n                            break;\n                        }\n                    }\n                    else if ( orderEntry.attributeValue( \"type\" ).equals( \"module-library\" ) )\n                    {\n                        Element lib = orderEntry.element( \"library\" );\n                        String name = lib.attributeValue( \"name\" );\n                        if ( name != null )\n                        {\n                            if ( name.equals( moduleName ) )\n                            {\n                                dep = orderEntry;\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            Element classesChild = lib.element( \"CLASSES\" );\n                            if ( classesChild != null )\n                            {\n                                Element rootChild = classesChild.element( \"root\" );\n                                if ( rootChild != null )\n                                {\n                                    String url = getLibraryUrl( a );\n                                    if ( url.equals( rootChild.getText() ) )\n                                    {\n                                        dep = orderEntry;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if ( dep == null )\n                {\n                    dep = createElement( component, \"orderEntry\" );\n                }\n\n                boolean isIdeaModule = false;\n                if ( linkModules )\n                {\n                    isIdeaModule = isReactorProject( a.getGroupId(), a.getArtifactId() );\n\n                    if ( isIdeaModule )\n                    {\n                        dep.addAttribute( \"type\", \"module\" );\n                        dep.addAttribute( \"module-name\", moduleName );\n                    }\n                }\n\n                if ( a.getFile() != null && !isIdeaModule )\n                {\n                    dep.addAttribute( \"type\", \"module-library\" );\n                    removeOldElements( dep, \"library\" );\n                    dep = createElement( dep, \"library\" );\n\n                    if ( dependenciesAsLibraries )\n                    {\n                        dep.addAttribute( \"name\", moduleName );\n                    }\n\n                    Element el = createElement( dep, \"CLASSES\" );\n                    if ( library != null && library.getSplitClasses().length > 0 )\n                    {\n                        dep.addAttribute( \"name\", moduleName );\n                        String[] libraryClasses = library.getSplitClasses();\n                        for ( int k = 0; k < libraryClasses.length; k++ )\n                        {\n                            String classpath = libraryClasses[k];\n                            extractMacro( classpath );\n                            Element classEl = createElement( el, \"root\" );\n                            classEl.addAttribute( \"url\", classpath );\n                        }\n                    }\n                    else\n                    {\n                        createElement( el, \"root\" ).addAttribute( \"url\", getLibraryUrl( a ) );\n                    }\n\n                    boolean usedSources = false;\n                    if ( library != null && library.getSplitSources().length > 0 )\n                    {\n                        Element sourcesElement = createElement( dep, \"SOURCES\" );\n                        usedSources = true;\n                        String[] sources = library.getSplitSources();\n                        for ( int k = 0; k < sources.length; k++ )\n                        {\n                            String source = sources[k];\n                            extractMacro( source );\n                            Element sourceEl = createElement( sourcesElement, \"root\" );\n                            sourceEl.addAttribute( \"url\", source );\n                        }\n                    }\n\n                    if ( !usedSources && downloadSources )\n                    {\n                        resolveClassifier( createElement( dep, \"SOURCES\" ), a, sourceClassifier );\n                    }\n\n                    if ( downloadJavadocs )\n                    {\n                        resolveClassifier( createElement( dep, \"JAVADOC\" ), a, javadocClassifier );\n                    }\n                }\n            }\n\n            writeXmlDocument( moduleFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"8523e541d528d9be1f32fd21b79d9142dae21f8c","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addResources( Element component, String directory )\n    {\n        Element dep = createElement( component, \"orderEntry\" );\n        dep.addAttribute( \"type\", \"module-library\" );\n        dep = createElement( dep, \"library\" );\n        dep.addAttribute( \"name\", \"resources\" );\n\n        Element el = createElement( dep, \"CLASSES\" );\n        el = createElement( el, \"root\" );\n        el.addAttribute( \"url\", getModuleFileUrl( directory ) );\n    }","id":41560,"modified_method":"private void addResources( Element component, String directory )\n    {\n        Element dep = createElement( component, \"orderEntry\" );\n        dep.addAttribute( \"type\", \"module-library\" );\n        dep = createElement( dep, \"library\" );\n\n        Element el = createElement( dep, \"CLASSES\" );\n        el = createElement( el, \"root\" );\n        el.addAttribute( \"url\", getModuleFileUrl( directory ) );\n    }","commit_id":"8523e541d528d9be1f32fd21b79d9142dae21f8c","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void writeCheckpoint(JournalEntry entry) {\n  }","id":41561,"modified_method":"public void writeCheckpoint(JournalEntry entry) throws IOException {\n    String tmpCheckpointPath = mCheckpointPath + \".tmp\";\n    LOG.info(\"Creating tmp checkpoint file: \" + tmpCheckpointPath);\n    if (!mUfs.exists(mJournalDirectory)) {\n      LOG.info(\"Creating journal folder: \" + mJournalDirectory);\n      mUfs.mkdirs(mJournalDirectory, true);\n    }\n    DataOutputStream dos = new DataOutputStream(mUfs.create(tmpCheckpointPath));\n    mJournal.getJournalFormatter().serialize(entry, dos);\n    dos.flush();\n    dos.close();\n\n    LOG.info(\"Successfully created tmp checkpoint file: \" + tmpCheckpointPath);\n    mUfs.delete(mCheckpointPath, false);\n    mUfs.rename(tmpCheckpointPath, mCheckpointPath);\n    mUfs.delete(tmpCheckpointPath, false);\n    LOG.info(\"Renamed checkpoint file \" + tmpCheckpointPath + \" to \" + mCheckpointPath);\n  }","commit_id":"e2eb282bef4ff7c31db6d30a4a5a200e8d725325","url":"https://github.com/amplab/tachyon"},{"original_method":"JournalWriter(Journal journal, TachyonConf tachyonConf) {\n    mJournal = journal;\n    mTachyonConf = tachyonConf;\n    mUfs = UnderFileSystem.get(mJournal.getDirectory(), mTachyonConf);\n  }","id":41562,"modified_method":"JournalWriter(Journal journal, TachyonConf tachyonConf) {\n    mJournal = journal;\n    mTachyonConf = tachyonConf;\n    mJournalDirectory = mJournal.getDirectory();\n    mCheckpointPath = mJournalDirectory + mJournal.getCheckpointFilename();\n    mUfs = UnderFileSystem.get(mJournalDirectory, mTachyonConf);\n  }","commit_id":"e2eb282bef4ff7c31db6d30a4a5a200e8d725325","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void extractExif(ImageEntry e) {\n\n        try {\n            int deg;\n            double min, sec;\n            double lon, lat;\n\n            Metadata metadata = JpegMetadataReader.readMetadata(e.getFile());\n            Directory dir = metadata.getDirectory(GpsDirectory.class);\n\n            // longitude\n\n            Rational[] components = dir.getRationalArray(GpsDirectory.TAG_GPS_LONGITUDE);\n\n            deg = components[0].intValue();\n            min = components[1].floatValue();\n            sec = components[2].floatValue();\n\n            lon = (deg + (min / 60) + (sec / 3600));\n\n            if (dir.getString(GpsDirectory.TAG_GPS_LONGITUDE_REF).charAt(0) == 'W') {\n                lon = -lon;\n            }\n\n            // latitude\n\n            components = dir.getRationalArray(GpsDirectory.TAG_GPS_LATITUDE);\n\n            deg = components[0].intValue();\n            min = components[1].floatValue();\n            sec = components[2].floatValue();\n\n            lat = (deg + (min / 60) + (sec / 3600));\n\n            if (dir.getString(GpsDirectory.TAG_GPS_LATITUDE_REF).charAt(0) == 'S') {\n                lat = -lat;\n            }\n\n\n            // compass direction value\n\n            Rational direction = null;\n            \n            try {\n                direction = dir.getRational(GpsDirectory.TAG_GPS_IMG_DIRECTION);\n            } catch (CompoundException p) {\n                direction = null;\n            }\n\n            // Store values\n\n            e.setExifCoor(new LatLon(lat, lon));\n            e.setPos(e.getExifCoor());\n            if (direction != null) {\n                e.setExifImgDir(direction.doubleValue());\n            }\n\n        } catch (CompoundException p) {\n            e.setExifCoor(null);\n            e.setPos(null);\n        }\n    }","id":41563,"modified_method":"private static void extractExif(ImageEntry e) {\n\n        int deg;\n        double min, sec;\n        double lon, lat;\n        Metadata metadata = null;\n        Directory dir = null;\n        \n        try {\n            metadata = JpegMetadataReader.readMetadata(e.getFile());\n            dir = metadata.getDirectory(GpsDirectory.class);\n        } catch (CompoundException p) {\n            e.setExifCoor(null);\n            e.setPos(null);\n            return;\n        }\n        \n        try {\n            // longitude\n\n            Rational[] components = dir.getRationalArray(GpsDirectory.TAG_GPS_LONGITUDE);\n\n            deg = components[0].intValue();\n            min = components[1].floatValue();\n            sec = components[2].floatValue();\n\n            lon = (deg + (min / 60) + (sec / 3600));\n\n            if (dir.getString(GpsDirectory.TAG_GPS_LONGITUDE_REF).charAt(0) == 'W') {\n                lon = -lon;\n            }\n\n            // latitude\n\n            components = dir.getRationalArray(GpsDirectory.TAG_GPS_LATITUDE);\n\n            deg = components[0].intValue();\n            min = components[1].floatValue();\n            sec = components[2].floatValue();\n\n            lat = (deg + (min / 60) + (sec / 3600));\n\n            if (dir.getString(GpsDirectory.TAG_GPS_LATITUDE_REF).charAt(0) == 'S') {\n                lat = -lat;\n            }\n\n            // Store values\n\n            e.setExifCoor(new LatLon(lat, lon));\n            e.setPos(e.getExifCoor());\n\n        } catch (CompoundException p) {\n            // Try to read lon/lat as double value (Nonstandard, created by some cameras -> #5220)\n            try {\n                Double longitude = dir.getDouble(GpsDirectory.TAG_GPS_LONGITUDE);\n                Double latitude = dir.getDouble(GpsDirectory.TAG_GPS_LATITUDE);\n                if (longitude == null || latitude == null)\n                    throw new CompoundException(\"\");\n\n                // Store values\n\n                e.setExifCoor(new LatLon(latitude, longitude));\n                e.setPos(e.getExifCoor());\n            } catch (CompoundException ex) {\n                e.setExifCoor(null);\n                e.setPos(null);\n            }\n        }\n\n        // compass direction value\n\n        Rational direction = null;\n        \n        try {\n            direction = dir.getRational(GpsDirectory.TAG_GPS_IMG_DIRECTION);\n        } catch (CompoundException p) {\n            direction = null;\n        }\n        if (direction != null) {\n            e.setExifImgDir(direction.doubleValue());\n        }\n\n    }","commit_id":"04c632c504387dd51f7fc44732de5546211735ff","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static ImageIcon getIfAvailable(Collection<String> dirs, String id, String subdir, String name, File archive) {\n        if (name == null)\n            return null;\n        if (name.startsWith(\"http://\")) {\n            Image img = cache.get(name);\n            if (img == null) {\n                try {\n                    MirroredInputStream is = new MirroredInputStream(name, new File(Main.pref.getPreferencesDir(),\n                    \"images\").toString());\n                    img = Toolkit.getDefaultToolkit().createImage(is.getFile().toURI().toURL());\n                    cache.put(name, img);\n                } catch (IOException e) {\n                }\n            }\n            return img == null ? null : new ImageIcon(img);\n        }\n        if (subdir == null) {\n            subdir = \"\";\n        } else if (!subdir.equals(\"\")) {\n            subdir += \"/\";\n        }\n        String ext = name.indexOf('.') != -1 ? \"\" : \".png\";\n        String full_name = subdir + name + ext;\n        String cache_name = full_name;\n        /* cache separately */\n        if (dirs != null && dirs.size() > 0) {\n            cache_name = \"id:\" + id + \":\" + full_name;\n            if(archive != null) {\n                cache_name += \":\" + archive.getName();\n            }\n        }\n\n        Image img = cache.get(cache_name);\n        if (img == null) {\n            if(archive != null)\n            {\n                try\n                {\n                    ZipFile zipFile = new ZipFile(archive);\n                    ZipEntry entry = zipFile.getEntry(full_name);\n                    if(entry != null)\n                    {\n                        int size = (int)entry.getSize();\n                        int offs = 0;\n                        byte[] buf = new byte[size];\n                        InputStream is = zipFile.getInputStream(entry);\n                        while(size > 0)\n                        {\n                            int l = is.read(buf, offs, size);\n                            offs += l;\n                            size -= l;\n                        }\n                        img = Toolkit.getDefaultToolkit().createImage(buf);\n                    }\n                } catch (Exception e) {\n                    System.err.println(tr(\"Warning: failed to handle zip file ''{0}''. Exception was: {1}\", archive.getName(), e.toString()));\n                }\n            }\n            // getImageUrl() does a ton of \"stat()\" calls and gets expensive\n            // and redundant when you have a whole ton of objects. So,\n            // index the cache by the name of the icon we're looking for\n            // and don't bother to create a URL unless we're actually\n            // creating the image.\n            if(img == null)\n            {\n                URL path = getImageUrl(full_name, dirs);\n                if (path == null)\n                    return null;\n                img = Toolkit.getDefaultToolkit().createImage(path);\n            }\n            cache.put(cache_name, img);\n        }\n\n        return new ImageIcon(img);\n    }","id":41564,"modified_method":"/**\n     * The full path of the image is either a url (starting with http://)\n     * or something like\n     *   dirs.get(i)+\"/\"+subdir+\"/\"+name+\".png\".\n     * @param dirs      Directories to look.\n     * @param id        An id used for caching. Id is not used for cache if name starts with http://. (URL is unique anyway.)\n     * @param subdir    Subdirectory the image lies in.\n     * @param name      The name of the image. If it contains no '.', a png extension is added.\n     * @param archive   A zip file where the image is located.\n     */\n    public static ImageIcon getIfAvailable(Collection<String> dirs, String id, String subdir, String name, File archive) {\n        if (name == null)\n            return null;\n        if (name.startsWith(\"http://\")) {\n            Image img = cache.get(name);\n            if (img == null) {\n                try {\n                    MirroredInputStream is = new MirroredInputStream(name, new File(Main.pref.getPreferencesDir(),\n                    \"images\").toString());\n                    img = Toolkit.getDefaultToolkit().createImage(is.getFile().toURI().toURL());\n                    cache.put(name, img);\n                } catch (IOException e) {\n                }\n            }\n            return img == null ? null : new ImageIcon(img);\n        }\n        if (subdir == null) {\n            subdir = \"\";\n        } else if (!subdir.equals(\"\")) {\n            subdir += \"/\";\n        }\n        String ext = name.indexOf('.') != -1 ? \"\" : \".png\";\n        String full_name = subdir + name + ext;\n        String cache_name = full_name;\n        /* cache separately */\n        if (dirs != null && dirs.size() > 0) {\n            cache_name = \"id:\" + id + \":\" + full_name;\n            if(archive != null) {\n                cache_name += \":\" + archive.getName();\n            }\n        }\n\n        Image img = cache.get(cache_name);\n        if (img == null) {\n            if(archive != null)\n            {\n                try\n                {\n                    ZipFile zipFile = new ZipFile(archive);\n                    ZipEntry entry = zipFile.getEntry(full_name);\n                    if(entry != null)\n                    {\n                        int size = (int)entry.getSize();\n                        int offs = 0;\n                        byte[] buf = new byte[size];\n                        InputStream is = zipFile.getInputStream(entry);\n                        while(size > 0)\n                        {\n                            int l = is.read(buf, offs, size);\n                            offs += l;\n                            size -= l;\n                        }\n                        img = Toolkit.getDefaultToolkit().createImage(buf);\n                    }\n                } catch (Exception e) {\n                    System.err.println(tr(\"Warning: failed to handle zip file ''{0}''. Exception was: {1}\", archive.getName(), e.toString()));\n                }\n            }\n            // getImageUrl() does a ton of \"stat()\" calls and gets expensive\n            // and redundant when you have a whole ton of objects. So,\n            // index the cache by the name of the icon we're looking for\n            // and don't bother to create a URL unless we're actually\n            // creating the image.\n            if(img == null)\n            {\n                URL path = getImageUrl(full_name, dirs);\n                if (path == null)\n                    return null;\n                img = Toolkit.getDefaultToolkit().createImage(path);\n            }\n            cache.put(cache_name, img);\n        }\n\n        return new ImageIcon(img);\n    }","commit_id":"04c632c504387dd51f7fc44732de5546211735ff","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Makes an XML string from an OSM primitive. Uses the OsmWriter class.\n     * @param o the OSM primitive\n     * @param addBody true to generate the full XML, false to only generate the encapsulating tag\n     * @return XML string\n     */\n    private String toXml(OsmPrimitive o, boolean addBody) {\n        swriter.getBuffer().setLength(0);\n        osmWriter.setWithBody(addBody);\n        osmWriter.setChangeset(changeset);\n        osmWriter.header();\n        o.visit(osmWriter);\n        osmWriter.footer();\n        osmWriter.out.flush();\n        return swriter.toString();\n    }","id":41565,"modified_method":"/**\n     * Makes an XML string from an OSM primitive. Uses the OsmWriter class.\n     * @param o the OSM primitive\n     * @param addBody true to generate the full XML, false to only generate the encapsulating tag\n     * @return XML string\n     */\n    private String toXml(OsmPrimitive o, boolean addBody) {\n        swriter.getBuffer().setLength(0);\n        osmWriter.setWithBody(addBody);\n        osmWriter.setChangeset(changeset);\n        osmWriter.header();\n        o.visit(osmWriter);\n        osmWriter.footer();\n        osmWriter.out.flush();\n        String s = swriter.toString();\n        System.err.println(\"OsmApi/toXml:\\n\"+s+\"_|\");\n        return s;\n    }","commit_id":"04c632c504387dd51f7fc44732de5546211735ff","url":"https://github.com/openstreetmap/josm"},{"original_method":"public String getDocument() {\n        return swriter.toString();\n    }","id":41566,"modified_method":"public String getDocument() {\n        String s = swriter.toString();\n        System.err.println(\"OsmChangeBuilder/getDocument:\\n\"+s+\"_|\");\n        return s;\n    }","commit_id":"04c632c504387dd51f7fc44732de5546211735ff","url":"https://github.com/openstreetmap/josm"},{"original_method":"public ERParsedMetadataDirectory parseMetadata(ERUnparsedMetadataDirectory unparsedMetadata) {\n    ERParsedMetadataDirectory parsedMetadataDirectory = null;\n    \n    Metadata metadata = new Metadata();\n    byte[] data = unparsedMetadata.getMetadata();\n    String directoryName = unparsedMetadata.getDirectoryName();\n    if (directoryName.equalsIgnoreCase(IERMetadataDirectory.EXIF)) {\n      new ExifReader(data).extract(metadata);\n      parsedMetadataDirectory = new ERParsedMetadataDirectory(directoryName);\n    }\n    else if (directoryName.equalsIgnoreCase(IERMetadataDirectory.IPTC)) {\n      new IptcReader(data).extract(metadata);\n      parsedMetadataDirectory = new ERParsedMetadataDirectory(directoryName);\n    }\n    \n    if (parsedMetadataDirectory != null) {\n      Iterator directories = metadata.getDirectoryIterator();\n      while (directories.hasNext()) {\n        Directory directory = (Directory) directories.next();\n        DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(parsedMetadataDirectory, directory);\n      }\n    }\n    \n    return parsedMetadataDirectory;\n  }","id":41567,"modified_method":"public ERParsedMetadataDirectory parseMetadata(ERUnparsedMetadataDirectory unparsedMetadata) {\n    ERParsedMetadataDirectory parsedMetadataDirectory = null;\n    \n    Metadata metadata = new Metadata();\n    ByteArrayReader reader = new ByteArrayReader(unparsedMetadata.getMetadata());\n    String directoryName = unparsedMetadata.getDirectoryName();\n    if (directoryName.equalsIgnoreCase(IERMetadataDirectory.EXIF)) {\n      new ExifReader().extract(reader, metadata);\n      parsedMetadataDirectory = new ERParsedMetadataDirectory(directoryName);\n    }\n    else if (directoryName.equalsIgnoreCase(IERMetadataDirectory.IPTC)) {\n      new IptcReader().extract(reader, metadata);\n      parsedMetadataDirectory = new ERParsedMetadataDirectory(directoryName);\n    }\n    \n    if (parsedMetadataDirectory != null) {\n      for (Directory directory : metadata.getDirectories()) {\n        DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(parsedMetadataDirectory, directory);\n      }\n    }\n    \n    return parsedMetadataDirectory;\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERMetadataDirectorySet parseMetadata(File importFile) throws ERMetadataParserException {\n    try {\n      ERMetadataDirectorySet directorySet = new ERMetadataDirectorySet();\n      Metadata metadata = JpegMetadataReader.readMetadata(importFile);\n      Iterator directoryIter = metadata.getDirectoryIterator();\n      while (directoryIter.hasNext()) {\n        Directory directory = (Directory) directoryIter.next();\n        ERParsedMetadataDirectory parsedMetadataDirectory = new ERParsedMetadataDirectory(directory.getName());\n        DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(parsedMetadataDirectory, directory);\n        directorySet.addMetadata(parsedMetadataDirectory);\n      }\n      return directorySet;\n    }\n    catch (JpegProcessingException e) {\n      throw new ERMetadataParserException(\"Failed to parse metadata.\", e);\n    }\n  }","id":41568,"modified_method":"public ERMetadataDirectorySet parseMetadata(File importFile) throws ERMetadataParserException {\n    try {\n      ERMetadataDirectorySet directorySet = new ERMetadataDirectorySet();\n      Metadata metadata = JpegMetadataReader.readMetadata(importFile);\n      for (Directory directory : metadata.getDirectories()) {\n        ERParsedMetadataDirectory parsedMetadataDirectory = new ERParsedMetadataDirectory(directory.getName());\n        DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(parsedMetadataDirectory, directory);\n        directorySet.addMetadata(parsedMetadataDirectory);\n      }\n      return directorySet;\n    }\n    catch (JpegProcessingException e) {\n      throw new ERMetadataParserException(\"Failed to parse metadata.\", e);\n    } catch (IOException e) {\n      throw new ERMetadataParserException(\"Failed to read metadata from file \" + importFile.getName() + \".\", e);\n\t}\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void fillInParsedMetadataDirectoryFromDrewMetadata(ERParsedMetadataDirectory parsedMetadataDirectory, Directory directory) {\n    String directoryName = directory.getName();\n    boolean isEXIF = IERMetadataDirectory.EXIF.equalsIgnoreCase(directoryName);\n    Iterator tags = directory.getTagIterator();\n    while (tags.hasNext()) {\n      Tag tag = (Tag) tags.next();\n      try {\n        String tagName = tag.getTagName();\n        String tagValue = tag.getDescription();\n        int tagType = tag.getTagType();\n        // System.out.println(\"ImageMagickJNIFilter.importMetadata: \" + directoryName + \", \" + tagName + \"=\" + tagValue);\n        // 0x927C = Maker Note, which is a crazy binary block, but purports to be a String\n        boolean isMakerNote = tagType == 0x927C && isEXIF;\n        boolean isUnknown = tagName.startsWith(DrewMetadataParser.UNKNOWN_TAG);\n        if (!isUnknown && !isMakerNote) {\n          parsedMetadataDirectory.addMetadataEntry(new ERMetadataEntry(tagType, tagName, tagValue, ERMetadataUtils.classForTagName(directoryName, tagName)));\n        }\n        else {\n          // NSLog.out.appendln(\"Skipped \" + tagType + \": \" + tagValue);\n        }\n      }\n      catch (MetadataException t) {\n        NSLog.out.appendln(t);\n      }\n    }\n    /*\n     if (directory.hasErrors()) {\n     Iterator errors = directory.getErrors();\n     while (errors.hasNext()) {\n     NSLog.out.appendln(\"Error: \" + errors.next());\n     }\n     }\n     */\n  }","id":41569,"modified_method":"public static void fillInParsedMetadataDirectoryFromDrewMetadata(ERParsedMetadataDirectory parsedMetadataDirectory, Directory directory) {\n    String directoryName = directory.getName();\n    boolean isEXIF = IERMetadataDirectory.EXIF.equalsIgnoreCase(directoryName);\n    for (Tag tag : directory.getTags()) {\n        String tagName = tag.getTagName();\n        String tagValue = tag.getDescription();\n        int tagType = tag.getTagType();\n        // System.out.println(\"ImageMagickJNIFilter.importMetadata: \" + directoryName + \", \" + tagName + \"=\" + tagValue);\n        // 0x927C = Maker Note, which is a crazy binary block, but purports to be a String\n        boolean isMakerNote = tagType == 0x927C && isEXIF;\n        boolean isUnknown = tagName.startsWith(DrewMetadataParser.UNKNOWN_TAG);\n        if (!isUnknown && !isMakerNote) {\n          parsedMetadataDirectory.addMetadataEntry(new ERMetadataEntry(tagType, tagName, tagValue, ERMetadataUtils.classForTagName(directoryName, tagName)));\n        }\n        else {\n          // NSLog.out.appendln(\"Skipped \" + tagType + \": \" + tagValue);\n        }\n    }\n    /*\n     if (directory.hasErrors()) {\n     Iterator errors = directory.getErrors();\n     while (errors.hasNext()) {\n     NSLog.out.appendln(\"Error: \" + errors.next());\n     }\n     }\n     */\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERMetadataDirectorySet parseMetadata(File importFile) throws ERMetadataParserException {\n    try {\n      ERMetadataDirectorySet rawAssetMetadata = new ERMetadataDirectorySet();\n      ImageInputStream imageInputStream = ImageIO.createImageInputStream(importFile);\n      try {\n        Iterator imageReadersIter = ImageIO.getImageReaders(imageInputStream);\n        while (imageReadersIter.hasNext()) {\n          ImageReader imageReader = (ImageReader) imageReadersIter.next();\n          imageReader.setInput(imageInputStream);\n          rawAssetMetadata.setWidth(imageReader.getWidth(0));\n          rawAssetMetadata.setHeight(imageReader.getHeight(0));\n          IIOMetadata metadata = imageReader.getImageMetadata(0);\n          if (metadata != null) {\n            Node metadataTree = metadata.getAsTree(metadata.getNativeMetadataFormatName());\n            if (metadataTree != null) {\n              IptcDirectory iptcDirectory = getIptcDirectory(metadataTree);\n              if (iptcDirectory != null) {\n                ERParsedMetadataDirectory iptcMetadataDirectory = new ERParsedMetadataDirectory(IERMetadataDirectory.IPTC);\n                DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(iptcMetadataDirectory, iptcDirectory);\n                rawAssetMetadata.addMetadata(iptcMetadataDirectory);\n              }\n\n              ExifDirectory exifDirectory = getExifDirectory(metadataTree);\n              if (exifDirectory != null) {\n                ERParsedMetadataDirectory exifMetadataDirectory = new ERParsedMetadataDirectory(IERMetadataDirectory.EXIF);\n                DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(exifMetadataDirectory, exifDirectory);\n                rawAssetMetadata.addMetadata(exifMetadataDirectory);\n              }\n            }\n          }\n        }\n      }\n      finally {\n        imageInputStream.close();\n      }\n      return rawAssetMetadata;\n    }\n    catch (IOException e) {\n      throw new ERMetadataParserException(\"Failed to parse metadata.\", e);\n    }\n  }","id":41570,"modified_method":"public ERMetadataDirectorySet parseMetadata(File importFile) throws ERMetadataParserException {\n    try {\n      ERMetadataDirectorySet rawAssetMetadata = new ERMetadataDirectorySet();\n      ImageInputStream imageInputStream = ImageIO.createImageInputStream(importFile);\n      try {\n        Iterator imageReadersIter = ImageIO.getImageReaders(imageInputStream);\n        while (imageReadersIter.hasNext()) {\n          ImageReader imageReader = (ImageReader) imageReadersIter.next();\n          imageReader.setInput(imageInputStream);\n          rawAssetMetadata.setWidth(imageReader.getWidth(0));\n          rawAssetMetadata.setHeight(imageReader.getHeight(0));\n          IIOMetadata metadata = imageReader.getImageMetadata(0);\n          if (metadata != null) {\n            Node metadataTree = metadata.getAsTree(metadata.getNativeMetadataFormatName());\n            if (metadataTree != null) {\n              IptcDirectory iptcDirectory = getIptcDirectory(metadataTree);\n              if (iptcDirectory != null) {\n                ERParsedMetadataDirectory iptcMetadataDirectory = new ERParsedMetadataDirectory(IERMetadataDirectory.IPTC);\n                DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(iptcMetadataDirectory, iptcDirectory);\n                rawAssetMetadata.addMetadata(iptcMetadataDirectory);\n              }\n\n              ExifIFD0Directory exifDirectory = getExifDirectory(metadataTree);\n              if (exifDirectory != null) {\n                ERParsedMetadataDirectory exifMetadataDirectory = new ERParsedMetadataDirectory(IERMetadataDirectory.EXIF);\n                DrewMetadataParser.fillInParsedMetadataDirectoryFromDrewMetadata(exifMetadataDirectory, exifDirectory);\n                rawAssetMetadata.addMetadata(exifMetadataDirectory);\n              }\n            }\n          }\n        }\n      }\n      finally {\n        imageInputStream.close();\n      }\n      return rawAssetMetadata;\n    }\n    catch (IOException e) {\n      throw new ERMetadataParserException(\"Failed to parse metadata.\", e);\n    }\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"private IptcDirectory getIptcDirectory(Node node) {\n    if (\"unknown\".equals(node.getNodeName())) {\n      if (Integer.parseInt(node.getAttributes().getNamedItem(\"MarkerTag\").getNodeValue()) == IPTC) {\n        byte[] data = (byte[]) ((IIOMetadataNode) node).getUserObject();\n        IptcDirectory iptcDirectory = (IptcDirectory) new IptcReader(data).extract().getDirectory(IptcDirectory.class);\n        return iptcDirectory;\n      }\n    }\n\n    Node child = node.getFirstChild();\n    while (child != null) {\n      IptcDirectory directory = getIptcDirectory(child);\n      if (directory != null) {\n        return directory;\n      }\n      child = child.getNextSibling();\n    }\n    return null;\n  }","id":41571,"modified_method":"private IptcDirectory getIptcDirectory(Node node) {\n    if (\"unknown\".equals(node.getNodeName())) {\n      if (Integer.parseInt(node.getAttributes().getNamedItem(\"MarkerTag\").getNodeValue()) == IPTC) {\n    \tByteArrayReader reader = new ByteArrayReader((byte[]) ((IIOMetadataNode) node).getUserObject());\n    \tMetadata metadata = new Metadata();\n    \tnew IptcReader().extract(reader, metadata);\n        return metadata.getDirectory(IptcDirectory.class);\n      }\n    }\n\n    Node child = node.getFirstChild();\n    while (child != null) {\n      IptcDirectory directory = getIptcDirectory(child);\n      if (directory != null) {\n        return directory;\n      }\n      child = child.getNextSibling();\n    }\n    return null;\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"private ExifDirectory getExifDirectory(Node node) {\n    if (\"unknown\".equals(node.getNodeName())) {\n      if (Integer.parseInt(node.getAttributes().getNamedItem(\"MarkerTag\").getNodeValue()) == EXIF) {\n        byte[] data = (byte[]) ((IIOMetadataNode) node).getUserObject();\n        return (ExifDirectory) new ExifReader(data).extract().getDirectory(ExifDirectory.class);\n      }\n    }\n\n    Node child = node.getFirstChild();\n    while (child != null) {\n      ExifDirectory directory = getExifDirectory(child);\n      if (directory != null) {\n        return directory;\n      }\n      child = child.getNextSibling();\n    }\n    return null;\n  }","id":41572,"modified_method":"private ExifIFD0Directory getExifDirectory(Node node) {\n    if (\"unknown\".equals(node.getNodeName())) {\n      if (Integer.parseInt(node.getAttributes().getNamedItem(\"MarkerTag\").getNodeValue()) == EXIF) {\n    \tByteArrayReader reader = new ByteArrayReader((byte[]) ((IIOMetadataNode) node).getUserObject());\n    \tMetadata metadata = new Metadata();\n    \tnew ExifReader().extract(reader, metadata);\n    \treturn metadata.getDirectory(ExifIFD0Directory.class);\n      }\n    }\n\n    Node child = node.getFirstChild();\n    while (child != null) {\n      ExifIFD0Directory directory = getExifDirectory(child);\n      if (directory != null) {\n        return directory;\n      }\n      child = child.getNextSibling();\n    }\n    return null;\n  }","commit_id":"ef8ff5edef1ab61daf5791cb48beffaf7539ae3b","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorOutputImpl(DirectoryScannerProcessor.this, name) {\n            public void readImpl(PipelineContext context, XMLReceiver xmlReceiver) {\n\n                // Read config\n                final Config config = readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader<Config>() {\n                    public Config read(PipelineContext context, ProcessorInput input) {\n\n                        final Document configNode = readInputAsDOM4J(context, input);\n                        final Config config = new Config();\n\n                        final String baseDirectoryURLString = XPathUtils.selectStringValueNormalize(configNode, \"/config/base-directory\").trim();\n\n                        // Use location data if present so that relative URLs can be supported\n                        final LocationData locationData = getLocationData();\n                        final URL fullURL;\n                        final String realPath;\n                        try {\n                            fullURL = (locationData != null && locationData.getSystemID() != null)\n                                                            ? URLFactory.createURL(locationData.getSystemID(), baseDirectoryURLString)\n                                                            : URLFactory.createURL(baseDirectoryURLString);\n\n                            if (fullURL.getProtocol().equals(\"oxf\")) {\n                                // Get real path to resource path if possible\n                                realPath = ResourceManagerWrapper.instance().getRealPath(fullURL.getFile());\n                                if (realPath == null)\n                                    throw new OXFException(\"Directory Scanner processor is unable to obtain the real path of the file using the oxf: protocol for the base-directory property: \" + baseDirectoryURLString);\n                            } else if (fullURL.getProtocol().equals(\"file\")) {\n                                String host = fullURL.getHost();\n                                realPath = host + (host.length() > 0 ? \":\" : \"\") + fullURL.getFile();\n                            } else {\n                                throw new OXFException(\"Directory Scanner processor only supports the file: and oxf: protocols for the base-directory property: \" + baseDirectoryURLString);\n                            }\n\n                        } catch (MalformedURLException e) {\n                            throw new OXFException(e);\n                        }\n                        config.setBaseDirectory(realPath);\n\n                        for (Iterator i = XPathUtils.selectIterator(configNode, \"/config/include\"); i.hasNext();) {\n                            final Node node = (Node) i.next();\n                            final String value = XPathUtils.selectStringValueNormalize(node, \".\");\n                            if (value != null)\n                                config.addInclude(value);\n                        }\n                        for (Iterator i = XPathUtils.selectIterator(configNode, \"/config/exclude\"); i.hasNext();) {\n                            final Node node = (Node) i.next();\n                            final String value = XPathUtils.selectStringValueNormalize(node, \".\");\n                            if (value != null)\n                                config.addExclude(value);\n                        }\n                        final boolean caseSensitive = ProcessorUtils.selectBooleanValue(configNode, \"/config/case-sensitive\", DEFAULT_CASE_SENSITIVE);\n                        config.setCaseSensitive(caseSensitive);\n                        final boolean defaultExcludes = ProcessorUtils.selectBooleanValue(configNode, \"/config/default-excludes\", DEFAULT_DEFAULT_EXCLUDES);\n                        config.setDefaultExcludes(defaultExcludes);\n\n                        final boolean basicInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/basic-info\", DEFAULT_BASIC_INFO);\n                        config.setBasicInfo(basicInfo);\n                        final boolean exifInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/exif-info\", DEFAULT_EXIF_INFO);\n                        config.setExifInfo(exifInfo);\n                        final boolean iptcInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/iptc-info\", DEFAULT_IPTC_INFO);\n                        config.setIptcInfo(iptcInfo);\n\n                        // TODO: sorting\n                        // TODO: use-ant-patterns (default and only currently supported), follow-symlinks\n                        // TODO: more generalized content-type detection\n                        // TODO: WebDAV support, and/or integration with resource manager\n                        // TODO: option to list excluded and not-included?\n\n                        return config;\n                    }\n                });\n\n                // Create and configure directory scanner\n                final DirectoryScanner ds = new DirectoryScanner();\n\n                if (config.isDefaultExcludes())\n                    ds.addDefaultExcludes();\n                if (config.getIncludes() != null)\n                    ds.setIncludes(config.getIncludes());\n                if (config.getExcludes() != null)\n                    ds.setExcludes(config.getExcludes());\n                ds.setBasedir(config.getBaseDirectory());\n                ds.setCaseSensitive(config.isCaseSensitive());\n\n                // Set the event listener\n                final ContentHandlerHelper helper = new ContentHandlerHelper(xmlReceiver);\n                ds.setEventListener(new DirectoryScanner.EventListener() {\n\n                    private List<String> pathNames = new ArrayList<String>();\n                    private List<String> paths = new ArrayList<String>();\n                    private int pathLevel = 0;\n\n                    private void enterDirectory(String path, String name, boolean included) {\n                        if (name.equals(\"\"))\n                            return;\n                        try {\n                            if (included) {\n                                outputPath();\n                                pathLevel++;\n                                helper.startElement(DIRECTORY_ELEMENT, new String[] {\"name\", name, \"path\", path + name, \"included\", \"true\"});\n                            }\n                            pathNames.add(name);\n                            paths.add(path);\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    private void exitDirectory(String name) {\n                        if (name.equals(\"\"))\n                            return;\n                        try {\n                            if (pathNames.size() <= pathLevel) {\n                                helper.endElement();\n                                pathLevel--;\n                            }\n                            pathNames.remove(pathNames.size() - 1);\n                            paths.remove(paths.size() - 1);\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    private void outputPath() {\n                        try {\n                            for (int i = pathLevel; i < pathNames.size(); i++) {\n                                String name = pathNames.get(i);\n                                String path = paths.get(i);\n                                helper.startElement(DIRECTORY_ELEMENT, new String[] {\"name\", name, \"path\", path + name});\n                            }\n                            pathLevel = pathNames.size();\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void deselectedFile(String path, String name) {\n                    }\n\n                    public void excludedFile(String path, String name) {\n                    }\n\n                    public void includedFile(String path, String name) {\n                        outputPath();\n                        try {\n                            String filePath = path + name;\n                            File file = new File(config.getBaseDirectory(), filePath);\n                            long lastModified = file.lastModified();\n                            String lastModifiedDate = DateUtils.DateTime().print(lastModified);\n                            long fileSize = file.length();\n\n                            helper.startElement(FILE_ELEMENT, new String[]{\"last-modified-ms\", Long.toString(lastModified),\n                                                                           \"last-modified-date\", lastModifiedDate,\n                                                                           \"size\", Long.toString(fileSize),\n                                                                           \"path\", filePath,\n                                                                           \"name\", name});\n\n                            if (config.isImageMetadata()) {\n                                outputImageMetadata(helper, config, file);\n                            }\n\n                            helper.endElement();\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void notIncludedFile(String path, String name) {\n                    }\n\n                    public void endDeselectedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endExcludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endIncludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endNotIncludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void startDeselectedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n\n                    public void startExcludedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n\n                    public void startIncludedDir(String path, String name) {\n                        enterDirectory(path, name, true);\n                    }\n\n                    public void startNotIncludedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n                });\n\n                // Output elements\n                try {\n                    final String baseDirectoryString = config.getBaseDirectory();\n                    final File baseDirectoryFile = new File(baseDirectoryString);\n                    if (!baseDirectoryFile.isDirectory())\n                        throw new OXFException(\"base-directory element does not point to an existing directory: \" + baseDirectoryString);\n                    final String baseDirectoryName = baseDirectoryFile.getCanonicalFile().getName();\n\n                    helper.startDocument();\n                    helper.startElement(DIRECTORY_ELEMENT, new String[] { \"name\", baseDirectoryName, \"path\", baseDirectoryString });\n\n                    // Do the scan\n                    ds.scan();\n\n//                    String[] directories = ds.getIncludedDirectories();\n//                    String[] files = ds.getIncludedFiles();\n//\n//                    for (int i = 0; i < directories.length; i++)\n//                        directories[i] = directories[i] + File.separator;\n//\n//                    String[] all = new String[directories.length + files.length];\n//                    Arrays.sort(all);\n//\n//                    for (int i = 0; i < all.length; i++) {\n//                        String current = all[i];\n//                        boolean isDirectory = current.endsWith(File.separator);\n//\n//                    }\n\n                    helper.endElement();\n                    helper.endDocument();\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n\n        };\n        addOutput(name, output);\n        return output;\n    }","id":41573,"modified_method":"@Override\n    public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorOutputImpl(DirectoryScannerProcessor.this, name) {\n            public void readImpl(PipelineContext context, XMLReceiver xmlReceiver) {\n\n                // Read config\n                final Config config = readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader<Config>() {\n                    public Config read(PipelineContext context, ProcessorInput input) {\n\n                        final Document configNode = readInputAsDOM4J(context, input);\n                        final Config config = new Config();\n\n                        final String baseDirectoryURLString = XPathUtils.selectStringValueNormalize(configNode, \"/config/base-directory\").trim();\n\n                        // Use location data if present so that relative URLs can be supported\n                        final LocationData locationData = getLocationData();\n\n                        final String realPath = NetUtils.getRealPath(baseDirectoryURLString, locationData);\n                        config.setBaseDirectory(realPath);\n\n                        for (Iterator i = XPathUtils.selectIterator(configNode, \"/config/include\"); i.hasNext();) {\n                            final Node node = (Node) i.next();\n                            final String value = XPathUtils.selectStringValueNormalize(node, \".\");\n                            if (value != null)\n                                config.addInclude(value);\n                        }\n                        for (Iterator i = XPathUtils.selectIterator(configNode, \"/config/exclude\"); i.hasNext();) {\n                            final Node node = (Node) i.next();\n                            final String value = XPathUtils.selectStringValueNormalize(node, \".\");\n                            if (value != null)\n                                config.addExclude(value);\n                        }\n                        final boolean caseSensitive = ProcessorUtils.selectBooleanValue(configNode, \"/config/case-sensitive\", DEFAULT_CASE_SENSITIVE);\n                        config.setCaseSensitive(caseSensitive);\n                        final boolean defaultExcludes = ProcessorUtils.selectBooleanValue(configNode, \"/config/default-excludes\", DEFAULT_DEFAULT_EXCLUDES);\n                        config.setDefaultExcludes(defaultExcludes);\n\n                        final boolean basicInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/basic-info\", DEFAULT_BASIC_INFO);\n                        config.setBasicInfo(basicInfo);\n                        final boolean exifInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/exif-info\", DEFAULT_EXIF_INFO);\n                        config.setExifInfo(exifInfo);\n                        final boolean iptcInfo = ProcessorUtils.selectBooleanValue(configNode, \"/config/image-metadata/iptc-info\", DEFAULT_IPTC_INFO);\n                        config.setIptcInfo(iptcInfo);\n\n                        // TODO: sorting\n                        // TODO: use-ant-patterns (default and only currently supported), follow-symlinks\n                        // TODO: more generalized content-type detection\n                        // TODO: WebDAV support, and/or integration with resource manager\n                        // TODO: option to list excluded and not-included?\n\n                        return config;\n                    }\n                });\n\n                // Create and configure directory scanner\n                final DirectoryScanner ds = new DirectoryScanner();\n\n                if (config.isDefaultExcludes())\n                    ds.addDefaultExcludes();\n                if (config.getIncludes() != null)\n                    ds.setIncludes(config.getIncludes());\n                if (config.getExcludes() != null)\n                    ds.setExcludes(config.getExcludes());\n                ds.setBasedir(config.getBaseDirectory());\n                ds.setCaseSensitive(config.isCaseSensitive());\n\n                // Set the event listener\n                final ContentHandlerHelper helper = new ContentHandlerHelper(xmlReceiver);\n                ds.setEventListener(new DirectoryScanner.EventListener() {\n\n                    private List<String> pathNames = new ArrayList<String>();\n                    private List<String> paths = new ArrayList<String>();\n                    private int pathLevel = 0;\n\n                    private void enterDirectory(String path, String name, boolean included) {\n                        if (name.equals(\"\"))\n                            return;\n                        try {\n                            if (included) {\n                                outputPath();\n                                pathLevel++;\n                                helper.startElement(DIRECTORY_ELEMENT, new String[] {\"name\", name, \"path\", path + name, \"included\", \"true\"});\n                            }\n                            pathNames.add(name);\n                            paths.add(path);\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    private void exitDirectory(String name) {\n                        if (name.equals(\"\"))\n                            return;\n                        try {\n                            if (pathNames.size() <= pathLevel) {\n                                helper.endElement();\n                                pathLevel--;\n                            }\n                            pathNames.remove(pathNames.size() - 1);\n                            paths.remove(paths.size() - 1);\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    private void outputPath() {\n                        try {\n                            for (int i = pathLevel; i < pathNames.size(); i++) {\n                                String name = pathNames.get(i);\n                                String path = paths.get(i);\n                                helper.startElement(DIRECTORY_ELEMENT, new String[] {\"name\", name, \"path\", path + name});\n                            }\n                            pathLevel = pathNames.size();\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void deselectedFile(String path, String name) {\n                    }\n\n                    public void excludedFile(String path, String name) {\n                    }\n\n                    public void includedFile(String path, String name) {\n                        outputPath();\n                        try {\n                            String filePath = path + name;\n                            File file = new File(config.getBaseDirectory(), filePath);\n                            long lastModified = file.lastModified();\n                            String lastModifiedDate = DateUtils.DateTime().print(lastModified);\n                            long fileSize = file.length();\n\n                            helper.startElement(FILE_ELEMENT, new String[]{\"last-modified-ms\", Long.toString(lastModified),\n                                                                           \"last-modified-date\", lastModifiedDate,\n                                                                           \"size\", Long.toString(fileSize),\n                                                                           \"path\", filePath,\n                                                                           \"name\", name});\n\n                            if (config.isImageMetadata()) {\n                                outputImageMetadata(helper, config, file);\n                            }\n\n                            helper.endElement();\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void notIncludedFile(String path, String name) {\n                    }\n\n                    public void endDeselectedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endExcludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endIncludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void endNotIncludedDir(String path, String name) {\n                        exitDirectory(name);\n                    }\n\n                    public void startDeselectedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n\n                    public void startExcludedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n\n                    public void startIncludedDir(String path, String name) {\n                        enterDirectory(path, name, true);\n                    }\n\n                    public void startNotIncludedDir(String path, String name) {\n                        enterDirectory(path, name, false);\n                    }\n                });\n\n                // Output elements\n                try {\n                    final String baseDirectoryString = config.getBaseDirectory();\n                    final File baseDirectoryFile = new File(baseDirectoryString);\n                    if (!baseDirectoryFile.isDirectory())\n                        throw new OXFException(\"base-directory element does not point to an existing directory: \" + baseDirectoryString);\n                    final String baseDirectoryName = baseDirectoryFile.getCanonicalFile().getName();\n\n                    helper.startDocument();\n                    helper.startElement(DIRECTORY_ELEMENT, new String[] { \"name\", baseDirectoryName, \"path\", baseDirectoryString });\n\n                    // Do the scan\n                    ds.scan();\n\n//                    String[] directories = ds.getIncludedDirectories();\n//                    String[] files = ds.getIncludedFiles();\n//\n//                    for (int i = 0; i < directories.length; i++)\n//                        directories[i] = directories[i] + File.separator;\n//\n//                    String[] all = new String[directories.length + files.length];\n//                    Arrays.sort(all);\n//\n//                    for (int i = 0; i < all.length; i++) {\n//                        String current = all[i];\n//                        boolean isDirectory = current.endsWith(File.separator);\n//\n//                    }\n\n                    helper.endElement();\n                    helper.endDocument();\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"ce77d43d0b919b094b07a86b03a3d78160232bc2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(PipelineContext context) {\n        try {\n            // Read config\n            final Document config = readCacheInputAsDOM4J(context, INPUT_CONFIG);\n\n            for (Iterator i = XPathUtils.selectIterator(config, \"/*/*\"); i.hasNext();) {\n                final Element currentElement = (Element) i.next();\n                if (currentElement.getName().equals(\"delete\")) {\n                    // delete operation\n\n\n                    // Get file object\n                    final File file = FileSerializer.getFile(\n                            XPathUtils.selectStringValueNormalize(currentElement, \"directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"url\"),\n                            getLocationData(),\n                            false,\n                            getPropertySet()\n                            );\n\n                    // Delete file if it exists\n                    if (file.exists() && file.canWrite()) {\n                        final boolean deleted = file.delete();\n                        if (!deleted)\n                            throw new OXFException(\"Can't delete file: \" + file);\n                    }\n                } else if (currentElement.getName().equals(\"move\")) {\n                    // Move operation\n\n                    // From\n                    final File fromFile = FileSerializer.getFile(\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/url\"),\n                            getLocationData(),\n                            false,\n                            getPropertySet()\n                            );\n\n                    if (!fromFile.exists() || ! fromFile.canRead()) {\n                        throw new OXFException(\"Can't move file: \" + fromFile);    \n                    }\n\n                    // To\n                    final File toFile = FileSerializer.getFile(\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/url\"),\n                            getLocationData(),\n                            ProcessorUtils.selectBooleanValue(currentElement, \"to/make-directories\", DEFAULT_MAKE_DIRECTORIES),\n                            getPropertySet()\n                            );\n\n                    if (! (toFile.exists() || toFile.createNewFile() )) {\n                        throw new OXFException(\"Can't create file: \" + toFile);\n                    }\n\n                    // Move\n                    if (! fromFile.renameTo(toFile)) {\n                        // If for whatever reason renameTo fails, try to copy and delete it \n                        copyFile(fromFile, toFile);\n                        final boolean deleted = fromFile.delete();\n                        if (!deleted)\n                            throw new OXFException(\"Can't delete file \" + fromFile + \" after copying it to \" + toFile);\n\n                    }\n\n\n                } else if (currentElement.getName().equals(\"copy\")) {\n                    // Copy operation\n\n                    // From\n                    final File fromFile = FileSerializer.getFile(\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/url\"),\n                            getLocationData(),\n                            false,\n                            getPropertySet()\n                            );\n\n                    if (!fromFile.exists() || ! fromFile.canRead()) {\n                        throw new OXFException(\"Can't copy file: \" + fromFile);\n                    }\n\n                    // To\n                    final File toFile = FileSerializer.getFile(\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/url\"),\n                            getLocationData(),\n                            ProcessorUtils.selectBooleanValue(currentElement, \"to/make-directories\", DEFAULT_MAKE_DIRECTORIES),\n                            getPropertySet()\n                            );\n\n                    if (! (toFile.exists() || toFile.createNewFile() )) {\n                        throw new OXFException(\"Can't create file: \" + toFile);\n                    }\n\n                    // Copy\n                    copyFile(fromFile, toFile);\n\n\n                } else if (currentElement.getName().equals(\"scp\")) {\n                    // scp operation\n\n                    // Create ant task\n                    final Scp scp = new Scp() {\n                        @Override\n                        public void log(String msg, int msgLevel) {\n                            switch (msgLevel) {\n                                case Project.MSG_ERR:\n                                    logger.error(msg);\n                                    break;\n                                case Project.MSG_WARN:\n                                    logger.warn(msg);\n                                    break;\n                                case Project.MSG_INFO:\n                                    logger.info(msg);\n                                    break;\n                                case Project.MSG_VERBOSE:\n                                case Project.MSG_DEBUG:\n                                    logger.debug(msg);\n                                    break;\n                            }\n                        }\n\n                        private final Project project = new Project() {\n                            @Override\n                            public File getBaseDir() {\n                                return super.getBaseDir();\n                            }\n                        };\n\n                        @Override\n                        public Project getProject() {\n                            return project;\n                        }\n                    };\n                    scp.init();\n\n                    // Set it up\n                    setupScp(scp, currentElement);\n\n                    // Execute it\n                    scp.execute();\n                }\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":41574,"modified_method":"public void start(PipelineContext context) {\n        try {\n            // Read config\n            final Document config = readCacheInputAsDOM4J(context, INPUT_CONFIG);\n\n            for (Iterator i = XPathUtils.selectIterator(config, \"/*/*\"); i.hasNext();) {\n                final Element currentElement = (Element) i.next();\n                if (currentElement.getName().equals(\"delete\")) {\n                    // delete operation\n\n\n                    // Get file object\n                    final File file = NetUtils.getFile(\n                            getDirectory(currentElement, \"directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"url\"),\n                            getLocationData(),\n                            false\n                    );\n\n                    // Delete file if it exists\n                    if (file.exists() && file.canWrite()) {\n                        final boolean deleted = file.delete();\n                        if (!deleted)\n                            throw new OXFException(\"Can't delete file: \" + file);\n                    }\n                } else if (currentElement.getName().equals(\"move\")) {\n                    // Move operation\n\n                    // From\n                    final File fromFile = NetUtils.getFile(\n                            getDirectory(currentElement, \"from/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/url\"),\n                            getLocationData(),\n                            false\n                            );\n\n                    if (!fromFile.exists() || ! fromFile.canRead()) {\n                        throw new OXFException(\"Can't move file: \" + fromFile);    \n                    }\n\n                    // To\n                    final File toFile = NetUtils.getFile(\n                            getDirectory(currentElement, \"to/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/url\"),\n                            getLocationData(),\n                            ProcessorUtils.selectBooleanValue(currentElement, \"to/make-directories\", DEFAULT_MAKE_DIRECTORIES)\n                            );\n\n                    if (! (toFile.exists() || toFile.createNewFile() )) {\n                        throw new OXFException(\"Can't create file: \" + toFile);\n                    }\n\n                    // Move\n                    if (! fromFile.renameTo(toFile)) {\n                        // If for whatever reason renameTo fails, try to copy and delete it \n                        copyFile(fromFile, toFile);\n                        final boolean deleted = fromFile.delete();\n                        if (!deleted)\n                            throw new OXFException(\"Can't delete file \" + fromFile + \" after copying it to \" + toFile);\n\n                    }\n\n\n                } else if (currentElement.getName().equals(\"copy\")) {\n                    // Copy operation\n\n                    // From\n                    final File fromFile = NetUtils.getFile(\n                            getDirectory(currentElement, \"from/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"from/url\"),\n                            getLocationData(),\n                            false\n                            );\n\n                    if (!fromFile.exists() || ! fromFile.canRead()) {\n                        throw new OXFException(\"Can't copy file: \" + fromFile);\n                    }\n\n                    // To\n                    final File toFile = NetUtils.getFile(\n                            getDirectory(currentElement, \"to/directory\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/file\"),\n                            XPathUtils.selectStringValueNormalize(currentElement, \"to/url\"),\n                            getLocationData(),\n                            ProcessorUtils.selectBooleanValue(currentElement, \"to/make-directories\", DEFAULT_MAKE_DIRECTORIES)\n                            );\n\n                    if (! (toFile.exists() || toFile.createNewFile() )) {\n                        throw new OXFException(\"Can't create file: \" + toFile);\n                    }\n\n                    // Copy\n                    copyFile(fromFile, toFile);\n\n\n                } else if (currentElement.getName().equals(\"scp\")) {\n                    // scp operation\n\n                    // Create ant task\n                    final Scp scp = new Scp() {\n                        @Override\n                        public void log(String msg, int msgLevel) {\n                            switch (msgLevel) {\n                                case Project.MSG_ERR:\n                                    logger.error(msg);\n                                    break;\n                                case Project.MSG_WARN:\n                                    logger.warn(msg);\n                                    break;\n                                case Project.MSG_INFO:\n                                    logger.info(msg);\n                                    break;\n                                case Project.MSG_VERBOSE:\n                                case Project.MSG_DEBUG:\n                                    logger.debug(msg);\n                                    break;\n                            }\n                        }\n\n                        private final Project project = new Project() {\n                            @Override\n                            public File getBaseDir() {\n                                return super.getBaseDir();\n                            }\n                        };\n\n                        @Override\n                        public Project getProject() {\n                            return project;\n                        }\n                    };\n                    scp.init();\n\n                    // Set it up\n                    setupScp(scp, currentElement);\n\n                    // Execute it\n                    scp.execute();\n                }\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"ce77d43d0b919b094b07a86b03a3d78160232bc2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public void start(PipelineContext context) {\n        try {\n            // Read config\n            final Config config = readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader<Config>() {\n                public Config read(PipelineContext context, ProcessorInput input) {\n                    return new Config(readInputAsDOM4J(context, input));\n                }\n            });\n\n            final ProcessorInput dataInput = getInputByName(INPUT_DATA);\n\n            // Get file object\n            final File file = getFile(config.getDirectory(), config.getFile(), config.getUrl(), getLocationData(), config.isMakeDirectories(), getPropertySet());\n\n            // NOTE: Caching here is broken, so we never cache. This is what we should do in case\n            // we want caching:\n            // o for a given file, store a hash of the content stored (or the input key?)\n            // o then when we check whether we need to modify the file, check against the key\n            //   AND the validity\n\n            // Delete file if it exists, unless we append\n            if (!config.isAppend() && file.exists()) {\n                final boolean deleted = file.delete();\n                // We test on file.exists() here again so we don't complain that the file can't be deleted if it got\n                // deleted just between our last test and the delete operation.\n                if (!deleted && file.exists())\n                    throw new OXFException(\"Can't delete file: \" + file);\n            }\n\n            // Create file if needed\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file, config.isAppend());\n            writeToFile(context, config, dataInput, fileOutputStream);\n\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":41575,"modified_method":"@Override\n    public void start(PipelineContext context) {\n        try {\n            // Read config\n            final Config config = readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader<Config>() {\n                public Config read(PipelineContext context, ProcessorInput input) {\n                    return new Config(readInputAsDOM4J(context, input));\n                }\n            });\n\n            final ProcessorInput dataInput = getInputByName(INPUT_DATA);\n\n            // Get file object\n            final String directory = config.getDirectory() != null ? config.getDirectory() : getPropertySet().getString(DIRECTORY_PROPERTY);\n            final File file = NetUtils.getFile(directory, config.getFile(), config.getUrl(), getLocationData(), config.isMakeDirectories());\n\n            // NOTE: Caching here is broken, so we never cache. This is what we should do in case\n            // we want caching:\n            // o for a given file, store a hash of the content stored (or the input key?)\n            // o then when we check whether we need to modify the file, check against the key\n            //   AND the validity\n\n            // Delete file if it exists, unless we append\n            if (!config.isAppend() && file.exists()) {\n                final boolean deleted = file.delete();\n                // We test on file.exists() here again so we don't complain that the file can't be deleted if it got\n                // deleted just between our last test and the delete operation.\n                if (!deleted && file.exists())\n                    throw new OXFException(\"Can't delete file: \" + file);\n            }\n\n            // Create file if needed\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file, config.isAppend());\n            writeToFile(context, config, dataInput, fileOutputStream);\n\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"ce77d43d0b919b094b07a86b03a3d78160232bc2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Nullable\n    private Pair<VirtualFile, ? extends MoveDestination> selectPackageBasedTargetDirAndDestination(boolean askIfDoesNotExist) {\n        String packageName = getTargetPackage();\n\n        RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n        PackageWrapper targetPackage = new PackageWrapper(PsiManager.getInstance(myProject), packageName);\n        if (!targetPackage.exists() && askIfDoesNotExist) {\n            int ret = Messages.showYesNoDialog(myProject, RefactoringBundle.message(\"package.does.not.exist\", packageName),\n                                               RefactoringBundle.message(\"move.title\"), Messages.getQuestionIcon());\n            if (ret != Messages.YES) return null;\n        }\n\n        PsiDirectory selectedPsiDirectory;\n        if (initialTargetDirectory == null) {\n            DirectoryChooser.ItemWrapper selectedItem = (DirectoryChooser.ItemWrapper)destinationFolderCB.getComboBox().getSelectedItem();\n            selectedPsiDirectory = selectedItem.getDirectory();\n            if (selectedPsiDirectory == null) return Pair.create(null, new MultipleRootsMoveDestination(targetPackage));\n        }\n        else {\n            selectedPsiDirectory = initialTargetDirectory;\n        }\n\n        VirtualFile targetDirectory = selectedPsiDirectory.getVirtualFile();\n        return Pair.create(targetDirectory, new AutocreatingSingleSourceRootMoveDestination(targetPackage, targetDirectory));\n    }","id":41576,"modified_method":"@Nullable\n    private Pair<VirtualFile, ? extends MoveDestination> selectPackageBasedTargetDirAndDestination(boolean askIfDoesNotExist) {\n        String packageName = getTargetPackage();\n\n        RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n        PackageWrapper targetPackage = new PackageWrapper(PsiManager.getInstance(myProject), packageName);\n        if (!targetPackage.exists() && askIfDoesNotExist) {\n            int ret = Messages.showYesNoDialog(myProject, RefactoringBundle.message(\"package.does.not.exist\", packageName),\n                                               RefactoringBundle.message(\"move.title\"), Messages.getQuestionIcon());\n            if (ret != Messages.YES) return null;\n        }\n\n        PsiDirectory selectedPsiDirectory;\n        if (initialTargetDirectory == null) {\n            DirectoryChooser.ItemWrapper selectedItem = (DirectoryChooser.ItemWrapper)destinationFolderCB.getComboBox().getSelectedItem();\n            selectedPsiDirectory = selectedItem != null ? selectedItem.getDirectory() : null;\n            if (selectedPsiDirectory == null) return Pair.create(null, new MultipleRootsMoveDestination(targetPackage));\n        }\n        else {\n            selectedPsiDirectory = initialTargetDirectory;\n        }\n\n        VirtualFile targetDirectory = selectedPsiDirectory.getVirtualFile();\n        return Pair.create(targetDirectory, new AutocreatingSingleSourceRootMoveDestination(targetPackage, targetDirectory));\n    }","commit_id":"f0a298e27b73d33076d6551f042666c02a403103","url":"https://github.com/JetBrains/kotlin"},{"original_method":"static AutoBuffer remote_exec( final AutoBuffer ab ) {\n    long lo = ab.get8(0), hi = ab.get8(8); // for dbg\n    final int task = ab.getTask();\n    final int flag = ab.getFlag();\n    assert flag==CLIENT_UDP_SEND || flag==CLIENT_TCP_SEND; // Client-side send\n    // Atomically record an instance of this task, one-time-only replacing a\n    // null with an RPCCall, a placeholder while we work on a proper responce -\n    // and it serves to let us discard dup UDP requests.\n    RPCCall old = ab._h2o.has_task(task);\n    // This is a UDP packet requesting an answer back for a request sent via\n    // TCP but the UDP packet has arrived ahead of the TCP.  Just drop the UDP\n    // and wait for the TCP to appear.\n    if( old == null && flag == CLIENT_TCP_SEND ) {\n      if(ab.hasTCP()){\n        System.out.println(\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi));\n        printMyTimeLine();\n      }\n      assert !ab.hasTCP();\n      // DROP PACKET\n    } else if( old == null ) {  // New task?\n      // Read the DTask Right Now.  If we are the TCPReceiver thread, then we\n      // are reading in that thread... and thus TCP reads are single-threaded.\n      RPCCall rpc = new RPCCall(ab.get(DTask.class),ab._h2o,task);\n      RPCCall rpc2 = ab._h2o.record_task(rpc);\n      if( rpc2==null ) {        // Atomically insert (to avoid double-work)\n        H2O.submitTask(rpc);    // And execute!\n      } else {                  // Else lost the task-insertion race\n        if(ab.hasTCP()){\n          System.out.println(\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi));\n          printMyTimeLine();\n        }\n        assert !ab.hasTCP();    // Hence this is a dup 'exec' request\n        // DROP PACKET\n      }\n\n    } else if( !old._computed ) {\n      if(ab.hasTCP()){\n        System.out.println(\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi));\n        printMyTimeLine();\n      }\n      // This packet has not been fully computed.  Hence it's still a work-in-\n      // progress locally.  We have no answer to reply but we do not want to\n      // re-offer the packet for repeated work.  Just ignore the packet.\n      assert !ab.hasTCP();      // All the resends should be UDP only\n\n      // DROP PACKET\n    } else {\n      if(ab.hasTCP()){\n        System.out.println(\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi));\n        printMyTimeLine();\n      }\n      // This is an old re-send of the same thing we've answered to before.\n      // Send back the same old answer ACK.  If we sent via TCP before, then\n      // we know the answer got there so just send a control-ACK back.  If we\n      // sent via UDP, resend the whole answer.\n      assert !ab.hasTCP();      // All the resends should be UDP only\n      old.resend_ack();\n    }\n    return ab;\n  }","id":41577,"modified_method":"static AutoBuffer remote_exec( final AutoBuffer ab ) {\n    long lo = ab.get8(0), hi = ab.get8(8); // for dbg\n    final int task = ab.getTask();\n    final int flag = ab.getFlag();\n    assert flag==CLIENT_UDP_SEND || flag==CLIENT_TCP_SEND; // Client-side send\n    // Atomically record an instance of this task, one-time-only replacing a\n    // null with an RPCCall, a placeholder while we work on a proper responce -\n    // and it serves to let us discard dup UDP requests.\n    RPCCall old = ab._h2o.has_task(task);\n    // This is a UDP packet requesting an answer back for a request sent via\n    // TCP but the UDP packet has arrived ahead of the TCP.  Just drop the UDP\n    // and wait for the TCP to appear.\n    if( old == null && flag == CLIENT_TCP_SEND ) {\n      if(ab.hasTCP())TimeLine.printMyTimeLine();\n      assert !ab.hasTCP():\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi);      // All the resends should be UDP only\n      // DROP PACKET\n    } else if( old == null ) {  // New task?\n      // Read the DTask Right Now.  If we are the TCPReceiver thread, then we\n      // are reading in that thread... and thus TCP reads are single-threaded.\n      RPCCall rpc = new RPCCall(ab.get(DTask.class),ab._h2o,task);\n      RPCCall rpc2 = ab._h2o.record_task(rpc);\n      if( rpc2==null ) {        // Atomically insert (to avoid double-work)\n        H2O.submitTask(rpc);    // And execute!\n      } else {                  // Else lost the task-insertion race\n        if(ab.hasTCP())TimeLine.printMyTimeLine();\n        assert !ab.hasTCP():\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi);      // All the resends should be UDP only\n        // DROP PACKET\n      }\n\n    } else if( !old._computed ) {\n      // This packet has not been fully computed.  Hence it's still a work-in-\n      // progress locally.  We have no answer to reply but we do not want to\n      // re-offer the packet for repeated work.  Just ignore the packet.\n      if(ab.hasTCP())TimeLine.printMyTimeLine();\n      assert !ab.hasTCP():\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi);      // All the resends should be UDP only\n      // DROP PACKET\n    } else {\n      // This is an old re-send of the same thing we've answered to before.\n      // Send back the same old answer ACK.  If we sent via TCP before, then\n      // we know the answer got there so just send a control-ACK back.  If we\n      // sent via UDP, resend the whole answer.\n      if(ab.hasTCP())TimeLine.printMyTimeLine();\n      assert !ab.hasTCP():\"ERROR: got tcp with existing task #, FROM \" + ab._h2o.toString() + \" AB: \" +  UDP.printx16(lo,hi);      // All the resends should be UDP only\n      old.resend_ack();\n    }\n    return ab;\n  }","commit_id":"1f737e2edaf0568f7746bd0cac3232fc4ae78327","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public List<Proxy> select(@Nullable URI uri) {\n    isInstalledAssertion();\n    if (uri == null) {\n      return NO_PROXY_LIST;\n    }\n    LOG.debug(\"CommonProxy.select called for \" + uri.toString());\n\n    if (Boolean.TRUE.equals(ourReenterDefence.get())) {\n      return NO_PROXY_LIST;\n    }\n    try {\n      ourReenterDefence.set(Boolean.TRUE);\n      final String host = uri.getHost() == null ? \"\" : uri.getHost();\n      final int port = correctPortByProtocol(uri);\n      final String protocol = uri.getScheme();\n      if (\"localhost\".equals(host) || \"127.0.0.1\".equals(host) || \"::1\".equals(host)) {\n        return NO_PROXY_LIST;\n      }\n\n      final HostInfo info = new HostInfo(protocol, host, port);\n      final Map<String, ProxySelector> copy;\n      synchronized (myLock) {\n        if (myNoProxy.contains(Pair.create(info, Thread.currentThread()))) {\n          LOG.debug(\"CommonProxy.select returns no proxy (in no proxy list) for \" + uri.toString());\n          return NO_PROXY_LIST;\n        }\n        copy = new HashMap<String, ProxySelector>(myCustom);\n      }\n      for (Map.Entry<String, ProxySelector> entry : copy.entrySet()) {\n        final List<Proxy> proxies = entry.getValue().select(uri);\n        if (proxies != null && proxies.size() > 0) {\n          LOG.debug(\"CommonProxy.select returns custom proxy for \" + uri.toString() + \", \" + proxies.toString());\n          return proxies;\n        }\n      }\n      return NO_PROXY_LIST;\n    } finally {\n      ourReenterDefence.remove();\n    }\n  }","id":41578,"modified_method":"@Override\n  public List<Proxy> select(@Nullable URI uri) {\n    isInstalledAssertion();\n    if (uri == null) {\n      return NO_PROXY_LIST;\n    }\n    LOG.debug(\"CommonProxy.select called for \" + uri.toString());\n\n    if (Boolean.TRUE.equals(ourReenterDefence.get())) {\n      return NO_PROXY_LIST;\n    }\n    try {\n      ourReenterDefence.set(Boolean.TRUE);\n      String host = StringUtil.notNullize(uri.getHost());\n      if (NetUtils.isLocalhost(host)) {\n        return NO_PROXY_LIST;\n      }\n\n      final HostInfo info = new HostInfo(uri.getScheme(), host, correctPortByProtocol(uri));\n      final Map<String, ProxySelector> copy;\n      synchronized (myLock) {\n        if (myNoProxy.contains(Pair.create(info, Thread.currentThread()))) {\n          LOG.debug(\"CommonProxy.select returns no proxy (in no proxy list) for \" + uri.toString());\n          return NO_PROXY_LIST;\n        }\n        copy = new HashMap<String, ProxySelector>(myCustom);\n      }\n      for (Map.Entry<String, ProxySelector> entry : copy.entrySet()) {\n        final List<Proxy> proxies = entry.getValue().select(uri);\n        if (!ContainerUtil.isEmpty(proxies)) {\n          LOG.debug(\"CommonProxy.select returns custom proxy for \" + uri.toString() + \", \" + proxies.toString());\n          return proxies;\n        }\n      }\n      return NO_PROXY_LIST;\n    }\n    finally {\n      ourReenterDefence.remove();\n    }\n  }","commit_id":"0be4dd293a3f61488ba617c9fbabd0e7889d35ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * todo [all] It is NOT necessary to call anything if you obey common IDEA proxy settings;\n   * todo if you want to define your own behaviour, refer to {@link com.intellij.util.proxy.CommonProxy}\n   *\n   * also, this method is useful in a way that it test connection to the host [through proxy]\n   *\n   * @param url URL for HTTP connection\n   * @throws IOException\n   */\n  public void prepareURL(@NotNull String url) throws IOException {\n    CommonProxy.isInstalledAssertion();\n\n    URLConnection connection = openConnection(url);\n    try {\n      connection.connect();\n      connection.getInputStream();\n    }\n    catch (IOException e) {\n      throw e;\n    }\n    catch (Throwable ignored) {\n    }\n    finally {\n      if (connection instanceof HttpURLConnection) {\n        ((HttpURLConnection)connection).disconnect();\n      }\n    }\n  }","id":41579,"modified_method":"/**\n   * todo [all] It is NOT necessary to call anything if you obey common IDEA proxy settings;\n   * todo if you want to define your own behaviour, refer to {@link com.intellij.util.proxy.CommonProxy}\n   *\n   * also, this method is useful in a way that it test connection to the host [through proxy]\n   *\n   * @param url URL for HTTP connection\n   * @throws IOException\n   */\n  public void prepareURL(@NotNull String url) throws IOException {\n    URLConnection connection = openConnection(url);\n    try {\n      connection.connect();\n      connection.getInputStream();\n    }\n    catch (IOException e) {\n      throw e;\n    }\n    catch (Throwable ignored) {\n    }\n    finally {\n      if (connection instanceof HttpURLConnection) {\n        ((HttpURLConnection)connection).disconnect();\n      }\n    }\n  }","commit_id":"0be4dd293a3f61488ba617c9fbabd0e7889d35ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public URLConnection openConnection(@NotNull String location) throws IOException {\n    CommonProxy.isInstalledAssertion();\n    final URL url = new URL(location);\n    URLConnection urlConnection = null;\n    final List<Proxy> proxies = CommonProxy.getInstance().select(url);\n    if (proxies == null || proxies.isEmpty()) {\n      urlConnection = url.openConnection();\n    } else {\n      IOException ioe = null;\n      for (Proxy proxy : proxies) {\n        try {\n          urlConnection = url.openConnection(proxy);\n        } catch (IOException e) {\n          // continue iteration\n          ioe = e;\n        }\n      }\n      if (urlConnection == null && ioe != null) {\n        throw ioe;\n      }\n    }\n    if (urlConnection != null) {\n      urlConnection.setReadTimeout(CONNECTION_TIMEOUT);\n      urlConnection.setConnectTimeout(CONNECTION_TIMEOUT);\n    }\n    return urlConnection;\n  }","id":41580,"modified_method":"@NotNull\n  public URLConnection openConnection(@NotNull String location) throws IOException {\n    CommonProxy.isInstalledAssertion();\n    final URL url = new URL(location);\n    URLConnection urlConnection = null;\n    final List<Proxy> proxies = CommonProxy.getInstance().select(url);\n    if (ContainerUtil.isEmpty(proxies)) {\n      urlConnection = url.openConnection();\n    }\n    else {\n      IOException exception = null;\n      for (Proxy proxy : proxies) {\n        try {\n          urlConnection = url.openConnection(proxy);\n        }\n        catch (IOException e) {\n          // continue iteration\n          exception = e;\n        }\n      }\n      if (urlConnection == null && exception != null) {\n        throw exception;\n      }\n    }\n\n    assert urlConnection != null;\n    urlConnection.setReadTimeout(CONNECTION_TIMEOUT);\n    urlConnection.setConnectTimeout(CONNECTION_TIMEOUT);\n    return urlConnection;\n  }","commit_id":"0be4dd293a3f61488ba617c9fbabd0e7889d35ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isLocalhost(@NotNull String host) {\n    return host.equalsIgnoreCase(\"localhost\") || host.equals(\"127.0.0.1\");\n  }","id":41581,"modified_method":"public static boolean isLocalhost(@NotNull String host) {\n    return host.equalsIgnoreCase(\"localhost\") || host.equals(\"127.0.0.1\") || host.equals(\"::1\");\n  }","commit_id":"0be4dd293a3f61488ba617c9fbabd0e7889d35ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * @see org.apache.sling.osgi.installer.impl.RegisteredResource#getURL()\n\t */\n\tpublic String getURL() {\n\t\treturn this.getScheme() + \":\" + this.getId();\n\t}","id":41582,"modified_method":"/**\n\t * @see org.apache.sling.osgi.installer.impl.RegisteredResource#getURL()\n\t */\n\tpublic String getURL() {\n\t\treturn this.getScheme() + \":\" + this.attributes.get(Constants.BUNDLE_SYMBOLICNAME) + \"-\" + this.attributes.get(Constants.BUNDLE_VERSION);\n\t}","commit_id":"a903122a022c6fdafb9b7f8f20168492f4ac6e53","url":"https://github.com/apache/sling"},{"original_method":"public void push(ServletRequest request)\n    {\n        Request baseRequest = Request.getBaseRequest(request);\n        HttpFields fields = new HttpFields(baseRequest.getHttpFields());\n        \n        String query=baseRequest.getQueryString();\n        if (_uri.hasQuery())\n        {\n            if (query==null)\n                query=_uri.getQuery();\n            else\n                query=query+\"&\"+_uri.getQuery(); // TODO is this correct semantic?\n        }\n        \n        int port=request.getServerPort();\n        if (port==80 && HttpScheme.HTTP.is(request.getScheme()))\n            port=0;\n        if (port==443 && HttpScheme.HTTPS.is(request.getScheme()))\n            port=0;\n        \n        HttpURI uri = new HttpURI(request.getScheme(),request.getServerName(),request.getServerPort(),_uri.getPath(),baseRequest.getHttpURI().getParam(),query,null);\n        \n        MetaData.Request push = new MetaData.Request(HttpMethod.GET.asString(),uri,baseRequest.getHttpVersion(),fields);\n        \n        baseRequest.getHttpChannel().getHttpTransport().push(push);\n    }","id":41583,"modified_method":"public void push(ServletRequest request)\n    {\n        Request baseRequest = Request.getBaseRequest(request);\n        HttpFields fields = new HttpFields(baseRequest.getHttpFields());\n        \n        String query=baseRequest.getQueryString();\n        if (_uri.hasQuery())\n        {\n            if (query==null)\n                query=_uri.getQuery();\n            else\n                query=query+\"&\"+_uri.getQuery(); // TODO is this correct semantic?\n        }\n        \n        HttpURI uri = HttpURI.createHttpURI(request.getScheme(),request.getServerName(),request.getServerPort(),_uri.getPath(),baseRequest.getHttpURI().getParam(),query,null);\n        \n        MetaData.Request push = new MetaData.Request(HttpMethod.GET.asString(),uri,baseRequest.getHttpVersion(),fields);\n        \n        baseRequest.getHttpChannel().getHttpTransport().push(push);\n    }","commit_id":"e5c1d66916549c0b796d1ae17c6b8609d5338b8d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Internally resolves the absolute path. The will almost always contain\n     * request selectors and an extension. Therefore this method uses the\n     * {@link ResourcePathIterator} to cut off parts of the path to find the\n     * actual resource.\n     * <p>\n     * This method operates in two steps:\n     * <ol>\n     * <li>Check the path directly\n     * <li>Drill down the resource tree from the root down to the resource\n     * trying to get the child as per the respective path segment or finding a\n     * child whose <code>sling:alias<\/code> property is set to the respective\n     * name.\n     * <\/ol>\n     * <p>\n     * If neither mechanism (direct access and drill down) resolves to a\n     * resource this method returns <code>null<\/code>.\n     * \n     * @param absPath The absolute path of the resource to return.\n     * @return The resource found or <code>null<\/code> if the resource could\n     *         not be found. The\n     *         {@link org.apache.sling.api.resource.ResourceMetadata#getResolutionPathInfo() resolution path info}\n     *         field of the resource returned is set to the part of the\n     *         <code>absPath<\/code> which has been cut off by the\n     *         {@link ResourcePathIterator} to resolve the resource.\n     */\n    private Resource resolveInternal(String absPath) {\n        Resource resource = null;\n        String curPath = absPath;\n        try {\n            final ResourcePathIterator it = new ResourcePathIterator(absPath);\n            while (it.hasNext() && resource == null) {\n                curPath = it.next();\n                resource = getResourceInternal(curPath);\n            }\n        } catch (Exception ex) {\n            throw new SlingException(\"Problem trying \" + curPath\n                + \" for request path \" + absPath, ex);\n        }\n\n        // SLING-627: set the part cut off from the uriPath as\n        // sling.resolutionPathInfo property such that\n        // uriPath = curPath + sling.resolutionPathInfo\n        if (resource != null) {\n\n            String rpi = absPath.substring(curPath.length());\n            resource.getResourceMetadata().setResolutionPathInfo(rpi);\n\n        } else {\n\n            // no direct resource found, so we have to drill down into the\n            // resource tree to find a match\n            resource = getResourceInternal(\"/\");\n            StringTokenizer tokener = new StringTokenizer(absPath, \"/\");\n            while (resource != null && tokener.hasMoreTokens()) {\n                String childNameRaw = tokener.nextToken();\n\n                Resource nextResource = getChildInternal(resource, childNameRaw);\n                if (nextResource != null) {\n\n                    resource = nextResource;\n\n                } else {\n\n                    String childName = null;\n                    ResourcePathIterator rpi = new ResourcePathIterator(\n                        childNameRaw);\n                    while (rpi.hasNext() && nextResource == null) {\n                        childName = rpi.next();\n                        nextResource = getChildInternal(resource, childName);\n                    }\n\n                    // switch the currentResource to the nextResource (may be\n                    // null)\n                    resource = nextResource;\n\n                    // SLING-627: set the part cut off from the uriPath as\n                    // sling.resolutionPathInfo property such that\n                    // uriPath = curPath + sling.resolutionPathInfo\n                    if (nextResource != null) {\n                        String path = ResourceUtil.normalize(ResourceUtil.getParent(\n                            nextResource).getPath()\n                            + \"/\" + childName);\n                        String pathInfo = absPath.substring(path.length());\n                        nextResource.getResourceMetadata().setResolutionPathInfo(\n                            pathInfo);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return resource;\n    }","id":41584,"modified_method":"/**\n     * Internally resolves the absolute path. The will almost always contain\n     * request selectors and an extension. Therefore this method uses the\n     * {@link ResourcePathIterator} to cut off parts of the path to find the\n     * actual resource.\n     * <p>\n     * This method operates in two steps:\n     * <ol>\n     * <li>Check the path directly\n     * <li>Drill down the resource tree from the root down to the resource\n     * trying to get the child as per the respective path segment or finding a\n     * child whose <code>sling:alias<\/code> property is set to the respective\n     * name.\n     * <\/ol>\n     * <p>\n     * If neither mechanism (direct access and drill down) resolves to a\n     * resource this method returns <code>null<\/code>.\n     * \n     * @param absPath The absolute path of the resource to return.\n     * @return The resource found or <code>null<\/code> if the resource could\n     *         not be found. The\n     *         {@link org.apache.sling.api.resource.ResourceMetadata#getResolutionPathInfo() resolution path info}\n     *         field of the resource returned is set to the part of the\n     *         <code>absPath<\/code> which has been cut off by the\n     *         {@link ResourcePathIterator} to resolve the resource.\n     */\n    private Resource resolveInternal(String absPath) {\n        Resource resource = null;\n        String curPath = absPath;\n        try {\n            final ResourcePathIterator it = new ResourcePathIterator(absPath);\n            while (it.hasNext() && resource == null) {\n                curPath = it.next();\n                resource = getResourceInternal(curPath);\n            }\n        } catch (Exception ex) {\n            throw new SlingException(\"Problem trying \" + curPath\n                + \" for request path \" + absPath, ex);\n        }\n\n        // SLING-627: set the part cut off from the uriPath as\n        // sling.resolutionPathInfo property such that\n        // uriPath = curPath + sling.resolutionPathInfo\n        if (resource != null) {\n\n            String rpi = absPath.substring(curPath.length());\n            resource.getResourceMetadata().setResolutionPathInfo(rpi);\n            \n            log.debug(\n                \"resolveInternal: Found resource {} with path info {} for {}\",\n                new Object[] { resource, rpi, absPath });\n\n        } else {\n\n            // no direct resource found, so we have to drill down into the\n            // resource tree to find a match\n            resource = getResourceInternal(\"/\");\n            StringTokenizer tokener = new StringTokenizer(absPath, \"/\");\n            while (resource != null && tokener.hasMoreTokens()) {\n                String childNameRaw = tokener.nextToken();\n\n                Resource nextResource = getChildInternal(resource, childNameRaw);\n                if (nextResource != null) {\n\n                    resource = nextResource;\n\n                } else {\n\n                    String childName = null;\n                    ResourcePathIterator rpi = new ResourcePathIterator(\n                        childNameRaw);\n                    while (rpi.hasNext() && nextResource == null) {\n                        childName = rpi.next();\n                        nextResource = getChildInternal(resource, childName);\n                    }\n\n                    // switch the currentResource to the nextResource (may be\n                    // null)\n                    resource = nextResource;\n\n                    // SLING-627: set the part cut off from the uriPath as\n                    // sling.resolutionPathInfo property such that\n                    // uriPath = curPath + sling.resolutionPathInfo\n                    if (nextResource != null) {\n                        String path = ResourceUtil.normalize(ResourceUtil.getParent(\n                            nextResource).getPath()\n                            + \"/\" + childName);\n                        String pathInfo = absPath.substring(path.length());\n                        nextResource.getResourceMetadata().setResolutionPathInfo(\n                            pathInfo);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return resource;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"public String getProperty(Resource res, String propName) {\n        \n        // check the property in the resource itself\n        ValueMap props = res.adaptTo(ValueMap.class);\n        if (props != null) {\n            String prop = props.get(propName, String.class);\n            if (prop != null) {\n                return prop;\n            }\n        }\n        \n        // otherwise, check it in the jcr:content child resource\n        res = getResource(res, \"jcr:content\");\n        if (res != null) {\n            return getProperty(res, propName);\n        }\n\n        return null;\n    }","id":41585,"modified_method":"public String getProperty(Resource res, String propName) {\n        \n        // check the property in the resource itself\n        ValueMap props = res.adaptTo(ValueMap.class);\n        if (props != null) {\n            String prop = props.get(propName, String.class);\n            if (prop != null) {\n                log.debug(\"getProperty: Resource {} has property {}={}\",\n                    new Object[] { res, propName, prop });\n                return prop;\n            }\n        }\n        \n        // otherwise, check it in the jcr:content child resource\n        res = getResource(res, \"jcr:content\");\n        if (res != null) {\n            return getProperty(res, propName);\n        }\n\n        return null;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"public String map(final HttpServletRequest request, final String resourcePath) {\n        \n        String mappedPath = resourcePath;\n        boolean mappedPathIsUrl = false;\n        String resolutionPathInfo;\n\n        // cut off scheme and host, if the same as requested\n        String schemehostport;\n        if (request != null) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(request.getScheme()).append(\"://\");\n            sb.append(request.getServerName());\n            if (request.getServerPort() > 0) {\n                sb.append(':').append(request.getServerPort());\n            }\n            sb.append(\"/\");\n            schemehostport = sb.toString();\n\n            log.debug(\"map: Mapping path {} for {}\", resourcePath,\n                schemehostport);\n\n        } else {\n\n            schemehostport = null;\n            log.debug(\"map: Mapping path {} for default\", resourcePath);\n\n        }\n\n        Resource res = resolveInternal(mappedPath);\n        if (res != null) {\n\n            // keep, what we might have cut off in internal resolution\n            resolutionPathInfo = res.getResourceMetadata().getResolutionPathInfo();\n            \n            log.debug(\"map: Path maps to resource {} with path info {}\", res,\n                resolutionPathInfo);\n            \n            // find aliases for segments\n            LinkedList<String> names = new LinkedList<String>();\n            while (res != null) {\n                String alias = getProperty(res, PROP_ALIAS);\n                if (alias == null) {\n                    alias = ResourceUtil.getName(res);\n                }\n                if (alias != null && alias.length() > 0) {\n                    names.add(alias);\n                }\n                res = ResourceUtil.getParent(res);\n            }\n            \n            // build path from segment names\n            StringBuilder buf = new StringBuilder();\n            while (!names.isEmpty()) {\n                buf.append('/');\n                buf.append(names.removeLast());\n            }\n            mappedPath = buf.toString();\n            \n            log.debug(\"map: Alias mapping resolves to path {}\", mappedPath);\n            \n        } else {\n            \n            // we have no resource, hence no resolution path info\n            resolutionPathInfo = null;\n            \n        }\n        \n        for (MapEntry mapEntry : resourceMapper.getMapMaps()) {\n            String[] mappedPaths = mapEntry.replace(mappedPath);\n            if (mappedPaths != null) {\n\n                log.debug(\"map: Match for Entry {}\", mapEntry);\n                \n                mappedPath = mappedPaths[0];\n                mappedPathIsUrl = !mapEntry.isInternal();\n\n                if (mappedPathIsUrl && schemehostport != null) {\n                    for (String candidate : mappedPaths) {\n                        if (candidate.startsWith(schemehostport)) {\n                            mappedPath = candidate.substring(schemehostport.length() - 1);\n                            log.debug(\n                                \"map: Found host specific mapping {} resolving to {}\",\n                                candidate, mappedPath);\n                            break;\n                        }\n                    }\n                }\n\n                log.debug(\n                    \"resolve: MapEntry {} matches, mapped path is {}\",\n                    mapEntry, mappedPath);\n\n                break;\n            }\n        }\n\n        // this should not be the case, since mappedPath is primed\n        if (mappedPath == null) {\n            mappedPath = resourcePath;\n        }\n        \n        // append resolution path info, which might have been cut off above\n        if (resolutionPathInfo != null) {\n            mappedPath = mappedPath.concat(resolutionPathInfo);\n        }\n        \n        if (mappedPathIsUrl) {\n            // TODO: Consider mangling the path but not the scheme and\n            // esp. the host:port part\n            \n            log.debug(\"map: Returning URL {} as mapping for path {}\",\n                mappedPath, resourcePath);\n            \n            return mappedPath;\n        }\n\n        // mangle the namespaces\n        mappedPath = mangleNamespaces(mappedPath);\n\n        // prepend servlet context path if we have a request\n        if (request != null && request.getContextPath() != null\n            && request.getContextPath().length() > 0) {\n            mappedPath = request.getContextPath().concat(mappedPath);\n        }\n\n        log.debug(\n            \"map: Returning path {} (after mangling, inlc. context) for {}\",\n            mappedPath, resourcePath);\n        \n        return mappedPath;\n    }","id":41586,"modified_method":"public String map(final HttpServletRequest request, final String resourcePath) {\n        \n        String mappedPath = resourcePath;\n        boolean mappedPathIsUrl = false;\n        String resolutionPathInfo;\n\n        // cut off scheme and host, if the same as requested\n        String schemehostport;\n        if (request != null) {\n            schemehostport = MapEntry.getURI(request.getScheme(),\n                request.getServerName(), request.getServerPort(), \"/\");\n\n            log.debug(\"map: Mapping path {} for {}\", resourcePath,\n                schemehostport);\n\n        } else {\n\n            schemehostport = null;\n            log.debug(\"map: Mapping path {} for default\", resourcePath);\n\n        }\n\n        Resource res = resolveInternal(mappedPath);\n        if (res != null) {\n\n            // keep, what we might have cut off in internal resolution\n            resolutionPathInfo = res.getResourceMetadata().getResolutionPathInfo();\n            \n            log.debug(\"map: Path maps to resource {} with path info {}\", res,\n                resolutionPathInfo);\n            \n            // find aliases for segments\n            LinkedList<String> names = new LinkedList<String>();\n            while (res != null) {\n                String alias = getProperty(res, PROP_ALIAS);\n                if (alias == null) {\n                    alias = ResourceUtil.getName(res);\n                }\n                if (alias != null && alias.length() > 0) {\n                    names.add(alias);\n                }\n                res = ResourceUtil.getParent(res);\n            }\n            \n            // build path from segment names\n            StringBuilder buf = new StringBuilder();\n            while (!names.isEmpty()) {\n                buf.append('/');\n                buf.append(names.removeLast());\n            }\n            mappedPath = buf.toString();\n            \n            log.debug(\"map: Alias mapping resolves to path {}\", mappedPath);\n            \n        } else {\n            \n            // we have no resource, hence no resolution path info\n            resolutionPathInfo = null;\n            \n        }\n        \n        for (MapEntry mapEntry : resourceMapper.getMapMaps()) {\n            String[] mappedPaths = mapEntry.replace(mappedPath);\n            if (mappedPaths != null) {\n\n                log.debug(\"map: Match for Entry {}\", mapEntry);\n                \n                mappedPath = mappedPaths[0];\n                mappedPathIsUrl = !mapEntry.isInternal();\n\n                if (mappedPathIsUrl && schemehostport != null) {\n                    for (String candidate : mappedPaths) {\n                        if (candidate.startsWith(schemehostport)) {\n                            mappedPath = candidate.substring(schemehostport.length() - 1);\n                            log.debug(\n                                \"map: Found host specific mapping {} resolving to {}\",\n                                candidate, mappedPath);\n                            break;\n                        }\n                    }\n                }\n\n                log.debug(\n                    \"resolve: MapEntry {} matches, mapped path is {}\",\n                    mapEntry, mappedPath);\n\n                break;\n            }\n        }\n\n        // this should not be the case, since mappedPath is primed\n        if (mappedPath == null) {\n            mappedPath = resourcePath;\n        }\n        \n        // append resolution path info, which might have been cut off above\n        if (resolutionPathInfo != null) {\n            mappedPath = mappedPath.concat(resolutionPathInfo);\n        }\n        \n        if (mappedPathIsUrl) {\n            // TODO: Consider mangling the path but not the scheme and\n            // esp. the host:port part\n            \n            log.debug(\"map: Returning URL {} as mapping for path {}\",\n                mappedPath, resourcePath);\n            \n            return mappedPath;\n        }\n\n        // mangle the namespaces\n        mappedPath = mangleNamespaces(mappedPath);\n\n        // prepend servlet context path if we have a request\n        if (request != null && request.getContextPath() != null\n            && request.getContextPath().length() > 0) {\n            mappedPath = request.getContextPath().concat(mappedPath);\n        }\n\n        log.debug(\n            \"map: Returning path {} (after mangling, inlc. context) for {}\",\n            mappedPath, resourcePath);\n        \n        return mappedPath;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"public Resource resolveInternal(HttpServletRequest request, String absPath,\n            boolean requireResource) {\n\n        // check for special namespace prefix treatment\n        absPath = unmangleNamespaces(absPath);\n        \n        // Assume http://localhost:80 if request is null\n        String[] realPathList = { absPath };\n        String requestPath;\n        if (request != null) {\n            requestPath = getMapPath(request.getScheme(),\n                request.getServerName(), request.getServerPort(), absPath);\n        } else {\n            requestPath = getMapPath(\"http\", \"localhost\", 80, absPath);\n        }\n\n        log.debug(\"resolve: Resolving request path {}\", requestPath);\n\n        // loop while finding internal or external redirect into the\n        // content out of the virtual host mapping tree\n        // the counter is to ensure we are not caught in an endless loop here\n        // TODO: might do better to be able to log the loop and help the user\n        for (int i = 0; i < 100; i++) {\n\n            String[] mappedPath = null;\n            for (MapEntry mapEntry : resourceMapper.getResolveMaps()) {\n                mappedPath = mapEntry.replace(requestPath);\n                if (mappedPath != null) {\n                    log.debug(\n                        \"resolve: MapEntry {} matches, mapped path is {}\",\n                        mapEntry, mappedPath);\n\n                    if (mapEntry.isInternal()) {\n                        // internal redirect\n                        log.debug(\"resolve: Redirecting internally\");\n                        break;\n                    }\n\n                    // external redirect\n                    log.debug(\"resolve: Returning external redirect\");\n                    return new RedirectResource(this, absPath, mappedPath[0]);\n                }\n            }\n\n            // if there is no virtual host based path mapping, abort\n            // and use the original realPath\n            if (mappedPath == null) {\n                log.debug(\n                    \"resolve: Request path {} does not match any MapEntry\",\n                    requestPath);\n                break;\n            }\n\n            // if the mapped path is not an URL, use this path to continue\n            if (!mappedPath[0].contains(\"://\")) {\n                log.debug(\"resolve: Mapped path is for resource tree\");\n                realPathList = mappedPath;\n                break;\n            }\n\n            // otherwise the mapped path is an URI and we have to try to\n            // resolve that URI now, using the URI's path as the real path\n            try {\n                URI uri = new URI(mappedPath[0]);\n                requestPath = getMapPath(uri.getScheme(), uri.getHost(),\n                    uri.getPort(), uri.getPath());\n                realPathList = new String[] { uri.getPath() };\n\n                log.debug(\n                    \"resolve: Mapped path is an URL, using new request path {}\",\n                    requestPath);\n            } catch (URISyntaxException use) {\n                // TODO: log and fail\n                throw new ResourceNotFoundException(absPath);\n            }\n        }\n\n        // now we have the real path resolved from virtual host mapping\n        // this path may be absolute or relative, in which case we try\n        // to resolve it against the search path\n\n        Resource res = null;\n        for (int i = 0; res == null && i < realPathList.length; i++) {\n            String realPath = realPathList[i];\n\n            // first check whether the requested resource is a StarResource\n            if (StarResource.appliesTo(realPath)) {\n\n                log.debug(\"resolve: Mapped path {} is a Star Resource\",\n                    realPath);\n                res = new StarResource(this, ensureAbsPath(realPath),\n                    factory.getJcrResourceTypeProvider());\n\n            } else\n\n            if (realPath.startsWith(\"/\")) {\n\n                // let's check it with a direct access first\n                log.debug(\"resolve: Try absolute mapped path\");\n                res = resolveInternal(realPath);\n\n            } else {\n\n                String[] searchPath = getSearchPath();\n                for (int spi = 0; res == null && spi < searchPath.length; spi++) {\n                    log.debug(\n                        \"resolve: Try relative mapped path with search path entry {}\",\n                        searchPath[spi]);\n                    res = resolveInternal(searchPath[spi] + realPath);\n                }\n\n            }\n\n        }\n        \n        if (res == null) {\n            if (requireResource) {\n                log.debug(\n                    \"resolve: Path {} does not resolve, returning NonExistingResource at {}\",\n                    absPath, realPathList[0]);\n                res = new NonExistingResource(this,\n                    ensureAbsPath(realPathList[0]));\n            } else {\n                log.debug(\"resolve: No Resource for {}\", absPath);\n            }\n        } else {\n            log.debug(\"resolve: Path {} resolves to Resource {}\", absPath, res);\n        }\n\n        return res;\n    }","id":41587,"modified_method":"public Resource resolveInternal(HttpServletRequest request, String absPath,\n            boolean requireResource) {\n\n        // check for special namespace prefix treatment\n        absPath = unmangleNamespaces(absPath);\n        \n        // Assume http://localhost:80 if request is null\n        String[] realPathList = { absPath };\n        String requestPath;\n        if (request != null) {\n            requestPath = getMapPath(request.getScheme(),\n                request.getServerName(), request.getServerPort(), absPath);\n        } else {\n            requestPath = getMapPath(\"http\", \"localhost\", 80, absPath);\n        }\n\n        log.debug(\"resolve: Resolving request path {}\", requestPath);\n\n        // loop while finding internal or external redirect into the\n        // content out of the virtual host mapping tree\n        // the counter is to ensure we are not caught in an endless loop here\n        // TODO: might do better to be able to log the loop and help the user\n        for (int i = 0; i < 100; i++) {\n\n            String[] mappedPath = null;\n            for (MapEntry mapEntry : resourceMapper.getResolveMaps()) {\n                mappedPath = mapEntry.replace(requestPath);\n                if (mappedPath != null) {\n                    log.debug(\n                        \"resolve: MapEntry {} matches, mapped path is {}\",\n                        mapEntry, mappedPath);\n\n                    if (mapEntry.isInternal()) {\n                        // internal redirect\n                        log.debug(\"resolve: Redirecting internally\");\n                        break;\n                    }\n\n                    // external redirect\n                    log.debug(\"resolve: Returning external redirect\");\n                    return new RedirectResource(this, absPath, mappedPath[0]);\n                }\n            }\n\n            // if there is no virtual host based path mapping, abort\n            // and use the original realPath\n            if (mappedPath == null) {\n                log.debug(\n                    \"resolve: Request path {} does not match any MapEntry\",\n                    requestPath);\n                break;\n            }\n\n            // if the mapped path is not an URL, use this path to continue\n            if (!mappedPath[0].contains(\"://\")) {\n                log.debug(\"resolve: Mapped path is for resource tree\");\n                realPathList = mappedPath;\n                break;\n            }\n\n            // otherwise the mapped path is an URI and we have to try to\n            // resolve that URI now, using the URI's path as the real path\n            try {\n                URI uri = new URI(mappedPath[0]);\n                requestPath = getMapPath(uri.getScheme(), uri.getHost(),\n                    uri.getPort(), uri.getPath());\n                realPathList = new String[] { uri.getPath() };\n\n                log.debug(\n                    \"resolve: Mapped path is an URL, using new request path {}\",\n                    requestPath);\n            } catch (URISyntaxException use) {\n                // TODO: log and fail\n                throw new ResourceNotFoundException(absPath);\n            }\n        }\n\n        // now we have the real path resolved from virtual host mapping\n        // this path may be absolute or relative, in which case we try\n        // to resolve it against the search path\n\n        Resource res = null;\n        for (int i = 0; res == null && i < realPathList.length; i++) {\n            String realPath = realPathList[i];\n\n            // first check whether the requested resource is a StarResource\n            if (StarResource.appliesTo(realPath)) {\n\n                log.debug(\"resolve: Mapped path {} is a Star Resource\",\n                    realPath);\n                res = new StarResource(this, ensureAbsPath(realPath),\n                    factory.getJcrResourceTypeProvider());\n\n            } else\n\n            if (realPath.startsWith(\"/\")) {\n\n                // let's check it with a direct access first\n                log.debug(\"resolve: Try absolute mapped path {}\", realPath);\n                res = resolveInternal(realPath);\n\n            } else {\n\n                String[] searchPath = getSearchPath();\n                for (int spi = 0; res == null && spi < searchPath.length; spi++) {\n                    log.debug(\n                        \"resolve: Try relative mapped path with search path entry {}\",\n                        searchPath[spi]);\n                    res = resolveInternal(searchPath[spi] + realPath);\n                }\n\n            }\n\n        }\n        \n        if (res == null) {\n            if (requireResource) {\n                log.debug(\n                    \"resolve: Path {} does not resolve, returning NonExistingResource at {}\",\n                    absPath, realPathList[0]);\n                res = new NonExistingResource(this,\n                    ensureAbsPath(realPathList[0]));\n            } else {\n                log.debug(\"resolve: No Resource for {}\", absPath);\n            }\n        } else {\n            log.debug(\"resolve: Path {} resolves to Resource {}\", absPath, res);\n        }\n\n        return res;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"private Resource getChildInternal(Resource parent, String childName) {\n        Resource child = getResource(parent, childName);\n        if (child != null) {\n            String alias = getProperty(child, PROP_REDIRECT_INTERNAL);\n            if (alias != null) {\n                // TODO: might be a redirect ??\n            }\n\n            // we have the resource name, continue with the next level\n            return child;\n        }\n\n        // we do not have a child with the exact name, so we look for\n        // a child, whose alias matches the childName\n        Iterator<Resource> children = listChildren(parent);\n        while (children.hasNext()) {\n            child = children.next();\n            String alias = getProperty(child, PROP_ALIAS);\n            if (childName.equals(alias)) {\n                return child;\n            }\n        }\n\n        // no match for the childName found\n        return null;\n    }","id":41588,"modified_method":"private Resource getChildInternal(Resource parent, String childName) {\n        Resource child = getResource(parent, childName);\n        if (child != null) {\n            String alias = getProperty(child, PROP_REDIRECT_INTERNAL);\n            if (alias != null) {\n                // TODO: might be a redirect ??\n                log.warn(\n                    \"getChildInternal: Internal redirect to {} for Resource {} is not supported yet, ignoring\",\n                    alias, child);\n            }\n\n            // we have the resource name, continue with the next level\n            return child;\n        }\n\n        // we do not have a child with the exact name, so we look for\n        // a child, whose alias matches the childName\n        Iterator<Resource> children = listChildren(parent);\n        while (children.hasNext()) {\n            child = children.next();\n            String alias = getProperty(child, PROP_ALIAS);\n            if (childName.equals(alias)) {\n                log.debug(\n                    \"getChildInternal: Found Resource {} with alias {} to use\",\n                    child, childName);\n                return child;\n            }\n        }\n\n        // no match for the childName found\n        log.debug(\"getChildInternal: Resource {} has no child {}\", parent,\n            childName);\n        return null;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns a string used for matching map entries against the given request\n     * or URI parts.\n     * \n     * @param scheme The URI scheme\n     * @param host The host name\n     * @param port The port number. If this is negative, the default value used\n     *            is 80 unless the scheme is \"https\" in which case the default\n     *            value is 443.\n     * @param path The (absolute) path\n     * @return The request path string {scheme}/{host}.{port}/{path}.\n     */\n    private String getMapPath(String scheme, String host, int port, String path) {\n        if (port < 0) {\n            port = (\"https\".equals(scheme)) ? 443 : 80;\n        }\n\n        return scheme + \"/\" + host + \".\" + port + path;\n    }","id":41589,"modified_method":"/**\n     * Returns a string used for matching map entries against the given request\n     * or URI parts.\n     * \n     * @param scheme The URI scheme\n     * @param host The host name\n     * @param port The port number. If this is negative, the default value used\n     *            is 80 unless the scheme is \"https\" in which case the default\n     *            value is 443.\n     * @param path The (absolute) path\n     * @return The request path string {scheme}/{host}.{port}{path}.\n     */\n    public static String getMapPath(String scheme, String host, int port, String path) {\n        if (port < 0) {\n            port = (\"https\".equals(scheme)) ? 443 : 80;\n        }\n        \n        return scheme + \"/\" + host + \".\" + port + path;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"public static List<MapEntry> createMapEntry(String url, Resource resource, boolean trailingSlash) {\n        ValueMap props = resource.adaptTo(ValueMap.class);\n        if (props != null) {\n            String redirect = props.get(\n                JcrResourceResolver2.PROP_REDIRECT_EXTERNAL, String.class);\n            if (redirect != null) {\n                // ignoring external redirects for mapping\n                return null;\n            }\n\n            String[] internalRedirect = props.get(\n                JcrResourceResolver2.PROP_REDIRECT_INTERNAL, String[].class);\n            if (internalRedirect != null) {\n\n                int status = -1;\n                URI extPathPrefix = toURI(url);\n                if (extPathPrefix != null) {\n                    url = extPathPrefix.toString();\n                    status = 302;\n                }\n\n                List<MapEntry> prepEntries = new ArrayList<MapEntry>(\n                    internalRedirect.length);\n                for (String redir : internalRedirect) {\n                    if (!redir.contains(\"$\")) {\n                        prepEntries.add(new MapEntry(redir, url, status, trailingSlash));\n                    }\n                }\n\n                if (prepEntries.size() > 0) {\n                    return prepEntries;\n                }\n            }\n        }\n\n        return null;\n    }","id":41590,"modified_method":"public static List<MapEntry> createMapEntry(String url, Resource resource, boolean trailingSlash) {\n        ValueMap props = resource.adaptTo(ValueMap.class);\n        if (props != null) {\n            String redirect = props.get(\n                JcrResourceResolver2.PROP_REDIRECT_EXTERNAL, String.class);\n            if (redirect != null) {\n                // ignoring external redirects for mapping\n                return null;\n            }\n\n            String[] internalRedirect = props.get(\n                JcrResourceResolver2.PROP_REDIRECT_INTERNAL, String[].class);\n            if (internalRedirect != null) {\n\n                int status = -1;\n                URI extPathPrefix = toURI(url);\n                if (extPathPrefix != null) {\n                    url = getURI(extPathPrefix.getScheme(),\n                        extPathPrefix.getHost(), extPathPrefix.getPort(),\n                        extPathPrefix.getPath());\n                    status = 302;\n                }\n\n                List<MapEntry> prepEntries = new ArrayList<MapEntry>(\n                    internalRedirect.length);\n                for (String redir : internalRedirect) {\n                    if (!redir.contains(\"$\")) {\n                        prepEntries.add(new MapEntry(redir, url, status, trailingSlash));\n                    }\n                }\n\n                if (prepEntries.size() > 0) {\n                    return prepEntries;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"678e23c89f9aa1a2e166a702d16d10b64385c135","url":"https://github.com/apache/sling"},{"original_method":"public AvroComponent() {\n    }","id":41591,"modified_method":"public AvroComponent() {\n        super(AvroEndpoint.class);\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"public AvroComponent(CamelContext context) {\n        super(context);\n    }","id":41592,"modified_method":"public AvroComponent(CamelContext context) {\n        super(context, AvroEndpoint.class);\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"public void setTransport(String transport) {\n        this.transport = transport;\n    }","id":41593,"modified_method":"public void setTransport(String transport) {\n        this.transport = AvroTransport.valueOf(transport);\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"public String getTransport() {\n        return transport;\n    }","id":41594,"modified_method":"public AvroTransport getTransport() {\n        return transport;\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"public void parseURI(URI uri, Map<String, Object> parameters, AvroComponent component) throws Exception {\n        transport = uri.getScheme();\n\n        if ((!AVRO_HTTP_TRANSPORT.equalsIgnoreCase(transport)) && (!AVRO_NETTY_TRANSPORT.equalsIgnoreCase(transport))) {\n            throw new IllegalArgumentException(\"Unrecognized Avro IPC transport: \" + protocol + \" for uri: \" + uri);\n        }\n\n        setHost(uri.getHost());\n        setPort(uri.getPort());\n        \n        if ((uri.getPath() != null)\n            && (StringUtils.indexOf(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR) != -1)) {\n            String path = StringUtils.substringAfter(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR);\n            if (!path.contains(AVRO_MESSAGE_NAME_SEPARATOR)) {\n                setMessageName(path);\n            } else {\n                throw new IllegalArgumentException(\"Unrecognized Avro message name: \" + path + \" for uri: \" + uri);\n            }\n        }\n        \n        setUriAuthority(uri.getAuthority());\n    }","id":41595,"modified_method":"public void parseURI(URI uri, Map<String, Object> parameters, AvroComponent component) throws Exception {\n        transport = AvroTransport.valueOf(uri.getScheme());\n\n        setHost(uri.getHost());\n        setPort(uri.getPort());\n        \n        if ((uri.getPath() != null)\n            && (StringUtils.indexOf(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR) != -1)) {\n            String path = StringUtils.substringAfter(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR);\n            if (!path.contains(AVRO_MESSAGE_NAME_SEPARATOR)) {\n                setMessageName(path);\n            } else {\n                throw new IllegalArgumentException(\"Unrecognized Avro message name: \" + path + \" for uri: \" + uri);\n            }\n        }\n        \n        setUriAuthority(uri.getAuthority());\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Initializes and starts http or netty server on basis of transport protocol from configuration.\n     *\n     *\n     * @param configuration\n     * @return Initialized and started server\n     * @throws java.io.IOException\n     */\n    private Server initAndStartServer(AvroConfiguration configuration) throws Exception {\n        SpecificResponder responder;\n        Server server;\n\n        if (configuration.isReflectionProtocol()) {\n            responder = new AvroReflectResponder(configuration.getProtocol(), this);\n        } else {\n            responder = new AvroSpecificResponder(configuration.getProtocol(), this);\n        }\n\n\n        if (AVRO_HTTP_TRANSPORT.equalsIgnoreCase(configuration.getTransport())) {\n            server = new HttpServer(responder, configuration.getPort());\n        } else if (AVRO_NETTY_TRANSPORT.equalsIgnoreCase(configuration.getTransport())) {\n            server = new NettyServer(responder, new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        } else {\n            throw new IllegalArgumentException(\"Unknown transport \" + configuration.getTransport());\n        }\n\n        server.start();\n\n        return server;\n    }","id":41596,"modified_method":"/**\n     * Initializes and starts http or netty server on basis of transport protocol from configuration.\n     *\n     *\n     * @param configuration\n     * @return Initialized and started server\n     * @throws java.io.IOException\n     */\n    private Server initAndStartServer(AvroConfiguration configuration) throws Exception {\n        SpecificResponder responder;\n        Server server;\n\n        if (configuration.isReflectionProtocol()) {\n            responder = new AvroReflectResponder(configuration.getProtocol(), this);\n        } else {\n            responder = new AvroSpecificResponder(configuration.getProtocol(), this);\n        }\n\n\n        if (AVRO_HTTP_TRANSPORT.equalsIgnoreCase(configuration.getTransport().name())) {\n            server = new HttpServer(responder, configuration.getPort());\n        } else if (AVRO_NETTY_TRANSPORT.equalsIgnoreCase(configuration.getTransport().name())) {\n            server = new NettyServer(responder, new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        } else {\n            throw new IllegalArgumentException(\"Unknown transport \" + configuration.getTransport());\n        }\n\n        server.start();\n\n        return server;\n    }","commit_id":"e49c560a62d5473d0b7f4e88bb23cebf741b4fb2","url":"https://github.com/apache/camel"},{"original_method":"@Nullable\n  @Override\n  public FileType getFileType(@NotNull Url url) {\n    return SCHEME.equals(url.getScheme()) || DartUrlResolver.PACKAGE_SCHEME.equals(url.getScheme()) ? DartFileType.INSTANCE : null;\n  }","id":41597,"modified_method":"@Nullable\n  @Override\n  public FileType getFileType(@NotNull Url url) {\n    return DartUrlResolver.DART_SCHEME.equals(url.getScheme()) || DartUrlResolver.PACKAGE_SCHEME.equals(url.getScheme())\n           ? DartFileType.INSTANCE\n           : null;\n  }","commit_id":"9362de88f3c2d57d4eac754fde11e1f348d25fde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public VirtualFile getFile(@NotNull final Url url, @NotNull final Project project, @Nullable Url requestor) {\n    if (DartUrlResolver.DART_SCHEME.equals(url.getScheme())) {\n      return DartUrlResolver.findFileInDartSdkLibFolder(project, DartSdk.getDartSdk(project), DartUrlResolver.DART_PREFIX + url.getPath());\n    }\n\n    if (DartUrlResolver.PACKAGE_SCHEME.equals(url.getScheme())) {\n      final String packageUrl = DartUrlResolver.PACKAGE_PREFIX + url.getPath();\n      final VirtualFile contextFile = findContextFile(project, requestor);\n\n      if (contextFile != null) {\n        return ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n          public VirtualFile compute() {\n            return DartUrlResolver.getInstance(project, contextFile).findFileByDartUrl(packageUrl);\n          }\n        });\n      }\n      else {\n        if (ApplicationManager.getApplication().isDispatchThread()) {\n          return DumbService.getInstance(project).isDumb() ? null : findFileInAnyPackagesFolder(project, packageUrl);\n        }\n\n        return DumbService.getInstance(project).runReadActionInSmartMode(new Computable<VirtualFile>() {\n          @Override\n          public VirtualFile compute() {\n            return findFileInAnyPackagesFolder(project, packageUrl);\n          }\n        });\n      }\n    }\n\n    return null;\n  }","id":41598,"modified_method":"@Nullable\n  @Override\n  public VirtualFile getFile(@NotNull final Url url, @NotNull final Project project, @Nullable Url requestor) {\n    final String scheme = url.getScheme();\n    final String path = url.getPath();\n\n    if (DartUrlResolver.DART_SCHEME.equals(scheme)) {\n      return DartUrlResolver.findFileInDartSdkLibFolder(project, DartSdk.getDartSdk(project), DartUrlResolver.DART_PREFIX + path);\n    }\n\n    if (DartUrlResolver.PACKAGE_SCHEME.equals(scheme)) {\n      final String packageUrl = DartUrlResolver.PACKAGE_PREFIX + path;\n      final VirtualFile contextFile = findContextFile(project, requestor);\n\n      if (contextFile != null) {\n        return ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n          public VirtualFile compute() {\n            return DartUrlResolver.getInstance(project, contextFile).findFileByDartUrl(packageUrl);\n          }\n        });\n      }\n      else {\n        if (ApplicationManager.getApplication().isDispatchThread()) {\n          return DumbService.getInstance(project).isDumb() ? null : findFileInAnyPackagesFolder(project, packageUrl);\n        }\n\n        return DumbService.getInstance(project).runReadActionInSmartMode(new Computable<VirtualFile>() {\n          @Override\n          public VirtualFile compute() {\n            return findFileInAnyPackagesFolder(project, packageUrl);\n          }\n        });\n      }\n    }\n\n    final int sdkUrlMarkerIndex = path.indexOf(SDK_URL_MARKER);\n    if (\"http\".equalsIgnoreCase(scheme) && sdkUrlMarkerIndex >= 0) {\n      // http://localhost:63343/dart-tagtree/example/packages/$sdk/lib/_internal/js_runtime/lib/js_helper.dart\n      final String relPath = path.substring(sdkUrlMarkerIndex + SDK_URL_MARKER.length());\n      return DartUrlResolver.findFileInDartSdkLibFolder(project, DartSdk.getDartSdk(project), DartUrlResolver.DART_PREFIX + relPath);\n    }\n\n    return null;\n  }","commit_id":"9362de88f3c2d57d4eac754fde11e1f348d25fde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Generates a Java package name from a URI according to the\n     * algorithm outlined in JAXB 2.0.\n     * \n     * @param namespaceURI the namespace URI.\n     * @return the package name.\n     */\n    public static String nameSpaceURIToPackage(URI uri) {\n       \n        StringBuilder packageName = new StringBuilder();\n        String authority = uri.getAuthority();\n        if (authority == null && \"urn\".equals(uri.getScheme())) {\n            authority = uri.getSchemeSpecificPart();\n        }\n        \n        if (null != authority && !\"\".equals(authority)) {\n            if (\"urn\".equals(uri.getScheme())) {\n                packageName.append(authority);\n                for (int i = 0; i < packageName.length(); i++) {\n                    if (packageName.charAt(i) == '-') {\n                        packageName.setCharAt(i, '.');\n                    } \n                }\n                authority = packageName.toString();\n                packageName.setLength(0);\n                \n                StringTokenizer st = new StringTokenizer(authority, \":\");\n                while (st.hasMoreTokens()) {\n                    String token = st.nextToken();\n                    if (packageName.length() > 0) {\n                        packageName.insert(0, \".\");\n                        packageName.insert(0, normalizePackageNamePart(token));\n                    } else {\n                        packageName.insert(0, token);\n                    }\n                }\n                authority = packageName.toString();\n                packageName.setLength(0);\n                \n            }  \n            \n            StringTokenizer st = new StringTokenizer(authority, \".\");\n            if (st.hasMoreTokens()) {\n                String token = null;\n                while (st.hasMoreTokens()) {\n                    token = st.nextToken();\n                    if (packageName.length() == 0) {\n                        if (\"www\".equals(token)) {\n                            continue;\n                        }\n                    } else {\n                        packageName.insert(0, \".\");\n                    }\n                    packageName.insert(0, normalizePackageNamePart(token));\n                }\n               \n            }\n        }\n\n        String path = uri.getPath();\n        if (path == null) {\n            path = \"\";\n        }\n        int index = path.lastIndexOf('.');\n        if (index < 0) {\n            index = path.length();\n        }\n        StringTokenizer st = new StringTokenizer(path.substring(0, index), \"/\");\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (packageName.length() > 0) {\n                packageName.append('.');\n            }\n            packageName.append(normalizePackageNamePart(token));\n        }\n        return packageName.toString();\n    }","id":41599,"modified_method":"/**\n     * Generates a Java package name from a URI according to the\n     * algorithm outlined in Appendix D of JAXB (2.0+).\n     * \n     * @param namespaceURI the namespace URI.\n     * @return the package name.\n     */\n    public static String nameSpaceURIToPackage(URI uri) {\n       \n        StringBuilder packageName = new StringBuilder();\n        String authority = uri.getAuthority();\n        String scheme = uri.getScheme();\n        if (authority == null && \"urn\".equals(scheme)) {\n            authority = uri.getSchemeSpecificPart();\n        }\n        \n        if (null != authority && !\"\".equals(authority)) {\n            if (\"urn\".equals(scheme)) {\n                packageName.append(authority);\n                /* JAXB 2.2 D.5.1, Rule #5 */\n                for (int i = 0; i < packageName.length(); i++) {\n                    if (packageName.charAt(i) == '-') {\n                        packageName.setCharAt(i, '.');\n                    } \n                }\n                authority = packageName.toString();\n                packageName.setLength(0);\n                \n                StringTokenizer st = new StringTokenizer(authority, \":\");\n                while (st.hasMoreTokens()) {\n                    String token = st.nextToken();\n                    if (packageName.length() > 0) {\n                        packageName.insert(0, \".\");\n                        packageName.insert(0, normalizePackageNamePart(token));\n                    } else {\n                        packageName.insert(0, token);\n                    }\n                }\n                authority = packageName.toString();\n                packageName.setLength(0);\n                \n            }  \n            \n            StringTokenizer st = new StringTokenizer(authority, \".\");\n            if (st.hasMoreTokens()) {\n                String token = null;\n                while (st.hasMoreTokens()) {\n                    token = st.nextToken();\n                    if (packageName.length() == 0) {\n                        if (\"www\".equals(token)) {\n                            continue;\n                        }\n                    } else {\n                        packageName.insert(0, \".\");\n                    }\n                    packageName.insert(0, normalizePackageNamePart(token));\n                }\n            }\n            \n            if (!(\"http\".equalsIgnoreCase(scheme) || \"urn\".equalsIgnoreCase(scheme))) {\n                packageName.insert(0, \".\");\n                packageName.insert(0, normalizePackageNamePart(scheme));\n            }\n            \n        }\n\n        String path = uri.getPath();\n        if (path == null) {\n            path = \"\";\n        }\n        /* JAXB 2.2 D.5.1 Rule 2 - remove trailing .??, .???, or .html only. */\n        int index = path.lastIndexOf('.');\n        if (index < 0) {\n            index = path.length();\n        } else {\n            String ending = path.substring(index + 1);\n            if (ending.length() < 2 || (ending.length() > 3 \n                && !\"html\".equalsIgnoreCase(ending))) {\n                index = path.length();\n            }\n        }\n        StringTokenizer st = new StringTokenizer(path.substring(0, index), \"/\");\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (packageName.length() > 0) {\n                packageName.append('.');\n            }\n            packageName.append(normalizePackageNamePart(token));\n        }\n        return packageName.toString();\n    }","commit_id":"533492132a6fcdd8f37fd031ea87e376d6bb7914","url":"https://github.com/apache/cxf"},{"original_method":"/** \n     * Checks if the specified word is a Java keyword (as of 1.5).\n     * \n     * @param word the word to check.\n     * @return true if the word is a keyword.\n     */\n    public static boolean isJavaKeyword(String word) {\n        return JavaUtils.isJavaKeyword(word);\n    }","id":41600,"modified_method":"/** \n     * Checks if the specified word is a Java keyword (as defined in JavaUtils).\n     * \n     * @param word the word to check.\n     * @return true if the word is a keyword.\n     * @see org.apache.cxf.helpers.JavaUtils\n     */\n    protected static boolean isJavaKeyword(String word) {\n        return JavaUtils.isJavaKeyword(word);\n    }","commit_id":"533492132a6fcdd8f37fd031ea87e376d6bb7914","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPackageNames() {\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types\"));\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.xsd\"));\n        assertEquals(\"org.apache.cxf.config_types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/config-types\"));\n        assertEquals(\"org.apache.cxf._default.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/default/types\"));\n        assertEquals(\"org.apache.cxf.config._4types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/config/4types.\"));\n        assertEquals(\"com.iona.configuration.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://www.iona.com/configuration/types\"));\n        assertEquals(\"org.apache.cxf.config.types\",\n                     JAXBUtils.namespaceURIToPackage(\"urn://cxf-apache-org/config/types\"));\n        assertEquals(\"types\", JAXBUtils.namespaceURIToPackage(\"types\"));\n    }","id":41601,"modified_method":"@Test\n    public void testPackageNames() {\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types\"));\n\n        // tests of JAXB 2.2 Appendix D.5.1, Rule #1: schemes to be removed are just http and urn\n        assertEquals(\"auto.org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"auto://cxf.apache.org/configuration/types\"));\n        assertEquals(\"mouse.org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"mouse://cxf.apache.org/configuration/types\"));\n        assertEquals(\"h.org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"h://cxf.apache.org/configuration/types\"));\n\n        // tests of JAXB 2.2 Appendix D.5.1, Rule #2: file type is one of .?? or .??? or .html\n        assertEquals(\"org.apache.cxf.configuration.types_h\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.h\"));\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.hi\"));\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.xsd\"));\n        assertEquals(\"org.apache.cxf.configuration.types\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.html\"));\n        assertEquals(\"org.apache.cxf.configuration.types_auto\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.auto\"));\n        assertEquals(\"org.apache.cxf.configuration.types_mouse\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/configuration/types.mouse\"));\n        \n        // other tests\n        assertEquals(\"https.com.mytech.rosette_analysis\",\n                JAXBUtils.namespaceURIToPackage(\"https://mytech.com/rosette.analysis\"));\n        assertEquals(\"org.apache.cxf.config._4types_\",\n                JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/config/4types.\"));\n        assertEquals(\"org.apache.cxf.config_types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/config-types\"));\n        assertEquals(\"org.apache.cxf._default.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://cxf.apache.org/default/types\"));\n        assertEquals(\"com.progress.configuration.types\",\n                     JAXBUtils.namespaceURIToPackage(\"http://www.progress.com/configuration/types\"));\n        assertEquals(\"org.apache.cxf.config.types\",\n                JAXBUtils.namespaceURIToPackage(\"urn:cxf-apache-org:config:types\"));\n        assertEquals(\"types\", JAXBUtils.namespaceURIToPackage(\"types\"));\n    }","commit_id":"533492132a6fcdd8f37fd031ea87e376d6bb7914","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Checks and updates the structure id or the path of the target.<p>  \n     * \n     * @param cms the cms context\n     */\n    public void checkConsistency(CmsObject cms) {\n\n        m_resource = null;\n        if (!m_internal || (cms == null)) {\n            return;\n        }\n        try {\n            if (m_structureId == null) {\n                // try by path\n                throw new CmsException(Messages.get().container(Messages.LOG_BROKEN_LINK_NO_ID_0));\n            }\n            // first look for the resource with the given structure id\n            String rootPath = null;\n            CmsResource res;\n            try {\n                res = cms.readResource(m_structureId, CmsResourceFilter.ALL);\n                m_resource = res;\n                rootPath = res.getRootPath();\n                if (!res.getRootPath().equals(m_target)) {\n                    // update path if needed\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(Messages.get().getBundle().key(\n                            Messages.LOG_BROKEN_LINK_UPDATED_BY_ID_3,\n                            m_structureId,\n                            m_target,\n                            res.getRootPath()));\n                    }\n\n                }\n            } catch (CmsException e) {\n                // not found\n                throw new CmsVfsResourceNotFoundException(org.opencms.db.generic.Messages.get().container(\n                    org.opencms.db.generic.Messages.ERR_READ_RESOURCE_1,\n                    m_target));\n            }\n            if ((rootPath != null) && !rootPath.equals(m_target)) {\n                // set the new target\n                m_target = res.getRootPath();\n                setUri();\n                // update xml node\n                CmsLinkUpdateUtil.updateXml(this, m_element, true);\n            }\n        } catch (CmsException e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(Messages.get().getBundle().key(Messages.LOG_BROKEN_LINK_BY_ID_2, m_target, m_structureId), e);\n            }\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_target)) {\n                // no correction is possible\n                return;\n            }\n            // go on with the resource with the given path\n            String siteRoot = cms.getRequestContext().getSiteRoot();\n            try {\n                cms.getRequestContext().setSiteRoot(\"\");\n                // now look for the resource with the given path\n                CmsResource res = cms.readResource(m_target, CmsResourceFilter.ALL);\n                m_resource = res;\n                if (!res.getStructureId().equals(m_structureId)) {\n                    // update structure id if needed\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(Messages.get().getBundle().key(\n                            Messages.LOG_BROKEN_LINK_UPDATED_BY_NAME_3,\n                            m_target,\n                            m_structureId,\n                            res.getStructureId()));\n                    }\n                    m_target = res.getRootPath(); // could change by a translation rule\n                    m_structureId = res.getStructureId();\n                    CmsLinkUpdateUtil.updateXml(this, m_element, true);\n                }\n            } catch (CmsException e1) {\n                // no correction was possible\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_BROKEN_LINK_BY_NAME_1, m_target), e1);\n                }\n                m_structureId = null;\n            } finally {\n                cms.getRequestContext().setSiteRoot(siteRoot);\n            }\n        }\n    }","id":41602,"modified_method":"/**\n     * Checks and updates the structure id or the path of the target.<p>  \n     * \n     * @param cms the cms context\n     */\n    public void checkConsistency(CmsObject cms) {\n\n        if (!m_internal || (cms == null)) {\n            return;\n        }\n        try {\n            if (m_structureId == null) {\n                // try by path\n                throw new CmsException(Messages.get().container(Messages.LOG_BROKEN_LINK_NO_ID_0));\n            }\n            // first look for the resource with the given structure id\n            String rootPath = null;\n            CmsResource res;\n            try {\n                res = cms.readResource(m_structureId, CmsResourceFilter.ALL);\n                rootPath = res.getRootPath();\n                if (!res.getRootPath().equals(m_target)) {\n                    // update path if needed\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(Messages.get().getBundle().key(\n                            Messages.LOG_BROKEN_LINK_UPDATED_BY_ID_3,\n                            m_structureId,\n                            m_target,\n                            res.getRootPath()));\n                    }\n\n                }\n            } catch (CmsException e) {\n                // not found\n                throw new CmsVfsResourceNotFoundException(org.opencms.db.generic.Messages.get().container(\n                    org.opencms.db.generic.Messages.ERR_READ_RESOURCE_1,\n                    m_target));\n            }\n            if ((rootPath != null) && !rootPath.equals(m_target)) {\n                // set the new target\n                m_target = res.getRootPath();\n                setUri();\n                // update xml node\n                CmsLinkUpdateUtil.updateXml(this, m_element, true);\n            }\n        } catch (CmsException e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(Messages.get().getBundle().key(Messages.LOG_BROKEN_LINK_BY_ID_2, m_target, m_structureId), e);\n            }\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_target)) {\n                // no correction is possible\n                return;\n            }\n            // go on with the resource with the given path\n            String siteRoot = cms.getRequestContext().getSiteRoot();\n            try {\n                cms.getRequestContext().setSiteRoot(\"\");\n                // now look for the resource with the given path\n                CmsResource res = cms.readResource(m_target, CmsResourceFilter.ALL);\n                if (!res.getStructureId().equals(m_structureId)) {\n                    // update structure id if needed\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(Messages.get().getBundle().key(\n                            Messages.LOG_BROKEN_LINK_UPDATED_BY_NAME_3,\n                            m_target,\n                            m_structureId,\n                            res.getStructureId()));\n                    }\n                    m_target = res.getRootPath(); // could change by a translation rule\n                    m_structureId = res.getStructureId();\n                    CmsLinkUpdateUtil.updateXml(this, m_element, true);\n                }\n            } catch (CmsException e1) {\n                // no correction was possible\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_BROKEN_LINK_BY_NAME_1, m_target), e1);\n                }\n                m_structureId = null;\n            } finally {\n                cms.getRequestContext().setSiteRoot(siteRoot);\n            }\n        }\n    }","commit_id":"a622ee75fb6b666668a1c8da46bf0952278ec1da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof CmsUriSplitter) {\n            CmsUriSplitter other = (CmsUriSplitter)obj;\n            if (((m_prefix == null) && (other.m_prefix != null)) && (!other.m_prefix.equals(m_prefix))) {\n                return false;\n            }\n            if (((m_anchor == null) && (other.m_anchor != null)) && (!other.m_anchor.equals(m_anchor))) {\n                return false;\n            }\n            if (((m_query == null) && (other.m_query != null)) && (!other.m_query.equals(m_query))) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }","id":41603,"modified_method":"/**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof CmsUriSplitter) {\n            CmsUriSplitter other = (CmsUriSplitter)obj;\n            if (!((m_protocol == other.m_protocol) || ((m_protocol != null) && m_protocol.equals(other.m_protocol)))) {\n                return false;\n            }\n            if (!((m_prefix == other.m_prefix) || ((m_prefix != null) && m_prefix.equals(other.m_prefix)))) {\n                return false;\n            }\n            if (!((m_anchor == other.m_anchor) || ((m_anchor != null) && m_anchor.equals(other.m_anchor)))) {\n                return false;\n            }\n            if (!((m_query == other.m_query) || ((m_query != null) && m_query.equals(other.m_query)))) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"a622ee75fb6b666668a1c8da46bf0952278ec1da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a splitted URI using the given parsing mode.<p>\n     * \n     * Using 'strict' parsing mode, all requirements for an URI are checked. \n     * If 'strict' is set to <code>false<\/code>, then only some simple parsing rules are applied,\n     * in which case the result may not be 100% valid (but still usable).\n     * If 'strict' parsing generates an error, then simple parsing is used as a fallback.<p>\n     *    \n     * @param uri the URI to split\n     * @param strict if <code>true<\/code>, then 'strict' parsing mode is used, otherwise a relaxed URI parsing is done\n     */\n    public CmsUriSplitter(String uri, boolean strict) {\n\n        m_uri = uri;\n        m_errorFree = true;\n        m_isStrict = strict;\n\n        if (strict) {\n\n            // use strict parsing \n            try {\n                URI u = new URI(uri);\n                m_prefix = ((u.getScheme() != null) ? u.getScheme() + \":\" : \"\") + u.getRawSchemeSpecificPart();\n                m_anchor = u.getRawFragment();\n                m_query = u.getRawQuery();\n                if (m_prefix != null) {\n                    int i = m_prefix.indexOf('?');\n                    if (i != -1) {\n                        m_query = m_prefix.substring(i + 1);\n                        m_prefix = m_prefix.substring(0, i);\n                    }\n                }\n                if (m_anchor != null) {\n                    int i = m_anchor.indexOf('?');\n                    if (i != -1) {\n                        m_query = m_anchor.substring(i + 1);\n                        m_anchor = m_anchor.substring(0, i);\n                    }\n                }\n            } catch (Exception exc) {\n                // may be thrown by URI constructor if URI is invalid\n                strict = false;\n                m_errorFree = false;\n            }\n        }\n\n        if ((!strict) && (uri != null)) {\n\n            // use simple parsing\n            StringBuffer prefix = new StringBuffer(uri.length());\n            StringBuffer anchor = EMPTY_BUFFER;\n            StringBuffer query = EMPTY_BUFFER;\n\n            int len = uri.length();\n            int cur = 0;\n\n            for (int i = 0; i < len; i++) {\n                char c = uri.charAt(i);\n                if (c == '#') {\n                    // start of anchor\n                    cur = 1;\n                    anchor = new StringBuffer(uri.length());\n                    continue;\n                }\n                if (c == '?') {\n                    // start of query\n                    cur = 2;\n                    // ensure a duplicate query part is 'flushed' (same behavior as strict parser)\n                    query = new StringBuffer(uri.length());\n                    continue;\n                }\n                switch (cur) {\n                    case 1:\n                        // append to anchor\n                        anchor.append(c);\n                        break;\n                    case 2:\n                        // append to query\n                        query.append(c);\n                        break;\n                    default:\n                        // append to prefix\n                        prefix.append(c);\n                        break;\n                }\n            }\n\n            if (prefix.length() > 0) {\n                m_prefix = prefix.toString();\n            }\n            if (anchor.length() > 0) {\n                m_anchor = anchor.toString();\n            }\n            if (query.length() > 0) {\n                m_query = query.toString();\n            }\n        }\n    }","id":41604,"modified_method":"/**\n     * Creates a splitted URI using the given parsing mode.<p>\n     * \n     * Using 'strict' parsing mode, all requirements for an URI are checked. \n     * If 'strict' is set to <code>false<\/code>, then only some simple parsing rules are applied,\n     * in which case the result may not be 100% valid (but still usable).\n     * If 'strict' parsing generates an error, then simple parsing is used as a fallback.<p>\n     *    \n     * @param uri the URI to split\n     * @param strict if <code>true<\/code>, then 'strict' parsing mode is used, otherwise a relaxed URI parsing is done\n     */\n    public CmsUriSplitter(String uri, boolean strict) {\n\n        m_uri = uri;\n        m_errorFree = true;\n        m_isStrict = strict;\n\n        if (strict) {\n\n            // use strict parsing \n            try {\n                URI u = new URI(uri);\n                m_protocol = u.getScheme();\n                m_prefix = ((m_protocol != null) ? m_protocol + \":\" : \"\") + u.getRawSchemeSpecificPart();\n                m_anchor = u.getRawFragment();\n                m_query = u.getRawQuery();\n                if (m_prefix != null) {\n                    int i = m_prefix.indexOf('?');\n                    if (i != -1) {\n                        m_query = m_prefix.substring(i + 1);\n                        m_prefix = m_prefix.substring(0, i);\n                    }\n                }\n                if (m_anchor != null) {\n                    int i = m_anchor.indexOf('?');\n                    if (i != -1) {\n                        m_query = m_anchor.substring(i + 1);\n                        m_anchor = m_anchor.substring(0, i);\n                    }\n                }\n            } catch (Exception exc) {\n                // may be thrown by URI constructor if URI is invalid\n                strict = false;\n                m_errorFree = false;\n            }\n        }\n\n        if ((!strict) && (uri != null)) {\n\n            // use simple parsing\n            StringBuffer prefix = new StringBuffer(uri.length());\n            StringBuffer anchor = EMPTY_BUFFER;\n            StringBuffer query = EMPTY_BUFFER;\n\n            int len = uri.length();\n            int cur = 0;\n\n            for (int i = 0; i < len; i++) {\n                char c = uri.charAt(i);\n                if ((cur == 0) && (c == ':')) {\n                    m_protocol = prefix.toString();\n                }\n                if (c == '#') {\n                    // start of anchor\n                    cur = 1;\n                    anchor = new StringBuffer(uri.length());\n                    continue;\n                }\n                if (c == '?') {\n                    // start of query\n                    cur = 2;\n                    // ensure a duplicate query part is 'flushed' (same behavior as strict parser)\n                    query = new StringBuffer(uri.length());\n                    continue;\n                }\n                switch (cur) {\n                    case 1:\n                        // append to anchor\n                        anchor.append(c);\n                        break;\n                    case 2:\n                        // append to query\n                        query.append(c);\n                        break;\n                    default:\n                        // append to prefix\n                        prefix.append(c);\n                        break;\n                }\n            }\n\n            if (prefix.length() > 0) {\n                m_prefix = prefix.toString();\n            }\n            if (anchor.length() > 0) {\n                m_anchor = anchor.toString();\n            }\n            if (query.length() > 0) {\n                m_query = query.toString();\n            }\n        }\n    }","commit_id":"a622ee75fb6b666668a1c8da46bf0952278ec1da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.types.A_CmsXmlContentValue#setStringValue(org.opencms.file.CmsObject, java.lang.String)\n     */\n    public void setStringValue(CmsObject cms, String value) throws CmsIllegalArgumentException {\n\n        // element is rebuild from given String value below\n        m_element.clearContent();\n        // link value is re-calculated below\n        m_linkValue = null;\n        // ensure the String value is re-calculated next time it's needed\n        m_stringValue = null;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(value)) {\n            // no valid value given\n            return;\n        }\n        String path = value;\n        if (cms != null) {\n            String siteRoot = OpenCms.getSiteManager().getSiteRoot(value);\n            String oldSite = cms.getRequestContext().getSiteRoot();\n            try {\n                if (siteRoot != null) {\n                    // only switch the site if needed\n                    cms.getRequestContext().setSiteRoot(siteRoot);\n                    // remove the site root, because the link manager call will append it anyway\n                    path = cms.getRequestContext().removeSiteRoot(value);\n                }\n                // remove parameters, if not the link manager call might fail\n                String query = \"\";\n                int pos = path.indexOf(CmsRequestUtil.URL_DELIMITER);\n                int anchorPos = path.indexOf('#');\n                if ((pos == -1) || ((anchorPos > -1) && (pos > anchorPos))) {\n                    pos = anchorPos;\n                }\n                if (pos > -1) {\n                    query = path.substring(pos);\n                    path = path.substring(0, pos);\n                }\n                // get the root path\n                path = OpenCms.getLinkManager().getRootPath(cms, path);\n                if (path != null) {\n                    // append parameters again\n                    path += query;\n                }\n            } finally {\n                if (siteRoot != null) {\n                    cms.getRequestContext().setSiteRoot(oldSite);\n                }\n            }\n        }\n        boolean internal = (path != null);\n        CmsRelationType type;\n        if (internal) {\n            type = getContentDefinition().getContentHandler().getRelationType(getPath());\n        } else {\n            // use original value for external links\n            path = value;\n            // external links are always \"weak\"\n            type = CmsRelationType.XML_WEAK;\n        }\n        CmsLink link = new CmsLink(TYPE_VAR_LINK, type, path, internal);\n        if (internal) {\n            // link management check for internal links\n            link.checkConsistency(cms);\n        }\n        // update xml node\n        CmsLinkUpdateUtil.updateXmlForHtmlValue(link, null, m_element.addElement(CmsXmlPage.NODE_LINK));\n        // store the calculated link\n        m_linkValue = link;\n    }","id":41605,"modified_method":"/**\n     * @see org.opencms.xml.types.A_CmsXmlContentValue#setStringValue(org.opencms.file.CmsObject, java.lang.String)\n     */\n    public void setStringValue(CmsObject cms, String value) throws CmsIllegalArgumentException {\n\n        // element is rebuild from given String value below\n        m_element.clearContent();\n        // link value is re-calculated below\n        m_linkValue = null;\n        // ensure the String value is re-calculated next time it's needed\n        m_stringValue = null;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(value)) {\n            // no valid value given\n            return;\n        }\n\n        String path = value;\n        if (cms != null) {\n            String siteRoot = OpenCms.getSiteManager().getSiteRoot(value);\n            String oldSite = cms.getRequestContext().getSiteRoot();\n            try {\n                if (siteRoot != null) {\n                    // only switch the site if needed\n                    cms.getRequestContext().setSiteRoot(siteRoot);\n                    // remove the site root, because the link manager call will append it anyway\n                    path = cms.getRequestContext().removeSiteRoot(value);\n                }\n                // remove parameters, if not the link manager call might fail\n                String query = \"\";\n                int pos = path.indexOf(CmsRequestUtil.URL_DELIMITER);\n                int anchorPos = path.indexOf('#');\n                if ((pos == -1) || ((anchorPos > -1) && (pos > anchorPos))) {\n                    pos = anchorPos;\n                }\n                if (pos > -1) {\n                    query = path.substring(pos);\n                    path = path.substring(0, pos);\n                }\n                // get the root path\n                path = OpenCms.getLinkManager().getRootPath(cms, path);\n                if (path != null) {\n                    // append parameters again\n                    path += query;\n                }\n            } finally {\n                if (siteRoot != null) {\n                    cms.getRequestContext().setSiteRoot(oldSite);\n                }\n            }\n        }\n        boolean internal = (path != null);\n        CmsRelationType type;\n        if (internal) {\n            type = getContentDefinition().getContentHandler().getRelationType(getPath());\n        } else {\n            // use original value for external links\n            path = value;\n            // external links are always \"weak\"\n            type = CmsRelationType.XML_WEAK;\n        }\n        CmsLink link = new CmsLink(TYPE_VAR_LINK, type, path, internal);\n        if (internal) {\n            // link management check for internal links\n            link.checkConsistency(cms);\n            if ((link.getStructureId() == null) && (new CmsUriSplitter(value).getProtocol() != null)) {\n                // checking consistency of an absolute link considered internal failed, assume external\n                link = new CmsLink(TYPE_VAR_LINK, CmsRelationType.XML_WEAK, value, false);\n            }\n        }\n        // update xml node\n        CmsLinkUpdateUtil.updateXmlForHtmlValue(link, null, m_element.addElement(CmsXmlPage.NODE_LINK));\n        // store the calculated link\n        m_linkValue = link;\n    }","commit_id":"a622ee75fb6b666668a1c8da46bf0952278ec1da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Test\n    public void testRequestWithPriorityWithContinuationFramesWithEmptyHeadersFrame() throws Exception\n    {\n        PriorityFrame priority = new PriorityFrame(1, 13, 200, true);\n        testRequestWithContinuationFrames(null, () ->\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.control(lease, new PrefaceFrame());\n            generator.control(lease, new SettingsFrame(new HashMap<>(), false));\n            MetaData.Request metaData = newRequest(\"GET\", new HttpFields());\n            generator.control(lease, new HeadersFrame(1, metaData, priority, true));\n            // Take the HeadersFrame header and set the length to just the priority frame.\n            List<ByteBuffer> buffers = lease.getByteBuffers();\n            ByteBuffer headersFrameHeader = buffers.get(2);\n            headersFrameHeader.put(0, (byte)0);\n            headersFrameHeader.putShort(1, (short)PriorityFrame.PRIORITY_LENGTH);\n            // Insert a CONTINUATION frame header for the body of the HEADERS frame.\n            lease.insert(4, buffers.get(5).slice(), false);\n            return lease;\n        });\n    }","id":41606,"modified_method":"@Test\n    public void testRequestWithPriorityWithContinuationFramesWithEmptyHeadersFrame() throws Exception\n    {\n        PriorityFrame priority = new PriorityFrame(1, 13, 200, true);\n        testRequestWithContinuationFrames(null, () ->\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.control(lease, new PrefaceFrame());\n            generator.control(lease, new SettingsFrame(new HashMap<>(), false));\n            MetaData.Request metaData = newRequest(\"GET\", new HttpFields());\n            generator.control(lease, new HeadersFrame(1, metaData, priority, true));\n            // Take the HeadersFrame header and set the length to just the priority frame.\n            List<ByteBuffer> buffers = lease.getByteBuffers();\n            ByteBuffer headersFrameHeader = buffers.get(2);\n            headersFrameHeader.put(0, (byte)0);\n            headersFrameHeader.putShort(1, (short)PriorityFrame.PRIORITY_LENGTH);\n            // Insert a CONTINUATION frame header for the body of the HEADERS frame.\n            lease.insert(3, buffers.get(4).slice(), false);\n            return lease;\n        });\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean parse(ByteBuffer buffer)\n    {\n        boolean loop = false;\n        while (buffer.hasRemaining() || loop)\n        {\n            switch (state)\n            {\n                case PREPARE:\n                {\n                    // SPEC: wrong streamId is treated as connection error.\n                    if (getStreamId() == 0)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_headers_frame\");\n\n                    length = getBodyLength();\n\n                    if (isPadding())\n                    {\n                        state = State.PADDING_LENGTH;\n                    }\n                    else if (hasFlag(Flags.PRIORITY))\n                    {\n                        state = State.EXCLUSIVE;\n                    }\n                    else\n                    {\n                        state = State.HEADERS;\n                    }\n                    break;\n                }\n                case PADDING_LENGTH:\n                {\n                    paddingLength = buffer.get() & 0xFF;\n                    --length;\n                    length -= paddingLength;\n                    state = hasFlag(Flags.PRIORITY) ? State.EXCLUSIVE : State.HEADERS;\n                    loop = length == 0;\n                    if (length < 0)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame_padding\");\n                    break;\n                }\n                case EXCLUSIVE:\n                {\n                    // We must only peek the first byte and not advance the buffer\n                    // because the 31 least significant bits represent the stream id.\n                    int currByte = buffer.get(buffer.position());\n                    exclusive = (currByte & 0x80) == 0x80;\n                    state = State.PARENT_STREAM_ID;\n                    break;\n                }\n                case PARENT_STREAM_ID:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        parentStreamId = buffer.getInt();\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        length -= 4;\n                        state = State.WEIGHT;\n                        if (length < 1)\n                            return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    }\n                    else\n                    {\n                        state = State.PARENT_STREAM_ID_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case PARENT_STREAM_ID_BYTES:\n                {\n                    int currByte = buffer.get() & 0xFF;\n                    --cursor;\n                    parentStreamId += currByte << (8 * cursor);\n                    --length;\n                    if (cursor > 0 && length <= 0)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    if (cursor == 0)\n                    {\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                        if (length < 1)\n                            return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    }\n                    break;\n                }\n                case WEIGHT:\n                {\n                    weight = buffer.get() & 0xFF;\n                    --length;\n                    state = State.HEADERS;\n                    loop = length == 0;\n                    break;\n                }\n                case HEADERS:\n                {\n                    if (hasFlag(Flags.END_HEADERS))\n                    {\n                        MetaData metaData = headerBlockParser.parse(buffer, length);\n                        if (metaData != null)\n                        {\n                            state = State.PADDING;\n                            loop = paddingLength == 0;\n                            onHeaders(parentStreamId, weight, exclusive, metaData);\n                        }\n                    }\n                    else\n                    {\n                        int remaining = buffer.remaining();\n                        if (remaining < length)\n                        {\n                            headerBlockFragments.storeFragment(buffer, remaining, false);\n                            length -= remaining;\n                        }\n                        else\n                        {\n                            headerBlockFragments.setStreamId(getStreamId());\n                            headerBlockFragments.setEndStream(isEndStream());\n                            if (hasFlag(Flags.PRIORITY))\n                                headerBlockFragments.setPriorityFrame(new PriorityFrame(getStreamId(), parentStreamId, weight, exclusive));\n                            headerBlockFragments.storeFragment(buffer, length, false);\n                            state = State.PADDING;\n                            loop = paddingLength == 0;\n                        }\n                    }\n                    break;\n                }\n                case PADDING:\n                {\n                    int size = Math.min(buffer.remaining(), paddingLength);\n                    buffer.position(buffer.position() + size);\n                    paddingLength -= size;\n                    if (paddingLength == 0)\n                    {\n                        reset();\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","id":41607,"modified_method":"@Override\n    public boolean parse(ByteBuffer buffer)\n    {\n        boolean loop = false;\n        while (buffer.hasRemaining() || loop)\n        {\n            switch (state)\n            {\n                case PREPARE:\n                {\n                    // SPEC: wrong streamId is treated as connection error.\n                    if (getStreamId() == 0)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_headers_frame\");\n\n                    length = getBodyLength();\n\n                    if (isPadding())\n                    {\n                        state = State.PADDING_LENGTH;\n                    }\n                    else if (hasFlag(Flags.PRIORITY))\n                    {\n                        state = State.EXCLUSIVE;\n                    }\n                    else\n                    {\n                        state = State.HEADERS;\n                    }\n                    break;\n                }\n                case PADDING_LENGTH:\n                {\n                    paddingLength = buffer.get() & 0xFF;\n                    --length;\n                    length -= paddingLength;\n                    state = hasFlag(Flags.PRIORITY) ? State.EXCLUSIVE : State.HEADERS;\n                    loop = length == 0;\n                    if (length < 0)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame_padding\");\n                    break;\n                }\n                case EXCLUSIVE:\n                {\n                    // We must only peek the first byte and not advance the buffer\n                    // because the 31 least significant bits represent the stream id.\n                    int currByte = buffer.get(buffer.position());\n                    exclusive = (currByte & 0x80) == 0x80;\n                    state = State.PARENT_STREAM_ID;\n                    break;\n                }\n                case PARENT_STREAM_ID:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        parentStreamId = buffer.getInt();\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        length -= 4;\n                        state = State.WEIGHT;\n                        if (length < 1)\n                            return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    }\n                    else\n                    {\n                        state = State.PARENT_STREAM_ID_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case PARENT_STREAM_ID_BYTES:\n                {\n                    int currByte = buffer.get() & 0xFF;\n                    --cursor;\n                    parentStreamId += currByte << (8 * cursor);\n                    --length;\n                    if (cursor > 0 && length <= 0)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    if (cursor == 0)\n                    {\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                        if (length < 1)\n                            return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_headers_frame\");\n                    }\n                    break;\n                }\n                case WEIGHT:\n                {\n                    weight = (buffer.get() & 0xFF) + 1;\n                    --length;\n                    state = State.HEADERS;\n                    loop = length == 0;\n                    break;\n                }\n                case HEADERS:\n                {\n                    if (hasFlag(Flags.END_HEADERS))\n                    {\n                        MetaData metaData = headerBlockParser.parse(buffer, length);\n                        if (metaData != null)\n                        {\n                            state = State.PADDING;\n                            loop = paddingLength == 0;\n                            onHeaders(parentStreamId, weight, exclusive, metaData);\n                        }\n                    }\n                    else\n                    {\n                        int remaining = buffer.remaining();\n                        if (remaining < length)\n                        {\n                            headerBlockFragments.storeFragment(buffer, remaining, false);\n                            length -= remaining;\n                        }\n                        else\n                        {\n                            headerBlockFragments.setStreamId(getStreamId());\n                            headerBlockFragments.setEndStream(isEndStream());\n                            if (hasFlag(Flags.PRIORITY))\n                                headerBlockFragments.setPriorityFrame(new PriorityFrame(getStreamId(), parentStreamId, weight, exclusive));\n                            headerBlockFragments.storeFragment(buffer, length, false);\n                            state = State.PADDING;\n                            loop = paddingLength == 0;\n                        }\n                    }\n                    break;\n                }\n                case PADDING:\n                {\n                    int size = Math.min(buffer.remaining(), paddingLength);\n                    buffer.position(buffer.position() + size);\n                    paddingLength -= size;\n                    if (paddingLength == 0)\n                    {\n                        reset();\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void generateHeaders(ByteBufferPool.Lease lease, int streamId, MetaData metaData, PriorityFrame priority, boolean endStream)\n    {\n        if (streamId < 0)\n            throw new IllegalArgumentException(\"Invalid stream id: \" + streamId);\n\n        int flags = Flags.NONE;\n\n        if (priority != null)\n        {\n            flags = Flags.PRIORITY;\n            int parentStreamId = priority.getParentStreamId();\n            if (parentStreamId < 0)\n                throw new IllegalArgumentException(\"Invalid parent stream id: \" + parentStreamId);\n            if (parentStreamId == streamId)\n                throw new IllegalArgumentException(\"Stream \" + streamId + \" cannot depend on stream \" + parentStreamId);\n            int weight = priority.getWeight();\n            if (weight > 255)\n                throw new IllegalArgumentException(\"Invalid weight: \" + weight);\n        }\n\n        int maxFrameSize = getMaxFrameSize();\n        ByteBuffer hpacked = lease.acquire(maxFrameSize, false);\n        BufferUtil.clearToFill(hpacked);\n        encoder.encode(hpacked, metaData);\n        int hpackedLength = hpacked.position();\n        BufferUtil.flipToFlush(hpacked, 0);\n\n        // Split into CONTINUATION frames if necessary.\n        if (maxHeaderBlockFragment > 0 && hpackedLength > maxHeaderBlockFragment)\n        {\n            if (endStream)\n                flags |= Flags.END_STREAM;\n\n            int length = maxHeaderBlockFragment;\n            if (priority != null)\n                length += PriorityFrame.PRIORITY_LENGTH;\n\n            ByteBuffer header = generateHeader(lease, FrameType.HEADERS, length, flags, streamId);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n\n            generatePriority(lease, priority);\n\n            hpacked.limit(maxHeaderBlockFragment);\n            lease.append(hpacked.slice(), false);\n\n            int position = maxHeaderBlockFragment;\n            int limit = position + maxHeaderBlockFragment;\n            while (limit < hpackedLength)\n            {\n                hpacked.position(position).limit(limit);\n                header = generateHeader(lease, FrameType.CONTINUATION, maxHeaderBlockFragment, Flags.NONE, streamId);\n                BufferUtil.flipToFlush(header, 0);\n                lease.append(header, true);\n                lease.append(hpacked.slice(), false);\n                position += maxHeaderBlockFragment;\n                limit += maxHeaderBlockFragment;\n            }\n\n            hpacked.position(position).limit(hpackedLength);\n            header = generateHeader(lease, FrameType.CONTINUATION, hpacked.remaining(), Flags.END_HEADERS, streamId);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n            lease.append(hpacked, true);\n        }\n        else\n        {\n            flags |= Flags.END_HEADERS;\n            if (endStream)\n                flags |= Flags.END_STREAM;\n\n            int length = hpackedLength;\n            if (priority != null)\n                length += PriorityFrame.PRIORITY_LENGTH;\n\n            ByteBuffer header = generateHeader(lease, FrameType.HEADERS, length, flags, streamId);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n\n            generatePriority(lease, priority);\n\n            lease.append(hpacked, true);\n        }\n    }","id":41608,"modified_method":"public void generateHeaders(ByteBufferPool.Lease lease, int streamId, MetaData metaData, PriorityFrame priority, boolean endStream)\n    {\n        if (streamId < 0)\n            throw new IllegalArgumentException(\"Invalid stream id: \" + streamId);\n\n        int flags = Flags.NONE;\n\n        if (priority != null)\n            flags = Flags.PRIORITY;\n\n        int maxFrameSize = getMaxFrameSize();\n        ByteBuffer hpacked = lease.acquire(maxFrameSize, false);\n        BufferUtil.clearToFill(hpacked);\n        encoder.encode(hpacked, metaData);\n        int hpackedLength = hpacked.position();\n        BufferUtil.flipToFlush(hpacked, 0);\n\n        // Split into CONTINUATION frames if necessary.\n        if (maxHeaderBlockFragment > 0 && hpackedLength > maxHeaderBlockFragment)\n        {\n            if (endStream)\n                flags |= Flags.END_STREAM;\n\n            int length = maxHeaderBlockFragment;\n            if (priority != null)\n                length += PriorityFrame.PRIORITY_LENGTH;\n\n            ByteBuffer header = generateHeader(lease, FrameType.HEADERS, length, flags, streamId);\n            generatePriority(header, priority);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n\n            hpacked.limit(maxHeaderBlockFragment);\n            lease.append(hpacked.slice(), false);\n\n            int position = maxHeaderBlockFragment;\n            int limit = position + maxHeaderBlockFragment;\n            while (limit < hpackedLength)\n            {\n                hpacked.position(position).limit(limit);\n                header = generateHeader(lease, FrameType.CONTINUATION, maxHeaderBlockFragment, Flags.NONE, streamId);\n                BufferUtil.flipToFlush(header, 0);\n                lease.append(header, true);\n                lease.append(hpacked.slice(), false);\n                position += maxHeaderBlockFragment;\n                limit += maxHeaderBlockFragment;\n            }\n\n            hpacked.position(position).limit(hpackedLength);\n            header = generateHeader(lease, FrameType.CONTINUATION, hpacked.remaining(), Flags.END_HEADERS, streamId);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n            lease.append(hpacked, true);\n        }\n        else\n        {\n            flags |= Flags.END_HEADERS;\n            if (endStream)\n                flags |= Flags.END_STREAM;\n\n            int length = hpackedLength;\n            if (priority != null)\n                length += PriorityFrame.PRIORITY_LENGTH;\n\n            ByteBuffer header = generateHeader(lease, FrameType.HEADERS, length, flags, streamId);\n            generatePriority(header, priority);\n            BufferUtil.flipToFlush(header, 0);\n            lease.append(header, true);\n            lease.append(hpacked, true);\n        }\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public HeadersGenerator(HeaderGenerator headerGenerator, HpackEncoder encoder, int maxHeaderBlockFragment)\n    {\n        super(headerGenerator);\n        this.encoder = encoder;\n        this.maxHeaderBlockFragment = maxHeaderBlockFragment;\n    }","id":41609,"modified_method":"public HeadersGenerator(HeaderGenerator headerGenerator, HpackEncoder encoder, int maxHeaderBlockFragment)\n    {\n        super(headerGenerator);\n        this.encoder = encoder;\n        this.maxHeaderBlockFragment = maxHeaderBlockFragment;\n        this.priorityGenerator = new PriorityGenerator(headerGenerator);\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void generatePriority(ByteBufferPool.Lease lease, PriorityFrame priority)\n    {\n        if (priority != null)\n        {\n            int parentStreamId = priority.getParentStreamId() & 0x7F_FF_FF_FF;\n            if (priority.isExclusive())\n                parentStreamId |= 0x80_00_00_00;\n            ByteBuffer buffer = lease.acquire(PriorityFrame.PRIORITY_LENGTH, true);\n            buffer.putInt(parentStreamId);\n            buffer.put((byte)(priority.getWeight() & 0xFF));\n            BufferUtil.flipToFlush(buffer, 0);\n            lease.append(buffer, true);\n        }\n    }","id":41610,"modified_method":"private void generatePriority(ByteBuffer header, PriorityFrame priority)\n    {\n        if (priority != null)\n        {\n            priorityGenerator.generatePriorityBody(header, priority.getStreamId(),\n                    priority.getParentStreamId(), priority.getWeight(), priority.isExclusive());\n        }\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean parse(ByteBuffer buffer)\n    {\n        while (buffer.hasRemaining())\n        {\n            switch (state)\n            {\n                case PREPARE:\n                {\n                    // SPEC: wrong streamId is treated as connection error.\n                    if (getStreamId() == 0)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_priority_frame\");\n                    int length = getBodyLength();\n                    if (length != 5)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_priority_frame\");\n                    state = State.EXCLUSIVE;\n                    break;\n                }\n                case EXCLUSIVE:\n                {\n                    // We must only peek the first byte and not advance the buffer\n                    // because the 31 least significant bits represent the stream id.\n                    int currByte = buffer.get(buffer.position());\n                    exclusive = (currByte & 0x80) == 0x80;\n                    state = State.PARENT_STREAM_ID;\n                    break;\n                }\n                case PARENT_STREAM_ID:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        parentStreamId = buffer.getInt();\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                    }\n                    else\n                    {\n                        state = State.PARENT_STREAM_ID_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case PARENT_STREAM_ID_BYTES:\n                {\n                    int currByte = buffer.get() & 0xFF;\n                    --cursor;\n                    parentStreamId += currByte << (8 * cursor);\n                    if (cursor == 0)\n                    {\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                    }\n                    break;\n                }\n                case WEIGHT:\n                {\n                    // SPEC: stream cannot depend on itself.\n                    if (getStreamId() == parentStreamId)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_priority_frame\");\n\n                    int weight = buffer.get() & 0xFF;\n                    return onPriority(parentStreamId, weight, exclusive);\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","id":41611,"modified_method":"@Override\n    public boolean parse(ByteBuffer buffer)\n    {\n        while (buffer.hasRemaining())\n        {\n            switch (state)\n            {\n                case PREPARE:\n                {\n                    // SPEC: wrong streamId is treated as connection error.\n                    if (getStreamId() == 0)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_priority_frame\");\n                    int length = getBodyLength();\n                    if (length != 5)\n                        return connectionFailure(buffer, ErrorCode.FRAME_SIZE_ERROR.code, \"invalid_priority_frame\");\n                    state = State.EXCLUSIVE;\n                    break;\n                }\n                case EXCLUSIVE:\n                {\n                    // We must only peek the first byte and not advance the buffer\n                    // because the 31 least significant bits represent the stream id.\n                    int currByte = buffer.get(buffer.position());\n                    exclusive = (currByte & 0x80) == 0x80;\n                    state = State.PARENT_STREAM_ID;\n                    break;\n                }\n                case PARENT_STREAM_ID:\n                {\n                    if (buffer.remaining() >= 4)\n                    {\n                        parentStreamId = buffer.getInt();\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                    }\n                    else\n                    {\n                        state = State.PARENT_STREAM_ID_BYTES;\n                        cursor = 4;\n                    }\n                    break;\n                }\n                case PARENT_STREAM_ID_BYTES:\n                {\n                    int currByte = buffer.get() & 0xFF;\n                    --cursor;\n                    parentStreamId += currByte << (8 * cursor);\n                    if (cursor == 0)\n                    {\n                        parentStreamId &= 0x7F_FF_FF_FF;\n                        state = State.WEIGHT;\n                    }\n                    break;\n                }\n                case WEIGHT:\n                {\n                    // SPEC: stream cannot depend on itself.\n                    if (getStreamId() == parentStreamId)\n                        return connectionFailure(buffer, ErrorCode.PROTOCOL_ERROR.code, \"invalid_priority_frame\");\n\n                    int weight = (buffer.get() & 0xFF) + 1;\n                    return onPriority(parentStreamId, weight, exclusive);\n                }\n                default:\n                {\n                    throw new IllegalStateException();\n                }\n            }\n        }\n        return false;\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        PriorityGenerator generator = new PriorityGenerator(new HeaderGenerator());\n\n        final List<PriorityFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onPriority(PriorityFrame frame)\n            {\n                frames.add(frame);\n            }\n        }, 4096, 8192);\n\n        int streamId = 13;\n        int parentStreamId = 17;\n        int weight = 3;\n        boolean exclusive = true;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generatePriority(lease, streamId, parentStreamId, weight, exclusive);\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(parentStreamId, frame.getParentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","id":41612,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        PriorityGenerator generator = new PriorityGenerator(new HeaderGenerator());\n\n        final List<PriorityFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onPriority(PriorityFrame frame)\n            {\n                frames.add(frame);\n            }\n        }, 4096, 8192);\n\n        int streamId = 13;\n        int parentStreamId = 17;\n        int weight = 256;\n        boolean exclusive = true;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generatePriority(lease, streamId, parentStreamId, weight, exclusive);\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(parentStreamId, frame.getParentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void generatePriority(ByteBufferPool.Lease lease, int streamId, int parentStreamId, int weight, boolean exclusive)\n    {\n        if (streamId < 0)\n            throw new IllegalArgumentException(\"Invalid stream id: \" + streamId);\n        if (parentStreamId < 0)\n            throw new IllegalArgumentException(\"Invalid parent stream id: \" + parentStreamId);\n\n        ByteBuffer header = generateHeader(lease, FrameType.PRIORITY, 5, Flags.NONE, streamId);\n\n        if (exclusive)\n            parentStreamId |= 0x80_00_00_00;\n\n        header.putInt(parentStreamId);\n\n        header.put((byte)weight);\n\n        BufferUtil.flipToFlush(header, 0);\n        lease.append(header, true);\n    }","id":41613,"modified_method":"public void generatePriority(ByteBufferPool.Lease lease, int streamId, int parentStreamId, int weight, boolean exclusive)\n    {\n        ByteBuffer header = generateHeader(lease, FrameType.PRIORITY, PriorityFrame.PRIORITY_LENGTH, Flags.NONE, streamId);\n        generatePriorityBody(header, streamId, parentStreamId, weight, exclusive);\n        BufferUtil.flipToFlush(header, 0);\n        lease.append(header, true);\n    }","commit_id":"83c5105e715fe84ffdc145c088f0541a22226d31","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime()\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        ByteBufferPool.Lease lease = generator.generateData(13, ByteBuffer.wrap(largeContent).slice(), true, false, new byte[1024]);\n\n        final List<DataFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onData(DataFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(largeContent.length, frames.size());\n    }","id":41614,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime()\n    {\n        DataGenerator generator = new DataGenerator(new HeaderGenerator());\n\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateData(lease, 13, ByteBuffer.wrap(largeContent).slice(), true, false, new byte[1024]);\n\n        final List<DataFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onData(DataFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(largeContent.length, frames.size());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private List<DataFrame> testGenerateParse(int paddingLength, ByteBuffer... data)\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<DataFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            for (int j = 1; j <= data.length; ++j)\n            {\n                lease = lease.merge(generator.generateData(13, data[j - 1].slice(), j == data.length, false, new byte[paddingLength]));\n            }\n\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onData(DataFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                parser.parse(buffer);\n            }\n        }\n\n        return frames;\n    }","id":41615,"modified_method":"private List<DataFrame> testGenerateParse(int paddingLength, ByteBuffer... data)\n    {\n        DataGenerator generator = new DataGenerator(new HeaderGenerator());\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<DataFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            for (int j = 1; j <= data.length; ++j)\n            {\n                generator.generateData(lease, 13, data[j - 1].slice(), j == data.length, false, new byte[paddingLength]);\n            }\n\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onData(DataFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                parser.parse(buffer);\n            }\n        }\n\n        return frames;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Generator(ByteBufferPool byteBufferPool)\n    {\n        this.byteBufferPool = byteBufferPool;\n        this.encoder = new HpackEncoder();\n    }","id":41616,"modified_method":"public Generator(ByteBufferPool byteBufferPool)\n    {\n        this.byteBufferPool = byteBufferPool;\n\n        HeaderGenerator headerGenerator = new HeaderGenerator();\n        HpackEncoder encoder = new HpackEncoder();\n\n        this.generators = new FrameGenerator[FrameType.values().length];\n        this.generators[FrameType.DATA.getType()] = new DataGenerator(headerGenerator);\n        this.generators[FrameType.HEADERS.getType()] = new HeadersGenerator(headerGenerator, encoder);\n        this.generators[FrameType.PRIORITY.getType()] = new PriorityGenerator(headerGenerator);\n        this.generators[FrameType.RST_STREAM.getType()] = new ResetGenerator(headerGenerator);\n        this.generators[FrameType.SETTINGS.getType()] = new SettingsGenerator(headerGenerator);\n        this.generators[FrameType.PUSH_PROMISE.getType()] = null; // TODO\n        this.generators[FrameType.PING.getType()] = new PingGenerator(headerGenerator);\n        this.generators[FrameType.GO_AWAY.getType()] = new GoAwayGenerator(headerGenerator);\n        this.generators[FrameType.WINDOW_UPDATE.getType()] = new WindowUpdateGenerator(headerGenerator);\n        this.generators[FrameType.CONTINUATION.getType()] = null; // TODO\n        this.generators[FrameType.ALTSVC.getType()] = null; // TODO\n        this.generators[FrameType.BLOCKED.getType()] = null; // TODO\n\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int lastStreamId = 13;\n        int error = 17;\n        byte[] payload = new byte[16];\n        new Random().nextBytes(payload);\n\n        final List<GoAwayFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generateGoAway(lastStreamId, error, payload);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onGoAway(GoAwayFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        GoAwayFrame frame = frames.get(0);\n        Assert.assertEquals(lastStreamId, frame.getLastStreamId());\n        Assert.assertEquals(error, frame.getError());\n        Assert.assertArrayEquals(payload, frame.getPayload());\n    }","id":41617,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        GoAwayGenerator generator = new GoAwayGenerator(new HeaderGenerator());\n\n        int lastStreamId = 13;\n        int error = 17;\n        byte[] payload = new byte[16];\n        new Random().nextBytes(payload);\n\n        final List<GoAwayFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateGoAway(lease, lastStreamId, error, payload);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onGoAway(GoAwayFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        GoAwayFrame frame = frames.get(0);\n        Assert.assertEquals(lastStreamId, frame.getLastStreamId());\n        Assert.assertEquals(error, frame.getError());\n        Assert.assertArrayEquals(payload, frame.getPayload());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int lastStreamId = 13;\n        int error = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<GoAwayFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generateGoAway(lastStreamId, error, null);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onGoAway(GoAwayFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        GoAwayFrame frame = frames.get(0);\n        Assert.assertEquals(lastStreamId, frame.getLastStreamId());\n        Assert.assertEquals(error, frame.getError());\n        Assert.assertNull(frame.getPayload());\n    }","id":41618,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        GoAwayGenerator generator = new GoAwayGenerator(new HeaderGenerator());\n\n        int lastStreamId = 13;\n        int error = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<GoAwayFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generateGoAway(lease, lastStreamId, error, null);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onGoAway(GoAwayFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        GoAwayFrame frame = frames.get(0);\n        Assert.assertEquals(lastStreamId, frame.getLastStreamId());\n        Assert.assertEquals(error, frame.getError());\n        Assert.assertNull(frame.getPayload());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n        {\n            LOG.debug(\"Received {} on {}\", frame, stream);\n\n            HttpTransportOverHTTP2 transport = new HttpTransportOverHTTP2();\n            HttpInputOverHTTP2 input = new HttpInputOverHTTP2();\n            HttpChannelOverHTTP2 channel = new HttpChannelOverHTTP2(connector, httpConfiguration, endPoint, transport, input);\n            // TODO: link channel to stream.\n\n//            if (frame.getMetaData().isEmpty())\n//            {\n                // TODO: abort.\n//                return null;\n//            }\n\n            channel.requestStart(frame);\n\n            return frame.isEndStream() ? null : this;\n        }","id":41619,"modified_method":"@Override\n        public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n        {\n            LOG.debug(\"Received {} on {}\", frame, stream);\n\n            HttpTransportOverHTTP2 transport = new HttpTransportOverHTTP2();\n            HttpInputOverHTTP2 input = new HttpInputOverHTTP2();\n            HttpChannelOverHTTP2 channel = new HttpChannelOverHTTP2(connector, httpConfiguration, endPoint, transport, input);\n            stream.setAttribute(CHANNEL_ATTRIBUTE, channel);\n\n            channel.requestHeaders(frame);\n\n            return frame.isEndStream() ? null : this;\n        }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Connection newConnection(Connector connector, EndPoint endPoint)\n    {\n        Session.Listener listener = new HTTPServerSessionListener(connector, httpConfiguration, endPoint);\n\n        HTTP2Session session = new HTTP2ServerSession(listener);\n\n        Parser parser = new Parser(connector.getByteBufferPool(), session);\n        HTTP2Connection connection = new HTTP2Connection(connector.getByteBufferPool(), connector.getExecutor(),\n                endPoint, parser, getInputBufferSize());\n\n        return configure(connection, connector, endPoint);\n    }","id":41620,"modified_method":"@Override\n    public Connection newConnection(Connector connector, EndPoint endPoint)\n    {\n        Session.Listener listener = new HTTPServerSessionListener(connector, httpConfiguration, endPoint);\n\n        Generator generator = new Generator(connector.getByteBufferPool());\n        HTTP2Session session = new HTTP2ServerSession(endPoint, generator, listener);\n\n        Parser parser = new Parser(connector.getByteBufferPool(), session);\n        HTTP2Connection connection = new HTTP2Connection(connector.getByteBufferPool(), connector.getExecutor(),\n                endPoint, parser, getInputBufferSize());\n\n        return configure(connection, connector, endPoint);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void onData(Stream stream, DataFrame frame)\n        {\n\n        }","id":41621,"modified_method":"@Override\n        public void onData(Stream stream, DataFrame frame, Callback callback)\n        {\n            HttpChannelOverHTTP2 channel = (HttpChannelOverHTTP2)stream.getAttribute(CHANNEL_ATTRIBUTE);\n            channel.requestContent(frame, callback);\n        }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public HTTP2ServerSession(Listener listener)\n    {\n        super(listener);\n    }","id":41622,"modified_method":"public HTTP2ServerSession(EndPoint endPoint, Generator generator, Listener listener)\n    {\n        super(endPoint, generator, listener);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean onHeaders(HeadersFrame frame)\n    {\n        // TODO: handle max concurrent streams\n        // TODO: handle duplicate streams\n\n        IStream stream = new HTTP2Stream();\n        IStream existing = streams.putIfAbsent(stream.getId(), stream);\n        if (existing == null)\n        {\n            Stream.Listener listener = notifyNewStream(stream, frame);\n            stream.setListener(listener);\n        }\n        return false;\n    }","id":41623,"modified_method":"@Override\n    public boolean onHeaders(HeadersFrame frame)\n    {\n        // TODO: handle max concurrent streams\n        // TODO: handle duplicate streams\n        // TODO: handle empty headers\n\n        IStream stream = new HTTP2Stream(this);\n        IStream existing = putIfAbsent(stream);\n        if (existing == null)\n        {\n            Stream.Listener listener = notifyNewStream(stream, frame);\n            stream.setListener(listener);\n        }\n        return false;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean onData(DataFrame frame)\n    {\n        return false;\n    }","id":41624,"modified_method":"@Override\n    public boolean onData(DataFrame frame)\n    {\n        IStream stream = streams.get(frame.getStreamId());\n        return stream.process(frame);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean onPing(PingFrame frame)\n    {\n        return false;\n    }","id":41625,"modified_method":"public HTTP2Session(EndPoint endPoint, Generator generator, Listener listener)\n    {\n        this.endPoint = endPoint;\n        this.generator = generator;\n        this.listener = listener;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void data(DataFrame frame, Callback callback)\n    {\n\n    }","id":41626,"modified_method":"@Override\n    public void data(DataFrame frame, Callback callback)\n    {\n        session.frame(frame, callback);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void headers(HeadersFrame frame, Callback callback)\n    {\n\n    }","id":41627,"modified_method":"@Override\n    public void headers(HeadersFrame frame, Callback callback)\n    {\n        session.frame(frame, callback);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void setListener(Listener listener)\n    {\n\n    }","id":41628,"modified_method":"public HTTP2Stream(ISession session)\n    {\n        this.session = session;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public HttpChannelOverHTTP2(Connector connector, HttpConfiguration configuration, EndPoint endPoint, HttpTransport transport, HttpInput<ByteBuffer> input)\n    {\n        super(connector, configuration, endPoint, transport, input);\n    }","id":41629,"modified_method":"public HttpChannelOverHTTP2(Connector connector, HttpConfiguration configuration, EndPoint endPoint, HttpTransport transport, HttpInput<ByteBufferCallback> input)\n    {\n        super(connector, configuration, endPoint, transport, input);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void requestStart(HeadersFrame frame)\n    {\n        // TODO: extract method, etc.\n        String method = null;\n        HttpURI uri = new HttpURI(\"/foo/bar\");\n        HttpVersion version = null;\n\n        startRequest(method, uri, version);\n\n        // TODO: See SPDY's\n    }","id":41630,"modified_method":"public void requestHeaders(HeadersFrame frame)\n    {\n        MetaData metaData = frame.getMetaData();\n        if (!metaData.isRequest())\n        {\n            badMessage(400, null);\n            return;\n        }\n\n        MetaData.Request requestMetaData = (MetaData.Request)metaData;\n\n        String method = requestMetaData.getMethod();\n        HttpURI uri = new HttpURI(requestMetaData.getPath());\n        HttpVersion version = HttpVersion.HTTP_2_0;\n\n        startRequest(method, uri, version);\n\n        HttpScheme scheme = requestMetaData.getScheme();\n        if (scheme != null)\n        {\n            getRequest().setScheme(scheme.asString());\n        }\n\n        parsedHostHeader(requestMetaData.getHost(), requestMetaData.getPort());\n\n        List<HttpField> fields = requestMetaData.getFields();\n        for (int i = 0; i < fields.size(); ++i)\n        {\n            HttpField field = fields.get(i);\n            parsedHeader(field);\n        }\n\n        headerComplete();\n\n        if (frame.isEndStream())\n        {\n            messageComplete();\n        }\n\n        // TODO: pending refactoring of HttpChannel API.\n        // Here we \"cheat\", knowing that headerComplete() will always return true\n        // and that content() and messageComplete() will always return false.\n        // This is the only place where we process the channel.\n        execute(this);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void onContentConsumed(ByteBuffer item)\n    {\n    }","id":41631,"modified_method":"@Override\n    protected void onContentConsumed(ByteBufferCallback item)\n    {\n        item.succeeded();\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void consume(ByteBuffer item, int length)\n    {\n    }","id":41632,"modified_method":"@Override\n    protected void consume(ByteBufferCallback item, int length)\n    {\n        ByteBuffer byteBuffer = item.getByteBuffer();\n        byteBuffer.position(byteBuffer.position() + length);\n        if (!byteBuffer.hasRemaining())\n            onContentConsumed(item);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected int get(ByteBuffer item, byte[] buffer, int offset, int length)\n    {\n        return 0;\n    }","id":41633,"modified_method":"@Override\n    protected int get(ByteBufferCallback item, byte[] buffer, int offset, int length)\n    {\n        ByteBuffer byteBuffer = item.getByteBuffer();\n        length = Math.min(byteBuffer.remaining(), length);\n        byteBuffer.get(buffer, offset, length);\n        return length;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected int remaining(ByteBuffer item)\n    {\n        return 0;\n    }","id":41634,"modified_method":"@Override\n    protected int remaining(ByteBufferCallback item)\n    {\n        return item.getByteBuffer().remaining();\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n    }","id":41635,"modified_method":"@Override\n    public void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        MetaData.Request metaData = (MetaData.Request)request.getMetaData();\n        boolean isHeadRequest = HttpMethod.HEAD.is(metaData.getMethod());\n        boolean hasContent = BufferUtil.hasContent(content) && !isHeadRequest;\n\n        // TODO: the idea here is this:\n        // CallbackLease lease = new CallbackLease(callback);\n        // commit(lease, ...)\n        //   stream.header(lease, frame)\n        //     session.frame(lease, frame)\n        //       generator.generate(lease, frame)\n        //         generateHeader(lease, frame);\n        //         bodyGenerator[frame.getType()].generateBody(lease, frame);\n        //   stream.content(lease, frame)\n        //     ...\n        //   flush(lease)\n        //\n        // Problem is that in this way I need to aggregate multiple callbacks for the same lease.\n        // So it'd need another abstraction that is a Lease+Callback\n\n        if (commit.compareAndSet(false, true))\n        {\n            commit(info, !hasContent, !hasContent ? callback : new Callback.Adapter()\n            {\n                @Override\n                public void failed(Throwable x)\n                {\n                    // TODO\n                }\n            });\n        }\n        else\n        {\n            // TODO\n        }\n\n        if (hasContent)\n        {\n            send(content, lastContent, callback);\n        }\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void send(ByteBuffer content, boolean lastContent, Callback callback)\n    {\n    }","id":41636,"modified_method":"@Override\n    public void send(ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        DataFrame frame = new DataFrame(stream.getId(), content, lastContent);\n        stream.data(frame, callback);\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        byte[] payload = new byte[8];\n        new Random().nextBytes(payload);\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<PingFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generatePing(payload, true);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onPing(PingFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PingFrame frame = frames.get(0);\n        Assert.assertArrayEquals(payload, frame.getPayload());\n        Assert.assertTrue(frame.isReply());\n    }","id":41637,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        PingGenerator generator = new PingGenerator(new HeaderGenerator());\n\n        byte[] payload = new byte[8];\n        new Random().nextBytes(payload);\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<PingFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generatePing(lease, payload, true);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onPing(PingFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PingFrame frame = frames.get(0);\n        Assert.assertArrayEquals(payload, frame.getPayload());\n        Assert.assertTrue(frame.isReply());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        byte[] payload = new byte[8];\n        new Random().nextBytes(payload);\n\n        final List<PingFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generatePing(payload, true);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onPing(PingFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PingFrame frame = frames.get(0);\n        Assert.assertArrayEquals(payload, frame.getPayload());\n        Assert.assertTrue(frame.isReply());\n    }","id":41638,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        PingGenerator generator = new PingGenerator(new HeaderGenerator());\n\n        byte[] payload = new byte[8];\n        new Random().nextBytes(payload);\n\n        final List<PingFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generatePing(lease, payload, true);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onPing(PingFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PingFrame frame = frames.get(0);\n        Assert.assertArrayEquals(payload, frame.getPayload());\n        Assert.assertTrue(frame.isReply());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int dependentStreamId = 17;\n        int weight = 3;\n        boolean exclusive = true;\n\n        final List<PriorityFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generatePriority(streamId, dependentStreamId, weight, exclusive);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onPriority(PriorityFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(dependentStreamId, frame.getDependentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","id":41639,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        PriorityGenerator generator = new PriorityGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int dependentStreamId = 17;\n        int weight = 3;\n        boolean exclusive = true;\n\n        final List<PriorityFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generatePriority(lease, streamId, dependentStreamId, weight, exclusive);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onPriority(PriorityFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(dependentStreamId, frame.getDependentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int dependentStreamId = 17;\n        int weight = 3;\n        boolean exclusive = true;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<PriorityFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generatePriority(streamId, dependentStreamId, weight, exclusive);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onPriority(PriorityFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(dependentStreamId, frame.getDependentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","id":41640,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        PriorityGenerator generator = new PriorityGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int dependentStreamId = 17;\n        int weight = 3;\n        boolean exclusive = true;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<PriorityFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generatePriority(lease, streamId, dependentStreamId, weight, exclusive);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onPriority(PriorityFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        PriorityFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(dependentStreamId, frame.getDependentStreamId());\n        Assert.assertEquals(weight, frame.getWeight());\n        Assert.assertEquals(exclusive, frame.isExclusive());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int error = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<ResetFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generateReset(streamId, error);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onReset(ResetFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        ResetFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(error, frame.getError());\n    }","id":41641,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        ResetGenerator generator = new ResetGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int error = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<ResetFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generateReset(lease, streamId, error);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onReset(ResetFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        ResetFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(error, frame.getError());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int error = 17;\n\n        final List<ResetFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generateReset(streamId, error);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onReset(ResetFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        ResetFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(error, frame.getError());\n    }","id":41642,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        ResetGenerator generator = new ResetGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int error = 17;\n\n        final List<ResetFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateReset(lease, streamId, error);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onReset(ResetFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        ResetFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(error, frame.getError());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private List<SettingsFrame> testGenerateParse(Map<Integer, Integer> settings)\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<SettingsFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generateSettings(settings, true);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onSettings(SettingsFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        return frames;\n    }","id":41643,"modified_method":"private List<SettingsFrame> testGenerateParse(Map<Integer, Integer> settings)\n    {\n        SettingsGenerator generator = new SettingsGenerator(new HeaderGenerator());\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<SettingsFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generateSettings(lease, settings, true);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onSettings(SettingsFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        return frames;\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        Map<Integer, Integer> settings1 = new HashMap<>();\n        int key = 13;\n        Integer value = 17;\n        settings1.put(key, value);\n\n        final List<SettingsFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generateSettings(settings1, true);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onSettings(SettingsFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        SettingsFrame frame = frames.get(0);\n        Map<Integer, Integer> settings2 = frame.getSettings();\n        Assert.assertEquals(1, settings2.size());\n        Assert.assertEquals(value, settings2.get(key));\n        Assert.assertTrue(frame.isReply());\n    }","id":41644,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        SettingsGenerator generator = new SettingsGenerator(new HeaderGenerator());\n\n        Map<Integer, Integer> settings1 = new HashMap<>();\n        int key = 13;\n        Integer value = 17;\n        settings1.put(key, value);\n\n        final List<SettingsFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateSettings(lease, settings1, true);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onSettings(SettingsFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        SettingsFrame frame = frames.get(0);\n        Map<Integer, Integer> settings2 = frame.getSettings();\n        Assert.assertEquals(1, settings2.size());\n        Assert.assertEquals(value, settings2.get(key));\n        Assert.assertTrue(frame.isReply());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseInvalidSettings() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n        Map<Integer, Integer> settings1 = new HashMap<>();\n        settings1.put(13, 17);\n        ByteBufferPool.Lease lease = generator.generateSettings(settings1, true);\n        // Modify the length of the frame to make it invalid\n        ByteBuffer bytes = lease.getByteBuffers().get(0);\n        bytes.putShort(0, (short)(bytes.getShort(0) - 1));\n\n        final AtomicInteger errorRef = new AtomicInteger();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onConnectionFailure(int error, String reason)\n            {\n                errorRef.set(error);\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(ErrorCode.PROTOCOL_ERROR, errorRef.get());\n    }","id":41645,"modified_method":"@Test\n    public void testGenerateParseInvalidSettings() throws Exception\n    {\n        SettingsGenerator generator = new SettingsGenerator(new HeaderGenerator());\n        Map<Integer, Integer> settings1 = new HashMap<>();\n        settings1.put(13, 17);\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateSettings(lease, settings1, true);\n        // Modify the length of the frame to make it invalid\n        ByteBuffer bytes = lease.getByteBuffers().get(0);\n        bytes.putShort(0, (short)(bytes.getShort(0) - 1));\n\n        final AtomicInteger errorRef = new AtomicInteger();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onConnectionFailure(int error, String reason)\n            {\n                errorRef.set(error);\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(ErrorCode.PROTOCOL_ERROR, errorRef.get());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int windowUpdate = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<WindowUpdateFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = generator.generateWindowUpdate(streamId, windowUpdate);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onWindowUpdate(WindowUpdateFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        WindowUpdateFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(windowUpdate, frame.getWindowDelta());\n    }","id":41646,"modified_method":"@Test\n    public void testGenerateParse() throws Exception\n    {\n        WindowUpdateGenerator generator = new WindowUpdateGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int windowUpdate = 17;\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        final List<WindowUpdateFrame> frames = new ArrayList<>();\n        for (int i = 0; i < 2; ++i)\n        {\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            generator.generateWindowUpdate(lease, streamId, windowUpdate);\n            Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n            {\n                @Override\n                public boolean onWindowUpdate(WindowUpdateFrame frame)\n                {\n                    frames.add(frame);\n                    return false;\n                }\n            });\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(buffer);\n                }\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        WindowUpdateFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(windowUpdate, frame.getWindowDelta());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        Generator generator = new Generator(byteBufferPool);\n\n        int streamId = 13;\n        int windowUpdate = 17;\n\n        final List<WindowUpdateFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = generator.generateWindowUpdate(streamId, windowUpdate);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onWindowUpdate(WindowUpdateFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        WindowUpdateFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(windowUpdate, frame.getWindowDelta());\n    }","id":41647,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        WindowUpdateGenerator generator = new WindowUpdateGenerator(new HeaderGenerator());\n\n        int streamId = 13;\n        int windowUpdate = 17;\n\n        final List<WindowUpdateFrame> frames = new ArrayList<>();\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        generator.generateWindowUpdate(lease, streamId, windowUpdate);\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public boolean onWindowUpdate(WindowUpdateFrame frame)\n            {\n                frames.add(frame);\n                return false;\n            }\n        });\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        WindowUpdateFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertEquals(windowUpdate, frame.getWindowDelta());\n    }","commit_id":"ad034f4d54aa4d6ce04c6fe3da8e8f48f63b21e5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public List<Revision> getRevisions(String name) {\n    List<Revision> result = new ArrayList<Revision>();\n\n    //todo clean up this mess\n    if (!mySnapshot.hasRevision(name)) return result;\n\n    Integer id = mySnapshot.getId(name);\n\n    for (Snapshot snapshot : getSnapshots()) {\n      Revision r = snapshot.getRevision(id);\n      if (r == null) break;\n      result.add(r);\n    }\n\n    return result;\n  }","id":41648,"modified_method":"public List<Revision> getRevisions(String name) {\n    List<Revision> result = new ArrayList<Revision>();\n\n    //todo clean up this mess\n    if (!mySnapshot.hasRevision(name)) return result;\n\n    Integer id = mySnapshot.getRevision(name).getObjectId();\n\n    for (Snapshot snapshot : getSnapshots()) {\n      Revision r = snapshot.getRevision(id);\n      if (r == null) break;\n\n      result.add(r);\n    }\n\n    return result;\n  }","commit_id":"61fb0515b476e2a800e0b48974d3dd6069cab61a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testGettingSnapshots() {\n    myVcs.createFile(\"file1\", \"content1\");\n    myVcs.createFile(\"file2\", \"content2\");\n    myVcs.commit();\n\n    myVcs.createFile(\"file3\", \"content3\");\n    myVcs.changeFile(\"file1\", \"new content1\");\n    myVcs.commit();\n\n    Integer id1 = myVcs.getId(\"file1\");\n    Integer id2 = myVcs.getId(\"file2\");\n    Integer id3 = myVcs.getId(\"file3\");\n\n    List<Snapshot> snapshots = myVcs.getSnapshots();\n    assertEquals(2, snapshots.size());\n\n    assertElements(\n        new Object[]{\n            new FileRevision(id1, \"file1\", \"new content1\"),\n            new FileRevision(id2, \"file2\", \"content2\"),\n            new FileRevision(id3, \"file3\", \"content3\")},\n        snapshots.get(0).getRevisions());\n\n    assertElements(\n        new Object[]{\n            new FileRevision(id1, \"file1\", \"content1\"),\n            new FileRevision(id2, \"file2\", \"content2\")},\n        snapshots.get(1).getRevisions());\n  }","id":41649,"modified_method":"@Test\n  public void testGettingSnapshots() {\n    myVcs.createFile(\"file1\", \"content1\");\n    myVcs.createFile(\"file2\", \"content2\");\n    myVcs.commit();\n\n    myVcs.createFile(\"file3\", \"content3\");\n    myVcs.changeFile(\"file1\", \"new content1\");\n    myVcs.commit();\n\n    Integer id1 = myVcs.getRevision(\"file1\").getObjectId();\n    Integer id2 = myVcs.getRevision(\"file2\").getObjectId();\n    Integer id3 = myVcs.getRevision(\"file3\").getObjectId();\n\n    List<Snapshot> snapshots = myVcs.getSnapshots();\n    assertEquals(2, snapshots.size());\n\n    assertElements(\n        new Object[]{\n            new FileRevision(id1, \"file1\", \"new content1\"),\n            new FileRevision(id2, \"file2\", \"content2\"),\n            new FileRevision(id3, \"file3\", \"content3\")},\n        snapshots.get(0).getRevisions());\n\n    assertElements(\n        new Object[]{\n            new FileRevision(id1, \"file1\", \"content1\"),\n            new FileRevision(id2, \"file2\", \"content2\")},\n        snapshots.get(1).getRevisions());\n  }","commit_id":"61fb0515b476e2a800e0b48974d3dd6069cab61a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(Object[] buddy1, Object[] buddy2) {\n\t\tlong userId1 = (Long)buddy1[0];\n\t\tString firstName1 = (String)buddy1[1];\n\t\tString middleName1 = (String)buddy1[2];\n\t\tString lastName1 = (String)buddy1[3];\n\t\tboolean awake1 = (Boolean)buddy1[5];\n\n\t\tlong userId2 = (Long)buddy2[0];\n\t\tString firstName2 = (String)buddy2[1];\n\t\tString middleName2 = (String)buddy2[2];\n\t\tString lastName2 = (String)buddy2[3];\n\t\tboolean awake2 = (Boolean)buddy2[5];\n\n\t\tint value = 0;\n\n\t\tif (userId1 == userId2) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (awake1 && !awake2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (!awake1 && awake2) {\n\t\t\tvalue = -1;\n\t\t}\n\n\t\tif (value == 0) {\n\t\t\tString fullName1 = ContactConstants.getFullName(\n\t\t\t\tfirstName1, middleName1, lastName1);\n\t\t\tString fullName2 = ContactConstants.getFullName(\n\t\t\t\tfirstName2, middleName2, lastName2);\n\n\t\t\tvalue = fullName1.compareTo(fullName2);\n\t\t}\n\n\t\tif (_asc) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","id":41650,"modified_method":"public int compare(Object[] buddy1, Object[] buddy2) {\n\t\tlong userId1 = (Long)buddy1[0];\n\t\tString firstName1 = (String)buddy1[2];\n\t\tString middleName1 = (String)buddy1[3];\n\t\tString lastName1 = (String)buddy1[4];\n\t\tboolean awake1 = (Boolean)buddy1[6];\n\n\t\tlong userId2 = (Long)buddy2[0];\n\t\tString firstName2 = (String)buddy2[2];\n\t\tString middleName2 = (String)buddy2[3];\n\t\tString lastName2 = (String)buddy2[4];\n\t\tboolean awake2 = (Boolean)buddy2[6];\n\n\t\tint value = 0;\n\n\t\tif (userId1 == userId2) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (awake1 && !awake2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (!awake1 && awake2) {\n\t\t\tvalue = -1;\n\t\t}\n\n\t\tif (value == 0) {\n\t\t\tString fullName1 = ContactConstants.getFullName(\n\t\t\t\tfirstName1, middleName1, lastName1);\n\t\t\tString fullName2 = ContactConstants.getFullName(\n\t\t\t\tfirstName2, middleName2, lastName2);\n\n\t\t\tvalue = fullName1.compareTo(fullName2);\n\t\t}\n\n\t\tif (_asc) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void getBuddies(\n\t\t\tPollerRequest pollerRequest, PollerResponse pollerResponse)\n\t\tthrows Exception {\n\n\t\tList<Object[]> buddies = ChatUtil.getBuddies(\n\t\t\tpollerRequest.getCompanyId(), pollerRequest.getUserId());\n\n\t\tJSONArray buddiesJSON = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Object[] buddy : buddies) {\n\t\t\tlong userId = (Long)buddy[0];\n\t\t\tString firstName = (String)buddy[1];\n\t\t\tString middleName = (String)buddy[2];\n\t\t\tString lastName = (String)buddy[3];\n\t\t\tlong portraitId = (Long)buddy[4];\n\t\t\tboolean awake = (Boolean)buddy[5];\n\n\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\tif (userId == pollerRequest.getUserId()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStatus buddyStatus = StatusLocalServiceUtil.getUserStatus(\n\t\t\t\tuserId);\n\n\t\t\tawake = buddyStatus.getAwake();\n\t\t\tString statusMessage = buddyStatus.getMessage();\n\n\t\t\tJSONObject curUserJSON = JSONFactoryUtil.createJSONObject();\n\n\t\t\tcurUserJSON.put(\"userId\", userId);\n\t\t\tcurUserJSON.put(\"fullName\", fullName);\n\t\t\tcurUserJSON.put(\"portraitId\", portraitId);\n\t\t\tcurUserJSON.put(\"awake\", awake);\n\t\t\tcurUserJSON.put(\"statusMessage\", statusMessage);\n\n\t\t\tbuddiesJSON.put(curUserJSON);\n\t\t}\n\n\t\tpollerResponse.setParameter(\"buddies\", buddiesJSON);\n\t}","id":41651,"modified_method":"protected void getBuddies(\n\t\t\tPollerRequest pollerRequest, PollerResponse pollerResponse)\n\t\tthrows Exception {\n\n\t\tList<Object[]> buddies = ChatUtil.getBuddies(\n\t\t\tpollerRequest.getCompanyId(), pollerRequest.getUserId());\n\n\t\tJSONArray buddiesJSON = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Object[] buddy : buddies) {\n\t\t\tlong userId = (Long)buddy[0];\n\t\t\tString screenName = (String)buddy[1];\n\t\t\tString firstName = (String)buddy[2];\n\t\t\tString middleName = (String)buddy[3];\n\t\t\tString lastName = (String)buddy[4];\n\t\t\tlong portraitId = (Long)buddy[5];\n\t\t\tboolean awake = (Boolean)buddy[6];\n\n\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\tif (userId == pollerRequest.getUserId()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStatus buddyStatus = StatusLocalServiceUtil.getUserStatus(\n\t\t\t\tuserId);\n\n\t\t\tawake = buddyStatus.getAwake();\n\t\t\tString statusMessage = buddyStatus.getMessage();\n\n\t\t\tJSONObject curUserJSON = JSONFactoryUtil.createJSONObject();\n\n\t\t\tcurUserJSON.put(\"userId\", userId);\n\t\t\tcurUserJSON.put(\"screenName\", screenName);\n\t\t\tcurUserJSON.put(\"fullName\", fullName);\n\t\t\tcurUserJSON.put(\"portraitId\", portraitId);\n\t\t\tcurUserJSON.put(\"awake\", awake);\n\t\t\tcurUserJSON.put(\"statusMessage\", statusMessage);\n\n\t\t\tbuddiesJSON.put(curUserJSON);\n\t\t}\n\n\t\tpollerResponse.setParameter(\"buddies\", buddiesJSON);\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Object[]> getStatuses(\n\t\tlong companyId, long userId, List<Object[]> buddies) {\n\n\t\ttry {\n\t\t\tConnection connection = getConnection(userId);\n\n\t\t\tif (connection == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User \" + userId + \" is not connected to Jabber\");\n\t\t\t\t}\n\n\t\t\t\treturn buddies;\n\t\t\t}\n\n\t\t\tList<Object[]> jabberBuddies = new ArrayList<Object[]>();\n\n\t\t\tjabberBuddies.addAll(buddies);\n\n\t\t\tRoster roster = connection.getRoster();\n\n\t\t\tCollection<RosterEntry> rosterEntries = roster.getEntries();\n\n\t\t\tBuddyComparator buddyComparator = new BuddyComparator(true);\n\n\t\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\t\tPresence presence = roster.getPresence(rosterEntry.getUser());\n\n\t\t\t\tif (!presence.isAvailable()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserByScreenName(\n\t\t\t\t\tcompanyId, getScreenName(rosterEntry.getUser()));\n\n\t\t\t\tObject[] jabberBuddy = new Object[6];\n\n\t\t\t\tjabberBuddy[0] = user.getUserId();\n\t\t\t\tjabberBuddy[1] = user.getFirstName();\n\t\t\t\tjabberBuddy[2] = user.getMiddleName();\n\t\t\t\tjabberBuddy[3] = user.getLastName();\n\t\t\t\tjabberBuddy[4] = user.getPortraitId();\n\t\t\t\tjabberBuddy[5] = true;\n\n\t\t\t\tif (Collections.binarySearch(\n\t\t\t\t\t\tjabberBuddies, jabberBuddy, buddyComparator) < 0) {\n\n\t\t\t\t\tjabberBuddies.add(jabberBuddy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(jabberBuddies, buddyComparator);\n\n\t\t\treturn jabberBuddies;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to get Jabber buddies\", e);\n\n\t\t\treturn buddies;\n\t\t}\n\t}","id":41652,"modified_method":"public List<Object[]> getStatuses(\n\t\tlong companyId, long userId, List<Object[]> buddies) {\n\n\t\ttry {\n\t\t\tConnection connection = getConnection(userId);\n\n\t\t\tif (connection == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User \" + userId + \" is not connected to Jabber\");\n\t\t\t\t}\n\n\t\t\t\treturn buddies;\n\t\t\t}\n\n\t\t\tList<Object[]> jabberBuddies = new ArrayList<Object[]>();\n\n\t\t\tjabberBuddies.addAll(buddies);\n\n\t\t\tRoster roster = connection.getRoster();\n\n\t\t\tCollection<RosterEntry> rosterEntries = roster.getEntries();\n\n\t\t\tif (PortletPropsValues.JABBER_IMPORT_USER_ENABLED) {\n\t\t\t\tfor (Object[] buddy : buddies) {\n\t\t\t\t\tString screenName = (String)buddy[1];\n\t\t\t\t\tString firstName = (String)buddy[2];\n\t\t\t\t\tString middleName = (String)buddy[3];\n\t\t\t\t\tString lastName = (String)buddy[4];\n\n\t\t\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\t\t\tString jabberId = getFullJabberId(screenName);\n\n\t\t\t\t\tif (!roster.contains(jabberId)) {\n\t\t\t\t\t\troster.createEntry(jabberId, fullName, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBuddyComparator buddyComparator = new BuddyComparator(true);\n\n\t\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\t\tPresence presence = roster.getPresence(rosterEntry.getUser());\n\n\t\t\t\tif (!presence.isAvailable()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserByScreenName(\n\t\t\t\t\tcompanyId, getScreenName(rosterEntry.getUser()));\n\n\t\t\t\tObject[] jabberBuddy = new Object[7];\n\n\t\t\t\tjabberBuddy[0] = user.getUserId();\n\t\t\t\tjabberBuddy[1] = user.getScreenName();\n\t\t\t\tjabberBuddy[2] = user.getFirstName();\n\t\t\t\tjabberBuddy[3] = user.getMiddleName();\n\t\t\t\tjabberBuddy[4] = user.getLastName();\n\t\t\t\tjabberBuddy[5] = user.getPortraitId();\n\t\t\t\tjabberBuddy[6] = true;\n\n\t\t\t\tif (Collections.binarySearch(\n\t\t\t\t\t\tjabberBuddies, jabberBuddy, buddyComparator) < 0) {\n\n\t\t\t\t\tjabberBuddies.add(jabberBuddy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(jabberBuddies, buddyComparator);\n\n\t\t\treturn jabberBuddies;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to get Jabber buddies\", e);\n\n\t\t\treturn buddies;\n\t\t}\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Object[]> findByModifiedDate(\n\t\t\tlong companyId, long userId, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_MODIFIED_DATE);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":41653,"modified_method":"public List<Object[]> findByModifiedDate(\n\t\t\tlong companyId, long userId, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_MODIFIED_DATE);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"screenName\", Type.STRING);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Object[]> findBySocialRelationType(\n\t\t\tlong userId, int type, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_SOCIAL_RELATION_TYPE);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(type);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":41654,"modified_method":"public List<Object[]> findBySocialRelationType(\n\t\t\tlong userId, int type, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_SOCIAL_RELATION_TYPE);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"screenName\", Type.STRING);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(type);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<Object[]> findByUsersGroups(\n\t\t\tlong userId, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_USERS_GROUPS);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":41655,"modified_method":"public List<Object[]> findByUsersGroups(\n\t\t\tlong userId, long modifiedDate, int start, int end)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_USERS_GROUPS);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\t\t\tq.addScalar(\"screenName\", Type.STRING);\n\t\t\tq.addScalar(\"firstName\", Type.STRING);\n\t\t\tq.addScalar(\"middleName\", Type.STRING);\n\t\t\tq.addScalar(\"lastName\", Type.STRING);\n\t\t\tq.addScalar(\"portraitId\", Type.LONG);\n\t\t\tq.addScalar(\"awake\", Type.BOOLEAN);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(modifiedDate);\n\n\t\t\treturn (List<Object[]>)QueryUtil.list(q, getDialect(), start, end);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"4d0f7ff5667fb778d3f3cfafde4ff040bef4d608","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void getBuddies(\n\t\t\tPollerRequest pollerRequest, PollerResponse pollerResponse)\n\t\tthrows Exception {\n\n\t\tList<Object[]> buddies = BuddyFinderUtil.getBuddies(\n\t\t\tpollerRequest.getCompanyId(), pollerRequest.getUserId());\n\n\t\tJSONArray buddiesJSONArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Object[] buddy : buddies) {\n\t\t\tlong userId = (Long)buddy[0];\n\t\t\tString screenName = (String)buddy[1];\n\t\t\tString firstName = (String)buddy[2];\n\t\t\tString middleName = (String)buddy[3];\n\t\t\tString lastName = (String)buddy[4];\n\t\t\tlong portraitId = (Long)buddy[5];\n\t\t\tboolean awake = (Boolean)buddy[6];\n\n\t\t\tJSONObject curUserJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tStatus buddyStatus = StatusLocalServiceUtil.getUserStatus(userId);\n\n\t\t\tawake = buddyStatus.getAwake();\n\n\t\t\tcurUserJSONObject.put(\"awake\", awake);\n\n\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\tcurUserJSONObject.put(\"fullName\", fullName);\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\tcurUserJSONObject.put(\"groupId\", user.getGroupId());\n\n\t\t\tcurUserJSONObject.put(\"portraitId\", portraitId);\n\t\t\tcurUserJSONObject.put(\"screenName\", screenName);\n\n\t\t\tString statusMessage = buddyStatus.getMessage();\n\n\t\t\tcurUserJSONObject.put(\"statusMessage\", statusMessage);\n\t\t\tcurUserJSONObject.put(\"userId\", userId);\n\n\t\t\tbuddiesJSONArray.put(curUserJSONObject);\n\t\t}\n\n\t\tpollerResponse.setParameter(\"buddies\", buddiesJSONArray);\n\t}","id":41656,"modified_method":"protected void getBuddies(\n\t\t\tPollerRequest pollerRequest, PollerResponse pollerResponse)\n\t\tthrows Exception {\n\n\t\tList<Object[]> buddies = BuddyFinderUtil.getBuddies(\n\t\t\tpollerRequest.getCompanyId(), pollerRequest.getUserId());\n\n\t\tJSONArray buddiesJSONArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Object[] buddy : buddies) {\n\t\t\tlong userId = (Long)buddy[1];\n\t\t\tString screenName = (String)buddy[2];\n\t\t\tString firstName = (String)buddy[3];\n\t\t\tString middleName = (String)buddy[4];\n\t\t\tString lastName = (String)buddy[5];\n\t\t\tlong portraitId = (Long)buddy[6];\n\t\t\tboolean awake = (Boolean)buddy[7];\n\n\t\t\tJSONObject curUserJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tStatus buddyStatus = StatusLocalServiceUtil.getUserStatus(userId);\n\n\t\t\tawake = buddyStatus.getAwake();\n\n\t\t\tcurUserJSONObject.put(\"awake\", awake);\n\n\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\tcurUserJSONObject.put(\"fullName\", fullName);\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\t\tcurUserJSONObject.put(\"groupId\", user.getGroupId());\n\n\t\t\tcurUserJSONObject.put(\"portraitId\", portraitId);\n\t\t\tcurUserJSONObject.put(\"screenName\", screenName);\n\n\t\t\tString statusMessage = buddyStatus.getMessage();\n\n\t\t\tcurUserJSONObject.put(\"statusMessage\", statusMessage);\n\t\t\tcurUserJSONObject.put(\"userId\", userId);\n\n\t\t\tbuddiesJSONArray.put(curUserJSONObject);\n\t\t}\n\n\t\tpollerResponse.setParameter(\"buddies\", buddiesJSONArray);\n\t}","commit_id":"5e36c2a30e09bdae345996524509d5a98f76e37b","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<Object[]> getStatuses(\n\t\tlong companyId, long userId, List<Object[]> buddies) {\n\n\t\ttry {\n\t\t\tConnection connection = getConnection(userId);\n\n\t\t\tif (connection == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User \" + userId + \" is not connected to Jabber\");\n\t\t\t\t}\n\n\t\t\t\treturn buddies;\n\t\t\t}\n\n\t\t\tList<Object[]> jabberBuddies = new ArrayList<Object[]>();\n\n\t\t\tjabberBuddies.addAll(buddies);\n\n\t\t\tRoster roster = connection.getRoster();\n\n\t\t\tCollection<RosterEntry> rosterEntries = roster.getEntries();\n\n\t\t\tif (PortletPropsValues.JABBER_IMPORT_USER_ENABLED) {\n\t\t\t\tfor (Object[] buddy : buddies) {\n\t\t\t\t\tString screenName = (String)buddy[1];\n\t\t\t\t\tString firstName = (String)buddy[2];\n\t\t\t\t\tString middleName = (String)buddy[3];\n\t\t\t\t\tString lastName = (String)buddy[4];\n\n\t\t\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\t\t\tString jabberId = getFullJabberId(screenName);\n\n\t\t\t\t\tif (!roster.contains(jabberId)) {\n\t\t\t\t\t\troster.createEntry(jabberId, fullName, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBuddyComparator buddyComparator = new BuddyComparator(true);\n\n\t\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\t\tPresence presence = roster.getPresence(rosterEntry.getUser());\n\n\t\t\t\tif (!presence.isAvailable()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserByScreenName(\n\t\t\t\t\tcompanyId, getScreenName(rosterEntry.getUser()));\n\n\t\t\t\tObject[] jabberBuddy = new Object[7];\n\n\t\t\t\tjabberBuddy[0] = user.getUserId();\n\t\t\t\tjabberBuddy[1] = user.getScreenName();\n\t\t\t\tjabberBuddy[2] = user.getFirstName();\n\t\t\t\tjabberBuddy[3] = user.getMiddleName();\n\t\t\t\tjabberBuddy[4] = user.getLastName();\n\t\t\t\tjabberBuddy[5] = user.getPortraitId();\n\t\t\t\tjabberBuddy[6] = true;\n\n\t\t\t\tif (Collections.binarySearch(\n\t\t\t\t\t\tjabberBuddies, jabberBuddy, buddyComparator) < 0) {\n\n\t\t\t\t\tjabberBuddies.add(jabberBuddy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(jabberBuddies, buddyComparator);\n\n\t\t\treturn jabberBuddies;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to get Jabber buddies\", e);\n\n\t\t\treturn buddies;\n\t\t}\n\t}","id":41657,"modified_method":"@Override\n\tpublic List<Object[]> getStatuses(\n\t\tlong companyId, long userId, List<Object[]> buddies) {\n\n\t\ttry {\n\t\t\tConnection connection = getConnection(userId);\n\n\t\t\tif (connection == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User \" + userId + \" is not connected to Jabber\");\n\t\t\t\t}\n\n\t\t\t\treturn buddies;\n\t\t\t}\n\n\t\t\tList<Object[]> jabberBuddies = new ArrayList<Object[]>();\n\n\t\t\tjabberBuddies.addAll(buddies);\n\n\t\t\tRoster roster = connection.getRoster();\n\n\t\t\tCollection<RosterEntry> rosterEntries = roster.getEntries();\n\n\t\t\tif (PortletPropsValues.JABBER_IMPORT_USER_ENABLED) {\n\t\t\t\tfor (Object[] buddy : buddies) {\n\t\t\t\t\tString screenName = (String)buddy[2];\n\t\t\t\t\tString firstName = (String)buddy[3];\n\t\t\t\t\tString middleName = (String)buddy[4];\n\t\t\t\t\tString lastName = (String)buddy[5];\n\n\t\t\t\t\tString fullName = ContactConstants.getFullName(\n\t\t\t\t\t\tfirstName, middleName, lastName);\n\n\t\t\t\t\tString jabberId = getFullJabberId(screenName);\n\n\t\t\t\t\tif (!roster.contains(jabberId)) {\n\t\t\t\t\t\troster.createEntry(jabberId, fullName, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBuddyComparator buddyComparator = new BuddyComparator(true);\n\n\t\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\t\tPresence presence = roster.getPresence(rosterEntry.getUser());\n\n\t\t\t\tif (!presence.isAvailable()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserByScreenName(\n\t\t\t\t\tcompanyId, getScreenName(rosterEntry.getUser()));\n\n\t\t\t\tObject[] jabberBuddy = new Object[8];\n\n\t\t\t\tjabberBuddy[0] = user.getUserUuid();\n\t\t\t\tjabberBuddy[1] = user.getUserId();\n\t\t\t\tjabberBuddy[2] = user.getScreenName();\n\t\t\t\tjabberBuddy[3] = user.getFirstName();\n\t\t\t\tjabberBuddy[4] = user.getMiddleName();\n\t\t\t\tjabberBuddy[5] = user.getLastName();\n\t\t\t\tjabberBuddy[6] = user.getPortraitId();\n\t\t\t\tjabberBuddy[7] = true;\n\n\t\t\t\tif (Collections.binarySearch(\n\t\t\t\t\t\tjabberBuddies, jabberBuddy, buddyComparator) < 0) {\n\n\t\t\t\t\tjabberBuddies.add(jabberBuddy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(jabberBuddies, buddyComparator);\n\n\t\t\treturn jabberBuddies;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to get Jabber buddies\", e);\n\n\t\t\treturn buddies;\n\t\t}\n\t}","commit_id":"5e36c2a30e09bdae345996524509d5a98f76e37b","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            Builder builder = new Builder(parserContext.mapperService().fullName(NAME));\n            if (parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {\n                parseField(builder, builder.name, node, parserContext);\n            }\n\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"enabled\")) {\n                    EnabledAttributeMapper mapper = nodeBooleanValue(fieldNode) ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;\n                    builder.enabled(mapper);\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","id":41658,"modified_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            Builder builder = new Builder(parserContext.mapperService().fullName(NAME));\n            if (parserContext.indexVersionCreated().onOrAfter(Version.V_2_0_0_beta1)) {\n                return builder;\n            }\n\n            parseField(builder, builder.name, node, parserContext);\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"enabled\")) {\n                    EnabledAttributeMapper mapper = nodeBooleanValue(fieldNode) ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;\n                    builder.enabled(mapper);\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testThatMergingFieldMappingAllowsDisabling() throws Exception {\n        String mappingWithIndexEnabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper mapperEnabled = parser.parse(mappingWithIndexEnabled);\n\n\n        String mappingWithIndexDisabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper mapperDisabled = parser.parse(mappingWithIndexDisabled);\n\n        mapperEnabled.merge(mapperDisabled.mapping(), false, false);\n        assertThat(mapperEnabled.IndexFieldMapper().enabled(), is(false));\n    }","id":41659,"modified_method":"public void testThatMergingFieldMappingAllowsDisablingBackcompat() throws Exception {\n        String mappingWithIndexEnabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\", bwcSettings).mapperService().documentMapperParser();\n        DocumentMapper mapperEnabled = parser.parse(mappingWithIndexEnabled);\n\n\n        String mappingWithIndexDisabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper mapperDisabled = parser.parse(mappingWithIndexDisabled);\n\n        mapperEnabled.merge(mapperDisabled.mapping(), false, false);\n        assertThat(mapperEnabled.IndexFieldMapper().enabled(), is(false));\n    }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testCustomSettingsBackcompat() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n            .startObject(\"_index\")\n                .field(\"enabled\", true)\n                .field(\"store\", \"yes\").endObject()\n            .endObject().endObject().string();\n        Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();\n        DocumentMapper docMapper = createIndex(\"test\", indexSettings).mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(true));\n        assertThat(indexMapper.fieldType().stored(), equalTo(true));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"field\", \"value\")\n            .endObject()\n            .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41660,"modified_method":"public void testCustomSettingsBackcompat() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n            .startObject(\"_index\")\n                .field(\"enabled\", true)\n                .field(\"store\", \"yes\").endObject()\n            .endObject().endObject().string();\n\n        DocumentMapper docMapper = createIndex(\"test\", bwcSettings).mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(true));\n        assertThat(indexMapper.fieldType().stored(), equalTo(true));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"field\", \"value\")\n            .endObject()\n            .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testThatDisablingWorksWhenMerging() throws Exception {\n        String enabledMapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper enabledMapper = parser.parse(enabledMapping);\n\n        String disabledMapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper disabledMapper = parser.parse(disabledMapping);\n\n        enabledMapper.merge(disabledMapper.mapping(), false, false);\n        assertThat(enabledMapper.indexMapper().enabled(), is(false));\n    }","id":41661,"modified_method":"public void testThatDisablingWorksWhenMergingBackcompat() throws Exception {\n        String enabledMapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\", bwcSettings).mapperService().documentMapperParser();\n        DocumentMapper enabledMapper = parser.parse(enabledMapping);\n\n        String disabledMapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper disabledMapper = parser.parse(disabledMapping);\n\n        enabledMapper.merge(disabledMapper.mapping(), false, false);\n        assertThat(enabledMapper.indexMapper().enabled(), is(false));\n    }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleIndexMapper() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.indexMapper();\n        assertThat(indexMapper.enabled(), equalTo(true));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41662,"modified_method":"public void testSimpleIndexMapperEnabledBackcompat() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\", bwcSettings).mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.indexMapper();\n        assertThat(indexMapper.enabled(), equalTo(true));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testExplicitDisabledIndexMapper() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41663,"modified_method":"public void testExplicitDisabledIndexMapperBackcompat() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\", bwcSettings).mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"1c99626b844dd9103e8ddae7f132557ba3c0c9f6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // if all defaults, no need to write it at all\n        if (!includeDefaults && fieldType().stored() == Defaults.FIELD_TYPE.stored() && enabledState == Defaults.ENABLED_STATE && customFieldDataSettings == null) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (includeDefaults || fieldType().stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType().stored());\n        }\n        if (includeDefaults || enabledState != Defaults.ENABLED_STATE) {\n            builder.field(\"enabled\", enabledState.enabled);\n        }\n\n        if (customFieldDataSettings != null) {\n            builder.field(\"fielddata\", (Map) customFieldDataSettings.getAsMap());\n        } else if (includeDefaults) {\n            builder.field(\"fielddata\", (Map) fieldDataType.getSettings().getAsMap());\n\n        }\n        builder.endObject();\n        return builder;\n    }","id":41664,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // if all defaults, no need to write it at all\n        if (!includeDefaults && fieldType().stored() == Defaults.FIELD_TYPE.stored() && enabledState == Defaults.ENABLED_STATE && customFieldDataSettings == null) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (writePre2xSettings && (includeDefaults || fieldType().stored() != Defaults.FIELD_TYPE.stored())) {\n            builder.field(\"store\", fieldType().stored());\n        }\n        if (includeDefaults || enabledState != Defaults.ENABLED_STATE) {\n            builder.field(\"enabled\", enabledState.enabled);\n        }\n\n        if (writePre2xSettings) {\n            if (customFieldDataSettings != null) {\n                builder.field(\"fielddata\", (Map) customFieldDataSettings.getAsMap());\n            } else if (includeDefaults) {\n                builder.field(\"fielddata\", (Map) fieldDataType.getSettings().getAsMap());\n            }\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            IndexFieldMapper.Builder builder = MapperBuilders.index();\n            parseField(builder, builder.name, node, parserContext);\n\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"enabled\")) {\n                    EnabledAttributeMapper mapper = nodeBooleanValue(fieldNode) ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;\n                    builder.enabled(mapper);\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","id":41665,"modified_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            IndexFieldMapper.Builder builder = MapperBuilders.index();\n            if (parserContext.indexVersionCreated().before(Version.V_2_0_0)) {\n                parseField(builder, builder.name, node, parserContext);\n            }\n\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"enabled\")) {\n                    EnabledAttributeMapper mapper = nodeBooleanValue(fieldNode) ? EnabledAttributeMapper.ENABLED : EnabledAttributeMapper.DISABLED;\n                    builder.enabled(mapper);\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void defaultDisabledIndexMapperTests() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n        assertThat(indexMapper.fieldType().stored(), equalTo(false));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41666,"modified_method":"public void testDefaultDisabledIndexMapper() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleIndexMapperTests() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(true));\n        assertThat(indexMapper.fieldType().stored(), equalTo(true));\n        assertThat(docMapper.mappers().indexName(\"_index\").mapper(), instanceOf(IndexFieldMapper.class));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41667,"modified_method":"public void testSimpleIndexMapper() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(true));\n        assertThat(docMapper.mappers().indexName(\"_index\").mapper(), instanceOf(IndexFieldMapper.class));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), equalTo(\"test\"));\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void explicitDisabledIndexMapperTests() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).field(\"store\", \"yes\").endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n        assertThat(indexMapper.fieldType().stored(), equalTo(true));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","id":41668,"modified_method":"public void testExplicitDisabledIndexMapper() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        IndexFieldMapper indexMapper = docMapper.rootMapper(IndexFieldMapper.class);\n        assertThat(indexMapper.enabled(), equalTo(false));\n\n        ParsedDocument doc = docMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                .field(\"field\", \"value\")\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().get(\"_index\"), nullValue());\n        assertThat(doc.rootDoc().get(\"field\"), equalTo(\"value\"));\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testThatMergingFieldMappingAllowsDisabling() throws Exception {\n        String mappingWithIndexEnabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper mapperEnabled = parser.parse(mappingWithIndexEnabled);\n\n\n        String mappingWithIndexDisabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).field(\"store\", \"yes\").endObject()\n                .endObject().endObject().string();\n        DocumentMapper mapperDisabled = parser.parse(mappingWithIndexDisabled);\n\n        mapperEnabled.merge(mapperDisabled, DocumentMapper.MergeFlags.mergeFlags().simulate(false));\n        assertThat(mapperEnabled.IndexFieldMapper().enabled(), is(false));\n    }","id":41669,"modified_method":"public void testThatMergingFieldMappingAllowsDisabling() throws Exception {\n        String mappingWithIndexEnabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", true).endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper mapperEnabled = parser.parse(mappingWithIndexEnabled);\n\n\n        String mappingWithIndexDisabled = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_index\").field(\"enabled\", false).endObject()\n                .endObject().endObject().string();\n        DocumentMapper mapperDisabled = parser.parse(mappingWithIndexDisabled);\n\n        mapperEnabled.merge(mapperDisabled, DocumentMapper.MergeFlags.mergeFlags().simulate(false));\n        assertThat(mapperEnabled.IndexFieldMapper().enabled(), is(false));\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testIndexFieldParsing() throws IOException {\n        IndexService indexService = createIndex(\"test\", ImmutableSettings.settingsBuilder().build());\n        XContentBuilder indexMapping = XContentFactory.jsonBuilder();\n        boolean enabled = randomBoolean();\n        indexMapping.startObject()\n                .startObject(\"type\")\n                .startObject(\"_index\")\n                .field(\"enabled\", enabled)\n                .field(\"store\", true)\n                .startObject(\"fielddata\")\n                .field(\"format\", \"fst\")\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject();\n        DocumentMapper documentMapper = indexService.mapperService().parse(\"type\", new CompressedString(indexMapping.string()), true);\n        assertThat(documentMapper.indexMapper().enabled(), equalTo(enabled));\n        assertTrue(documentMapper.indexMapper().fieldType().stored());\n        assertThat(documentMapper.indexMapper().fieldDataType().getFormat(null), equalTo(\"fst\"));\n        documentMapper.refreshSource();\n        documentMapper = indexService.mapperService().parse(\"type\", new CompressedString(documentMapper.mappingSource().string()), true);\n        assertThat(documentMapper.indexMapper().enabled(), equalTo(enabled));\n        assertTrue(documentMapper.indexMapper().fieldType().stored());\n        assertThat(documentMapper.indexMapper().fieldDataType().getFormat(null), equalTo(\"fst\"));\n    }","id":41670,"modified_method":"@Test\n    public void testIndexFieldParsing() throws IOException {\n        IndexService indexService = createIndex(\"test\", ImmutableSettings.settingsBuilder().build());\n        XContentBuilder indexMapping = XContentFactory.jsonBuilder();\n        boolean enabled = randomBoolean();\n        indexMapping.startObject()\n                .startObject(\"type\")\n                .startObject(\"_index\")\n                .field(\"enabled\", enabled)\n                .endObject()\n                .endObject()\n                .endObject();\n        DocumentMapper documentMapper = indexService.mapperService().parse(\"type\", new CompressedString(indexMapping.string()), true);\n        assertThat(documentMapper.indexMapper().enabled(), equalTo(enabled));\n        documentMapper.refreshSource();\n        documentMapper = indexService.mapperService().parse(\"type\", new CompressedString(documentMapper.mappingSource().string()), true);\n        assertThat(documentMapper.indexMapper().enabled(), equalTo(enabled));\n    }","commit_id":"32e042f1c456e3149644f00ad17b4f6b3433429d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testUngeneratedFieldsNotPartOfSourceUnstored() throws IOException {\n        indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(false, randomBoolean());\n        String[] fieldsList = {\"_timestamp\", \"_size\", \"_routing\"};\n        // before refresh - document is only in translog\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n        refresh();\n        //after refresh - document is in translog and also indexed\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n        flush();\n        //after flush - document is in not anymore translog - only indexed\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n    }","id":41671,"modified_method":"@Test\n    public void testUngeneratedFieldsNotPartOfSourceUnstored() throws IOException {\n        indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(false, randomBoolean());\n        String[] fieldsList = {\"_timestamp\", \"_size\"};\n        String[] alwaysStoredFieldsList = {\"_routing\"};\n        // before refresh - document is only in translog\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n        assertGetFieldsAlwaysWorks(indexOrAlias(), \"doc\", \"1\", alwaysStoredFieldsList, \"1\");\n        refresh();\n        //after refresh - document is in translog and also indexed\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n        assertGetFieldsAlwaysWorks(indexOrAlias(), \"doc\", \"1\", alwaysStoredFieldsList, \"1\");\n        flush();\n        //after flush - document is in not anymore translog - only indexed\n        assertGetFieldsAlwaysNull(indexOrAlias(), \"doc\", \"1\", fieldsList, \"1\");\n        assertGetFieldsAlwaysWorks(indexOrAlias(), \"doc\", \"1\", alwaysStoredFieldsList, \"1\");\n    }","commit_id":"78df69e6a05295e6e1c19654cdf3bc24180fac60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(boolean stored, boolean sourceEnabled) {\n        String storedString = stored ? \"yes\" : \"no\";\n        String createIndexSource = \"{\\n\" +\n                \"  \\\"settings\\\": {\\n\" +\n                \"    \\\"index.translog.disable_flush\\\": true,\\n\" +\n                \"    \\\"refresh_interval\\\": \\\"-1\\\"\\n\" +\n                \"  },\\n\" +\n                \"  \\\"mappings\\\": {\\n\" +\n                \"    \\\"parentdoc\\\": {},\\n\" +\n                \"    \\\"doc\\\": {\\n\" +\n                \"      \\\"_timestamp\\\": {\\n\" +\n                \"        \\\"store\\\": \\\"\" + storedString + \"\\\",\\n\" +\n                \"        \\\"enabled\\\": true\\n\" +\n                \"      },\\n\" +\n                \"      \\\"_routing\\\": {\\n\" +\n                \"        \\\"store\\\": \\\"\" + storedString + \"\\\"\\n\" +\n                \"      },\\n\" +\n                \"      \\\"_size\\\": {\\n\" +\n                \"        \\\"store\\\": \\\"\" + storedString + \"\\\",\\n\" +\n                \"        \\\"enabled\\\": true\\n\" +\n                \"      }\\n\" +\n                \"    }\\n\" +\n                \"  }\\n\" +\n                \"}\";\n\n        assertAcked(prepareCreate(\"test\").addAlias(new Alias(\"alias\")).setSource(createIndexSource));\n        ensureGreen();\n        String doc = \"{\\n\" +\n                \"  \\\"text\\\": \\\"some text.\\\"\\n\" +\n                \"}\\n\";\n        client().prepareIndex(\"test\", \"doc\").setId(\"1\").setSource(doc).setRouting(\"1\").get();\n    }","id":41672,"modified_method":"void indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(boolean stored, boolean sourceEnabled) {\n        String storedString = stored ? \"yes\" : \"no\";\n        String createIndexSource = \"{\\n\" +\n                \"  \\\"settings\\\": {\\n\" +\n                \"    \\\"index.translog.disable_flush\\\": true,\\n\" +\n                \"    \\\"refresh_interval\\\": \\\"-1\\\"\\n\" +\n                \"  },\\n\" +\n                \"  \\\"mappings\\\": {\\n\" +\n                \"    \\\"parentdoc\\\": {},\\n\" +\n                \"    \\\"doc\\\": {\\n\" +\n                \"      \\\"_timestamp\\\": {\\n\" +\n                \"        \\\"store\\\": \\\"\" + storedString + \"\\\",\\n\" +\n                \"        \\\"enabled\\\": true\\n\" +\n                \"      },\\n\" +\n                \"      \\\"_size\\\": {\\n\" +\n                \"        \\\"store\\\": \\\"\" + storedString + \"\\\",\\n\" +\n                \"        \\\"enabled\\\": true\\n\" +\n                \"      }\\n\" +\n                \"    }\\n\" +\n                \"  }\\n\" +\n                \"}\";\n\n        assertAcked(prepareCreate(\"test\").addAlias(new Alias(\"alias\")).setSource(createIndexSource));\n        ensureGreen();\n        String doc = \"{\\n\" +\n                \"  \\\"text\\\": \\\"some text.\\\"\\n\" +\n                \"}\\n\";\n        client().prepareIndex(\"test\", \"doc\").setId(\"1\").setSource(doc).setRouting(\"1\").get();\n    }","commit_id":"78df69e6a05295e6e1c19654cdf3bc24180fac60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            RoutingFieldMapper.Builder builder = routing();\n            parseField(builder, builder.name, node, parserContext);\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"required\")) {\n                    builder.required(nodeBooleanValue(fieldNode));\n                    iterator.remove();\n                } else if (fieldName.equals(\"path\") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {\n                    builder.path(fieldNode.toString());\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","id":41673,"modified_method":"@Override\n        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            RoutingFieldMapper.Builder builder = routing();\n            if (parserContext.indexVersionCreated().before(Version.V_2_0_0)) {\n                parseField(builder, builder.name, node, parserContext);\n            }\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"required\")) {\n                    builder.required(nodeBooleanValue(fieldNode));\n                    iterator.remove();\n                } else if (fieldName.equals(\"path\") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {\n                    builder.path(fieldNode.toString());\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","commit_id":"78df69e6a05295e6e1c19654cdf3bc24180fac60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // if all are defaults, no sense to write it at all\n        boolean indexed = fieldType.indexOptions() != IndexOptions.NONE;\n        boolean indexedDefault = Defaults.FIELD_TYPE.indexOptions() != IndexOptions.NONE;\n        if (!includeDefaults && indexed == indexedDefault &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && required == Defaults.REQUIRED && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (includeDefaults || indexed != indexedDefault) {\n            builder.field(\"index\", indexTokenizeOptionToString(indexed, fieldType.tokenized()));\n        }\n        if (includeDefaults || fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (includeDefaults || required != Defaults.REQUIRED) {\n            builder.field(\"required\", required);\n        }\n        if (writePre2xSettings && (includeDefaults || path != Defaults.PATH)) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","id":41674,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // if all are defaults, no sense to write it at all\n        boolean indexed = fieldType.indexOptions() != IndexOptions.NONE;\n        boolean indexedDefault = Defaults.FIELD_TYPE.indexOptions() != IndexOptions.NONE;\n        if (!includeDefaults && indexed == indexedDefault &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && required == Defaults.REQUIRED && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (writePre2xSettings && (includeDefaults || indexed != indexedDefault)) {\n            builder.field(\"index\", indexTokenizeOptionToString(indexed, fieldType.tokenized()));\n        }\n        if (writePre2xSettings && (includeDefaults || fieldType.stored() != Defaults.FIELD_TYPE.stored())) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (includeDefaults || required != Defaults.REQUIRED) {\n            builder.field(\"required\", required);\n        }\n        if (writePre2xSettings && (includeDefaults || path != Defaults.PATH)) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"78df69e6a05295e6e1c19654cdf3bc24180fac60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) {\n\t\t\tsval = filterStyle(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else\n\t\t\tsetDynaProp(name, value);\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval});\n\t}","id":41675,"modified_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) {\n\t\t\tsval = filterStyle(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else if (\"src\".equals(name)) {\n\t\t\tsval = getEncodedURL(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else if (\"textContent\".equals(name)) {\n\t\t\tsetDynaProp(name, sval);\n\t\t\tif (!getChildren().isEmpty())\n\t\t\t\tinvalidate();\n\t\t} else\n\t\t\tsetDynaProp(name, value);\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval});\n\t}","commit_id":"0f37ff32f487c12159811719ad3d18257a152067","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * @param hideUuidIfNoId whether not to generate UUID if possible\n\t */\n\t/*package*/ String getPrologHalf(boolean hideUuidIfNoId) {\n\t\tfinal StringBuffer sb = new StringBuffer(128)\n\t\t\t.append('<').append(_tagnm);\n\n\t\tif ((!hideUuidIfNoId && !shallHideId()) || getId().length() > 0)\n\t\t\tsb.append(\" id=\\\"\").append(getUuid()).append('\"');\n\n\t\tif (_props != null) {\n\t\t\tfor (Iterator it = _props.entrySet().iterator(); it.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)it.next();\n\t\t\t\tsb.append(' ').append(me.getKey()).append(\"=\\\"\")\n\t\t\t\t\t.append(XMLs.encodeAttribute(Objects.toString(me.getValue())))\n\t\t\t\t\t.append('\"');\n\t\t\t}\n\t\t}\n\n\t\tif (!isOrphanTag())\n\t\t\tsb.append('/');\n\n\t\treturn sb.append('>').toString();\n\t}","id":41676,"modified_method":"/**\n\t * @param hideUuidIfNoId whether not to generate UUID if possible\n\t */\n\t/*package*/ String getPrologHalf(boolean hideUuidIfNoId) {\n\t\tfinal StringBuilder sb = new StringBuilder(128)\n\t\t\t.append('<').append(_tagnm);\n\n\t\tif ((!hideUuidIfNoId && !shallHideId()) || getId().length() > 0)\n\t\t\tsb.append(\" id=\\\"\").append(getUuid()).append('\"');\n\n\t\tif (_props != null) {\n\t\t\tfor (Iterator it = _props.entrySet().iterator(); it.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)it.next();\n\t\t\t\tsb.append(' ').append(me.getKey()).append(\"=\\\"\")\n\t\t\t\t\t.append(XMLs.encodeAttribute(Objects.toString(me.getValue())))\n\t\t\t\t\t.append('\"');\n\t\t\t}\n\t\t}\n\n\t\tif (!isOrphanTag())\n\t\t\tsb.append('/');\n\n\t\tsb.append('>');\n\t\t\n\n\t\tObject textContent = getDynamicProperty(\"textContent\");\n\t\tif (textContent != null)\n\t\t\tsb.append((String)textContent);\n\t\treturn sb.toString();\n\t}","commit_id":"0f37ff32f487c12159811719ad3d18257a152067","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) {\n\t\t\tsval = filterStyle(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else if (\"src\".equals(name)) {\n\t\t\tsval = getEncodedURL(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else if (\"textContent\".equals(name)) {\n\t\t\tsetDynaProp(name, sval);\n\t\t\tif (!getChildren().isEmpty())\n\t\t\t\tinvalidate();\n\t\t} else\n\t\t\tsetDynaProp(name, value);\n\t\t//B80-ZK-2716: style and textContent are both dynamiccProperty\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval}, true);\n\t}","id":41677,"modified_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) {\n\t\t\tsval = filterStyle(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else if (\"src\".equals(name)) {\n\t\t\t// ZK-3011: should defer until render\n\t\t\tEncodedURL url = new EncodedURL(sval);\n\t\t\tsetDynaProp(name, url);\n\t\t\tsmartUpdate(\"dynamicProperty\", new Object[]{name, url}, true);\n\t\t\treturn;\n\t\t} else if (\"textContent\".equals(name)) {\n\t\t\tsetDynaProp(name, sval);\n\t\t\tif (!getChildren().isEmpty())\n\t\t\t\tinvalidate();\n\t\t} else\n\t\t\tsetDynaProp(name, value);\n\t\t//B80-ZK-2716: style and textContent are both dynamiccProperty\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval}, true);\n\t}","commit_id":"57c7945a4a6474df80edee0b71b73aae2c676f5c","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * @param hideUuidIfNoId whether not to generate UUID if possible\n\t */\n\t/*package*/ String getPrologHalf(boolean hideUuidIfNoId) {\n\t\tfinal StringBuilder sb = new StringBuilder(128)\n\t\t\t.append('<').append(_tagnm);\n\n\t\tif ((!hideUuidIfNoId && !shallHideId()) || getId().length() > 0)\n\t\t\tsb.append(\" id=\\\"\").append(getUuid()).append('\"');\n\n\t\tif (_props != null) {\n\t\t\tfor (Iterator it = _props.entrySet().iterator(); it.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)it.next();\n\t\t\t\tif (!\"textContent\".equals(me.getKey())) { // ignore textContent\n\t\t\t\t\tsb.append(' ').append(me.getKey()).append(\"=\\\"\")\n\t\t\t\t\t\t.append(XMLs.encodeAttribute(Objects.toString(me.getValue())))\n\t\t\t\t\t\t.append('\"');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isOrphanTag())\n\t\t\tsb.append('/');\n\n\t\tsb.append('>');\n\t\t\n\n\t\tObject textContent = getDynamicProperty(\"textContent\");\n\t\tif (textContent != null)\n\t\t\tsb.append(XMLs.escapeXML((String)textContent));\n\t\treturn sb.toString();\n\t}","id":41678,"modified_method":"/**\n\t * @param hideUuidIfNoId whether not to generate UUID if possible\n\t */\n\t/*package*/ String getPrologHalf(boolean hideUuidIfNoId) {\n\t\tfinal StringBuilder sb = new StringBuilder(128)\n\t\t\t.append('<').append(_tagnm);\n\n\t\tif ((!hideUuidIfNoId && !shallHideId()) || getId().length() > 0)\n\t\t\tsb.append(\" id=\\\"\").append(getUuid()).append('\"');\n\n\t\tif (_props != null) {\n\t\t\tfor (Iterator it = _props.entrySet().iterator(); it.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)it.next();\n\t\t\t\tif (!\"textContent\".equals(me.getKey())) { // ignore textContent\n\t\t\t\t\t// ZK-3011: should getValue if it's a deferredValue\n\t\t\t\t\tObject v = me.getValue();\n\t\t\t\t\tif (v instanceof DeferredValue) {\n\t\t\t\t\t\tv = ((DeferredValue) v).getValue();\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(' ').append(me.getKey()).append(\"=\\\"\")\n\t\t\t\t\t\t.append(XMLs.encodeAttribute(Objects.toString(v)))\n\t\t\t\t\t\t.append('\"');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isOrphanTag())\n\t\t\tsb.append('/');\n\n\t\tsb.append('>');\n\t\t\n\n\t\tObject textContent = getDynamicProperty(\"textContent\");\n\t\tif (textContent != null)\n\t\t\tsb.append(XMLs.escapeXML((String)textContent));\n\t\treturn sb.toString();\n\t}","commit_id":"57c7945a4a6474df80edee0b71b73aae2c676f5c","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) sval = filterStyle(sval);\n\n\t\tsetDynaProp(name, sval);\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval});\n\t}","id":41679,"modified_method":"/** Sets the dynamic property.\n\t * Note: it converts the value to a string object (by use of\n\t * {@link Objects#toString}).\n\t *\n\t * <p>Note: it handles the style property specially. Refer to {@link #setStyle}\n\t * for details.\n\t */\n\tpublic void setDynamicProperty(String name, Object value)\n\tthrows WrongValueException {\n\t\tif (name == null)\n\t\t\tthrow new WrongValueException(\"name is required\");\n\t\tif (!hasDynamicProperty(name))\n\t\t\tthrow new WrongValueException(\"Attribute not allowed: \"+name+\"\\nSpecify the ZK namespace if you want to use special ZK attributes\");\n\n\t\tString sval = Objects.toString(value);\n\t\tif (\"style\".equals(name)) {\n\t\t\tsval = filterStyle(sval);\n\t\t\tsetDynaProp(name, sval);\n\t\t} else\n\t\t\tsetDynaProp(name, value);\n\t\tsmartUpdate(\"dynamicProperty\", new String[] {name, sval});\n\t}","commit_id":"1bcb2173bf9d6d9b197ab9627b3d72eec3843de2","url":"https://github.com/zkoss/zk"},{"original_method":"/** Set the dynamic property 'blindly'. */\n\tprivate void setDynaProp(String name, String value) {\n\t\tif (value == null) {\n\t\t\tif (_props != null) _props.remove(name);\n\t\t} else {\n\t\t\tif (_props == null)\n\t\t\t\t_props = new LinkedHashMap();\n\t\t\t_props.put(name, value);\n\t\t}\n\t}","id":41680,"modified_method":"/** Set the dynamic property 'blindly'. */\n\tprivate void setDynaProp(String name, Object value) {\n\t\tif (value == null) {\n\t\t\tif (_props != null) _props.remove(name);\n\t\t} else {\n\t\t\tif (_props == null)\n\t\t\t\t_props = new LinkedHashMap();\n\t\t\t_props.put(name, value);\n\t\t}\n\t}","commit_id":"1bcb2173bf9d6d9b197ab9627b3d72eec3843de2","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * @since 5.0.0\n\t */\n\tpublic void process(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String name = request.getName();\n\t\tif (name.equals(Events.ON_CHANGE)) {\n\t\t\tInputEvent evt = InputEvent.getInputEvent(request);\n\n\t\t\tfinal String value = evt.getValue();\n\t\t\t_byClient = true;\n\t\t\ttry {\n\t\t\t\tsetValue(value);\n\t\t\t} finally {\n\t\t\t\t_byClient = false;\n\t\t\t}\n\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.process(request, everError);\n\t}","id":41681,"modified_method":"/** Processes an AU request.\n\t *\n\t * @since 5.0.0\n\t */\n\tpublic void process(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String name = request.getName();\n\t\tif (name.equals(Events.ON_CHANGE)) {\n\t\t\tInputEvent evt = InputEvent.getInputEvent(request);\n\n\t\t\tfinal String value = evt.getValue();\n\t\t\t_byClient = true;\n\t\t\ttry {\n\t\t\t\tsetValue(value);\n\t\t\t} finally {\n\t\t\t\t_byClient = false;\n\t\t\t}\n\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_CHECK)) {\n\t\t\tCheckEvent evt = CheckEvent.getCheckEvent(request);\n\n\t\t\t_byClient = true;\n\t\t\ttry {\n\t\t\t\tsetChecked(evt.isChecked());\n\t\t\t} finally {\n\t\t\t\t_byClient = false;\n\t\t\t}\n\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.process(request, everError);\n\t}","commit_id":"1bcb2173bf9d6d9b197ab9627b3d72eec3843de2","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * Get the revision of the latest change made to this node.\n     * \n     * @param nodeMap the document\n     * @param before the returned value is guaranteed to be older than this revision\n     * @param onlyCommitted whether only committed changes should be considered\n     * @return the revision, or null if deleted\n     */\n    @Nullable Revision getNewestRevision(Map<String, Object> nodeMap, Revision before, boolean onlyCommitted) {\n        if (nodeMap == null) {\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        Revision newestRev = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n                // TODO check if propRev is really committed, if\n                // onlyCommitted is set\n                if (isRevisionNewer(before, propRev)) {\n                    newestRev = propRev;\n                }\n            }\n        }\n        return newestRev;\n    }","id":41682,"modified_method":"/**\n     * Get the revision of the latest change made to this node.\n     * \n     * @param nodeMap the document\n     * @param before the returned value is guaranteed to be older than this revision\n     * @param onlyCommitted whether only committed changes should be considered\n     * @return the revision, or null if deleted\n     */\n    @Nullable Revision getNewestRevision(Map<String, Object> nodeMap, Revision before, boolean onlyCommitted) {\n        if (nodeMap == null) {\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        Revision newestRev = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n                if (isRevisionNewer(before, propRev)) {\n                    if (!onlyCommitted || isValidRevision(propRev, before, nodeMap)) {\n                        newestRev = propRev;\n                    }\n                }\n            }\n        }\n        return newestRev;\n    }","commit_id":"627e4103ddd012ba5c9af75a131403a30b659061","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Node readNode(String path, Revision readRevision) {\n        String id = Utils.getIdFromPath(path);\n        Map<String, Object> map = store.find(DocumentStore.Collection.NODES, id);\n        if (map == null) {\n            return null;\n        }\n        Revision min = getLiveRevision(map, readRevision);\n        if (min == null) {\n            // deleted\n            return null;\n        }\n        Node n = new Node(path, readRevision);\n        for (String key : map.keySet()) {\n            if (!Utils.isPropertyName(key)) {\n                continue;\n            }\n            Object v = map.get(key);\n            @SuppressWarnings(\"unchecked\")\n            Map<String, String> valueMap = (Map<String, String>) v;\n            if (valueMap != null) {\n                if (valueMap instanceof TreeMap) {\n                    // TODO instanceof should be avoided\n                    // use descending keys (newest first) if map is sorted\n                    valueMap = ((TreeMap<String, String>) valueMap).descendingMap();\n                }\n                String value = getLatestValue(valueMap, min, readRevision);\n                String propertyName = Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n\n        // when was this node last modified?\n        Revision lastRevision = null;\n        Map<String, Revision> lastRevs = new HashMap<String, Revision>();\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) map.get(UpdateOp.LAST_REV);\n        if (valueMap != null) {\n            for (String clusterId : valueMap.keySet()) {\n                lastRevs.put(clusterId, Revision.fromString(valueMap.get(clusterId)));\n            }\n        }\n        // overlay with unsaved last modified from this instance\n        Revision lastModified = unsavedLastRevisions.get(path);\n        Branch branch = branches.getBranch(readRevision);\n        if (lastModified != null) {\n            if (branch != null) {\n                // visible from this branch if revision is\n                // not newer than base of branch\n                if (!isRevisionNewer(lastModified, branch.getBase())) {\n                    lastRevs.put(String.valueOf(clusterId), lastModified);\n                }\n            } else {\n                // non-branch read -> check if newer\n                if (isRevisionNewer(lastModified, readRevision)) {\n                    // at most readRevision\n                    lastRevs.put(String.valueOf(clusterId), readRevision);\n                } else {\n                    lastRevs.put(String.valueOf(clusterId), lastModified);\n                }\n            }\n        }\n        if (branch != null) {\n            // read from a branch\n            // -> overlay with unsaved last revs from branch\n            Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevs.put(String.valueOf(clusterId), r);\n            }\n        }\n\n        for (String r : lastRevs.keySet()) {\n            lastModified = lastRevs.get(r);\n            if (isRevisionNewer(lastModified, readRevision)) {\n                // at most the read revision\n                lastModified = readRevision;\n            }\n            if (lastRevision == null || isRevisionNewer(lastModified, lastRevision)) {\n                lastRevision = lastModified;\n            }\n        }\n        if (lastRevision == null) {\n            // use readRevision if none found\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }","id":41683,"modified_method":"private Node readNode(String path, Revision readRevision) {\n        String id = Utils.getIdFromPath(path);\n        Map<String, Object> map = store.find(DocumentStore.Collection.NODES, id);\n        if (map == null) {\n            return null;\n        }\n        Revision min = getLiveRevision(map, readRevision);\n        if (min == null) {\n            // deleted\n            return null;\n        }\n        Node n = new Node(path, readRevision);\n        for (String key : map.keySet()) {\n            if (!Utils.isPropertyName(key)) {\n                continue;\n            }\n            Object v = map.get(key);\n            @SuppressWarnings(\"unchecked\")\n            Map<String, String> valueMap = (Map<String, String>) v;\n            if (valueMap != null) {\n                if (valueMap instanceof TreeMap) {\n                    // TODO instanceof should be avoided\n                    // use descending keys (newest first) if map is sorted\n                    valueMap = ((TreeMap<String, String>) valueMap).descendingMap();\n                }\n                String value = getLatestValue(valueMap, min, readRevision);\n                String propertyName = Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n\n        // when was this node last modified?\n        Branch branch = branches.getBranch(readRevision);\n        Revision lastRevision = null;\n        Map<Integer, Revision> lastRevs = new HashMap<Integer, Revision>();\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) map.get(UpdateOp.LAST_REV);\n        if (valueMap != null) {\n            for (String clusterId : valueMap.keySet()) {\n                lastRevs.put(Integer.parseInt(clusterId),\n                        Revision.fromString(valueMap.get(clusterId)));\n            }\n        }\n        // overlay with unsaved last modified from this instance\n        Revision lastModified = unsavedLastRevisions.get(path);\n        if (lastModified != null) {\n            lastRevs.put(clusterId, lastModified);\n        }\n        // filter out revisions newer than branch base\n        if (branch != null) {\n            for (Iterator<Revision> it = lastRevs.values().iterator(); it.hasNext(); ) {\n                Revision r = it.next();\n                if (isRevisionNewer(r, branch.getBase())) {\n                    it.remove();\n                }\n            }\n        }\n        for (Revision r : lastRevs.values()) {\n            // ignore if newer than readRevision\n            if (isRevisionNewer(r, readRevision)) {\n                continue;\n            }\n            if (lastRevision == null || isRevisionNewer(r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            // read from a branch\n            // -> possibly overlay with unsaved last revs from branch\n            Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        if (lastRevision == null) {\n            // use readRevision if none found\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }","commit_id":"f02c3058bb42bbe27353da612b65e12765ef6ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public String rebase(String branchRevisionId, String newBaseRevisionId)\n            throws MicroKernelException {\n        // TODO improve implementation if needed\n        return branchRevisionId;\n    }","id":41684,"modified_method":"@Override\n    @Nonnull\n    public String rebase(@Nonnull String branchRevisionId, String newBaseRevisionId)\n            throws MicroKernelException {\n        Revision r = Revision.fromString(stripBranchRevMarker(branchRevisionId));\n        Branch b = branches.getBranch(r);\n        if (b == null) {\n            throw new MicroKernelException(branchRevisionId\n                    + \" is not a valid branch revision\");\n        }\n        // TODO conflict handling\n        Revision base = Revision.fromString(newBaseRevisionId);\n        b.setBase(base);\n        // add a pseudo commit to make sure current head of branch\n        // has a higher revision than base of branch\n        Revision head = newRevision();\n        b.addCommit(head);\n        return \"b\" + head.toString();\n    }","commit_id":"f02c3058bb42bbe27353da612b65e12765ef6ebf","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the latest revision where the node was alive at or before the the\n     * provided revision.\n     * \n     * @param nodeMap the node map\n     * @param maxRev the maximum revision to return\n     * @return the earliest revision, or null if the node is deleted at the\n     *         given revision\n     */\n    private Revision getLiveRevision(Map<String, Object> nodeMap,\n            Revision maxRev) {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        Revision firstRev = null;\n        String value = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (isRevisionNewer(propRev, maxRev)) {\n                continue;\n            }\n            String v = valueMap.get(r);\n            if (firstRev == null || isRevisionNewer(propRev, firstRev)) {\n                firstRev = propRev;\n                value = v;\n            }\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return firstRev;\n    }","id":41685,"modified_method":"/**\n     * Get the latest revision where the node was alive at or before the\n     * provided revision.\n     * \n     * @param nodeMap the node map\n     * @param maxRev the maximum revision to return\n     * @return the earliest revision, or null if the node is deleted at the\n     *         given revision\n     */\n    private Revision getLiveRevision(Map<String, Object> nodeMap,\n            Revision maxRev) {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        Revision firstRev = null;\n        String value = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (isRevisionNewer(propRev, maxRev)\n                    || !isValidRevision(propRev, nodeMap)) {\n                continue;\n            }\n            String v = valueMap.get(r);\n            if (firstRev == null || isRevisionNewer(propRev, firstRev)) {\n                firstRev = propRev;\n                value = v;\n            }\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return firstRev;\n    }","commit_id":"c323553c09ca786cfe1eac64eed8f85bb2ef7419","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void addNodeGetNode() {\n        MongoMK mk = new MongoMK();\n        Revision rev = mk.newRevision();\n        Node n = new Node(\"/test\", rev);\n        n.setProperty(\"name\", \"Hello\");\n        UpdateOp op = n.asOperation(true);\n        DocumentStore s = mk.getDocumentStore();\n        assertTrue(s.create(Collection.NODES, Lists.newArrayList(op)));\n        Node n2 = mk.getNode(\"/test\", rev);\n        assertEquals(\"Hello\", n2.getProperty(\"name\"));\n        mk.dispose();\n    }","id":41686,"modified_method":"@Test\n    public void addNodeGetNode() {\n        MongoMK mk = new MongoMK();\n        Revision rev = mk.newRevision();\n        Node n = new Node(\"/test\", rev);\n        n.setProperty(\"name\", \"Hello\");\n        UpdateOp op = n.asOperation(true);\n        // mark as commit root\n        op.addMapEntry(UpdateOp.REVISIONS + \".\" + rev, \"true\");\n        DocumentStore s = mk.getDocumentStore();\n        assertTrue(s.create(Collection.NODES, Lists.newArrayList(op)));\n        Node n2 = mk.getNode(\"/test\", rev);\n        assertEquals(\"Hello\", n2.getProperty(\"name\"));\n        mk.dispose();\n    }","commit_id":"c323553c09ca786cfe1eac64eed8f85bb2ef7419","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n\t * Updates the folder.\n\t *\n\t * @param  folderId the primary key of the folder\n\t * @param  parentFolderId the primary key of the folder's new parent folder\n\t * @param  name the folder's new name\n\t * @param  description the folder's new description\n\t * @param  serviceContext the service context to be applied. In a Liferay\n\t *         repository, it may include:  <ul> <li> defaultFileEntryTypeId -\n\t *         the file entry type to default all Liferay file entries to <\/li>\n\t *         <li> dlFileEntryTypesSearchContainerPrimaryKeys - a\n\t *         comma-delimited list of file entry type primary keys allowed in\n\t *         the given folder and all descendants <\/li> <li>\n\t *         overrideFileEntryTypes - boolean specifying whether to override\n\t *         ancestral folder's restriction of file entry types allowed <\/li>\n\t *         <li> workflowDefinitionXYZ - the workflow definition name\n\t *         specified per file entry type. The parameter name must be the\n\t *         string <code>workflowDefinition<\/code> appended by the <code>\n\t *         fileEntryTypeId<\/code> (optionally <code>0<\/code>). <\/li> <\/ul>\n\t * @return the folder\n\t * @throws PortalException if the current or new parent folder could not be\n\t *         found, or if the new parent folder's information was invalid\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic Folder updateFolder(\n\t\t\tlong folderId, long parentFolderId, String name, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tLocalRepository localRepository = getFolderLocalRepository(folderId);\n\n\t\tFolder folder = localRepository.updateFolder(\n\t\t\tfolderId, parentFolderId, name, description, serviceContext);\n\n\t\tdlAppHelperLocalService.updateFolder(\n\t\t\tserviceContext.getUserId(), folder, serviceContext);\n\n\t\treturn folder;\n\t}","id":41687,"modified_method":"/**\n\t * Updates the folder.\n\t *\n\t * @param  folderId the primary key of the folder\n\t * @param  parentFolderId the primary key of the folder's new parent folder\n\t * @param  name the folder's new name\n\t * @param  description the folder's new description\n\t * @param  serviceContext the service context to be applied. In a Liferay\n\t *         repository, it may include:  <ul> <li> defaultFileEntryTypeId -\n\t *         the file entry type to default all Liferay file entries to <\/li>\n\t *         <li> dlFileEntryTypesSearchContainerPrimaryKeys - a\n\t *         comma-delimited list of file entry type primary keys allowed in\n\t *         the given folder and all descendants <\/li> <li>\n\t *         overrideFileEntryTypes - boolean specifying whether to override\n\t *         ancestral folder's restriction of file entry types allowed <\/li>\n\t *         <li> workflowDefinitionXYZ - the workflow definition name\n\t *         specified per file entry type. The parameter name must be the\n\t *         string <code>workflowDefinition<\/code> appended by the <code>\n\t *         fileEntryTypeId<\/code> (optionally <code>0<\/code>). <\/li> <\/ul>\n\t * @return the folder\n\t * @throws PortalException if the current or new parent folder could not be\n\t *         found, or if the new parent folder's information was invalid\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic Folder updateFolder(\n\t\t\tlong folderId, long parentFolderId, String name, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tLocalRepository localRepository = getFolderLocalRepository(folderId);\n\n\t\tFolder folder = localRepository.updateFolder(\n\t\t\tfolderId, parentFolderId, name, description, serviceContext);\n\n\t\tif (folder != null) {\n\t\t\tdlAppHelperLocalService.updateFolder(\n\t\t\t\tserviceContext.getUserId(), folder, serviceContext);\n\t\t}\n\n\t\treturn folder;\n\t}","commit_id":"824f25f027048dc6e188ddd075127b9a87d92299","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tif (PortalSessionThreadLocal.getHttpSession() == null) {\n\t\t\t\tPortalSessionThreadLocal.setHttpSession(session);\n\t\t\t}\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\tString path = HttpUtil.fixPath(request.getPathInfo());\n\t\t\tString[] pathArray = StringUtil.split(path, CharPool.SLASH);\n\n\t\t\tif (pathArray[0].equals(\"image\")) {\n\t\t\t\tlong imageId = GetterUtil.getLong(pathArray[1]);\n\n\t\t\t\tsendImage(response, imageId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong groupId = GetterUtil.getLong(pathArray[0]);\n\t\t\t\tString uuid = pathArray[1];\n\n\t\t\t\tboolean patch = ParamUtil.getBoolean(request, \"patch\");\n\n\t\t\t\tif (patch) {\n\t\t\t\t\tsendPatch(request, response, user, groupId, uuid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsendFile(request, response, groupId, uuid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\tPortalUtil.sendError(\n\t\t\t\tHttpServletResponse.SC_NOT_FOUND, nsfee, request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\t\t}\n\t}","id":41688,"modified_method":"@Override\n\tpublic void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tif (PortalSessionThreadLocal.getHttpSession() == null) {\n\t\t\t\tPortalSessionThreadLocal.setHttpSession(session);\n\t\t\t}\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\tString path = HttpUtil.fixPath(request.getPathInfo());\n\t\t\tString[] pathArray = StringUtil.split(path, CharPool.SLASH);\n\n\t\t\tif (pathArray[0].equals(\"image\")) {\n\t\t\t\tlong imageId = GetterUtil.getLong(pathArray[1]);\n\n\t\t\t\tsendImage(response, imageId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong groupId = GetterUtil.getLong(pathArray[0]);\n\t\t\t\tString uuid = pathArray[1];\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\t\t\tif ((group == null) || !SyncUtil.isSyncEnabled(group)) {\n\t\t\t\t\tresponse.setHeader(\n\t\t\t\t\t\t_ERROR_HEADER,\n\t\t\t\t\t\tSyncSiteUnavailableException.class.getName());\n\n\t\t\t\t\tServletResponseUtil.write(response, new byte[0]);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tboolean patch = ParamUtil.getBoolean(request, \"patch\");\n\n\t\t\t\tif (patch) {\n\t\t\t\t\tsendPatch(request, response, user, groupId, uuid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsendFile(request, response, groupId, uuid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\tPortalUtil.sendError(\n\t\t\t\tHttpServletResponse.SC_NOT_FOUND, nsfee, request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject getFolderSyncDLObject(\n\t\t\tlong repositoryId, long parentFolderId, String name)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppService.getFolder(\n\t\t\t\trepositoryId, parentFolderId, name);\n\n\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41689,"modified_method":"@Override\n\tpublic SyncDLObject getFolderSyncDLObject(\n\t\t\tlong repositoryId, long parentFolderId, String name)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tFolder folder = dlAppService.getFolder(\n\t\t\t\trepositoryId, parentFolderId, name);\n\n\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject cancelCheckOut(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tdlAppService.cancelCheckOut(fileEntryId);\n\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(\n\t\t\t\tfileEntry, SyncConstants.EVENT_CANCEL_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41690,"modified_method":"@Override\n\tpublic SyncDLObject cancelCheckOut(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tdlAppService.cancelCheckOut(fileEntryId);\n\n\t\t\tfileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(\n\t\t\t\tfileEntry, SyncConstants.EVENT_CANCEL_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<SyncDLObject> getFileEntrySyncDLObjects(\n\t\t\tlong repositoryId, long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tList<FileEntry> fileEntries = dlAppService.getFileEntries(\n\t\t\t\trepositoryId, folderId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>(\n\t\t\t\tfileEntries.size());\n\n\t\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\t\tSyncDLObject syncDLObject = toSyncDLObject(\n\t\t\t\t\tfileEntry, SyncConstants.EVENT_GET);\n\n\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t}\n\n\t\t\treturn syncDLObjects;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41691,"modified_method":"@Override\n\tpublic List<SyncDLObject> getFileEntrySyncDLObjects(\n\t\t\tlong repositoryId, long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tList<FileEntry> fileEntries = dlAppService.getFileEntries(\n\t\t\t\trepositoryId, folderId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>(\n\t\t\t\tfileEntries.size());\n\n\t\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\t\tSyncDLObject syncDLObject = toSyncDLObject(\n\t\t\t\t\tfileEntry, SyncConstants.EVENT_GET);\n\n\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t}\n\n\t\t\treturn syncDLObjects;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<SyncDLObject> getFolderSyncDLObjects(\n\t\t\tlong repositoryId, long parentFolderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tList<Folder> folders = dlAppService.getFolders(\n\t\t\t\trepositoryId, parentFolderId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>(\n\t\t\t\tfolders.size());\n\n\t\t\tfor (Folder folder : folders) {\n\t\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSyncDLObject syncDLObject = toSyncDLObject(\n\t\t\t\t\tfolder, SyncConstants.EVENT_GET);\n\n\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t}\n\n\t\t\treturn syncDLObjects;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41692,"modified_method":"@Override\n\tpublic List<SyncDLObject> getFolderSyncDLObjects(\n\t\t\tlong repositoryId, long parentFolderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tList<Folder> folders = dlAppService.getFolders(\n\t\t\t\trepositoryId, parentFolderId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>(\n\t\t\t\tfolders.size());\n\n\t\t\tfor (Folder folder : folders) {\n\t\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSyncDLObject syncDLObject = toSyncDLObject(\n\t\t\t\t\tfolder, SyncConstants.EVENT_GET);\n\n\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t}\n\n\t\t\treturn syncDLObjects;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<Group> getUserSitesGroups() throws PortalException {\n\t\ttry {\n\t\t\tUser user = getUser();\n\n\t\t\tList<Group> groups = new ArrayList<Group>();\n\n\t\t\tLinkedHashMap<String, Object> groupParams =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tgroupParams.put(\"active\", true);\n\t\t\tgroupParams.put(\"usersGroups\", user.getUserId());\n\n\t\t\tList<Group> userSiteGroups = groupLocalService.search(\n\t\t\t\tuser.getCompanyId(), null, groupParams, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS);\n\n\t\t\tfor (Group userSiteGroup : userSiteGroups) {\n\t\t\t\tif (isSyncEnabled(userSiteGroup)) {\n\t\t\t\t\tif (userSiteGroup.isGuest()) {\n\t\t\t\t\t\tuserSiteGroup.setName(\n\t\t\t\t\t\t\tuserSiteGroup.getDescriptiveName());\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups.add(userSiteGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Organization> organizations =\n\t\t\t\torganizationLocalService.getOrganizations(\n\t\t\t\t\tuser.getUserId(), QueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\tnull);\n\n\t\t\tfor (Organization organization : organizations) {\n\t\t\t\tGroup userOrganizationGroup = organization.getGroup();\n\n\t\t\t\tif (isSyncEnabled(userOrganizationGroup)) {\n\t\t\t\t\tgroups.add(userOrganizationGroup);\n\t\t\t\t}\n\n\t\t\t\tif (!GetterUtil.getBoolean(\n\t\t\t\t\t\tPropsUtil.get(\n\t\t\t\t\t\t\tPropsKeys.ORGANIZATIONS_MEMBERSHIP_STRICT))) {\n\n\t\t\t\t\tfor (Organization ancestorOrganization :\n\t\t\t\t\t\t\torganization.getAncestors()) {\n\n\t\t\t\t\t\tGroup userAncestorOrganizationGroup =\n\t\t\t\t\t\t\tancestorOrganization.getGroup();\n\n\t\t\t\t\t\tif (isSyncEnabled(userAncestorOrganizationGroup)) {\n\t\t\t\t\t\t\tgroups.add(userAncestorOrganizationGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroups.add(user.getGroup());\n\n\t\t\tCollections.sort(groups, new GroupNameComparator());\n\n\t\t\treturn ListUtil.unique(groups);\n\t\t}\n\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(pe.getClass().getName(), pe);\n\t\t}\n\t}","id":41693,"modified_method":"@Override\n\tpublic List<Group> getUserSitesGroups() throws PortalException {\n\t\ttry {\n\t\t\tUser user = getUser();\n\n\t\t\tList<Group> groups = new ArrayList<Group>();\n\n\t\t\tLinkedHashMap<String, Object> groupParams =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tgroupParams.put(\"active\", true);\n\t\t\tgroupParams.put(\"usersGroups\", user.getUserId());\n\n\t\t\tList<Group> userSiteGroups = groupLocalService.search(\n\t\t\t\tuser.getCompanyId(), null, groupParams, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS);\n\n\t\t\tfor (Group userSiteGroup : userSiteGroups) {\n\t\t\t\tif (SyncUtil.isSyncEnabled(userSiteGroup)) {\n\t\t\t\t\tif (userSiteGroup.isGuest()) {\n\t\t\t\t\t\tuserSiteGroup.setName(\n\t\t\t\t\t\t\tuserSiteGroup.getDescriptiveName());\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups.add(userSiteGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Organization> organizations =\n\t\t\t\torganizationLocalService.getOrganizations(\n\t\t\t\t\tuser.getUserId(), QueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\tnull);\n\n\t\t\tfor (Organization organization : organizations) {\n\t\t\t\tGroup userOrganizationGroup = organization.getGroup();\n\n\t\t\t\tif (SyncUtil.isSyncEnabled(userOrganizationGroup)) {\n\t\t\t\t\tgroups.add(userOrganizationGroup);\n\t\t\t\t}\n\n\t\t\t\tif (!GetterUtil.getBoolean(\n\t\t\t\t\t\tPropsUtil.get(\n\t\t\t\t\t\t\tPropsKeys.ORGANIZATIONS_MEMBERSHIP_STRICT))) {\n\n\t\t\t\t\tfor (Organization ancestorOrganization :\n\t\t\t\t\t\t\torganization.getAncestors()) {\n\n\t\t\t\t\t\tGroup userAncestorOrganizationGroup =\n\t\t\t\t\t\t\tancestorOrganization.getGroup();\n\n\t\t\t\t\t\tif (SyncUtil.isSyncEnabled(\n\t\t\t\t\t\t\t\tuserAncestorOrganizationGroup)) {\n\n\t\t\t\t\t\t\tgroups.add(userAncestorOrganizationGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroups.add(user.getGroup());\n\n\t\t\tCollections.sort(groups, new GroupNameComparator());\n\n\t\t\treturn ListUtil.unique(groups);\n\t\t}\n\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(pe.getClass().getName(), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long parentFolderId,\n\t\t\tlong lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>();\n\n\t\t\tif (parentFolderId > 0) {\n\t\t\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\t\t\tif (permissionChecker.hasPermission(\n\t\t\t\t\t\trepositoryId, DLFolderConstants.getClassName(),\n\t\t\t\t\t\tparentFolderId, ActionKeys.VIEW)) {\n\n\t\t\t\t\tSyncDLObject syncDLObject =\n\t\t\t\t\t\tsyncDLObjectPersistence.fetchByT_T(\n\t\t\t\t\t\t\tSyncConstants.TYPE_FOLDER, parentFolderId);\n\n\t\t\t\t\tif (syncDLObject != null) {\n\t\t\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyncDLObjects = getSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId, parentFolderId,\n\t\t\t\tlastAccessTime);\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41694,"modified_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long parentFolderId,\n\t\t\tlong lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects = new ArrayList<SyncDLObject>();\n\n\t\t\tif (parentFolderId > 0) {\n\t\t\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\t\t\tif (permissionChecker.hasPermission(\n\t\t\t\t\t\trepositoryId, DLFolderConstants.getClassName(),\n\t\t\t\t\t\tparentFolderId, ActionKeys.VIEW)) {\n\n\t\t\t\t\tSyncDLObject syncDLObject =\n\t\t\t\t\t\tsyncDLObjectPersistence.fetchByT_T(\n\t\t\t\t\t\t\tSyncConstants.TYPE_FOLDER, parentFolderId);\n\n\t\t\t\t\tif (syncDLObject != null) {\n\t\t\t\t\t\tsyncDLObjects.add(syncDLObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyncDLObjects = getSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId, parentFolderId,\n\t\t\t\tlastAccessTime);\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic Group getGroup(long groupId) throws PortalException {\n\t\ttry {\n\t\t\treturn groupService.getGroup(groupId);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41695,"modified_method":"@Override\n\tpublic Group getGroup(long groupId) throws PortalException {\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(groupId);\n\n\t\t\treturn groupService.getGroup(groupId);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject checkInFileEntry(\n\t\t\tlong fileEntryId, boolean majorVersion, String changeLog,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tdlAppService.checkInFileEntry(\n\t\t\t\tfileEntryId, majorVersion, changeLog, serviceContext);\n\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_IN);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41696,"modified_method":"@Override\n\tpublic SyncDLObject checkInFileEntry(\n\t\t\tlong fileEntryId, boolean majorVersion, String changeLog,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tdlAppService.checkInFileEntry(\n\t\t\t\tfileEntryId, majorVersion, changeLog, serviceContext);\n\n\t\t\tfileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_IN);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject moveFileEntry(\n\t\t\tlong fileEntryId, long newFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntryId, newFolderId, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_MOVE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41697,"modified_method":"@Override\n\tpublic SyncDLObject moveFileEntry(\n\t\t\tlong fileEntryId, long newFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tfileEntry = dlAppService.moveFileEntry(\n\t\t\t\tfileEntryId, newFolderId, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_MOVE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject checkOutFileEntry(\n\t\t\tlong fileEntryId, String owner, long expirationTime,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppService.checkOutFileEntry(\n\t\t\t\tfileEntryId, owner, expirationTime, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41698,"modified_method":"@Override\n\tpublic SyncDLObject checkOutFileEntry(\n\t\t\tlong fileEntryId, String owner, long expirationTime,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tfileEntry = dlAppService.checkOutFileEntry(\n\t\t\t\tfileEntryId, owner, expirationTime, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject checkOutFileEntry(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tdlAppService.checkOutFileEntry(fileEntryId, serviceContext);\n\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41699,"modified_method":"@Override\n\tpublic SyncDLObject checkOutFileEntry(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tdlAppService.checkOutFileEntry(fileEntryId, serviceContext);\n\n\t\t\tfileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_CHECK_OUT);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject moveFolderToTrash(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tif (TrashUtil.isInTrash(\n\t\t\t\t\tDLFolderConstants.getClassName(), folderId)) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tFolder folder = dlAppService.moveFolderToTrash(folderId);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_TRASH);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41700,"modified_method":"@Override\n\tpublic SyncDLObject moveFolderToTrash(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\tSyncUtil.checkSyncEnabled(folder.getGroupId());\n\n\t\t\tif (TrashUtil.isInTrash(\n\t\t\t\t\tDLFolderConstants.getClassName(), folderId)) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfolder = dlAppService.moveFolderToTrash(folderId);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_TRASH);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.filterFindByC_M_R_P(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, -1);\n\n\t\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\t\tif (syncDLObject.getModifiedTime() > lastAccessTime) {\n\t\t\t\t\tlastAccessTime = syncDLObject.getModifiedTime();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41701,"modified_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.filterFindByC_M_R_P(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, -1);\n\n\t\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\t\tif (syncDLObject.getModifiedTime() > lastAccessTime) {\n\t\t\t\t\tlastAccessTime = syncDLObject.getModifiedTime();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject addFolder(\n\t\t\tlong repositoryId, long parentFolderId, String name,\n\t\t\tString description, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppService.addFolder(\n\t\t\t\trepositoryId, parentFolderId, name, description,\n\t\t\t\tserviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_ADD);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (pe instanceof DuplicateFolderNameException) {\n\t\t\t\tif (GetterUtil.getBoolean(\n\t\t\t\t\t\tserviceContext.getAttribute(\"overwrite\"))) {\n\n\t\t\t\t\tFolder folder = dlAppService.getFolder(\n\t\t\t\t\t\trepositoryId, parentFolderId, name);\n\n\t\t\t\t\tfolder = dlAppService.updateFolder(\n\t\t\t\t\t\tfolder.getFolderId(), name, description,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_UPDATE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41702,"modified_method":"@Override\n\tpublic SyncDLObject addFolder(\n\t\t\tlong repositoryId, long parentFolderId, String name,\n\t\t\tString description, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tFolder folder = dlAppService.addFolder(\n\t\t\t\trepositoryId, parentFolderId, name, description,\n\t\t\t\tserviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_ADD);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (pe instanceof DuplicateFolderNameException) {\n\t\t\t\tif (GetterUtil.getBoolean(\n\t\t\t\t\t\tserviceContext.getAttribute(\"overwrite\"))) {\n\n\t\t\t\t\tFolder folder = dlAppService.getFolder(\n\t\t\t\t\t\trepositoryId, parentFolderId, name);\n\n\t\t\t\t\tfolder = dlAppService.updateFolder(\n\t\t\t\t\t\tfolder.getFolderId(), name, description,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_UPDATE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject moveFileEntryToTrash(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tif (TrashUtil.isInTrash(\n\t\t\t\t\tDLFileEntryConstants.getClassName(), fileEntryId)) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tFileEntry fileEntry = dlAppService.moveFileEntryToTrash(\n\t\t\t\tfileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_TRASH);\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41703,"modified_method":"@Override\n\tpublic SyncDLObject moveFileEntryToTrash(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tif (TrashUtil.isInTrash(\n\t\t\t\t\tDLFileEntryConstants.getClassName(), fileEntryId)) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfileEntry = dlAppService.moveFileEntryToTrash(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_TRASH);\n\t\t}\n\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\treturn syncDLObjectFinder.filterFindByC_R(companyId, repositoryId);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41704,"modified_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\treturn syncDLObjectFinder.filterFindByC_R(companyId, repositoryId);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject restoreFolderFromTrash(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tdlAppService.restoreFolderFromTrash(folderId);\n\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_RESTORE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41705,"modified_method":"@Override\n\tpublic SyncDLObject restoreFolderFromTrash(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\tSyncUtil.checkSyncEnabled(folder.getGroupId());\n\n\t\t\tdlAppService.restoreFolderFromTrash(folderId);\n\n\t\t\tfolder = dlAppLocalService.getFolder(folderId);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_RESTORE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject getFileEntrySyncDLObject(\n\t\t\tlong groupId, long folderId, String title)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppService.getFileEntry(\n\t\t\t\tgroupId, folderId, title);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41706,"modified_method":"@Override\n\tpublic SyncDLObject getFileEntrySyncDLObject(\n\t\t\tlong groupId, long folderId, String title)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(groupId);\n\n\t\t\tFileEntry fileEntry = dlAppService.getFileEntry(\n\t\t\t\tgroupId, folderId, title);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject moveFolder(\n\t\t\tlong folderId, long parentFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppService.moveFolder(\n\t\t\t\tfolderId, parentFolderId, serviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_MOVE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41707,"modified_method":"@Override\n\tpublic SyncDLObject moveFolder(\n\t\t\tlong folderId, long parentFolderId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\tSyncUtil.checkSyncEnabled(folder.getGroupId());\n\n\t\t\tfolder = dlAppService.moveFolder(\n\t\t\t\tfolderId, parentFolderId, serviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_MOVE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject updateFileEntry(\n\t\t\tlong fileEntryId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, String checksum,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppService.updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, mimeType, title, description,\n\t\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_UPDATE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41708,"modified_method":"@Override\n\tpublic SyncDLObject updateFileEntry(\n\t\t\tlong fileEntryId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, String checksum,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tfileEntry = dlAppService.updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, mimeType, title, description,\n\t\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_UPDATE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject patchFileEntry(\n\t\t\tlong fileEntryId, String sourceVersion, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File deltaFile, String checksum,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFile patchedFile = null;\n\n\t\ttry {\n\t\t\tFile sourceFile = dlFileEntryLocalService.getFile(\n\t\t\t\tgetUserId(), fileEntryId, sourceVersion, false);\n\n\t\t\tpatchedFile = FileUtil.createTempFile();\n\n\t\t\tSyncUtil.patchFile(sourceFile, deltaFile, patchedFile);\n\n\t\t\tSyncDLObject syncDLObject = updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, mimeType, title, description,\n\t\t\t\tchangeLog, majorVersion, patchedFile, checksum, serviceContext);\n\n\t\t\tif (PortletPropsValues.SYNC_FILE_DIFF_CACHE_ENABLED) {\n\t\t\t\tDLFileVersion sourceDLFileVersion =\n\t\t\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\t\t\tfileEntryId, sourceVersion);\n\t\t\t\tDLFileVersion targetDLFileVersion =\n\t\t\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\t\t\tfileEntryId, syncDLObject.getVersion());\n\n\t\t\t\tsyncDLFileVersionDiffLocalService.addSyncDLFileVersionDiff(\n\t\t\t\t\tfileEntryId, sourceDLFileVersion.getFileVersionId(),\n\t\t\t\t\ttargetDLFileVersion.getFileVersionId(), deltaFile);\n\t\t\t}\n\n\t\t\treturn syncDLObject;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(patchedFile);\n\t\t}\n\t}","id":41709,"modified_method":"@Override\n\tpublic SyncDLObject patchFileEntry(\n\t\t\tlong fileEntryId, String sourceVersion, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File deltaFile, String checksum,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFile patchedFile = null;\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tFile sourceFile = dlFileEntryLocalService.getFile(\n\t\t\t\tgetUserId(), fileEntryId, sourceVersion, false);\n\n\t\t\tpatchedFile = FileUtil.createTempFile();\n\n\t\t\tSyncUtil.patchFile(sourceFile, deltaFile, patchedFile);\n\n\t\t\tSyncDLObject syncDLObject = updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, mimeType, title, description,\n\t\t\t\tchangeLog, majorVersion, patchedFile, checksum, serviceContext);\n\n\t\t\tif (PortletPropsValues.SYNC_FILE_DIFF_CACHE_ENABLED) {\n\t\t\t\tDLFileVersion sourceDLFileVersion =\n\t\t\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\t\t\tfileEntryId, sourceVersion);\n\t\t\t\tDLFileVersion targetDLFileVersion =\n\t\t\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\t\t\tfileEntryId, syncDLObject.getVersion());\n\n\t\t\t\tsyncDLFileVersionDiffLocalService.addSyncDLFileVersionDiff(\n\t\t\t\t\tfileEntryId, sourceDLFileVersion.getFileVersionId(),\n\t\t\t\t\ttargetDLFileVersion.getFileVersionId(), deltaFile);\n\t\t\t}\n\n\t\t\treturn syncDLObject;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(patchedFile);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n\t * @deprecated As of 7.0.0, with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic SyncDLObjectUpdate getAllSyncDLObjects(\n\t\t\tlong repositoryId, long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tlong lastAccessTime = System.currentTimeMillis();\n\n\t\t\tlong companyId = 0;\n\n\t\t\tRepository repository = repositoryLocalService.fetchRepository(\n\t\t\t\trepositoryId);\n\n\t\t\tif (repository != null) {\n\t\t\t\tcompanyId = repository.getCompanyId();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGroup group = groupLocalService.getGroup(repositoryId);\n\n\t\t\t\tcompanyId = group.getCompanyId();\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_M_R(companyId, 0, repositoryId);\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41710,"modified_method":"/**\n\t * @deprecated As of 7.0.0, with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic SyncDLObjectUpdate getAllSyncDLObjects(\n\t\t\tlong repositoryId, long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tlong lastAccessTime = System.currentTimeMillis();\n\n\t\t\tlong companyId = 0;\n\n\t\t\tRepository repository = repositoryLocalService.fetchRepository(\n\t\t\t\trepositoryId);\n\n\t\t\tif (repository != null) {\n\t\t\t\tcompanyId = repository.getCompanyId();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGroup group = groupLocalService.getGroup(repositoryId);\n\n\t\t\t\tcompanyId = group.getCompanyId();\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_M_R(companyId, 0, repositoryId);\n\n\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject restoreFileEntryFromTrash(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tdlAppService.restoreFileEntryFromTrash(fileEntryId);\n\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_RESTORE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41711,"modified_method":"@Override\n\tpublic SyncDLObject restoreFileEntryFromTrash(long fileEntryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\tSyncUtil.checkSyncEnabled(fileEntry.getGroupId());\n\n\t\t\tdlAppService.restoreFileEntryFromTrash(fileEntryId);\n\n\t\t\tfileEntry = dlAppLocalService.getFileEntry(fileEntryId);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_RESTORE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject addFileEntry(\n\t\t\tlong repositoryId, long folderId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tFile file, String checksum, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFileEntry fileEntry = dlAppService.addFileEntry(\n\t\t\t\trepositoryId, folderId, sourceFileName, mimeType, title,\n\t\t\t\tdescription, changeLog, file, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_ADD);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (pe instanceof DuplicateFileException) {\n\t\t\t\tif (GetterUtil.getBoolean(\n\t\t\t\t\t\tserviceContext.getAttribute(\"overwrite\"))) {\n\n\t\t\t\t\tFileEntry fileEntry = dlAppService.getFileEntry(\n\t\t\t\t\t\trepositoryId, folderId, title);\n\n\t\t\t\t\tfileEntry = dlAppService.updateFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId(), sourceFileName, mimeType,\n\t\t\t\t\t\ttitle, description, changeLog, false, file,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\treturn toSyncDLObject(\n\t\t\t\t\t\tfileEntry, SyncConstants.EVENT_UPDATE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41712,"modified_method":"@Override\n\tpublic SyncDLObject addFileEntry(\n\t\t\tlong repositoryId, long folderId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tFile file, String checksum, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\tFileEntry fileEntry = dlAppService.addFileEntry(\n\t\t\t\trepositoryId, folderId, sourceFileName, mimeType, title,\n\t\t\t\tdescription, changeLog, file, serviceContext);\n\n\t\t\treturn toSyncDLObject(fileEntry, SyncConstants.EVENT_ADD);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (pe instanceof DuplicateFileException) {\n\t\t\t\tif (GetterUtil.getBoolean(\n\t\t\t\t\t\tserviceContext.getAttribute(\"overwrite\"))) {\n\n\t\t\t\t\tFileEntry fileEntry = dlAppService.getFileEntry(\n\t\t\t\t\t\trepositoryId, folderId, title);\n\n\t\t\t\t\tfileEntry = dlAppService.updateFileEntry(\n\t\t\t\t\t\tfileEntry.getFileEntryId(), sourceFileName, mimeType,\n\t\t\t\t\t\ttitle, description, changeLog, false, file,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\treturn toSyncDLObject(\n\t\t\t\t\t\tfileEntry, SyncConstants.EVENT_UPDATE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject updateFolder(\n\t\t\tlong folderId, String name, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppService.updateFolder(\n\t\t\t\tfolderId, name, description, serviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_UPDATE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41713,"modified_method":"@Override\n\tpublic SyncDLObject updateFolder(\n\t\t\tlong folderId, String name, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\tSyncUtil.checkSyncEnabled(folder.getGroupId());\n\n\t\t\tfolder = dlAppService.updateFolder(\n\t\t\t\tfolderId, name, description, serviceContext);\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_UPDATE);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObject getFolderSyncDLObject(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppService.getFolder(folderId);\n\n\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":41714,"modified_method":"@Override\n\tpublic SyncDLObject getFolderSyncDLObject(long folderId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tFolder folder = dlAppLocalService.getFolder(folderId);\n\n\t\t\tSyncUtil.checkSyncEnabled(folder.getGroupId());\n\n\t\t\tfolder = dlAppService.getFolder(folderId);\n\n\t\t\tif (!SyncUtil.isSupportedFolder(folder)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn toSyncDLObject(folder, SyncConstants.EVENT_GET);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"792c0f553afd36ccf5f8f3645524d1a302b71bb8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n\t * Does its best at determining the default value for the given key. Checks\n\t * the given object's type and then looks in the list of defaults to see if\n\t * a value exists. If not or if there is a problem converting the value, the\n\t * default default value for that type is returned.\n\t * \n\t * @param key\n\t *            the key to search\n\t * @param obj\n\t *            the object who default we are looking for\n\t * @return Object or <code>null<\/code>\n\t */\n\tObject getDefault(String key, Object obj) {\n\t\tIEclipsePreferences defaults = getDefaultPreferences();\n\t\tif (obj instanceof String) {\n\t\t\treturn defaults.get(key, STRING_DEFAULT_DEFAULT);\n\t\t} else if (obj instanceof Integer) {\n\t\t\treturn new Integer(defaults.getInt(key, INT_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Double) {\n\t\t\treturn new Double(defaults.getDouble(key, DOUBLE_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Float) {\n\t\t\treturn new Float(defaults.getFloat(key, FLOAT_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Long) {\n\t\t\treturn new Long(defaults.getLong(key, LONG_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Boolean) {\n\t\t\treturn defaults.getBoolean(key, BOOLEAN_DEFAULT_DEFAULT) ? Boolean.TRUE\n\t\t\t\t\t: Boolean.FALSE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":41715,"modified_method":"/**\n\t * Does its best at determining the default value for the given key. Checks\n\t * the given object's type and then looks in the list of defaults to see if\n\t * a value exists. If not or if there is a problem converting the value, the\n\t * default default value for that type is returned.\n\t * \n\t * @param key\n\t *            the key to search\n\t * @param obj\n\t *            the object who default we are looking for\n\t * @return Object or <code>null<\/code>\n\t */\n\tObject getDefault(String key, Object obj) {\n\t\tIEclipsePreferences defaults = getDefaultPreferences();\n\t\tif (obj instanceof String) {\n\t\t\treturn defaults.get(key, STRING_DEFAULT_DEFAULT);\n\t\t} else if (obj instanceof Integer) {\n\t\t\treturn Integer.valueOf(defaults.getInt(key, INT_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Double) {\n\t\t\treturn Double.valueOf(defaults.getDouble(key, DOUBLE_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Float) {\n\t\t\treturn Float.valueOf(defaults.getFloat(key, FLOAT_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Long) {\n\t\t\treturn Long.valueOf(defaults.getLong(key, LONG_DEFAULT_DEFAULT));\n\t\t} else if (obj instanceof Boolean) {\n\t\t\treturn defaults.getBoolean(key, BOOLEAN_DEFAULT_DEFAULT) ? Boolean.TRUE : Boolean.FALSE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"0bd87f337aab9532aa9e63815c3d365171f9e91f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Paint calcGradientPaint(Gradient gradient) {\n            if (gradient instanceof LinearGradient) {\n                LinearGradient grad = (LinearGradient) gradient;\n                \n                /*\n                Color c1 = new Color(0xFF000000 | grad.color[0]);\n                Color c2 = new Color(0xFF000000 | grad.color[grad.count-1]);\n                return new GradientPaint(grad.x1, grad.y1, c1,\n                                         grad.x2, grad.y2, c2);\n                                         */\n                return new LinearGradientPaint(grad.x1, grad.y1, grad.x2, grad.y2,\n                                               grad.offset, grad.color, grad.count);\n                \n                    \n            } else if (gradient instanceof RadialGradient) {\n                RadialGradient grad = (RadialGradient) gradient;\n                \n                //Color c1 = new Color(0xFF000000 | grad.color[0]);\n                //Color c2 = new Color(0xFF000000 | grad.color[grad.count-1]);\n                return new RadialGradientPaint(grad.cx, grad.cy, grad.r, \n                                               grad.offset, grad.color, grad.count);\n            }\n            return null;\n        }","id":41716,"modified_method":"protected Paint calcGradientPaint(Gradient gradient) { //, float opacity) {\n            if (gradient instanceof LinearGradient) {\n                LinearGradient grad = (LinearGradient) gradient;\n                \n                /*\n                Color c1 = new Color(0xFF000000 | grad.color[0]);\n                Color c2 = new Color(0xFF000000 | grad.color[grad.count-1]);\n                return new GradientPaint(grad.x1, grad.y1, c1,\n                                         grad.x2, grad.y2, c2);\n                                         */\n                return new LinearGradientPaint(grad.x1, grad.y1, grad.x2, grad.y2,\n                                               grad.offset, grad.color, grad.count,\n                                               opacity);\n                \n                    \n            } else if (gradient instanceof RadialGradient) {\n                RadialGradient grad = (RadialGradient) gradient;\n                \n                //Color c1 = new Color(0xFF000000 | grad.color[0]);\n                //Color c2 = new Color(0xFF000000 | grad.color[grad.count-1]);\n                return new RadialGradientPaint(grad.cx, grad.cy, grad.r, \n                                               grad.offset, grad.color, grad.count, \n                                               opacity);\n            }\n            return null;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public Gradient(XMLElement properties) {\n            super(properties);\n            \n            XMLElement elements[] = properties.getChildren();\n            offset = new float[elements.length];\n            color = new int[elements.length];\n            \n            // <stop  offset=\"0\" style=\"stop-color:#967348\"/>\n            for (int i = 0; i < elements.length; i++){\n                XMLElement element = elements[i];\n                String name = element.getName();\n                if (name.equals(\"stop\")) {\n                    offset[count] = element.getFloatAttribute(\"offset\");\n                    String farbe = element.getStringAttribute(\"style\");\n                    int idx = farbe.indexOf(\"#\");\n                    if (idx != -1) {\n                        color[count] = Integer.parseInt(farbe.substring(idx+1), 16);\n                        count++;\n                    } else {\n                        System.err.println(\"problem with gradient stop \" + properties);\n                    }\n                }\n            }\n        }","id":41717,"modified_method":"public Gradient(XMLElement properties) {\n            super(properties);\n            \n            XMLElement elements[] = properties.getChildren();\n            offset = new float[elements.length];\n            color = new int[elements.length];\n            \n            // <stop  offset=\"0\" style=\"stop-color:#967348\"/>\n            for (int i = 0; i < elements.length; i++){\n                XMLElement elem = elements[i];\n                String name = elem.getName();\n                if (name.equals(\"stop\")) {\n                    offset[count] = elem.getFloatAttribute(\"offset\");\n                    String style = elem.getStringAttribute(\"style\");\n                    Hashtable styles = parseStyleAttributes(style);\n                    \n                    String colorStr = (String) styles.get(\"stop-color\");\n                    if (colorStr == null) colorStr = \"#000000\";\n                    String opacityStr = (String) styles.get(\"stop-opacity\");\n                    if (opacityStr == null) opacityStr = \"1\";\n                    int tupacity = (int) (PApplet.parseFloat(opacityStr) * 255);\n                    color[count] = (tupacity << 24) | \n                        Integer.parseInt(colorStr.substring(1), 16);\n                    count++;\n                    //System.out.println(\"this color is \" + PApplet.hex(color[count]));\n                    /*\n                    int idx = farbe.indexOf(\"#\");\n                    if (idx != -1) {\n                        color[count] = Integer.parseInt(farbe.substring(idx+1), 16);\n                        count++;\n                    } else {\n                        System.err.println(\"problem with gradient stop \" + properties);\n                    }\n                    */\n                }\n            }\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public PaintContext createContext(ColorModel cm,\n                                          Rectangle deviceBounds, Rectangle2D userBounds,\n                                          AffineTransform xform, RenderingHints hints) {\n            Point2D t1 = xform.transform(new Point2D.Float(x1, y1), null);\n            Point2D t2 = xform.transform(new Point2D.Float(x2, y2), null);\n            return new LinearGradientContext((float) t1.getX(), (float) t1.getY(), \n                                             (float) t2.getX(), (float) t2.getY(), \n                                             offset, color, count);\n        }","id":41718,"modified_method":"public PaintContext createContext(ColorModel cm,\n                                          Rectangle deviceBounds, Rectangle2D userBounds,\n                                          AffineTransform xform, RenderingHints hints) {\n            Point2D t1 = xform.transform(new Point2D.Float(x1, y1), null);\n            Point2D t2 = xform.transform(new Point2D.Float(x2, y2), null);\n            return new LinearGradientContext((float) t1.getX(), (float) t1.getY(), \n                                             (float) t2.getX(), (float) t2.getY(), \n                                             offset, color, count, opacity);\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public LinearGradientContext(float x1, float y1, float x2, float y2,\n                                     float[] offset, int[] color, int count) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n        }","id":41719,"modified_method":"public LinearGradientContext(float x1, float y1, float x2, float y2,\n                                     float[] offset, int[] color, int count,\n                                     float opacity) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n            this.opacity = opacity;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public RadialGradientContext(float cx, float cy, float radius, \n                                     float[] offset, int[] color, int count) {\n            this.cx = cx;\n            this.cy = cy;\n            this.radius = radius;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n        }","id":41720,"modified_method":"public RadialGradientContext(float cx, float cy, float radius, \n                                     float[] offset, int[] color, int count,\n                                     float opacity) {\n            this.cx = cx;\n            this.cy = cy;\n            this.radius = radius;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n            this.opacity = opacity;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"protected void getColors(XMLElement properties){\n            \n            // opacity for postscript-derived things like svg affects both stroke and fill\n            //if (properties.hasAttribute(\"opacity\")) {\n            opacity = properties.getFloatAttribute(\"opacity\", 1);\n            //}\n            int opacityMask = ((int) (opacity * 255)) << 24;\n            \n            String strokeText = properties.getStringAttribute(\"stroke\", \"none\");\n            if (strokeText.equals(\"none\")) {\n\n            } else if (strokeText.startsWith(\"#\")) {\n                stroke = true;\n                strokeColor = opacityMask |\n                    (Integer.parseInt(strokeText.substring(1), 16)) & 0xFFFFFF;\n            } else if (strokeText.startsWith(\"url(#\")) {\n                strokeName = strokeText.substring(5, strokeText.length() - 1);\n                Object strokeObject = idTable.get(strokeName);\n                if (strokeObject instanceof Gradient) {\n                    strokeGradient = (Gradient) strokeObject;\n                    strokeGradientPaint = calcGradientPaint(strokeGradient);\n                } else {\n                    System.err.println(\"url \" + strokeName + \" refers to unexpected data\");\n                }\n            }\n            \n            // fill defaults to black (though stroke defaults to \"none\")\n            // http://www.w3.org/TR/SVG/painting.html#FillProperties\n            String fillText = properties.getStringAttribute(\"fill\", \"#000000\");\n            if (fillText.equals(\"none\")) {\n\n            } else if (fillText.startsWith(\"#\")) {\n                fill = true;\n                fillColor = opacityMask |\n                    (Integer.parseInt(fillText.substring(1), 16)) & 0xFFFFFF;\n                //System.out.println(\"hex for fill is \" + PApplet.hex(fillColor));\n            } else if (fillText.startsWith(\"url(#\")) {\n                fillName = fillText.substring(5, fillText.length() - 1);\n                //PApplet.println(\"looking for \" + fillName);\n                Object fillObject = idTable.get(fillName);\n                //PApplet.println(\"found \" + fillObject);\n                if (fillObject instanceof Gradient) {\n                    fill = true;\n                    fillGradient = (Gradient) fillObject;\n                    fillGradientPaint = calcGradientPaint(fillGradient);\n                    //PApplet.println(\"got filla \" + fillObject);\n                } else {\n                    System.err.println(\"url \" + fillName + \" refers to unexpected data\");\n                }\n            }\n\n            //if (properties.hasAttribute(\"stroke-width\")){\n            //strokeWeight = properties.getFloatAttribute(\"stroke-width\");\n            //}\n            strokeWeight = properties.getFloatAttribute(\"stroke-width\", Float.NaN);\n        }","id":41721,"modified_method":"protected void getColors(XMLElement properties){\n            \n            // opacity for postscript-derived things like svg affects both stroke and fill\n            //if (properties.hasAttribute(\"opacity\")) {\n            opacity = properties.getFloatAttribute(\"opacity\", 1);\n            //}\n            int opacityMask = ((int) (opacity * 255)) << 24;\n            \n            String strokeText = properties.getStringAttribute(\"stroke\", \"none\");\n            if (strokeText.equals(\"none\")) {\n\n            } else if (strokeText.startsWith(\"#\")) {\n                stroke = true;\n                strokeColor = opacityMask |\n                    (Integer.parseInt(strokeText.substring(1), 16)) & 0xFFFFFF;\n            } else if (strokeText.startsWith(\"url(#\")) {\n                strokeName = strokeText.substring(5, strokeText.length() - 1);\n                Object strokeObject = table.get(strokeName);\n                if (strokeObject instanceof Gradient) {\n                    strokeGradient = (Gradient) strokeObject;\n                    strokeGradientPaint = calcGradientPaint(strokeGradient); //, opacity);\n                } else {\n                    System.err.println(\"url \" + strokeName + \" refers to unexpected data\");\n                }\n            }\n            \n            // fill defaults to black (though stroke defaults to \"none\")\n            // http://www.w3.org/TR/SVG/painting.html#FillProperties\n            String fillText = properties.getStringAttribute(\"fill\", \"#000000\");\n            if (fillText.equals(\"none\")) {\n\n            } else if (fillText.startsWith(\"#\")) {\n                fill = true;\n                fillColor = opacityMask |\n                    (Integer.parseInt(fillText.substring(1), 16)) & 0xFFFFFF;\n                //System.out.println(\"hex for fill is \" + PApplet.hex(fillColor));\n            } else if (fillText.startsWith(\"url(#\")) {\n                fillName = fillText.substring(5, fillText.length() - 1);\n                //PApplet.println(\"looking for \" + fillName);\n                Object fillObject = table.get(fillName);\n                //PApplet.println(\"found \" + fillObject);\n                if (fillObject instanceof Gradient) {\n                    fill = true;\n                    fillGradient = (Gradient) fillObject;\n                    fillGradientPaint = calcGradientPaint(fillGradient); //, opacity);\n                    //PApplet.println(\"got filla \" + fillObject);\n                } else {\n                    System.err.println(\"url \" + fillName + \" refers to unexpected data\");\n                }\n            }\n\n            //if (properties.hasAttribute(\"stroke-width\")){\n            //strokeWeight = properties.getFloatAttribute(\"stroke-width\");\n            //}\n            strokeWeight = properties.getFloatAttribute(\"stroke-width\", Float.NaN);\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public Group(XMLElement graphics) {\n            super(graphics);\n            \n            XMLElement elements[] = graphics.getChildren();\n            objects = new BaseObject[elements.length];\n            \n            for (int i = 0; i < elements.length; i++){\n                String name = elements[i].getName(); //getElement();\n                XMLElement element = elements[i];\n                \n                if (name.equals(\"g\")) {\n                    objects[objectCount++] = new Group(element);\n                    \n                } else if (name.equals(\"line\")) {\n                    objects[objectCount++] = new Line(element);\n                    \n                } else if (name.equals(\"circle\")) {\n                    objects[objectCount++] = new Circle(element);\n                    \n                } else if (name.equals(\"ellipse\")) {\n                    objects[objectCount++] = new Ellipse(element);\n                    \n                } else if (name.equals(\"rect\")) {\n                    objects[objectCount++] = new Rect(element);\n                    \n                } else if (name.equals(\"polygon\")) {\n                    objects[objectCount++] = new Poly(element, true);\n                    \n                } else if (name.equals(\"polyline\")) {\n                    objects[objectCount++] = new Poly(element, false);\n                    \n                } else if (name.equals(\"path\")) {\n                    objects[objectCount++] = new Path(element);\n                    \n                } else if (name.equals(\"radialGradient\")) {\n                    objects[objectCount++] = new RadialGradient(element);\n                    \n                } else if (name.equals(\"linearGradient\")) {\n                    objects[objectCount++] = new LinearGradient(element);                    \n                    \n                } else {\n                    PApplet.println(\"not handled \" + name);\n                }\n            }\n        }","id":41722,"modified_method":"public Group(XMLElement graphics) {\n            super(graphics);\n            \n            XMLElement elements[] = graphics.getChildren();\n            objects = new BaseObject[elements.length];\n            \n            for (int i = 0; i < elements.length; i++){\n                String name = elements[i].getName(); //getElement();\n                XMLElement elem = elements[i];\n                \n                if (name.equals(\"g\")) {\n                    objects[objectCount++] = new Group(elem);\n                    \n                } else if (name.equals(\"defs\")) {\n                    // generally this will contain gradient info, so may \n                    // as well just throw it into a group element for parsing\n                    objects[objectCount++] = new Group(elem);\n                    \n                } else if (name.equals(\"line\")) {\n                    objects[objectCount++] = new Line(elem);\n                    \n                } else if (name.equals(\"circle\")) {\n                    objects[objectCount++] = new Circle(elem);\n                    \n                } else if (name.equals(\"ellipse\")) {\n                    objects[objectCount++] = new Ellipse(elem);\n                    \n                } else if (name.equals(\"rect\")) {\n                    objects[objectCount++] = new Rect(elem);\n                    \n                } else if (name.equals(\"polygon\")) {\n                    objects[objectCount++] = new Poly(elem, true);\n                    \n                } else if (name.equals(\"polyline\")) {\n                    objects[objectCount++] = new Poly(elem, false);\n                    \n                } else if (name.equals(\"path\")) {\n                    objects[objectCount++] = new Path(elem);\n                    \n                } else if (name.equals(\"radialGradient\")) {\n                    objects[objectCount++] = new RadialGradient(elem);\n                    \n                } else if (name.equals(\"linearGradient\")) {\n                    objects[objectCount++] = new LinearGradient(elem);                    \n                    \n                } else {\n                    PApplet.println(\"not handled \" + name);\n                }\n            }\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public int getTransparency() {\n            /*\n            int a1 = mPointColor.getAlpha();\n            int a2 = mBackgroundColor.getAlpha();\n            return (((a1 & a2) == 0xff) ? OPAQUE : TRANSLUCENT);\n            */\n            return OPAQUE;\n        }","id":41723,"modified_method":"public int getTransparency() {\n            /*\n            int a1 = mPointColor.getAlpha();\n            int a2 = mBackgroundColor.getAlpha();\n            return (((a1 & a2) == 0xff) ? OPAQUE : TRANSLUCENT);\n            */\n            //return OPAQUE;\n            return TRANSLUCENT;  // why not.. rather than checking each color\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public Raster getRaster(int x, int y, int w, int h) {\n            WritableRaster raster =\n                getColorModel().createCompatibleWritableRaster(w, h);\n\n            // make normalized version of base vector\n            float nx = x2 - x1;\n            float ny = y2 - y1;\n            float len = (float) Math.sqrt(nx*nx + ny*ny);\n            if (len != 0) {\n                nx /= len;\n                ny /= len;\n            }\n            \n            int span = (int) PApplet.dist(x1, y1, x2, y2) * ACCURACY;\n            int[][] interp = new int[span][3];\n            int prev = 0;\n            for (int i = 1; i < count; i++) {\n                int c0 = color[i-1];\n                int c1 = color[i];\n                int last = (int) (offset[i] * (span-1));\n                //System.out.println(\"last is \" + last);\n                for (int j = prev; j <= last; j++) {\n                    float btwn = PApplet.norm(j, prev, last);\n                    interp[j][0] = (int) PApplet.lerp((c0 >> 16) & 0xff, (c1 >> 16) & 0xff, btwn);\n                    interp[j][1] = (int) PApplet.lerp((c0 >> 8) & 0xff, (c1 >> 8) & 0xff, btwn);\n                    interp[j][2] = (int) PApplet.lerp(c0 & 0xff, c1 & 0xff, btwn);\n                    //System.out.println(j + \" \" + interp[j][0] + \" \" + interp[j][1] + \" \" + interp[j][2]);\n                }\n                prev = last;\n            }\n\n            int[] data = new int[w * h * 4];\n            int index = 0;\n            for (int j = 0; j < h; j++) {\n                for (int i = 0; i < w; i++) {\n                    //float distance = 0; //PApplet.dist(cx, cy, x + i, y + j);\n                    //int which = PApplet.min((int) (distance * ACCURACY), interp.length-1);\n                    float px = (x + i) - x1;\n                    float py = (y + j) - y1;\n                    // distance up the line is the dot product of the normalized\n                    // vector of the gradient start/stop by the point being tested\n                    int which = (int) ((px*nx + py*ny) * ACCURACY);\n                    if (which < 0) which = 0;\n                    if (which > interp.length-1) which = interp.length-1; \n                    //if (which > 138) System.out.println(\"grabbing \" + which);\n                    \n                    data[index++] = interp[which][0];\n                    data[index++] = interp[which][1];\n                    data[index++] = interp[which][2];\n                    data[index++] = 255;\n                }\n            }\n            raster.setPixels(0, 0, w, h, data);\n\n            return raster;\n        }","id":41724,"modified_method":"public Raster getRaster(int x, int y, int w, int h) {\n            WritableRaster raster =\n                getColorModel().createCompatibleWritableRaster(w, h);\n\n            // make normalized version of base vector\n            float nx = x2 - x1;\n            float ny = y2 - y1;\n            float len = (float) Math.sqrt(nx*nx + ny*ny);\n            if (len != 0) {\n                nx /= len;\n                ny /= len;\n            }\n            \n            int span = (int) PApplet.dist(x1, y1, x2, y2) * ACCURACY;\n            int[][] interp = new int[span][4];\n            int prev = 0;\n            for (int i = 1; i < count; i++) {\n                int c0 = color[i-1];\n                int c1 = color[i];\n                int last = (int) (offset[i] * (span-1));\n                //System.out.println(\"last is \" + last);\n                for (int j = prev; j <= last; j++) {\n                    float btwn = PApplet.norm(j, prev, last);\n                    interp[j][0] = (int) PApplet.lerp((c0 >> 16) & 0xff, (c1 >> 16) & 0xff, btwn);\n                    interp[j][1] = (int) PApplet.lerp((c0 >> 8) & 0xff, (c1 >> 8) & 0xff, btwn);\n                    interp[j][2] = (int) PApplet.lerp(c0 & 0xff, c1 & 0xff, btwn);\n                    interp[j][3] = (int) (PApplet.lerp((c0 >> 24) & 0xff, (c1 >> 24) & 0xff, btwn) * opacity);\n                    //System.out.println(j + \" \" + interp[j][0] + \" \" + interp[j][1] + \" \" + interp[j][2]);\n                }\n                prev = last;\n            }\n\n            int[] data = new int[w * h * 4];\n            int index = 0;\n            for (int j = 0; j < h; j++) {\n                for (int i = 0; i < w; i++) {\n                    //float distance = 0; //PApplet.dist(cx, cy, x + i, y + j);\n                    //int which = PApplet.min((int) (distance * ACCURACY), interp.length-1);\n                    float px = (x + i) - x1;\n                    float py = (y + j) - y1;\n                    // distance up the line is the dot product of the normalized\n                    // vector of the gradient start/stop by the point being tested\n                    int which = (int) ((px*nx + py*ny) * ACCURACY);\n                    if (which < 0) which = 0;\n                    if (which > interp.length-1) which = interp.length-1; \n                    //if (which > 138) System.out.println(\"grabbing \" + which);\n                    \n                    data[index++] = interp[which][0];\n                    data[index++] = interp[which][1];\n                    data[index++] = interp[which][2];\n                    data[index++] = interp[which][3];\n                }\n            }\n            raster.setPixels(0, 0, w, h, data);\n\n            return raster;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public BaseObject(XMLElement properties) {\n            id = properties.getStringAttribute(\"id\");\n            if (id != null) {\n                idTable.put(id, this);\n                //System.out.println(\"now parsing \" + id);\n            }\n        }","id":41725,"modified_method":"public BaseObject(XMLElement properties) {\n            element = properties;\n            id = properties.getStringAttribute(\"id\");\n            if (id != null) {\n                table.put(id, this);\n                //System.out.println(\"now parsing \" + id);\n            }\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public RadialGradientPaint(float cx, float cy, float radius, \n                                   float[] offset, int[] color, int count) {\n            this.cx = cx;\n            this.cy = cy;\n            this.radius = radius;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n        }","id":41726,"modified_method":"public RadialGradientPaint(float cx, float cy, float radius, \n                                   float[] offset, int[] color, int count,\n                                   float opacity) {\n            this.cx = cx;\n            this.cy = cy;\n            this.radius = radius;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n            this.opacity = opacity;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public LinearGradientPaint(float x1, float y1, float x2, float y2,\n                                   float[] offset, int[] color, int count) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n        }","id":41727,"modified_method":"public LinearGradientPaint(float x1, float y1, float x2, float y2,\n                                   float[] offset, int[] color, int count, \n                                   float opacity) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.offset = offset;\n            this.color = color;\n            this.count = count;\n            this.opacity = opacity;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public Raster getRaster(int x, int y, int w, int h) {\n            WritableRaster raster =\n                getColorModel().createCompatibleWritableRaster(w, h);\n\n            //System.out.println(\"radius here is \" + radius);\n            int span = (int) radius * ACCURACY; \n            int[][] interp = new int[span][3];\n            int prev = 0;\n            for (int i = 1; i < count; i++) {\n                int c0 = color[i-1];\n                int c1 = color[i];\n                int last = (int) (offset[i] * (span - 1));\n                for (int j = prev; j <= last; j++) {\n                    float btwn = PApplet.norm(j, prev, last);\n                    interp[j][0] = (int) PApplet.lerp((c0 >> 16) & 0xff, (c1 >> 16) & 0xff, btwn);\n                    interp[j][1] = (int) PApplet.lerp((c0 >> 8) & 0xff, (c1 >> 8) & 0xff, btwn);\n                    interp[j][2] = (int) PApplet.lerp(c0 & 0xff, c1 & 0xff, btwn);\n                }\n                prev = last;\n            }\n                \n            int[] data = new int[w * h * 4];\n            int index = 0;\n            for (int j = 0; j < h; j++) {\n                for (int i = 0; i < w; i++) {\n                    float distance = PApplet.dist(cx, cy, x + i, y + j);\n                    int which = PApplet.min((int) (distance * ACCURACY), interp.length-1);\n                    \n                    data[index++] = interp[which][0];\n                    data[index++] = interp[which][1];\n                    data[index++] = interp[which][2];\n                    data[index++] = 255;\n                }\n            }\n            raster.setPixels(0, 0, w, h, data);\n\n            return raster;\n        }","id":41728,"modified_method":"public Raster getRaster(int x, int y, int w, int h) {\n            WritableRaster raster =\n                getColorModel().createCompatibleWritableRaster(w, h);\n\n            //System.out.println(\"radius here is \" + radius);\n            //System.out.println(\"count is \" + count);\n            int span = (int) radius * ACCURACY; \n            int[][] interp = new int[span][4];\n            int prev = 0;\n            for (int i = 1; i < count; i++) {\n                int c0 = color[i-1];\n                int c1 = color[i];\n                int last = (int) (offset[i] * (span - 1));\n                for (int j = prev; j <= last; j++) {\n                    float btwn = PApplet.norm(j, prev, last);\n                    interp[j][0] = (int) PApplet.lerp((c0 >> 16) & 0xff, (c1 >> 16) & 0xff, btwn);\n                    interp[j][1] = (int) PApplet.lerp((c0 >> 8) & 0xff, (c1 >> 8) & 0xff, btwn);\n                    interp[j][2] = (int) PApplet.lerp(c0 & 0xff, c1 & 0xff, btwn);\n                    interp[j][3] = (int) (PApplet.lerp((c0 >> 24) & 0xff, (c1 >> 24) & 0xff, btwn) * opacity);\n                    //System.out.println(interp[j][3]);\n                }\n                prev = last;\n            }\n                \n            int[] data = new int[w * h * 4];\n            int index = 0;\n            for (int j = 0; j < h; j++) {\n                for (int i = 0; i < w; i++) {\n                    float distance = PApplet.dist(cx, cy, x + i, y + j);\n                    int which = PApplet.min((int) (distance * ACCURACY), interp.length-1);\n                    \n                    data[index++] = interp[which][0];\n                    data[index++] = interp[which][1];\n                    data[index++] = interp[which][2];\n                    data[index++] = interp[which][3];\n                }\n            }\n            raster.setPixels(0, 0, w, h, data);\n\n            return raster;\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Initializes a new SVG Object with the given filename.\n     * @param filename, String: filename of the object\n     * @param parent, PApplet: instance of the parent application\n     */\n    public SVG(String filename, PApplet parent){\n        this.parent = parent;        \n        this.filename = filename;\n\n        // this will grab the root document, starting <svg ...>\n        // the xml version and initial comments are ignored\n        svg = new XMLElement(filename, parent);\n        \n        /*\n        Reader reader = parent.createReader(filename);\n        if (reader == null) {\n            System.err.println(\"The file \" + filename + \" could not be found.\");\n            return;\n        }\n        try {\n            document.parseFromReader(reader);\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Could not load SVG file\");\n            //throw new RuntimeException(\"Could not load SVG file\");\n            return;\n        }\n        */\n        if (!svg.getName().equals(\"svg\")) {\n            throw new RuntimeException(\"root isn't svg, it's \" + svg.getName());\n        }\n\n        width = svg.getFloatAttribute(\"width\");\n        height = svg.getFloatAttribute(\"height\");\n        \n        /*\n        PApplet.println(\"document has \" + document.getChildCount() + \" children\");\n        //Get the xml child node we need\n        XMLElement doc = document.getChild(1);\n        PApplet.println(doc);\n        if (true) return;\n        */\n        \n        /*\n        //XMLElement entSVG = doc.getChild(0);\n        //XMLElement svg = entSVG.getChild(1);\n        //While we're doing that, save the width and height too\n        //svgWidth = svg.getIntAttribute(\"width\");\n        //svgHeight = svg.getIntAttribute(\"height\");\n\n        //Catch exception when SVG doesn't have a <g> tag\n        XMLElement graphics;\t\n        String nameOfFirstChild = svg.getChild(1).toString();\n        if(nameOfFirstChild.equals(\"<g>\"))\n            graphics = svg.getChild(1);\t\n        else\n            graphics = svg;\t   \n\n        this.svgData = svg;\n        */\n        \n        //parseChildren(document);\n        root = new Group(svg);\n        \n        /*\n        XMLElement graphics = null;\n\n        //Print SVG on construction\n        //Use this for debugging\n        //svg.printElementTree(\" .\");\n        */\n    }","id":41729,"modified_method":"/**\n     * Initializes a new SVG Object with the given filename.\n     * @param filename, String: filename of the object\n     * @param parent, PApplet: instance of the parent application\n     */\n    public SVG(String filename, PApplet parent){\n        this.parent = parent;        \n        //this.filename = filename;\n\n        // this will grab the root document, starting <svg ...>\n        // the xml version and initial comments are ignored\n        svg = new XMLElement(filename, parent);\n        \n        /*\n        Reader reader = parent.createReader(filename);\n        if (reader == null) {\n            System.err.println(\"The file \" + filename + \" could not be found.\");\n            return;\n        }\n        try {\n            document.parseFromReader(reader);\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Could not load SVG file\");\n            //throw new RuntimeException(\"Could not load SVG file\");\n            return;\n        }\n        */\n        if (!svg.getName().equals(\"svg\")) {\n            throw new RuntimeException(\"root isn't svg, it's \" + svg.getName());\n        }\n\n        width = parseUnitSize(svg.getStringAttribute(\"width\"));\n        height = parseUnitSize(svg.getStringAttribute(\"height\"));\n        \n        /*\n        PApplet.println(\"document has \" + document.getChildCount() + \" children\");\n        //Get the xml child node we need\n        XMLElement doc = document.getChild(1);\n        PApplet.println(doc);\n        if (true) return;\n        */\n        \n        /*\n        //XMLElement entSVG = doc.getChild(0);\n        //XMLElement svg = entSVG.getChild(1);\n        //While we're doing that, save the width and height too\n        //svgWidth = svg.getIntAttribute(\"width\");\n        //svgHeight = svg.getIntAttribute(\"height\");\n\n        //Catch exception when SVG doesn't have a <g> tag\n        XMLElement graphics;\t\n        String nameOfFirstChild = svg.getChild(1).toString();\n        if(nameOfFirstChild.equals(\"<g>\"))\n            graphics = svg.getChild(1);\t\n        else\n            graphics = svg;\t   \n\n        this.svgData = svg;\n        */\n        \n        //parseChildren(document);\n        root = new Group(svg);\n        \n        /*\n        XMLElement graphics = null;\n\n        //Print SVG on construction\n        //Use this for debugging\n        //svg.printElementTree(\" .\");\n        */\n    }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public PaintContext createContext(ColorModel cm,\n                                          Rectangle deviceBounds, Rectangle2D userBounds,\n                                          AffineTransform xform, RenderingHints hints) {\n            Point2D transformedPoint = \n                xform.transform(new Point2D.Float(cx, cy), null);\n            // this causes problems\n            //Point2D transformedRadius = \n            //    xform.deltaTransform(new Point2D.Float(radius, radius), null);\n            return new RadialGradientContext((float) transformedPoint.getX(), \n                                             (float) transformedPoint.getY(), \n                                             radius, //(float) transformedRadius.distance(0, 0), \n                                             offset, color, count);\n        }","id":41730,"modified_method":"public PaintContext createContext(ColorModel cm,\n                                          Rectangle deviceBounds, Rectangle2D userBounds,\n                                          AffineTransform xform, RenderingHints hints) {\n            Point2D transformedPoint = \n                xform.transform(new Point2D.Float(cx, cy), null);\n            // this causes problems\n            //Point2D transformedRadius = \n            //    xform.deltaTransform(new Point2D.Float(radius, radius), null);\n            return new RadialGradientContext((float) transformedPoint.getX(), \n                                             (float) transformedPoint.getY(), \n                                             radius, //(float) transformedRadius.distance(0, 0), \n                                             offset, color, count, opacity);\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"public int getTransparency() {\n            /*\n            int a1 = mPointColor.getAlpha();\n            int a2 = mBackgroundColor.getAlpha();\n            return (((a1 & a2) == 0xff) ? OPAQUE : TRANSLUCENT);\n            */\n            return OPAQUE;\n        }","id":41731,"modified_method":"public int getTransparency() {\n            /*\n            int a1 = mPointColor.getAlpha();\n            int a2 = mBackgroundColor.getAlpha();\n            return (((a1 & a2) == 0xff) ? OPAQUE : TRANSLUCENT);\n            */\n            //return (opacity == 1) ? OPAQUE : TRANSLUCENT;\n            return TRANSLUCENT;  // why not.. rather than checking each color\n        }","commit_id":"9cad02ea190bed41152098460585dde9adfaa9f1","url":"https://github.com/processing/processing"},{"original_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( fileName + \".1\" );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            if ( copy.exists() )\n            {\n                if ( !copy.delete() )\n                {\n                    log.warning( \"Unable to delete \" + copy.getName() );\n                }\n            }\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = fileName + \".1\";\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( fileName + \".2\" );\n                if ( file.exists() )\n                {\n                    fixCleanKill( fileName + \".2\" );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = fileName + \".1\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( fileName + \".2\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = fileName + \".2\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( fileName + \".1\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41732,"modified_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( getLog1FileName() );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            safeDeleteFile( copy );\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = getLog1FileName();\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( getLog2FileName() );\n                if ( file.exists() )\n                {\n                    fixCleanKill( file.getPath() );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = getLog1FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( getLog2FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = getLog2FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( getLog1FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        \n        instantiateCorrectWriteBuffer();\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n    }","id":41733,"modified_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unrecognized log entry \" + entry );\n        }\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":41734,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        long[] header = readLogHeader( buffer, fileChannel, false );\n        if ( header == null )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        logVersion = header[0];\n        long lastCommittedTx = header[1];\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLogicalLogLength( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File( name );\n        if ( !file.exists() )\n        {\n            return -1;\n        }\n        return file.length();\n    }","id":41735,"modified_method":"public long getLogicalLogLength( long version )\n    {\n        File file = new File( getFileName( version ) );\n        return file.exists() ? file.length() : -1;\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41736,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            if ( log.read( buf ) != 16 )\n            {\n                throw new IOException( \"Unable to read log version \" + \n                        version );\n            }\n            buf.flip();\n            long readVersion = buf.getLong();\n            if ( readVersion != version )\n            {\n                throw new IOException( \"Got \" + readVersion + \n                        \" from log when expecting \" + version );\n            }\n            committedTx = buf.getLong();\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","id":41737,"modified_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            long[] header = readAndAssertLogHeader( buf, log, version );\n            committedTx = header[1];\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = \n                fileName + (currentLog == LOG1 ? \".1\" : \".2\" );\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","id":41738,"modified_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = getCurrentLogFileName();\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean deleteLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File(name );\n        if ( file.exists() )\n        {\n            return FileUtils.deleteFile( file );\n        }\n        return false;\n    }","id":41739,"modified_method":"public boolean deleteLogicalLog( long version )\n    {\n        File file = new File(getFileName( version ) );\n        return file.exists() ? FileUtils.deleteFile( file ) : false;\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","id":41740,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = getFileName( xaTf.getAndSetNewVersion() );\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":41741,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        readLogHeader( buffer, log, false );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean hasLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        return new File( name ).exists();\n    }","id":41742,"modified_method":"public boolean hasLogicalLog( long version )\n    {\n        return new File( getFileName( version ) ).exists();\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":41743,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        long[] header = readAndAssertLogHeader( buffer, log, expectedVersion );\n        long prevTxId = header[1];\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( byteChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to read log version\" );\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long previousCommittedTx = buffer.getLong();\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","id":41744,"modified_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        long[] header = readLogHeader( buffer, byteChannel, true );\n        logVersion = header[0];\n        long previousCommittedTx = header[1];\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = fileName + \".v\" + version;\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","id":41745,"modified_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = getFileName( version );\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","commit_id":"7ba88ea4425aed3c241f1c9d4e8456bcd5032fa1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n    }","id":41746,"modified_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unrecognized log entry \" + entry );\n        }\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean deleteLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File(name );\n        if ( file.exists() )\n        {\n            return FileUtils.deleteFile( file );\n        }\n        return false;\n    }","id":41747,"modified_method":"public boolean deleteLogicalLog( long version )\n    {\n        File file = new File(getFileName( version ) );\n        return file.exists() ? FileUtils.deleteFile( file ) : false;\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":41748,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        long[] header = readAndAssertLogHeader( buffer, log, expectedVersion );\n        long prevTxId = header[1];\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = fileName + \".v\" + version;\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","id":41749,"modified_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = getFileName( version );\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":41750,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        readLogHeader( buffer, log, false );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( fileName + \".1\" );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            if ( copy.exists() )\n            {\n                if ( !copy.delete() )\n                {\n                    log.warning( \"Unable to delete \" + copy.getName() );\n                }\n            }\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = fileName + \".1\";\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( fileName + \".2\" );\n                if ( file.exists() )\n                {\n                    fixCleanKill( fileName + \".2\" );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = fileName + \".1\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( fileName + \".2\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = fileName + \".2\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( fileName + \".1\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41751,"modified_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( getLog1FileName() );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            safeDeleteFile( copy );\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = getLog1FileName();\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( getLog2FileName() );\n                if ( file.exists() )\n                {\n                    fixCleanKill( file.getPath() );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = getLog1FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( getLog2FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = getLog2FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( getLog1FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        \n        instantiateCorrectWriteBuffer();\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLogicalLogLength( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File( name );\n        if ( !file.exists() )\n        {\n            return -1;\n        }\n        return file.length();\n    }","id":41752,"modified_method":"public long getLogicalLogLength( long version )\n    {\n        File file = new File( getFileName( version ) );\n        return file.exists() ? file.length() : -1;\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( byteChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to read log version\" );\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long previousCommittedTx = buffer.getLong();\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","id":41753,"modified_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        long[] header = readLogHeader( buffer, byteChannel, true );\n        logVersion = header[0];\n        long previousCommittedTx = header[1];\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = \n                fileName + (currentLog == LOG1 ? \".1\" : \".2\" );\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","id":41754,"modified_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = getCurrentLogFileName();\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean hasLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        return new File( name ).exists();\n    }","id":41755,"modified_method":"public boolean hasLogicalLog( long version )\n    {\n        return new File( getFileName( version ) ).exists();\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","id":41756,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = getFileName( xaTf.getAndSetNewVersion() );\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":41757,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        long[] header = readLogHeader( buffer, fileChannel, false );\n        if ( header == null )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        logVersion = header[0];\n        long lastCommittedTx = header[1];\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            if ( log.read( buf ) != 16 )\n            {\n                throw new IOException( \"Unable to read log version \" + \n                        version );\n            }\n            buf.flip();\n            long readVersion = buf.getLong();\n            if ( readVersion != version )\n            {\n                throw new IOException( \"Got \" + readVersion + \n                        \" from log when expecting \" + version );\n            }\n            committedTx = buf.getLong();\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","id":41758,"modified_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            long[] header = readAndAssertLogHeader( buf, log, version );\n            committedTx = header[1];\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41759,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n    }","commit_id":"f5fad0a16b14dd20189290d62af62af3ee2edfbc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = fileName + \".v\" + version;\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","id":41760,"modified_method":"public ReadableByteChannel getLogicalLog( long version ) throws IOException\n    {\n        String name = getFileName( version );\n        if ( !new File( name ).exists() )\n        {\n            throw new IOException( \"No such log version:\" + version );\n        }\n        return new RandomAccessFile( name, \"r\" ).getChannel();\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41761,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":41762,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        readLogHeader( buffer, log, false );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( fileName + \".1\" );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            if ( copy.exists() )\n            {\n                if ( !copy.delete() )\n                {\n                    log.warning( \"Unable to delete \" + copy.getName() );\n                }\n            }\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = fileName + \".1\";\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( fileName + \".2\" );\n                if ( file.exists() )\n                {\n                    fixCleanKill( fileName + \".2\" );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = fileName + \".1\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( fileName + \".2\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = fileName + \".2\";\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( fileName + \".1\" );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":41763,"modified_method":"synchronized void open() throws IOException\n    {\n        String activeFileName = fileName + \".active\";\n        if ( !new File( activeFileName ).exists() )\n        {\n            if ( new File( fileName ).exists() )\n            {\n                // old < b8 xaframework with no log rotation and we need to \n                // do recovery on it\n                open( fileName );\n            }\n            else\n            {\n                open( getLog1FileName() );\n                setActiveLog( LOG1 );\n            }\n        }\n        else\n        {\n            FileChannel fc = new RandomAccessFile( activeFileName , \n                \"rw\" ).getChannel();\n            byte bytes[] = new byte[256];\n            ByteBuffer buf = ByteBuffer.wrap( bytes );\n            int read = fc.read( buf );\n            fc.close();\n            if ( read != 4 )\n            {\n                throw new IllegalStateException( \"Read \" + read + \n                    \" bytes from \" + activeFileName + \" but expected 4\" ); \n            }\n            buf.flip();\n            char c = buf.asCharBuffer().get();\n            File copy = new File( fileName + \".copy\" );\n            safeDeleteFile( copy );\n            if ( c == CLEAN )\n            {\n                // clean\n                String newLog = getLog1FileName();\n                File file = new File( newLog );\n                if ( file.exists() )\n                {\n                    fixCleanKill( newLog );\n                }\n                file = new File( getLog2FileName() );\n                if ( file.exists() )\n                {\n                    fixCleanKill( file.getPath() );\n                }\n                open( newLog );\n                setActiveLog( LOG1 );\n            }\n            else if ( c == LOG1 )\n            {\n                String newLog = getLog1FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 1 but no \" + newLog + \" exist\" );\n                }\n                currentLog = LOG1;\n                File otherLog = new File( getLog2FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                open( newLog );\n            }\n            else if ( c == LOG2 )\n            {\n                String newLog = getLog2FileName();\n                if ( !new File( newLog ).exists() )\n                {\n                    throw new IllegalStateException( \n                        \"Active marked as 2 but no \" + newLog + \" exist\" );\n                }\n                File otherLog = new File( getLog1FileName() );\n                if ( otherLog.exists() )\n                {\n                    if ( !otherLog.delete() )\n                    {\n                        log.warning( \"Unable to delete \" + copy.getName() );\n                    }\n                }\n                currentLog = LOG2;\n                open( newLog );\n            }\n            else\n            {\n                throw new IllegalStateException( \"Unknown active log: \" + c );\n            }\n        }\n        \n        instantiateCorrectWriteBuffer();\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","id":41764,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = getFileName( xaTf.getAndSetNewVersion() );\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            if ( log.read( buf ) != 16 )\n            {\n                throw new IOException( \"Unable to read log version \" + \n                        version );\n            }\n            buf.flip();\n            long readVersion = buf.getLong();\n            if ( readVersion != version )\n            {\n                throw new IOException( \"Got \" + readVersion + \n                        \" from log when expecting \" + version );\n            }\n            committedTx = buf.getLong();\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","id":41765,"modified_method":"private long findLogContainingTxId( long txId ) throws IOException\n    {\n        long version = logVersion;\n        long committedTx = previousLogLastCommittedTx;\n        while ( version >= 0 )\n        {\n            ReadableByteChannel log = getLogicalLogOrMyself( version );\n            ByteBuffer buf = ByteBuffer.allocate( 16 );\n            long[] header = readAndAssertLogHeader( buf, log, version );\n            committedTx = header[1];\n            log.close();\n            if ( committedTx <= txId )\n            {\n                break;\n            }\n            version--;\n        }\n        return version;\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( byteChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to read log version\" );\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long previousCommittedTx = buffer.getLong();\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","id":41766,"modified_method":"public synchronized void applyLog( ReadableByteChannel byteChannel ) \n        throws IOException\n    {\n        if ( !backupSlave )\n        {\n            throw new IllegalStateException( \"This is not a backup slave\" );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            throw new IllegalStateException( \"There are active transactions\" );\n        }\n        long[] header = readLogHeader( buffer, byteChannel, true );\n        logVersion = header[0];\n        long previousCommittedTx = header[1];\n        if ( logVersion != xaTf.getCurrentVersion() )\n        {\n            throw new IllegalStateException( \"Tried to apply version \" + \n                logVersion + \" but expected version \" + \n                xaTf.getCurrentVersion() );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \"(previous committed tx=\" + previousCommittedTx + \")\" );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        while ( logApplier.readAndApplyEntry() )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        xaTf.flushAll();\n        xaTf.getAndSetNewVersion();\n        xaRm.reset();\n        log.info( \"Log[\" + fileName + \"] version \" + logVersion + \n                \" applied successfully.\" );\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean deleteLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File(name );\n        if ( file.exists() )\n        {\n            return FileUtils.deleteFile( file );\n        }\n        return false;\n    }","id":41767,"modified_method":"public boolean deleteLogicalLog( long version )\n    {\n        File file = new File(getFileName( version ) );\n        return file.exists() ? FileUtils.deleteFile( file ) : false;\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = \n                fileName + (currentLog == LOG1 ? \".1\" : \".2\" );\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","id":41768,"modified_method":"private ReadableByteChannel getLogicalLogOrMyself( long version ) throws IOException\n    {\n        if ( version < logVersion )\n        {\n            return getLogicalLog( version );\n        }\n        else if ( version == logVersion )\n        {\n            String currentLogName = getCurrentLogFileName();\n            return new RandomAccessFile( currentLogName, \"r\" ).getChannel();\n        }\n        else\n        {\n            throw new RuntimeException( \"Version[\" + version + \n                    \"] is higher then current log version[\" + logVersion + \"]\" );\n        }\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n    }","id":41769,"modified_method":"private void applyEntry( LogEntry entry ) throws IOException\n    {\n        if ( entry instanceof LogEntry.Start )\n        {\n            applyStartEntry( (LogEntry.Start) entry );\n        }\n        else if ( entry instanceof LogEntry.Prepare )\n        {\n            applyPrepareEntry( (LogEntry.Prepare ) entry );\n        }\n        else if ( entry instanceof LogEntry.Command )\n        {\n            applyCommandEntry( (LogEntry.Command ) entry );\n        }\n        else if ( entry instanceof LogEntry.OnePhaseCommit )\n        {\n            applyOnePhaseCommitEntry( (LogEntry.OnePhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.TwoPhaseCommit )\n        {\n            applyTwoPhaseCommitEntry( (LogEntry.TwoPhaseCommit ) entry );\n        }\n        else if ( entry instanceof LogEntry.Done )\n        {\n            applyDoneEntry( (LogEntry.Done ) entry );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unrecognized log entry \" + entry );\n        }\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean hasLogicalLog( long version )\n    {\n        String name = fileName + \".v\" + version;\n        return new File( name ).exists();\n    }","id":41770,"modified_method":"public boolean hasLogicalLog( long version )\n    {\n        return new File( getFileName( version ) ).exists();\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":41771,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        long[] header = readLogHeader( buffer, fileChannel, false );\n        if ( header == null )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        logVersion = header[0];\n        long lastCommittedTx = header[1];\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLogicalLogLength( long version )\n    {\n        String name = fileName + \".v\" + version;\n        File file = new File( name );\n        if ( !file.exists() )\n        {\n            return -1;\n        }\n        return file.length();\n    }","id":41772,"modified_method":"public long getLogicalLogLength( long version )\n    {\n        File file = new File( getFileName( version ) );\n        return file.exists() ? file.length() : -1;\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":41773,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        long[] header = readAndAssertLogHeader( buffer, log, expectedVersion );\n        long prevTxId = header[1];\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"46147aeb5be8bc8363a36375b227100cbda8b135","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Map _insertRequestVariables(Element parent) {\n\t\tMap map = new HashMap();\n\n\t\tif (parent == null) {\n\t\t\treturn map;\n\t\t}\n\n\t\tIterator itr1 = parent.elements().iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement el = (Element)itr1.next();\n\n\t\t\tString name = el.getName();\n\n\t\t\tif (name.equals(\"application-attributes\") ||\n\t\t\t\tname.equals(\"portlet-attributes\") ||\n\t\t\t\tname.equals(\"attribute\")) {\n\n\t\t\t\tmap.put(\n\t\t\t\t\tel.element(\"name\").getText(),\n\t\t\t\t\tel.element(\"value\").getText());\n\t\t\t}\n\t\t\telse if (name.equals(\"parameter\")) {\n\t\t\t\tname = el.element(\"name\").getText();\n\n\t\t\t\tList valueEls = el.elements(\"value\");\n\n\t\t\t\tif (valueEls.size() == 1) {\n\t\t\t\t\tmap.put(name, valueEls.get(0));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList values = new ArrayList();\n\n\t\t\t\t\tIterator itr2 = valueEls.iterator();\n\n\t\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\t\tElement valueEl = (Element)itr2.next();\n\n\t\t\t\t\t\tvalues.add(valueEl.getText());\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.put(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (el.elements().size() > 0) {\n\t\t\t\tmap.put(name, _insertRequestVariables(el));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(name, el.getText());\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}","id":41774,"modified_method":"private static Map _insertRequestVariables(Element parent) {\n\t\tMap map = new HashMap();\n\n\t\tif (parent == null) {\n\t\t\treturn map;\n\t\t}\n\n\t\tIterator itr1 = parent.elements().iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement el = (Element)itr1.next();\n\n\t\t\tString name = el.getName();\n\n\t\t\tif (name.equals(\"application-attributes\") ||\n\t\t\t\tname.equals(\"portlet-attributes\") ||\n\t\t\t\tname.equals(\"attribute\")) {\n\n\t\t\t\tmap.put(el.elementText(\"name\"), el.elementText(\"value\"));\n\t\t\t}\n\t\t\telse if (name.equals(\"parameter\")) {\n\t\t\t\tname = el.element(\"name\").getText();\n\n\t\t\t\tList valueEls = el.elements(\"value\");\n\n\t\t\t\tif (valueEls.size() == 1) {\n\t\t\t\t\tmap.put(name, valueEls.get(0));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList values = new ArrayList();\n\n\t\t\t\t\tIterator itr2 = valueEls.iterator();\n\n\t\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\t\tElement valueEl = (Element)itr2.next();\n\n\t\t\t\t\t\tvalues.add(valueEl.getText());\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.put(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (el.elements().size() > 0) {\n\t\t\t\tmap.put(name, _insertRequestVariables(el));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(name, el.getText());\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}","commit_id":"bd637a13a6b706e59c483339b709dc84b80dd8a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String toXML(PortletRequest req, PortletResponse res) {\n\t\tString xml = null;\n\n\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\tElement reqEl = doc.addElement(\"request\");\n\n\t\tDocUtil.add(reqEl, \"container-type\", \"portlet\");\n\t\tDocUtil.add(reqEl, \"container-namespace\", req.getContextPath());\n\t\tDocUtil.add(reqEl, \"content-type\", req.getResponseContentType());\n\t\tDocUtil.add(reqEl, \"server-name\", req.getServerName());\n\t\tDocUtil.add(reqEl, \"server-port\", req.getServerPort());\n\t\tDocUtil.add(reqEl, \"secure\", req.isSecure());\n\t\tDocUtil.add(reqEl, \"auth-type\", req.getAuthType());\n\t\tDocUtil.add(reqEl, \"remote-user\", req.getRemoteUser());\n\t\tDocUtil.add(reqEl, \"context-path\", req.getContextPath());\n\t\tDocUtil.add(reqEl, \"locale\", req.getLocale());\n\t\tDocUtil.add(reqEl, \"portlet-mode\", req.getPortletMode());\n\t\tDocUtil.add(reqEl, \"portlet-session-id\", req.getRequestedSessionId());\n\t\tDocUtil.add(reqEl, \"scheme\", req.getScheme());\n\t\tDocUtil.add(reqEl, \"window-state\", req.getWindowState());\n\n\t\tif (req instanceof RenderRequest) {\n\t\t\tDocUtil.add(reqEl, \"action\", Boolean.FALSE);\n\t\t}\n\t\telse if (req instanceof ActionRequest) {\n\t\t\tDocUtil.add(reqEl, \"action\", Boolean.TRUE);\n\t\t}\n\n\t\tif (res instanceof RenderResponse) {\n\t\t\t_renderResponseToXML((RenderResponse)res, reqEl);\n\t\t}\n\n\t\tElement parametersEl = reqEl.addElement(\"parameters\");\n\n\t\tEnumeration enu = req.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement parameterEl = parametersEl.addElement(\"parameter\");\n\n\t\t\tDocUtil.add(parameterEl, \"name\", name);\n\n\t\t\tString[] values = req.getParameterValues(name);\n\n\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\tDocUtil.add(parameterEl, \"value\", values[i]);\n\t\t\t}\n\t\t}\n\n\t\tElement attributesEl = reqEl.addElement(\"attributes\");\n\n\t\tenu = req.getAttributeNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = req.getAttribute(name);\n\n\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t}\n\n\t\tElement portletSessionEl = reqEl.addElement(\"portlet-session\");\n\n\t\tattributesEl = portletSessionEl.addElement(\"portlet-attributes\");\n\n\t\tPortletSession ses = req.getPortletSession();\n\n\t\tenu = ses.getAttributeNames(PortletSession.PORTLET_SCOPE);\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = ses.getAttribute(name, PortletSession.PORTLET_SCOPE);\n\n\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t}\n\n\t\tattributesEl = portletSessionEl.addElement(\"application-attributes\");\n\n\t\tenu = ses.getAttributeNames(PortletSession.APPLICATION_SCOPE);\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = ses.getAttribute(\n\t\t\t\tname, PortletSession.APPLICATION_SCOPE);\n\n\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t}\n\n\t\ttry {\n\t\t\txml = XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\treturn xml;\n\t}","id":41775,"modified_method":"public static String toXML(PortletRequest req, PortletResponse res) {\n\t\tString xml = null;\n\n\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\tElement reqEl = doc.addElement(\"request\");\n\n\t\tDocUtil.add(reqEl, \"container-type\", \"portlet\");\n\t\tDocUtil.add(reqEl, \"container-namespace\", req.getContextPath());\n\t\tDocUtil.add(reqEl, \"content-type\", req.getResponseContentType());\n\t\tDocUtil.add(reqEl, \"server-name\", req.getServerName());\n\t\tDocUtil.add(reqEl, \"server-port\", req.getServerPort());\n\t\tDocUtil.add(reqEl, \"secure\", req.isSecure());\n\t\tDocUtil.add(reqEl, \"auth-type\", req.getAuthType());\n\t\tDocUtil.add(reqEl, \"remote-user\", req.getRemoteUser());\n\t\tDocUtil.add(reqEl, \"context-path\", req.getContextPath());\n\t\tDocUtil.add(reqEl, \"locale\", req.getLocale());\n\t\tDocUtil.add(reqEl, \"portlet-mode\", req.getPortletMode());\n\t\tDocUtil.add(reqEl, \"portlet-session-id\", req.getRequestedSessionId());\n\t\tDocUtil.add(reqEl, \"scheme\", req.getScheme());\n\t\tDocUtil.add(reqEl, \"window-state\", req.getWindowState());\n\n\t\tif (req instanceof RenderRequest) {\n\t\t\tDocUtil.add(reqEl, \"action\", Boolean.FALSE);\n\t\t}\n\t\telse if (req instanceof ActionRequest) {\n\t\t\tDocUtil.add(reqEl, \"action\", Boolean.TRUE);\n\t\t}\n\n\t\tif (res instanceof RenderResponse) {\n\t\t\t_renderResponseToXML((RenderResponse)res, reqEl);\n\t\t}\n\n\t\tElement parametersEl = reqEl.addElement(\"parameters\");\n\n\t\tEnumeration enu = req.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement parameterEl = parametersEl.addElement(\"parameter\");\n\n\t\t\tDocUtil.add(parameterEl, \"name\", name);\n\n\t\t\tString[] values = req.getParameterValues(name);\n\n\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\tDocUtil.add(parameterEl, \"value\", values[i]);\n\t\t\t}\n\t\t}\n\n\t\tElement attributesEl = reqEl.addElement(\"attributes\");\n\n\t\tenu = req.getAttributeNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = req.getAttribute(name);\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t\t}\n\t\t}\n\n\t\tElement portletSessionEl = reqEl.addElement(\"portlet-session\");\n\n\t\tattributesEl = portletSessionEl.addElement(\"portlet-attributes\");\n\n\t\tPortletSession ses = req.getPortletSession();\n\n\t\tenu = ses.getAttributeNames(PortletSession.PORTLET_SCOPE);\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = ses.getAttribute(name, PortletSession.PORTLET_SCOPE);\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t\t}\n\t\t}\n\n\t\tattributesEl = portletSessionEl.addElement(\"application-attributes\");\n\n\t\tenu = ses.getAttributeNames(PortletSession.APPLICATION_SCOPE);\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tElement attributeEl = attributesEl.addElement(\"attribute\");\n\n\t\t\tDocUtil.add(attributeEl, \"name\", name);\n\n\t\t\tObject value = ses.getAttribute(\n\t\t\t\tname, PortletSession.APPLICATION_SCOPE);\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tDocUtil.add(attributeEl, \"value\", String.valueOf(value));\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\txml = XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\treturn xml;\n\t}","commit_id":"bd637a13a6b706e59c483339b709dc84b80dd8a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String convertStagingPreferencesToJSON(String preferences)\n\t\tthrows Exception {\n\n\t\tDocument newDocument = SAXReaderUtil.createDocument();\n\n\t\tElement newRootElement = SAXReaderUtil.createElement(\n\t\t\t\"portlet-preferences\");\n\n\t\tnewDocument.add(newRootElement);\n\n\t\tDocument document = SAXReaderUtil.read(preferences);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tIterator<Element> itr = rootElement.elementIterator();\n\n\t\tMap<String, String> stagingPreferencesMap = new HashMap<>();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement preferenceElement = itr.next();\n\n\t\t\tElement nameElement = preferenceElement.element(\"name\");\n\n\t\t\tString preferenceName = nameElement.getText();\n\n\t\t\tif (preferenceName.contains(Staging.class.getName())) {\n\t\t\t\tElement valueElement = preferenceElement.element(\"value\");\n\n\t\t\t\tString value = valueElement.getText();\n\n\t\t\t\tint index = preferenceName.indexOf(StringPool.POUND);\n\n\t\t\t\tstagingPreferencesMap.put(\n\t\t\t\t\tpreferenceName.substring(index + 1), value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnewRootElement.add(preferenceElement.createCopy());\n\t\t\t}\n\t\t}\n\n\t\tJSONArray stagingPreferencesJsonArray =\n\t\t\tJSONFactoryUtil.createJSONArray();\n\n\t\tfor (String key : stagingPreferencesMap.keySet()) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(key, stagingPreferencesMap.get(key));\n\n\t\t\tstagingPreferencesJsonArray.put(jsonObject);\n\t\t}\n\n\t\tif (stagingPreferencesJsonArray.length() > 0) {\n\t\t\tElement stagingPreferencesElement = SAXReaderUtil.createElement(\n\t\t\t\t\"preference\");\n\n\t\t\tElement stagingPreferencesNameElement = SAXReaderUtil.createElement(\n\t\t\t\t\"name\");\n\n\t\t\tString stagingPreferencesName =\n\t\t\t\tStaging.class.getName() + StringPool.POUND +\n\t\t\t\tStagingConstants.STAGING_RECENT_LAYOUT_IDS_MAP;\n\n\t\t\tstagingPreferencesNameElement.setText(stagingPreferencesName);\n\n\t\t\tElement stagingPreferencesValueElement =\n\t\t\t\tSAXReaderUtil.createElement(\"value\");\n\n\t\t\tstagingPreferencesValueElement.setText(\n\t\t\t\tstagingPreferencesJsonArray.toString());\n\n\t\t\tstagingPreferencesElement.add(stagingPreferencesNameElement);\n\t\t\tstagingPreferencesElement.add(stagingPreferencesValueElement);\n\n\t\t\tnewRootElement.add(stagingPreferencesElement);\n\t\t}\n\n\t\treturn DDMXMLUtil.formatXML(newDocument);\n\t}","id":41776,"modified_method":"protected String convertStagingPreferencesToJSON(String preferences)\n\t\tthrows Exception {\n\n\t\tDocument newDocument = SAXReaderUtil.createDocument();\n\n\t\tElement newRootElement = SAXReaderUtil.createElement(\n\t\t\t\"portlet-preferences\");\n\n\t\tnewDocument.add(newRootElement);\n\n\t\tDocument document = SAXReaderUtil.read(preferences);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tIterator<Element> itr = rootElement.elementIterator();\n\n\t\tMap<String, String> stagingPreferencesMap = new HashMap<>();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement preferenceElement = itr.next();\n\n\t\t\tString preferenceName = preferenceElement.elementText(\"name\");\n\n\t\t\tif (preferenceName.contains(Staging.class.getName())) {\n\t\t\t\tString preferenceValue = preferenceElement.elementText(\"value\");\n\n\t\t\t\tint index = preferenceName.indexOf(StringPool.POUND);\n\n\t\t\t\tstagingPreferencesMap.put(\n\t\t\t\t\tpreferenceName.substring(index + 1), preferenceValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnewRootElement.add(preferenceElement.createCopy());\n\t\t\t}\n\t\t}\n\n\t\tJSONArray stagingPreferencesJsonArray =\n\t\t\tJSONFactoryUtil.createJSONArray();\n\n\t\tfor (String key : stagingPreferencesMap.keySet()) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(key, stagingPreferencesMap.get(key));\n\n\t\t\tstagingPreferencesJsonArray.put(jsonObject);\n\t\t}\n\n\t\tif (stagingPreferencesJsonArray.length() > 0) {\n\t\t\tElement preferenceElement = SAXReaderUtil.createElement(\n\t\t\t\t\"preference\");\n\n\t\t\tElement nameElement = SAXReaderUtil.createElement(\"name\");\n\n\t\t\tString stagingPreferencesName =\n\t\t\t\tStaging.class.getName() + StringPool.POUND +\n\t\t\t\tStagingConstants.STAGING_RECENT_LAYOUT_IDS_MAP;\n\n\t\t\tnameElement.setText(stagingPreferencesName);\n\n\t\t\tElement valueElement = SAXReaderUtil.createElement(\"value\");\n\n\t\t\tvalueElement.setText(stagingPreferencesJsonArray.toString());\n\n\t\t\tpreferenceElement.add(nameElement);\n\t\t\tpreferenceElement.add(valueElement);\n\n\t\t\tnewRootElement.add(preferenceElement);\n\t\t}\n\n\t\treturn DDMXMLUtil.formatXML(newDocument);\n\t}","commit_id":"6219f4e250f183ffa9a32ada7217e132dd96eb8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":41777,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"b2886115672716b75eb7727c6df437912370ae40","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","id":41778,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"b2886115672716b75eb7727c6df437912370ae40","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","id":41779,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","commit_id":"b2886115672716b75eb7727c6df437912370ae40","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","id":41780,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"f172cdce4ad59f1073c2a2b3dd948d521f2079ee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","id":41781,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","commit_id":"f172cdce4ad59f1073c2a2b3dd948d521f2079ee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":41782,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"f172cdce4ad59f1073c2a2b3dd948d521f2079ee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","id":41783,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","commit_id":"75a4ef5e61af9a0d627cafd2390221f24dfff652","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","id":41784,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"75a4ef5e61af9a0d627cafd2390221f24dfff652","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":41785,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"75a4ef5e61af9a0d627cafd2390221f24dfff652","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public final void beforeRun() throws Exception {\n        callable = getNodeEngine().toObject(callableData);\n        ManagedContext managedContext = getManagedContext();\n\n        if (callable instanceof RunnableAdapter) {\n            RunnableAdapter adapter = (RunnableAdapter) callable;\n            Runnable runnable = (Runnable) managedContext.initialize(adapter.getRunnable());\n            adapter.setRunnable(runnable);\n        } else {\n            callable = (Callable) managedContext.initialize(callable);\n        }\n    }","id":41786,"modified_method":"@Override\n    public final void beforeRun() throws Exception {\n        callable = getCallable();\n        ManagedContext managedContext = getManagedContext();\n\n        if (callable instanceof RunnableAdapter) {\n            RunnableAdapter adapter = (RunnableAdapter) callable;\n            Runnable runnable = (Runnable) managedContext.initialize(adapter.getRunnable());\n            adapter.setRunnable(runnable);\n        } else {\n            callable = (Callable) managedContext.initialize(callable);\n        }\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testExecutorServiceStats() throws InterruptedException, ExecutionException {\n        final IExecutorService executorService = createSingleNodeExecutorService(\"testExecutorServiceStats\");\n        final int k = 10;\n        final CountDownLatch latch = new CountDownLatch(k);\n        final int executionTime = 200;\n        for (int i = 0; i < k; i++) {\n            executorService.execute(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(executionTime);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    latch.countDown();\n                }\n            });\n\n        }\n        latch.await(2, TimeUnit.MINUTES);\n\n        final Future<Boolean> f = executorService.submit(new SleepingTask(10000));\n        Thread.sleep(1000);\n        f.cancel(true);\n        try {\n            f.get();\n        } catch (CancellationException e) {\n        }\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(k + 1, stats.getStartedTaskCount());\n        assertEquals(k, stats.getCompletedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n        assertEquals(1, stats.getCancelledTaskCount());\n    }","id":41787,"modified_method":"@Test\n    public void testExecutorServiceStats() throws InterruptedException, ExecutionException {\n        final IExecutorService executorService = createSingleNodeExecutorService(\"testExecutorServiceStats\");\n        final int k = 10;\n        LatchRunnable.latch = new CountDownLatch(k);\n\n        for (int i = 0; i < k; i++) {\n            executorService.execute(new LatchRunnable());\n        }\n        LatchRunnable.latch.await(2, TimeUnit.MINUTES);\n\n        final Future<Boolean> f = executorService.submit(new SleepingTask(10000));\n        Thread.sleep(1000);\n        f.cancel(true);\n        try {\n            f.get();\n        } catch (CancellationException e) {\n        }\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(k + 1, stats.getStartedTaskCount());\n        assertEquals(k, stats.getCompletedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n        assertEquals(1, stats.getCancelledTaskCount());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSubmitToMemberRunnable() throws InterruptedException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if (response == null) {\n                    count.incrementAndGet();\n                }\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToMemberRunnable\");\n            final String script = \"if(!hazelcast.getCluster().getLocalMember().equals(member)) \" +\n                    \"hazelcast.getAtomicLong('testSubmitToMemberRunnable').incrementAndGet();\";\n            final HashMap map = new HashMap();\n            map.put(\"member\", instance.getCluster().getLocalMember());\n            service.submitToMember(new ScriptRunnable(script, map), instance.getCluster().getLocalMember(), callback);\n        }\n        assertOpenEventually(latch);\n        assertEquals(0, instances[0].getAtomicLong(\"testSubmitToMemberRunnable\").get());\n        assertEquals(k, count.get());\n    }","id":41788,"modified_method":"@Test\n    public void testSubmitToMemberRunnable() throws InterruptedException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if (response == null) {\n                    count.incrementAndGet();\n                }\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToMemberRunnable\");\n            final String script = \"if(!hazelcast.getCluster().getLocalMember().getUuid().equals(memberUUID)) \" +\n                    \"hazelcast.getAtomicLong('testSubmitToMemberRunnable').incrementAndGet();\";\n            final HashMap map = new HashMap();\n            map.put(\"memberUUID\", instance.getCluster().getLocalMember().getUuid());\n            service.submitToMember(new ScriptRunnable(script, map), instance.getCluster().getLocalMember(), callback);\n        }\n        assertOpenEventually(latch);\n        assertEquals(0, instances[0].getAtomicLong(\"testSubmitToMemberRunnable\").get());\n        assertEquals(k, count.get());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void hazelcastInstanceAwareAndLocal() throws Exception {\n        final Config config = new Config();\n        config.addExecutorConfig(new ExecutorConfig(\"test\", 1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        IExecutorService executor = instance.getExecutorService(\"test\");\n\n        HazelcastInstanceAwareRunnable task = new HazelcastInstanceAwareRunnable();\n        executor.submit(task).get();\n        assertTrue(\"The setHazelcastInstance should have been called\", task.initializeCalled);\n    }","id":41789,"modified_method":"@Test\n    public void hazelcastInstanceAwareAndLocal() throws Exception {\n        final Config config = new Config();\n        config.addExecutorConfig(new ExecutorConfig(\"test\", 1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        IExecutorService executor = instance.getExecutorService(\"test\");\n\n        HazelcastInstanceAwareRunnable task = new HazelcastInstanceAwareRunnable();\n        // if 'setHazelcastInstance' not called we expect a RuntimeException\n        executor.submit(task).get();\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSubmitToMemberCallable() throws ExecutionException, InterruptedException, TimeoutException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k / 2);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if ((Boolean) response)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToMemberCallable\");\n            final String script = \"hazelcast.getCluster().getLocalMember().equals(member); \";\n            final HashMap map = new HashMap();\n            map.put(\"member\", instance.getCluster().getLocalMember());\n            if (i % 2 == 0) {\n                final Future f = service.submitToMember(new ScriptCallable(script, map), instance.getCluster().getLocalMember());\n                assertTrue((Boolean) f.get(5, TimeUnit.SECONDS));\n            } else {\n                service.submitToMember(new ScriptCallable(script, map), instance.getCluster().getLocalMember(), callback);\n            }\n        }\n        assertTrue(latch.await(30, TimeUnit.SECONDS));\n        assertEquals(k / 2, count.get());\n    }","id":41790,"modified_method":"@Test\n    public void testSubmitToMemberCallable() throws ExecutionException, InterruptedException, TimeoutException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k / 2);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if ((Boolean) response)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToMemberCallable\");\n            final String script = \"hazelcast.getCluster().getLocalMember().getUuid().equals(memberUUID); \";\n            final HashMap map = new HashMap();\n            map.put(\"memberUUID\", instance.getCluster().getLocalMember().getUuid());\n            if (i % 2 == 0) {\n                final Future f = service.submitToMember(new ScriptCallable(script, map), instance.getCluster().getLocalMember());\n                assertTrue((Boolean) f.get(5, TimeUnit.SECONDS));\n            } else {\n                service.submitToMember(new ScriptCallable(script, map), instance.getCluster().getLocalMember(), callback);\n            }\n        }\n        assertTrue(latch.await(30, TimeUnit.SECONDS));\n        assertEquals(k / 2, count.get());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSubmitToKeyOwnerRunnable() throws InterruptedException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if (response == null)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToKeyOwnerRunnable\");\n            final String script = \"if(!hazelcast.getCluster().getLocalMember().equals(member)) \" +\n                    \"hazelcast.getAtomicLong('testSubmitToKeyOwnerRunnable').incrementAndGet();\";\n            final HashMap map = new HashMap();\n            map.put(\"member\", instance.getCluster().getLocalMember());\n            int key = 0;\n            while (!instance.getCluster().getLocalMember().equals(instance.getPartitionService().getPartition(++key).getOwner())) {\n                Thread.sleep(1);\n            }\n            service.submitToKeyOwner(new ScriptRunnable(script, map), key, callback);\n        }\n        assertOpenEventually(latch);\n        assertEquals(0, instances[0].getAtomicLong(\"testSubmitToKeyOwnerRunnable\").get());\n        assertEquals(k, count.get());\n    }","id":41791,"modified_method":"@Test\n    public void testSubmitToKeyOwnerRunnable() throws InterruptedException {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if (response == null)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToKeyOwnerRunnable\");\n            final String script = \"if(!hazelcast.getCluster().getLocalMember().getUuid().equals(memberUUID)) \" +\n                    \"hazelcast.getAtomicLong('testSubmitToKeyOwnerRunnable').incrementAndGet();\";\n            final HashMap map = new HashMap();\n            map.put(\"memberUUID\", instance.getCluster().getLocalMember().getUuid());\n            int key = 0;\n            while (!instance.getCluster().getLocalMember().equals(instance.getPartitionService().getPartition(++key).getOwner())) {\n                Thread.sleep(1);\n            }\n            service.submitToKeyOwner(new ScriptRunnable(script, map), key, callback);\n        }\n        assertOpenEventually(latch);\n        assertEquals(0, instances[0].getAtomicLong(\"testSubmitToKeyOwnerRunnable\").get());\n        assertEquals(k, count.get());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSubmitToKeyOwnerCallable() throws Exception {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k / 2);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if ((Boolean) response)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToKeyOwnerCallable\");\n            final String script = \"hazelcast.getCluster().getLocalMember().equals(member)\";\n            final HashMap map = new HashMap();\n            final Member localMember = instance.getCluster().getLocalMember();\n            map.put(\"member\", localMember);\n            int key = 0;\n            while (!localMember.equals(instance.getPartitionService().getPartition(++key).getOwner())) ;\n            if (i % 2 == 0) {\n                final Future f = service.submitToKeyOwner(new ScriptCallable(script, map), key);\n                assertTrue((Boolean) f.get(60, TimeUnit.SECONDS));\n            } else {\n                service.submitToKeyOwner(new ScriptCallable(script, map), key, callback);\n            }\n        }\n        assertOpenEventually(latch);\n        assertEquals(k / 2, count.get());\n    }","id":41792,"modified_method":"@Test\n    public void testSubmitToKeyOwnerCallable() throws Exception {\n        final int k = simpleTestNodeCount;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(new Config());\n        final AtomicInteger count = new AtomicInteger(0);\n        final CountDownLatch latch = new CountDownLatch(k / 2);\n        final ExecutionCallback callback = new ExecutionCallback() {\n            public void onResponse(Object response) {\n                if ((Boolean) response)\n                    count.incrementAndGet();\n                latch.countDown();\n            }\n\n            public void onFailure(Throwable t) {\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            final HazelcastInstance instance = instances[i];\n            final IExecutorService service = instance.getExecutorService(\"testSubmitToKeyOwnerCallable\");\n            final String script = \"hazelcast.getCluster().getLocalMember().getUuid().equals(memberUUID)\";\n            final HashMap map = new HashMap();\n            final Member localMember = instance.getCluster().getLocalMember();\n            map.put(\"memberUUID\", localMember.getUuid());\n            int key = 0;\n            while (!localMember.equals(instance.getPartitionService().getPartition(++key).getOwner())) ;\n            if (i % 2 == 0) {\n                final Future f = service.submitToKeyOwner(new ScriptCallable(script, map), key);\n                assertTrue((Boolean) f.get(60, TimeUnit.SECONDS));\n            } else {\n                service.submitToKeyOwner(new ScriptCallable(script, map), key, callback);\n            }\n        }\n        assertOpenEventually(latch);\n        assertEquals(k / 2, count.get());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void run() {\n        }","id":41793,"modified_method":"@Override\n        public void run() {\n            if (!initializeCalled) {\n                throw new RuntimeException(\"The setHazelcastInstance should have been called\");\n            }\n        }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testManagedContextAndLocal() throws Exception {\n        final Config config = new Config();\n        config.addExecutorConfig(new ExecutorConfig(\"test\", 1));\n        config.setManagedContext(new ManagedContext() {\n            @Override\n            public Object initialize(Object obj) {\n                if (obj instanceof RunnableWithManagedContext) {\n                    RunnableWithManagedContext task = (RunnableWithManagedContext) obj;\n                    task.initializeCalled = true;\n                }\n                return obj;\n            }\n        });\n\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        IExecutorService executor = instance.getExecutorService(\"test\");\n\n        RunnableWithManagedContext task = new RunnableWithManagedContext();\n        executor.submit(task).get();\n        assertTrue(\"The task should have been initialized by the ManagedContext\", task.initializeCalled);\n    }","id":41794,"modified_method":"@Test\n    public void testManagedContextAndLocal() throws Exception {\n        final Config config = new Config();\n        config.addExecutorConfig(new ExecutorConfig(\"test\", 1));\n        final AtomicBoolean initialized = new AtomicBoolean();\n        config.setManagedContext(new ManagedContext() {\n            @Override\n            public Object initialize(Object obj) {\n                if (obj instanceof RunnableWithManagedContext) {\n                    initialized.set(true);\n                }\n                return obj;\n            }\n        });\n\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        IExecutorService executor = instance.getExecutorService(\"test\");\n\n        RunnableWithManagedContext task = new RunnableWithManagedContext();\n        executor.submit(task).get();\n        assertTrue(\"The task should have been initialized by the ManagedContext\", initialized.get());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testStatsIssue2039() throws InterruptedException, ExecutionException, TimeoutException {\n        final Config config = new Config();\n        final String name = \"testStatsIssue2039\";\n        config.addExecutorConfig(new ExecutorConfig(name).setQueueCapacity(1).setPoolSize(1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IExecutorService executorService = instance.getExecutorService(name);\n\n        final CountDownLatch startLatch = new CountDownLatch(1);\n        final CountDownLatch sleepLatch = new CountDownLatch(1);\n\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                startLatch.countDown();\n                assertOpenEventually(sleepLatch);\n            }\n        });\n\n        assertTrue(startLatch.await(30, TimeUnit.SECONDS));\n        final Future waitingInQueue = executorService.submit(new Runnable() {\n            public void run() {\n            }\n        });\n\n        final Future rejected = executorService.submit(new Runnable() {\n            public void run() {\n            }\n        });\n\n        try {\n            rejected.get(1, TimeUnit.MINUTES);\n        } catch (Exception e) {\n            boolean isRejected = e.getCause() instanceof RejectedExecutionException;\n            if (!isRejected) {\n                fail(e.toString());\n            }\n        } finally {\n            sleepLatch.countDown();\n        }\n\n        waitingInQueue.get(1, TimeUnit.MINUTES);\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(2, stats.getStartedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n    }","id":41795,"modified_method":"@Test\n    public void testStatsIssue2039() throws InterruptedException, ExecutionException, TimeoutException {\n        final Config config = new Config();\n        final String name = \"testStatsIssue2039\";\n        config.addExecutorConfig(new ExecutorConfig(name).setQueueCapacity(1).setPoolSize(1));\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IExecutorService executorService = instance.getExecutorService(name);\n\n\n        executorService.execute(new SleepLatchRunnable());\n\n        assertTrue(SleepLatchRunnable.startLatch.await(30, TimeUnit.SECONDS));\n        final Future waitingInQueue = executorService.submit(new EmptyRunnable());\n\n        final Future rejected = executorService.submit(new EmptyRunnable());\n\n        try {\n            rejected.get(1, TimeUnit.MINUTES);\n        } catch (Exception e) {\n            boolean isRejected = e.getCause() instanceof RejectedExecutionException;\n            if (!isRejected) {\n                fail(e.toString());\n            }\n        } finally {\n            SleepLatchRunnable.sleepLatch.countDown();\n        }\n\n        waitingInQueue.get(1, TimeUnit.MINUTES);\n\n        final LocalExecutorStats stats = executorService.getLocalExecutorStats();\n        assertEquals(2, stats.getStartedTaskCount());\n        assertEquals(0, stats.getPendingTaskCount());\n    }","commit_id":"b47adb55c1ad244d9168146e200177e5567a83a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void onlineFilter() {\n      if (mySelectedProfile == null) return;\n      final String filter = getFilter();\n      if (filter != null && filter.length() > 0) {\n        if (!myExpansionMonitor.isFreeze()) {\n          myExpansionMonitor.freeze();\n        }\n      }\n      fillTreeData(filter, true);\n      ((DefaultTreeModel)myTree.getModel()).reload();\n      TreeUtil.expandAll(myTree);\n      if (filter == null || filter.length() == 0) {\n        TreeUtil.collapseAll(myTree, 0);\n        myExpansionMonitor.restore();\n      }\n    }","id":41796,"modified_method":"protected void onlineFilter() {\n      if (mySelectedProfile == null) return;\n      final String filter = getFilter();\n      if (filter != null && filter.length() > 0) {\n        if (!myExpansionMonitor.isFreeze()) {\n          myExpansionMonitor.freeze();\n        }\n      }\n      fillTreeData(filter, true);\n      reloadModel();\n      TreeUtil.expandAll(myTree);\n      if (filter == null || filter.length() == 0) {\n        TreeUtil.collapseAll(myTree, 0);\n        myExpansionMonitor.restore();\n      }\n    }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateSelectedProfileState() {\n    if (mySelectedProfile == null) return;\n    ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().restoreVisibleState(myTree);\n    repaintTableData();\n    final TreePath selectionPath = myTree.getSelectionPath();\n    if (selectionPath != null) {\n      TreeUtil.showRowCentered(myTree, myTree.getRowForPath(selectionPath), false);\n    }\n  }","id":41797,"modified_method":"private void updateSelectedProfileState() {\n    if (mySelectedProfile == null) return;\n    restoreTreeState();\n    repaintTableData();\n    final TreePath selectionPath = myTree.getSelectionPath();\n    if (selectionPath != null) {\n      TreeUtil.showRowCentered(myTree, myTree.getRowForPath(selectionPath), false);\n    }\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JScrollPane initTreeScrollPane() {\n\n    fillTreeData(null, true);\n\n    final MyTreeCellRenderer renderer = new MyTreeCellRenderer();\n    myTree = new Tree(myRoot) {\n      public Dimension getPreferredScrollableViewportSize() {\n        Dimension size = super.getPreferredScrollableViewportSize();\n        size = new Dimension(size.width + 10, size.height);\n        return size;\n      }\n\n      protected void processMouseEvent(MouseEvent e) {\n        if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n          int row = myTree.getRowForLocation(e.getX(), e.getY());\n          if (row >= 0) {\n            Rectangle rowBounds = myTree.getRowBounds(row);\n            renderer.setBounds(rowBounds);\n            Rectangle checkBounds = renderer.myCheckbox.getBounds();\n\n            checkBounds.setLocation(rowBounds.getLocation());\n\n            if (checkBounds.contains(e.getPoint())) {\n              MyTreeNode node = (MyTreeNode)myTree.getPathForRow(row).getLastPathComponent();\n              toggleNode(node);\n              myTree.setSelectionRow(row);\n            }\n          }\n        }\n        super.processMouseEvent(e);\n      }\n\n      public int getToggleClickCount() {\n        return -1;\n      }\n    };\n\n\n    myTree.setCellRenderer(renderer);\n    myTree.setRootVisible(true);\n    myTree.setShowsRootHandles(true);\n    UIUtil.setLineStyleAngled(myTree);\n    TreeToolTipHandler.install(myTree);\n    TreeUtil.installActions(myTree);\n\n    myTree.addKeyListener(new KeyAdapter() {\n      public void keyPressed(KeyEvent e) {\n        if (!e.isConsumed() && e.getKeyCode() == KeyEvent.VK_SPACE && !SpeedSearchBase.hasActiveSpeedSearch(myTree)) {\n          final int selectionRow = myTree.getLeadSelectionRow();\n          final int[] rows = myTree.getSelectionRows();\n          for (int i = 0; rows != null && i < rows.length; i++) {\n            final TreePath path = myTree.getPathForRow(rows[i]);\n            final MyTreeNode node = (MyTreeNode)path.getLastPathComponent();\n            if (Arrays.binarySearch(rows, myTree.getRowForPath(path.getParentPath())) < 0) {\n              toggleNode(node);\n            }\n          }\n          myTree.setSelectionRow(selectionRow);\n          e.consume();\n        }\n      }\n    });\n\n    myTree.addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        if (myTree.getSelectionPaths() != null && myTree.getSelectionPaths().length == 1) {\n          updateOptionsAndDescriptionPanel(myTree.getSelectionPaths()[0]);\n        }\n        else {\n          initOptionsAndDescriptionPanel();\n        }\n      }\n    });\n\n\n    myTree.addMouseListener(new PopupHandler() {\n      public void invokePopup(Component comp, int x, int y) {\n        if (myTree.getPathForLocation(x, y) != null && Arrays.binarySearch(myTree.getSelectionRows(), myTree.getRowForLocation(x, y)) > -1)\n        {\n          compoundPopup().show(comp, x, y);\n        }\n      }\n    });\n\n\n    new TreeSpeedSearch(myTree, new Convertor<TreePath, String>() {\n      public String convert(TreePath o) {\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)o.getLastPathComponent();\n        final Object userObject = node.getUserObject();\n        if (userObject instanceof Descriptor) {\n          return getDisplayTextToSort(((Descriptor)userObject).getText());\n        }\n        return getDisplayTextToSort(userObject.toString());\n      }\n    });\n\n\n    myTree.setSelectionModel(new DefaultTreeSelectionModel());\n\n    final JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTree);\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    TreeUtil.collapseAll(myTree, 1);\n    final Dimension preferredSize = new Dimension(myTree.getPreferredSize().width + 20, scrollPane.getPreferredSize().height);\n    scrollPane.setPreferredSize(preferredSize);\n    scrollPane.setMinimumSize(preferredSize);\n\n    myTree.addTreeExpansionListener(new TreeExpansionListener() {\n      private String getExpandedString(TreePath treePath) {\n        final Object userObject = ((DefaultMutableTreeNode)treePath.getLastPathComponent()).getUserObject();\n        if (userObject instanceof Descriptor) {\n          return ((Descriptor)userObject).getText();\n        }\n        else {\n          return (String)userObject;\n        }\n      }\n\n      public void treeCollapsed(TreeExpansionEvent event) {\n        InspectionProfileImpl selected = (InspectionProfileImpl)mySelectedProfile;\n        String nodeTitle = getExpandedString(event.getPath());\n        ((InspectionProfileImpl)selected.getParentProfile()).getExpandedNodes().collapseNode(nodeTitle);\n        selected.getExpandedNodes().collapseNode(nodeTitle);\n      }\n\n      public void treeExpanded(TreeExpansionEvent event) {\n        InspectionProfileImpl selected = (InspectionProfileImpl)mySelectedProfile;\n        String nodeTitle = getExpandedString(event.getPath());\n        ((InspectionProfileImpl)selected.getParentProfile()).getExpandedNodes().expandNode(nodeTitle);\n        selected.getExpandedNodes().expandNode(nodeTitle);\n      }\n    });\n\n    myTreeExpander = new DefaultTreeExpander(myTree);\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        myTree.requestFocus();\n      }\n    });\n\n    myProfileFilter = new MyFilterComponent();\n\n    return scrollPane;\n  }","id":41798,"modified_method":"private JScrollPane initTreeScrollPane() {\n\n    fillTreeData(null, true);\n\n    final MyTreeCellRenderer renderer = new MyTreeCellRenderer();\n    myTree = new Tree(myRoot) {\n      public Dimension getPreferredScrollableViewportSize() {\n        Dimension size = super.getPreferredScrollableViewportSize();\n        size = new Dimension(size.width + 10, size.height);\n        return size;\n      }\n\n      protected void processMouseEvent(MouseEvent e) {\n        if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n          int row = myTree.getRowForLocation(e.getX(), e.getY());\n          if (row >= 0) {\n            Rectangle rowBounds = myTree.getRowBounds(row);\n            renderer.setBounds(rowBounds);\n            Rectangle checkBounds = renderer.myCheckbox.getBounds();\n\n            checkBounds.setLocation(rowBounds.getLocation());\n\n            if (checkBounds.contains(e.getPoint())) {\n              MyTreeNode node = (MyTreeNode)myTree.getPathForRow(row).getLastPathComponent();\n              toggleNode(node);\n              myTree.setSelectionRow(row);\n            }\n          }\n        }\n        super.processMouseEvent(e);\n      }\n\n      public int getToggleClickCount() {\n        return -1;\n      }\n    };\n\n\n    myTree.setCellRenderer(renderer);\n    myTree.setRootVisible(true);\n    myTree.setShowsRootHandles(true);\n    UIUtil.setLineStyleAngled(myTree);\n    TreeToolTipHandler.install(myTree);\n    TreeUtil.installActions(myTree);\n\n    myTree.addKeyListener(new KeyAdapter() {\n      public void keyPressed(KeyEvent e) {\n        if (!e.isConsumed() && e.getKeyCode() == KeyEvent.VK_SPACE && !SpeedSearchBase.hasActiveSpeedSearch(myTree)) {\n          final int selectionRow = myTree.getLeadSelectionRow();\n          final int[] rows = myTree.getSelectionRows();\n          for (int i = 0; rows != null && i < rows.length; i++) {\n            final TreePath path = myTree.getPathForRow(rows[i]);\n            final MyTreeNode node = (MyTreeNode)path.getLastPathComponent();\n            if (Arrays.binarySearch(rows, myTree.getRowForPath(path.getParentPath())) < 0) {\n              toggleNode(node);\n            }\n          }\n          myTree.setSelectionRow(selectionRow);\n          e.consume();\n        }\n      }\n    });\n\n    myTree.addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        if (myTree.getSelectionPaths() != null && myTree.getSelectionPaths().length == 1) {\n          updateOptionsAndDescriptionPanel(myTree.getSelectionPaths()[0]);\n        }\n        else {\n          initOptionsAndDescriptionPanel();\n        }\n\n        if (!myIsInRestore) {\n          InspectionProfileImpl selected = (InspectionProfileImpl)mySelectedProfile;\n          ((InspectionProfileImpl)selected.getParentProfile()).getExpandedNodes().setSelectionPaths(myTree.getSelectionPaths());\n          selected.getExpandedNodes().setSelectionPaths(myTree.getSelectionPaths());\n        }\n\n      }\n    });\n\n\n    myTree.addMouseListener(new PopupHandler() {\n      public void invokePopup(Component comp, int x, int y) {\n        if (myTree.getPathForLocation(x, y) != null && Arrays.binarySearch(myTree.getSelectionRows(), myTree.getRowForLocation(x, y)) > -1)\n        {\n          compoundPopup().show(comp, x, y);\n        }\n      }\n    });\n\n\n    new TreeSpeedSearch(myTree, new Convertor<TreePath, String>() {\n      public String convert(TreePath o) {\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)o.getLastPathComponent();\n        final Object userObject = node.getUserObject();\n        if (userObject instanceof Descriptor) {\n          return getDisplayTextToSort(((Descriptor)userObject).getText());\n        }\n        return getDisplayTextToSort(userObject.toString());\n      }\n    });\n\n\n    myTree.setSelectionModel(new DefaultTreeSelectionModel());\n\n    final JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTree);\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    TreeUtil.collapseAll(myTree, 1);\n    final Dimension preferredSize = new Dimension(myTree.getPreferredSize().width + 20, scrollPane.getPreferredSize().height);\n    scrollPane.setPreferredSize(preferredSize);\n    scrollPane.setMinimumSize(preferredSize);\n\n    myTree.addTreeExpansionListener(new TreeExpansionListener() {\n      private String getExpandedString(TreePath treePath) {\n        final Object userObject = ((DefaultMutableTreeNode)treePath.getLastPathComponent()).getUserObject();\n        if (userObject instanceof Descriptor) {\n          return ((Descriptor)userObject).getText();\n        }\n        else {\n          return (String)userObject;\n        }\n      }\n\n      public void treeCollapsed(TreeExpansionEvent event) {\n        InspectionProfileImpl selected = (InspectionProfileImpl)mySelectedProfile;\n        String nodeTitle = getExpandedString(event.getPath());\n        ((InspectionProfileImpl)selected.getParentProfile()).getExpandedNodes().collapseNode(nodeTitle);\n        selected.getExpandedNodes().collapseNode(nodeTitle);\n      }\n\n      public void treeExpanded(TreeExpansionEvent event) {\n        InspectionProfileImpl selected = (InspectionProfileImpl)mySelectedProfile;\n        String nodeTitle = getExpandedString(event.getPath());\n        ((InspectionProfileImpl)selected.getParentProfile()).getExpandedNodes().expandNode(nodeTitle);\n        selected.getExpandedNodes().expandNode(nodeTitle);\n      }\n    });\n\n    myTreeExpander = new DefaultTreeExpander(myTree);\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        myTree.requestFocus();\n      }\n    });\n\n    myProfileFilter = new MyFilterComponent();\n\n    return scrollPane;\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void filterTree(String filter) {\n    if (myTree != null) {\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().saveVisibleState(myTree);\n      fillTreeData(filter, true);\n      ((DefaultTreeModel)myTree.getModel()).reload();\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().restoreVisibleState(myTree);\n      if (myTree.getSelectionPath() == null) {\n        TreeUtil.selectFirstNode(myTree);\n      }\n    }\n  }","id":41799,"modified_method":"public void filterTree(String filter) {\n    if (myTree != null) {\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().saveVisibleState(myTree);\n      fillTreeData(filter, true);\n      reloadModel();\n      restoreTreeState();\n      if (myTree.getSelectionPath() == null) {\n        TreeUtil.selectFirstNode(myTree);\n      }\n    }\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void toggleNode(MyTreeNode node) {\n    List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myTree);\n    node.isEnabled = !node.isEnabled;\n    Object userObject = node.getUserObject();\n    final MyTreeNode parent = (MyTreeNode)node.getParent();\n    if (userObject instanceof Descriptor) {\n      toggleToolNode(node);\n    }\n    else {\n      final Enumeration children = node.children();\n      node.isProperSetting = false;\n      while (children.hasMoreElements()) {\n        MyTreeNode child = (MyTreeNode)children.nextElement();\n        child.isEnabled = node.isEnabled;\n        child.isProperSetting = false;\n        if (child.getUserObject()instanceof Descriptor) {\n          toggleToolNode(child);\n        }\n        else {\n          final Enumeration descriptorNodes = child.children();\n          while (descriptorNodes.hasMoreElements()) {\n            MyTreeNode descriptorNode = (MyTreeNode)descriptorNodes.nextElement();\n            descriptorNode.isEnabled = child.isEnabled;\n            if (descriptorNode.getUserObject()instanceof Descriptor) {\n              toggleToolNode(descriptorNode);\n            }\n            child.isProperSetting |= descriptorNode.isProperSetting;\n          }\n        }\n        node.isProperSetting |= child.isProperSetting;\n      }\n    }\n    updateUpHierarchy(node, parent);\n    ((DefaultTreeModel)myTree.getModel()).reload();\n    updateOptionsAndDescriptionPanel(new TreePath(node.getPath()));\n    TreeUtil.restoreExpandedPaths(myTree, expandedPaths);\n  }","id":41800,"modified_method":"private void toggleNode(MyTreeNode node) {\n    List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myTree);\n    node.isEnabled = !node.isEnabled;\n    Object userObject = node.getUserObject();\n    final MyTreeNode parent = (MyTreeNode)node.getParent();\n    if (userObject instanceof Descriptor) {\n      toggleToolNode(node);\n    }\n    else {\n      final Enumeration children = node.children();\n      node.isProperSetting = false;\n      while (children.hasMoreElements()) {\n        MyTreeNode child = (MyTreeNode)children.nextElement();\n        child.isEnabled = node.isEnabled;\n        child.isProperSetting = false;\n        if (child.getUserObject()instanceof Descriptor) {\n          toggleToolNode(child);\n        }\n        else {\n          final Enumeration descriptorNodes = child.children();\n          while (descriptorNodes.hasMoreElements()) {\n            MyTreeNode descriptorNode = (MyTreeNode)descriptorNodes.nextElement();\n            descriptorNode.isEnabled = child.isEnabled;\n            if (descriptorNode.getUserObject()instanceof Descriptor) {\n              toggleToolNode(descriptorNode);\n            }\n            child.isProperSetting |= descriptorNode.isProperSetting;\n          }\n        }\n        node.isProperSetting |= child.isProperSetting;\n      }\n    }\n    updateUpHierarchy(node, parent);\n    reloadModel();\n    updateOptionsAndDescriptionPanel(new TreePath(node.getPath()));\n    TreeUtil.restoreExpandedPaths(myTree, expandedPaths);\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void repaintTableData() {\n    if (myTree != null) {\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().saveVisibleState(myTree);\n      ((DefaultTreeModel)myTree.getModel()).reload();\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().restoreVisibleState(myTree);\n    }\n  }","id":41801,"modified_method":"private void repaintTableData() {\n    if (myTree != null) {\n      ((InspectionProfileImpl)mySelectedProfile).getExpandedNodes().saveVisibleState(myTree);\n      reloadModel();\n      restoreTreeState();\n    }\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveVisibleState(Tree tree) {\n    myExpandedNodes.clear();\n    final DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode)tree.getModel().getRoot();\n    Enumeration<TreePath> expanded = tree.getExpandedDescendants(new TreePath(rootNode.getPath()));\n    if (expanded != null) {\n      while (expanded.hasMoreElements()) {\n        final TreePath treePath = expanded.nextElement();\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n        String expandedNode;\n        if (node.getUserObject() instanceof Descriptor) {\n          expandedNode = ((Descriptor)node.getUserObject()).getKey().toString();\n        }\n        else {\n          expandedNode = (String)node.getUserObject();\n        }\n        myExpandedNodes.add(expandedNode);\n      }\n    }\n    mySelectedNodes.clear();\n    final TreePath[] selectionPaths = tree.getSelectionPaths();\n    for (int i = 0; selectionPaths != null && i < selectionPaths.length; i++) {\n      final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPaths[i].getLastPathComponent();\n      String selectedNode;\n      if (node.getUserObject() instanceof Descriptor) {\n        selectedNode = ((Descriptor)node.getUserObject()).getKey().toString();\n      }\n      else {\n        selectedNode = (String)node.getUserObject();\n      }\n      mySelectedNodes.add(selectedNode);\n    }\n  }","id":41802,"modified_method":"public void saveVisibleState(Tree tree) {\n    myExpandedNodes.clear();\n    final DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode)tree.getModel().getRoot();\n    Enumeration<TreePath> expanded = tree.getExpandedDescendants(new TreePath(rootNode.getPath()));\n    if (expanded != null) {\n      while (expanded.hasMoreElements()) {\n        final TreePath treePath = expanded.nextElement();\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n        String expandedNode;\n        if (node.getUserObject() instanceof Descriptor) {\n          expandedNode = ((Descriptor)node.getUserObject()).getKey().toString();\n        }\n        else {\n          expandedNode = (String)node.getUserObject();\n        }\n        myExpandedNodes.add(expandedNode);\n      }\n    }\n\n    setSelectionPaths(tree.getSelectionPaths());\n  }","commit_id":"8a80ba07b99fcf91b8dc7e1a98999ed6b2a37715","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getSelectedProblemCount() {\n    if (getSelectionCount() == 0) return 0;\n    final TreePath[] paths = getSelectionPaths();\n    LOG.assertTrue(paths != null);\n    Set<InspectionTreeNode> result = new HashSet<>();\n    MultiMap<InspectionTreeNode, InspectionTreeNode> rootDependencies = new MultiMap<>();\n    for (TreePath path : paths) {\n\n      final InspectionTreeNode node = (InspectionTreeNode)path.getLastPathComponent();\n      final Collection<InspectionTreeNode> visitedChildren = rootDependencies.get(node);\n      for (InspectionTreeNode child : visitedChildren) {\n        result.remove(child);\n      }\n\n      boolean needToAdd = true;\n      for (int i = 0; i < path.getPathCount() - 1; i++) {\n        final InspectionTreeNode parent = (InspectionTreeNode) path.getPathComponent(i);\n        rootDependencies.putValue(parent, node);\n        if (result.contains(parent)) {\n          needToAdd = false;\n          break;\n        }\n      }\n\n      if (needToAdd) {\n        result.add(node);\n      }\n    }\n\n    int count = 0;\n    for (InspectionTreeNode node : result) {\n      count += node.getProblemCount();\n    }\n    return count;\n  }","id":41803,"modified_method":"public int getSelectedProblemCount() {\n    int count = 0;\n    for (TreePath path : TreeUtil.selectMaximals(getSelectionPaths())) {\n      count += ((InspectionTreeNode)path.getLastPathComponent()).getProblemCount();\n    }\n    return count;\n  }","commit_id":"459edd9fb07eaf8f3a09bd7064469b4d8f371dfc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Change[] getSelectedChanges() {\n    Set<Change> changes = new LinkedHashSet<Change>();\n\n    final TreePath[] paths = getSelectionPaths();\n    if (paths == null) {\n      return new Change[0];\n    }\n\n    for (TreePath path : paths) {\n      ChangesBrowserNode<?> node = (ChangesBrowserNode)path.getLastPathComponent();\n      changes.addAll(node.getAllChangesUnder());\n    }\n\n    if (changes.isEmpty()) {\n      final List<VirtualFile> selectedModifiedWithoutEditing = getSelectedModifiedWithoutEditing();\n      if (selectedModifiedWithoutEditing != null && !selectedModifiedWithoutEditing.isEmpty()) {\n        for(VirtualFile file: selectedModifiedWithoutEditing) {\n          AbstractVcs vcs = ProjectLevelVcsManager.getInstance(myProject).getVcsFor(file);\n          if (vcs == null) continue;\n          final VcsCurrentRevisionProxy before =\n            VcsCurrentRevisionProxy.create(file, myProject, vcs.getKeyInstanceMethod());\n          if (before != null) {\n            ContentRevision afterRevision = new CurrentContentRevision(VcsUtil.getFilePath(file));\n            changes.add(new Change(before, afterRevision, FileStatus.HIJACKED));\n          }\n        }\n      }\n    }\n\n    return changes.toArray(new Change[changes.size()]);\n  }","id":41804,"modified_method":"@NotNull\n  public Change[] getSelectedChanges() {\n    return getChanges(myProject, getSelectionPaths());\n  }","commit_id":"3b8ff57f0cb69d8e683b0c3971ea25010a00a677","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyIfStatement ifStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyIfStatement.class, \"if True:\\n    \\nelse:\\n\");\n    final PsiElement parent = elements[0].getParent();\n    ifStatement.getIfPart().addRange(elements[0], elements[elements.length - 1]);\n    ifStatement = (PyIfStatement) parent.addBefore(ifStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    ifStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(ifStatement);\n    if (ifStatement == null) {\n      return null;\n    }\n    return ifStatement.getTextRange();\n  }","id":41805,"modified_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyIfStatement ifStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyIfStatement.class, \"if True:\\n    pass\\nelse:    pass\\n\");\n    final PsiElement parent = elements[0].getParent();\n    final PyStatementList statementList = ifStatement.getIfPart().getStatementList();\n    assert statementList != null;\n    statementList.addRange(elements[0], elements[elements.length - 1]);\n    statementList.deleteChildRange(statementList.getFirstChild(), statementList.getFirstChild());\n\n    ifStatement = (PyIfStatement) parent.addBefore(ifStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    ifStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(ifStatement);\n    if (ifStatement == null) {\n      return null;\n    }\n    return ifStatement.getTextRange();\n  }","commit_id":"77a3189d40bfcac007d99ac8b9f888dbae32ad07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyIfStatement ifStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyIfStatement.class, \"if True:\\n    \");\n    final PsiElement parent = elements[0].getParent();\n    ifStatement.getIfPart().addRange(elements[0], elements[elements.length - 1]);\n    ifStatement = (PyIfStatement) parent.addBefore(ifStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    ifStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(ifStatement);\n    if (ifStatement == null) {\n      return null;\n    }\n    return ifStatement.getTextRange();\n  }","id":41806,"modified_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyIfStatement ifStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyIfStatement.class, \"if True:\\n    \");\n    final PsiElement parent = elements[0].getParent();\n    final PyStatementList statementList = ifStatement.getIfPart().getStatementList();\n    assert statementList != null;\n    statementList.addRange(elements[0], elements[elements.length - 1]);\n    ifStatement = (PyIfStatement) parent.addBefore(ifStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    ifStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(ifStatement);\n    if (ifStatement == null) {\n      return null;\n    }\n    return ifStatement.getIfPart().getCondition().getTextRange();\n  }","commit_id":"77a3189d40bfcac007d99ac8b9f888dbae32ad07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyTryExceptStatement tryStatement = PythonLanguage.getInstance().getElementGenerator()\n      .createFromText(project, PyTryExceptStatement.class, \"try:\\n    \\nexcept Exception:\\n\");\n    final PsiElement parent = elements[0].getParent();\n    tryStatement.getTryPart().addRange(elements[0], elements[elements.length - 1]);\n    tryStatement = (PyTryExceptStatement)parent.addBefore(tryStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    tryStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(tryStatement);\n    if (tryStatement == null) {\n      return null;\n    }\n    return tryStatement.getTextRange();\n  }","id":41807,"modified_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyTryExceptStatement tryStatement = PythonLanguage.getInstance().getElementGenerator()\n      .createFromText(project, PyTryExceptStatement.class, \"try:\\n    pass\\nexcept:\\n    pass\");\n    final PsiElement parent = elements[0].getParent();\n    final PyStatementList statementList = tryStatement.getTryPart().getStatementList();\n    assert statementList != null;\n    statementList.addRange(elements[0], elements[elements.length - 1]);\n    statementList.getFirstChild().delete();\n    tryStatement = (PyTryExceptStatement)parent.addBefore(tryStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    tryStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(tryStatement);\n    if (tryStatement == null) {\n      return null;\n    }\n    return tryStatement.getTextRange();\n  }","commit_id":"77a3189d40bfcac007d99ac8b9f888dbae32ad07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyWhileStatement whileStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyWhileStatement.class, \"while True:\\n    \");\n    final PsiElement parent = elements[0].getParent();\n    whileStatement.addRange(elements[0], elements[elements.length - 1]);\n    whileStatement = (PyWhileStatement) parent.addBefore(whileStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    whileStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(whileStatement);\n    if (whileStatement == null) {\n      return null;\n    }\n    return whileStatement.getTextRange();\n  }","id":41808,"modified_method":"@Override\n  @Nullable\n  protected TextRange surroundStatement(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n    throws IncorrectOperationException {\n    PyWhileStatement whileStatement =\n      PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyWhileStatement.class, \"while True:\\n    \");\n    final PsiElement parent = elements[0].getParent();\n    final PyStatementList statementList = whileStatement.getWhilePart().getStatementList();\n    assert statementList != null;\n    statementList.addRange(elements[0], elements[elements.length - 1]);\n    whileStatement = (PyWhileStatement) parent.addBefore(whileStatement, elements[0]);\n    parent.deleteChildRange(elements[0], elements[elements.length - 1]);\n\n    whileStatement = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(whileStatement);\n    if (whileStatement == null) {\n      return null;\n    }\n    final PyExpression condition = whileStatement.getWhilePart().getCondition();\n    assert condition != null;\n    return condition.getTextRange();\n  }","commit_id":"77a3189d40bfcac007d99ac8b9f888dbae32ad07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public FormattingModel createModel(final PsiElement element, final CodeStyleSettings settings) {\n    if (DUMP_FORMATTING_AST) {\n      ASTNode fileNode = element.getContainingFile().getNode();\n      System.out.println(\"AST tree for \" + element.getContainingFile().getName() + \":\");\n      printAST(fileNode, 0);\n    }\n    final PyBlock block = new PyBlock((PythonLanguage)PythonFileType.INSTANCE.getLanguage(),\n                                      element.getNode(), null, Indent.getNoneIndent(), null, settings);\n    return FormattingModelProvider.createFormattingModelForPsiFile(element.getContainingFile(), block, settings);\n  }","id":41809,"modified_method":"@NotNull\n  public FormattingModel createModel(final PsiElement element, final CodeStyleSettings settings) {\n    if (DUMP_FORMATTING_AST) {\n      ASTNode fileNode = element.getContainingFile().getNode();\n      System.out.println(\"AST tree for \" + element.getContainingFile().getName() + \":\");\n      printAST(fileNode, 0);\n    }\n    final PyBlock block = new PyBlock((PythonLanguage)PythonFileType.INSTANCE.getLanguage(),\n                                      element.getNode(), null, Indent.getNoneIndent(), null, settings);\n    FormattingModelDumper.dumpFormattingModel(block, 2, System.out);\n    return FormattingModelProvider.createFormattingModelForPsiFile(element.getContainingFile(), block, settings);\n  }","commit_id":"77a3189d40bfcac007d99ac8b9f888dbae32ad07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyBinaryExpression element = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyBinaryExpression.class);\n    while (element.getParent() instanceof PyBinaryExpression) {\n      element = (PyBinaryExpression)element.getParent();\n    }\n    PyIfStatement ifStatement = PsiTreeUtil.getParentOfType(element, PyIfStatement.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    StringBuilder builder = new StringBuilder();\n  \n    builder.append(\"if \").append(element.getLeftExpression().getText()).append(\":\\n\");\n    builder.append(\"    if \").append(element.getRightExpression().getText()).append(\":\");\n    appendStatements(ifStatement.getIfPart().getStatementList(), builder);\n    final PyIfPart[] elifParts = ifStatement.getElifParts();\n    for (PyIfPart elifPart: elifParts) {\n      builder.append(\"\\n    elif \").append(elifPart.getCondition().getText()).append(\":\");\n      appendStatements(elifPart.getStatementList(), builder);\n    }\n    final PyElsePart elsePart = ifStatement.getElsePart();\n    if (elsePart != null) {\n      builder.append(\"\\n    else:\");\n      appendStatements(elsePart.getStatementList(), builder);\n    }\n    ifStatement.getIfPart().replace(elementGenerator.createFromText(PyIfStatement.class, builder.toString()));\n  }","id":41810,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyBinaryExpression element = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyBinaryExpression.class);\n    while (element.getParent() instanceof PyBinaryExpression) {\n      element = (PyBinaryExpression)element.getParent();\n    }\n    PyIfStatement ifStatement = PsiTreeUtil.getParentOfType(element, PyIfStatement.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    \n    PyIfStatement subIf = (PyIfStatement) ifStatement.copy();\n    subIf.getIfPart().getCondition().replace(element.getRightExpression());\n    ifStatement.getIfPart().getCondition().replace(element.getLeftExpression());\n    PyStatementList statementList = elementGenerator.createFromText(PyIfStatement.class, \"if a:\\n    a = 1\").getIfPart().getStatementList();\n    statementList.getStatements()[0].replace(subIf);\n    ifStatement.getIfPart().getStatementList().replace(statementList);\n  }","commit_id":"3a09ce5eb8418d8b2787564f5e5db25b24b06543","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Set<String> getMembers( String idAttrName, String memberAttrName, Attributes attrs ) throws NamingException {\n    Set<String> members = Sets.newHashSet( );\n    Attribute membersAttr = attrs.get( memberAttrName );\n    if ( membersAttr != null ) {\n      NamingEnumeration<?> names = membersAttr.getAll( );\n\t  while ( names.hasMore( ) ) {\n\t    members.add( parseMemberName( idAttrName, ( String ) names.next( ) ).toLowerCase( ) );\n\t  }\n    }\n    return members;\n  }","id":41811,"modified_method":"private static Set<String> getMembers( String idAttrName, String memberAttrName, Attributes attrs ) throws NamingException {\n    Set<String> members = Sets.newHashSet( );\n    Attribute membersAttr = attrs.get( memberAttrName );\n    if ( membersAttr != null ) {\n      NamingEnumeration<?> names = membersAttr.getAll( );\n      while ( names.hasMore( ) ) {\n        members.add( parseMemberName( idAttrName, ( ( String ) names.next( ) ).toLowerCase( ) ).toLowerCase( ) );\n      }\n    }\n    return members;\n  }","commit_id":"ade89afc240f6cd41e082f06bca2a1c7c6e00a09","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static String getAttrWithNullCheck( Attributes attrs, String attrName ) throws NamingException {\n\tAttribute attr = attrs.get( attrName );\n\tif ( attr != null ) {\n      return ( String ) attr.get( );\n\t}\n\treturn null;\n  }","id":41812,"modified_method":"private static String getAttrWithNullCheck( Attributes attrs, String attrName ) throws NamingException {\n    Attribute attr = attrs.get( attrName );\n    if ( attr != null ) {\n      return ( ( String ) attr.get( ) ).toLowerCase( );\n    }\n    return null;\n  }","commit_id":"ade89afc240f6cd41e082f06bca2a1c7c6e00a09","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void parseGroups( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject groups = JsonUtils.getRequiredByType( JSONObject.class, licJson, LicSpec.GROUPS );\n    lic.setGroupBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, groups, LicSpec.GROUP_BASE_DN ) ) );\n    lic.setGroupsSelection( parseSelection( JsonUtils.getByType( JSONObject.class, groups, LicSpec.SELECTION ) ) );\n    lic.setGroupIdAttribute( JsonUtils.getRequiredByType( String.class, groups, LicSpec.ID_ATTRIBUTE ) );\n    lic.setUsersAttribute( JsonUtils.getRequiredByType( String.class, groups, LicSpec.USERS_ATTRIBUTE ) );\n  }","id":41813,"modified_method":"private void parseGroups( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject groups = JsonUtils.getRequiredByType( JSONObject.class, licJson, LicSpec.GROUPS );\n    lic.setGroupBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, groups, LicSpec.GROUP_BASE_DN ) ) );\n    lic.setGroupsSelection( parseSelection( JsonUtils.getByType( JSONObject.class, groups, LicSpec.SELECTION ) ) );\n    lic.setGroupIdAttribute( JsonUtils.getRequiredByType( String.class, groups, LicSpec.ID_ATTRIBUTE ).toLowerCase( ) );\n    lic.setUsersAttribute( JsonUtils.getRequiredByType( String.class, groups, LicSpec.USERS_ATTRIBUTE ) );\n  }","commit_id":"ade89afc240f6cd41e082f06bca2a1c7c6e00a09","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void parseUsers( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject users = JsonUtils.getRequiredByType( JSONObject.class, licJson, LicSpec.USERS );\n    lic.setUserBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, users, LicSpec.USER_BASE_DN ) ) );\n    lic.setUsersSelection( parseSelection( JsonUtils.getByType( JSONObject.class, users, LicSpec.SELECTION ) ) );\n    lic.setUserIdAttribute( JsonUtils.getRequiredByType( String.class, users, LicSpec.ID_ATTRIBUTE ) );\n    parseUserInfoMap( ( JSONObject ) JsonUtils.getByType( JSONObject.class, users, LicSpec.USER_INFO_ATTRIBUTES ), lic );\n  }","id":41814,"modified_method":"private void parseUsers( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject users = JsonUtils.getRequiredByType( JSONObject.class, licJson, LicSpec.USERS );\n    lic.setUserBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, users, LicSpec.USER_BASE_DN ) ) );\n    lic.setUsersSelection( parseSelection( JsonUtils.getByType( JSONObject.class, users, LicSpec.SELECTION ) ) );\n    lic.setUserIdAttribute( JsonUtils.getRequiredByType( String.class, users, LicSpec.ID_ATTRIBUTE ).toLowerCase( ) );\n    parseUserInfoMap( ( JSONObject ) JsonUtils.getByType( JSONObject.class, users, LicSpec.USER_INFO_ATTRIBUTES ), lic );\n  }","commit_id":"ade89afc240f6cd41e082f06bca2a1c7c6e00a09","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void parseAccountingGroups( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject accountingGroups = JsonUtils.getByType( JSONObject.class, licJson, LicSpec.ACCOUNTING_GROUPS );\n    lic.setAccountingGroupBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.ACCOUNTING_GROUP_BASE_DN ) ) );\n    lic.setAccountingGroupsSelection( parseSelection( JsonUtils.getByType( JSONObject.class, accountingGroups, LicSpec.SELECTION ) ) );\n    lic.setAccountingGroupIdAttribute( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.ID_ATTRIBUTE ) );\n    lic.setGroupsAttribute( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.GROUPS_ATTRIBUTE ) );\n  }","id":41815,"modified_method":"private void parseAccountingGroups( JSONObject licJson, LdapIntegrationConfiguration lic ) throws JSONException {\n    JSONObject accountingGroups = JsonUtils.getByType( JSONObject.class, licJson, LicSpec.ACCOUNTING_GROUPS );\n    lic.setAccountingGroupBaseDn( validateNonEmpty( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.ACCOUNTING_GROUP_BASE_DN ) ) );\n    lic.setAccountingGroupsSelection( parseSelection( JsonUtils.getByType( JSONObject.class, accountingGroups, LicSpec.SELECTION ) ) );\n    lic.setAccountingGroupIdAttribute( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.ID_ATTRIBUTE ).toLowerCase( ) );\n    lic.setGroupsAttribute( JsonUtils.getRequiredByType( String.class, accountingGroups, LicSpec.GROUPS_ATTRIBUTE ) );\n  }","commit_id":"ade89afc240f6cd41e082f06bca2a1c7c6e00a09","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Map<String, String> getParameters(\n\t\t\tJSONArray parametersJSONArray)\n\t\tthrows Exception {\n\n\t\tMap<String, String> parameters = new HashMap<>();\n\n\t\tfor (int i = 0; i < parametersJSONArray.length(); i++) {\n\t\t\tJSONObject parameter = parametersJSONArray.getJSONObject(i);\n\n\t\t\tif (parameter.opt(\"value\") instanceof String) {\n\t\t\t\tString name = parameter.getString(\"name\");\n\t\t\t\tString value = parameter.getString(\"value\");\n\n\t\t\t\tparameters.put(name, value);\n\t\t\t}\n\t\t}\n\n\t\treturn parameters;\n\t}","id":41816,"modified_method":"protected Map<String, String> getParameters(JSONArray jsonArray)\n\t\tthrows Exception {\n\n\t\tMap<String, String> parameters = new HashMap<>();\n\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\n\t\t\tJSONObject jsonObject = jsonArray.getJSONObject(i);\n\n\t\t\tif (jsonObject.opt(\"value\") instanceof String) {\n\t\t\t\tString name = jsonObject.getString(\"name\");\n\t\t\t\tString value = jsonObject.getString(\"value\");\n\n\t\t\t\tparameters.put(name, value);\n\t\t\t}\n\t\t}\n\n\t\treturn parameters;\n\t}","commit_id":"e2b5e236dd6effcae06e80c0bcb8530635b0ee42","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Map<String, String> getParameters(JSONObject buildJSONObject)\n\t\tthrows Exception {\n\n\t\tJSONArray actionsJSONArray = buildJSONObject.getJSONArray(\"actions\");\n\n\t\tif ((actionsJSONArray.length() > 0) &&\n\t\t\tactionsJSONArray.getJSONObject(0).has(\"parameters\")) {\n\n\t\t\tJSONArray parametersJSONArray = actionsJSONArray.getJSONObject(\n\t\t\t\t0).getJSONArray(\"parameters\");\n\n\t\t\treturn getParameters(parametersJSONArray);\n\t\t}\n\n\t\treturn new HashMap<>();\n\t}","id":41817,"modified_method":"protected Map<String, String> getParameters(JSONObject buildJSONObject)\n\t\tthrows Exception {\n\n\t\tJSONArray actionsJSONArray = buildJSONObject.getJSONArray(\"actions\");\n\n\t\tif (actionsJSONArray.length() == 0) {\n\t\t\treturn new HashMap<>();\n\t\t}\n\n\t\tJSONObject jsonObject = actionsJSONArray.getJSONObject(0);\n\t\t\n\t\tif (jsonObject.has(\"parameters\")) {\n\t\t\tJSONArray parametersJSONArray = jsonObject.getJSONArray(\n\t\t\t\t\"parameters\");\n\n\t\t\treturn getParameters(parametersJSONArray);\n\t\t}\n\n\t\treturn new HashMap<>();\n\t}","commit_id":"e2b5e236dd6effcae06e80c0bcb8530635b0ee42","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JSONArray getJSONSearch(\n\t\t\tlong[] groupIds, String name, long[] vocabularyIds, int start,\n\t\t\tint end)\n\t\tthrows PortalException, SystemException {\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (AssetVocabulary vocabulary :\n\t\t\t\tassetVocabularyService.getVocabularies(vocabularyIds)) {\n\n\t\t\tfor (int i = 0; i < groupIds.length; i++) {\n\t\t\t\tList<AssetCategory> vocabularyCategory =\n\t\t\t\t\tassetCategoryFinder.findByG_N_V(\n\t\t\t\t\t\tgroupIds[i], name, vocabulary.getVocabularyId(), start,\n\t\t\t\t\t\tend, null);\n\n\t\t\t\tJSONArray vocabularyCategoryJSONArray = toJSONArray(\n\t\t\t\t\tvocabularyCategory);\n\n\t\t\t\tint length = vocabularyCategoryJSONArray.length();\n\n\t\t\t\tfor (int j = 0; j < length; j++) {\n\t\t\t\t\tJSONObject vocabularyCategoryJSONObject =\n\t\t\t\t\t\tvocabularyCategoryJSONArray.getJSONObject(j);\n\n\t\t\t\t\tjsonArray.put(vocabularyCategoryJSONObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsonArray;\n\t}","id":41818,"modified_method":"public JSONArray search(\n\t\t\tlong[] groupIds, String name, long[] vocabularyIds, int start,\n\t\t\tint end)\n\t\tthrows PortalException, SystemException {\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (long groupId : groupIds) {\n\t\t\tJSONArray categoryJSONArray;\n\n\t\t\tif (Validator.isNull(name)) {\n\t\t\t\tcategoryJSONArray = toJSONArray(\n\t\t\t\t\tassetCategoryPersistence.filterFindByG_V(\n\t\t\t\t\t\tgroupId, vocabularyIds));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcategoryJSONArray = toJSONArray(\n\t\t\t\t\tassetCategoryPersistence.filterFindByG_N_V(\n\t\t\t\t\t\tgroupId, name, vocabularyIds));\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < categoryJSONArray.length(); j++) {\n\t\t\t\tjsonArray.put(categoryJSONArray.getJSONObject(j));\n\t\t\t}\n\t\t}\n\n\t\treturn jsonArray;\n\t}","commit_id":"57a6bb949de8a17d781c3646f35dee578a80e4be","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<AssetCategory> getVocabularyCategories(\n\t\t\tlong groupId, String name, long vocabularyId, int start, int end,\n\t\t\tOrderByComparator obc)\n\t\tthrows SystemException {\n\n\t\treturn assetCategoryFinder.filterFindByG_N_V(\n\t\t\tgroupId, name, vocabularyId, start, end, obc);\n\t}","id":41819,"modified_method":"public List<AssetCategory> getVocabularyCategories(\n\t\t\tlong groupId, String name, long vocabularyId, int start, int end,\n\t\t\tOrderByComparator obc)\n\t\tthrows SystemException {\n\n\t\tif (Validator.isNull(name)) {\n\t\t\treturn assetCategoryPersistence.filterFindByG_V(\n\t\t\t\tgroupId, vocabularyId, start, end, obc);\n\t\t}\n\t\telse {\n\t\t\treturn assetCategoryPersistence.filterFindByG_N_V(\n\t\t\t\tgroupId, name, vocabularyId, start, end, obc);\n\t\t}\n\t}","commit_id":"57a6bb949de8a17d781c3646f35dee578a80e4be","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JSONArray getJSONSearch(\n\t\t\tlong groupId, String name, long[] vocabularyIds, int start, int end)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn getJSONSearch(\n\t\t\tnew long[]{groupId}, name, vocabularyIds, start, end);\n\t}","id":41820,"modified_method":"/**\n\t * @deprecated {@link #search(long[], String, long[], int, int)}\n\t */\n\tpublic JSONArray getJSONSearch(\n\t\t\tlong groupId, String name, long[] vocabularyIds, int start, int end)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn search(new long[]{groupId}, name, vocabularyIds, start, end);\n\t}","commit_id":"57a6bb949de8a17d781c3646f35dee578a80e4be","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<AssetCategory> search(\n\t\t\tlong groupId, String keywords, long vocabularyId, int start,\n\t\t\tint end, OrderByComparator obc)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn filterCategories(\n\t\t\tassetCategoryFinder.findByG_N_V(\n\t\t\t\tgroupId, CustomSQLUtil.keywords(keywords)[0], vocabularyId,\n\t\t\t\tstart, end, obc));\n\t}","id":41821,"modified_method":"public List<AssetCategory> search(\n\t\t\tlong groupId, String keywords, long vocabularyId, int start,\n\t\t\tint end, OrderByComparator obc)\n\t\tthrows PortalException, SystemException {\n\n\t\tString name = CustomSQLUtil.keywords(keywords)[0];\n\n\t\tif (Validator.isNull(name)) {\n\t\t\treturn assetCategoryPersistence.filterFindByG_V(\n\t\t\t\tgroupId, vocabularyId, start, end, obc);\n\t\t}\n\t\telse {\n\t\t\treturn assetCategoryPersistence.filterFindByG_N_V(\n\t\t\t\tgroupId, name, vocabularyId, start, end, obc);\n\t\t}\n\t}","commit_id":"57a6bb949de8a17d781c3646f35dee578a80e4be","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int getVocabularyCategoriesCount(\n\t\t\tlong groupId, String name, long vocabularyId)\n\t\tthrows SystemException {\n\n\t\treturn assetCategoryFinder.filterCountByG_N_V(\n\t\t\tgroupId, name, vocabularyId);\n\t}","id":41822,"modified_method":"public int getVocabularyCategoriesCount(\n\t\t\tlong groupId, String name, long vocabularyId)\n\t\tthrows SystemException {\n\n\t\tif (Validator.isNull(name)) {\n\t\t\treturn assetCategoryPersistence.filterCountByG_V(\n\t\t\t\tgroupId, vocabularyId);\n\t\t}\n\t\telse {\n\t\t\treturn assetCategoryPersistence.filterCountByG_N_V(\n\t\t\t\tgroupId, name, vocabularyId);\n\t\t}\n\t}","commit_id":"57a6bb949de8a17d781c3646f35dee578a80e4be","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Set<String> getParameterNames() throws Exception {\n\t\tSet<String> parameterNames = new HashSet<>();\n\n\t\tJSONObject jsonObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tgetJobURL() + \"/api/json?tree=actions[parameterDefinitions\" +\n\t\t\t\t\"[name,type,value]]\");\n\n\t\tJSONArray parameterDefinitions = jsonObject.getJSONArray(\n\t\t\t\"actions\").getJSONObject(0).getJSONArray(\"parameterDefinitions\");\n\n\t\tfor (int i = 0; i < parameterDefinitions.length(); i++) {\n\t\t\tJSONObject parameterDefinition = parameterDefinitions.getJSONObject(\n\t\t\t\ti);\n\n\t\t\tif (parameterDefinition.getString(\n\t\t\t\t\t\"type\").equals(\"StringParameterDefinition\")) {\n\n\t\t\t\tparameterNames.add(parameterDefinition.getString(\"name\"));\n\t\t\t}\n\t\t}\n\n\t\treturn parameterNames;\n\t}","id":41823,"modified_method":"protected Set<String> getParameterNames() throws Exception {\n\t\tSet<String> parameterNames = new HashSet<>();\n\n\t\tJSONObject jsonObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tgetJobURL() + \"/api/json?tree=actions[parameterDefinitions\" +\n\t\t\t\t\"[name,type,value]]\");\n\n\t\tJSONArray actionsJSONArray = jsonObject.getJSONArray(\"actions\");\n\n\t\tJSONObject firstActionJSONObject = actionsJSONArray.getJSONObject(0);\n\n\t\tJSONArray parameterDefinitionsJSONArray =\n\t\t\tfirstActionJSONObject.getJSONArray(\"parameterDefinitions\");\n\n\t\tfor (int i = 0; i < parameterDefinitionsJSONArray.length(); i++) {\n\t\t\tJSONObject parameterDefinitionJSONObject =\n\t\t\t\tparameterDefinitionsJSONArray.getJSONObject(i);\n\n\t\t\tString type = parameterDefinitionJSONObject.getString(\"type\");\n\n\t\t\tif (type.equals(\"StringParameterDefinition\")) {\n\t\t\t\tparameterNames.add(\n\t\t\t\t\tparameterDefinitionJSONObject.getString(\"name\"));\n\t\t\t}\n\t\t}\n\n\t\treturn parameterNames;\n\t}","commit_id":"d1a46297ae258b4b73d66d0bf03c7b943cb58d18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(dependsOnMethods = \"populate\")\r\n\tpublic void testSQLAgainstGraph() {\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tODocument tom = (ODocument) database.createVertex().field(\"name\", \"Tom\").save();\r\n\t\tODocument ferrari = (ODocument) database.createVertex(\"GraphCar\").field(\"brand\", \"Ferrari\").save();\r\n\t\tODocument porsche = (ODocument) database.createVertex(\"GraphCar\").field(\"brand\", \"Porsche\").save();\r\n\t\tdatabase.createEdge(tom, ferrari).save();\r\n\t\tdatabase.createEdge(tom, porsche).save();\r\n\r\n\t\tList<OGraphElement> result = database.query(new OSQLSynchQuery<OGraphElement>(\r\n\t\t\t\t\"select out[in.@class = 'GraphCar'].in from V where name = 'Tom'\"));\r\n\t\tAssert.assertEquals(result.size(), 1);\r\n\r\n\t\tresult = database.query(new OSQLSynchQuery<OGraphElement>(\"select out[in.brand = 'Ferrari'].in from V where name = 'Tom'\"));\r\n\t\tAssert.assertEquals(result.size(), 1);\r\n\r\n\t\tdatabase.close();\r\n\t}","id":41824,"modified_method":"@Test(dependsOnMethods = \"populate\")\r\n\tpublic void testSQLAgainstGraph() {\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tODocument tom = (ODocument) database.createVertex().field(\"name\", \"Tom\").save();\r\n\t\tODocument ferrari = (ODocument) database.createVertex(\"GraphCar\").field(\"brand\", \"Ferrari\").save();\r\n\t\tODocument maserati = (ODocument) database.createVertex(\"GraphCar\").field(\"brand\", \"Maserati\").save();\r\n\t\tODocument porsche = (ODocument) database.createVertex(\"GraphCar\").field(\"brand\", \"Porsche\").save();\r\n\t\tdatabase.createEdge(tom, ferrari).field(\"label\", \"drives\").save();\r\n\t\tdatabase.createEdge(tom, maserati).field(\"label\", \"drives\").save();\r\n\t\tdatabase.createEdge(tom, porsche).field(\"label\", \"owns\").save();\r\n\r\n\t\tList<OGraphElement> result = database.query(new OSQLSynchQuery<OGraphElement>(\r\n\t\t\t\t\"select out[in.@class = 'GraphCar'].in from V where name = 'Tom'\"));\r\n\t\tAssert.assertEquals(result.size(), 1);\r\n\r\n\t\tresult = database.query(new OSQLSynchQuery<OGraphElement>(\r\n\t\t\t\t\"select out[label='drives'][in.brand = 'Ferrari'].in from V where name = 'Tom'\"));\r\n\t\tAssert.assertEquals(result.size(), 1);\r\n\r\n\t\tresult = database.query(new OSQLSynchQuery<OGraphElement>(\"select out[in.brand = 'Ferrari'].in from V where name = 'Tom'\"));\r\n\t\tAssert.assertEquals(result.size(), 1);\r\n\r\n\t\tdatabase.close();\r\n\t}","commit_id":"0bf5abfb369b53fe2859c5925c7649179e40e76e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n\t * @return Returns the finished.\n\t */\n\tpublic boolean isFinished() {\n\t\treturn finished;\n\t}","id":41825,"modified_method":"/**\n\t * @return Returns the finished.\n\t */\n\tpublic boolean isFinished() {\n\t\treturn isFlagSet(FINISHED);\n\t}","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * @return true if this ClassVertex represents an application class,\n     *         false otherwise\n     */\n    public boolean isApplicationClass() {\n\t    return applicationClass;\n    }","id":41826,"modified_method":"/**\n     * @return true if this ClassVertex represents an application class,\n     *         false otherwise\n     */\n    public boolean isApplicationClass() {\n    \treturn isFlagSet(APPLICATION_CLASS);\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param classDescriptor ClassDescriptor naming the class or interface\n\t * @param xclass          object containing information about a class or interface,\n\t *                        null if this ClassVertex represents a missing class\n\t */\n\tpublic ClassVertex(ClassDescriptor classDescriptor, @Nullable XClass xclass) {\n\t\tthis.classDescriptor = classDescriptor;\n\t\tthis.xclass = xclass;\n\t\tthis.finished = false;\n\t\tthis.applicationClass = false;\n\t}","id":41827,"modified_method":"private ClassVertex(ClassDescriptor classDescriptor, @Nullable XClass xclass) {\n\t\tthis.classDescriptor = classDescriptor;\n\t\tthis.xclass = xclass;\n\t\tthis.flags = 0;\n\t\tif (xclass.isInterface()) {\n\t\t\tsetInterface();\n\t\t}\n\t}","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Mark this ClassVertex as representing an application class.\n     */\n    public void markAsApplicationClass() {\n    \tthis.applicationClass = true;\n    }","id":41828,"modified_method":"/**\n     * Mark this ClassVertex as representing an application class.\n     */\n    public void markAsApplicationClass() {\n    \tsetFlag(APPLICATION_CLASS, true);\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * @param finished The finished to set.\n\t */\n\tpublic void setFinished(boolean finished) {\n\t\tthis.finished = finished;\n\t}","id":41829,"modified_method":"/**\n\t * @param finished The finished to set.\n\t */\n\tpublic void setFinished(boolean finished) {\n\t\tsetFlag(FINISHED, finished);\n\t}","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add a ClassVertex representing a missing class.\n\t * \n\t * @param missingClassDescriptor ClassDescriptor naming a missing class\n\t * @return the ClassVertex representing the missing class\n\t */\n    private ClassVertex addClassVertexForMissingClass(ClassDescriptor missingClassDescriptor) {\n    \tClassVertex missingClassVertex = new ClassVertex(missingClassDescriptor, null);\n    \tmissingClassVertex.setFinished(true);\n    \taddVertexToGraph(missingClassDescriptor, missingClassVertex);\n\t    \n\t    AnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(missingClassDescriptor);\n\t    \n\t    return missingClassVertex;\n    }","id":41830,"modified_method":"/**\n\t * Add a ClassVertex representing a missing class.\n\t * \n\t * @param missingClassDescriptor ClassDescriptor naming a missing class\n\t * @param isInterfaceEdge \n\t * @return the ClassVertex representing the missing class\n\t */\n    private ClassVertex addClassVertexForMissingClass(ClassDescriptor missingClassDescriptor, boolean isInterfaceEdge) {\n    \tClassVertex missingClassVertex = ClassVertex.createMissingClassVertex(missingClassDescriptor, isInterfaceEdge);\n    \tmissingClassVertex.setFinished(true);\n    \taddVertexToGraph(missingClassDescriptor, missingClassVertex);\n\t    \n\t    AnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(missingClassDescriptor);\n\t    \n\t    return missingClassVertex;\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Compute supertypes for class named by given ClassDescriptor.\n     * \n     * @param classDescriptor a ClassDescriptor\n     * @return SupertypeQueryResults containing known supertypes of the class\n     * @throws ClassNotFoundException if the class can't be found\n     */\n\tprivate SupertypeQueryResults computeSupertypes(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n\t\t// Try to fully resolve the class and its superclasses/superinterfaces.\n\t\tClassVertex typeVertex = resolveClassVertex(classDescriptor);\n\n\t\t// Create new empty SupertypeQueryResults.\n\t\tSupertypeQueryResults supertypeSet = new SupertypeQueryResults();\n\t\t\n\t\t// Add all known superclasses/superinterfaces.\n\t\t// The ClassVertexes for all of them should be in the\n\t\t// InheritanceGraph by now.\n\t\tLinkedList<ClassVertex> workList = new LinkedList<ClassVertex>();\n\t\tworkList.addLast(typeVertex);\n\t\twhile (!workList.isEmpty()) {\n\t\t\tClassVertex vertex = workList.removeFirst();\n\t\t\tif (vertex.isResolved()) {\n\t\t\t\tsupertypeSet.addSupertype(vertex.getClassDescriptor());\n\t\t\t} else {\n\t\t\t\tsupertypeSet.setEncounteredMissingClasses(true);\n\t\t\t}\n\t\t\t\n\t\t\tIterator<InheritanceEdge> i = graph.outgoingEdgeIterator(vertex);\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tInheritanceEdge edge = i.next();\n\t\t\t\tworkList.addLast(edge.getTarget());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn supertypeSet;\n    }","id":41831,"modified_method":"/**\n     * Compute supertypes for class named by given ClassDescriptor.\n     * \n     * @param classDescriptor a ClassDescriptor\n     * @return SupertypeQueryResults containing known supertypes of the class\n     * @throws ClassNotFoundException if the class can't be found\n     */\n\tprivate SupertypeQueryResults computeSupertypes(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Computing supertypes for \" + classDescriptor.toDottedClassName());\n\t\t}\n\t\t\n\t\t// Try to fully resolve the class and its superclasses/superinterfaces.\n\t\tClassVertex typeVertex = resolveClassVertex(classDescriptor);\n\n\t\t// Create new empty SupertypeQueryResults.\n\t\tSupertypeQueryResults supertypeSet = new SupertypeQueryResults();\n\t\t\n\t\t// Add all known superclasses/superinterfaces.\n\t\t// The ClassVertexes for all of them should be in the\n\t\t// InheritanceGraph by now.\n\t\tLinkedList<ClassVertex> workList = new LinkedList<ClassVertex>();\n\t\tworkList.addLast(typeVertex);\n\t\twhile (!workList.isEmpty()) {\n\t\t\tClassVertex vertex = workList.removeFirst();\n\t\t\tif (vertex.isResolved()) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"  Adding supertype \" + vertex.getClassDescriptor().toDottedClassName());\n\t\t\t\t}\n\t\t\t\tsupertypeSet.addSupertype(vertex.getClassDescriptor());\n\t\t\t} else {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\n\t\t\t\t\t\t\t\"  Encountered unresolved class \" +\n\t\t\t\t\t\t\tvertex.getClassDescriptor().toDottedClassName() +\n\t\t\t\t\t\t\t\" in supertype query\");\n\t\t\t\t}\n\t\t\t\tsupertypeSet.setEncounteredMissingClasses(true);\n\t\t\t}\n\t\t\t\n\t\t\tIterator<InheritanceEdge> i = graph.outgoingEdgeIterator(vertex);\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tInheritanceEdge edge = i.next();\n\t\t\t\tworkList.addLast(edge.getTarget());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn supertypeSet;\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Determine whether or not a given ObjectType is a subtype of another.\n\t * Throws ClassNotFoundException if the question cannot be answered\n\t * definitively due to a missing class.\n\t * \n\t * @param type              a ReferenceType\n\t * @param possibleSupertype another Reference type\n\t * @return true if <code>type<\/code> is a subtype of <code>possibleSupertype<\/code>, false if not\n\t * @throws ClassNotFoundException if a missing class prevents a definitive answer\n     */\n    public boolean isSubtype(ObjectType type, ObjectType possibleSupertype) throws ClassNotFoundException {\n    \tif (type.equals(possibleSupertype)) return true;\n\t    ClassDescriptor typeClassDescriptor = BCELUtil.getClassDescriptor(type);\n\t    ClassDescriptor possibleSuperclassClassDescriptor = BCELUtil.getClassDescriptor(possibleSupertype);\n\t    ClassVertex possibleSuperclassClassVertex = resolveClassVertex(possibleSuperclassClassDescriptor);\n\t    if (possibleSuperclassClassVertex.isResolved() && possibleSuperclassClassVertex.getXClass().isFinal()) return false;\n\t    \n\t    // Get the supertype query results\n\t    SupertypeQueryResults supertypeQueryResults = getSupertypeQueryResults(typeClassDescriptor);\n\t    \n\t    return supertypeQueryResults.containsType(possibleSuperclassClassDescriptor);\n    }","id":41832,"modified_method":"/**\n\t * Determine whether or not a given ObjectType is a subtype of another.\n\t * Throws ClassNotFoundException if the question cannot be answered\n\t * definitively due to a missing class.\n\t * \n\t * @param type              a ReferenceType\n\t * @param possibleSupertype another Reference type\n\t * @return true if <code>type<\/code> is a subtype of <code>possibleSupertype<\/code>, false if not\n\t * @throws ClassNotFoundException if a missing class prevents a definitive answer\n     */\n    public boolean isSubtype(ObjectType type, ObjectType possibleSupertype) throws ClassNotFoundException {\n    \tif (DEBUG) {\n    \t\tSystem.out.println(\"isSubtype: check \" + type + \" subtype of \" + possibleSupertype);\n    \t}\n    \t\n    \tif (type.equals(possibleSupertype)) {\n    \t\tif (DEBUG) {\n    \t\t\tSystem.out.println(\"  ==> yes, types are same\");\n    \t\t}\n    \t\treturn true;\n    \t}\n\t    ClassDescriptor typeClassDescriptor = BCELUtil.getClassDescriptor(type);\n\t    ClassDescriptor possibleSuperclassClassDescriptor = BCELUtil.getClassDescriptor(possibleSupertype);\n\t    ClassVertex possibleSuperclassClassVertex = resolveClassVertex(possibleSuperclassClassDescriptor);\n\t    if (possibleSuperclassClassVertex.isResolved() && possibleSuperclassClassVertex.getXClass().isFinal()) {\n\t    \tif (DEBUG) {\n\t    \t\tSystem.out.println(\"  ==> no, \" + possibleSuperclassClassDescriptor + \" is final\");\n\t    \t}\n\t    \treturn false;\n\t    }\n\t    \n\t    // Get the supertype query results\n\t    SupertypeQueryResults supertypeQueryResults = getSupertypeQueryResults(typeClassDescriptor);\n\t    if (DEBUG) {\n\t    \tSystem.out.println(\"  Superclass set: \" + supertypeQueryResults.supertypeSet);\n\t    }\n\t    \n\t    boolean isSubtype = supertypeQueryResults.containsType(possibleSuperclassClassDescriptor);\n\t    if (DEBUG) {\n\t    \tif (isSubtype) {\n\t    \t\tSystem.out.println(\"  ==> yes, \" + possibleSuperclassClassDescriptor + \" is in superclass set\");\n\t    \t} else {\n\t    \t\tSystem.out.println(\"  ==> no, \" + possibleSuperclassClassDescriptor + \" is not in superclass set\");\n\t    \t}\n\t    }\n\t    return isSubtype;\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Resolve a class named by given ClassDescriptor and return\n\t * its resolved ClassVertex.\n\t * \n\t * @param classDescriptor a ClassDescriptor\n\t * @return resolved ClassVertex representing the class in the InheritanceGraph\n\t * @throws ClassNotFoundException if the class named by the ClassDescriptor does not exist\n\t */\n\tprivate ClassVertex resolveClassVertex(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n\t    ClassVertex typeVertex = classDescriptorToVertexMap.get(classDescriptor);\n\t    if (typeVertex == null) {\n\t    \t// We have never tried to resolve this ClassVertex before.\n\t    \t// Try to find the XClass for this class.\n\t    \tXClass xclass = AnalysisContext.currentXFactory().getXClass(classDescriptor);\n\t    \tif (xclass == null) {\n\t    \t\t// Class we're trying to resolve doesn't exist.\n\t    \t\ttypeVertex = addClassVertexForMissingClass(classDescriptor);\n\t    \t} else {\n\t    \t\t// Add the class and all its superclasses/superinterfaces to the inheritance graph.\n\t    \t\t// This will result in a resolved ClassVertex.\n\t    \t\ttypeVertex = addClassAndGetClassVertex(xclass);\n\t    \t}\n\t    }\n\t    \n\t    if (!typeVertex.isResolved()) {\n\t    \tBCELUtil.throwClassNotFoundException(classDescriptor);\n\t    }\n\t    \n\t\tassert typeVertex.isResolved();\n\t    return typeVertex;\n    }","id":41833,"modified_method":"/**\n\t * Resolve a class named by given ClassDescriptor and return\n\t * its resolved ClassVertex.\n\t * \n\t * @param classDescriptor a ClassDescriptor\n\t * @return resolved ClassVertex representing the class in the InheritanceGraph\n\t * @throws ClassNotFoundException if the class named by the ClassDescriptor does not exist\n\t */\n\tprivate ClassVertex resolveClassVertex(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n\t    ClassVertex typeVertex = classDescriptorToVertexMap.get(classDescriptor);\n\t    if (typeVertex == null) {\n\t    \t// We have never tried to resolve this ClassVertex before.\n\t    \t// Try to find the XClass for this class.\n\t    \tXClass xclass = AnalysisContext.currentXFactory().getXClass(classDescriptor);\n\t    \tif (xclass == null) {\n\t    \t\t// Class we're trying to resolve doesn't exist.\n\t    \t\t// XXX: unfortunately, we don't know if the missing class is a class or interface\n\t    \t\ttypeVertex = addClassVertexForMissingClass(classDescriptor, false);\n\t    \t} else {\n\t    \t\t// Add the class and all its superclasses/superinterfaces to the inheritance graph.\n\t    \t\t// This will result in a resolved ClassVertex.\n\t    \t\ttypeVertex = addClassAndGetClassVertex(xclass);\n\t    \t}\n\t    }\n\t    \n\t    if (!typeVertex.isResolved()) {\n\t    \tBCELUtil.throwClassNotFoundException(classDescriptor);\n\t    }\n\t    \n\t\tassert typeVertex.isResolved();\n\t    return typeVertex;\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add supertype edge to the InheritanceGraph.\n\t * \n\t * @param vertex               source ClassVertex (subtype)\n\t * @param superclassDescriptor ClassDescriptor of a direct supertype\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added\n\t */\n\tprivate void addInheritanceEdge(ClassVertex vertex, ClassDescriptor superclassDescriptor, LinkedList<XClass> workList) {\n\t\tif (superclassDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tClassVertex superclassVertex = classDescriptorToVertexMap.get(superclassDescriptor);\n\t\tif (superclassVertex == null) {\n\t\t\t// Haven't encountered this class previously.\n\t\t\t\n\t\t\tXClass superclassXClass = AnalysisContext.currentXFactory().getXClass(superclassDescriptor);\n\t\t\tif (superclassXClass == null) {\n\t\t\t\t// Inheritance graph will be incomplete.\n\t\t\t\t// Add a dummy node to inheritance graph and report missing class.\n\t\t\t\tsuperclassVertex = addClassVertexForMissingClass(superclassDescriptor);\n\t\t\t} else {\n\t\t\t\t// Haven't seen this class before.\n\t\t\t\tsuperclassVertex = new ClassVertex(superclassDescriptor, superclassXClass);\n\t\t\t\taddVertexToGraph(superclassDescriptor, superclassVertex);\n\t\t\t\t\n\t\t\t\t// We'll want to recursively process the superclass.\n\t\t\t\tworkList.addLast(superclassXClass);\n\t\t\t}\n\t\t}\n\t\tassert superclassVertex != null;\n\t\t\n\t\tgraph.createEdge(vertex, superclassVertex);\n\t}","id":41834,"modified_method":"/**\n\t * Add supertype edge to the InheritanceGraph.\n\t * \n\t * @param vertex               source ClassVertex (subtype)\n\t * @param superclassDescriptor ClassDescriptor of a direct supertype\n\t * @param isInterfaceEdge      true if supertype is (as far as we know) an interface\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added (null if no further work will be generated) \n\t */\n\tprivate void addInheritanceEdge(\n\t\t\tClassVertex vertex,\n\t\t\tClassDescriptor superclassDescriptor,\n\t\t\tboolean isInterfaceEdge,\n\t\t\t@CheckForNull LinkedList<XClass> workList) {\n\t\tif (superclassDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tClassVertex superclassVertex = classDescriptorToVertexMap.get(superclassDescriptor);\n\t\tif (superclassVertex == null) {\n\t\t\t// Haven't encountered this class previously.\n\t\t\t\n\t\t\tXClass superclassXClass = AnalysisContext.currentXFactory().getXClass(superclassDescriptor);\n\t\t\tif (superclassXClass == null) {\n\t\t\t\t// Inheritance graph will be incomplete.\n\t\t\t\t// Add a dummy node to inheritance graph and report missing class.\n\t\t\t\tsuperclassVertex = addClassVertexForMissingClass(superclassDescriptor, isInterfaceEdge);\n\t\t\t} else {\n\t\t\t\t// Haven't seen this class before.\n\t\t\t\tsuperclassVertex = ClassVertex.createResolvedClassVertex(superclassDescriptor, superclassXClass);\n\t\t\t\taddVertexToGraph(superclassDescriptor, superclassVertex);\n\n\t\t\t\tif (workList != null) {\n\t\t\t\t\t// We'll want to recursively process the superclass.\n\t\t\t\t\tworkList.addLast(superclassXClass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert superclassVertex != null;\n\t\t\n\t\tif (graph.lookupEdge(vertex, superclassVertex) == null) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  Add edge \" + vertex.getClassDescriptor().toDottedClassName() + \" -> \" + superclassDescriptor.toDottedClassName());\n\t\t\t}\n\t\t\tgraph.createEdge(vertex, superclassVertex);\n\t\t}\n\t}","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add supertype edges to the InheritanceGraph\n\t * for given ClassVertex.  If any direct supertypes\n\t * have not been processed, add them to the worklist. \n\t * \n\t * @param vertex   a ClassVertex whose supertype edges need to be added\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added\n\t */\n\tprivate void addSupertypeEdges(ClassVertex vertex, LinkedList<XClass> workList) {\n\t\tXClass xclass = vertex.getXClass();\n\n\t\t// Direct superclass\n\t\taddInheritanceEdge(vertex, xclass.getSuperclassDescriptor(), workList);\n\t\t\n\t\t// Directly implemented interfaces\n\t\tfor (ClassDescriptor ifaceDesc : xclass.getInterfaceDescriptorList()) {\n\t\t\taddInheritanceEdge(vertex, ifaceDesc, workList);\n\t\t}\n\t}","id":41835,"modified_method":"/**\n\t * Add supertype edges to the InheritanceGraph\n\t * for given ClassVertex.  If any direct supertypes\n\t * have not been processed, add them to the worklist. \n\t * \n\t * @param vertex   a ClassVertex whose supertype edges need to be added\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added\n\t */\n\tprivate void addSupertypeEdges(ClassVertex vertex, LinkedList<XClass> workList) {\n\t\tXClass xclass = vertex.getXClass();\n\n\t\t// Direct superclass\n\t\taddInheritanceEdge(vertex, xclass.getSuperclassDescriptor(), false, workList);\n\t\t\n\t\t// Directly implemented interfaces\n\t\tfor (ClassDescriptor ifaceDesc : xclass.getInterfaceDescriptorList()) {\n\t\t\taddInheritanceEdge(vertex, ifaceDesc, true, workList);\n\t\t}\n\t}","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void addVertexToGraph(ClassDescriptor classDescriptor, ClassVertex vertex) {\n    \tif (classDescriptorToVertexMap.get(classDescriptor) != null) {\n    \t\tthrow new IllegalStateException();\n    \t}\n\t\tgraph.addVertex(vertex);\n\t\tclassDescriptorToVertexMap.put(classDescriptor, vertex);\n    }","id":41836,"modified_method":"private void addVertexToGraph(ClassDescriptor classDescriptor, ClassVertex vertex) {\n    \tif (classDescriptorToVertexMap.get(classDescriptor) != null) {\n    \t\tthrow new IllegalStateException();\n    \t}\n    \t\n    \tif (DEBUG) {\n    \t\tSystem.out.println(\"Adding \" + classDescriptor.toDottedClassName() + \" to inheritance graph\");\n    \t}\n    \t\n\t\tgraph.addVertex(vertex);\n\t\tclassDescriptorToVertexMap.put(classDescriptor, vertex);\n\t\t\n\t\tif (vertex.isInterface()) {\n\t\t\t// There is no need to add additional worklist nodes because java/lang/Object has no supertypes.\n\t\t\taddInheritanceEdge(vertex, DescriptorFactory.instance().getClassDescriptor(\"java/lang/Object\"), false, null);\n\t\t}\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add an XClass and all of its supertypes to\n\t * the InheritanceGraph.\n\t * \n     * @param xclass an XClass\n     * @return the ClassVertex representing the class in \n     *         the InheritanceGraph\n     */\n    private ClassVertex addClassAndGetClassVertex(XClass xclass) {\n\t    if (xclass == null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tLinkedList<XClass> workList = new LinkedList<XClass>();\n\t\tworkList.add(xclass);\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tXClass work = workList.removeFirst();\n\t\t\tClassVertex vertex = classDescriptorToVertexMap.get(work.getClassDescriptor());\n\t\t\tif (vertex != null && vertex.isFinished()) {\n\t\t\t\t// This class has already been processed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vertex == null) {\n\t\t\t\tvertex = new ClassVertex(work.getClassDescriptor(), work);\n\t\t\t\taddVertexToGraph(work.getClassDescriptor(), vertex);\n\t\t\t}\n\n\t\t\taddSupertypeEdges(vertex, workList);\n\n\t\t\tvertex.setFinished(true);\n\t\t}\n\t\t\n\t\treturn classDescriptorToVertexMap.get(xclass.getClassDescriptor());\n    }","id":41837,"modified_method":"/**\n\t * Add an XClass and all of its supertypes to\n\t * the InheritanceGraph.\n\t * \n     * @param xclass an XClass\n     * @return the ClassVertex representing the class in \n     *         the InheritanceGraph\n     */\n    private ClassVertex addClassAndGetClassVertex(XClass xclass) {\n\t    if (xclass == null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tLinkedList<XClass> workList = new LinkedList<XClass>();\n\t\tworkList.add(xclass);\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tXClass work = workList.removeFirst();\n\t\t\tClassVertex vertex = classDescriptorToVertexMap.get(work.getClassDescriptor());\n\t\t\tif (vertex != null && vertex.isFinished()) {\n\t\t\t\t// This class has already been processed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vertex == null) {\n\t\t\t\tvertex = ClassVertex.createResolvedClassVertex(work.getClassDescriptor(), work);\n\t\t\t\taddVertexToGraph(work.getClassDescriptor(), vertex);\n\t\t\t}\n\n\t\t\taddSupertypeEdges(vertex, workList);\n\n\t\t\tvertex.setFinished(true);\n\t\t}\n\t\t\n\t\treturn classDescriptorToVertexMap.get(xclass.getClassDescriptor());\n    }","commit_id":"47f9af5bd16f7d29ff0bbea9a76efea867c01f5e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static String getMissingClassName(ClassNotFoundException ex) {\n\t\tString message = ex.getMessage();\n\n\t\t// Try to decode the error message by extracting the class name.\n\t\tString className = ClassNotFoundExceptionParser.getMissingClassName(ex);\n\t\tif (className != null) {\n\t\t\tif (className.indexOf('/') >= 0) {\n\t\t\t\tclassName = className.replace('/','.');\n\t\t\t}\n\t\t\treturn className;\n\n\t\t}\n\n\t\t// Just return the entire message.\n\t\t// It hopefully will still make sense to the user.\n\t\treturn message;\n\t}","id":41838,"modified_method":"public static String getMissingClassName(ClassNotFoundException ex) {\n\t\tString message = ex.getMessage();\n\t\tif (message == null) {\n\t\t\tmessage = \"\";\n\t\t}\n\n\t\t// Try to decode the error message by extracting the class name.\n\t\tString className = ClassNotFoundExceptionParser.getMissingClassName(ex);\n\t\tif (className != null) {\n\t\t\tif (className.indexOf('/') >= 0) {\n\t\t\t\tclassName = className.replace('/','.');\n\t\t\t}\n\t\t\treturn className;\n\n\t\t}\n\n\t\t// Just return the entire message.\n\t\t// It hopefully will still make sense to the user.\n\t\treturn message;\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Set the collection of class descriptors identifying all\n\t * application classes.\n\t * \n\t * @param appClassCollection List of ClassDescriptors identifying application classes\n\t */\n\tpublic void setAppClassList(List<ClassDescriptor> appClassCollection) throws CheckedAnalysisException {\n\n\t\t// FIXME: we really should drive the progress callback here\n\n\t\tSubtypes subtypes = getSubtypes();\n\t\tSubtypes2 subtypes2 = null;\n\t\tif (Subtypes2.ENABLE_SUBTYPES2) {\n\t\t\tSystem.out.println(\"Subtypes2 enabled\");\n\t\t\tsubtypes2 = Global.getAnalysisCache().getDatabase(Subtypes2.class);\n\t\t}\n\n\t\tfor (ClassDescriptor appClass : appClassCollection) {\n\t\t\ttry {\n\t\t\t\tJavaClass jclass =\n\t\t\t\t\tGlobal.getAnalysisCache().getClassAnalysis(JavaClass.class, appClass);\n\t\t\t\tsubtypes.addApplicationClass(jclass);\n\t\t\t} catch (ClassFormatException e) {\n\t\t\t\tGlobal.getAnalysisCache().getErrorLogger().logError(\n\t\t\t\t\t\t\"Error parsing application class \" + appClass, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (Subtypes2.ENABLE_SUBTYPES2) {\n\t\t\t\t// New Subtypes2 database - does not require JavaClass objects to be\n\t\t\t\t// cached indefinitely\n\t\t\t\tXClass xclass = currentXFactory().getXClass(appClass);\n\t\t\t\tassert xclass != null;\n\t\t\t\t\n\t\t\t\t// Add the application class to the database\n\t\t\t\tsubtypes2.addApplicationClass(xclass);\n\t\t\t\t\n\t\t\t\t// Add all referenced clases to the database\n\t\t\t\tfor (ClassDescriptor refClassDesc : xclass.getReferencedClassDescriptorList()) {\n\t\t\t\t\tXClass refXClass = currentXFactory().getXClass(refClassDesc);\n\t\t\t\t\tif (refXClass != null) {\n\t\t\t\t\t\tsubtypes2.addClass(refXClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetLookupFailureCallback().reportMissingClass(refClassDesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":41839,"modified_method":"/**\n\t * Set the collection of class descriptors identifying all\n\t * application classes.\n\t * \n\t * @param appClassCollection List of ClassDescriptors identifying application classes\n\t */\n\tpublic void setAppClassList(List<ClassDescriptor> appClassCollection) throws CheckedAnalysisException {\n\n\t\t// FIXME: we really should drive the progress callback here\n\n\t\tSubtypes subtypes = getSubtypes();\n\t\tSubtypes2 subtypes2 = null;\n\t\tif (Subtypes2.ENABLE_SUBTYPES2) {\n\t\t\tSystem.out.println(\"Subtypes2 enabled\");\n\t\t\tsubtypes2 = Global.getAnalysisCache().getDatabase(Subtypes2.class);\n\t\t}\n\n\t\tfor (ClassDescriptor appClass : appClassCollection) {\n\t\t\ttry {\n\t\t\t\tJavaClass jclass =\n\t\t\t\t\tGlobal.getAnalysisCache().getClassAnalysis(JavaClass.class, appClass);\n\t\t\t\tsubtypes.addApplicationClass(jclass);\n\t\t\t} catch (ClassFormatException e) {\n\t\t\t\tGlobal.getAnalysisCache().getErrorLogger().logError(\n\t\t\t\t\t\t\"Error parsing application class \" + appClass, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (Subtypes2.ENABLE_SUBTYPES2) {\n\t\t\t\t// New Subtypes2 database - does not require JavaClass objects to be\n\t\t\t\t// cached indefinitely\n\t\t\t\tXClass xclass = currentXFactory().getXClass(appClass);\n\t\t\t\tassert xclass != null;\n\t\t\t\t\n\t\t\t\t// Add the application class to the database\n\t\t\t\tsubtypes2.addApplicationClass(xclass);\n\t\t\t\t\n\t\t\t\t// Add all referenced clases to the database\n\t\t\t\tfor (ClassDescriptor refClassDesc : xclass.getReferencedClassDescriptorList()) {\n\t\t\t\t\tXClass refXClass = currentXFactory().getXClass(refClassDesc);\n\t\t\t\t\tif (refXClass != null) {\n\t\t\t\t\t\tsubtypes2.addClass(refXClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetLookupFailureCallback().reportMissingClass(refClassDesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Subtypes2.ENABLE_SUBTYPES2) {\n\t\t\tSystem.out.println(subtypes2.getGraph().getNumVertices() + \" vertices in inheritance graph\");\n\t\t}\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void reportMissingClass(ClassNotFoundException ex) {\n\t\tString missing = AbstractBugReporter.getMissingClassName(ex);\n\t\tif (missing.charAt(0) == '[') return;\n\t\tbugCollection.addMissingClass(missing);\n\t\tsuper.reportMissingClass(ex);\n\t}","id":41840,"modified_method":"@Override\n\tpublic void reportMissingClass(ClassNotFoundException ex) {\n\t\tString missing = AbstractBugReporter.getMissingClassName(ex);\n\t\tif (missing == null || missing.startsWith(\"[\")) {\n\t\t\treturn;\n\t\t}\n\t\tbugCollection.addMissingClass(missing);\n\t\tsuper.reportMissingClass(ex);\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the name of the missing class from a ClassNotFoundException.\n\t *\n\t * @param ex the ClassNotFoundException\n\t * @return the name of the missing class, or null if we\n\t *         couldn't figure out the class name\n\t */\n\tpublic static String getMissingClassName(ClassNotFoundException ex) {\n\t\t// If the exception has a ResourceNotFoundException as the cause,\n\t\t// then we have an easy answer.\n\t\tThrowable cause = ex.getCause();\n\t\tif (cause instanceof ResourceNotFoundException) {\n\t\t\tString resourceName = ((ResourceNotFoundException) cause).getResourceName();\n\t\t\tif (resourceName != null) {\n\t\t\t\tClassDescriptor classDesc = ClassDescriptor.fromResourceName(resourceName);\n\t\t\t\treturn classDesc.toDottedClassName();\n\t\t\t}\n\t\t}\n\n\t\t// Try the regular expression patterns to parse the class name\n\t\t// from the exception message.\n\t\tfor (Pattern pattern : patternList) {\n\t\t\tMatcher matcher = pattern.matcher(ex.getMessage());\n\t\t\tif (matcher.matches())\n\t\t\t\treturn matcher.group(1);\n\t\t}\n\t\treturn null;\n\t}","id":41841,"modified_method":"/**\n\t * Get the name of the missing class from a ClassNotFoundException.\n\t *\n\t * @param ex the ClassNotFoundException\n\t * @return the name of the missing class, or null if we\n\t *         couldn't figure out the class name\n\t */\n\tpublic static String getMissingClassName(ClassNotFoundException ex) {\n\t\t// If the exception has a ResourceNotFoundException as the cause,\n\t\t// then we have an easy answer.\n\t\tThrowable cause = ex.getCause();\n\t\tif (cause instanceof ResourceNotFoundException) {\n\t\t\tString resourceName = ((ResourceNotFoundException) cause).getResourceName();\n\t\t\tif (resourceName != null) {\n\t\t\t\tClassDescriptor classDesc = ClassDescriptor.fromResourceName(resourceName);\n\t\t\t\treturn classDesc.toDottedClassName();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ex.getMessage() == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try the regular expression patterns to parse the class name\n\t\t// from the exception message.\n\t\tfor (Pattern pattern : patternList) {\n\t\t\tMatcher matcher = pattern.matcher(ex.getMessage());\n\t\t\tif (matcher.matches())\n\t\t\t\treturn matcher.group(1);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void reportMissingClass(ClassNotFoundException ex) {\n\t\tString missing = AbstractBugReporter.getMissingClassName(ex);\n\t\tif (missing.charAt(0) == '[') return;\n\t\tif (missingClassSet.add(missing))\n\t\t\t++missingClassCount;\n\t\tsuper.reportMissingClass(ex);\n\t}","id":41842,"modified_method":"@Override\n\tpublic void reportMissingClass(ClassNotFoundException ex) {\n\t\tString missing = AbstractBugReporter.getMissingClassName(ex);\n\t\tif (missing == null || missing.startsWith(\"[\")) {\n\t\t\treturn;\n\t\t}\n\t\tif (missingClassSet.add(missing))\n\t\t\t++missingClassCount;\n\t\tsuper.reportMissingClass(ex);\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add a ClassVertex representing a missing class.\n\t * \n\t * @param missingClassDescriptor ClassDescriptor naming a missing class\n\t * @return the ClassVertex representing the missing class\n\t */\n    private ClassVertex addClassVertexForMissingClass(ClassDescriptor missingClassDescriptor) {\n    \tClassVertex missingClassVertex = new ClassVertex(missingClassDescriptor, null);\n    \tmissingClassVertex.setFinished(true);\n\t    graph.addVertex(missingClassVertex);\n\t    \n\t    AnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(missingClassDescriptor);\n\t    \n\t    return missingClassVertex;\n    }","id":41843,"modified_method":"/**\n\t * Add a ClassVertex representing a missing class.\n\t * \n\t * @param missingClassDescriptor ClassDescriptor naming a missing class\n\t * @return the ClassVertex representing the missing class\n\t */\n    private ClassVertex addClassVertexForMissingClass(ClassDescriptor missingClassDescriptor) {\n    \tClassVertex missingClassVertex = new ClassVertex(missingClassDescriptor, null);\n    \tmissingClassVertex.setFinished(true);\n    \taddVertexToGraph(missingClassDescriptor, missingClassVertex);\n\t    \n\t    AnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(missingClassDescriptor);\n\t    \n\t    return missingClassVertex;\n    }","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add an XClass and all of its supertypes to\n\t * the InheritanceGraph.\n\t * \n     * @param xclass an XClass\n     * @return the ClassVertex representing the class in \n     *         the InheritanceGraph\n     */\n    private ClassVertex addClassAndGetClassVertex(XClass xclass) {\n\t    if (xclass == null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tLinkedList<XClass> workList = new LinkedList<XClass>();\n\t\tworkList.add(xclass);\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tXClass work = workList.removeFirst();\n\t\t\tClassVertex vertex = classDescriptorToVertexMap.get(work.getClassDescriptor());\n\t\t\tif (vertex != null && vertex.isFinished()) {\n\t\t\t\t// This class has already been processed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vertex == null) {\n\t\t\t\tvertex = new ClassVertex(work.getClassDescriptor(), work);\n\t\t\t\tclassDescriptorToVertexMap.put(work.getClassDescriptor(), vertex);\n\t\t\t}\n\n\t\t\taddSupertypeEdges(vertex, workList);\n\n\t\t\tvertex.setFinished(true);\n\t\t}\n\t\t\n\t\treturn classDescriptorToVertexMap.get(xclass.getClassDescriptor());\n    }","id":41844,"modified_method":"/**\n\t * Add an XClass and all of its supertypes to\n\t * the InheritanceGraph.\n\t * \n     * @param xclass an XClass\n     * @return the ClassVertex representing the class in \n     *         the InheritanceGraph\n     */\n    private ClassVertex addClassAndGetClassVertex(XClass xclass) {\n\t    if (xclass == null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tLinkedList<XClass> workList = new LinkedList<XClass>();\n\t\tworkList.add(xclass);\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tXClass work = workList.removeFirst();\n\t\t\tClassVertex vertex = classDescriptorToVertexMap.get(work.getClassDescriptor());\n\t\t\tif (vertex != null && vertex.isFinished()) {\n\t\t\t\t// This class has already been processed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vertex == null) {\n\t\t\t\tvertex = new ClassVertex(work.getClassDescriptor(), work);\n\t\t\t\taddVertexToGraph(work.getClassDescriptor(), vertex);\n\t\t\t}\n\n\t\t\taddSupertypeEdges(vertex, workList);\n\n\t\t\tvertex.setFinished(true);\n\t\t}\n\t\t\n\t\treturn classDescriptorToVertexMap.get(xclass.getClassDescriptor());\n    }","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Constructor.\n\t */\n\tpublic Subtypes2() {\n\t\tthis.graph = new InheritanceGraph();\n\t\tthis.classDescriptorToVertexMap = new HashMap<ClassDescriptor, ClassVertex>();\n\t\tthis.supertypeSetMap = new HashMap<ClassDescriptor, SupertypeQueryResults>();// XXX: use MapCache?\n\t\tthis.SERIALIZABLE = ObjectTypeFactory.getInstance(\"java.io.Serializable\");\n\t\tthis.CLONEABLE = ObjectTypeFactory.getInstance(\"java.lang.Cloneable\");\n\t}","id":41845,"modified_method":"/**\n\t * Constructor.\n\t */\n\tpublic Subtypes2() {\n\t\tthis.graph = new InheritanceGraph();\n\t\tthis.classDescriptorToVertexMap = new HashMap<ClassDescriptor, ClassVertex>();\n\t\tthis.supertypeSetMap = new HashMap<ClassDescriptor, SupertypeQueryResults>();// XXX: use MapCache?\n\t\tthis.subtypeSetMap = new HashMap<ClassDescriptor, Set<ClassDescriptor>>();// XXX: use MapCache?\n\t\tthis.SERIALIZABLE = ObjectTypeFactory.getInstance(\"java.io.Serializable\");\n\t\tthis.CLONEABLE = ObjectTypeFactory.getInstance(\"java.lang.Cloneable\");\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add supertype edge to the InheritanceGraph.\n\t * \n\t * @param vertex               source ClassVertex (subtype)\n\t * @param superclassDescriptor ClassDescriptor of a direct supertype\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added\n\t */\n\tprivate void addInheritanceEdge(ClassVertex vertex, ClassDescriptor superclassDescriptor, LinkedList<XClass> workList) {\n\t\tif (superclassDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tXClass superClass = AnalysisContext.currentXFactory().getXClass(superclassDescriptor);\n\t\tif (superClass == null) {\n\t\t\t// Inheritance graph will be incomplete.\n\t\t\t// Add a dummy node to inheritance graph and report missing class.\n\t\t\taddClassVertexForMissingClass(superclassDescriptor);\n\t\t\treturn;\n\t\t}\n\n\t\tClassVertex superVertex = classDescriptorToVertexMap.get(superclassDescriptor);\n\t\tif (superVertex == null) {\n\t\t\t// Seeing this class for the first time\n\n\t\t\tsuperVertex = new ClassVertex(superclassDescriptor, superClass);\n\t\t\tclassDescriptorToVertexMap.put(superclassDescriptor, superVertex);\n\t\t\tworkList.addLast(superClass); // recursively process supertype\n\t\t}\n\n\t\tInheritanceEdge edge = graph.createEdge(vertex, superVertex);\n\t}","id":41846,"modified_method":"/**\n\t * Add supertype edge to the InheritanceGraph.\n\t * \n\t * @param vertex               source ClassVertex (subtype)\n\t * @param superclassDescriptor ClassDescriptor of a direct supertype\n\t * @param workList work list of ClassVertexes that need to have\n\t *                 their supertype edges added\n\t */\n\tprivate void addInheritanceEdge(ClassVertex vertex, ClassDescriptor superclassDescriptor, LinkedList<XClass> workList) {\n\t\tif (superclassDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tClassVertex superclassVertex = classDescriptorToVertexMap.get(superclassDescriptor);\n\t\tif (superclassVertex == null) {\n\t\t\t// Haven't encountered this class previously.\n\t\t\t\n\t\t\tXClass superclassXClass = AnalysisContext.currentXFactory().getXClass(superclassDescriptor);\n\t\t\tif (superclassXClass == null) {\n\t\t\t\t// Inheritance graph will be incomplete.\n\t\t\t\t// Add a dummy node to inheritance graph and report missing class.\n\t\t\t\tsuperclassVertex = addClassVertexForMissingClass(superclassDescriptor);\n\t\t\t} else {\n\t\t\t\t// Haven't seen this class before.\n\t\t\t\tsuperclassVertex = new ClassVertex(superclassDescriptor, superclassXClass);\n\t\t\t\taddVertexToGraph(superclassDescriptor, superclassVertex);\n\t\t\t\t\n\t\t\t\t// We'll want to recursively process the superclass.\n\t\t\t\tworkList.addLast(superclassXClass);\n\t\t\t}\n\t\t}\n\t\tassert superclassVertex != null;\n\t\t\n\t\tgraph.createEdge(vertex, superclassVertex);\n\t}","commit_id":"56c3c19eb901cf7a8d637b1418854f1c3fbef5f9","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Edge(@NotNull Node from, @NotNull Node to, @NotNull Type type, Branch branch) {\n        this.from = from;\n        this.to = to;\n        this.type = type;\n        this.branch = branch;\n    }","id":41847,"modified_method":"public Edge(@NotNull Node upNode, @NotNull Node downNode, @NotNull Type type, Branch branch) {\n        this.upNode = upNode;\n        this.downNode = downNode;\n        this.type = type;\n        this.branch = branch;\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MutableNode addCurrentCommit(Commit commit) {\n        MutableNode node = hashMutableNode.get(commit.hash());\n        if (node == null) {\n            node = new MutableNode(commit, new Branch());\n        }\n        node.setLogIndex(rows.size());\n        node.setRow(nextRow);\n        node.setType(Node.Type.commitNode);\n        nextRow.add(node);\n        rows.add(nextRow);\n\n        return node;\n    }","id":41848,"modified_method":"private MutableNode addCurrentCommit(Commit commit) {\n        MutableNode node = hashMutableNode.remove(commit.hash());\n        if (node == null) {\n            node = new MutableNode(commit, new Branch());\n        }\n        node.setRow(nextRow);\n        node.setType(Node.Type.commitNode);\n        nextRow.add(node);\n        rows.add(nextRow);\n\n        nextRow = new MutableNodeRow(rows.size());\n        return node;\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void prepare(int lastLogIndex) {\n        this.lastLogIndex = lastLogIndex;\n    }","id":41849,"modified_method":"private void prepare(int lastLogIndex) {\n        this.lastLogIndex = lastLogIndex;\n        nextRow = new MutableNodeRow(0);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public GraphModel build(ReadOnlyList<Commit> listOfCommits) {\n        prepare(listOfCommits.size() - 1);\n        for (int i = 0; i < listOfCommits.size(); i++) {\n            append(listOfCommits.get(i));\n        }\n        lastActions();\n        return new GraphModelImpl(rows);\n    }","id":41850,"modified_method":"@NotNull\n    public GraphModel build(ReadOnlyList<Commit> listOfCommits) {\n        prepare(listOfCommits.size() - 1);\n        for (Commit listOfCommit : listOfCommits) {\n            append(listOfCommit);\n        }\n        lastActions();\n        return new GraphModelImpl(rows);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addParent(MutableNode node, Commit parent, Branch branch) {\n        MutableNode parentNode = hashMutableNode.get(parent.hash());\n        if (parentNode == null) {\n            parentNode = new MutableNode(parent, branch);\n            createEdge(node, parentNode, Edge.Type.usual, branch);\n            hashMutableNode.put(parent.hash(), parentNode);\n        } else {\n            int index = getLogIndexOfCommit(parent);\n            createEdge(node, parentNode, Edge.Type.usual, branch);\n            // i.e. we need create new Node (\n            if (index != rows.size()) {\n                MutableNode newParentNode = new MutableNode(parentNode.getCommit(), parentNode.getBranch());\n                createEdge(parentNode, newParentNode, Edge.Type.usual, parentNode.getBranch());\n                nextRow.add(parentNode);\n            }\n        }\n    }","id":41851,"modified_method":"private void addParent(MutableNode node, Commit parent, Branch branch) {\n        MutableNode parentNode = hashMutableNode.get(parent.hash());\n        if (parentNode == null) {\n            parentNode = new MutableNode(parent, branch);\n            createEdge(node, parentNode, Edge.Type.usual, branch);\n            hashMutableNode.put(parent.hash(), parentNode);\n        } else {\n            int index = getLogIndexOfCommit(parent);\n            createEdge(node, parentNode, Edge.Type.usual, branch);\n            // i.e. we need create new Node\n            if (index != rows.size()) {\n                // remove old node\n                hashMutableNode.remove(parent.hash());\n\n                MutableNode newParentNode = new MutableNode(parentNode.getCommit(), parentNode.getBranch());\n                createEdge(parentNode, newParentNode, Edge.Type.usual, parentNode.getBranch());\n                hashMutableNode.put(parent.hash(), newParentNode);\n\n                parentNode.setType(Node.Type.edgeNode);\n                parentNode.setRow(nextRow);\n                nextRow.add(parentNode);\n\n            }\n        }\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void lastActions() {\n        final Collection<MutableNode> lastNodes = hashMutableNode.values();\n        for (MutableNode node : lastNodes) {\n            node.setRow(nextRow);\n            node.setLogIndex(rows.size());\n            node.setType(Node.Type.endCommitNode);\n            nextRow.add(node);\n        }\n        if (nextRow.getNodes().size() > 0) {\n            rows.add(nextRow);\n        }\n    }","id":41852,"modified_method":"private void lastActions() {\n        final Collection<MutableNode> lastNodes = hashMutableNode.values();\n        for (MutableNode node : lastNodes) {\n            node.setRow(nextRow);\n            node.setType(Node.Type.endCommitNode);\n            nextRow.add(node);\n        }\n        if (nextRow.getNodes().size() > 0) {\n            rows.add(nextRow);\n        }\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public NodeRow getRow() {\n        return row;\n    }","id":41853,"modified_method":"@Override\n    public int getRowIndex() {\n        return row.getRowIndex();\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ReadOnlyList<Edge> getDownEdges() {\n        return readOnlyDownEdges;\n    }","id":41854,"modified_method":"@NotNull\n    @Override\n    public ReadOnlyList<Edge> getDownEdges() {\n        return ReadOnlyList.newReadOnlyList(downEdges);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setRow(@NotNull NodeRow row) {\n        this.row = row;\n    }","id":41855,"modified_method":"public void setRow(@NotNull MutableNodeRow row) {\n        this.row = row;\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ReadOnlyList<Edge> getUpEdges() {\n        return readOnlyUpEdges;\n    }","id":41856,"modified_method":"@NotNull\n    @Override\n    public ReadOnlyList<Edge> getUpEdges() {\n        return ReadOnlyList.newReadOnlyList(upEdges);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ReadOnlyList<Node> getNodes() {\n        return ReadOnlyList.newReadOnlyList(nodes);\n    }","id":41857,"modified_method":"@NotNull\n    @Override\n    public ReadOnlyList<Node> getNodes() {\n        return ReadOnlyList.<Node>newReadOnlyList(nodes);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MutableNodeRow(int logIndex) {\n        this.logIndex = logIndex;\n    }","id":41858,"modified_method":"public MutableNodeRow(int rowIndex) {\n        this.rowIndex = rowIndex;\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void add(Node node) {\n        nodes.add(node);\n    }","id":41859,"modified_method":"public void add(MutableNode node) {\n        nodes.add(node);\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int getLogIndex() {\n        return 0;\n    }","id":41860,"modified_method":"public int getRowIndex() {\n        return rowIndex;\n    }","commit_id":"b340193a1d5ce5ec6d2f903ebe386d73c0d56b6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void onComplete(Result result)\n    {\n        if (!result.isFailed())\n        {\n            List<WWWAuthenticate> wwwAuthenticates = parseWWWAuthenticate(result.getResponse());\n            if (wwwAuthenticates.isEmpty())\n            {\n                // TODO\n            }\n            else\n            {\n                Request request = result.getRequest();\n                final String uri = request.uri();\n                Authentication authentication = null;\n                for (WWWAuthenticate wwwAuthenticate : wwwAuthenticates)\n                {\n                    authentication = client.getAuthenticationStore().findAuthentication(wwwAuthenticate.type, uri, wwwAuthenticate.realm);\n                    if (authentication != null)\n                        break;\n                }\n                if (authentication != null)\n                {\n                    final Authentication authn = authentication;\n                    authn.authenticate(request);\n                    request.send(new Adapter()\n                    {\n                        @Override\n                        public void onComplete(Result result)\n                        {\n                            if (!result.isFailed())\n                            {\n                                Authentication.Result authnResult = new Authentication.Result(uri, authn);\n                                client.getAuthenticationStore().addAuthenticationResult(authnResult);\n                            }\n                        }\n                    });\n                }\n                else\n                {\n                    noAuthentication(request, result.getResponse());\n                }\n            }\n        }\n    }","id":41861,"modified_method":"@Override\n    public void onComplete(Result result)\n    {\n        if (!result.isFailed())\n        {\n            List<WWWAuthenticate> wwwAuthenticates = parseWWWAuthenticate(result.getResponse());\n            if (wwwAuthenticates.isEmpty())\n            {\n                // TODO\n            }\n            else\n            {\n                Request request = result.getRequest();\n                final String uri = request.uri();\n                Authentication authentication = null;\n                String params = null;\n                for (WWWAuthenticate wwwAuthenticate : wwwAuthenticates)\n                {\n                    authentication = client.getAuthenticationStore().findAuthentication(wwwAuthenticate.type, uri, wwwAuthenticate.realm);\n                    if (authentication != null)\n                    {\n                        params = wwwAuthenticate.params;\n                        break;\n                    }\n                }\n                if (authentication != null)\n                {\n                    final Authentication authn = authentication;\n                    authn.authenticate(request, params, client.getConversation(request));\n                    request.send(new Adapter()\n                    {\n                        @Override\n                        public void onComplete(Result result)\n                        {\n                            if (!result.isFailed())\n                            {\n                                Authentication.Result authnResult = new Authentication.Result(uri, authn);\n                                client.getAuthenticationStore().addAuthenticationResult(authnResult);\n                            }\n                        }\n                    });\n                }\n                else\n                {\n                    noAuthentication(request, result.getResponse());\n                }\n            }\n        }\n    }","commit_id":"52accdf7611621a69f7c0433d47c52fe7b2d0f0d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void authenticate(Request request)\n    {\n        String encoding = StringUtil.__ISO_8859_1;\n        try\n        {\n            String value = \"Basic \" + B64Code.encode(user + \":\" + password, encoding);\n            request.header(HttpHeader.AUTHORIZATION.asString(), value);\n        }\n        catch (UnsupportedEncodingException x)\n        {\n            throw new UnsupportedCharsetException(encoding);\n        }\n    }","id":41862,"modified_method":"@Override\n    public boolean authenticate(Request request, String params, Attributes context)\n    {\n        String encoding = StringUtil.__ISO_8859_1;\n        try\n        {\n            String value = \"Basic \" + B64Code.encode(user + \":\" + password, encoding);\n            request.header(HttpHeader.AUTHORIZATION.asString(), value);\n        }\n        catch (UnsupportedEncodingException x)\n        {\n            throw new UnsupportedCharsetException(encoding);\n        }\n    }","commit_id":"52accdf7611621a69f7c0433d47c52fe7b2d0f0d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_BasicAuthentication() throws Exception\n    {\n        startBasic(new EmptyHandler());\n\n        AuthenticationStore authenticationStore = client.getAuthenticationStore();\n\n        final AtomicInteger requests = new AtomicInteger();\n        Request.Listener.Adapter requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request without Authentication causes a 401\n        Request request = client.newRequest(\"localhost\", connector.getLocalPort());\n        ContentResponse response = request.send().get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(401, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        String user = \"basic\";\n        String password = \"basic\";\n        authenticationStore.addAuthentication(new BasicAuthentication(\"http://localhost:\" + connector.getLocalPort(), realm, user, password));\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request with authentication causes a 401 (no previous successful authentication) + 200\n        response = request.send().get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(2, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Further requests do not trigger 401 because there is a previous successful authentication\n        // Remove existing header to be sure it's added by the implementation\n        request.header(HttpHeader.AUTHORIZATION.asString(), null);\n        response = request.send().get(555, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n    }","id":41863,"modified_method":"@Test\n    public void test_BasicAuthentication() throws Exception\n    {\n        startBasic(new EmptyHandler());\n        test_Authentication(new BasicAuthentication(\"http://localhost:\" + connector.getLocalPort(), realm, \"basic\", \"basic\"));\n    }","commit_id":"52accdf7611621a69f7c0433d47c52fe7b2d0f0d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_DigestAuthentication() throws Exception\n    {\n        startDigest(new EmptyHandler());\n\n        Request request = client.newRequest(\"localhost\", connector.getLocalPort());\n        ContentResponse response = request.send().get(5, TimeUnit.SECONDS);\n        Assert.assertEquals(401, response.status());\n    }","id":41864,"modified_method":"@Test\n    public void test_DigestAuthentication() throws Exception\n    {\n        startDigest(new EmptyHandler());\n        test_Authentication(new DigestAuthentication(\"http://localhost:\" + connector.getLocalPort(), realm));\n    }","commit_id":"52accdf7611621a69f7c0433d47c52fe7b2d0f0d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public DatastoreFilterLogicHandler(MutableClusterView clusterView, String lastLocalAddr, HashedDatastore hashRingDatastore, DatastoreAccessControl hostAcl) {\n      this.clusterView = clusterView;\n      this.hostAcl = hostAcl;\n      this.lastLocalAddr = lastLocalAddr;\n      this.hashRingDatastore = hashRingDatastore;\n   }","id":41865,"modified_method":"public DatastoreFilterLogicHandler(MutableClusterView clusterView, String lastLocalAddr, HashedDatastore hashRingDatastore, DatastoreAccessControl hostAcl) {\n      this.clusterView = clusterView;\n      this.hostAcl = hostAcl;\n      this.hashRingDatastore = hashRingDatastore;\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n      FilterDirector director = new FilterDirectorImpl();\n      director.setFilterAction(FilterAction.PASS);\n\n      if (CacheRequest.isCacheRequest(request)) {\n         if (isAllowed(request)) {\n            // TODO: Get rid of this monstrosity :x\n            updateClusterViewLocalAddress(request.getLocalAddr(), request.getLocalPort());\n\n            director = performCacheRequest(request);\n         } else {\n            director.setResponseStatus(HttpStatusCode.FORBIDDEN);\n            director.setFilterAction(FilterAction.RETURN);\n         }\n      }\n\n      return director;\n   }","id":41866,"modified_method":"@Override\n   public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n      FilterDirector director = new FilterDirectorImpl();\n      director.setFilterAction(FilterAction.PASS);\n\n      if (CacheRequest.isCacheRequest(request)) {\n         if (isAllowed(request)) {\n            clusterView.updateLocalAddress(new InetSocketAddress(request.getLocalAddr(), request.getLocalPort()));\n            director = performCacheRequest(request);\n         } else {\n            director.setResponseStatus(HttpStatusCode.FORBIDDEN);\n            director.setFilterAction(FilterAction.RETURN);\n         }\n      }\n\n      return director;\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"public static void main(String[] args) throws Exception {\n        final MutableClusterView view = new ThreadSafeClusterView();\n        final EHCacheDatastoreManager localManager = new EHCacheDatastoreManager(new CacheManager());\n        final HashRingDatastoreManager remoteManager = new HashRingDatastoreManager(\"temp-host-key\", UUIDEncodingProvider.getInstance(), MD5MessageDigestFactory.getInstance(), view, localManager.getDatastore());\n        final Datastore datastore = remoteManager.getDatastore();\n\n        view.updateLocal(new InetSocketAddress(InetAddress.getLocalHost(), 20000));\n        view.updateMembers(new InetSocketAddress[]{\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2101),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2102),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2103),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2104)});\n\n        final String myKey = \"mykey\";\n        final int finishTotal = 9700,\n                sleep1 = 1000,\n                sleep2 = 2000,\n                sleep3 = 1200,\n                sleep4 = 3000;\n\n        total = 0;\n\n        final Thread inserter1 = new Thread(new CacheInserterRunnable(sleep1, finishTotal, datastore, myKey)),\n                inserter2 = new Thread(new CacheInserterRunnable(sleep2, finishTotal, datastore, myKey)),\n                inserter3 = new Thread(new CacheInserterRunnable(sleep3, finishTotal, datastore, myKey)),\n                inserter4 = new Thread(new CacheInserterRunnable(sleep4, finishTotal, datastore, myKey));\n\n        final Thread reader = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        try {\n                            Thread.sleep(400);\n                        } catch (InterruptedException ie) {\n                            break;\n                        }\n\n                        final CacheableValue myValue = datastore.get(myKey).elementAs(CacheableValue.class);\n                        System.out.println(\"Acquired: \" + myValue.getValue() + \" out of \" + total\n                                + \"\\t\\t\\t\\t- Potential Drift Ratio: \" + ((double) myValue.getValue() / (double) total)\n                                + \"\\t\\t- Elapsed time: \" + (System.currentTimeMillis() - beginTimestamp) + \"ms\");\n                    }\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }, \"Reader 1\");\n\n        Thread.sleep(4000);\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n\n        oos.writeObject(new CacheableValue(0, true));\n        oos.close();\n\n        beginTimestamp = System.currentTimeMillis();\n\n        datastore.put(myKey, baos.toByteArray(), 200, TimeUnit.SECONDS);\n\n        reader.start();\n        inserter1.start();\n        inserter2.start();\n        inserter3.start();\n        inserter4.start();\n\n        Thread.sleep(200000);\n\n        System.exit(0);\n    }","id":41867,"modified_method":"public static void main(String[] args) throws Exception {\n        final MutableClusterView view = new ThreadSafeClusterView();\n        final EHCacheDatastoreManager localManager = new EHCacheDatastoreManager(new CacheManager());\n        final HashRingDatastoreManager remoteManager = new HashRingDatastoreManager(\"temp-host-key\", UUIDEncodingProvider.getInstance(), MD5MessageDigestFactory.getInstance(), view, localManager.getDatastore());\n        final Datastore datastore = remoteManager.getDatastore();\n\n        view.updateLocalAddress(new InetSocketAddress(InetAddress.getLocalHost(), 20000));\n        view.updateMembers(new InetSocketAddress[]{\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2101),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2102),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2103),\n                    new InetSocketAddress(InetAddress.getLocalHost(), 2104)});\n\n        final String myKey = \"mykey\";\n        final int finishTotal = 9700,\n                sleep1 = 1000,\n                sleep2 = 2000,\n                sleep3 = 1200,\n                sleep4 = 3000;\n\n        total = 0;\n\n        final Thread inserter1 = new Thread(new CacheInserterRunnable(sleep1, finishTotal, datastore, myKey)),\n                inserter2 = new Thread(new CacheInserterRunnable(sleep2, finishTotal, datastore, myKey)),\n                inserter3 = new Thread(new CacheInserterRunnable(sleep3, finishTotal, datastore, myKey)),\n                inserter4 = new Thread(new CacheInserterRunnable(sleep4, finishTotal, datastore, myKey));\n\n        final Thread reader = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        try {\n                            Thread.sleep(400);\n                        } catch (InterruptedException ie) {\n                            break;\n                        }\n\n                        final CacheableValue myValue = datastore.get(myKey).elementAs(CacheableValue.class);\n                        System.out.println(\"Acquired: \" + myValue.getValue() + \" out of \" + total\n                                + \"\\t\\t\\t\\t- Potential Drift Ratio: \" + ((double) myValue.getValue() / (double) total)\n                                + \"\\t\\t- Elapsed time: \" + (System.currentTimeMillis() - beginTimestamp) + \"ms\");\n                    }\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }, \"Reader 1\");\n\n        Thread.sleep(4000);\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n\n        oos.writeObject(new CacheableValue(0, true));\n        oos.close();\n\n        beginTimestamp = System.currentTimeMillis();\n\n        datastore.put(myKey, baos.toByteArray(), 200, TimeUnit.SECONDS);\n\n        reader.start();\n        inserter1.start();\n        inserter2.start();\n        inserter3.start();\n        inserter4.start();\n\n        Thread.sleep(200000);\n\n        System.exit(0);\n    }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"public ThreadSafeClusterView() {\n        clusterMembers = new LinkedList<ClusterMember>();\n    }","id":41868,"modified_method":"public ThreadSafeClusterView() {\n      this(new LinkedList<ClusterMember>());\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public synchronized void updateLocal(InetSocketAddress local) {\n        localAddress = local;\n    }","id":41869,"modified_method":"@Override\n   public synchronized void updateLocalAddress(InetSocketAddress local) {\n      localAddress.set(local);\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"public ThreadSafeClusterView(InetSocketAddress localAddress, List<ClusterMember> clusterMembers) {\n        this.clusterMembers = new LinkedList<ClusterMember>(clusterMembers);\n        this.localAddress = localAddress;\n    }","id":41870,"modified_method":"public ThreadSafeClusterView(List<ClusterMember> clusterMembers) {\n      this.clusterMembers = new LinkedList<ClusterMember>(clusterMembers);\n\n      localAddress = new ThreadLocal<InetSocketAddress>();\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"public ThreadSafeClusterView copy() {\n       return new ThreadSafeClusterView(localAddress, clusterMembers);\n    }","id":41871,"modified_method":"@Override\n   public ThreadSafeClusterView copy() {\n      return new ThreadSafeClusterView(clusterMembers);\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public synchronized InetSocketAddress localMember() {\n        return localAddress;\n    }","id":41872,"modified_method":"@Override\n   public synchronized InetSocketAddress localMember() {\n      return localAddress.get();\n   }","commit_id":"13ee0df3f28a0229a12961839f7061b167b3b747","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void handleIncoming(DiscoveryMessage message) {\n        if (message instanceof ChannelAvailable) {\n            ChannelAvailable channelAvailable = (ChannelAvailable) message;\n            RequestDetails request = pending.remove(channelAvailable.getChannel());\n            if (request != null) {\n                LOGGER.debug(\"Channel discovered: {}.\", channelAvailable);\n                request.handleResponse(channelAvailable);\n            } else {\n                LOGGER.debug(\"Channel discovered: {}. Ignoring\", channelAvailable);\n            }\n        } else if (!(message instanceof LookupRequest) && !(message instanceof ChannelUnavailable)) {\n            // Discard\n            LOGGER.debug(\"Received unknown discovery message {}. Discarding.\", message);\n        }\n        // Else ignore\n    }","id":41873,"modified_method":"public void handleIncoming(DiscoveryMessage message) {\n        if (message instanceof ChannelAvailable) {\n            ChannelAvailable channelAvailable = (ChannelAvailable) message;\n            RequestDetails request = channels.get(channelAvailable.getChannel());\n            if (request != null) {\n                LOGGER.debug(\"Channel discovered: {}.\", channelAvailable);\n                request.handleResponse(channelAvailable);\n            } else {\n                LOGGER.debug(\"Channel discovered: {}. Ignoring\", channelAvailable);\n            }\n        } else if (!(message instanceof LookupRequest) && !(message instanceof ChannelUnavailable)) {\n            // Discard\n            LOGGER.debug(\"Received unknown discovery message {}. Discarding.\", message);\n        }\n        // Else ignore\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public void handleOutgoing(DiscoveryMessage message) {\n        if (message instanceof LookupRequest) {\n            LookupRequest lookupRequest = (LookupRequest) message;\n            LOGGER.debug(\"Broadcasting lookup request {}.\", lookupRequest);\n            RequestDetails request = new RequestDetails(lookupRequest);\n            pending.put(lookupRequest.getChannel(), request);\n            request.run();\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }","id":41874,"modified_method":"public void handleOutgoing(DiscoveryMessage message) {\n        if (message instanceof LookupRequest) {\n            LookupRequest lookupRequest = (LookupRequest) message;\n            LOGGER.debug(\"Broadcasting lookup request {}.\", lookupRequest);\n            RequestDetails request = new RequestDetails(lookupRequest);\n            channels.put(lookupRequest.getChannel(), request);\n            request.run();\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Starts accepting connections.\n     *\n     * @param handler The handler for connections.\n     */\n    void accept(final IncomingConnectionHandler handler) {\n        DefaultExecutorFactory executorFactory = new DefaultExecutorFactory();\n        TcpIncomingConnector<Object> incomingConnector = new TcpIncomingConnector<Object>(executorFactory, new DefaultMessageSerializer<Object>(getClass().getClassLoader()));\n        final CompletionHandler finished = new CompletionHandler();\n\n        LOGGER.lifecycle(\"Awaiting requests.\");\n\n        Address address = incomingConnector.accept(new Action<ConnectEvent<Connection<Object>>>() {\n            public void execute(ConnectEvent<Connection<Object>> connectionConnectEvent) {\n                try {\n                    finished.onStartActivity();\n                    handler.handle(connectionConnectEvent.getConnection(), finished);\n                } finally {\n                    finished.onActivityComplete();\n                    connectionConnectEvent.getConnection().stop();\n                }\n            }\n        });\n\n        storeDaemonAddress(address);\n\n        boolean stopped = finished.awaitStop();\n        if (!stopped) {\n            LOGGER.lifecycle(\"Time-out waiting for requests. Stopping.\");\n        }\n        new CompositeStoppable(incomingConnector, executorFactory).stop();\n\n        getRegistryFile().delete();\n    }","id":41875,"modified_method":"/**\n     * Starts accepting connections.\n     *\n     * @param handler The handler for connections.\n     */\n    void accept(final IncomingConnectionHandler handler) {\n        DefaultExecutorFactory executorFactory = new DefaultExecutorFactory();\n        TcpIncomingConnector<Object> incomingConnector = new TcpIncomingConnector<Object>(executorFactory, new DefaultMessageSerializer<Object>(getClass().getClassLoader()), new InetAddressFactory(), new UUIDGenerator());\n        final CompletionHandler finished = new CompletionHandler();\n\n        LOGGER.lifecycle(\"Awaiting requests.\");\n\n        Action<ConnectEvent<Connection<Object>>> connectEvent = new Action<ConnectEvent<Connection<Object>>>() {\n            public void execute(ConnectEvent<Connection<Object>> connectionConnectEvent) {\n                try {\n                    finished.onStartActivity();\n                    handler.handle(connectionConnectEvent.getConnection(), finished);\n                } finally {\n                    finished.onActivityComplete();\n                    connectionConnectEvent.getConnection().stop();\n                }\n            }\n        };\n        Address address = incomingConnector.accept(connectEvent, false);\n\n        storeDaemonAddress(address);\n\n        boolean stopped = finished.awaitStop();\n        if (!stopped) {\n            LOGGER.lifecycle(\"Time-out waiting for requests. Stopping.\");\n        }\n        new CompositeStoppable(incomingConnector, executorFactory).stop();\n\n        getRegistryFile().delete();\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIncomingBroadcast(String group, String nodeName, AsyncConnection<DiscoveryMessage> connection, IncomingConnector<Message> incomingConnector, ExecutorFactory executorFactory, IdGenerator<?> idGenerator, ClassLoader messagingClassLoader) {\n        this.group = group;\n\n        executor = executorFactory.create(\"discovery broadcast\");\n        DiscardingFailureHandler<DiscoveryMessage> failureHandler = new DiscardingFailureHandler<DiscoveryMessage>(LOGGER);\n        protocolStack = new ProtocolStack<DiscoveryMessage>(executor, failureHandler, failureHandler, new ChannelRegistrationProtocol());\n        connection.dispatchTo(new GroupMessageFilter(group, protocolStack.getBottom()));\n        protocolStack.getBottom().dispatchTo(connection);\n\n        address = incomingConnector.accept(new IncomingConnectionAction());\n        hub = new MessageHub(\"incoming broadcast\", nodeName, executorFactory, idGenerator, messagingClassLoader);\n    }","id":41876,"modified_method":"public DefaultIncomingBroadcast(String group, String nodeName, AsyncConnection<DiscoveryMessage> connection, IncomingConnector<Message> incomingConnector, ExecutorFactory executorFactory, IdGenerator<?> idGenerator, ClassLoader messagingClassLoader) {\n        this.group = group;\n\n        executor = executorFactory.create(\"discovery broadcast\");\n        DiscardingFailureHandler<DiscoveryMessage> failureHandler = new DiscardingFailureHandler<DiscoveryMessage>(LOGGER);\n        protocolStack = new ProtocolStack<DiscoveryMessage>(executor, failureHandler, failureHandler, new ChannelRegistrationProtocol());\n        connection.dispatchTo(new GroupMessageFilter(group, protocolStack.getBottom()));\n        protocolStack.getBottom().dispatchTo(connection);\n\n        address = incomingConnector.accept(new IncomingConnectionAction(), true);\n        hub = new MessageHub(\"incoming broadcast\", nodeName, executorFactory, idGenerator, messagingClassLoader);\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public Address accept(final Action<ConnectEvent<MultiChannelConnection<Object>>> action) {\n        return incomingConnector.accept(new Action<ConnectEvent<Connection<Message>>>() {\n            public void execute(ConnectEvent<Connection<Message>> event) {\n                finishConnect(event, action);\n            }\n        });\n    }","id":41877,"modified_method":"public Address accept(final Action<ConnectEvent<MultiChannelConnection<Object>>> action) {\n        Action<ConnectEvent<Connection<Message>>> connectAction = new Action<ConnectEvent<Connection<Message>>>() {\n            public void execute(ConnectEvent<Connection<Message>> event) {\n                finishConnect(event, action);\n            }\n        };\n        return incomingConnector.accept(connectAction, false);\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> T addOutgoing(Class<T> type) {\n        String channelKey = type.getName();\n        lock.lock();\n        try {\n            if (pending.add(channelKey)) {\n                discoveryBroadcast.getTop().dispatch(new LookupRequest(group, channelKey));\n            }\n        } finally {\n            lock.unlock();\n        }\n        return new ProxyDispatchAdapter<T>(type, hub.addMulticastOutgoing(channelKey)).getSource();\n    }","id":41878,"modified_method":"public <T> T addOutgoing(Class<T> type) {\n        String channelKey = type.getName();\n        lock.lock();\n        try {\n            if (channels.add(channelKey)) {\n                discoveryBroadcast.getTop().dispatch(new LookupRequest(group, channelKey));\n            }\n        } finally {\n            lock.unlock();\n        }\n        return new ProxyDispatchAdapter<T>(type, hub.addMulticastOutgoing(channelKey)).getSource();\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public void dispatch(DiscoveryMessage message) {\n            if (message instanceof ChannelAvailable) {\n                ChannelAvailable available = (ChannelAvailable) message;\n                Address serviceAddress = available.getAddress();\n                lock.lock();\n                try {\n                    if (!pending.remove(available.getChannel())) {\n                        return;\n                    }\n                    if (connections.contains(serviceAddress)) {\n                        return;\n                    }\n                    connections.add(serviceAddress);\n                } finally {\n                    lock.unlock();\n                }\n\n                Connection<Message> syncConnection = outgoingConnector.connect(serviceAddress);\n                hub.addConnection(syncConnection);\n            }\n        }","id":41879,"modified_method":"public void dispatch(DiscoveryMessage message) {\n            if (message instanceof ChannelAvailable) {\n                ChannelAvailable available = (ChannelAvailable) message;\n                Address serviceAddress = available.getAddress();\n                lock.lock();\n                try {\n                    if (!channels.contains(available.getChannel())) {\n                        return;\n                    }\n                    if (connections.contains(serviceAddress)) {\n                        return;\n                    }\n                    connections.add(serviceAddress);\n                } finally {\n                    lock.unlock();\n                }\n\n                Connection<Message> syncConnection = outgoingConnector.connect(serviceAddress);\n                hub.addConnection(syncConnection);\n            }\n        }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private SocketInetAddress readAddress(DataInputStream inputStream) throws IOException {\n        int length = inputStream.readInt();\n        byte[] binAddress = new byte[length];\n        inputStream.readFully(binAddress);\n        InetAddress inetAddress = InetAddress.getByAddress(binAddress);\n        int port = inputStream.readInt();\n        return new SocketInetAddress(inetAddress, port);\n    }","id":41880,"modified_method":"private MultiChoiceAddress readAddress(DataInputStream inputStream) throws IOException {\n        long mostSigUuidBits = inputStream.readLong();\n        long leastSigUuidBits = inputStream.readLong();\n        UUID uuid = new UUID(mostSigUuidBits, leastSigUuidBits);\n        int port = inputStream.readInt();\n        int addressCount = inputStream.readInt();\n        List<InetAddress> addresses = new ArrayList<InetAddress>();\n        for (int i = 0; i < addressCount; i++) {\n            int length = inputStream.readInt();\n            byte[] binAddress = new byte[length];\n            inputStream.readFully(binAddress);\n            InetAddress inetAddress = InetAddress.getByAddress(binAddress);\n            addresses.add(inetAddress);\n        }\n        return new MultiChoiceAddress(uuid, port, addresses);\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private DiscoveryMessage readChannelUnavailable(DataInputStream inputStream) throws IOException {\n        String group = inputStream.readUTF();\n        String channel = inputStream.readUTF();\n        SocketInetAddress address = readAddress(inputStream);\n        return new ChannelUnavailable(group, channel, address);\n    }","id":41881,"modified_method":"private DiscoveryMessage readChannelUnavailable(DataInputStream inputStream) throws IOException {\n        String group = inputStream.readUTF();\n        String channel = inputStream.readUTF();\n        Address address = readAddress(inputStream);\n        return new ChannelUnavailable(group, channel, address);\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeAddress(DataOutputStream outputStream, SocketInetAddress address) throws IOException {\n        byte[] binAddress = address.getAddress().getAddress();\n        outputStream.writeInt(binAddress.length);\n        outputStream.write(binAddress);\n        outputStream.writeInt(address.getPort());\n    }","id":41882,"modified_method":"private void writeAddress(DataOutputStream outputStream, MultiChoiceAddress address) throws IOException {\n        UUID uuid = (UUID) address.getCanonicalAddress();\n        outputStream.writeLong(uuid.getMostSignificantBits());\n        outputStream.writeLong(uuid.getLeastSignificantBits());\n        outputStream.writeInt(address.getPort());\n        outputStream.writeInt(address.getCandidates().size());\n        for (InetAddress inetAddress : address.getCandidates()) {\n            byte[] binAddress = inetAddress.getAddress();\n            outputStream.writeInt(binAddress.length);\n            outputStream.write(binAddress);\n        }\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeChannelUnavailable(DataOutputStream outputStream, ChannelUnavailable channelUnavailable) throws IOException {\n        outputStream.writeByte(CHANNEL_UNAVAILABLE);\n        outputStream.writeUTF(channelUnavailable.getGroup());\n        outputStream.writeUTF(channelUnavailable.getChannel());\n        writeAddress(outputStream, (SocketInetAddress) channelUnavailable.getAddress());\n    }","id":41883,"modified_method":"private void writeChannelUnavailable(DataOutputStream outputStream, ChannelUnavailable channelUnavailable) throws IOException {\n        outputStream.writeByte(CHANNEL_UNAVAILABLE);\n        outputStream.writeUTF(channelUnavailable.getGroup());\n        outputStream.writeUTF(channelUnavailable.getChannel());\n        writeAddress(outputStream, (MultiChoiceAddress) channelUnavailable.getAddress());\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeChannelAvailable(DataOutputStream outputStream, ChannelAvailable channelAvailable) throws IOException {\n        outputStream.writeByte(CHANNEL_AVAILABLE);\n        outputStream.writeUTF(channelAvailable.getGroup());\n        outputStream.writeUTF(channelAvailable.getChannel());\n        writeAddress(outputStream, (SocketInetAddress) channelAvailable.getAddress());\n    }","id":41884,"modified_method":"private void writeChannelAvailable(DataOutputStream outputStream, ChannelAvailable channelAvailable) throws IOException {\n        outputStream.writeByte(CHANNEL_AVAILABLE);\n        outputStream.writeUTF(channelAvailable.getGroup());\n        outputStream.writeUTF(channelAvailable.getChannel());\n        writeAddress(outputStream, (MultiChoiceAddress) channelAvailable.getAddress());\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"private DiscoveryMessage readChannelAvailable(DataInputStream inputStream) throws IOException {\n        String group = inputStream.readUTF();\n        String channel = inputStream.readUTF();\n        SocketInetAddress address = readAddress(inputStream);\n        return new ChannelAvailable(group, channel, address);\n    }","id":41885,"modified_method":"private DiscoveryMessage readChannelAvailable(DataInputStream inputStream) throws IOException {\n        String group = inputStream.readUTF();\n        String channel = inputStream.readUTF();\n        Address address = readAddress(inputStream);\n        return new ChannelAvailable(group, channel, address);\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public Address accept(Action<ConnectEvent<Connection<Message>>> action) {\n        synchronized (lock) {\n            if (localAddress == null) {\n                localAddress = connector.accept(handShakeAction());\n            }\n\n            Address localAddress = new CompositeAddress(this.localAddress, nextId++);\n            pendingActions.put(localAddress, action);\n            return localAddress;\n        }\n    }","id":41886,"modified_method":"public Address accept(Action<ConnectEvent<Connection<Message>>> action, boolean allowRemote) {\n        assert !allowRemote;\n        synchronized (lock) {\n            if (localAddress == null) {\n                localAddress = connector.accept(handShakeAction(), false);\n            }\n\n            Address localAddress = new CompositeAddress(this.localAddress, nextId++);\n            pendingActions.put(localAddress, action);\n            return localAddress;\n        }\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"protected IncomingConnector<Message> createIncomingConnector() {\n        incomingConnector = new TcpIncomingConnector<Message>(\n                get(ExecutorFactory.class),\n                new DefaultMessageSerializer<Message>(\n                        messageClassLoader));\n        return incomingConnector;\n    }","id":41887,"modified_method":"protected IncomingConnector<Message> createIncomingConnector() {\n        incomingConnector = new TcpIncomingConnector<Message>(\n                get(ExecutorFactory.class),\n                new DefaultMessageSerializer<Message>(\n                        messageClassLoader),\n                new InetAddressFactory(),\n                new UUIDGenerator());\n        return incomingConnector;\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public Address accept(Action<ConnectEvent<Connection<T>>> action) {\n        ServerSocketChannel serverSocket;\n        Address localAddress;\n        try {\n            serverSocket = ServerSocketChannel.open();\n            serverSockets.add(serverSocket);\n            serverSocket.socket().bind(new InetSocketAddress(0));\n            localAddress = new SocketInetAddress(InetAddress.getByName(\"localhost\"), serverSocket.socket().getLocalPort());\n            LOGGER.debug(\"Listening on {}.\", localAddress);\n        } catch (Exception e) {\n            throw UncheckedException.asUncheckedException(e);\n        }\n\n        executor.execute(new Receiver(serverSocket, action));\n        return localAddress;\n    }","id":41888,"modified_method":"public Address accept(Action<ConnectEvent<Connection<T>>> action, boolean allowRemote) {\n        ServerSocketChannel serverSocket;\n        int localPort;\n        try {\n            serverSocket = ServerSocketChannel.open();\n            serverSockets.add(serverSocket);\n            serverSocket.socket().bind(new InetSocketAddress(0));\n            localPort = serverSocket.socket().getLocalPort();\n        } catch (Exception e) {\n            throw UncheckedException.asUncheckedException(e);\n        }\n\n        Object id = idGenerator.generateId();\n        List<InetAddress> addresses = allowRemote ? remoteAddresses : localAddresses;\n        Address address = new MultiChoiceAddress(id, localPort, addresses);\n        LOGGER.debug(\"Listening on {}.\", address);\n\n        executor.execute(new Receiver(serverSocket, action, allowRemote));\n        return address;\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public TcpIncomingConnector(ExecutorFactory executorFactory, MessageSerializer<T> serializer) {\n        this.serializer = serializer;\n        this.executor = executorFactory.create(\"Incoming TCP Connector\");\n\n        localAddresses = TcpOutgoingConnector.findLocalAddresses();\n    }","id":41889,"modified_method":"public TcpIncomingConnector(ExecutorFactory executorFactory, MessageSerializer<T> serializer, InetAddressFactory addressFactory, IdGenerator<?> idGenerator) {\n        this.serializer = serializer;\n        this.idGenerator = idGenerator;\n        this.executor = executorFactory.create(\"Incoming TCP Connector\");\n\n        localAddresses = addressFactory.findLocalAddresses();\n        remoteAddresses = addressFactory.findRemoteAddresses();\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public Receiver(ServerSocketChannel serverSocket, Action<ConnectEvent<Connection<T>>> action) {\n            this.serverSocket = serverSocket;\n            this.action = action;\n        }","id":41890,"modified_method":"public Receiver(ServerSocketChannel serverSocket, Action<ConnectEvent<Connection<T>>> action, boolean allowRemote) {\n            this.serverSocket = serverSocket;\n            this.action = action;\n            this.allowRemote = allowRemote;\n        }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public void run() {\n            try {\n                try {\n                    while (true) {\n                        SocketChannel socket = serverSocket.accept();\n                        InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.socket().getRemoteSocketAddress();\n                        if (!localAddresses.contains(remoteSocketAddress.getAddress())) {\n                            LOGGER.error(\"Cannot accept connection from remote address {}.\", remoteSocketAddress.getAddress());\n                            socket.close();\n                            continue;\n                        }\n\n                        SocketConnection<T> connection = new SocketConnection<T>(socket, serializer);\n                        Address localAddress = connection.getLocalAddress();\n                        Address remoteAddress = connection.getRemoteAddress();\n\n                        LOGGER.debug(\"Accepted connection from {} to {}.\", remoteAddress, localAddress);\n                        action.execute(new ConnectEvent<Connection<T>>(connection, localAddress, remoteAddress));\n                    }\n                } catch (ClosedChannelException e) {\n                    // Ignore\n                } catch (Exception e) {\n                    LOGGER.error(\"Could not accept remote connection.\", e);\n                }\n            } finally {\n                new CompositeStoppable(serverSocket).stop();\n                serverSockets.remove(serverSocket);\n            }\n        }","id":41891,"modified_method":"public void run() {\n            try {\n                try {\n                    while (true) {\n                        SocketChannel socket = serverSocket.accept();\n                        InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.socket().getRemoteSocketAddress();\n                        if (!allowRemote && !localAddresses.contains(remoteSocketAddress.getAddress())) {\n                            LOGGER.error(\"Cannot accept connection from remote address {}.\", remoteSocketAddress.getAddress());\n                            socket.close();\n                            continue;\n                        }\n\n                        SocketConnection<T> connection = new SocketConnection<T>(socket, serializer);\n                        Address localAddress = connection.getLocalAddress();\n                        Address remoteAddress = connection.getRemoteAddress();\n\n                        LOGGER.debug(\"Accepted connection from {} to {}.\", remoteAddress, localAddress);\n                        action.execute(new ConnectEvent<Connection<T>>(connection, localAddress, remoteAddress));\n                    }\n                } catch (ClosedChannelException e) {\n                    // Ignore\n                } catch (Exception e) {\n                    LOGGER.error(\"Could not accept remote connection.\", e);\n                }\n            } finally {\n                new CompositeStoppable(serverSocket).stop();\n                serverSockets.remove(serverSocket);\n            }\n        }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"public Connection<T> connect(Address destinationAddress) {\n        if (!(destinationAddress instanceof SocketInetAddress)) {\n            throw new IllegalArgumentException(String.format(\"Cannot create a connection to address of unknown type: %s.\", destinationAddress));\n        }\n        SocketInetAddress socketInetAddress = (SocketInetAddress) destinationAddress;\n\n        // Find all loop back addresses. Not all of them are necessarily reachable (eg when socket option IPV6_V6ONLY\n        // is on - the default for debian and others), so we will try each of them until we can connect\n        List<InetAddress> loopBackAddresses = findLocalAddresses();\n\n        // Now try each address\n        try {\n            SocketException lastFailure = null;\n            for (InetAddress address : loopBackAddresses) {\n                LOGGER.debug(\"Trying to connect to address {}.\", address);\n                SocketChannel socketChannel;\n                try {\n                    socketChannel = SocketChannel.open(new InetSocketAddress(address, socketInetAddress.getPort()));\n                } catch (SocketException e) {\n                    LOGGER.debug(\"Cannot connect to address {}, skipping.\", address);\n                    lastFailure = e;\n                    continue;\n                }\n                LOGGER.debug(\"Connected to address {}.\", address);\n                return new SocketConnection<T>(socketChannel, serializer);\n            }\n            throw lastFailure;\n        } catch (java.net.ConnectException e) {\n            throw new ConnectException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, loopBackAddresses), e);\n        } catch (Exception e) {\n            throw new GradleException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, loopBackAddresses), e);\n        }\n    }","id":41892,"modified_method":"public Connection<T> connect(Address destinationAddress) {\n        if (!(destinationAddress instanceof MultiChoiceAddress)) {\n            throw new IllegalArgumentException(String.format(\"Cannot create a connection to address of unknown type: %s.\", destinationAddress));\n        }\n        MultiChoiceAddress address = (MultiChoiceAddress) destinationAddress;\n        LOGGER.debug(\"Attempting to connect to {}.\", address);\n\n        // Try each address in turn. Not all of them are necessarily reachable (eg when socket option IPV6_V6ONLY\n        // is on - the default for debian and others), so we will try each of them until we can connect\n        List<InetAddress> candidateAddresses = address.getCandidates();\n\n        // Now try each address\n        try {\n            SocketException lastFailure = null;\n            for (InetAddress candidate : candidateAddresses) {\n                LOGGER.debug(\"Trying to connect to address {}.\", candidate);\n                SocketChannel socketChannel;\n                try {\n                    socketChannel = SocketChannel.open(new InetSocketAddress(candidate, address.getPort()));\n                } catch (SocketException e) {\n                    LOGGER.debug(\"Cannot connect to address {}, skipping.\", candidate);\n                    lastFailure = e;\n                    continue;\n                }\n                LOGGER.debug(\"Connected to address {}.\", candidate);\n                return new SocketConnection<T>(socketChannel, serializer);\n            }\n            throw lastFailure;\n        } catch (java.net.ConnectException e) {\n            throw new ConnectException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), e);\n        } catch (Exception e) {\n            throw new GradleException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), e);\n        }\n    }","commit_id":"360890d60554d3bdd3202cf14863f5389f5c622f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    serverSocket = new ServerSocket();\n    serverThread = new Thread() {\n      public void run() {\n        try {\n          serverSocket.bind(null);\n          serverSocket.accept();\n        } catch (IOException e) {\n          // TODO Auto-generated catch block\n        }\n      }\n    };\n    serverThread.start();\n  }","id":41893,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        serverSocket = new ServerSocket();\n        serverThread = new Thread() {\n            public void run() {\n                try {\n                    serverSocket.bind(null);\n                    serverSocket.accept();\n                    serverSocket.notifyAll();\n                }\n                catch (IOException e) {\n                    // TODO Auto-generated catch block\n                }\n            }\n        };\n        serverThread.setDaemon(true);\n        serverThread.start();\n        \n        synchronized (serverSocket) {\n            serverSocket.wait(100);\n        }\n    }","commit_id":"bbc8c582c74402f107de1c464a049ba80a8a917a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void testHttpClientReadTimeout() throws Exception {\n    HttpClient client = HttpClientManager.getNewHTTPClient();\n    final GetMethod get = new GetMethod(\"http://\" + serverSocket.getInetAddress().getHostAddress() + \":\"  + serverSocket.getLocalPort());\n\n    try {\n      client.executeMethod(get);\n    } catch (SocketTimeoutException ste) {\n      //expected\n    } catch (SocketException se) {\n      //expected\n    }\n  }","id":41894,"modified_method":"public void testHttpClientReadTimeout() throws Exception {\n        HttpClient client = HttpClientManager.getNewHTTPClient();\n        final InetAddress localAddress = serverSocket.getInetAddress();\n        final String hostAddress = localAddress.getHostAddress();\n        final int localPort = serverSocket.getLocalPort();\n        final String testUrl = \"http://\" + hostAddress + \":\" + localPort;\n        final GetMethod get = new GetMethod(testUrl);\n\n        try {\n            client.executeMethod(get);\n        }\n        catch (SocketTimeoutException ste) {\n            //expected\n        }\n        catch (SocketException se) {\n            //expected\n        }\n    }","commit_id":"bbc8c582c74402f107de1c464a049ba80a8a917a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void reportResult(int locationMonitorID, int serviceId, PollStatus status) {\n        \n        OnmsLocationMonitor locationMonitor = m_locMonDao.get(locationMonitorID);\n        OnmsMonitoredService monSvc = m_monSvcDao.get(serviceId);\n        \n        OnmsLocationSpecificStatusChange currentStatus = m_locMonDao.getMostRecentStatusChange(locationMonitor, monSvc);\n        \n        if (!currentStatus.equals(status)) {\n            OnmsLocationSpecificStatusChange newStatus = new OnmsLocationSpecificStatusChange(locationMonitor, monSvc, status);\n            m_locMonDao.saveStatusChange(newStatus);\n        }\n    }","id":41895,"modified_method":"public void reportResult(int locationMonitorID, int serviceId, PollStatus pollResult) {\n        \n        OnmsLocationMonitor locationMonitor = m_locMonDao.get(locationMonitorID);\n        OnmsMonitoredService monSvc = m_monSvcDao.get(serviceId);\n        OnmsLocationSpecificStatus newStatus = new OnmsLocationSpecificStatus(locationMonitor, monSvc, pollResult);\n        \n        if (newStatus.getPollResult().getResponseTime() >= 0) {\n            m_locMonDao.savePerformanceData(newStatus);\n        }\n        \n        OnmsLocationSpecificStatus currentStatus = m_locMonDao.getMostRecentStatusChange(locationMonitor, monSvc);\n        \n        if (currentStatus == null || !currentStatus.getPollResult().equals(pollResult)) {\n            m_locMonDao.saveStatusChange(newStatus);\n        }\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void saveStatusChange(OnmsLocationSpecificStatusChange statusChange) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","id":41896,"modified_method":"public void saveStatusChange(OnmsLocationSpecificStatus statusChange) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsLocationSpecificStatusChange getMostRecentStatusChange(OnmsLocationMonitor locationMonitor, OnmsMonitoredService monSvc) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","id":41897,"modified_method":"public OnmsLocationSpecificStatus getMostRecentStatusChange(OnmsLocationMonitor locationMonitor, OnmsMonitoredService monSvc) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testRegisterLocationMonitor() {\n        \n \n        expect(m_locMonDao.findMonitoringLocationDefinition(m_locationDefinition.getName())).andReturn(m_locationDefinition);\n        m_locMonDao.save(isA(OnmsLocationMonitor.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationMonitor mon = (OnmsLocationMonitor)getCurrentArguments()[0];\n                mon.setId(1);\n                return null;\n            }\n            \n        });\n        \n        replay(m_locMonDao);\n        \n        int locationMonitorId = m_backEnd.registerLocationMonitor(m_locationDefinition.getName());\n        \n        verify(m_locMonDao);\n        \n        assertEquals(1, locationMonitorId);\n        \n        \n        \n    }","id":41898,"modified_method":"public void testRegisterLocationMonitor() {\n        \n        expect(m_locMonDao.findMonitoringLocationDefinition(m_locationDefinition.getName())).andReturn(m_locationDefinition);\n\n        m_locMonDao.save(isA(OnmsLocationMonitor.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationMonitor mon = (OnmsLocationMonitor)getCurrentArguments()[0];\n                mon.setId(1);\n                return null;\n            }\n            \n        });\n        \n        replayMocks();\n        \n        int locationMonitorId = m_backEnd.registerLocationMonitor(m_locationDefinition.getName());\n        \n        verifyMocks();\n        \n        assertEquals(1, locationMonitorId);\n        \n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testStatusChangeFromUpToDown() {\n        \n        expect(m_locMonDao.get(1)).andReturn(m_locationMonitor);\n        expect(m_monSvcDao.get(1)).andReturn(m_httpService);\n        \n        expect(m_locMonDao.getMostRecentStatusChange(m_locationMonitor, m_httpService)).andReturn(m_httpCurrentStatus);\n        \n        final PollStatus newStatus = PollStatus.unavailable(\"Test Down\");\n        \n        m_locMonDao.saveStatusChange(isA(OnmsLocationSpecificStatusChange.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationSpecificStatusChange statusChange = (OnmsLocationSpecificStatusChange)getCurrentArguments()[0];\n                assertEquals(m_locationMonitor, statusChange.getLocationMonitor());\n                assertEquals(m_httpService, statusChange.getMonitoredService());\n                assertEquals(newStatus.getStatusCode(), statusChange.getStatus().getStatusCode());\n                assertEquals(newStatus.getResponseTime(), statusChange.getStatus().getResponseTime());\n                assertEquals(newStatus.getReason(), statusChange.getStatus().getReason());\n                \n                return null;\n            }\n            \n        });\n        \n        replay(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        m_backEnd.reportResult(1, 1, newStatus);\n        \n        verify(m_locMonDao, m_monSvcDao, m_pollerConfig);\n    }","id":41899,"modified_method":"public void testStatusChangeFromUpToDown() {\n        \n        expect(m_locMonDao.get(1)).andReturn(m_locationMonitor);\n        expect(m_monSvcDao.get(1)).andReturn(m_httpService);\n        \n        expect(m_locMonDao.getMostRecentStatusChange(m_locationMonitor, m_httpService)).andReturn(m_httpCurrentStatus);\n        \n        final PollStatus newStatus = PollStatus.unavailable(\"Test Down\");\n        \n        OnmsLocationSpecificStatus expectedStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_httpService, newStatus);\n        \n        m_locMonDao.saveStatusChange(isA(OnmsLocationSpecificStatus.class));\n        expectLastCall().andAnswer(new StatusChecker(expectedStatus));\n\n        replayMocks();\n        \n        m_backEnd.reportResult(1, 1, newStatus);\n        \n        verifyMocks();\n\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetPollerConfiguration() {\n        \n        expect(m_locMonDao.get(m_locationMonitor.getId())).andReturn(m_locationMonitor);\n        \n        expect(m_pollerConfig.getPackage(m_locationDefinition.getPollingPackageName())).andReturn(m_package);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_package)).andReturn(m_serviceSelector);\n        expect(m_pollerConfig.getServiceInPackage(\"HTTP\", m_package)).andReturn(m_httpSvcConfig);\n        expect(m_pollerConfig.getServiceInPackage(\"DNS\", m_package)).andReturn(m_dnsSvcConfig);\n        \n        expect(m_monSvcDao.findMatchingServices(m_serviceSelector)).andReturn(Arrays.asList(m_monServices));\n        \n        replay(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        PollerConfiguration config = m_backEnd.getPollerConfiguration(m_locationMonitor.getId());\n        \n        verify(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        assertNotNull(config);\n        assertEquals(2, config.getConfigurationForPoller().length);\n        assertEquals(m_httpService, config.getConfigurationForPoller()[0].getMonitoredService());\n        assertEquals(m_dnsService, config.getConfigurationForPoller()[1].getMonitoredService());\n        assertEquals(5678, config.getConfigurationForPoller()[1].getPollModel().getPollInterval());\n        assertTrue(config.getConfigurationForPoller()[1].getMonitorConfiguration().containsKey(\"hostname\"));\n    }","id":41900,"modified_method":"public void testGetPollerConfiguration() {\n        \n        expect(m_locMonDao.get(m_locationMonitor.getId())).andReturn(m_locationMonitor);\n        \n        expect(m_pollerConfig.getPackage(m_locationDefinition.getPollingPackageName())).andReturn(m_package);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_package)).andReturn(m_serviceSelector);\n        expect(m_pollerConfig.getServiceInPackage(\"HTTP\", m_package)).andReturn(m_httpSvcConfig);\n        expect(m_pollerConfig.getServiceInPackage(\"DNS\", m_package)).andReturn(m_dnsSvcConfig);\n        \n        expect(m_monSvcDao.findMatchingServices(m_serviceSelector)).andReturn(Arrays.asList(m_monServices));\n        \n        replayMocks();\n        \n        PollerConfiguration config = m_backEnd.getPollerConfiguration(m_locationMonitor.getId());\n        \n        verifyMocks();\n        \n        assertNotNull(config);\n        assertEquals(2, config.getConfigurationForPoller().length);\n        assertEquals(m_httpService, config.getConfigurationForPoller()[0].getMonitoredService());\n        assertEquals(m_dnsService, config.getConfigurationForPoller()[1].getMonitoredService());\n        assertEquals(5678, config.getConfigurationForPoller()[1].getPollModel().getPollInterval());\n        assertTrue(config.getConfigurationForPoller()[1].getMonitorConfiguration().containsKey(\"hostname\"));\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        \n        m_locMonDao = createMock(LocationMonitorDao.class);\n        m_monSvcDao = createMock(MonitoredServiceDao.class);\n        m_pollerConfig = createMock(PollerConfig.class);\n        \n        m_backEnd = new DefaultPollerBackEnd();\n        m_backEnd.setLocationMonitorDao(m_locMonDao);\n        m_backEnd.setMonitoredServiceDao(m_monSvcDao);\n        m_backEnd.setPollerConfig(m_pollerConfig);\n        \n        m_backEnd.afterPropertiesSet();\n\n        // set up some objects that can be used to mock up the tests\n        m_locationDefinition = new OnmsMonitoringLocationDefinition();\n        m_locationDefinition.setArea(\"Oakland\");\n        m_locationDefinition.setName(\"OAK\");\n        m_locationDefinition.setPollingPackageName(\"OAKPackage\");\n        \n        m_locations = Collections.singleton(m_locationDefinition);\n        \n        m_package = createPackage(m_locationDefinition.getPollingPackageName(), \"ipaddr = '192.168.1.1'\");\n        m_httpSvcConfig = addService(m_package, \"HTTP\", 1234, \"url\", \"http://www.opennms.org\");\n        m_dnsSvcConfig = addService(m_package, \"DNS\", 5678, \"hostname\", \"www.opennms.org\");\n        m_serviceSelector = new ServiceSelector(m_package.getFilter().getContent(), Arrays.asList(new String[]{ \"HTTP\", \"DNS\" }));\n\n        m_locationMonitor = new OnmsLocationMonitor();\n        m_locationMonitor.setId(1);\n        m_locationMonitor.setLocationDefinition(m_locationDefinition);\n        \n        NetworkBuilder builder = new NetworkBuilder(new OnmsDistPoller(\"localhost\", \"127.0.0.1\"));\n        OnmsNode node = builder.addNode(\"testNode\");\n        node.setId(1);\n        OnmsIpInterface iface = builder.addInterface(\"192.168.1.1\").getInterface();\n        iface.setId(1);\n        m_httpService = builder.addService(new OnmsServiceType(\"HTTP\"));\n        m_httpService.setId(1);\n        m_dnsService = builder.addService(new OnmsServiceType(\"DNS\"));\n        m_dnsService.setId(2);\n        \n        \n        \n        m_monServices = new OnmsMonitoredService[] { m_httpService, m_dnsService };\n        \n        long now = System.currentTimeMillis();\n        \n        PollStatus httpResult = PollStatus.available(1000L);\n        httpResult.setTimestamp(now - 300000);\n\n        m_httpCurrentStatus = new OnmsLocationSpecificStatusChange(m_locationMonitor, m_httpService, httpResult);\n        m_httpCurrentStatus.setId(1);\n\n        PollStatus dnsResult = PollStatus.unavailable(\"Non responsive\");\n        dnsResult.setTimestamp(now - 300000);\n\n        m_dnsCurrentStatus = new OnmsLocationSpecificStatusChange(m_locationMonitor, m_dnsService, dnsResult);\n        m_dnsCurrentStatus.setId(2);\n\n    }","id":41901,"modified_method":"protected void setUp() throws Exception {\n        \n        System.setProperty(\"opennms.home\", \"src/test/test-configurations/PollerBackEndTest-home\");\n        \n        m_locMonDao = createMock(LocationMonitorDao.class);\n        m_monSvcDao = createMock(MonitoredServiceDao.class);\n        m_pollerConfig = createMock(PollerConfig.class);\n        m_scheduler = createMock(Scheduler.class);\n        \n        m_backEnd = new DefaultPollerBackEnd();\n        m_backEnd.setLocationMonitorDao(m_locMonDao);\n        m_backEnd.setMonitoredServiceDao(m_monSvcDao);\n        m_backEnd.setPollerConfig(m_pollerConfig);\n        \n        m_backEnd.afterPropertiesSet();\n\n        // set up some objects that can be used to mock up the tests\n        \n        // the location definition\n        m_locationDefinition = new OnmsMonitoringLocationDefinition();\n        m_locationDefinition.setArea(\"Oakland\");\n        m_locationDefinition.setName(\"OAK\");\n        m_locationDefinition.setPollingPackageName(\"OAKPackage\");\n        \n        m_package = createPackage(m_locationDefinition.getPollingPackageName(), \"ipaddr = '192.168.1.1'\");\n        m_serviceSelector = new ServiceSelector(m_package.getFilter().getContent(), Arrays.asList(new String[]{ \"HTTP\", \"DNS\" }));\n\n        m_httpSvcConfig = addService(m_package, \"HTTP\", 1234, \"url\", \"http://www.opennms.org\");\n        m_dnsSvcConfig = addService(m_package, \"DNS\", 5678, \"hostname\", \"www.opennms.org\");\n\n        m_locationMonitor = new OnmsLocationMonitor();\n        m_locationMonitor.setId(1);\n        m_locationMonitor.setLocationDefinition(m_locationDefinition);\n        \n        NetworkBuilder builder = new NetworkBuilder(new OnmsDistPoller(\"localhost\", \"127.0.0.1\"));\n        OnmsNode node = builder.addNode(\"testNode\");\n        node.setId(1);\n        OnmsIpInterface iface = builder.addInterface(\"192.168.1.1\").getInterface();\n        iface.setId(1);\n        m_httpService = builder.addService(new OnmsServiceType(\"HTTP\"));\n        m_httpService.setId(1);\n        m_dnsService = builder.addService(new OnmsServiceType(\"DNS\"));\n        m_dnsService.setId(2);\n        \n        m_monServices = new OnmsMonitoredService[] { m_httpService, m_dnsService };\n        \n        long now = System.currentTimeMillis();\n        \n        PollStatus httpResult = PollStatus.available(1000L);\n        httpResult.setTimestamp(now - 300000);\n\n        m_httpCurrentStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_httpService, httpResult);\n        m_httpCurrentStatus.setId(1);\n\n        PollStatus dnsResult = PollStatus.unavailable(\"Non responsive\");\n        dnsResult.setTimestamp(now - 300000);\n\n        m_dnsCurrentStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_dnsService, dnsResult);\n        m_dnsCurrentStatus.setId(2);\n\n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetMonitoringLocations() {\n        \n        expect(m_locMonDao.findAllMonitoringLocationDefinitions()).andReturn(m_locations);\n        \n        replay(m_locMonDao);\n        \n        Collection<OnmsMonitoringLocationDefinition> returned = m_backEnd.getMonitoringLocations();\n        \n        verify(m_locMonDao);\n        \n        assertEquals(m_locations, returned);\n        \n    }","id":41902,"modified_method":"public void testGetMonitoringLocations() {\n        \n        Collection<OnmsMonitoringLocationDefinition> locations = Collections.singleton(m_locationDefinition);\n        \n        expect(m_locMonDao.findAllMonitoringLocationDefinitions()).andReturn(locations);\n        \n        replayMocks();\n        \n        Collection<OnmsMonitoringLocationDefinition> returned = m_backEnd.getMonitoringLocations();\n        \n        verifyMocks();\n        \n        assertEquals(locations, returned);\n        \n    }","commit_id":"551049286631da740b73e0d76d43f0fb8f43b0f6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void createTicketForAlarm(int alarmId, Map<String,String> attributes) {\n\n        OnmsAlarm alarm = m_alarmDao.get(alarmId);\n        if (alarm == null) {\n            LOG.error(\"No alarm with id {} was found. No ticket will be created.\", alarmId);\n            return;\n        }\n\n        Ticket ticket = createTicketFromAlarm(alarm);\n        if (attributes.containsKey(\"user\"))\n            ticket.setUser(attributes.get(\"user\"));\n        ticket.setAttributes(attributes);\n\n        try {\n            m_ticketerPlugin.saveOrUpdate(ticket);\n            alarm.setTTicketId(ticket.getId());\n            alarm.setTTicketState(TroubleTicketState.OPEN);\n        } catch (PluginException e) {\n            alarm.setTTicketState(TroubleTicketState.CREATE_FAILED);\n            LOG.error(\"Unable to create ticket for alarm: {}\", e.getMessage(), e);\n            m_eventIpcManager.sendNow(createEvent(e.getMessage()));\n        }\n\n        m_alarmDao.saveOrUpdate(alarm);\n\n    }","id":41903,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void createTicketForAlarm(int alarmId, Map<String,String> attributes) {\n\n        OnmsAlarm alarm = m_alarmDao.get(alarmId);\n        if (alarm == null) {\n            LOG.error(\"No alarm with id {} was found. No ticket will be created.\", alarmId);\n            return;\n        }\n\n        Ticket ticket = createTicketFromAlarm(alarm, attributes);\n\n        try {\n            m_ticketerPlugin.saveOrUpdate(ticket);\n            alarm.setTTicketId(ticket.getId());\n            alarm.setTTicketState(TroubleTicketState.OPEN);\n        } catch (PluginException e) {\n            alarm.setTTicketState(TroubleTicketState.CREATE_FAILED);\n            LOG.error(\"Unable to create ticket for alarm: {}\", e.getMessage(), e);\n            m_eventIpcManager.sendNow(createEvent(e.getMessage()));\n        }\n\n        m_alarmDao.saveOrUpdate(alarm);\n\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>Constructor for DefaultTicketerServiceLayer.<\/p>\n     */\n    public DefaultTicketerServiceLayer() {\n        m_eventIpcManager = EventIpcManagerFactory.getIpcManager();\n    }","id":41904,"modified_method":"public DefaultTicketerServiceLayer() {\n        m_eventIpcManager = EventIpcManagerFactory.getIpcManager();\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Called from API implemented method after successful retrieval of Alarm.\n     * \n     * @param alarm OpenNMS Model class alarm\n     * @return OpenNMS Ticket with contents of alarm.\n     * TODO: Add alarm attributes to Ticket.\n     * TODO: Add alarmid to Ticket class for ability to reference back to Alarm (waffling on this\n     * since ticket isn't a persisted object and other reasons)\n     */\n    protected Ticket createTicketFromAlarm(OnmsAlarm alarm) {\n        Ticket ticket = new Ticket();\n        ticket.setSummary(alarm.getLogMsg());\n        ticket.setDetails(alarm.getDescription());\n        ticket.setId(alarm.getTTicketId());\n        ticket.setAlarmId(alarm.getId());\n        ticket.setNodeId(alarm.getNodeId());\n        ticket.setIpAddress(alarm.getIpAddr());\n        return ticket;\n    }","id":41905,"modified_method":"/**\n     * Called from API implemented method after successful retrieval of Alarm.\n     * \n     * @param alarm OpenNMS Model class alarm\n     * @param attributes\n     * @return OpenNMS Ticket with contents of alarm.\n     * TODO: Add alarm attributes to Ticket.\n     * TODO: Add alarmid to Ticket class for ability to reference back to Alarm (waffling on this\n     * since ticket isn't a persisted object and other reasons)\n     */\n    protected Ticket createTicketFromAlarm(OnmsAlarm alarm, Map<String, String> attributes) {\n        Ticket ticket = new Ticket();\n        ticket.setSummary(alarm.getLogMsg());\n        ticket.setDetails(alarm.getDescription());\n        ticket.setId(alarm.getTTicketId());\n        ticket.setAlarmId(alarm.getId());\n        ticket.setNodeId(alarm.getNodeId());\n        ticket.setIpAddress(alarm.getIpAddr());\n        ticket.setAttributes(attributes);\n        if (attributes.containsKey(\"user\"))\n            ticket.setUser(attributes.get(\"user\"));\n        return ticket;\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Called from API implemented method after successful retrieval of Alarm.\n\t * \n\t * @param alarm OpenNMS Model class alarm\n\t * @return OpenNMS Ticket processed by Drools logic.\n\t */\n    @Override\n    protected Ticket createTicketFromAlarm(OnmsAlarm alarm) {\n        LOG.debug(\"Initializing ticket from alarm: {}\", alarm);\n\n        // Call superclass method if the knowledge-base was not properly created.\n        if( m_knowledgeBase == null ) {\n            LOG.error(\"KnowledgeBase is NULL, creating basic ticket form alarm.\");\n            return super.createTicketFromAlarm(alarm);\n        }\n        \n        Ticket ticket = new Ticket();\n        StatefulKnowledgeSession session = m_knowledgeBase.newStatefulKnowledgeSession();\n        try {\n            // Pass the ticket as a global - the logic will fill the appropriate fields\n            session.setGlobal(\"ticket\", ticket);\n            // Pass the alarm and the node objects\n            session.insert(alarm);\n            session.insert(alarm.getNode());\n            session.fireAllRules();\n        } finally {\n            session.dispose();\n        }\n\n        LOG.debug(\"Succesfully initialized ticket: {} from alarm: {}.\", ticket, alarm);\n        return ticket;\n    }","id":41906,"modified_method":"/**\n\t * Called from API implemented method after successful retrieval of Alarm.\n\t * \n\t * @param alarm OpenNMS Model class alarm\n\t * @param attributes\n     * @return OpenNMS Ticket processed by Drools logic.\n\t */\n    @Override\n    protected Ticket createTicketFromAlarm(OnmsAlarm alarm, Map<String, String> attributes) {\n        LOG.debug(\"Initializing ticket from alarm: {}\", alarm);\n\n        // Call superclass method if the knowledge-base was not properly created.\n        if( m_knowledgeBase == null ) {\n            LOG.error(\"KnowledgeBase is NULL, creating basic ticket form alarm.\");\n            return super.createTicketFromAlarm(alarm, attributes);\n        }\n        \n        Ticket ticket = new Ticket();\n        StatefulKnowledgeSession session = m_knowledgeBase.newStatefulKnowledgeSession();\n        try {\n            // Pass the ticket as a global - the logic will fill the appropriate fields\n            session.setGlobal(\"ticket\", ticket);\n            // Pass the alarm and the node objects\n            session.insert(alarm);\n            session.insert(alarm.getNode());\n            session.fireAllRules();\n        } finally {\n            session.dispose();\n        }\n\n        LOG.debug(\"Successfully initialized ticket: {} from alarm: {}.\", ticket, alarm);\n        return ticket;\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Test method for {@link org.opennms.netmgt.ticketd.DefaultTicketerServiceLayer#createTicketForAlarm(int)}.\n     */\n    public void testCreateTicketForAlarm() {\n        EasyMock.expect(m_alarmDao.get(m_alarm.getId())).andReturn(m_alarm);\n\n        expectNewTicket();\n\n        expectNewAlarmState(TroubleTicketState.OPEN);\n\n        m_easyMockUtils.replayAll();\n\n        m_droolsTicketerServiceLayer.createTicketForAlarm(m_alarm.getId(), new HashMap<String, String>());\n\n        m_easyMockUtils.verifyAll();\n    }","id":41907,"modified_method":"@Test\n    public void testCreateTicketForAlarm() throws PluginException {\n        EasyMock.expect(m_alarmDao.get(m_alarm.getId())).andReturn(m_alarm);\n\n        expectNewTicket();\n\n        expectNewAlarmState(TroubleTicketState.OPEN);\n\n        m_easyMockUtils.replayAll();\n\n        m_droolsTicketerServiceLayer.createTicketForAlarm(m_alarm.getId(), new HashMap<>());\n\n        m_easyMockUtils.verifyAll();\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Test method for {@link org.opennms.netmgt.ticketd.DefaultTicketerServiceLayer#createTicketForAlarm(int)}.\n     * Tests for correct alarm TroubleTicketState set as CREATE_FAILED when ticketer plugin fails\n     */\n    public void testFailedCreateTicketForAlarm() {\n    \t\n        EasyMock.expect(m_alarmDao.get(m_alarm.getId())).andReturn(m_alarm);\n        \n        try {\n            m_ticketerPlugin.saveOrUpdate(EasyMock.isA(Ticket.class));\n        } catch (PluginException e) {\n            e.printStackTrace();\n        }\n        \n        EasyMock.expectLastCall().andThrow(new PluginException(\"Failed Create\"));\n\n        expectNewAlarmState(TroubleTicketState.CREATE_FAILED);\n        \n        m_easyMockUtils.replayAll();\n        \n        m_droolsTicketerServiceLayer.createTicketForAlarm(m_alarm.getId(),new HashMap<String, String>());\n        \n        m_easyMockUtils.verifyAll();\n    }","id":41908,"modified_method":"/**\n     * Tests for correct alarm TroubleTicketState set as CREATE_FAILED when ticketer plugin fails\n     */\n    @Test\n    public void testFailedCreateTicketForAlarm() throws PluginException {\n    \t\n        EasyMock.expect(m_alarmDao.get(m_alarm.getId())).andReturn(m_alarm);\n        \n        m_ticketerPlugin.saveOrUpdate(EasyMock.isA(Ticket.class));\n\n        EasyMock.expectLastCall().andThrow(new PluginException(\"Failed Create\"));\n\n        expectNewAlarmState(TroubleTicketState.CREATE_FAILED);\n        \n        m_easyMockUtils.replayAll();\n        \n        m_droolsTicketerServiceLayer.createTicketForAlarm(m_alarm.getId(), new HashMap<>());\n        \n        m_easyMockUtils.verifyAll();\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param state\n     */\n    private void expectNewAlarmState(final TroubleTicketState state) {\n        m_alarmDao.saveOrUpdate(m_alarm);\n        EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {\n            @Override\n            public Object answer() throws Throwable {\n                OnmsAlarm alarm = (OnmsAlarm) EasyMock.getCurrentArguments()[0];\n                assertEquals(state, alarm.getTTicketState());\n                return null;\n            }\n        });\n    }","id":41909,"modified_method":"private void expectNewAlarmState(final TroubleTicketState state) {\n        m_alarmDao.saveOrUpdate(m_alarm);\n        EasyMock.expectLastCall().andAnswer(() -> {\n            OnmsAlarm alarm = (OnmsAlarm) EasyMock.getCurrentArguments()[0];\n            assertEquals(state, alarm.getTTicketState());\n            return null;\n        });\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param state\n     */\n    private void expectNewTicket() {\n        try {\n            m_ticketerPlugin.saveOrUpdate(EasyMock.isA(Ticket.class));\n        } catch (PluginException e) {\n            e.printStackTrace();\n        }\n        EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {\n            @Override\n            public Object answer() throws Throwable {\n                Ticket ticket = (Ticket) EasyMock.getCurrentArguments()[0];\n                assertNull(ticket.getId());\n                ticket.setId(\"7\");\n                \n                //\n                // Verify the properties as generated by the Drools engine\n                //\n                assertEquals(\"Not Test Logmsg\", ticket.getSummary());\n                assertEquals(\"Not Test Description\", ticket.getDetails());\n                assertEquals(\"Jesse\", ticket.getUser());\n                return null;\n            }\n        });\n    }","id":41910,"modified_method":"private void expectNewTicket() throws PluginException {\n        m_ticketerPlugin.saveOrUpdate(EasyMock.isA(Ticket.class));\n        EasyMock.expectLastCall().andAnswer(() -> {\n            Ticket ticket = (Ticket) EasyMock.getCurrentArguments()[0];\n            assertNull(ticket.getId());\n            ticket.setId(\"7\");\n\n            // Verify the properties as generated by the Drools engine\n            assertEquals(\"Not Test Logmsg\", ticket.getSummary());\n            assertEquals(\"Not Test Description\", ticket.getDetails());\n            assertEquals(\"Jesse\", ticket.getUser());\n            assertEquals(\n                    ImmutableMap.of(\"custom-key\", \"custom-value\"),\n                    ticket.getAttributes());\n            return null;\n        });\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        m_eventIpcManager = new MockEventIpcManager();\n        EventIpcManagerFactory.setIpcManager(m_eventIpcManager);\n        MockLogAppender.setupLogging();\n        \n        ResourceLoader loader = new DefaultResourceLoader();\n        Resource resource = loader.getResource(\"classpath:drools-ticketer-rules.drl\");\n        \n        m_easyMockUtils = new EasyMockUtils();\n        m_configDao = m_easyMockUtils.createMock(DroolsTicketerConfigDao.class);\n        EasyMock.expect(m_configDao.getRulesFile()).andReturn(resource.getFile()).times(1);\n        EasyMock.replay(m_configDao);\n        \n        m_alarmDao = m_easyMockUtils.createMock(AlarmDao.class);\n        m_ticketerPlugin = m_easyMockUtils.createMock(Plugin.class);\n        \n        m_droolsTicketerServiceLayer = new DroolsTicketerServiceLayer(m_configDao);\n        m_droolsTicketerServiceLayer.setAlarmDao(m_alarmDao);\n        m_droolsTicketerServiceLayer.setTicketerPlugin(m_ticketerPlugin);\n        \n        EasyMock.reset(m_configDao);\n        \n        m_alarm = new OnmsAlarm();\n        m_alarm.setId(1);\n        m_alarm.setLogMsg(\"Test Logmsg\");\n        m_alarm.setDescription(\"Test Description\");\n        m_alarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n        \n        m_ticket = new Ticket();\n        m_ticket.setId(\"4\");\n    }","id":41911,"modified_method":"@Before\n    public void setUp() throws Exception {\n        m_eventIpcManager = new MockEventIpcManager();\n        EventIpcManagerFactory.setIpcManager(m_eventIpcManager);\n        MockLogAppender.setupLogging();\n        \n        ResourceLoader loader = new DefaultResourceLoader();\n        Resource resource = loader.getResource(\"classpath:drools-ticketer-rules.drl\");\n        \n        m_easyMockUtils = new EasyMockUtils();\n        m_configDao = m_easyMockUtils.createMock(DroolsTicketerConfigDao.class);\n        EasyMock.expect(m_configDao.getRulesFile()).andReturn(resource.getFile()).times(1);\n        EasyMock.replay(m_configDao);\n        \n        m_alarmDao = m_easyMockUtils.createMock(AlarmDao.class);\n        m_ticketerPlugin = m_easyMockUtils.createMock(Plugin.class);\n        \n        m_droolsTicketerServiceLayer = new DroolsTicketerServiceLayer(m_configDao);\n        m_droolsTicketerServiceLayer.setAlarmDao(m_alarmDao);\n        m_droolsTicketerServiceLayer.setTicketerPlugin(m_ticketerPlugin);\n        \n        EasyMock.reset(m_configDao);\n        \n        m_alarm = new OnmsAlarm();\n        m_alarm.setId(1);\n        m_alarm.setLogMsg(\"Test Logmsg\");\n        m_alarm.setDescription(\"Test Description\");\n        m_alarm.setUei(\"uei.opennms.org/nodes/nodeDown\");\n        \n        m_ticket = new Ticket();\n        m_ticket.setId(\"4\");\n    }","commit_id":"caa9a80efbe4d22699915eed36d22739280b9096","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void reportResult(int locationMonitorID, int serviceId, PollStatus status) {\n        \n        OnmsLocationMonitor locationMonitor = m_locMonDao.get(locationMonitorID);\n        OnmsMonitoredService monSvc = m_monSvcDao.get(serviceId);\n        \n        OnmsLocationSpecificStatusChange currentStatus = m_locMonDao.getMostRecentStatusChange(locationMonitor, monSvc);\n        \n        if (!currentStatus.equals(status)) {\n            OnmsLocationSpecificStatusChange newStatus = new OnmsLocationSpecificStatusChange(locationMonitor, monSvc, status);\n            m_locMonDao.saveStatusChange(newStatus);\n        }\n    }","id":41912,"modified_method":"public void reportResult(int locationMonitorID, int serviceId, PollStatus pollResult) {\n        \n        OnmsLocationMonitor locationMonitor = m_locMonDao.get(locationMonitorID);\n        OnmsMonitoredService monSvc = m_monSvcDao.get(serviceId);\n        OnmsLocationSpecificStatus newStatus = new OnmsLocationSpecificStatus(locationMonitor, monSvc, pollResult);\n        \n        if (newStatus.getPollResult().getResponseTime() >= 0) {\n            m_locMonDao.savePerformanceData(newStatus);\n        }\n        \n        OnmsLocationSpecificStatus currentStatus = m_locMonDao.getMostRecentStatusChange(locationMonitor, monSvc);\n        \n        if (currentStatus == null || !currentStatus.getPollResult().equals(pollResult)) {\n            m_locMonDao.saveStatusChange(newStatus);\n        }\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsLocationSpecificStatusChange getMostRecentStatusChange(OnmsLocationMonitor locationMonitor, OnmsMonitoredService monSvc) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","id":41913,"modified_method":"public OnmsLocationSpecificStatus getMostRecentStatusChange(OnmsLocationMonitor locationMonitor, OnmsMonitoredService monSvc) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void saveStatusChange(OnmsLocationSpecificStatusChange statusChange) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","id":41914,"modified_method":"public void saveStatusChange(OnmsLocationSpecificStatus statusChange) {\n        throw new UnsupportedOperationException(\"not yet implemented\");\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        \n        m_locMonDao = createMock(LocationMonitorDao.class);\n        m_monSvcDao = createMock(MonitoredServiceDao.class);\n        m_pollerConfig = createMock(PollerConfig.class);\n        \n        m_backEnd = new DefaultPollerBackEnd();\n        m_backEnd.setLocationMonitorDao(m_locMonDao);\n        m_backEnd.setMonitoredServiceDao(m_monSvcDao);\n        m_backEnd.setPollerConfig(m_pollerConfig);\n        \n        m_backEnd.afterPropertiesSet();\n\n        // set up some objects that can be used to mock up the tests\n        m_locationDefinition = new OnmsMonitoringLocationDefinition();\n        m_locationDefinition.setArea(\"Oakland\");\n        m_locationDefinition.setName(\"OAK\");\n        m_locationDefinition.setPollingPackageName(\"OAKPackage\");\n        \n        m_locations = Collections.singleton(m_locationDefinition);\n        \n        m_package = createPackage(m_locationDefinition.getPollingPackageName(), \"ipaddr = '192.168.1.1'\");\n        m_httpSvcConfig = addService(m_package, \"HTTP\", 1234, \"url\", \"http://www.opennms.org\");\n        m_dnsSvcConfig = addService(m_package, \"DNS\", 5678, \"hostname\", \"www.opennms.org\");\n        m_serviceSelector = new ServiceSelector(m_package.getFilter().getContent(), Arrays.asList(new String[]{ \"HTTP\", \"DNS\" }));\n\n        m_locationMonitor = new OnmsLocationMonitor();\n        m_locationMonitor.setId(1);\n        m_locationMonitor.setLocationDefinition(m_locationDefinition);\n        \n        NetworkBuilder builder = new NetworkBuilder(new OnmsDistPoller(\"localhost\", \"127.0.0.1\"));\n        OnmsNode node = builder.addNode(\"testNode\");\n        node.setId(1);\n        OnmsIpInterface iface = builder.addInterface(\"192.168.1.1\").getInterface();\n        iface.setId(1);\n        m_httpService = builder.addService(new OnmsServiceType(\"HTTP\"));\n        m_httpService.setId(1);\n        m_dnsService = builder.addService(new OnmsServiceType(\"DNS\"));\n        m_dnsService.setId(2);\n        \n        \n        \n        m_monServices = new OnmsMonitoredService[] { m_httpService, m_dnsService };\n        \n        long now = System.currentTimeMillis();\n        \n        PollStatus httpResult = PollStatus.available(1000L);\n        httpResult.setTimestamp(now - 300000);\n\n        m_httpCurrentStatus = new OnmsLocationSpecificStatusChange(m_locationMonitor, m_httpService, httpResult);\n        m_httpCurrentStatus.setId(1);\n\n        PollStatus dnsResult = PollStatus.unavailable(\"Non responsive\");\n        dnsResult.setTimestamp(now - 300000);\n\n        m_dnsCurrentStatus = new OnmsLocationSpecificStatusChange(m_locationMonitor, m_dnsService, dnsResult);\n        m_dnsCurrentStatus.setId(2);\n\n    }","id":41915,"modified_method":"protected void setUp() throws Exception {\n        \n        System.setProperty(\"opennms.home\", \"src/test/test-configurations/PollerBackEndTest-home\");\n        \n        m_locMonDao = createMock(LocationMonitorDao.class);\n        m_monSvcDao = createMock(MonitoredServiceDao.class);\n        m_pollerConfig = createMock(PollerConfig.class);\n        m_scheduler = createMock(Scheduler.class);\n        \n        m_backEnd = new DefaultPollerBackEnd();\n        m_backEnd.setLocationMonitorDao(m_locMonDao);\n        m_backEnd.setMonitoredServiceDao(m_monSvcDao);\n        m_backEnd.setPollerConfig(m_pollerConfig);\n        \n        m_backEnd.afterPropertiesSet();\n\n        // set up some objects that can be used to mock up the tests\n        \n        // the location definition\n        m_locationDefinition = new OnmsMonitoringLocationDefinition();\n        m_locationDefinition.setArea(\"Oakland\");\n        m_locationDefinition.setName(\"OAK\");\n        m_locationDefinition.setPollingPackageName(\"OAKPackage\");\n        \n        m_package = createPackage(m_locationDefinition.getPollingPackageName(), \"ipaddr = '192.168.1.1'\");\n        m_serviceSelector = new ServiceSelector(m_package.getFilter().getContent(), Arrays.asList(new String[]{ \"HTTP\", \"DNS\" }));\n\n        m_httpSvcConfig = addService(m_package, \"HTTP\", 1234, \"url\", \"http://www.opennms.org\");\n        m_dnsSvcConfig = addService(m_package, \"DNS\", 5678, \"hostname\", \"www.opennms.org\");\n\n        m_locationMonitor = new OnmsLocationMonitor();\n        m_locationMonitor.setId(1);\n        m_locationMonitor.setLocationDefinition(m_locationDefinition);\n        \n        NetworkBuilder builder = new NetworkBuilder(new OnmsDistPoller(\"localhost\", \"127.0.0.1\"));\n        OnmsNode node = builder.addNode(\"testNode\");\n        node.setId(1);\n        OnmsIpInterface iface = builder.addInterface(\"192.168.1.1\").getInterface();\n        iface.setId(1);\n        m_httpService = builder.addService(new OnmsServiceType(\"HTTP\"));\n        m_httpService.setId(1);\n        m_dnsService = builder.addService(new OnmsServiceType(\"DNS\"));\n        m_dnsService.setId(2);\n        \n        m_monServices = new OnmsMonitoredService[] { m_httpService, m_dnsService };\n        \n        long now = System.currentTimeMillis();\n        \n        PollStatus httpResult = PollStatus.available(1000L);\n        httpResult.setTimestamp(now - 300000);\n\n        m_httpCurrentStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_httpService, httpResult);\n        m_httpCurrentStatus.setId(1);\n\n        PollStatus dnsResult = PollStatus.unavailable(\"Non responsive\");\n        dnsResult.setTimestamp(now - 300000);\n\n        m_dnsCurrentStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_dnsService, dnsResult);\n        m_dnsCurrentStatus.setId(2);\n\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testStatusChangeFromUpToDown() {\n        \n        expect(m_locMonDao.get(1)).andReturn(m_locationMonitor);\n        expect(m_monSvcDao.get(1)).andReturn(m_httpService);\n        \n        expect(m_locMonDao.getMostRecentStatusChange(m_locationMonitor, m_httpService)).andReturn(m_httpCurrentStatus);\n        \n        final PollStatus newStatus = PollStatus.unavailable(\"Test Down\");\n        \n        m_locMonDao.saveStatusChange(isA(OnmsLocationSpecificStatusChange.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationSpecificStatusChange statusChange = (OnmsLocationSpecificStatusChange)getCurrentArguments()[0];\n                assertEquals(m_locationMonitor, statusChange.getLocationMonitor());\n                assertEquals(m_httpService, statusChange.getMonitoredService());\n                assertEquals(newStatus.getStatusCode(), statusChange.getStatus().getStatusCode());\n                assertEquals(newStatus.getResponseTime(), statusChange.getStatus().getResponseTime());\n                assertEquals(newStatus.getReason(), statusChange.getStatus().getReason());\n                \n                return null;\n            }\n            \n        });\n        \n        replay(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        m_backEnd.reportResult(1, 1, newStatus);\n        \n        verify(m_locMonDao, m_monSvcDao, m_pollerConfig);\n    }","id":41916,"modified_method":"public void testStatusChangeFromUpToDown() {\n        \n        expect(m_locMonDao.get(1)).andReturn(m_locationMonitor);\n        expect(m_monSvcDao.get(1)).andReturn(m_httpService);\n        \n        expect(m_locMonDao.getMostRecentStatusChange(m_locationMonitor, m_httpService)).andReturn(m_httpCurrentStatus);\n        \n        final PollStatus newStatus = PollStatus.unavailable(\"Test Down\");\n        \n        OnmsLocationSpecificStatus expectedStatus = new OnmsLocationSpecificStatus(m_locationMonitor, m_httpService, newStatus);\n        \n        m_locMonDao.saveStatusChange(isA(OnmsLocationSpecificStatus.class));\n        expectLastCall().andAnswer(new StatusChecker(expectedStatus));\n\n        replayMocks();\n        \n        m_backEnd.reportResult(1, 1, newStatus);\n        \n        verifyMocks();\n\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testRegisterLocationMonitor() {\n        \n \n        expect(m_locMonDao.findMonitoringLocationDefinition(m_locationDefinition.getName())).andReturn(m_locationDefinition);\n        m_locMonDao.save(isA(OnmsLocationMonitor.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationMonitor mon = (OnmsLocationMonitor)getCurrentArguments()[0];\n                mon.setId(1);\n                return null;\n            }\n            \n        });\n        \n        replay(m_locMonDao);\n        \n        int locationMonitorId = m_backEnd.registerLocationMonitor(m_locationDefinition.getName());\n        \n        verify(m_locMonDao);\n        \n        assertEquals(1, locationMonitorId);\n        \n        \n        \n    }","id":41917,"modified_method":"public void testRegisterLocationMonitor() {\n        \n        expect(m_locMonDao.findMonitoringLocationDefinition(m_locationDefinition.getName())).andReturn(m_locationDefinition);\n\n        m_locMonDao.save(isA(OnmsLocationMonitor.class));\n        expectLastCall().andAnswer(new IAnswer<Object>() {\n\n            public Object answer() throws Throwable {\n                OnmsLocationMonitor mon = (OnmsLocationMonitor)getCurrentArguments()[0];\n                mon.setId(1);\n                return null;\n            }\n            \n        });\n        \n        replayMocks();\n        \n        int locationMonitorId = m_backEnd.registerLocationMonitor(m_locationDefinition.getName());\n        \n        verifyMocks();\n        \n        assertEquals(1, locationMonitorId);\n        \n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetMonitoringLocations() {\n        \n        expect(m_locMonDao.findAllMonitoringLocationDefinitions()).andReturn(m_locations);\n        \n        replay(m_locMonDao);\n        \n        Collection<OnmsMonitoringLocationDefinition> returned = m_backEnd.getMonitoringLocations();\n        \n        verify(m_locMonDao);\n        \n        assertEquals(m_locations, returned);\n        \n    }","id":41918,"modified_method":"public void testGetMonitoringLocations() {\n        \n        Collection<OnmsMonitoringLocationDefinition> locations = Collections.singleton(m_locationDefinition);\n        \n        expect(m_locMonDao.findAllMonitoringLocationDefinitions()).andReturn(locations);\n        \n        replayMocks();\n        \n        Collection<OnmsMonitoringLocationDefinition> returned = m_backEnd.getMonitoringLocations();\n        \n        verifyMocks();\n        \n        assertEquals(locations, returned);\n        \n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetPollerConfiguration() {\n        \n        expect(m_locMonDao.get(m_locationMonitor.getId())).andReturn(m_locationMonitor);\n        \n        expect(m_pollerConfig.getPackage(m_locationDefinition.getPollingPackageName())).andReturn(m_package);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_package)).andReturn(m_serviceSelector);\n        expect(m_pollerConfig.getServiceInPackage(\"HTTP\", m_package)).andReturn(m_httpSvcConfig);\n        expect(m_pollerConfig.getServiceInPackage(\"DNS\", m_package)).andReturn(m_dnsSvcConfig);\n        \n        expect(m_monSvcDao.findMatchingServices(m_serviceSelector)).andReturn(Arrays.asList(m_monServices));\n        \n        replay(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        PollerConfiguration config = m_backEnd.getPollerConfiguration(m_locationMonitor.getId());\n        \n        verify(m_locMonDao, m_monSvcDao, m_pollerConfig);\n        \n        assertNotNull(config);\n        assertEquals(2, config.getConfigurationForPoller().length);\n        assertEquals(m_httpService, config.getConfigurationForPoller()[0].getMonitoredService());\n        assertEquals(m_dnsService, config.getConfigurationForPoller()[1].getMonitoredService());\n        assertEquals(5678, config.getConfigurationForPoller()[1].getPollModel().getPollInterval());\n        assertTrue(config.getConfigurationForPoller()[1].getMonitorConfiguration().containsKey(\"hostname\"));\n    }","id":41919,"modified_method":"public void testGetPollerConfiguration() {\n        \n        expect(m_locMonDao.get(m_locationMonitor.getId())).andReturn(m_locationMonitor);\n        \n        expect(m_pollerConfig.getPackage(m_locationDefinition.getPollingPackageName())).andReturn(m_package);\n        expect(m_pollerConfig.getServiceSelectorForPackage(m_package)).andReturn(m_serviceSelector);\n        expect(m_pollerConfig.getServiceInPackage(\"HTTP\", m_package)).andReturn(m_httpSvcConfig);\n        expect(m_pollerConfig.getServiceInPackage(\"DNS\", m_package)).andReturn(m_dnsSvcConfig);\n        \n        expect(m_monSvcDao.findMatchingServices(m_serviceSelector)).andReturn(Arrays.asList(m_monServices));\n        \n        replayMocks();\n        \n        PollerConfiguration config = m_backEnd.getPollerConfiguration(m_locationMonitor.getId());\n        \n        verifyMocks();\n        \n        assertNotNull(config);\n        assertEquals(2, config.getConfigurationForPoller().length);\n        assertEquals(m_httpService, config.getConfigurationForPoller()[0].getMonitoredService());\n        assertEquals(m_dnsService, config.getConfigurationForPoller()[1].getMonitoredService());\n        assertEquals(5678, config.getConfigurationForPoller()[1].getPollModel().getPollInterval());\n        assertTrue(config.getConfigurationForPoller()[1].getMonitorConfiguration().containsKey(\"hostname\"));\n    }","commit_id":"e7a35bdf02ceca3418caf261942c1c5c6c669b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The method <code>getDescendants<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence the context sequence\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getDescendants(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getDescendants(axis == Constants.DESCENDANT_SELF_AXIS, test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        //TODO : understand this. I guess comments should be treated in a similar way ? -pb\n        if (test.isWildcardTest() || test.getType() == Type.PROCESSING_INSTRUCTION) {\n            // test is one out of *, text(), node() including processing-instruction(targetname)\n            VirtualNodeSet vset = new VirtualNodeSet(context.getBroker(), axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            // TODO : understand why this one is different from the other ones\n            //TODO : currentDocs can not be null here\n            //TODO : currentSet can not be null here\n            if (!optimized && (currentSet == null || currentDocs == null\n                || !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT,\n                                                         docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, \n                    \t\tNodeSet.DESCENDANT, true, contextId);\n                case Constants.DESCENDANT_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, \n                    \t\tNodeSet.DESCENDANT, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n            DocumentSet docs = contextSet.getDocumentSet();\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled()) {\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            }\n            if (contextSet instanceof ExtNodeSet) {\n            \treturn index.findDescendantsByTagName(ElementValue.ELEMENT, \n            \t\t\ttest.getName(), axis, docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n                NodeSelector selector;\n                switch (axis) {\n                    case Constants.DESCENDANT_SELF_AXIS:\n                        selector = new DescendantOrSelfSelector(contextSet, contextId);\n                        break;\n                    case Constants.DESCENDANT_AXIS:\n                        selector = new DescendantSelector(contextSet, contextId);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Unsupported axis specified\");\n                }\n                return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n            }\n\n        }\n    }","id":41920,"modified_method":"/**\n     * The method <code>getDescendants<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence the context sequence\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getDescendants(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getDescendants(axis == Constants.DESCENDANT_SELF_AXIS, test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        //TODO : understand this. I guess comments should be treated in a similar way ? -pb\n        if (test.isWildcardTest() || test.getType() == Type.PROCESSING_INSTRUCTION) {\n            // test is one out of *, text(), node() including processing-instruction(targetname)\n            VirtualNodeSet vset = new VirtualNodeSet(context.getBroker(), axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            // TODO : understand why this one is different from the other ones\n            if (currentSet == null || currentDocs == null ||\n                    (!optimized && !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT,\n                                                         docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, \n                    \t\tNodeSet.DESCENDANT, true, contextId);\n                case Constants.DESCENDANT_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, \n                    \t\tNodeSet.DESCENDANT, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n            DocumentSet docs = contextSet.getDocumentSet();\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled()) {\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            }\n            if (contextSet instanceof ExtNodeSet) {\n            \treturn index.findDescendantsByTagName(ElementValue.ELEMENT, \n            \t\t\ttest.getName(), axis, docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n                NodeSelector selector;\n                switch (axis) {\n                    case Constants.DESCENDANT_SELF_AXIS:\n                        selector = new DescendantOrSelfSelector(contextSet, contextId);\n                        break;\n                    case Constants.DESCENDANT_AXIS:\n                        selector = new DescendantSelector(contextSet, contextId);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Unsupported axis specified\");\n                }\n                return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n            }\n\n        }\n    }","commit_id":"2737c2069f84098f5f1f32cc5279e6050505b9b7","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The method <code>getAttributes<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>NodeSet<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getAttributes(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            if (axis == Constants.DESCENDANT_ATTRIBUTE_AXIS)\n                return nodes.getDescendantAttributes(test);\n            else\n                return nodes.getAttributes(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        boolean selectDirect = false;\n        if (useDirectAttrSelect && axis == Constants.ATTRIBUTE_AXIS) {\n            if (contextSet instanceof VirtualNodeSet)\n                selectDirect = ((VirtualNodeSet) contextSet).preferTreeTraversal()\n                    && contextSet.getLength() < ATTR_DIRECT_SELECT_THRESHOLD;\n            else\n                selectDirect = contextSet.getLength() < ATTR_DIRECT_SELECT_THRESHOLD;\n        }\n        if (selectDirect) {\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\", \"direct attribute selection\");\n            if (contextSet.isEmpty())\n                return NodeSet.EMPTY_SET;\n            //TODO : why only the first node ?\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy != null)\n                return contextSet.directSelectAttribute(context.getBroker(), test, contextId);\n        }\n        if (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(context.getBroker(), axis, test, contextId, contextSet);\n            ((VirtualNodeSet) result).setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return result;\n            // if there's just a single known node in the context, it is faster\n            // do directly search for the attribute in the parent node.\n        }\n        if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : currentDocs can not be null here\n            //TODO : currentSet can not be null here\n            if (!optimized && (currentSet == null || currentDocs == null\n                || !(docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                // TODO : why a null selector here ? We have one below !\n                currentSet = index.findElementsByTagName(ElementValue.ATTRIBUTE, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS:\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, contextId);\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n        \tDocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            if (contextSet instanceof ExtNodeSet && !contextSet.getProcessInReverseOrder()) {\n                return index.findDescendantsByTagName(ElementValue.ATTRIBUTE, test.getName(), axis,\n                                                      docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n            \tNodeSelector selector;            \n                switch (axis) {\n                    case Constants.ATTRIBUTE_AXIS:\n                        selector = new ChildSelector(contextSet, contextId);\n                        break;\n                    case Constants.DESCENDANT_ATTRIBUTE_AXIS:\n                        selector = new DescendantSelector(contextSet, contextId);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Unsupported axis specified\");\n                }\n                return index.findElementsByTagName(ElementValue.ATTRIBUTE, docs, test.getName(), selector);\n            }\n        }\n    }","id":41921,"modified_method":"/**\n     * The method <code>getAttributes<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>NodeSet<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getAttributes(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            if (axis == Constants.DESCENDANT_ATTRIBUTE_AXIS)\n                return nodes.getDescendantAttributes(test);\n            else\n                return nodes.getAttributes(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        boolean selectDirect = false;\n        if (useDirectAttrSelect && axis == Constants.ATTRIBUTE_AXIS) {\n            if (contextSet instanceof VirtualNodeSet)\n                selectDirect = ((VirtualNodeSet) contextSet).preferTreeTraversal()\n                    && contextSet.getLength() < ATTR_DIRECT_SELECT_THRESHOLD;\n            else\n                selectDirect = contextSet.getLength() < ATTR_DIRECT_SELECT_THRESHOLD;\n        }\n        if (selectDirect) {\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\", \"direct attribute selection\");\n            if (contextSet.isEmpty())\n                return NodeSet.EMPTY_SET;\n            //TODO : why only the first node ?\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy != null)\n                return contextSet.directSelectAttribute(context.getBroker(), test, contextId);\n        }\n        if (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(context.getBroker(), axis, test, contextId, contextSet);\n            ((VirtualNodeSet) result).setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return result;\n            // if there's just a single known node in the context, it is faster\n            // do directly search for the attribute in the parent node.\n        }\n        if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null ||\n                    (!optimized && !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                // TODO : why a null selector here ? We have one below !\n                currentSet = index.findElementsByTagName(ElementValue.ATTRIBUTE, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS:\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, contextId);\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS:\n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n        \tDocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            if (contextSet instanceof ExtNodeSet && !contextSet.getProcessInReverseOrder()) {\n                return index.findDescendantsByTagName(ElementValue.ATTRIBUTE, test.getName(), axis,\n                                                      docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n            \tNodeSelector selector;            \n                switch (axis) {\n                    case Constants.ATTRIBUTE_AXIS:\n                        selector = new ChildSelector(contextSet, contextId);\n                        break;\n                    case Constants.DESCENDANT_ATTRIBUTE_AXIS:\n                        selector = new DescendantSelector(contextSet, contextId);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Unsupported axis specified\");\n                }\n                return index.findElementsByTagName(ElementValue.ATTRIBUTE, docs, test.getName(), selector);\n            }\n        }\n    }","commit_id":"2737c2069f84098f5f1f32cc5279e6050505b9b7","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The method <code>getParents<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>Sequence<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getParents(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getParents(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        if (test.isWildcardTest()) {\n            NodeSet temp = contextSet.getParents(contextId);\n            NodeSet result = new NewArrayNodeSet();\n            NodeProxy p;\n            for (Iterator i = temp.iterator(); i.hasNext(); ) {\n                p = (NodeProxy) i.next();\n\n                if (test.matches(p)) {\n                    result.add(p);\n                }\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : currentDocs can not be null here\n            //TODO : currentSet can not be null here\n            if (!optimized && (currentSet == null || currentDocs == null\n                || !(docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return contextSet.selectParentChild(currentSet, NodeSet.ANCESTOR); \n        } else {\n        \tDocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();            \n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            NodeSelector selector = new ParentSelector(contextSet, contextId);\n            return index.findElementsByTagName(ElementValue.ELEMENT, \n            \t\tdocs, test.getName(), selector);\n        }\n    }","id":41922,"modified_method":"/**\n     * The method <code>getParents<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>Sequence<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getParents(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getParents(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        if (test.isWildcardTest()) {\n            NodeSet temp = contextSet.getParents(contextId);\n            NodeSet result = new NewArrayNodeSet();\n            NodeProxy p;\n            for (Iterator i = temp.iterator(); i.hasNext(); ) {\n                p = (NodeProxy) i.next();\n\n                if (test.matches(p)) {\n                    result.add(p);\n                }\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null ||\n                    (!optimized && !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return contextSet.selectParentChild(currentSet, NodeSet.ANCESTOR); \n        } else {\n        \tDocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();            \n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            NodeSelector selector = new ParentSelector(contextSet, contextId);\n            return index.findElementsByTagName(ElementValue.ELEMENT, \n            \t\tdocs, test.getName(), selector);\n        }\n    }","commit_id":"2737c2069f84098f5f1f32cc5279e6050505b9b7","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The method <code>getAncestors<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>Sequence<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getAncestors(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getAncestors(axis == Constants.ANCESTOR_SELF_AXIS, test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        if (test.isWildcardTest()) {\n            NodeSet result = new NewArrayNodeSet();\n            result.setProcessInReverseOrder(true);\n            for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                NodeProxy current = (NodeProxy) i.next();\n                NodeProxy ancestor;\n                if (axis == Constants.ANCESTOR_SELF_AXIS\n                    && test.matches(current)) {\n                    ancestor = new NodeProxy(current.getDocument(), current.getNodeId(), \n                                             Node.ELEMENT_NODE, current.getInternalAddress());\n                    NodeProxy t = result.get(ancestor);\n                    if (t == null) {\n                        if (Expression.NO_CONTEXT_ID != contextId)\n                            ancestor.addContextNode(contextId, current);\n                        else\n                            ancestor.copyContext(current);\n                        ancestor.addMatches(current);\n                        result.add(ancestor);\n                    } else {\n                        t.addContextNode(contextId, current);\n                        t.addMatches(current);\n                    }\n                }\n                NodeId parentID = current.getNodeId().getParentId();\n                while (parentID != null) {\n                    ancestor = new NodeProxy(current.getDocument(), parentID, Node.ELEMENT_NODE);\n                    // Filter out the temporary nodes wrapper element\n                    if (parentID != NodeId.DOCUMENT_NODE && \n                        !(parentID.getTreeLevel() == 1  && current.getDocument().getCollection().isTempCollection())) {\n                        if (test.matches(ancestor)) {\n                            NodeProxy t = result.get(ancestor);\n                            if (t == null) {\n                                if (Expression.NO_CONTEXT_ID != contextId)\n                                    ancestor.addContextNode(contextId, current);\n                                else\n                                    ancestor.copyContext(current);\n                                ancestor.addMatches(current);\n                                result.add(ancestor);\n                            } else {\n                                t.addContextNode(contextId, current);\n                                t.addMatches(current);\n                            }\n                        }\n                    }\n                    parentID = parentID.getParentId();\n                }\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : currentDocs can not be null here\n            //TODO : currentSet can not be null here\n            if (!optimized && (currentSet == null || currentDocs == null\n                || !(docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS:\n                    return currentSet.selectAncestors(contextSet, true, contextId);\n                case Constants.ANCESTOR_AXIS:\n                    return currentSet.selectAncestors(contextSet, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            NodeSelector selector;\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS:\n                    selector = new AncestorSelector(contextSet, contextId, true);\n                    break;\n                case Constants.ANCESTOR_AXIS:\n                    selector = new AncestorSelector(contextSet, contextId, false);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n            return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n        }\n    }","id":41923,"modified_method":"/**\n     * The method <code>getAncestors<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence a <code>Sequence<\/code> value\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getAncestors(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getAncestors(axis == Constants.ANCESTOR_SELF_AXIS, test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        if (test.isWildcardTest()) {\n            NodeSet result = new NewArrayNodeSet();\n            result.setProcessInReverseOrder(true);\n            for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                NodeProxy current = (NodeProxy) i.next();\n                NodeProxy ancestor;\n                if (axis == Constants.ANCESTOR_SELF_AXIS\n                    && test.matches(current)) {\n                    ancestor = new NodeProxy(current.getDocument(), current.getNodeId(), \n                                             Node.ELEMENT_NODE, current.getInternalAddress());\n                    NodeProxy t = result.get(ancestor);\n                    if (t == null) {\n                        if (Expression.NO_CONTEXT_ID != contextId)\n                            ancestor.addContextNode(contextId, current);\n                        else\n                            ancestor.copyContext(current);\n                        ancestor.addMatches(current);\n                        result.add(ancestor);\n                    } else {\n                        t.addContextNode(contextId, current);\n                        t.addMatches(current);\n                    }\n                }\n                NodeId parentID = current.getNodeId().getParentId();\n                while (parentID != null) {\n                    ancestor = new NodeProxy(current.getDocument(), parentID, Node.ELEMENT_NODE);\n                    // Filter out the temporary nodes wrapper element\n                    if (parentID != NodeId.DOCUMENT_NODE && \n                        !(parentID.getTreeLevel() == 1  && current.getDocument().getCollection().isTempCollection())) {\n                        if (test.matches(ancestor)) {\n                            NodeProxy t = result.get(ancestor);\n                            if (t == null) {\n                                if (Expression.NO_CONTEXT_ID != contextId)\n                                    ancestor.addContextNode(contextId, current);\n                                else\n                                    ancestor.copyContext(current);\n                                ancestor.addMatches(current);\n                                result.add(ancestor);\n                            } else {\n                                t.addContextNode(contextId, current);\n                                t.addMatches(current);\n                            }\n                        }\n                    }\n                    parentID = parentID.getParentId();\n                }\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null ||\n                    (!optimized && !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS:\n                    return currentSet.selectAncestors(contextSet, true, contextId);\n                case Constants.ANCESTOR_AXIS:\n                    return currentSet.selectAncestors(contextSet, false, contextId);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            NodeSelector selector;\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS:\n                    selector = new AncestorSelector(contextSet, contextId, true);\n                    break;\n                case Constants.ANCESTOR_AXIS:\n                    selector = new AncestorSelector(contextSet, contextId, false);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }\n            return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n        }\n    }","commit_id":"2737c2069f84098f5f1f32cc5279e6050505b9b7","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The method <code>getChildren<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence the context sequence\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getChildren(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getChildren(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        //TODO : understand this. I guess comments should be treated in a similar way ? -pb\n        if (test.isWildcardTest() || test.getType() == Type.PROCESSING_INSTRUCTION) {\n            // test is one out of *, text(), node() including processing-instruction(targetname)\n            VirtualNodeSet vset = new VirtualNodeSet(context.getBroker(), axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        }\n\n//        IndexStatistics stats = (IndexStatistics) context.getBroker().getBrokerPool().\n//            getIndexManager().getIndexById(IndexStatistics.ID);\n//        int parentDepth = stats.getMaxParentDepth(test.getName());\n//        LOG.debug(\"parentDepth for \" + test.getName() + \": \" + parentDepth);\n\n        if (useDirectChildSelect) {\n            NewArrayNodeSet result = new NewArrayNodeSet();\n            for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n                NodeProxy p = (NodeProxy) i.next();\n                result.addAll(p.directSelectChild(test.getName(), contextId));\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            // TODO : understand why this one is different from the other ones\n            //TODO : currentDocs can not be null here\n            //TODO : currentSet can not be null here\n            if (!optimized && (currentSet == null || currentDocs == null\n                || !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT,\n                                                         docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, contextId);\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            if (contextSet instanceof ExtNodeSet && !contextSet.getProcessInReverseOrder()) {\n                return index.findDescendantsByTagName(ElementValue.ELEMENT, \n                \t\ttest.getName(), axis, docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n                //            \tif (contextSet instanceof VirtualNodeSet)\n                //            \t\t((VirtualNodeSet)contextSet).realize();\n                NodeSelector selector = new ChildSelector(contextSet, contextId);\n                return index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), selector);\n            }\n        }\n    }","id":41924,"modified_method":"/**\n     * The method <code>getChildren<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSequence the context sequence\n     * @return a <code>NodeSet<\/code> value\n     */\n    protected Sequence getChildren(XQueryContext context, Sequence contextSequence) throws XPathException {\n        if (!contextSequence.isPersistentSet()) {\n            MemoryNodeSet nodes = contextSequence.toMemNodeSet();\n            return nodes.getChildren(test);\n        }\n        NodeSet contextSet = contextSequence.toNodeSet();\n        //TODO : understand this. I guess comments should be treated in a similar way ? -pb\n        if (test.isWildcardTest() || test.getType() == Type.PROCESSING_INSTRUCTION) {\n            // test is one out of *, text(), node() including processing-instruction(targetname)\n            VirtualNodeSet vset = new VirtualNodeSet(context.getBroker(), axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        }\n\n//        IndexStatistics stats = (IndexStatistics) context.getBroker().getBrokerPool().\n//            getIndexManager().getIndexById(IndexStatistics.ID);\n//        int parentDepth = stats.getMaxParentDepth(test.getName());\n//        LOG.debug(\"parentDepth for \" + test.getName() + \": \" + parentDepth);\n\n        if (useDirectChildSelect) {\n            NewArrayNodeSet result = new NewArrayNodeSet();\n            for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n                NodeProxy p = (NodeProxy) i.next();\n                result.addAll(p.directSelectChild(test.getName(), contextId));\n            }\n            return result;\n        } else if (hasPreloadedData()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            // TODO : understand why this one is different from the other ones\n            if (currentSet == null || currentDocs == null ||\n                    (!optimized && !(docs == currentDocs || docs.equalDocs(currentDocs)))) {\n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                                  \"OPTIMIZATION\",\n                                                  \"Using structural index '\" + index.toString() + \"'\");\n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT,\n                                                         docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, contextId);\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            if (contextSet instanceof ExtNodeSet && !contextSet.getProcessInReverseOrder()) {\n                return index.findDescendantsByTagName(ElementValue.ELEMENT, \n                \t\ttest.getName(), axis, docs, (ExtNodeSet) contextSet, contextId);\n            } else {\n                //            \tif (contextSet instanceof VirtualNodeSet)\n                //            \t\t((VirtualNodeSet)contextSet).realize();\n                NodeSelector selector = new ChildSelector(contextSet, contextId);\n                return index.findElementsByTagName(ElementValue.ELEMENT, \n                \t\tdocs, test.getName(), selector);\n            }\n        }\n    }","commit_id":"2737c2069f84098f5f1f32cc5279e6050505b9b7","url":"https://github.com/eXist-db/exist"},{"original_method":"public void run() {\n            if(suspended) {\n                if(log.isTraceEnabled())\n                    log.trace(\"stable task will not run as suspended=\" + suspended);\n                return;\n            }\n\n            // asks the NAKACK protocol for the current digest\n            Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n            if(my_digest == null) {\n                if(log.isWarnEnabled())\n                    log.warn(\"received null digest, skipped sending of stable message\");\n                return;\n            }\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(my_digest);\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n            sendStableMessage(my_digest);\n        }","id":41925,"modified_method":"public void run() {\n            if(suspended) {\n                if(log.isTraceEnabled())\n                    log.trace(\"stable task will not run as suspended=\" + suspended);\n                return;\n            }\n\n            // asks the NAKACK protocol for the current digest\n            Digest my_digest=getDigest();\n            if(my_digest == null) {\n                if(log.isWarnEnabled())\n                    log.warn(\"received null digest, skipped sending of stable message\");\n                return;\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n            sendStableMessage(my_digest);\n        }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n        if(!digest.sameSenders(d)) {\n            // to avoid sending incorrect stability/stable msgs, we simply reset our heard_from list, see DESIGN\n            resetDigest(mbrs);\n            return false;\n        }\n\n        StringBuilder sb=null;\n        if(log.isTraceEnabled()) {\n            sb=new StringBuilder(\"[\").append(local_addr).append(\"] handling digest from \").append(sender).append(\" (\").\n                    append(votes.size()).append(\" pending):\\nmine:   \").append(digest.printHighestDeliveredSeqnos())\n                    .append(\"\\nother:  \").append(d.printHighestDeliveredSeqnos());\n        }\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno, my_low, low, new_low;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Digest.Entry val;\n        for(Map.Entry<Address, Digest.Entry> entry: d.getSenders().entrySet()) {\n            mbr=entry.getKey();\n            val=entry.getValue();\n            low=val.getLow();\n            highest_seqno=val.getHighestDeliveredSeqno();      // highest *delivered* seqno\n            highest_seen_seqno=val.getHighestReceivedSeqno();  // highest *received* seqno\n\n            my_low=digest.lowSeqnoAt(mbr);\n            new_low=Math.min(my_low, low);\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highestDeliveredSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highestReceivedSeqnoAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_low, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            sb.append(\"\\nresult: \").append(digest.printHighestDeliveredSeqnos()).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","id":41926,"modified_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    @GuardedBy(\"lock\")\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n        if(!digest.sameSenders(d)) {\n            // to avoid sending incorrect stability/stable msgs, we simply reset our votes list, see DESIGN\n            resetDigest();\n            return false;\n        }\n\n        StringBuilder sb=null;\n        if(log.isTraceEnabled()) {\n            sb=new StringBuilder(\"[\").append(local_addr).append(\"] handling digest from \").append(sender).append(\" (\").\n                    append(votes.size()).append(\" votes):\\nmine:   \").append(digest.printHighestDeliveredSeqnos())\n                    .append(\"\\nother:  \").append(d.printHighestDeliveredSeqnos());\n        }\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno, my_low, low, new_low;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Digest.Entry val;\n        for(Map.Entry<Address, Digest.Entry> entry: d.getSenders().entrySet()) {\n            mbr=entry.getKey();\n            val=entry.getValue();\n            low=val.getLow();\n            highest_seqno=val.getHighestDeliveredSeqno();      // highest *delivered* seqno\n            highest_seen_seqno=val.getHighestReceivedSeqno();  // highest *received* seqno\n\n            my_low=digest.lowSeqnoAt(mbr);\n            new_low=Math.min(my_low, low);\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highestDeliveredSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highestReceivedSeqnoAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_low, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            assert sb != null;\n            sb.append(\"\\nresult: \").append(digest.printHighestDeliveredSeqnos()).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector<Address> tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        adjustSenders(digest, tmp);\n        adjustSenders(latest_local_digest, tmp);\n\n        // asks the NAKACK protocol for the current digest\n        Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n        if(my_digest != null) {\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(my_digest);\n            }\n        }\n\n        resetDigest(tmp);\n        if(!initialized)\n            initialized=true;\n    }","id":41927,"modified_method":"private void handleViewChange(View v) {\n        Vector<Address> tmp=v.getMembers();\n        synchronized(mbrs) {\n            mbrs.clear();\n            mbrs.addAll(tmp);\n        }\n        lock.lock();\n        try {\n            resetDigest();\n            if(!initialized)\n                initialized=true;\n        }\n        finally {\n            lock.unlock();\n        }\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleRegularMessage(Message msg) {\n        // only if message counting is enabled, and only for multicast messages\n        // fixes http://jira.jboss.com/jira/browse/JGRP-233\n        if(max_bytes <= 0)\n            return;\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            received.lock();\n            boolean locked=true;\n            try {\n                num_bytes_received+=(long)msg.getLength();\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        log.trace(new StringBuilder(\"max_bytes has been reached (\").append(max_bytes).\n                                append(\", bytes received=\").append(num_bytes_received).append(\"): triggers stable msg\"));\n                    }\n                    num_bytes_received=0;\n                    received.unlock();\n                    locked=false;\n\n                    // asks the NAKACK protocol for the current digest,\n                    Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n                    synchronized(latest_local_digest) {\n                        latest_local_digest.replace(my_digest);\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n                    sendStableMessage(my_digest);\n                }\n            }\n            finally {\n                if(locked)\n                    received.unlock();\n            }\n        }\n    }","id":41928,"modified_method":"private void handleRegularMessage(Message msg) {\n        // only if message counting is enabled, and only for multicast messages\n        // fixes http://jira.jboss.com/jira/browse/JGRP-233\n        if(max_bytes <= 0)\n            return;\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            received.lock();\n            boolean locked=true;\n            try {\n                num_bytes_received+=(long)msg.getLength();\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        log.trace(new StringBuilder(\"max_bytes has been reached (\").append(max_bytes).\n                                append(\", bytes received=\").append(num_bytes_received).append(\"): triggers stable msg\"));\n                    }\n                    num_bytes_received=0;\n                    received.unlock();\n                    locked=false;\n                    Digest my_digest=getDigest();  // asks the NAKACK protocol for the current digest,\n                    if(log.isTraceEnabled())\n                        log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n                    sendStableMessage(my_digest);\n                }\n            }\n            finally {\n                if(locked)\n                    received.unlock();\n            }\n        }\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStabilityMessage(Digest d, Address sender) {\n         if(d == null) {\n             if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n             return;\n         }\n\n         if(!initialized) {\n             if(log.isTraceEnabled())\n                 log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n             return;\n         }\n\n         if(suspended) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"stability message will not be handled as I'm suspended\");\n             }\n             return;\n         }\n\n         if(log.isTraceEnabled())\n             log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighestDeliveredSeqnos()));\n         stopStabilityTask();\n\n         // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n         // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n         if(!this.digest.sameSenders(d)) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                         this.digest + \"): ignoring digest and re-initializing own digest\");\n             }\n             return;\n         }\n\n         num_stability_msgs_received++;\n\n         resetDigest(mbrs);\n\n         // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n         down_prot.down(new Event(Event.STABLE, d));\n     }","id":41929,"modified_method":"private void handleStabilityMessage(Digest stable_digest, Address sender) {\n        if(stable_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n         if(!initialized) {\n             if(log.isTraceEnabled())\n                 log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n             return;\n         }\n\n         if(suspended) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"stability message will not be handled as I'm suspended\");\n             }\n             return;\n         }\n\n         if(log.isTraceEnabled())\n             log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(stable_digest.printHighestDeliveredSeqnos()));\n         stopStabilityTask();\n\n        lock.lock();\n        try {\n            // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n            // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n            if(!this.digest.sameSenders(stable_digest)) {\n                if(log.isDebugEnabled()) {\n                    log.debug(\"received digest (digest=\" + stable_digest + \") which does not match my own digest (\"+\n                            this.digest + \"): ignoring digest and re-initializing own digest\");\n                }\n                resetDigest();\n                return;\n            }\n            num_stability_msgs_received++;\n            resetDigest();\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        down_prot.down(new Event(Event.STABLE, stable_digest));\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"public void runMessageGarbageCollection() {\n        Digest copy;\n        synchronized(digest) {\n            copy=digest.copy();\n        }\n        sendStableMessage(copy);\n    }","id":41930,"modified_method":"public void runMessageGarbageCollection() {\n        Digest copy=getDigest();\n        sendStableMessage(copy);\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        stopStableTask();\n        clearDigest();\n    }","id":41931,"modified_method":"public void stop() {\n        stopStableTask();\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(!votes.contains(sender)) {  // already received gossip from sender; discard it\n            return;\n        }\n\n        num_stable_msgs_received++;\n\n        Digest copy;\n        synchronized(digest) {\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only remove the sender from heard_from if *all* elements of my digest were updated\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeVote(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","id":41932,"modified_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        Digest copy=null;\n        boolean all_votes_received=false;\n        lock.lock();\n        try {\n            if(votes.contains(sender))  // already received gossip from sender; discard it\n                return;\n            num_stable_msgs_received++;\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only add the sender to votes if *all* elements of my digest were updated\n                return;\n\n            all_votes_received=addVote(sender);\n            if(all_votes_received)\n                copy=digest.copy();\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // we don't yet reset digest: new STABLE messages will be discarded anyway as we have already\n        // received votes from their senders\n        if(copy != null) {\n            sendStabilityMessage(copy);\n        }\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes mbr from heard_from and returns true if this was the last member, otherwise false.\n     * Resets the heard_from list (populates with membership)\n     * @param mbr\n     */\n    private boolean removeVote(Address mbr) {\n        synchronized(votes) {\n            boolean removed=votes.remove(mbr);\n            if(removed && votes.isEmpty()) {\n                resetDigest(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","id":41933,"modified_method":"/**\n     * Adds mbr to votes and returns true if we have all the votes, otherwise false.\n     * @param mbr\n     */\n    @GuardedBy(\"lock\")\n    private boolean addVote(Address mbr) {\n        boolean added=votes.add(mbr);\n        return added && allVotesReceived(votes);\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void resume() {\n        resetDigest(mbrs); // start from scratch\n        suspended=false;\n        if(log.isDebugEnabled())\n            log.debug(\"resuming message garbage collection\");\n        stopResumeTask();\n    }","id":41934,"modified_method":"private void resume() {\n        lock.lock();\n        try {\n            resetDigest(); // start from scratch\n            suspended=false;\n        }\n        finally {\n            lock.unlock();\n        }\n\n        if(log.isDebugEnabled())\n            log.debug(\"resuming message garbage collection\");\n        stopResumeTask();\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void clearDigest() {\n        synchronized(digest) {\n            digest.clear();\n        }\n    }","id":41935,"modified_method":"private Digest getDigest() {\n        return (Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n    }","commit_id":"fbefa95f7ff5ed42e25abe94a1eda344326c5601","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleRegularMessage(Message msg) {\n        // only if message counting is enabled, and only for multicast messages\n        // fixes http://jira.jboss.com/jira/browse/JGRP-233\n        if(max_bytes <= 0)\n            return;\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            received.lock();\n            boolean locked=true;\n            try {\n                num_bytes_received+=(long)msg.getLength();\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        log.trace(new StringBuilder(\"max_bytes has been reached (\").append(max_bytes).\n                                append(\", bytes received=\").append(num_bytes_received).append(\"): triggers stable msg\"));\n                    }\n                    num_bytes_received=0;\n                    received.unlock();\n                    locked=false;\n\n                    // asks the NAKACK protocol for the current digest,\n                    Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n                    synchronized(latest_local_digest) {\n                        latest_local_digest.replace(my_digest);\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n                    sendStableMessage(my_digest);\n                }\n            }\n            finally {\n                if(locked)\n                    received.unlock();\n            }\n        }\n    }","id":41936,"modified_method":"private void handleRegularMessage(Message msg) {\n        // only if message counting is enabled, and only for multicast messages\n        // fixes http://jira.jboss.com/jira/browse/JGRP-233\n        if(max_bytes <= 0)\n            return;\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            received.lock();\n            boolean locked=true;\n            try {\n                num_bytes_received+=(long)msg.getLength();\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        log.trace(new StringBuilder(\"max_bytes has been reached (\").append(max_bytes).\n                                append(\", bytes received=\").append(num_bytes_received).append(\"): triggers stable msg\"));\n                    }\n                    num_bytes_received=0;\n                    received.unlock();\n                    locked=false;\n                    Digest my_digest=getDigest();  // asks the NAKACK protocol for the current digest,\n                    if(log.isTraceEnabled())\n                        log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n                    sendStableMessage(my_digest);\n                }\n            }\n            finally {\n                if(locked)\n                    received.unlock();\n            }\n        }\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void runMessageGarbageCollection() {\n        Digest copy;\n        synchronized(digest) {\n            copy=digest.copy();\n        }\n        sendStableMessage(copy);\n    }","id":41937,"modified_method":"public void runMessageGarbageCollection() {\n        Digest copy=getDigest();\n        sendStableMessage(copy);\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            if(suspended) {\n                if(log.isTraceEnabled())\n                    log.trace(\"stable task will not run as suspended=\" + suspended);\n                return;\n            }\n\n            // asks the NAKACK protocol for the current digest\n            Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n            if(my_digest == null) {\n                if(log.isWarnEnabled())\n                    log.warn(\"received null digest, skipped sending of stable message\");\n                return;\n            }\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(my_digest);\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n            sendStableMessage(my_digest);\n        }","id":41938,"modified_method":"public void run() {\n            if(suspended) {\n                if(log.isTraceEnabled())\n                    log.trace(\"stable task will not run as suspended=\" + suspended);\n                return;\n            }\n\n            // asks the NAKACK protocol for the current digest\n            Digest my_digest=getDigest();\n            if(my_digest == null) {\n                if(log.isWarnEnabled())\n                    log.warn(\"received null digest, skipped sending of stable message\");\n                return;\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"setting latest_local_digest from NAKACK: \" + my_digest.printHighestDeliveredSeqnos());\n            sendStableMessage(my_digest);\n        }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector<Address> tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        adjustSenders(digest, tmp);\n        adjustSenders(latest_local_digest, tmp);\n\n        // asks the NAKACK protocol for the current digest\n        Digest my_digest=(Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n        if(my_digest != null) {\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(my_digest);\n            }\n        }\n\n        resetDigest(tmp);\n        if(!initialized)\n            initialized=true;\n    }","id":41939,"modified_method":"private void handleViewChange(View v) {\n        Vector<Address> tmp=v.getMembers();\n        synchronized(mbrs) {\n            mbrs.clear();\n            mbrs.addAll(tmp);\n        }\n        lock.lock();\n        try {\n            resetDigest();\n            if(!initialized)\n                initialized=true;\n        }\n        finally {\n            lock.unlock();\n        }\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes mbr from heard_from and returns true if this was the last member, otherwise false.\n     * Resets the heard_from list (populates with membership)\n     * @param mbr\n     */\n    private boolean removeVote(Address mbr) {\n        synchronized(votes) {\n            boolean removed=votes.remove(mbr);\n            if(removed && votes.isEmpty()) {\n                resetDigest(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","id":41940,"modified_method":"/**\n     * Adds mbr to votes and returns true if we have all the votes, otherwise false.\n     * @param mbr\n     */\n    @GuardedBy(\"lock\")\n    private boolean addVote(Address mbr) {\n        boolean added=votes.add(mbr);\n        return added && allVotesReceived(votes);\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n        if(!digest.sameSenders(d)) {\n            // to avoid sending incorrect stability/stable msgs, we simply reset our heard_from list, see DESIGN\n            resetDigest(mbrs);\n            return false;\n        }\n\n        StringBuilder sb=null;\n        if(log.isTraceEnabled()) {\n            sb=new StringBuilder(\"[\").append(local_addr).append(\"] handling digest from \").append(sender).append(\" (\").\n                    append(votes.size()).append(\" pending):\\nmine:   \").append(digest.printHighestDeliveredSeqnos())\n                    .append(\"\\nother:  \").append(d.printHighestDeliveredSeqnos());\n        }\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno, my_low, low, new_low;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Digest.Entry val;\n        for(Map.Entry<Address, Digest.Entry> entry: d.getSenders().entrySet()) {\n            mbr=entry.getKey();\n            val=entry.getValue();\n            low=val.getLow();\n            highest_seqno=val.getHighestDeliveredSeqno();      // highest *delivered* seqno\n            highest_seen_seqno=val.getHighestReceivedSeqno();  // highest *received* seqno\n\n            my_low=digest.lowSeqnoAt(mbr);\n            new_low=Math.min(my_low, low);\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highestDeliveredSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highestReceivedSeqnoAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_low, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            sb.append(\"\\nresult: \").append(digest.printHighestDeliveredSeqnos()).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","id":41941,"modified_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    @GuardedBy(\"lock\")\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n        if(!digest.sameSenders(d)) {\n            // to avoid sending incorrect stability/stable msgs, we simply reset our votes list, see DESIGN\n            resetDigest();\n            return false;\n        }\n\n        StringBuilder sb=null;\n        if(log.isTraceEnabled()) {\n            sb=new StringBuilder(\"[\").append(local_addr).append(\"] handling digest from \").append(sender).append(\" (\").\n                    append(votes.size()).append(\" votes):\\nmine:   \").append(digest.printHighestDeliveredSeqnos())\n                    .append(\"\\nother:  \").append(d.printHighestDeliveredSeqnos());\n        }\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno, my_low, low, new_low;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Digest.Entry val;\n        for(Map.Entry<Address, Digest.Entry> entry: d.getSenders().entrySet()) {\n            mbr=entry.getKey();\n            val=entry.getValue();\n            low=val.getLow();\n            highest_seqno=val.getHighestDeliveredSeqno();      // highest *delivered* seqno\n            highest_seen_seqno=val.getHighestReceivedSeqno();  // highest *received* seqno\n\n            my_low=digest.lowSeqnoAt(mbr);\n            new_low=Math.min(my_low, low);\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highestDeliveredSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highestReceivedSeqnoAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_low, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            assert sb != null;\n            sb.append(\"\\nresult: \").append(digest.printHighestDeliveredSeqnos()).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"private void resume() {\n        resetDigest(mbrs); // start from scratch\n        suspended=false;\n        if(log.isDebugEnabled())\n            log.debug(\"resuming message garbage collection\");\n        stopResumeTask();\n    }","id":41942,"modified_method":"private void resume() {\n        lock.lock();\n        try {\n            resetDigest(); // start from scratch\n            suspended=false;\n        }\n        finally {\n            lock.unlock();\n        }\n\n        if(log.isDebugEnabled())\n            log.debug(\"resuming message garbage collection\");\n        stopResumeTask();\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStabilityMessage(Digest d, Address sender) {\n         if(d == null) {\n             if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n             return;\n         }\n\n         if(!initialized) {\n             if(log.isTraceEnabled())\n                 log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n             return;\n         }\n\n         if(suspended) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"stability message will not be handled as I'm suspended\");\n             }\n             return;\n         }\n\n         if(log.isTraceEnabled())\n             log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighestDeliveredSeqnos()));\n         stopStabilityTask();\n\n         // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n         // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n         if(!this.digest.sameSenders(d)) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                         this.digest + \"): ignoring digest and re-initializing own digest\");\n             }\n             return;\n         }\n\n         num_stability_msgs_received++;\n\n         resetDigest(mbrs);\n\n         // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n         down_prot.down(new Event(Event.STABLE, d));\n     }","id":41943,"modified_method":"private void handleStabilityMessage(Digest stable_digest, Address sender) {\n        if(stable_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n         if(!initialized) {\n             if(log.isTraceEnabled())\n                 log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n             return;\n         }\n\n         if(suspended) {\n             if(log.isDebugEnabled()) {\n                 log.debug(\"stability message will not be handled as I'm suspended\");\n             }\n             return;\n         }\n\n         if(log.isTraceEnabled())\n             log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(stable_digest.printHighestDeliveredSeqnos()));\n         stopStabilityTask();\n\n        lock.lock();\n        try {\n            // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n            // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n            if(!this.digest.sameSenders(stable_digest)) {\n                if(log.isDebugEnabled()) {\n                    log.debug(\"received digest (digest=\" + stable_digest + \") which does not match my own digest (\"+\n                            this.digest + \"): ignoring digest and re-initializing own digest\");\n                }\n                resetDigest();\n                return;\n            }\n            num_stability_msgs_received++;\n            resetDigest();\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        down_prot.down(new Event(Event.STABLE, stable_digest));\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(!votes.contains(sender)) {  // already received gossip from sender; discard it\n            return;\n        }\n\n        num_stable_msgs_received++;\n\n        Digest copy;\n        synchronized(digest) {\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only remove the sender from heard_from if *all* elements of my digest were updated\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeVote(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","id":41944,"modified_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        Digest copy=null;\n        boolean all_votes_received=false;\n        lock.lock();\n        try {\n            if(votes.contains(sender))  // already received gossip from sender; discard it\n                return;\n            num_stable_msgs_received++;\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only add the sender to votes if *all* elements of my digest were updated\n                return;\n\n            all_votes_received=addVote(sender);\n            if(all_votes_received)\n                copy=digest.copy();\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // we don't yet reset digest: new STABLE messages will be discarded anyway as we have already\n        // received votes from their senders\n        if(copy != null) {\n            sendStabilityMessage(copy);\n        }\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"private void clearDigest() {\n        synchronized(digest) {\n            digest.clear();\n        }\n    }","id":41945,"modified_method":"private Digest getDigest() {\n        return (Digest)down_prot.down(Event.GET_DIGEST_STABLE_EVT);\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        stopStableTask();\n        clearDigest();\n    }","id":41946,"modified_method":"public void stop() {\n        stopStableTask();\n    }","commit_id":"86f96477916e3e2a0ff5935def40198f50e145d8","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testOneBridgeMoreMacOnePort() throws Exception {\n\n        Integer nodeA  = 20;\n        \n        Integer portA1 = 1;\n\n        String mac1 = \"000daaaa0001\"; // port A1 \n        String mac2 = \"000daaaa0002\"; // port A1\n        String mac3 = \"000daaaa0003\"; // port A1\n        String mac4 = \"000daaaa0004\"; // port A1\n\n        Map<Integer,Set<String>> bftA = new HashMap<Integer, Set<String>>();\n\n        bftA = addBridgeForwardingTableEntry(portA1, mac1,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac2,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac3,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac4,bftA);\n        \n        BridgeTopology bridgeTopology = new BridgeTopology();\n        \n        bridgeTopology.parseBFT(nodeA,bftA);\n\n        List<BridgeTopologyLink> links = bridgeTopology.getTopology();\n        printBridgeTopologyLinks(links);\n        assertEquals(1, links.size());\n        for (BridgeTopologyLink link: links) {\n        \tBridgeTopologyPort port = link.getBridgeTopologyPort();\n    \t\tassertEquals(port.getMacs(),link.getMacs());\n        \tassertEquals(null,link.getDesignateBridgePort());\n        \tif (link.getBridgeTopologyPort().getBridgePort() == portA1) {\n        \t\tassertEquals(4, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n                        assertEquals(mac3, macs.next());\n                        assertEquals(mac2, macs.next());\n                        assertEquals(mac1, macs.next());\n        \t\tassertEquals(mac4, macs.next());\n        \t} else {\n        \t\tassertEquals(-1, 1);\n        \t}\n        }\n\n\t}","id":41947,"modified_method":"@Test\n    public void testOneBridgeMoreMacOnePort() throws Exception {\n\n        Integer nodeA  = 20;\n\n        Integer portA1 = 1;\n\n        String mac1 = \"000daaaa0001\"; // port A1 \n        String mac2 = \"000daaaa0002\"; // port A1\n        String mac3 = \"000daaaa0003\"; // port A1\n        String mac4 = \"000daaaa0004\"; // port A1\n\n        Map<Integer,Set<String>> bftA = new HashMap<Integer, Set<String>>();\n\n        bftA = addBridgeForwardingTableEntry(portA1, mac1,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac2,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac3,bftA);\n        bftA =addBridgeForwardingTableEntry(portA1, mac4,bftA);\n\n        BridgeTopology bridgeTopology = new BridgeTopology();\n\n        bridgeTopology.parseBFT(nodeA,bftA);\n\n        List<BridgeTopologyLink> links = bridgeTopology.getTopology();\n        printBridgeTopologyLinks(links);\n        assertEquals(1, links.size());\n        for (BridgeTopologyLink link: links) {\n            BridgeTopologyPort port = link.getBridgeTopologyPort();\n            assertEquals(port.getMacs(),link.getMacs());\n            assertEquals(null,link.getDesignateBridgePort());\n            if (link.getBridgeTopologyPort().getBridgePort() == portA1) {\n                final Set<String> macs = link.getMacs();\n                assertEquals(4, macs.size());\n                assertTrue(macs.contains(mac1));\n                assertTrue(macs.contains(mac2));\n                assertTrue(macs.contains(mac3));\n                assertTrue(macs.contains(mac4));\n            } else {\n                assertEquals(-1, 1);\n            }\n        }\n\n    }","commit_id":"d9ecc8949a62896a8a4fe071f8b82b240c8c77e9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n\tpublic void testOneBridgeComplete() throws Exception {\n\n\t\tInteger nodeA = 30;\n\n\t\tInteger portA1 = 1;\n\t\tInteger portA2 = 2;\n\t\tInteger portA3 = 3;\n\t\tInteger portA4 = 4;\n\n\t\tInteger portA23 = 23;\n\t\tInteger portA24 = 24;\n\t\tInteger portA25 = 25;\n\n\t\tString mac1 = \"000daaaa0001\"; // port A1\n\t\tString mac2 = \"000daaaa0002\"; // port A2\n\t\tString mac3 = \"000daaaa0003\"; // port A3\n\t\tString mac4 = \"000daaaa0004\"; // port A4\n\n\t\tString mac231 = \"000daaaa0231\"; // port A23\n\t\tString mac232 = \"000daaaa0232\"; // port A23\n\t\tString mac233 = \"000daaaa0233\"; // port A23\n\t\tString mac234 = \"000daaaa0234\"; // port A23\n\n\t\tString mac241 = \"000daaaa0241\"; // port A24\n\t\tString mac242 = \"000daaaa0242\"; // port A24\n\t\tString mac243 = \"000daaaa0243\"; // port A24\n\t\tString mac244 = \"000daaaa0244\"; // port A24\n\t\tString mac245 = \"000daaaa0245\"; // port A24\n\n\t\tString mac251 = \"000daaaa0251\"; // port A25\n\t\tString mac252 = \"000daaaa0252\"; // port A25\n\t\tString mac253 = \"000daaaa0253\"; // port A25\n\t\t\n        Map<Integer,Set<String>> bftA = new HashMap<Integer, Set<String>>();\n\n        bftA =addBridgeForwardingTableEntry(portA1, mac1,bftA);\n        bftA =addBridgeForwardingTableEntry(portA2, mac2,bftA);\n        bftA =addBridgeForwardingTableEntry(portA3, mac3,bftA);\n        bftA =addBridgeForwardingTableEntry(portA4, mac4,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA23, mac231,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac232,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac233,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac234,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA24, mac241,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac242,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac243,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac244,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac245,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA25, mac251,bftA);\n        bftA =addBridgeForwardingTableEntry(portA25, mac252,bftA);\n        bftA =addBridgeForwardingTableEntry(portA25, mac253,bftA);\n        \n\n        BridgeTopology bridgeTopology = new BridgeTopology();\n        \n        bridgeTopology.parseBFT(nodeA,bftA);\n\n        List<BridgeTopologyLink> links = bridgeTopology.getTopology();\n        printBridgeTopologyLinks(links);\n        assertEquals(7, links.size());\n        for (BridgeTopologyLink link: links) {\n        \tBridgeTopologyPort port = link.getBridgeTopologyPort();\n    \t\tassertEquals(port.getMacs(),link.getMacs());\n        \tassertEquals(null,link.getDesignateBridgePort());\n        \tif (link.getBridgeTopologyPort().getBridgePort() == portA1) {\n        \t\tassertEquals(1, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n        \t\tassertEquals(mac1, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA2) {\n        \t\tassertEquals(1, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n        \t\tassertEquals(mac2, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA3) {\n        \t\tassertEquals(1, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n        \t\tassertEquals(mac3, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA4) {\n        \t\tassertEquals(1, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n        \t\tassertEquals(mac4, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA23) {\n        \t\tassertEquals(4, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n                        assertEquals(mac234, macs.next());\n                        assertEquals(mac233, macs.next());\n        \t\tassertEquals(mac232, macs.next());\n        \t\tassertEquals(mac231, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA24) {\n        \t\tassertEquals(5, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n        \t\tassertEquals(mac241, macs.next());\n        \t\tassertEquals(mac245, macs.next());\n        \t\tassertEquals(mac244, macs.next());\n        \t\tassertEquals(mac243, macs.next());\n        \t\tassertEquals(mac242, macs.next());\n        \t} else if (link.getBridgeTopologyPort().getBridgePort() == portA25) {\n        \t\tassertEquals(3, link.getMacs().size());\n        \t\tIterator<String> macs = link.getMacs().iterator();\n                        assertEquals(mac252, macs.next());\n                        assertEquals(mac251, macs.next());\n        \t\tassertEquals(mac253, macs.next());\n        \t} else {\n        \t\tassertEquals(-1, 1);\n        \t}\n        }\n\n\t}","id":41948,"modified_method":"@Test\n    public void testOneBridgeComplete() throws Exception {\n\n        Integer nodeA = 30;\n\n        Integer portA1 = 1;\n        Integer portA2 = 2;\n        Integer portA3 = 3;\n        Integer portA4 = 4;\n\n        Integer portA23 = 23;\n        Integer portA24 = 24;\n        Integer portA25 = 25;\n\n        String mac1 = \"000daaaa0001\"; // port A1\n        String mac2 = \"000daaaa0002\"; // port A2\n        String mac3 = \"000daaaa0003\"; // port A3\n        String mac4 = \"000daaaa0004\"; // port A4\n\n        String mac231 = \"000daaaa0231\"; // port A23\n        String mac232 = \"000daaaa0232\"; // port A23\n        String mac233 = \"000daaaa0233\"; // port A23\n        String mac234 = \"000daaaa0234\"; // port A23\n\n        String mac241 = \"000daaaa0241\"; // port A24\n        String mac242 = \"000daaaa0242\"; // port A24\n        String mac243 = \"000daaaa0243\"; // port A24\n        String mac244 = \"000daaaa0244\"; // port A24\n        String mac245 = \"000daaaa0245\"; // port A24\n\n        String mac251 = \"000daaaa0251\"; // port A25\n        String mac252 = \"000daaaa0252\"; // port A25\n        String mac253 = \"000daaaa0253\"; // port A25\n\n        Map<Integer,Set<String>> bftA = new HashMap<Integer, Set<String>>();\n\n        bftA =addBridgeForwardingTableEntry(portA1, mac1,bftA);\n        bftA =addBridgeForwardingTableEntry(portA2, mac2,bftA);\n        bftA =addBridgeForwardingTableEntry(portA3, mac3,bftA);\n        bftA =addBridgeForwardingTableEntry(portA4, mac4,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA23, mac231,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac232,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac233,bftA);\n        bftA =addBridgeForwardingTableEntry(portA23, mac234,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA24, mac241,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac242,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac243,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac244,bftA);\n        bftA =addBridgeForwardingTableEntry(portA24, mac245,bftA);\n\n        bftA =addBridgeForwardingTableEntry(portA25, mac251,bftA);\n        bftA =addBridgeForwardingTableEntry(portA25, mac252,bftA);\n        bftA =addBridgeForwardingTableEntry(portA25, mac253,bftA);\n\n\n        BridgeTopology bridgeTopology = new BridgeTopology();\n\n        bridgeTopology.parseBFT(nodeA,bftA);\n\n        List<BridgeTopologyLink> links = bridgeTopology.getTopology();\n        printBridgeTopologyLinks(links);\n        assertEquals(7, links.size());\n        for (BridgeTopologyLink link: links) {\n            BridgeTopologyPort port = link.getBridgeTopologyPort();\n            assertEquals(port.getMacs(),link.getMacs());\n            assertEquals(null,link.getDesignateBridgePort());\n            if (link.getBridgeTopologyPort().getBridgePort() == portA1) {\n                assertEquals(1, link.getMacs().size());\n                Iterator<String> macs = link.getMacs().iterator();\n                assertEquals(mac1, macs.next());\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA2) {\n                assertEquals(1, link.getMacs().size());\n                Iterator<String> macs = link.getMacs().iterator();\n                assertEquals(mac2, macs.next());\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA3) {\n                assertEquals(1, link.getMacs().size());\n                Iterator<String> macs = link.getMacs().iterator();\n                assertEquals(mac3, macs.next());\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA4) {\n                assertEquals(1, link.getMacs().size());\n                Iterator<String> macs = link.getMacs().iterator();\n                assertEquals(mac4, macs.next());\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA23) {\n                final Set<String> macs = link.getMacs();\n                assertEquals(4, macs.size());\n                assertTrue(macs.contains(mac231));\n                assertTrue(macs.contains(mac232));\n                assertTrue(macs.contains(mac233));\n                assertTrue(macs.contains(mac234));\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA24) {\n                final Set<String> macs = link.getMacs();\n                assertEquals(5, macs.size());\n                assertTrue(macs.contains(mac241));\n                assertTrue(macs.contains(mac242));\n                assertTrue(macs.contains(mac243));\n                assertTrue(macs.contains(mac244));\n                assertTrue(macs.contains(mac245));\n            } else if (link.getBridgeTopologyPort().getBridgePort() == portA25) {\n                final Set<String> macs = link.getMacs();\n                assertEquals(3, macs.size());\n                assertTrue(macs.contains(mac251));\n                assertTrue(macs.contains(mac252));\n                assertTrue(macs.contains(mac253));\n            } else {\n                assertEquals(-1, 1);\n            }\n        }\n\n    }","commit_id":"d9ecc8949a62896a8a4fe071f8b82b240c8c77e9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the state icon.<p>\n     * \n     * The state icon indicates if a resource is exported, secure, etc.<p>\n     * \n     * @param icon the state icon\n     */\n    public void setStateIcon(StateIcon icon) {\n\n        if (m_stateIcon == null) {\n            m_stateIcon = new HTML();\n            m_contentPanel.add(m_stateIcon);\n        }\n\n        switch (icon) {\n            case export:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().export());\n                m_stateIcon.setTitle(Messages.get().key(Messages.GUI_ICON_TITLE_EXPORT_0));\n                break;\n            case secure:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().secure());\n                m_stateIcon.setTitle(Messages.get().key(Messages.GUI_ICON_TITLE_SECURE_0));\n                break;\n            default:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon());\n                m_stateIcon.setTitle(null);\n                break;\n        }\n\n    }","id":41949,"modified_method":"/**\n     * Sets the state icon.<p>\n     * \n     * The state icon indicates if a resource is exported, secure, etc.<p>\n     * \n     * @param icon the state icon\n     */\n    public void setStateIcon(StateIcon icon) {\n\n        if (m_stateIcon == null) {\n            m_stateIcon = new HTML();\n            m_stateIcon.addClickHandler(m_iconSuperClickHandler);\n            m_contentPanel.add(m_stateIcon);\n\n        }\n        String iconTitle = null;\n        switch (icon) {\n            case export:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().export());\n                iconTitle = Messages.get().key(Messages.GUI_ICON_TITLE_EXPORT_0);\n                break;\n            case secure:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().secure());\n                iconTitle = Messages.get().key(Messages.GUI_ICON_TITLE_SECURE_0);\n                break;\n            default:\n                m_stateIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().stateIcon());\n                break;\n        }\n        m_stateIcon.setTitle(concatIconTitles(m_iconTitle, iconTitle));\n        m_stateIcon.getElement().getStyle().setCursor(Style.Cursor.POINTER);\n\n    }","commit_id":"e0bdc5fc8d5c3c2fd75cb68082d33c7e23df263f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the icon title.<p>\n     * \n     * @param title the new icon title\n     */\n    public void setIconTitle(String title) {\n\n        m_iconPanel.setTitle(title);\n    }","id":41950,"modified_method":"/**\n     * Sets the icon title.<p>\n     * \n     * @param title the new icon title\n     */\n    public void setIconTitle(String title) {\n\n        m_iconTitle = title;\n        m_iconPanel.setTitle(title);\n    }","commit_id":"e0bdc5fc8d5c3c2fd75cb68082d33c7e23df263f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the lock icon.<p>\n     * \n     * @param icon the icon to use\n     * @param iconTitle the icon title\n     */\n    public void setLockIcon(LockIcon icon, String iconTitle) {\n\n        if (m_lockIcon == null) {\n            m_lockIcon = new HTML();\n            m_contentPanel.add(m_lockIcon);\n        }\n        switch (icon) {\n            case CLOSED:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockClosed());\n                break;\n            case OPEN:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockOpen());\n                break;\n            case SHARED_CLOSED:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockSharedClosed());\n                break;\n            case SHARED_OPEN:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockSharedOpen());\n                break;\n            case NONE:\n            default:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon());\n        }\n        m_lockIcon.setTitle(iconTitle);\n    }","id":41951,"modified_method":"/**\n     * Sets the lock icon.<p>\n     * \n     * @param icon the icon to use\n     * @param iconTitle the icon title\n     */\n    public void setLockIcon(LockIcon icon, String iconTitle) {\n\n        if (m_lockIcon == null) {\n            m_lockIcon = new HTML();\n            m_lockIcon.addClickHandler(m_iconSuperClickHandler);\n            m_contentPanel.add(m_lockIcon);\n        }\n        switch (icon) {\n            case CLOSED:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockClosed());\n                break;\n            case OPEN:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockOpen());\n                break;\n            case SHARED_CLOSED:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockSharedClosed());\n                break;\n            case SHARED_OPEN:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon()\n                    + \" \"\n                    + I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockSharedOpen());\n                break;\n            case NONE:\n            default:\n                m_lockIcon.setStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().lockIcon());\n        }\n\n        m_lockIcon.setTitle(concatIconTitles(m_iconTitle, iconTitle));\n        m_lockIcon.getElement().getStyle().setCursor(Style.Cursor.POINTER);\n    }","commit_id":"e0bdc5fc8d5c3c2fd75cb68082d33c7e23df263f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a mouse click handler to the icon panel.<p>\n     * \n     * @param handler the click handler\n     * \n     * @return the handler registration\n     */\n    public HandlerRegistration addIconClickHandler(ClickHandler handler) {\n\n        return m_iconPanel.addDomHandler(handler, ClickEvent.getType());\n    }","id":41952,"modified_method":"/**\n     * Adds a mouse click handler to the icon panel.<p>\n     * \n     * @param handler the click handler\n     * \n     * @return the handler registration\n     */\n    public HandlerRegistration addIconClickHandler(final ClickHandler handler) {\n\n        final HandlerRegistration internalHandlerRegistration = m_iconPanel.addDomHandler(handler, ClickEvent.getType());\n        m_iconClickHandlers.add(handler);\n        HandlerRegistration result = new HandlerRegistration() {\n\n            public void removeHandler() {\n\n                internalHandlerRegistration.removeHandler();\n                m_iconClickHandlers.remove(handler);\n            }\n        };\n        return result;\n    }","commit_id":"e0bdc5fc8d5c3c2fd75cb68082d33c7e23df263f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void setPercent(int percent)\n   {\n      String color = \"24, 163, 82\";\n      progressBar_.getElement().getStyle().setBackgroundImage(\n            \"linear-gradient(to right, \" +\n              \"rgba(\" + color + \", 1.0), \" +\n              \"rgba(\" + color + \", 1.0) \" + percent + \"%, \" +\n              \"rgba(\" + color + \", 0.3) \" + percent + \"%, \" +\n              \"rgba(\" + color + \", 0.3) 100%\");\n   }","id":41953,"modified_method":"public void setPercent(String chunkName, int percent)\n   {\n      String color = \"24, 163, 82\";\n      progressBar_.getElement().getStyle().setBackgroundImage(\n            \"linear-gradient(to right, \" +\n              \"rgba(\" + color + \", 1.0), \" +\n              \"rgba(\" + color + \", 1.0) \" + percent + \"%, \" +\n              \"rgba(\" + color + \", 0.3) \" + percent + \"%, \" +\n              \"rgba(\" + color + \", 0.3) 100%\");\n      chunkAnchor_.setText(chunkName);\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"public NotebookProgressWidget()\n   {\n      manager_ = new HandlerManager(this);\n\n      initWidget(uiBinder.createAndBindUi(this));\n      \n      // ensure elements look clickable\n      progressBar_.getElement().getStyle().setCursor(Cursor.POINTER);\n      interruptButton_.getElement().getStyle().setCursor(Cursor.POINTER);\n\n      // connect native click handler\n      progressBar_.addDomHandler(new MouseDownHandler()\n      {\n         public void onMouseDown(MouseDownEvent event)\n         {\n            event.preventDefault();\n            event.stopPropagation();\n\n            ClickEvent.fireNativeEvent(\n                  Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, \n                        false, false),\n                  manager_);\n         }\n      }, MouseDownEvent.getType());\n      \n      interruptButton_.addDomHandler(new MouseDownHandler()\n      {\n         @Override\n         public void onMouseDown(MouseDownEvent event)\n         {\n            RStudioGinjector.INSTANCE.getCommands().interruptR().execute();\n         }\n      }, MouseDownEvent.getType());\n   }","id":41954,"modified_method":"public NotebookProgressWidget()\n   {\n      manager_ = new HandlerManager(this);\n\n      initWidget(uiBinder.createAndBindUi(this));\n      \n      // ensure elements look clickable\n      progressBar_.getElement().getStyle().setCursor(Cursor.POINTER);\n      interruptButton_.getElement().getStyle().setCursor(Cursor.POINTER);\n\n      MouseDownHandler handler = new MouseDownHandler()\n      {\n         public void onMouseDown(MouseDownEvent event)\n         {\n            event.preventDefault();\n            event.stopPropagation();\n\n            ClickEvent.fireNativeEvent(\n                  Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, \n                        false, false),\n                  manager_);\n         }\n      };\n\n      // connect native click handler\n      progressBar_.addDomHandler(handler, MouseDownEvent.getType());\n      chunkAnchor_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            event.preventDefault();\n            event.stopPropagation();\n\n            ClickEvent.fireNativeEvent(\n                  Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, \n                        false, false),\n                  manager_);\n         }\n      });\n      \n      interruptButton_.addDomHandler(new MouseDownHandler()\n      {\n         @Override\n         public void onMouseDown(MouseDownEvent event)\n         {\n            RStudioGinjector.INSTANCE.getCommands().interruptR().execute();\n         }\n      }, MouseDownEvent.getType());\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showNotebookProgress(String label)\n   {\n      // cancel the hide timer if it's running\n      hideProgressTimer_.cancel();\n      \n      // ensure notebook progress widget is visible\n      if (!progress_.isVisible())\n      {\n         language_.setVisible(false);\n         progress_.setVisible(true);\n      }\n      \n      progress_.setLabel(label);\n      progress_.setPercent(0);\n   }","id":41955,"modified_method":"@Override\n   public void showNotebookProgress(String label)\n   {\n      // cancel the hide timer if it's running\n      hideProgressTimer_.cancel();\n      \n      // ensure notebook progress widget is visible\n      if (!progress_.isVisible())\n      {\n         language_.setVisible(false);\n         progress_.setVisible(true);\n      }\n      \n      progress_.setLabel(label);\n      progress_.setPercent(\"\", 0);\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void updateNotebookProgress(int percent)\n   {\n      // just update the status bar\n      progress_.setPercent(percent);\n   }","id":41956,"modified_method":"@Override\n   public void updateNotebookProgress(String chunkName, int percent)\n   {\n      // just update the status bar\n      progress_.setPercent(chunkName, percent);\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void updateProgress()\n   {\n      // update progress meter on status bar\n      editingTarget_.getStatusBar().updateNotebookProgress(\n           (int)Math.round(100 * ((double)(execQueueMaxSize_ - \n                                           chunkExecQueue_.size()) / \n                                  (double) execQueueMaxSize_)));\n      \n      // register click callback if necessary\n      if (progressClickReg_ == null)\n      {\n         progressClickReg_ = editingTarget_.getStatusBar()\n               .addProgressClickHandler(new ClickHandler()\n               {\n                  \n                  @Override\n                  public void onClick(ClickEvent arg0)\n                  {\n                     if (executingChunk_ != null &&\n                         outputs_.containsKey(executingChunk_.chunkId))\n                     {\n                        outputs_.get(executingChunk_.chunkId).ensureVisible();\n                     }\n                  }\n               });\n         releaseOnDismiss_.add(progressClickReg_);\n      }\n   }","id":41957,"modified_method":"private void updateProgress()\n   {\n      // update progress meter on status bar\n      editingTarget_.getStatusBar().updateNotebookProgress(\n           executingChunk_ == null ? \"\" : executingChunk_.label,\n           (int)Math.round(100 * ((double)(execQueueMaxSize_ - \n                                           chunkExecQueue_.size()) / \n                                  (double) execQueueMaxSize_)));\n      \n      // register click callback if necessary\n      if (progressClickReg_ == null)\n      {\n         progressClickReg_ = editingTarget_.getStatusBar()\n               .addProgressClickHandler(new ClickHandler()\n               {\n                  \n                  @Override\n                  public void onClick(ClickEvent arg0)\n                  {\n                     if (executingChunk_ != null &&\n                         outputs_.containsKey(executingChunk_.chunkId))\n                     {\n                        outputs_.get(executingChunk_.chunkId).ensureVisible();\n                     }\n                  }\n               });\n         releaseOnDismiss_.add(progressClickReg_);\n      }\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkExecQueueUnit(String chunkIdIn, int modeIn, String codeIn, \n            String optionsIn, int rowIn, String setupCrc32In)\n      {\n         chunkId = chunkIdIn;\n         mode = modeIn;\n         options = optionsIn;\n         code = codeIn;\n         row = rowIn;\n         setupCrc32 = setupCrc32In;\n         pos = 0;\n         linesExecuted = 0;\n         executingRowStart = 0;\n         executingRowEnd = 0;\n      }","id":41958,"modified_method":"public ChunkExecQueueUnit(String chunkIdIn, String labelIn, int modeIn, \n            String codeIn, String optionsIn, int rowIn, String setupCrc32In)\n      {\n         chunkId = chunkIdIn;\n         label = labelIn;\n         mode = modeIn;\n         options = optionsIn;\n         code = codeIn;\n         row = rowIn;\n         setupCrc32 = setupCrc32In;\n         pos = 0;\n         linesExecuted = 0;\n         executingRowStart = 0;\n         executingRowEnd = 0;\n      }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void executeChunk(Scope chunk, String code, String options,\n         int mode)\n   {\n      // maximize the source window if it's paired with the console and this\n      // is the first chunk we've executed since we were activated\n      if (!executedSinceActivate_)\n      {\n         pSourceWindowManager_.get().maximizeSourcePaneIfNecessary();\n         executedSinceActivate_ = true;\n      }\n      \n      // get the row that ends the chunk\n      int row = chunk.getEnd().getRow();\n\n      String chunkId = \"\";\n      String setupCrc32 = \"\";\n      if (isSetupChunkScope(chunk))\n      {\n         setupCrc32 = getChunkCrc32(chunk);\n         chunkId = SETUP_CHUNK_ID;\n      }\n      else\n      {\n         ensureSetupChunkExecuted();\n      }\n\n      // find or create a matching chunk definition \n      ChunkDefinition chunkDef = getChunkDefAtRow(row, chunkId);\n      if (chunkDef == null)\n         return;\n      chunkId = chunkDef.getChunkId();\n\n      // check to see if this chunk is already in the execution queue--if so\n      // just update the code and leave it queued\n      for (ChunkExecQueueUnit unit: chunkExecQueue_)\n      {\n         if (unit.chunkId == chunkId)\n         {\n            unit.code = code;\n            unit.options = options;\n            unit.setupCrc32 = setupCrc32;\n            unit.row = row;\n            return;\n         }\n      }\n\n      // if this is the currently executing chunk, don't queue it again\n      if (executingChunk_ != null && executingChunk_.chunkId == chunkId)\n         return;\n\n      // decorate the gutter to show the chunk is queued\n      docDisplay_.setChunkLineExecState(chunk.getBodyStart().getRow() + 1,\n            chunk.getEnd().getRow(), ChunkRowExecState.LINE_QUEUED);\n      chunks_.setChunkState(chunk.getPreamble().getRow(), \n            ChunkContextToolbar.STATE_QUEUED);\n      \n      // find the appropriate place in the queue for this chunk\n      int idx = chunkExecQueue_.size();\n      for (int i = 0; i < chunkExecQueue_.size(); i++)\n      {\n         if (chunkExecQueue_.get(i).row > row)\n         {\n            idx = i;\n            break;\n         }\n      }\n\n      // put it in the queue \n      chunkExecQueue_.add(idx, new ChunkExecQueueUnit(chunkId, mode, code,\n             options, row, setupCrc32));\n      \n      // record maximum queue size (for scaling progress when we start popping\n      // chunks from the list)\n      if (chunkExecQueue_.size() == 1)\n      {\n         // first item in the queue resets the max recorded size\n         execQueueMaxSize_ = 1;\n      }\n      else\n      {\n         // otherwise, maintain the high water mark until the queue is empty\n         execQueueMaxSize_ = Math.max(execQueueMaxSize_, \n                                      chunkExecQueue_.size());\n      }\n      \n      // draw progress meter for the new queue in batch mode\n      if (mode == MODE_BATCH)\n         updateProgress();\n\n      // if there are other chunks in the queue, let them run\n      if (chunkExecQueue_.size() > 1)\n         return;\n      \n      // if this is the first chunk in the queue, make sure the doc is saved\n      // and check for param eval before we continue. since we suppress the\n      // execution of additional chunks while waiting for param evaluation, we\n      // need to guarantee that this state gets cleaned up correctly on error\n      evaluatingParams_ = true;\n      final Command completeEval = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            evaluatingParams_ = false;\n            processChunkExecQueue();\n         }\n      };\n\n      docUpdateSentinel_.withSavedDoc(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            server_.prepareForRmdChunkExecution(docUpdateSentinel_.getId(), \n               new ServerRequestCallback<Void>()\n               {\n                  @Override\n                  public void onResponseReceived(Void v)\n                  {\n                     completeEval.execute();\n                  }\n\n                  @Override\n                  public void onError(ServerError error)\n                  {\n                     // if we couldn't evaluate the parameters, process the queue\n                     // anyway\n                     Debug.logError(error);\n                     completeEval.execute();\n                  }\n               });\n         }\n      }, \n      new CommandWithArg<String>()\n      {\n         @Override\n         public void execute(String arg)\n         {\n            Debug.logWarning(arg);\n            completeEval.execute();\n         }\n      });\n   }","id":41959,"modified_method":"public void executeChunk(Scope chunk, String code, String options,\n         int mode)\n   {\n      // maximize the source window if it's paired with the console and this\n      // is the first chunk we've executed since we were activated\n      if (!executedSinceActivate_)\n      {\n         pSourceWindowManager_.get().maximizeSourcePaneIfNecessary();\n         executedSinceActivate_ = true;\n      }\n      \n      // get the row that ends the chunk\n      int row = chunk.getEnd().getRow();\n\n      String chunkId = \"\";\n      String setupCrc32 = \"\";\n      if (isSetupChunkScope(chunk))\n      {\n         setupCrc32 = getChunkCrc32(chunk);\n         chunkId = SETUP_CHUNK_ID;\n      }\n      else\n      {\n         ensureSetupChunkExecuted();\n      }\n\n      // find or create a matching chunk definition \n      ChunkDefinition chunkDef = getChunkDefAtRow(row, chunkId);\n      if (chunkDef == null)\n         return;\n      chunkId = chunkDef.getChunkId();\n\n      // check to see if this chunk is already in the execution queue--if so\n      // just update the code and leave it queued\n      for (ChunkExecQueueUnit unit: chunkExecQueue_)\n      {\n         if (unit.chunkId == chunkId)\n         {\n            unit.code = code;\n            unit.options = options;\n            unit.setupCrc32 = setupCrc32;\n            unit.row = row;\n            return;\n         }\n      }\n\n      // if this is the currently executing chunk, don't queue it again\n      if (executingChunk_ != null && executingChunk_.chunkId == chunkId)\n         return;\n\n      // decorate the gutter to show the chunk is queued\n      docDisplay_.setChunkLineExecState(chunk.getBodyStart().getRow() + 1,\n            chunk.getEnd().getRow(), ChunkRowExecState.LINE_QUEUED);\n      chunks_.setChunkState(chunk.getPreamble().getRow(), \n            ChunkContextToolbar.STATE_QUEUED);\n      \n      // find the appropriate place in the queue for this chunk\n      int idx = chunkExecQueue_.size();\n      for (int i = 0; i < chunkExecQueue_.size(); i++)\n      {\n         if (chunkExecQueue_.get(i).row > row)\n         {\n            idx = i;\n            break;\n         }\n      }\n\n      // put it in the queue \n      chunkExecQueue_.add(idx, new ChunkExecQueueUnit(chunkId, \n            StringUtil.isNullOrEmpty(chunk.getChunkLabel()) ? \n                  chunk.getLabel() : chunk.getChunkLabel(),\n            mode, code, options, row, setupCrc32));\n      \n      // record maximum queue size (for scaling progress when we start popping\n      // chunks from the list)\n      if (chunkExecQueue_.size() == 1)\n      {\n         // first item in the queue resets the max recorded size\n         execQueueMaxSize_ = 1;\n      }\n      else\n      {\n         // otherwise, maintain the high water mark until the queue is empty\n         execQueueMaxSize_ = Math.max(execQueueMaxSize_, \n                                      chunkExecQueue_.size());\n      }\n      \n      // draw progress meter for the new queue in batch mode\n      if (mode == MODE_BATCH)\n         updateProgress();\n\n      // if there are other chunks in the queue, let them run\n      if (chunkExecQueue_.size() > 1)\n         return;\n      \n      // if this is the first chunk in the queue, make sure the doc is saved\n      // and check for param eval before we continue. since we suppress the\n      // execution of additional chunks while waiting for param evaluation, we\n      // need to guarantee that this state gets cleaned up correctly on error\n      evaluatingParams_ = true;\n      final Command completeEval = new Command()\n      {\n         @Override\n         public void execute()\n         {\n            evaluatingParams_ = false;\n            processChunkExecQueue();\n         }\n      };\n\n      docUpdateSentinel_.withSavedDoc(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            server_.prepareForRmdChunkExecution(docUpdateSentinel_.getId(), \n               new ServerRequestCallback<Void>()\n               {\n                  @Override\n                  public void onResponseReceived(Void v)\n                  {\n                     completeEval.execute();\n                  }\n\n                  @Override\n                  public void onError(ServerError error)\n                  {\n                     // if we couldn't evaluate the parameters, process the queue\n                     // anyway\n                     Debug.logError(error);\n                     completeEval.execute();\n                  }\n               });\n         }\n      }, \n      new CommandWithArg<String>()\n      {\n         @Override\n         public void execute(String arg)\n         {\n            Debug.logWarning(arg);\n            completeEval.execute();\n         }\n      });\n   }","commit_id":"0af2327b2919e2d90b4392657f0ed1312abaad6c","url":"https://github.com/rstudio/rstudio"},{"original_method":"PageSelectorItem(final WizardPage<I,T> page)\n      {\n         WizardResources res = WizardResources.INSTANCE;\n         WizardResources.Styles styles = res.styles();\n         \n         LayoutPanel layoutPanel = new LayoutPanel();\n         layoutPanel.addStyleName(styles.wizardPageSelectorItem());\n         \n         Image image = new Image(page.getImage());\n         layoutPanel.add(image);\n         layoutPanel.setWidgetLeftWidth(image, \n                                        10, Unit.PX, \n                                        image.getWidth(), Unit.PX);\n         layoutPanel.setWidgetTopHeight(image, \n                                        40-(image.getHeight()/2), Unit.PX, \n                                        image.getHeight(), Unit.PX);\n         \n        \n         FlowPanel captionPanel = new FlowPanel();\n         Label titleLabel = new Label(page.getTitle());\n         titleLabel.addStyleName(styles.headerLabel());\n         captionPanel.add(titleLabel);\n         Label subTitleLabel = new Label(page.getSubTitle());\n         subTitleLabel.addStyleName(styles.subcaptionLabel());\n         captionPanel.add(subTitleLabel);\n         layoutPanel.add(captionPanel);\n         layoutPanel.setWidgetLeftWidth(captionPanel,\n                                        10 + image.getWidth() + 12, Unit.PX,\n                                        450, Unit.PX);\n         layoutPanel.setWidgetTopHeight(captionPanel,\n                                        19, Unit.PX, \n                                        55, Unit.PX);\n         \n         \n         Image arrowImage = new Image(res.wizardDisclosureArrow());\n         layoutPanel.add(arrowImage);\n         layoutPanel.setWidgetRightWidth(arrowImage, \n                                         20, Unit.PX, \n                                         arrowImage.getWidth(), \n                                         Unit.PX);\n         layoutPanel.setWidgetTopHeight(arrowImage,\n                                        40-(arrowImage.getHeight()/2), Unit.PX,\n                                        arrowImage.getHeight(), Unit.PX);\n         \n         \n         layoutPanel.addDomHandler(new ClickHandler() {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               showPage(page);\n                \n            }\n         }, ClickEvent.getType());\n       \n         \n         initWidget(layoutPanel);\n      }","id":41960,"modified_method":"PageSelectorItem(final WizardPageInfo pageInfo, ClickHandler clickHandler)\n      {\n         WizardResources res = WizardResources.INSTANCE;\n         WizardResources.Styles styles = res.styles();\n         \n         LayoutPanel layoutPanel = new LayoutPanel();\n         layoutPanel.addStyleName(styles.wizardPageSelectorItem());\n         \n         Image image = new Image(pageInfo.getImage());\n         layoutPanel.add(image);\n         layoutPanel.setWidgetLeftWidth(image, \n                                        10, Unit.PX, \n                                        image.getWidth(), Unit.PX);\n         layoutPanel.setWidgetTopHeight(image, \n                                        40-(image.getHeight()/2), Unit.PX, \n                                        image.getHeight(), Unit.PX);\n         \n        \n         FlowPanel captionPanel = new FlowPanel();\n         Label titleLabel = new Label(pageInfo.getTitle());\n         titleLabel.addStyleName(styles.headerLabel());\n         captionPanel.add(titleLabel);\n         Label subTitleLabel = new Label(pageInfo.getSubTitle());\n         subTitleLabel.addStyleName(styles.subcaptionLabel());\n         captionPanel.add(subTitleLabel);\n         layoutPanel.add(captionPanel);\n         layoutPanel.setWidgetLeftWidth(captionPanel,\n                                        10 + image.getWidth() + 12, Unit.PX,\n                                        450, Unit.PX);\n         layoutPanel.setWidgetTopHeight(captionPanel,\n                                        19, Unit.PX, \n                                        55, Unit.PX);\n         \n         \n         Image arrowImage = new Image(res.wizardDisclosureArrow());\n         layoutPanel.add(arrowImage);\n         layoutPanel.setWidgetRightWidth(arrowImage, \n                                         20, Unit.PX, \n                                         arrowImage.getWidth(), \n                                         Unit.PX);\n         layoutPanel.setWidgetTopHeight(arrowImage,\n                                        40-(arrowImage.getHeight()/2), Unit.PX,\n                                        arrowImage.getHeight(), Unit.PX);\n         \n         \n         layoutPanel.addDomHandler(clickHandler, ClickEvent.getType());\n       \n         \n         initWidget(layoutPanel);\n      }","commit_id":"4fa301aee35fa35eec742e7c14e517c7f4ecbf2b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Widget createMainWidget()\n   {\n      WizardResources res = WizardResources.INSTANCE;\n      WizardResources.Styles styles = res.styles();\n      \n      VerticalPanel mainWidget = new VerticalPanel();\n      mainWidget.addStyleName(styles.mainWidget());\n      \n      headerPanel_ = new LayoutPanel();\n      headerPanel_.addStyleName(styles.headerPanel());\n      \n      // layout consants\n      final int kTopMargin = 5;\n      final int kLeftMargin = 8;\n      final int kCaptionWidth = 400;\n      final int kCaptionHeight = 30;\n      final int kPageUILeftMargin = 123;\n      \n      // first page caption\n      subCaptionLabel_ = new Label(subCaption_);\n      subCaptionLabel_.addStyleName(styles.headerLabel());\n      headerPanel_.add(subCaptionLabel_);\n      headerPanel_.setWidgetLeftWidth(subCaptionLabel_,\n                                      kTopMargin, Unit.PX, \n                                      kCaptionWidth, Unit.PX);\n      headerPanel_.setWidgetTopHeight(subCaptionLabel_,\n                                      kLeftMargin, Unit.PX,\n                                      kCaptionHeight, Unit.PX);\n      \n      // second page back button\n      ImageResource bkImg = res.wizardBackButton();\n      backButton_ = new Label(\"Back\");\n      backButton_.addStyleName(styles.wizardBackButton());\n      headerPanel_.add(backButton_);\n      headerPanel_.setWidgetLeftWidth(backButton_,\n                                      kTopMargin - 2, Unit.PX, \n                                      bkImg.getWidth(), Unit.PX);\n      headerPanel_.setWidgetTopHeight(backButton_,\n                                      kTopMargin - 2, Unit.PX,\n                                      bkImg.getHeight(), Unit.PX);\n      backButton_.setVisible(false);\n      backButton_.addClickHandler(new ClickHandler()\n      {\n         public void onClick(ClickEvent event)\n         {\n            backToSelector();\n         }\n      });\n      \n      // second page caption label\n      pageCaptionLabel_ = new Label();\n      pageCaptionLabel_.addStyleName(styles.headerLabel());\n      headerPanel_.add(pageCaptionLabel_);\n      headerPanel_.setWidgetLeftWidth(pageCaptionLabel_,\n                                      kPageUILeftMargin, Unit.PX, \n                                      kCaptionWidth, Unit.PX);\n      headerPanel_.setWidgetTopHeight(pageCaptionLabel_,\n                                      kLeftMargin, Unit.PX,\n                                      kCaptionHeight, Unit.PX);\n      pageCaptionLabel_.setVisible(false);\n      \n     \n      mainWidget.add(headerPanel_);\n      \n      // main body panel for transitions\n      bodyPanel_ = new LayoutPanel();\n      bodyPanel_.addStyleName(styles.wizardBodyPanel());\n      bodyPanel_.getElement().getStyle().setProperty(\"overflowX\", \"hidden\");\n      mainWidget.add(bodyPanel_);\n     \n      // page selection panel\n      pageSelectorPanel_ = new FlowPanel();\n      pageSelectorPanel_.addStyleName(styles.wizardPageSelector());\n      pageSelectorPanel_.setSize(\"100%\", \"100%\");\n      for (int i=0; i<pages_.size(); i++)\n      {\n         PageSelectorItem pageSelector = new PageSelectorItem(pages_.get(i));\n         \n         if (i==0)\n            pageSelector.addStyleName(styles.wizardPageSelectorItemFirst());\n         \n         if (i == (pages_.size() -1))\n            pageSelector.addStyleName(styles.wizardPageSelectorItemLast());\n         \n         pageSelectorPanel_.add(pageSelector);\n      }\n      bodyPanel_.add(pageSelectorPanel_);\n      bodyPanel_.setWidgetTopBottom(pageSelectorPanel_, 0, Unit.PX, 0, Unit.PX);\n      bodyPanel_.setWidgetLeftRight(pageSelectorPanel_, 0, Unit.PX, 0, Unit.PX);\n      bodyPanel_.setWidgetVisible(pageSelectorPanel_, true);\n    \n      // add pages and make them invisible\n      for (int i=0; i<pages_.size(); i++)\n      {\n         WizardPage<I,T> page = pages_.get(i);\n         page.setSize(\"100%\", \"100%\");\n         \n         bodyPanel_.add(page);\n         bodyPanel_.setWidgetTopBottom(page, 0, Unit.PX, 0, Unit.PX);\n         bodyPanel_.setWidgetLeftRight(page, 0, Unit.PX, 0, Unit.PX);\n         bodyPanel_.setWidgetVisible(page, false);\n         \n         page.initialize(initialData_);\n      }\n      \n     \n      \n      return mainWidget;\n   }","id":41961,"modified_method":"@Override\n   protected Widget createMainWidget()\n   {\n      WizardResources res = WizardResources.INSTANCE;\n      WizardResources.Styles styles = res.styles();\n      \n      VerticalPanel mainWidget = new VerticalPanel();\n      mainWidget.addStyleName(styles.mainWidget());\n      \n      headerPanel_ = new LayoutPanel();\n      headerPanel_.addStyleName(styles.headerPanel());\n      \n      // layout consants\n      final int kTopMargin = 5;\n      final int kLeftMargin = 8;\n      final int kCaptionWidth = 400;\n      final int kCaptionHeight = 30;\n      final int kPageUILeftMargin = 123;\n      \n      // first page caption\n      subCaptionLabel_ = new Label(subCaption_);\n      subCaptionLabel_.addStyleName(styles.headerLabel());\n      headerPanel_.add(subCaptionLabel_);\n      headerPanel_.setWidgetLeftWidth(subCaptionLabel_,\n                                      kTopMargin, Unit.PX, \n                                      kCaptionWidth, Unit.PX);\n      headerPanel_.setWidgetTopHeight(subCaptionLabel_,\n                                      kLeftMargin, Unit.PX,\n                                      kCaptionHeight, Unit.PX);\n      \n      // second page back button\n      ImageResource bkImg = res.wizardBackButton();\n      backButton_ = new Label(\"Back\");\n      backButton_.addStyleName(styles.wizardBackButton());\n      headerPanel_.add(backButton_);\n      headerPanel_.setWidgetLeftWidth(backButton_,\n                                      kTopMargin - 2, Unit.PX, \n                                      bkImg.getWidth(), Unit.PX);\n      headerPanel_.setWidgetTopHeight(backButton_,\n                                      kTopMargin - 2, Unit.PX,\n                                      bkImg.getHeight(), Unit.PX);\n      backButton_.setVisible(false);\n      backButton_.addClickHandler(new ClickHandler()\n      {\n         public void onClick(ClickEvent event)\n         {\n            backToSelector();\n         }\n      });\n      \n      // second page caption label\n      pageCaptionLabel_ = new Label();\n      pageCaptionLabel_.addStyleName(styles.headerLabel());\n      headerPanel_.add(pageCaptionLabel_);\n      headerPanel_.setWidgetLeftWidth(pageCaptionLabel_,\n                                      kPageUILeftMargin, Unit.PX, \n                                      kCaptionWidth, Unit.PX);\n      headerPanel_.setWidgetTopHeight(pageCaptionLabel_,\n                                      kLeftMargin, Unit.PX,\n                                      kCaptionHeight, Unit.PX);\n      pageCaptionLabel_.setVisible(false);\n      \n     \n      mainWidget.add(headerPanel_);\n      \n      // main body panel for transitions\n      bodyPanel_ = new LayoutPanel();\n      bodyPanel_.addStyleName(styles.wizardBodyPanel());\n      bodyPanel_.getElement().getStyle().setProperty(\"overflowX\", \"hidden\");\n      mainWidget.add(bodyPanel_);\n     \n      // page selection panel\n      pageSelectorPanel_ = new FlowPanel();\n      pageSelectorPanel_.addStyleName(styles.wizardPageSelector());\n      pageSelectorPanel_.setSize(\"100%\", \"100%\");\n      for (int i=0; i<pages_.size(); i++)\n      {\n         final WizardPage<I,T> page = pages_.get(i);\n         PageSelectorItem pageSelector = \n           new PageSelectorItem(page, new ClickHandler() {\n              @Override\n              public void onClick(ClickEvent event)\n              {\n                 showPage(page);  \n              }\n           });\n         \n         if (i==0)\n            pageSelector.addStyleName(styles.wizardPageSelectorItemFirst());\n         \n         if (i == (pages_.size() -1))\n            pageSelector.addStyleName(styles.wizardPageSelectorItemLast());\n         \n         pageSelectorPanel_.add(pageSelector);\n      }\n      bodyPanel_.add(pageSelectorPanel_);\n      bodyPanel_.setWidgetTopBottom(pageSelectorPanel_, 0, Unit.PX, 0, Unit.PX);\n      bodyPanel_.setWidgetLeftRight(pageSelectorPanel_, 0, Unit.PX, 0, Unit.PX);\n      bodyPanel_.setWidgetVisible(pageSelectorPanel_, true);\n    \n      // add pages and make them invisible\n      for (int i=0; i<pages_.size(); i++)\n      {\n         WizardPage<I,T> page = pages_.get(i);\n         page.setSize(\"100%\", \"100%\");\n         \n         bodyPanel_.add(page);\n         bodyPanel_.setWidgetTopBottom(page, 0, Unit.PX, 0, Unit.PX);\n         bodyPanel_.setWidgetLeftRight(page, 0, Unit.PX, 0, Unit.PX);\n         bodyPanel_.setWidgetVisible(page, false);\n         \n         page.initialize(initialData_);\n      }\n      \n     \n      \n      return mainWidget;\n   }","commit_id":"4fa301aee35fa35eec742e7c14e517c7f4ecbf2b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n\tprotected boolean hasAccessPermissionDenied(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (group.isLayoutSetPrototype() &&\n\t\t\tPortalPermissionUtil.contains(\n\t\t\t\tpermissionChecker, ActionKeys.ADD_LAYOUT_SET_PROTOTYPE)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":41962,"modified_method":"@Override\n\tprotected boolean hasAccessPermissionDenied(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (!group.isLayoutSetPrototype()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn super.hasAccessPermissionDenied(\n\t\t\tpermissionChecker, group, portlet);\n\t}","commit_id":"f9a904f7074a5a646f6092d71b28114fb9a07457","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateFile(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\t// Build compatibility\n\n\t\treadXML(portletDataContext);\n\n\t\tint buildNumber = ReleaseInfo.getBuildNumber();\n\n\t\tint importBuildNumber = GetterUtil.getInteger(\n\t\t\t_headerElement.attributeValue(\"build-number\"));\n\n\t\tif (buildNumber != importBuildNumber) {\n\t\t\tthrow new LayoutImportException(\n\t\t\t\t\"LAR build number \" + importBuildNumber + \" does not match \" +\n\t\t\t\t\t\"portal build number \" + buildNumber);\n\t\t}\n\n\t\t// Type\n\n\t\tString larType = _headerElement.attributeValue(\"type\");\n\n\t\tif (!larType.equals(\"layout-prototype\") &&\n\t\t\t!larType.equals(\"layout-set\") &&\n\t\t\t!larType.equals(\"layout-set-prototype\")) {\n\n\t\t\tthrow new LARTypeException(larType);\n\t\t}\n\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE);\n\n\t\tGroup group = GroupLocalServiceUtil.fetchGroup(\n\t\t\tportletDataContext.getGroupId());\n\n\t\tif (larType.equals(\"layout-set-prototype\") &&\n\t\t\t!group.isLayoutSetPrototype() &&\n\t\t\t!layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\tthrow new LARTypeException(\n\t\t\t\t\"Site template can be only imported to a site template\");\n\t\t}\n\n\t\tif (larType.equals(\"layout-set\") && group.isLayoutSetPrototype()) {\n\t\t\tthrow new LARTypeException(\"Site can be only imported to a site\");\n\t\t}\n\n\t\t// Available locales\n\n\t\tLocale[] sourceAvailableLocales = LocaleUtil.fromLanguageIds(\n\t\t\tStringUtil.split(\n\t\t\t\t_headerElement.attributeValue(\"available-locales\")));\n\n\t\tLocale[] targetAvailableLocales = LanguageUtil.getAvailableLocales(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tfor (Locale sourceAvailableLocale : sourceAvailableLocales) {\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\ttargetAvailableLocales, sourceAvailableLocale)) {\n\n\t\t\t\tLocaleException le = new LocaleException(\n\t\t\t\t\tLocaleException.TYPE_EXPORT_IMPORT);\n\n\t\t\t\tle.setSourceAvailableLocales(sourceAvailableLocales);\n\t\t\t\tle.setTargetAvailableLocales(targetAvailableLocales);\n\n\t\t\t\tthrow le;\n\t\t\t}\n\t\t}\n\n\t\t// Layout prototypes validity\n\n\t\tvalidateLayoutPrototypes(\n\t\t\tportletDataContext.getCompanyId(), _layoutsElement,\n\t\t\t_layoutElements);\n\t}","id":41963,"modified_method":"protected void validateFile(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\t// Build compatibility\n\n\t\treadXML(portletDataContext);\n\n\t\tint buildNumber = ReleaseInfo.getBuildNumber();\n\n\t\tint importBuildNumber = GetterUtil.getInteger(\n\t\t\t_headerElement.attributeValue(\"build-number\"));\n\n\t\tif (buildNumber != importBuildNumber) {\n\t\t\tthrow new LayoutImportException(\n\t\t\t\t\"LAR build number \" + importBuildNumber + \" does not match \" +\n\t\t\t\t\t\"portal build number \" + buildNumber);\n\t\t}\n\n\t\t// Type\n\n\t\tString larType = _headerElement.attributeValue(\"type\");\n\n\t\tif (!larType.equals(\"layout-prototype\") &&\n\t\t\t!larType.equals(\"layout-set\") &&\n\t\t\t!larType.equals(\"layout-set-prototype\")) {\n\n\t\t\tthrow new LARTypeException(larType);\n\t\t}\n\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE);\n\n\t\tGroup group = GroupLocalServiceUtil.fetchGroup(\n\t\t\tportletDataContext.getGroupId());\n\n\t\tif (larType.equals(\"layout-prototype\") && !group.isLayoutPrototype() &&\n\t\t\t!layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\tthrow new LARTypeException(\n\t\t\t\t\"A page template can be only imported to a page template\");\n\t\t}\n\n\t\tif (larType.equals(\"layout-set\") &&\n\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\tthrow new LARTypeException(\"A site can be only imported to a site\");\n\t\t}\n\n\t\tif (larType.equals(\"layout-set-prototype\") &&\n\t\t\t!group.isLayoutSetPrototype() &&\n\t\t\t!layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\tthrow new LARTypeException(\n\t\t\t\t\"A site template can be only imported to a site template\");\n\t\t}\n\n\t\t// Available locales\n\n\t\tLocale[] sourceAvailableLocales = LocaleUtil.fromLanguageIds(\n\t\t\tStringUtil.split(\n\t\t\t\t_headerElement.attributeValue(\"available-locales\")));\n\n\t\tLocale[] targetAvailableLocales = LanguageUtil.getAvailableLocales(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tfor (Locale sourceAvailableLocale : sourceAvailableLocales) {\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\ttargetAvailableLocales, sourceAvailableLocale)) {\n\n\t\t\t\tLocaleException le = new LocaleException(\n\t\t\t\t\tLocaleException.TYPE_EXPORT_IMPORT);\n\n\t\t\t\tle.setSourceAvailableLocales(sourceAvailableLocales);\n\t\t\t\tle.setTargetAvailableLocales(targetAvailableLocales);\n\n\t\t\t\tthrow le;\n\t\t\t}\n\t\t}\n\n\t\t// Layout prototypes validity\n\n\t\tvalidateLayoutPrototypes(\n\t\t\tportletDataContext.getCompanyId(), _layoutsElement,\n\t\t\t_layoutElements);\n\t}","commit_id":"5b76cabb90a6eb8e72d4fb4b2ef6eeb79b9948cf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletURL getPortletURL(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = themeDisplay.getSiteGroup();\n\n\t\tPortletURL portletURL = super.getPortletURL(request);\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.TRUE.toString());\n\t\t}\n\n\t\treturn portletURL;\n\t}","id":41964,"modified_method":"@Override\n\tpublic PortletURL getPortletURL(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = themeDisplay.getSiteGroup();\n\n\t\tPortletURL portletURL = super.getPortletURL(request);\n\n\t\tif ((!group.hasPublicLayouts() && group.hasPrivateLayouts()) ||\n\t\t\tgroup.isLayoutSetPrototype()) {\n\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.TRUE.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.FALSE.toString());\n\t\t}\n\n\t\treturn portletURL;\n\t}","commit_id":"a8fa6895272619de2632a52e855492b262dbdeea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletURL getPortletURL(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = themeDisplay.getSiteGroup();\n\n\t\tPortletURL portletURL = super.getPortletURL(request);\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.TRUE.toString());\n\t\t}\n\n\t\treturn portletURL;\n\t}","id":41965,"modified_method":"@Override\n\tpublic PortletURL getPortletURL(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = themeDisplay.getSiteGroup();\n\n\t\tPortletURL portletURL = super.getPortletURL(request);\n\n\t\tif ((!group.hasPublicLayouts() && group.hasPrivateLayouts()) ||\n\t\t\tgroup.isLayoutSetPrototype()) {\n\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.TRUE.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"privateLayout\", Boolean.FALSE.toString());\n\t\t}\n\n\t\treturn portletURL;\n\t}","commit_id":"a8fa6895272619de2632a52e855492b262dbdeea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void run() throws Exception {\n        try {\n            Object[] responses;\n            if (operationFactory instanceof PartitionAwareOperationFactory) {\n                responses = executePartitionAwareOperations();\n            } else {\n                responses = executeOperations();\n            }\n\n            results = resolveResponses(responses);\n        } catch (Exception e) {\n            getLogger(getNodeEngine()).severe(e);\n        }\n    }","id":41966,"modified_method":"@Override\n    public void run() throws Exception {\n        try {\n            Object[] responses;\n\n            PartitionAwareOperationFactory partitionAware = getPartitionAwareFactoryOrNull();\n            if (partitionAware != null) {\n                responses = executePartitionAwareOperations(partitionAware);\n            } else {\n                responses = executeOperations();\n            }\n\n            results = resolveResponses(responses);\n        } catch (Exception e) {\n            getLogger(getNodeEngine()).severe(e);\n        }\n    }","commit_id":"718c68d8448be78b37cb04b131be2e9a732d0326","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Object[] executeOperations() {\n        NodeEngine nodeEngine = getNodeEngine();\n        Object[] responses = new Object[partitions.length];\n        for (int i = 0; i < partitions.length; i++) {\n            ResponseQueue responseQueue = new ResponseQueue();\n            responses[i] = responseQueue;\n\n            Operation operation = operationFactory.createOperation();\n            operation.setNodeEngine(nodeEngine)\n                    .setPartitionId(partitions[i])\n                    .setReplicaIndex(getReplicaIndex())\n                    .setOperationResponseHandler(responseQueue)\n                    .setServiceName(getServiceName())\n                    .setService(getService());\n\n            setCallerUuid(operation);\n            OperationAccessor.setCallerAddress(operation, getCallerAddress());\n            nodeEngine.getOperationService().execute(operation);\n        }\n        return responses;\n    }","id":41967,"modified_method":"private Object[] executeOperations() {\n        NodeEngine nodeEngine = getNodeEngine();\n        Object[] responses = new Object[partitions.length];\n        for (int i = 0; i < partitions.length; i++) {\n            ResponseQueue responseQueue = new ResponseQueue();\n            responses[i] = responseQueue;\n\n            Operation operation = operationFactory.createOperation();\n            operation.setNodeEngine(nodeEngine)\n                    .setPartitionId(partitions[i])\n                    .setReplicaIndex(getReplicaIndex())\n                    .setOperationResponseHandler(responseQueue)\n                    .setServiceName(getServiceName())\n                    .setService(getService())\n                    .setCallerUuid(extractCallerUuid());\n\n            OperationAccessor.setCallerAddress(operation, getCallerAddress());\n            nodeEngine.getOperationService().execute(operation);\n        }\n        return responses;\n    }","commit_id":"718c68d8448be78b37cb04b131be2e9a732d0326","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Object[] executePartitionAwareOperations() {\n        PartitionAwareOperationFactory operationFactory = (PartitionAwareOperationFactory) this.operationFactory;\n        operationFactory.init(getNodeEngine());\n\n        NodeEngine nodeEngine = getNodeEngine();\n        int[] operationFactoryPartitions = operationFactory.getPartitions();\n        partitions = operationFactoryPartitions == null ? partitions : operationFactoryPartitions;\n        Object[] responses = new Object[partitions.length];\n\n        for (int i = 0; i < partitions.length; i++) {\n            ResponseQueue responseQueue = new ResponseQueue();\n            responses[i] = responseQueue;\n\n            int partition = partitions[i];\n            Operation operation = operationFactory.createPartitionOperation(partition);\n            operation.setNodeEngine(nodeEngine)\n                    .setPartitionId(partition)\n                    .setReplicaIndex(getReplicaIndex())\n                    .setOperationResponseHandler(responseQueue)\n                    .setServiceName(getServiceName())\n                    .setService(getService());\n\n            setCallerUuid(operation);\n            OperationAccessor.setCallerAddress(operation, getCallerAddress());\n            nodeEngine.getOperationService().execute(operation);\n        }\n        return responses;\n    }","id":41968,"modified_method":"private Object[] executePartitionAwareOperations(PartitionAwareOperationFactory partitionAwareFactory) {\n        partitionAwareFactory.init(getNodeEngine());\n\n        NodeEngine nodeEngine = getNodeEngine();\n        int[] operationFactoryPartitions = partitionAwareFactory.getPartitions();\n        partitions = operationFactoryPartitions == null ? partitions : operationFactoryPartitions;\n        Object[] responses = new Object[partitions.length];\n\n        for (int i = 0; i < partitions.length; i++) {\n            ResponseQueue responseQueue = new ResponseQueue();\n            responses[i] = responseQueue;\n\n            int partition = partitions[i];\n            Operation operation = partitionAwareFactory.createPartitionOperation(partition);\n\n            operation.setNodeEngine(nodeEngine)\n                    .setPartitionId(partition)\n                    .setReplicaIndex(getReplicaIndex())\n                    .setOperationResponseHandler(responseQueue)\n                    .setServiceName(getServiceName())\n                    .setService(getService())\n                    .setCallerUuid(extractCallerUuid());\n\n            OperationAccessor.setCallerAddress(operation, getCallerAddress());\n            nodeEngine.getOperationService().execute(operation);\n        }\n        return responses;\n    }","commit_id":"718c68d8448be78b37cb04b131be2e9a732d0326","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void setCallerUuid(Operation operation) {\n        // Clients callerUUID can be set already. See OperationFactoryWrapper usage.\n        if (operation.getCallerUuid() != null) {\n            return;\n        }\n\n        operation.setCallerUuid(getCallerUuid());\n    }","id":41969,"modified_method":"private String extractCallerUuid() {\n        // Clients callerUUID can be set already. See OperationFactoryWrapper usage.\n        if (operationFactory instanceof OperationFactoryWrapper) {\n            return ((OperationFactoryWrapper) operationFactory).getUuid();\n        }\n\n        // Members UUID\n        return getCallerUuid();\n    }","commit_id":"718c68d8448be78b37cb04b131be2e9a732d0326","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void run() throws Exception {\n        final NodeEngine nodeEngine = getNodeEngine();\n        results = new HashMap<Integer, Object>(partitions.size());\n        try {\n            Map<Integer, ResponseQueue> responses = new HashMap<Integer, ResponseQueue>(partitions.size());\n            for (final int partitionId : partitions) {\n                ResponseQueue responseQueue = new ResponseQueue();\n                final Operation op = operationFactory.createOperation();\n                op.setNodeEngine(nodeEngine)\n                        .setPartitionId(partitionId)\n                        .setReplicaIndex(getReplicaIndex())\n                        .setResponseHandler(responseQueue)\n                        .setServiceName(getServiceName())\n                        .setService(getService());\n                OperationAccessor.setCallerAddress(op, getCallerAddress());\n                responses.put(partitionId, responseQueue);\n                nodeEngine.getOperationService().executeOperation(op);\n            }\n            for (Map.Entry<Integer, ResponseQueue> responseQueueEntry : responses.entrySet()) {\n                final ResponseQueue queue = responseQueueEntry.getValue();\n                final Integer key = responseQueueEntry.getKey();\n                final Object result = queue.get();\n                if (result instanceof NormalResponse) {\n                    results.put(key, ((NormalResponse) result).getValue());\n                } else {\n                    results.put(key, result);\n                }\n            }\n        } catch (Exception e) {\n            getLogger(nodeEngine).severe(e);\n        }\n    }","id":41970,"modified_method":"public final void run() throws Exception {\n        final NodeEngine nodeEngine = getNodeEngine();\n        results = new HashMap<Integer, Object>(partitions.size());\n        try {\n            Map<Integer, ResponseQueue> responses = new HashMap<Integer, ResponseQueue>(partitions.size());\n            for (final int partitionId : partitions) {\n                ResponseQueue responseQueue = new ResponseQueue();\n                final Operation op = operationFactory.createOperation();\n                op.setNodeEngine(nodeEngine)\n                        .setPartitionId(partitionId)\n                        .setReplicaIndex(getReplicaIndex())\n                        .setResponseHandler(responseQueue)\n                        .setServiceName(getServiceName())\n                        .setService(getService())\n                        .setCallerUuid(getCallerUuid());\n                OperationAccessor.setCallerAddress(op, getCallerAddress());\n                responses.put(partitionId, responseQueue);\n                nodeEngine.getOperationService().executeOperation(op);\n            }\n            for (Map.Entry<Integer, ResponseQueue> responseQueueEntry : responses.entrySet()) {\n                final ResponseQueue queue = responseQueueEntry.getValue();\n                final Integer key = responseQueueEntry.getKey();\n                final Object result = queue.get();\n                if (result instanceof NormalResponse) {\n                    results.put(key, ((NormalResponse) result).getValue());\n                } else {\n                    results.put(key, result);\n                }\n            }\n        } catch (Exception e) {\n            getLogger(nodeEngine).severe(e);\n        }\n    }","commit_id":"e5b77a2014a572d91ae8eade932068d3f7e61bd0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n   * Checks the restriction on a node for a given user layout and node ID\n   * @param layout a <code>IAggregatedLayout<\/code> layout\n   * @param nodeId a <code>INodeId<\/code> node ID\n   * @return a boolean value\n   * @exception PortalException\n   */\n  public boolean checkRestriction ( IAggregatedLayout layout, INodeId nodeId ) throws PortalException {\n  \tIALNode node = (IALNode) layout.getLayoutNode(nodeId);\n  \tif ( node == null )\n  \t  throw new PortalException ( \"The aggregated layout does not contain the node specified by ID = \"+nodeId);\t\n  \treturn checkRestriction(node);\n  }","id":41971,"modified_method":"/**\n   * Checks the restriction on a node for a given user layout and node ID\n   * @param layout a <code>IAggregatedLayout<\/code> layout\n   * @param nodeId a <code>INodeId<\/code> node ID\n   * @return a boolean value\n   * @exception PortalException\n   */\n  public boolean checkRestriction ( IAggregatedLayout layout, INodeId nodeId ) throws PortalException {\n  \tIALNode node = (IALNode) layout.getNode(nodeId);\n  \tif ( node == null )\n  \t  throw new PortalException ( \"The aggregated layout does not contain the node specified by ID = \"+nodeId);\t\n  \treturn checkRestriction(node);\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setUserLayout(IUserLayout layout) throws PortalException {\n   if ( !(layout instanceof IAggregatedLayout) )\n    throw new PortalException ( \"The user layout instance must have IAggregatedLayout type!\" );\n    this.layout = (IAggregatedLayout) layout;\n  }","id":41972,"modified_method":"public void setUserLayout(ILayout layout) throws PortalException {\n   if ( !(layout instanceof IAggregatedLayout) )\n    throw new PortalException ( \"The user layout instance must have IAggregatedLayout type!\" );\n    this.layout = (IAggregatedLayout) layout;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Recursively checks the depth restrictions beginning with a given node\n     * @param nodeId a node id\n     * @param depth a depth on which the node is going to be attached\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkDepthRestrictions( INodeId nodeId, int depth ) throws PortalException {\n    IALNode node = layout.getLayoutNode(nodeId);\n    // Checking restrictions for the node\n    if ( !checkRestriction(node.getId(),RestrictionType.DEPTH_RESTRICTION,depth+\"\") )\n            return false;\n    if ( node.getType() == NodeType.FOLDER ) {\n     IALFolder folder = (IALFolder) node;\t\n     for ( INode n = folder.getFirstChildNode(); n != null; n = n.getNextSiblingNode() ) {\n      if ( !checkDepthRestrictions(((ILayoutNode)n).getId(),depth+1) )\n            return false;\n     }\n    }\n    return true;\n  }","id":41973,"modified_method":"/**\n     * Recursively checks the depth restrictions beginning with a given node\n     * @param nodeId a node id\n     * @param depth a depth on which the node is going to be attached\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkDepthRestrictions( INodeId nodeId, int depth ) throws PortalException {\n    IALNode node = (IALNode) layout.getNode(nodeId);\n    // Checking restrictions for the node\n    if ( !checkRestriction(node.getId(),RestrictionType.DEPTH_RESTRICTION,depth+\"\") )\n            return false;\n    if ( node.getType() == NodeType.FOLDER ) {\n     IALFolder folder = (IALFolder) node;\t\n     for ( INode n = folder.getFirstChildNode(); n != null; n = n.getNextSiblingNode() ) {\n      if ( !checkDepthRestrictions(((ILayoutNode)n).getId(),depth+1) )\n            return false;\n     }\n    }\n    return true;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Checks the necessary restrictions while adding a new node\n     * @param node a <code>ILayoutNode<\/code> a new node to be added\n     * @param parentId a parent node id\n     * @param nextSiblingId a <next sibling node id\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkAddRestrictions( ILayoutNode node, INodeId parentId, INodeId nextSiblingId ) throws PortalException {\n  \t\n  \tif ( !(node instanceof IALNode) )\n       throw new PortalException (\"The node must be IALNode type!\");\n  \t\n  \tIALNode newNode = (IALNode) node;\n    INodeId newNodeId = newNode.getId();\n    IALNode parentNode = layout.getLayoutNode(parentId);\n\n    if ( !(parentNode.getType()==NodeType.FOLDER ) )\n      throw new PortalException (\"The target parent node should be a folder!\");\n\n    //if ( checkRestriction(parentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {\n    if ( !parentNode.isImmutable() ) {\n\n     // Checking children related restrictions\n     Collection restrictions = parentNode.getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n     for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if (   !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(newNode) )\n            return false;\n     }\n\n     // Checking parent related restrictions\n     restrictions = newNode.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n     for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n          IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n          if (  !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(parentNode) )\n            return false;\n     }\n\n     // Considering two cases if the node is new or it is already in the user layout\n     if ( newNodeId != null ) {\n      // Checking depth restrictions for the node and all its descendants (if there are any)\n      if ( !checkDepthRestrictions(newNodeId,parentId) )\n         return false;\n     } else\n         return checkRestriction(newNode,RestrictionType.DEPTH_RESTRICTION,(layout.getDepth(parentId)+1)+\"\");\n\n     // Checking sibling nodes order\n     //return changeSiblingNodesPriorities(newNode,parentId,nextSiblingId);\n     return true;\n\n    } else\n        return false;\n  }","id":41974,"modified_method":"/**\n     * Checks the necessary restrictions while adding a new node\n     * @param node a <code>ILayoutNode<\/code> a new node to be added\n     * @param parentId a parent node id\n     * @param nextSiblingId a <next sibling node id\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkAddRestrictions( INode node, INodeId parentId, INodeId nextSiblingId ) throws PortalException {\n  \t\n  \tif ( !(node instanceof IALNode) )\n       throw new PortalException (\"The node must be IALNode type!\");\n  \t\n  \tIALNode newNode = (IALNode) node;\n    INodeId newNodeId = newNode.getId();\n    IALNode parentNode = (IALNode) layout.getNode(parentId);\n\n    if ( !(parentNode.getType()==NodeType.FOLDER ) )\n      throw new PortalException (\"The target parent node should be a folder!\");\n\n    //if ( checkRestriction(parentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {\n    if ( !parentNode.isImmutable() ) {\n\n     // Checking children related restrictions\n     Collection restrictions = parentNode.getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n     for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if (   !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(newNode) )\n            return false;\n     }\n\n     // Checking parent related restrictions\n     restrictions = newNode.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n     for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n          IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n          if (  !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(parentNode) )\n            return false;\n     }\n\n     // Considering two cases if the node is new or it is already in the user layout\n     if ( newNodeId != null ) {\n      // Checking depth restrictions for the node and all its descendants (if there are any)\n      if ( !checkDepthRestrictions(newNodeId,parentId) )\n         return false;\n     } else\n         return checkRestriction(newNode,RestrictionType.DEPTH_RESTRICTION,(layout.getDepth(parentId)+1)+\"\");\n\n     // Checking sibling nodes order\n     //return changeSiblingNodesPriorities(newNode,parentId,nextSiblingId);\n     return true;\n\n    } else\n        return false;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Checks the restriction specified by the parameters below\n     * @param nodeId a node id\n     * @param restrictionType a <code>RestrictionType<\/code> restriction type\n     * @param restrictionPath a <code>RestrictionPath<\/code> restriction path\n     * @param propertyValue a <code>String<\/code> property value to be checked\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkRestriction(INodeId nodeId, RestrictionType restrictionType, RestrictionPath restrictionPath, String propertyValue) throws PortalException {\n    IALNode node = layout.getLayoutNode(nodeId);\n    return (node!=null)?checkRestriction(node,restrictionType,restrictionPath,propertyValue):true;\n  }","id":41975,"modified_method":"/**\n     * Checks the restriction specified by the parameters below\n     * @param nodeId a node id\n     * @param restrictionType a <code>RestrictionType<\/code> restriction type\n     * @param restrictionPath a <code>RestrictionPath<\/code> restriction path\n     * @param propertyValue a <code>String<\/code> property value to be checked\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkRestriction(INodeId nodeId, RestrictionType restrictionType, RestrictionPath restrictionPath, String propertyValue) throws PortalException {\n    IALNode node = (IALNode) layout.getNode(nodeId);\n    return (node!=null)?checkRestriction(node,restrictionType,restrictionPath,propertyValue):true;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Checks the necessary restrictions while moving a node\n     * @param nodeId a <code>String<\/code> node ID of a node to be moved\n     * @param newParentId a <code>String<\/code> new parent node ID\n     * @param nextSiblingId a <code>String<\/code> next sibling node ID\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkMoveRestrictions( INodeId nodeId, INodeId newParentId, INodeId nextSiblingId ) throws PortalException {\n  \t\n    IALNode node = layout.getLayoutNode(nodeId);\n    IALNode oldParentNode = (IALNode) node.getParentNode();\n    IALFolder newParentNode = layout.getLayoutFolder(newParentId);\n\n    /*if ( checkRestriction(oldParentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") &&\n         checkRestriction(newParentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {*/\n    if ( !oldParentNode.isImmutable() && !newParentNode.isImmutable() ) {\n\n     if ( !oldParentNode.equals(newParentNode) ) {\n      // Checking children related restrictions\n      Collection restrictions = newParentNode.getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n      for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if (   !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(node) )\n            return false;\n      }\n\n      // Checking parent related restrictions\n      restrictions = node.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n      for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n          IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n          if (  !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(newParentNode) )\n            return false;\n      }\n\n      // Checking depth restrictions for the node and all its descendants\n      if ( !checkDepthRestrictions(nodeId,newParentId) )\n            return false;\n     }\n\n     return true;\n\n    } else\n        return false;\n  }","id":41976,"modified_method":"/**\n     * Checks the necessary restrictions while moving a node\n     * @param nodeId a <code>String<\/code> node ID of a node to be moved\n     * @param newParentId a <code>String<\/code> new parent node ID\n     * @param nextSiblingId a <code>String<\/code> next sibling node ID\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkMoveRestrictions( INodeId nodeId, INodeId newParentId, INodeId nextSiblingId ) throws PortalException {\n  \t\n    IALNode node = (IALNode) layout.getNode(nodeId);\n    IALNode oldParentNode = (IALNode) node.getParentNode();\n    IALFolder newParentNode = (IALFolder) layout.getNode(newParentId);\n\n    /*if ( checkRestriction(oldParentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") &&\n         checkRestriction(newParentNode,RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {*/\n    if ( !oldParentNode.isImmutable() && !newParentNode.isImmutable() ) {\n\n     if ( !oldParentNode.equals(newParentNode) ) {\n      // Checking children related restrictions\n      Collection restrictions = newParentNode.getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n      for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if (   !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(node) )\n            return false;\n      }\n\n      // Checking parent related restrictions\n      restrictions = node.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n      for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n          IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n          if (  !restriction.is(RestrictionType.DEPTH_RESTRICTION) &&\n                !restriction.checkRestriction(newParentNode) )\n            return false;\n      }\n\n      // Checking depth restrictions for the node and all its descendants\n      if ( !checkDepthRestrictions(nodeId,newParentId) )\n            return false;\n     }\n\n     return true;\n\n    } else\n        return false;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean checkUpdateRestrictions(INodeDescription nodeDescription, INodeId nodeId ) throws PortalException {\n  \t   \n        IALNodeDescription nodeDesc=(IALNodeDescription) nodeDescription;\n        \n        if ( nodeId == null ) return false;\n        \n        IALNode node = layout.getLayoutNode(nodeId);\n        IALNodeDescription currentNodeDesc = node.getNodeDescription();\n\n        // Checking the immutable node restriction\n        //if ( checkRestriction(node,RestrictionTypes.IMMUTABLE_RESTRICTION,\"true\") )\n        if ( node.isImmutable() )\n            return false;\n\n        // Checking the immutable parent node related restriction\n        if ( getRestriction((IALNode)node.getParentNode(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.CHILDREN_RESTRICTION_PATH) != null &&\n             checkRestriction(((ILayoutNode)node.getParentNode()).getId(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.CHILDREN_RESTRICTION_PATH,\"true\") )\n            return false;\n\n        // Checking the immutable children node related restrictions\n        if ( node.getType().equals(NodeType.FOLDER) ) {\n            IALFolder folder = (IALFolder) node;\n            //Loop for all children\n            for ( node = (IALNode) folder.getFirstChildNode(); node != null; node = (IALNode) node.getNextSiblingNode() )\n             if ( getRestriction(node,RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.PARENT_RESTRICTION_PATH) != null &&\n                  checkRestriction(node.getId(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.PARENT_RESTRICTION_PATH,\"true\") )\n                  return false;\n        }\n\n       // if a new node description doesn't contain any restrictions the old restrictions will be used\n        if ( nodeDesc.getRestrictions() == null )\n          nodeDesc.setRestrictions(node.getRestrictions());\n        \n        Collection restrictions = nodeDesc.getRestrictions();\n        // Setting the new node description to the node\n        node.setNodeDescription(nodeDesc);\n\n        // Checking restrictions for the node\n        if ( restrictions != null ) {\n           for ( Iterator i = restrictions.iterator(); i.hasNext(); )\n             if ( !((IUserLayoutRestriction)i.next()).checkRestriction(node) ) {\n                  node.setNodeDescription(currentNodeDesc);\n                  return false;\n             }\n        }\n\n\n        // Checking parent related restrictions for the children\n        restrictions = ((IALNode)node.getParentNode()).getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n        for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if ( !restriction.checkRestriction(node) ) {\n            node.setNodeDescription(currentNodeDesc);\n            return false;\n         }\n        }\n\n\n        // Checking child related restrictions for the parent\n        if ( node.getType().equals(NodeType.FOLDER) ) {\n         for ( IALNode child = (IALNode) ((IALFolder)node).getFirstChildNode(); child != null; ) {\n          restrictions = child.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n          for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n           IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n           if ( !restriction.checkRestriction(node) ) {\n            node.setNodeDescription(currentNodeDesc);\n            return false;\n           }\n          }\n          child=(IALNode) child.getNextSiblingNode();\n         }\n        }\n\n        return true;\n  \t\n    }","id":41977,"modified_method":"public boolean checkUpdateRestrictions(INodeDescription nodeDescription, INodeId nodeId ) throws PortalException {\n  \t   \n        IALNodeDescription nodeDesc=(IALNodeDescription) nodeDescription;\n        \n        if ( nodeId == null ) return false;\n        \n        IALNode node = (IALNode) layout.getNode(nodeId);\n        IALNodeDescription currentNodeDesc = node.getNodeDescription();\n\n        // Checking the immutable node restriction\n        //if ( checkRestriction(node,RestrictionTypes.IMMUTABLE_RESTRICTION,\"true\") )\n        if ( node.isImmutable() )\n            return false;\n\n        // Checking the immutable parent node related restriction\n        if ( getRestriction((IALNode)node.getParentNode(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.CHILDREN_RESTRICTION_PATH) != null &&\n             checkRestriction(((ILayoutNode)node.getParentNode()).getId(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.CHILDREN_RESTRICTION_PATH,\"true\") )\n            return false;\n\n        // Checking the immutable children node related restrictions\n        if ( node.getType().equals(NodeType.FOLDER) ) {\n            IALFolder folder = (IALFolder) node;\n            //Loop for all children\n            for ( node = (IALNode) folder.getFirstChildNode(); node != null; node = (IALNode) node.getNextSiblingNode() )\n             if ( getRestriction(node,RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.PARENT_RESTRICTION_PATH) != null &&\n                  checkRestriction(node.getId(),RestrictionType.IMMUTABLE_RESTRICTION,RestrictionPath.PARENT_RESTRICTION_PATH,\"true\") )\n                  return false;\n        }\n\n       // if a new node description doesn't contain any restrictions the old restrictions will be used\n        if ( nodeDesc.getRestrictions() == null )\n          nodeDesc.setRestrictions(node.getRestrictions());\n        \n        Collection restrictions = nodeDesc.getRestrictions();\n        // Setting the new node description to the node\n        node.setNodeDescription(nodeDesc);\n\n        // Checking restrictions for the node\n        if ( restrictions != null ) {\n           for ( Iterator i = restrictions.iterator(); i.hasNext(); )\n             if ( !((IUserLayoutRestriction)i.next()).checkRestriction(node) ) {\n                  node.setNodeDescription(currentNodeDesc);\n                  return false;\n             }\n        }\n\n\n        // Checking parent related restrictions for the children\n        restrictions = ((IALNode)node.getParentNode()).getRestrictionsByPath(RestrictionPath.CHILDREN_RESTRICTION_PATH);\n        for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n         IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n         if ( !restriction.checkRestriction(node) ) {\n            node.setNodeDescription(currentNodeDesc);\n            return false;\n         }\n        }\n\n\n        // Checking child related restrictions for the parent\n        if ( node.getType().equals(NodeType.FOLDER) ) {\n         for ( IALNode child = (IALNode) ((IALFolder)node).getFirstChildNode(); child != null; ) {\n          restrictions = child.getRestrictionsByPath(RestrictionPath.PARENT_RESTRICTION_PATH);\n          for ( Iterator i = restrictions.iterator(); i.hasNext(); ) {\n           IUserLayoutRestriction restriction = (IUserLayoutRestriction) i.next();\n           if ( !restriction.checkRestriction(node) ) {\n            node.setNodeDescription(currentNodeDesc);\n            return false;\n           }\n          }\n          child=(IALNode) child.getNextSiblingNode();\n         }\n        }\n\n        return true;\n  \t\n    }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Checks the necessary restrictions while deleting a node\n     * @param nodeId an id of a node to be deleted\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkDeleteRestrictions( INodeId nodeId ) throws PortalException {\n    IALNode node = layout.getLayoutNode(nodeId);\n    if ( nodeId == null || node == null ) return true;\n    //if ( checkRestriction(node.getParentNodeId(),RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {\n    if ( !node.getParentNode().isImmutable() ) {\n         // Checking the unremovable restriction on the node to be deleted\n         //return checkRestriction(nodeId,RestrictionTypes.UNREMOVABLE_RESTRICTION,\"false\");\n         return !node.isUnremovable();\n    } else\n         return false;\n  }","id":41978,"modified_method":"/**\n     * Checks the necessary restrictions while deleting a node\n     * @param nodeId an id of a node to be deleted\n     * @return a boolean value\n     * @exception PortalException if an error occurs\n     */\n  public boolean checkDeleteRestrictions( INodeId nodeId ) throws PortalException {\n    IALNode node = (IALNode) layout.getNode(nodeId);\n    if ( nodeId == null || node == null ) return true;\n    //if ( checkRestriction(node.getParentNodeId(),RestrictionTypes.IMMUTABLE_RESTRICTION,\"false\") ) {\n    if ( !node.getParentNode().isImmutable() ) {\n         // Checking the unremovable restriction on the node to be deleted\n         //return checkRestriction(nodeId,RestrictionTypes.UNREMOVABLE_RESTRICTION,\"false\");\n         return !node.isUnremovable();\n    } else\n         return false;\n  }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Obtain a regular restriction manager implementation\n     *\n     * @return an <code>IRestrictionManager<\/code> value\n     */\n    public static IRestrictionManager getRestrictionManager(IUserLayout layout) throws PortalException {\n        try {\n            IRestrictionManager restrictionManager = (IRestrictionManager) restrictionManagerClass.newInstance();\n            restrictionManager.setUserLayout(layout);\n            return restrictionManager;\n        } catch (Exception e) {\n            throw new PortalException(\"Unable to instantiate a \\\"\"+restrictionManagerClass.getName()+\"\\\"\",e);\n        }\n    }","id":41979,"modified_method":"/**\n     * Obtain a regular restriction manager implementation\n     *\n     * @return an <code>IRestrictionManager<\/code> value\n     */\n    public static IRestrictionManager getRestrictionManager(ILayout layout) throws PortalException {\n        try {\n            IRestrictionManager restrictionManager = (IRestrictionManager) restrictionManagerClass.newInstance();\n            restrictionManager.setUserLayout(layout);\n            return restrictionManager;\n        } catch (Exception e) {\n            throw new PortalException(\"Unable to instantiate a \\\"\"+restrictionManagerClass.getName()+\"\\\"\",e);\n        }\n    }","commit_id":"61d9e6413362a47d4f1a350f0b033c877c40a97a","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\r\n  public void removeResource(final Resource res) throws XMLDBException {\r\n    check();\r\n\r\n    // resource is no relevant xml resource\r\n    final BXXMLResource del = checkXML(res);\r\n    final Data data = ctx.data;\r\n\r\n    // check if data instance refers to another database\r\n    if(del.data != data && del.data != null) throw new XMLDBException(\r\n        ErrorCodes.NO_SUCH_RESOURCE, ERR_UNKNOWN + data.meta.name);\r\n\r\n    // find correct value and remove the node\r\n    Delete.delete(ctx, getResource(del.getId()).pre);\r\n  }","id":41980,"modified_method":"@Override\r\n  public void removeResource(final Resource res) throws XMLDBException {\r\n    check();\r\n\r\n    // resource is no relevant xml resource\r\n    final BXXMLResource del = checkXML(res);\r\n    final Data data = ctx.data;\r\n\r\n    // check if data instance refers to another database\r\n    if(del.data != data && del.data != null) throw new XMLDBException(\r\n        ErrorCodes.NO_SUCH_RESOURCE, ERR_UNKNOWN + data.meta.name);\r\n\r\n    // find correct value and remove the node\r\n    final IntList il = new IntList();\r\n    il.add(getResource(del.getId()).pre);\r\n    Delete.delete(ctx, il);\r\n  }","commit_id":"a56b2fe5d0554df5ca4cbcadce05a209b7de7819","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public String[] listResources() throws XMLDBException {\r\n    check();\r\n    final StringList sl = new StringList();\r\n    final Data data = ctx.data;\r\n    for(final int pre : data.doc()) {\r\n      sl.add(Token.string(data.text(pre, true)));\r\n    }\r\n    return sl.toArray();\r\n  }","id":41981,"modified_method":"@Override\r\n  public String[] listResources() throws XMLDBException {\r\n    check();\r\n    final StringList sl = new StringList();\r\n    final Data data = ctx.data;\r\n    final IntList il = data.doc();\r\n    for(int i = 0, is = il.size(); i < is; i++) {\r\n      sl.add(Token.string(data.text(il.get(i), true)));\r\n    }\r\n    return sl.toArray();\r\n  }","commit_id":"a56b2fe5d0554df5ca4cbcadce05a209b7de7819","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public BXXMLResource getResource(final String id) throws XMLDBException {\r\n    check();\r\n    if(id == null) return null;\r\n    final Data data = ctx.data;\r\n    final byte[] idd = Token.token(id);\r\n    for(final int pre : data.doc()) {\r\n      if(Token.eq(data.text(pre, true), idd))\r\n        return new BXXMLResource(data, pre, id, this);\r\n    }\r\n    return null;\r\n  }","id":41982,"modified_method":"@Override\r\n  public BXXMLResource getResource(final String id) throws XMLDBException {\r\n    check();\r\n    if(id == null) return null;\r\n    final Data data = ctx.data;\r\n    final byte[] idd = Token.token(id);\r\n    final IntList il = data.doc();\r\n    for(int i = 0, is = il.size(); i < is; i++) {\r\n      final int pre = il.get(i);\r\n      if(Token.eq(data.text(pre, true), idd))\r\n        return new BXXMLResource(data, pre, id, this);\r\n    }\r\n    return null;\r\n  }","commit_id":"a56b2fe5d0554df5ca4cbcadce05a209b7de7819","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public int getResourceCount() throws XMLDBException {\r\n    check();\r\n    return ctx.data.doc().length;\r\n  }","id":41983,"modified_method":"@Override\r\n  public int getResourceCount() throws XMLDBException {\r\n    check();\r\n    return ctx.data.doc().size();\r\n  }","commit_id":"a56b2fe5d0554df5ca4cbcadce05a209b7de7819","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the root resource of the specified path.\r\n   * If the path contains more or less than a single resource,\r\n   * an exception is thrown.\r\n   * @param path path\r\n   * @return root resource\r\n   */\r\n  final String root(final ResourcePath path) {\r\n    if(path.getDepth() == 1) return path.getResourcePath();\r\n    throw new JaxRxException(404, \"Resource '\" + path + \"' was not found.\");\r\n  }","id":41984,"modified_method":"/**\r\n   * Returns the root resource of the specified path.\r\n   * If the path contains more or less than a single resource,\r\n   * an exception is thrown.\r\n   * @param path path\r\n   * @return root resource\r\n   */\r\n  final String db(final ResourcePath path) {\r\n    return path.getResource(0);\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Runs the {@link #code()} method and closes the client session.\r\n   * A server exception is thrown if I/O errors occur.\r\n   */\r\n  final void run() {\r\n    try {\r\n      code();\r\n    } catch(final IOException ex) {\r\n      throw new JaxRxException(ex);\r\n    } finally {\r\n      try { cs.close(); } catch(final Exception ex) { /**/ }\r\n    }\r\n  }","id":41985,"modified_method":"/**\r\n   * Runs the {@link #code()} method and closes the client session.\r\n   * A server exception is thrown if I/O errors occur.\r\n   * @return info message\r\n   */\r\n  final String run() {\r\n    try {\r\n      return code();\r\n    } catch(final IOException ex) {\r\n      throw new JaxRxException(ex);\r\n    } finally {\r\n      try { cs.close(); } catch(final Exception ex) { /**/ }\r\n    }\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Code to be run.\r\n   * @throws IOException I/O exception\r\n   */\r\n  abstract void code() throws IOException;","id":41986,"modified_method":"/**\r\n   * Code to be run.\r\n   * @return string info message\r\n   * @throws IOException I/O exception\r\n   */\r\n  abstract String code() throws IOException;","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public int getResourceCount() throws XMLDBException {\r\n    check();\r\n    return ctx.data.doc().length;\r\n  }","id":41987,"modified_method":"@Override\r\n  public int getResourceCount() throws XMLDBException {\r\n    check();\r\n    return ctx.data.doc().size();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public String[] listResources() throws XMLDBException {\r\n    check();\r\n    final StringList sl = new StringList();\r\n    final Data data = ctx.data;\r\n    for(final int d : data.doc()) sl.add(Token.string(data.text(d, true)));\r\n    return sl.toArray();\r\n  }","id":41988,"modified_method":"@Override\r\n  public String[] listResources() throws XMLDBException {\r\n    check();\r\n    final StringList sl = new StringList();\r\n    final Data data = ctx.data;\r\n    for(final int d : data.doc().toArray()) {\r\n      sl.add(Token.string(data.text(d, true)));\r\n    }\r\n    return sl.toArray();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public BXXMLResource getResource(final String id) throws XMLDBException {\r\n    check();\r\n    if(id == null) return null;\r\n    final Data data = ctx.data;\r\n    final byte[] idd = Token.token(id);\r\n    for(final int d : data.doc()) {\r\n      if(Token.eq(data.text(d, true), idd))\r\n        return new BXXMLResource(data, d, id, this);\r\n    }\r\n    return null;\r\n  }","id":41989,"modified_method":"@Override\r\n  public BXXMLResource getResource(final String id) throws XMLDBException {\r\n    check();\r\n    if(id == null) return null;\r\n    final Data data = ctx.data;\r\n    final byte[] idd = Token.token(id);\r\n    for(final int d : data.doc().toArray()) {\r\n      if(Token.eq(data.text(d, true), idd))\r\n        return new BXXMLResource(data, d, id, this);\r\n    }\r\n    return null;\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public StreamingOutput command(final String cmd, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      void code() throws IOException {\r\n        // perform command\r\n        final ArrayOutput ao = new ArrayOutput();\r\n        exec(cmd, ao);\r\n\r\n        // serialize output and remove carriage returns\r\n        final XMLSerializer xml =\r\n          new XMLSerializer(out, new SerializerProp(params(path)));\r\n        xml.text(Token.delete(ao.toArray(), '\\r'));\r\n        xml.close();\r\n      }\r\n    };\r\n  }","id":41990,"modified_method":"@Override\r\n  public StreamingOutput command(final String cmd, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      String code() throws IOException {\r\n        // perform command\r\n        final ArrayOutput ao = new ArrayOutput();\r\n        exec(cmd, ao);\r\n\r\n        // serialize output and remove carriage returns\r\n        final XMLSerializer xml =\r\n          new XMLSerializer(out, new SerializerProp(params(path)));\r\n        xml.text(Token.delete(ao.toArray(), '\\r'));\r\n        xml.close();\r\n        return cs.info();\r\n      }\r\n    };\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public StreamingOutput get(final ResourcePath rp) {\r\n    if(rp.getDepth() != 0) return query(\".\", rp);\r\n\r\n    return new BXOutput(null) {\r\n      @Override\r\n      void code() throws IOException {\r\n        final XMLSerializer xml = new XMLSerializer(out,\r\n            new SerializerProp(params(rp)));\r\n\r\n        // retrieve list of databases\r\n        final Table table = new Table(exec(new List(), null));\r\n        for(final TokenList l : table.contents) {\r\n          xml.emptyElement(Token.token(JAXRX + \":\" + \"resource\"),\r\n              Token.token(\"name\"), l.get(0),\r\n              Token.token(\"documents\"), l.get(1),\r\n              Token.token(\"size\"), l.get(2));\r\n        }\r\n        xml.close();\r\n      }\r\n    };\r\n  }","id":41991,"modified_method":"@Override\r\n  public StreamingOutput get(final ResourcePath rp) {\r\n    if(rp.getDepth() != 0) return query(null, rp);\r\n\r\n    return new BXOutput(null) {\r\n      @Override\r\n      String code() throws IOException {\r\n        final XMLSerializer xml = new XMLSerializer(out,\r\n            new SerializerProp(params(rp)));\r\n\r\n        // retrieve list of databases\r\n        final Table table = new Table(exec(new List(), null));\r\n        for(final TokenList l : table.contents) {\r\n          xml.emptyElement(Token.token(JAXRX + \":\" + \"resource\"),\r\n              Token.token(\"name\"), l.get(0),\r\n              Token.token(\"documents\"), l.get(1),\r\n              Token.token(\"size\"), l.get(2));\r\n        }\r\n        xml.close();\r\n        return null;\r\n      }\r\n    };\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public StreamingOutput query(final String query, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      void code() {\r\n        // wrap start and counter around query expression\r\n        final String xq = query != null ? query : \".\";\r\n        // evaluate first result and number of results\r\n        final int s = num(rp, QueryParameter.START, 1);\r\n        final int m = num(rp, QueryParameter.COUNT, Integer.MAX_VALUE - s);\r\n\r\n        try {\r\n          cs.execute(new Set(Prop.SERIALIZER, params(path)));\r\n          cs.setOutputStream(out);\r\n\r\n          // create query instance\r\n          final ClientQuery cq = cs.query(xq);\r\n          final String var = path.getValue(QueryParameter.VAR);\r\n          if(var != null) {\r\n            final Scanner sc = new Scanner(var);\r\n            sc.useDelimiter(\"\\t\");\r\n            while(sc.hasNext()) {\r\n              final String v = sc.next();\r\n              final String[] sp = v.split(\":\", 2);\r\n              cq.bind(sp[0], sp.length == 1 ? \"\" : sp[1], \"\");\r\n            }\r\n          }\r\n          // loop through all results\r\n          int c = 0;\r\n          cq.init();\r\n          while(++c < s + m && cq.more()) if(c >= s) cq.next();\r\n          cq.close();\r\n        } catch(final BaseXException ex) {\r\n          throw new JaxRxException(400, ex.getMessage());\r\n        }\r\n      }\r\n    };\r\n  }","id":41992,"modified_method":"@Override\r\n  public StreamingOutput query(final String query, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      String code() {\r\n        // wrap start and counter around query expression\r\n        final String xq = query != null ? query : \".\";\r\n        // evaluate first result and number of results\r\n        final int s = num(rp, QueryParameter.START, 1);\r\n        final int m = num(rp, QueryParameter.COUNT, Integer.MAX_VALUE - s);\r\n\r\n        try {\r\n          cs.execute(new Set(Prop.SERIALIZER, params(path)));\r\n          cs.setOutputStream(out);\r\n\r\n          // create query instance\r\n          final ClientQuery cq = cs.query(xq);\r\n          final String var = path.getValue(QueryParameter.VAR);\r\n          if(var != null) {\r\n            final Scanner sc = new Scanner(var);\r\n            sc.useDelimiter(\"\\t\");\r\n            while(sc.hasNext()) {\r\n              final String v = sc.next();\r\n              final String[] sp = v.split(\":\", 2);\r\n              cq.bind(sp[0], sp.length == 1 ? \"\" : sp[1], \"\");\r\n            }\r\n          }\r\n          // loop through all results\r\n          int c = 0;\r\n          cq.init();\r\n          while(++c < s + m && cq.more()) if(c >= s) cq.next();\r\n          cq.close();\r\n          return null;\r\n        } catch(final BaseXException ex) {\r\n          throw new JaxRxException(400, ex.getMessage());\r\n        }\r\n      }\r\n    };\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public StreamingOutput run(final String file, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      void code() {\r\n        // get root directory for files\r\n        final String root = System.getProperty(\"org.basex.jaxrxpath\") + \"/\";\r\n        final IO io = IO.get(root + file);\r\n        exec(new Run(io.path()), out);\r\n      }\r\n    };\r\n  }","id":41993,"modified_method":"@Override\r\n  public StreamingOutput run(final String file, final ResourcePath rp) {\r\n    return new BXOutput(rp) {\r\n      @Override\r\n      String code() {\r\n        // get root directory for files\r\n        final String root = System.getProperty(\"org.basex.jaxrxpath\") + \"/\";\r\n        final IO io = IO.get(root + file);\r\n        exec(new Run(io.path()), out);\r\n        return cs.info();\r\n      }\r\n    };\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void delete(final ResourcePath rp) {\r\n    new BXCode() {\r\n      @Override\r\n      void code() {\r\n        try {\r\n          cs.execute(new DropDB(root(rp)));\r\n        } catch(final BaseXException ex) {\r\n          // return exception if process failed\r\n          throw new JaxRxException(404, ex.getMessage());\r\n        }\r\n      }\r\n    }.run();\r\n  }","id":41994,"modified_method":"@Override\r\n  public String delete(final ResourcePath rp) {\r\n    return new BXCode() {\r\n      @Override\r\n      String code() {\r\n        try {\r\n          if(rp.getDepth() == 1) {\r\n            cs.execute(new DropDB(db(rp)));\r\n          } else {\r\n            cs.execute(new Open(db(rp)));\r\n            cs.execute(new Delete(path(rp)));\r\n          }\r\n          return cs.info();\r\n        } catch(final BaseXException ex) {\r\n          // return exception if process failed\r\n          throw new JaxRxException(404, ex.getMessage());\r\n        }\r\n      }\r\n    }.run();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void add(final InputStream input, final ResourcePath rp) {\r\n    new BXCode() {\r\n      @Override\r\n      void code() throws IOException {\r\n        // open database\r\n        try {\r\n          cs.execute(new Open(root(rp)));\r\n        } catch(final BaseXException ex) {\r\n          throw new JaxRxException(404, ex.getMessage());\r\n        }\r\n\r\n        // add cached file to the database\r\n        final File file = cache(input);\r\n        try {\r\n          cs.execute(new Add(file.toString()));\r\n        } catch(final BaseXException ex) {\r\n          throw new JaxRxException(404, ex.getMessage());\r\n        } finally {\r\n          file.delete();\r\n        }\r\n      }\r\n    }.run();\r\n  }","id":41995,"modified_method":"@Override\r\n  public String add(final InputStream input, final ResourcePath rp) {\r\n    return new BXCode() {\r\n      @Override\r\n      String code() {\r\n        // open database\r\n        try {\r\n          cs.execute(new Open(db(rp)));\r\n        } catch(final BaseXException ex) {\r\n          throw new JaxRxException(404, ex.getMessage());\r\n        }\r\n        add(input, rp, cs);\r\n        return cs.info();\r\n      }\r\n    }.run();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void update(final InputStream input, final ResourcePath rp) {\r\n    new BXCode() {\r\n      @Override\r\n      void code() {\r\n        final String name = root(rp);\r\n        try {\r\n          cs.create(name, input);\r\n        } catch(final BaseXException ex) {\r\n          // return exception if process failed\r\n          throw new JaxRxException(400, ex.getMessage());\r\n        }\r\n      }\r\n    }.run();\r\n  }","id":41996,"modified_method":"@Override\r\n  public String update(final InputStream input, final ResourcePath rp) {\r\n    return new BXCode() {\r\n      @Override\r\n      String code() {\r\n        try {\r\n          final int d = rp.getDepth();\r\n          // create new database\r\n          if(d == 1) {\r\n            cs.create(db(rp), input);\r\n          } else {\r\n            // add document to database\r\n            cs.execute(new Open(db(rp)));\r\n            final StringBuilder target = new StringBuilder();\r\n            for(int i = 1; i < d; i++) {\r\n              target.append('/').append(rp.getResource(i));\r\n            }\r\n            cs.execute(new Delete(target.toString()));\r\n            add(input, rp, cs);\r\n          }\r\n          return cs.info();\r\n        } catch(final BaseXException ex) {\r\n          // return exception if process failed\r\n          throw new JaxRxException(400, ex.getMessage());\r\n        }\r\n      }\r\n    }.run();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void write(final OutputStream os) {\r\n    out = os;\r\n\r\n    if(path != null) {\r\n      // open database if a single resource was specified\r\n      try {\r\n        if(path.getDepth() != 0) cs.execute(new Open(root(path)));\r\n      } catch(final BaseXException ex) {\r\n        throw new JaxRxException(404, ex.getMessage());\r\n      }\r\n      try {\r\n        // set serialization parameters\r\n        cs.execute(new Set(Prop.SERIALIZER, params(path)));\r\n      } catch(final BaseXException ex) {\r\n        throw new JaxRxException(400, ex.getMessage());\r\n      }\r\n    }\r\n    run();\r\n  }","id":41997,"modified_method":"@Override\r\n  public void write(final OutputStream os) {\r\n    out = os;\r\n\r\n    if(path != null) {\r\n      try {\r\n        // open database if a resource path was specified\r\n        if(path.getDepth() != 0) cs.execute(new Open(path.getResourcePath()));\r\n      } catch(final BaseXException ex) {\r\n        throw new JaxRxException(404, ex.getMessage());\r\n      }\r\n      try {\r\n        // set serialization parameters\r\n        cs.execute(new Set(Prop.SERIALIZER, params(path)));\r\n      } catch(final BaseXException ex) {\r\n        throw new JaxRxException(400, ex.getMessage());\r\n      }\r\n    }\r\n    run();\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates a database.\r\n   * @param name name of database\r\n   * @param input xml input\r\n   * @throws IOException I/O exception\r\n   */\r\n  public void create(final String name, final InputStream input)\r\n      throws IOException {\r\n    // send 8 to mark start of query execution, and {Query}0 as query string\r\n    out.write(8);\r\n    send(name);\r\n    int l;\r\n    while((l = input.read()) != -1) out.write(l);\r\n    out.write(0);\r\n    info = receive();\r\n    if(!ok()) throw new IOException(info);\r\n  }","id":41998,"modified_method":"/**\r\n   * Creates a database.\r\n   * @param name name of database\r\n   * @param input xml input\r\n   * @throws IOException I/O exception\r\n   */\r\n  public void create(final String name, final InputStream input)\r\n      throws IOException {\r\n\r\n    out.write(8);\r\n    send(name);\r\n    send(input);\r\n  }","commit_id":"3293a7b691411fe51c9bea51e4248581a7696c45","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Runs the example code.\r\n   * @param args (ignored) command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    System.out.println(\"=== CollectionTest ===\");\r\n\r\n    // Create test database\r\n    System.out.println(\"\\n* Create test database.\");\r\n    final CreateDB cmd = new CreateDB(\"test\");\r\n    cmd.execute(CONTEXT);\r\n    System.out.print(cmd.info());\r\n\r\n    Performance perf = new Performance();\r\n\r\n    // Add documents\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new Add(\"<xml/>\", Integer.toString(i)).execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* \" + SIZE + \" documents added: \" + perf);\r\n\r\n    // Request specific documents\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new XQuery(\"collection('test/\" + i + \"')\").execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* Request specific documents: \" + perf);\r\n\r\n    // Close database\r\n    new Close().execute(CONTEXT);\r\n\r\n    // Request specific documents (open database by XQuery processor)\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new XQuery(\"collection('test/\" + i + \"')\").execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* Request specific documents (db closed): \" + perf);\r\n\r\n    new Open(\"test\").execute(CONTEXT);\r\n\r\n    // Loop through all documents\r\n    new XQuery(\"for $i in 0 to \" + (SIZE - 1) + \" \" +\r\n      \"return collection(concat('test/', $i))\").execute(CONTEXT);\r\n    System.out.println(\"\\n* Loop through documents: \" + perf);\r\n\r\n    // Close database\r\n    new Close().execute(CONTEXT);\r\n\r\n    // Loop through all documents (open database by XQuery processor)\r\n    new XQuery(\"for $i in 0 to \" + (SIZE - 1) + \" \" +\r\n      \"return collection(concat('test/', $i))\").execute(CONTEXT);\r\n    System.out.println(\"\\n* Loop through documents (db closed): \" + perf);\r\n\r\n    new DropDB(\"test\").execute(CONTEXT);\r\n  }","id":41999,"modified_method":"/**\r\n   * Runs the example code.\r\n   * @param args (ignored) command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    System.out.println(\"=== CollStressTest ===\");\r\n\r\n    // Create test database\r\n    System.out.println(\"\\n* Create test database.\");\r\n    final CreateDB cmd = new CreateDB(\"test\");\r\n    cmd.execute(CONTEXT);\r\n    System.out.print(cmd.info());\r\n\r\n    Performance perf = new Performance();\r\n\r\n    // Add documents\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new Add(\"<xml/>\", Integer.toString(i)).execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* \" + SIZE + \" documents added: \" + perf);\r\n\r\n    // Request specific documents\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new XQuery(\"collection('test/\" + i + \"')\").execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* Request specific documents: \" + perf);\r\n\r\n    // Close database\r\n    new Close().execute(CONTEXT);\r\n\r\n    // Request specific documents (open database by XQuery processor)\r\n    for(int i = 0; i < SIZE; i++) {\r\n      new XQuery(\"collection('test/\" + i + \"')\").execute(CONTEXT);\r\n    }\r\n    System.out.println(\"\\n* Request specific documents (db closed): \" + perf);\r\n\r\n    new Open(\"test\").execute(CONTEXT);\r\n\r\n    // Loop through all documents\r\n    new XQuery(\"for $i in 0 to \" + (SIZE - 1) + \" \" +\r\n      \"return collection(concat('test/', $i))\").execute(CONTEXT);\r\n    System.out.println(\"\\n* Loop through documents: \" + perf);\r\n\r\n    // Close database\r\n    new Close().execute(CONTEXT);\r\n\r\n    // Loop through all documents (open database by XQuery processor)\r\n    new XQuery(\"for $i in 0 to \" + (SIZE - 1) + \" \" +\r\n      \"return collection(concat('test/', $i))\").execute(CONTEXT);\r\n    System.out.println(\"\\n* Loop through documents (db closed): \" + perf);\r\n\r\n    new DropDB(\"test\").execute(CONTEXT);\r\n  }","commit_id":"ce98591b3b4d664783fa014cd42f89f9acb7e35e","url":"https://github.com/BaseXdb/basex"}]