[{"original_method":"/**\n    * Format entities for output based on the reference into a format,\n    * use the provided list or get the entities\n    * \n    * @param ref the entity reference for this, \n    * if this is a reference to a collection then this will be rendered as a collection of entities,\n    * if a reference to a single entity then only the matching one from the collection will be used\n    * @param format the format to use for the output data\n    * @param entities (optional) if this is null then the entities will be fetched\n    * @param output the outputstream to place the encoded data into\n    * @param view (optional) \n    */\n   public void internalOutputFormatter(EntityReference ref, String format, List<?> entities, OutputStream output, EntityView view) {\n      if (format == null) { format = Outputable.HTML; }\n      if (view == null) {\n         view = makeEntityView(ref, null, null);\n      }\n      // create a scrap view from the current view, this should be more efficient\n      EntityView workingView = makeEVfromEV(view);\n\n      // get the entities if not supplied\n      if (entities == null) {\n         entities = fetchEntityList(ref, new Search());\n      }\n\n      // get the encoder to use\n      EntityXStream encoder = getEncoderForFormat(format);\n\n      String encoded = null;\n      if (entities.isEmpty()) {\n         // nothing to do here but warn\n         log.warn(\"No entities to format (\"+format+\") and output for: \" + ref);\n      } else if (EntityView.VIEW_LIST.equals(view.getViewKey()) \n            || ref.getId() == null) {\n         // encoding a collection of entities\n         if (encoder != null) {\n            Class<?> entityClass = ReflectUtil.getClassFromCollection((Collection<?>)entities);\n            encoder.alias(ref.prefix, entityClass);\n            StringBuilder sb = new StringBuilder();\n            // make header\n            if (Formats.JSON.equals(format)) {\n               sb.append(\"{\\\"\"+ENTITY_PREFIX+\"\\\": \"+ref.getPrefix() + \", \\\"\" + ref.getPrefix() + COLLECTION + \"\\\": [\\n\");\n            } else { // assume XML\n               sb.append(\"<\" + ref.getPrefix() + COLLECTION + \" \" + ENTITY_PREFIX + \"=\\\"\" + ref.getPrefix() + \"\\\">\\n\");\n            }\n            // loop through and encode items\n            int encodedEntities = 0;\n            for (Object entity : entities) {\n               String encode = encodeEntity(ref, workingView, entity, encoder);\n               if (encode.length() > 3) {\n                  if (Formats.JSON.equals(format)) {\n                     if (encodedEntities > 0) {\n                        sb.append(\",\\n\");\n                     }\n                     // special JSON cleanup (strips off the {\"stuff\": ... })\n                     encode = encode.substring(encode.indexOf(':')+1, encode.length()-1);\n                  } else {\n                     if (encodedEntities > 0) {\n                        sb.append(\"\\n\");\n                     }\n                  }\n                  sb.append(encode);                     \n                  encodedEntities++;\n               }\n            }\n            // make footer\n            if (Formats.JSON.equals(format)) {\n               sb.append(\"\\n]}\");\n            } else { // assume XML\n               sb.append(\"\\n<\/\" + ref.getPrefix() + COLLECTION + \">\");\n            }\n            encoded = sb.toString();\n         } else {\n            // just dump the whole thing to a string\n            encoded = encodeEntity(ref, workingView, entities, null);\n         }\n      } else {\n         // encoding a single entity\n         Object toEncode = entities.get(0);\n         if (toEncode == null) {\n            throw new RuntimeException(\"Failed to encode data for entity (\" + ref.toString() + \"), entity object to encode could not be found\");\n         } else {\n            Class<?> encodeClass = toEncode.getClass();\n            if (encoder != null) {\n               encoder.alias(ref.getPrefix(), encodeClass); // add alias for the current entity prefix\n            }\n            encoded = encodeEntity(ref, workingView, toEncode, encoder);\n         }\n      }\n      // put the encoded data into the OS\n      try {\n         byte[] b = encoded.getBytes(UTF_8);\n         output.write(b);\n      } catch (UnsupportedEncodingException e) {\n         throw new RuntimeException(\"Failed to encode UTF-8: \" + ref.toString(), e);\n      } catch (IOException e) {\n         throw new RuntimeException(\"Failed to encode into output stream: \" + ref.toString(), e);\n      }\n   }","id":106000,"modified_method":"/**\n    * Format entities for output based on the reference into a format,\n    * use the provided list or get the entities\n    * \n    * @param ref the entity reference for this, \n    * if this is a reference to a collection then this will be rendered as a collection of entities,\n    * if a reference to a single entity then only the matching one from the collection will be used\n    * @param format the format to use for the output data\n    * @param entities (optional) if this is null then the entities will be fetched\n    * @param output the outputstream to place the encoded data into\n    * @param view (optional) \n    */\n   public void internalOutputFormatter(EntityReference ref, String format, List<?> entities, OutputStream output, EntityView view) {\n      if (format == null) { format = Outputable.HTML; }\n      if (view == null) {\n         view = makeEntityView(ref, null, null);\n      }\n      // create a scrap view from the current view, this should be more efficient\n      EntityView workingView = makeEVfromEV(view);\n\n      // get the entities if not supplied\n      if (entities == null) {\n         entities = fetchEntityList(ref, new Search());\n      }\n\n      // get the encoder to use\n      EntityXStream encoder = getEncoderForFormat(format, true);\n\n      String encoded = null;\n      if (entities.isEmpty()) {\n         // nothing to do here but warn\n         log.warn(\"No entities to format (\"+format+\") and output for: \" + ref);\n      } else if (EntityView.VIEW_LIST.equals(view.getViewKey()) \n            || ref.getId() == null) {\n         // encoding a collection of entities\n         if (encoder != null) {\n            Class<?> entityClass = ReflectUtil.getClassFromCollection((Collection<?>)entities);\n            encoder.alias(ref.prefix, entityClass);\n            StringBuilder sb = new StringBuilder();\n            // make header\n            if (Formats.JSON.equals(format)) {\n               sb.append(\"{\\\"\"+ENTITY_PREFIX+\"\\\": \"+ref.getPrefix() + \", \\\"\" + ref.getPrefix() + COLLECTION + \"\\\": [\\n\");\n            } else { // assume XML\n               sb.append(\"<\" + ref.getPrefix() + COLLECTION + \" \" + ENTITY_PREFIX + \"=\\\"\" + ref.getPrefix() + \"\\\">\\n\");\n            }\n            // loop through and encode items\n            int encodedEntities = 0;\n            for (Object entity : entities) {\n               String encode = encodeEntity(ref, workingView, entity, encoder);\n               if (encode.length() > 3) {\n                  if (Formats.JSON.equals(format)) {\n                     if (encodedEntities > 0) {\n                        sb.append(\",\\n\");\n                     }\n                     // special JSON cleanup (strips off the {\"stuff\": ... })\n                     encode = encode.substring(encode.indexOf(':')+1, encode.length()-1);\n                  } else {\n                     if (encodedEntities > 0) {\n                        sb.append(\"\\n\");\n                     }\n                  }\n                  sb.append(encode);                     \n                  encodedEntities++;\n               }\n            }\n            // make footer\n            if (Formats.JSON.equals(format)) {\n               sb.append(\"\\n]}\");\n            } else { // assume XML\n               sb.append(\"\\n<\/\" + ref.getPrefix() + COLLECTION + \">\");\n            }\n            encoded = sb.toString();\n         } else {\n            // just dump the whole thing to a string\n            encoded = encodeEntity(ref, workingView, entities, null);\n         }\n      } else {\n         // encoding a single entity\n         Object toEncode = entities.get(0);\n         if (toEncode == null) {\n            throw new RuntimeException(\"Failed to encode data for entity (\" + ref.toString() + \"), entity object to encode could not be found\");\n         } else {\n            Class<?> encodeClass = toEncode.getClass();\n            if (encoder != null) {\n               encoder.alias(ref.getPrefix(), encodeClass); // add alias for the current entity prefix\n            }\n            encoded = encodeEntity(ref, workingView, toEncode, encoder);\n         }\n      }\n      // put the encoded data into the OS\n      try {\n         byte[] b = encoded.getBytes(UTF_8);\n         output.write(b);\n      } catch (UnsupportedEncodingException e) {\n         throw new RuntimeException(\"Failed to encode UTF-8: \" + ref.toString(), e);\n      } catch (IOException e) {\n         throw new RuntimeException(\"Failed to encode into output stream: \" + ref.toString(), e);\n      }\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n    * @param format\n    * @return the appropriate encoder for the format\n    */\n   private EntityXStream getEncoderForFormat(String format) {\n      EntityXStream encoder = null;\n      if (Formats.JSON.equals(format)) {\n         if (! xstreams.containsKey(format)) {\n            xstreams.put( format, new EntityXStream(new JsonHierarchicalStreamDriver()) );\n         }\n         encoder = xstreams.get(format);\n      } else if (Formats.XML.equals(format)) {\n         if (! xstreams.containsKey(format)) {\n            xstreams.put( format, new EntityXStream(new XppDomDriver()) );\n         }\n         encoder = xstreams.get(format);\n      } else {\n         encoder = null; // do a toString dump\n      }\n      return encoder;\n   }","id":106001,"modified_method":"/**\n    * @param format\n    * @param output if true then get the encode for output, if false then for input\n    * @return the appropriate encoder for the format\n    */\n   private EntityXStream getEncoderForFormat(String format, boolean output) {\n      EntityXStream encoder = null;\n      if (Formats.JSON.equals(format)) {\n         if (output) {\n            if (! xstreams.containsKey(format)) {\n               xstreams.put( format, new EntityXStream(new JsonHierarchicalStreamDriver()) );\n            }\n         } else {\n            format += \"-IN\";\n            if (! xstreams.containsKey(format)) {\n               xstreams.put( format, new EntityXStream(new JettisonMappedXmlDriver()) );\n            }\n         }\n         encoder = xstreams.get(format);\n      } else if (Formats.XML.equals(format)) {\n         if (! xstreams.containsKey(format)) {\n            xstreams.put( format, new EntityXStream(new XppDomDriver()) );\n         }\n         encoder = xstreams.get(format);\n      } else if (Formats.TXT.equals(format)) {\n         // TODO Add in plaintext encoder/decoder\n      } else {\n         encoder = null; // do a toString dump\n      }\n      return encoder;\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n      // get the path info if not set\n      if (path == null) {\n         path = req.getPathInfo();\n      }\n\n      EntityView view;\n      try {\n         view = parseEntityURL(path);\n      } catch (IllegalArgumentException e) {\n         // indicates we could not parse the reference\n         throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n      }\n\n      if (view == null) {\n         // no provider for this entity prefix\n         throw new EntityException( \"No entity provider could be found to handle the prefix in this path: \" + path, \n               path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n      } else if (! entityExists(view.getEntityReference()) ) {\n         // reference parsing failure\n         String message = \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n            + view.getEntityReference().toString() + \") that does not exist\";\n         throw new EntityException( message, view.toString(), HttpServletResponse.SC_NOT_FOUND );\n      } else {\n         String prefix = view.getEntityReference().getPrefix();\n         // reference successfully parsed\n         res.setStatus(HttpServletResponse.SC_OK); // other things can switch this later on\n\n         // store the current request and response\n         ((RequestGetterImpl) requestGetter).setRequest(req);\n         ((RequestGetterImpl) requestGetter).setResponse(res);\n\n         // check for extensions\n         if (view.getExtension() == null) {\n            view.setExtension(Outputable.HTML); // update the view\n         }\n         req.setAttribute(\"extension\", view.getExtension());\n\n         // handle the before interceptor\n         RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n         if (interceptor != null) {\n            interceptor.before(view, req, res);\n         }\n\n         // check for provider handling of this request\n         RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n         if (handler != null) {\n            // provider is handling this request\n            handleClassLoaderAccess(handler, req, res, view);\n         } else {\n            // handle the request internally if possible\n\n            // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n            boolean output = false;\n            String method = req.getMethod() == null ? \"GET\" : req.getMethod().toUpperCase().trim();\n            if (\"GET\".equals(method)) {\n               output = true;\n            } else {\n               // identify the action based on the method type or \"_method\" attribute\n               if (\"DELETE\".equals(method)) {\n                  view.setViewKey(EntityView.VIEW_DELETE);\n               } else if (\"PUT\".equals(method)) {\n                  view.setViewKey(EntityView.VIEW_EDIT);\n               } else if (\"POST\".equals(method)) {\n                  String _method = req.getParameter(\"_method\");\n                  if (_method == null) {\n                     // this better be a create request\n                     view.setViewKey(EntityView.VIEW_NEW);\n                  } else {\n                     _method = _method.toUpperCase().trim();\n                     if (\"DELETE\".equals(_method)) {\n                        view.setViewKey(EntityView.VIEW_DELETE);\n                     } else if (\"PUT\".equals(_method)) {\n                        view.setViewKey(EntityView.VIEW_EDIT);\n                     } else {\n                        throw new EntityException(\"Unable to handle POST request with _method, unknown method (only PUT/DELETE allowed): \" + _method, \n                              view.toString(), HttpServletResponse.SC_BAD_REQUEST);                        \n                     }\n                  }\n               } else {\n                  throw new EntityException(\"Unable to handle request method, unknown method (only GET/POST/PUT/DELETE allowed): \" + method, \n                        view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n               }\n\n               // check that the request is valid (edit and delete require an entity id)\n               if ( (EntityView.VIEW_EDIT.equals(view.getViewKey()) || EntityView.VIEW_DELETE.equals(view.getViewKey()) )\n                     && view.getEntityReference().getId() == null) {\n                  throw new EntityException(\"Unable to handle entity (\"+prefix+\") edit or delete request without entity id, url=\" + view.getOriginalEntityUrl(), \n                        view.getEntityReference().toString(), HttpServletResponse.SC_BAD_REQUEST);\n               }\n            }\n\n            boolean handled = false;\n            if (output) {\n               // output request\n               try {\n                  Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                  if (outputable != null) {\n                     if ( ReflectUtil.contains(outputable.getHandledOutputFormats(), view.getExtension()) ) {\n                        // we are handling this type of format for this entity\n                        res.setCharacterEncoding(UTF_8);\n                        String encoding = null;\n                        if (Formats.XML.equals(view.getExtension())) {\n                           encoding = Formats.XML_MIME_TYPE;\n                        } else if (Formats.HTML.equals(view.getExtension())) {\n                           encoding = Formats.HTML_MIME_TYPE;\n                        } else if (Formats.JSON.equals(view.getExtension())) {\n                           encoding = Formats.JSON_MIME_TYPE;\n                        } else if (Formats.RSS.equals(view.getExtension())) {\n                           encoding = Formats.RSS_MIME_TYPE;                        \n                        } else if (Formats.ATOM.equals(view.getExtension())) {\n                           encoding = Formats.ATOM_MIME_TYPE;                        \n                        } else {\n                           encoding = Formats.TXT_MIME_TYPE;\n                        }\n                        res.setContentType(encoding);\n\n                        // get the entities to output\n                        Search search = makeSearchFromRequest(req);\n                        List<?> entities = fetchEntityList(view.getEntityReference(), search);\n                        OutputStream outputStream = null;\n                        try {\n                           outputStream = res.getOutputStream();\n                        } catch (IOException e) {\n                           throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                        }\n\n                        OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                        if (formattable == null) {\n                           // handle internally or fail\n                           internalOutputFormatter(view.getEntityReference(), view.getExtension(), entities, outputStream, view);\n                        } else {\n                           // use provider's formatter\n                           formattable.formatOutput(view.getEntityReference(), view.getExtension(), entities, outputStream);\n                        }\n                        res.setStatus(HttpServletResponse.SC_OK);\n                        handled = true;\n                     } else {\n                        // will not handle this format type\n                        throw new EntityException( \"Will not handle output request for format  \"+view.getExtension()+\" for this path (\" \n                              + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference().toString() + \")\", \n                              view.getEntityReference().toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                     }\n                  }\n               } catch (IllegalArgumentException e) {\n                  // translate IAE into EE\n                  throw new EntityException(\"IllegalArgumentException: Unable to handle output input request url (\"\n                        + view.getOriginalEntityUrl()+\"), \" + e.getMessage(),\n                        view.getEntityReference().toString(), HttpServletResponse.SC_BAD_REQUEST);                  \n               }\n            } else {\n               // input request\n               try {\n                  if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                     // delete request\n                     Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                     if (deleteable != null) {\n                        deleteable.deleteEntity(view.getEntityReference());\n                        res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                        handled = true;\n                     }\n                  } else {\n                     // save request\n                     Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                     if (inputable != null) {\n                        if ( ReflectUtil.contains(inputable.getHandledInputFormats(), view.getExtension()) ) {\n                           // we are handling this type of format for this entity\n                           Object entity = null;\n                           InputStream inputStream = null;\n                           try {\n                              inputStream = req.getInputStream();\n                           } catch (IOException e) {\n                              throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                           }\n\n                           InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                           if (translatable == null) {\n                              // use internal translators or fail\n                              entity = internalInputTranslator(view.getEntityReference(), \n                                       view.getExtension(), inputStream, req);\n                           } else {\n                              // use provider's translator\n                              entity = translatable.translateFormattedData(view.getEntityReference(), \n                                    view.getExtension(), inputStream);\n                           }\n\n                           if (entity == null) {\n                              throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\"), entity object was null\", \n                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                           } else {\n                              if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                 String createdId = inputable.createEntity(view.getEntityReference(), entity);\n                                 view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                 res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                 res.setStatus(HttpServletResponse.SC_CREATED);\n                              } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                 inputable.updateEntity(view.getEntityReference(), entity);\n                                 res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                              } else {\n                                 throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                 \t\t\"action was not understood: \" + view.getViewKey(), \n                                       view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                              }\n                              // return the location of this updated or created entity (without any extension)\n                              res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL(EntityView.VIEW_SHOW, null));\n                              res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString());\n                              handled = true;\n                           }\n                        } else {\n                           // will not handle this format type\n                           throw new EntityException( \"Will not handle input request for format  \"+view.getExtension()+\" for this path (\" \n                                 + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference().toString() + \")\", \n                                 view.getEntityReference().toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                        }\n                     }\n                  }\n               } catch (IllegalArgumentException e) {\n                  // translate IAE into EE\n                  throw new EntityException(\"IllegalArgumentException: Unable to handle entity input request url (\"\n                        + view.getOriginalEntityUrl()+\"), \" + e.getMessage(),\n                        view.getEntityReference().toString(), HttpServletResponse.SC_BAD_REQUEST);                  \n               }\n            }\n\n            if (! handled) {\n               // default handling, send to the access provider if there is one\n               handleAccessProvider(view, req, res);\n            }\n         }\n\n         // handle the after interceptor\n         if (interceptor != null) {\n            interceptor.after(view, req, res);\n         }\n      }\n\n      return view.toString();\n   }","id":106002,"modified_method":"public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n      // get the path info if not set\n      if (path == null) {\n         path = req.getPathInfo();\n      }\n\n      EntityView view;\n      try {\n         view = parseEntityURL(path);\n      } catch (IllegalArgumentException e) {\n         // indicates we could not parse the reference\n         throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n      }\n\n      if (view == null) {\n         // no provider for this entity prefix\n         throw new EntityException( \"No entity provider could be found to handle the prefix in this path: \" + path, \n               path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n      } else if (! entityExists(view.getEntityReference()) ) {\n         // reference parsing failure\n         throw new EntityException( \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n               + view.getEntityReference() + \") that does not exist\", \n               view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n      } else {\n         String prefix = view.getEntityReference().getPrefix();\n         // reference successfully parsed\n         res.setStatus(HttpServletResponse.SC_OK); // other things can switch this later on\n\n         // store the current request and response\n         ((RequestGetterImpl) requestGetter).setRequest(req);\n         ((RequestGetterImpl) requestGetter).setResponse(res);\n\n         // check for extensions\n         if (view.getExtension() == null) {\n            view.setExtension(Outputable.HTML); // update the view\n         }\n         req.setAttribute(\"extension\", view.getExtension());\n\n         // handle the before interceptor\n         RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n         if (interceptor != null) {\n            interceptor.before(view, req, res);\n         }\n\n         // check for provider handling of this request\n         RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n         if (handler != null) {\n            // provider is handling this request\n            handleClassLoaderAccess(handler, req, res, view);\n         } else {\n            // handle the request internally if possible\n\n            // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n            boolean output = false;\n            String method = req.getMethod() == null ? \"GET\" : req.getMethod().toUpperCase().trim();\n            if (\"GET\".equals(method)) {\n               output = true;\n            } else {\n               // identify the action based on the method type or \"_method\" attribute\n               if (\"DELETE\".equals(method)) {\n                  view.setViewKey(EntityView.VIEW_DELETE);\n               } else if (\"PUT\".equals(method)) {\n                  view.setViewKey(EntityView.VIEW_EDIT);\n               } else if (\"POST\".equals(method)) {\n                  String _method = req.getParameter(\"_method\");\n                  if (_method == null) {\n                     // this better be a create request\n                     view.setViewKey(EntityView.VIEW_NEW);\n                  } else {\n                     _method = _method.toUpperCase().trim();\n                     if (\"DELETE\".equals(_method)) {\n                        view.setViewKey(EntityView.VIEW_DELETE);\n                     } else if (\"PUT\".equals(_method)) {\n                        view.setViewKey(EntityView.VIEW_EDIT);\n                     } else {\n                        throw new EntityException(\"Unable to handle POST request with _method, unknown method (only PUT/DELETE allowed): \" + _method, \n                              view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);                        \n                     }\n                  }\n               } else {\n                  throw new EntityException(\"Unable to handle request method, unknown method (only GET/POST/PUT/DELETE allowed): \" + method, \n                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n               }\n\n               // check that the request is valid (edit and delete require an entity id)\n               if ( (EntityView.VIEW_EDIT.equals(view.getViewKey()) || EntityView.VIEW_DELETE.equals(view.getViewKey()) )\n                     && view.getEntityReference().getId() == null) {\n                  throw new EntityException(\"Unable to handle entity (\"+prefix+\") edit or delete request without entity id, url=\" \n                        + view.getOriginalEntityUrl(), \n                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n               }\n            }\n\n            boolean handled = false;\n            try {\n               if (output) {\n                  // output request\n                  Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                  if (outputable != null) {\n                     if ( ReflectUtil.contains(outputable.getHandledOutputFormats(), view.getExtension()) ) {\n                        // we are handling this type of format for this entity\n                        res.setCharacterEncoding(UTF_8);\n                        String encoding = null;\n                        if (Formats.XML.equals(view.getExtension())) {\n                           encoding = Formats.XML_MIME_TYPE;\n                        } else if (Formats.HTML.equals(view.getExtension())) {\n                           encoding = Formats.HTML_MIME_TYPE;\n                        } else if (Formats.JSON.equals(view.getExtension())) {\n                           encoding = Formats.JSON_MIME_TYPE;\n                        } else if (Formats.RSS.equals(view.getExtension())) {\n                           encoding = Formats.RSS_MIME_TYPE;                        \n                        } else if (Formats.ATOM.equals(view.getExtension())) {\n                           encoding = Formats.ATOM_MIME_TYPE;                        \n                        } else {\n                           encoding = Formats.TXT_MIME_TYPE;\n                        }\n                        res.setContentType(encoding);\n\n                        // get the entities to output\n                        Search search = makeSearchFromRequest(req);\n                        List<?> entities = fetchEntityList(view.getEntityReference(), search);\n                        OutputStream outputStream = null;\n                        try {\n                           outputStream = res.getOutputStream();\n                        } catch (IOException e) {\n                           throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                        }\n\n                        OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                        if (formattable == null) {\n                           // handle internally or fail\n                           internalOutputFormatter(view.getEntityReference(), view.getExtension(), entities, outputStream, view);\n                        } else {\n                           // use provider's formatter\n                           formattable.formatOutput(view.getEntityReference(), view.getExtension(), entities, outputStream);\n                        }\n                        res.setStatus(HttpServletResponse.SC_OK);\n                        handled = true;\n                     } else {\n                        // will not handle this format type\n                        throw new EntityException( \"Will not handle output request for format  \"+view.getExtension()+\" for this path (\" \n                              + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \")\", \n                              view.getEntityReference()+\"\", HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                     }\n                  }\n               } else {\n                  // input request\n                  if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                     // delete request\n                     Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                     if (deleteable != null) {\n                        deleteable.deleteEntity(view.getEntityReference());\n                        res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                        handled = true;\n                     }\n                  } else {\n                     // save request\n                     Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                     if (inputable != null) {\n                        if ( ReflectUtil.contains(inputable.getHandledInputFormats(), view.getExtension()) ) {\n                           // we are handling this type of format for this entity\n                           Object entity = null;\n                           InputStream inputStream = null;\n                           try {\n                              inputStream = req.getInputStream();\n                           } catch (IOException e) {\n                              throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                           }\n\n                           InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                           if (translatable == null) {\n                              // use internal translators or fail\n                              entity = internalInputTranslator(view.getEntityReference(), \n                                    view.getExtension(), inputStream, req);\n                           } else {\n                              // use provider's translator\n                              entity = translatable.translateFormattedData(view.getEntityReference(), \n                                    view.getExtension(), inputStream);\n                           }\n\n                           if (entity == null) {\n                              throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\"), entity object was null\", \n                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                           } else {\n                              if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                 String createdId = inputable.createEntity(view.getEntityReference(), entity);\n                                 view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                 res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                 res.setStatus(HttpServletResponse.SC_CREATED);\n                              } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                 inputable.updateEntity(view.getEntityReference(), entity);\n                                 res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                              } else {\n                                 throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                       \"action was not understood: \" + view.getViewKey(), \n                                       view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n                              }\n                              // return the location of this updated or created entity (without any extension)\n                              res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL(EntityView.VIEW_SHOW, null));\n                              res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString());\n                              handled = true;\n                           }\n                        } else {\n                           // will not handle this format type\n                           throw new EntityException( \"Will not handle input request for format  \"+view.getExtension()+\" for this path (\" \n                                 + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference().toString() + \")\", \n                                 view.getEntityReference()+\"\", HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                        }\n                     }\n                  }\n               }\n            } catch (IllegalArgumentException e) {\n               // translate IAE into EE - bad request\n               throw new EntityException(\"IllegalArgumentException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request url (\"\n                     + view.getOriginalEntityUrl()+\"), \" + e.getMessage(),\n                     view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);        \n            } catch (IllegalStateException e) {\n               // translate ISE into EE - internal server error\n               throw new EntityException(\"IllegalStateException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request url (\"\n                     + view.getOriginalEntityUrl()+\"), \" + e.getMessage(),\n                     view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            }\n\n            if (! handled) {\n               // default handling, send to the access provider if there is one\n               handleAccessProvider(view, req, res);\n            }\n         }\n\n         // handle the after interceptor\n         if (interceptor != null) {\n            interceptor.after(view, req, res);\n         }\n      }\n\n      return view.toString();\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n    * Handled the internal encoding of data into an entity object\n    * \n    * @param ref the entity reference\n    * @param format the format which the input is encoded in\n    * @param input the data being input\n    * @return the entity object based on the data\n    * @throws EntityException if there is a failure in translation\n    */\n   @SuppressWarnings(\"unchecked\")\n   public Object internalInputTranslator(EntityReference ref, String format, InputStream input, HttpServletRequest req) {\n      Object entity = null;\n\n      // get the encoder to use\n      EntityXStream encoder = getEncoderForFormat(format);\n\n      Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(ref.getPrefix(), Inputable.class);\n      if (inputable != null) {\n         // get a the current entity object or a sample\n         Object current = null;\n         if (ref.getId() == null) {\n            // get a sample\n            current = inputable.getSampleEntity();\n         } else {\n            // get the current entity\n            current = inputable.getEntity(ref);\n         }\n\n         if (encoder != null) {\n            // translate using the encoder\n            entity = encoder.fromXML(input, current);\n         } else {\n            // html req handled specially\n            if (req != null) {\n               Map<String, String[]> params = req.getParameterMap();\n               if (params != null && params.size() > 0) {\n                  entity = current;\n                  try {\n                     beanUtils.populate(entity, params);\n                  } catch (Exception e) {\n                     throw new IllegalArgumentException(\"Unable to populate bean for ref (\"+ref+\") from request: \" + e.getMessage(), e);\n                  }\n               } else {\n                  // no request params, bad request\n                  throw new EntityException(\"No request params for html input request (there must be at least one) for reference: \" + ref, \n                        ref.toString(), HttpServletResponse.SC_BAD_REQUEST);\n               }\n            }\n         }         \n      }\n\n      if (entity == null) {\n         throw new EntityException(\"Unable to encode entity from input for reference: \" + ref, ref.toString(), HttpServletResponse.SC_BAD_REQUEST);\n      }\n      return entity;\n   }","id":106003,"modified_method":"/**\n    * Handled the internal encoding of data into an entity object\n    * \n    * @param ref the entity reference\n    * @param format the format which the input is encoded in\n    * @param input the data being input\n    * @return the entity object based on the data\n    * @throws EntityException if there is a failure in translation\n    */\n   @SuppressWarnings(\"unchecked\")\n   public Object internalInputTranslator(EntityReference ref, String format, InputStream input, HttpServletRequest req) {\n      Object entity = null;\n\n      // get the encoder to use\n      EntityXStream encoder = getEncoderForFormat(format, false);\n\n      Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(ref.getPrefix(), Inputable.class);\n      if (inputable != null) {\n         // get a the current entity object or a sample\n         Object current = null;\n         if (ref.getId() == null) {\n            // get a sample\n            current = inputable.getSampleEntity();\n         } else {\n            // get the current entity\n            current = inputable.getEntity(ref);\n         }\n\n         if (current != null) {\n            if (Formats.HTML.equals(format) || format == null || \"\".equals(format)) {\n               // html req handled specially\n               if (req != null) {\n                  Map<String, String[]> params = req.getParameterMap();\n                  if (params != null && params.size() > 0) {\n                     entity = current;\n                     try {\n                        beanUtils.populate(entity, params);\n                     } catch (Exception e) {\n                        throw new IllegalArgumentException(\"Unable to populate bean for ref (\"+ref+\") from request: \" + e.getMessage(), e);\n                     }\n                  } else {\n                     // no request params, bad request\n                     throw new EntityException(\"No request params for html input request (there must be at least one) for reference: \" + ref, \n                           ref.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                  }\n               }\n            } else if (encoder != null) {\n               if (input == null) {\n                  // no request params, bad request\n                  throw new EntityException(\"No input for input translation (input cannot be null) for reference: \" + ref, \n                        ref.toString(), HttpServletResponse.SC_BAD_REQUEST);\n               } else {\n                  encoder.alias(ref.getPrefix(), current.getClass());\n                  // translate using the encoder\n                  entity = encoder.fromXML(input, current);\n               }\n            }\n         }\n      }\n\n      if (entity == null) {\n         throw new EntityException(\"Unable to encode entity from input for reference: \" + ref, ref.toString(), HttpServletResponse.SC_BAD_REQUEST);\n      }\n      return entity;\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n    * Test method for {@link org.sakaiproject.entitybroker.impl.EntityHandlerImpl#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String)}.\n    */\n   public void testHandleEntityAccess() {\n      MockHttpServletRequest req = null;\n      MockHttpServletResponse res = null;\n\n      // test valid entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF1);\n      res = new MockHttpServletResponse();\n\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n\n      // test invalid prefix\n      req = new MockHttpServletRequest(\"GET\", \"/fake/thing\");\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_NOT_IMPLEMENTED, e.responseCode);\n      }\n\n      // test invalid id\n      req = new MockHttpServletRequest(\"GET\", TestData.REF1_INVALID);\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(TestData.REF1_INVALID, e.entityReference);\n         assertEquals(HttpServletResponse.SC_NOT_FOUND, e.responseCode);\n      }\n\n      // test invalid path format\n      req = new MockHttpServletRequest(\"GET\", \"xxxxxxxxxxxxxxxx\");\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_BAD_REQUEST, e.responseCode);\n      }\n\n      // XML test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.XML);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String xml = res.getContentAsString();\n         assertNotNull(xml);\n         assertTrue(xml.length() > 20);\n         assertTrue(xml.contains(TestData.PREFIX4));\n         assertTrue(xml.contains(\"<id>4-one<\/id>\"));\n         assertTrue(xml.contains(EntityXStream.SAKAI_ENTITY));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // JSON test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.JSON);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String json = res.getContentAsString();\n         assertNotNull(json);\n         assertTrue(json.length() > 20);\n         assertTrue(json.contains(TestData.PREFIX4));\n         assertTrue(json.contains(\"\\\"id\\\": \\\"4-one\\\",\"));\n         assertTrue(json.contains(EntityXStream.SAKAI_ENTITY));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // HTML test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.HTML);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String html = res.getContentAsString();\n         assertNotNull(html);\n         assertTrue(html.length() > 20);\n         assertTrue(html.contains(TestData.PREFIX4));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // types that cannot handle the return requested\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".xxxx\");\n      res = new MockHttpServletResponse();\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_METHOD_NOT_ALLOWED, e.responseCode);\n      }\n\n      // test the REST and CRUD methods\n\n      // HTML testing\n\n      // test creating an entity\n      // create without data is invalid\n      req = new MockHttpServletRequest(\"POST\", TestData.SPACE6 + \"/new\");\n      res = new MockHttpServletResponse();\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_BAD_REQUEST, e.responseCode);\n      }\n\n      req = new MockHttpServletRequest(\"POST\", TestData.SPACE6 + \"/new\");\n      req.setParameter(\"stuff\", \"TEST\"); // now fill in the fields to create the entity in the request (html)\n      req.setParameter(\"number\", \"5\");\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_CREATED, res.getStatus());\n      assertNotNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_ID));\n      assertNotNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE));\n      assertNotNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_URL));\n      String entityId = (String) res.getHeader(EntityRequestHandler.HEADER_ENTITY_ID);\n      assertTrue( td.entityProvider6.myEntities.containsKey(entityId) );\n      MyEntity me = td.entityProvider6.myEntities.get(entityId);\n      assertNotNull(me);\n      assertEquals(\"TEST\", me.getStuff());\n      assertEquals(5, me.getNumber());\n\n      // test modifying an entity\n      // modify without data is invalid\n      req = new MockHttpServletRequest(\"PUT\", TestData.SPACE6 + \"/\" + entityId);\n      res = new MockHttpServletResponse();\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_BAD_REQUEST, e.responseCode);\n      }\n\n      req = new MockHttpServletRequest(\"PUT\", TestData.SPACE6 + \"/\" + entityId);\n      req.setParameter(\"stuff\", \"TEST-PUT\"); // now fill in the fields to create the entity in the request (html)\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_NO_CONTENT, res.getStatus());\n      assertNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_ID));\n      assertNotNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE));\n      assertNotNull(res.getHeader(EntityRequestHandler.HEADER_ENTITY_URL));\n      assertTrue( td.entityProvider6.myEntities.containsKey(entityId) );\n      me = td.entityProvider6.myEntities.get(entityId);\n      assertNotNull(me);\n      assertEquals(\"TEST-PUT\", me.getStuff());\n      assertEquals(5, me.getNumber());\n      \n\n      // test deleting an entity\n\n      // space delete is invalid\n      req = new MockHttpServletRequest(\"DELETE\", TestData.SPACE6);\n      res = new MockHttpServletResponse();\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_BAD_REQUEST, e.responseCode);\n      }\n\n      // entity delete is allowed\n      assertTrue( td.entityProvider6.myEntities.containsKey(TestData.IDS6[3]) );\n      req = new MockHttpServletRequest(\"DELETE\", TestData.REF6_4);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_NO_CONTENT, res.getStatus());\n      assertFalse( td.entityProvider6.myEntities.containsKey(TestData.IDS6[3]) );\n\n   }","id":106004,"modified_method":"/**\n    * Test method for {@link org.sakaiproject.entitybroker.impl.EntityHandlerImpl#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String)}.\n    */\n   public void testHandleEntityAccess() {\n      MockHttpServletRequest req = null;\n      MockHttpServletResponse res = null;\n\n      // test valid entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF1);\n      res = new MockHttpServletResponse();\n\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n\n      // test invalid prefix\n      req = new MockHttpServletRequest(\"GET\", \"/fake/thing\");\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_NOT_IMPLEMENTED, e.responseCode);\n      }\n\n      // test invalid id\n      req = new MockHttpServletRequest(\"GET\", TestData.REF1_INVALID);\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(TestData.REF1_INVALID, e.entityReference);\n         assertEquals(HttpServletResponse.SC_NOT_FOUND, e.responseCode);\n      }\n\n      // test invalid path format\n      req = new MockHttpServletRequest(\"GET\", \"xxxxxxxxxxxxxxxx\");\n      res = new MockHttpServletResponse();\n\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_BAD_REQUEST, e.responseCode);\n      }\n\n      // XML test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.XML);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String xml = res.getContentAsString();\n         assertNotNull(xml);\n         assertTrue(xml.length() > 20);\n         assertTrue(xml.contains(TestData.PREFIX4));\n         assertTrue(xml.contains(\"<id>4-one<\/id>\"));\n         assertTrue(xml.contains(EntityXStream.SAKAI_ENTITY));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // JSON test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.JSON);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String json = res.getContentAsString();\n         assertNotNull(json);\n         assertTrue(json.length() > 20);\n         assertTrue(json.contains(TestData.PREFIX4));\n         assertTrue(json.contains(\"\\\"id\\\": \\\"4-one\\\",\"));\n         assertTrue(json.contains(EntityXStream.SAKAI_ENTITY));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // HTML test valid resolveable entity\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".\" + Formats.HTML);\n      res = new MockHttpServletResponse();\n      entityHandler.handleEntityAccess(req, res, null);\n      assertEquals(HttpServletResponse.SC_OK, res.getStatus());\n      assertNotNull(res.getOutputStream());\n      try {\n         String html = res.getContentAsString();\n         assertNotNull(html);\n         assertTrue(html.length() > 20);\n         assertTrue(html.contains(TestData.PREFIX4));\n      } catch (UnsupportedEncodingException e) {\n         fail(\"failure trying to get string content\");\n      }\n\n      // types that cannot handle the return requested\n      req = new MockHttpServletRequest(\"GET\", TestData.REF4 + \".xxxx\");\n      res = new MockHttpServletResponse();\n      try {\n         entityHandler.handleEntityAccess(req, res, null);\n         fail(\"Should have thrown exception\");\n      } catch (EntityException e) {\n         assertNotNull(e.getMessage());\n         assertEquals(HttpServletResponse.SC_METHOD_NOT_ALLOWED, e.responseCode);\n      }\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n    * Expects {@link MyEntity} objects\n    * {@inheritDoc}\n    */\n   public String createEntity(EntityReference reference, Object entity) {\n      MyEntity me = (MyEntity) entity;\n      if (me.getStuff() == null) {\n         throw new IllegalArgumentException(\"stuff is not set, it is required\");\n      }\n      String newId = null;\n      int counter = 0;\n      while (newId == null) {\n         if (! myEntities.containsKey(\"my\"+counter)) {\n            newId = \"my\"+counter;\n         }\n      }\n      me.setId( newId );\n      myEntities.put(newId, me);\n      return newId;\n   }","id":106005,"modified_method":"/**\n    * Expects {@link MyEntity} objects\n    * {@inheritDoc}\n    */\n   public String createEntity(EntityReference reference, Object entity) {\n      MyEntity me = (MyEntity) entity;\n      if (me.getStuff() == null) {\n         throw new IllegalArgumentException(\"stuff is not set, it is required\");\n      }\n      String newId = null;\n      int counter = 0;\n      while (newId == null) {\n         String id = \"my\"+counter++;\n         if (! myEntities.containsKey(id)) {\n            newId = id;\n         }\n      }\n      me.setId( newId );\n      myEntities.put(newId, me);\n      return newId;\n   }","commit_id":"7cfe35c1c45f506ae5188e552b59470933384ad1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private NextTurnInfoControl createNextNextInfoControl() {\n\t\tfinal RoutingHelper routingHelper = routeLayer.getHelper();\n\t\tfinal NextTurnInfoControl nextTurnInfo = new NextTurnInfoControl(map, paintSmallText, paintSmallSubText, true) {\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tboolean visible = false;\n\t\t\t\tif (routeLayer != null && routingHelper.isRouterEnabled() && routingHelper.isFollowingMode()) {\n\t\t\t\t\tboolean uturnWhenPossible = routingHelper.makeUturnWhenPossible();\n\t\t\t\t\tint d;\n\t\t\t\t\tif(uturnWhenPossible) {\n\t\t\t\t\t\td = routingHelper.getDistanceToNextRouteDirection() ; \n\t\t\t\t\t} else {\n\t\t\t\t\t\td = routingHelper.getDistanceToNextNextRouteDirection();\n\t\t\t\t\t}\n\t\t\t\t\tif (d >= 0 && !showMiniMap) {\n\t\t\t\t\t\tvisible = true;\n\t\t\t\t\t\tRouteDirectionInfo next = uturnWhenPossible? routingHelper.getNextRouteDirectionInfo() : \n\t\t\t\t\t\t\troutingHelper.getNextNextRouteDirectionInfo();\n\t\t\t\t\t\tif (next == null) {\n\t\t\t\t\t\t\tif (turnType != null) {\n\t\t\t\t\t\t\t\tturnType = null;\n\t\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!Algoritms.objectEquals(turnType, next.getTurnType())) {\n\t\t\t\t\t\t\tturnType = next.getTurnType();\n\t\t\t\t\t\t\tTurnPathHelper.calcTurnPath(pathForTurn, turnType, pathTransform);\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (distChanged(d, nextTurnDirection)) {\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t\tnextTurnDirection = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint imminent = uturnWhenPossible? routingHelper.getNextTurnImminent() : routingHelper.getNextNextTurnImminent();\n\t\t\t\t\t\tif (turnImminent != imminent) {\n\t\t\t\t\t\t\tturnImminent = imminent;\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdateVisibility(visible);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tnextTurnInfo.setOnClickListener(new View.OnClickListener() {\n//\t\t\tint i = 0;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// uncomment to test turn info rendering\n//\t\t\t\tfinal int l = TurnType.predefinedTypes.length;\n//\t\t\t\tfinal int exits = 5;\n//\t\t\t\ti++;\n//\t\t\t\tif (i % (l + exits) >= l ) {\n//\t\t\t\t\tnextTurnInfo.turnType = TurnType.valueOf(\"EXIT\" + (i % (l + exits) - l + 1));\n//\t\t\t\t\tnextTurnInfo.exitOut = (i % (l + exits) - l + 1)+\"\";\n//\t\t\t\t\tfloat a = 180 - (i % (l + exits) - l + 1) * 50;\n//\t\t\t\t\tnextTurnInfo.turnType.setTurnAngle(a < 0 ? a + 360 : a);\n//\t\t\t\t} else {\n//\t\t\t\t\tnextTurnInfo.turnType = TurnType.valueOf(TurnType.predefinedTypes[i % (TurnType.predefinedTypes.length + exits)]);\n//\t\t\t\t\tnextTurnInfo.exitOut = \"\";\n//\t\t\t\t}\n//\t\t\t\tnextTurnInfo.turnImminent = (nextTurnInfo.turnImminent + 1) % 3;\n//\t\t\t\tnextTurnInfo.nextTurnDirection = 580;\n//\t\t\t\tTurnPathHelper.calcTurnPath(nextTurnInfo.pathForTurn, nextTurnInfo.turnType,nextTurnInfo.pathTransform);\n\t\t\t\tshowMiniMap = true;\n\t\t\t\tview.refreshMap();\n\t\t\t}\n\t\t});\n\t\t// initial state\n\t\tnextTurnInfo.setVisibility(View.GONE);\n\t\treturn nextTurnInfo;\n\t}","id":106006,"modified_method":"private NextTurnInfoControl createNextNextInfoControl() {\n\t\tfinal RoutingHelper routingHelper = routeLayer.getHelper();\n\t\tfinal NextTurnInfoControl nextTurnInfo = new NextTurnInfoControl(map, paintSmallText, paintSmallSubText, true) {\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tboolean visible = false;\n\t\t\t\tif (routeLayer != null && routingHelper.isRouterEnabled() && routingHelper.isFollowingMode()) {\n\t\t\t\t\tboolean uturnWhenPossible = routingHelper.makeUturnWhenPossible();\n\t\t\t\t\tint d;\n\t\t\t\t\tif(uturnWhenPossible) {\n\t\t\t\t\t\td = routingHelper.getDistanceToNextRouteDirection() ; \n\t\t\t\t\t} else {\n\t\t\t\t\t\td = routingHelper.getDistanceToNextNextRouteDirection();\n\t\t\t\t\t}\n\t\t\t\t\tif (d >= 0 && !showMiniMap) {\n\t\t\t\t\t\tvisible = true;\n\t\t\t\t\t\tRouteDirectionInfo next = uturnWhenPossible? routingHelper.getNextRouteDirectionInfo() : \n\t\t\t\t\t\t\troutingHelper.getNextNextRouteDirectionInfo();\n\t\t\t\t\t\tif (next == null) {\n\t\t\t\t\t\t\tif (turnType != null) {\n\t\t\t\t\t\t\t\tturnType = null;\n\t\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!Algoritms.objectEquals(turnType, next.getTurnType())) {\n\t\t\t\t\t\t\tturnType = next.getTurnType();\n\t\t\t\t\t\t\tTurnPathHelper.calcTurnPath(pathForTurn, turnType, pathTransform);\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (distChanged(d, nextTurnDirection)) {\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t\tnextTurnDirection = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint imminent = uturnWhenPossible? routingHelper.getNextTurnImminent() : routingHelper.getNextNextTurnImminent();\n\t\t\t\t\t\tif (turnImminent != imminent) {\n\t\t\t\t\t\t\tturnImminent = imminent;\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdateVisibility(visible);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tnextTurnInfo.setOnClickListener(new View.OnClickListener() {\n//\t\t\tint i = 0;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// uncomment to test turn info rendering\n//\t\t\t\tfinal int l = TurnType.predefinedTypes.length;\n//\t\t\t\tfinal int exits = 5;\n//\t\t\t\ti++;\n//\t\t\t\tif (i % (l + exits) >= l ) {\n//\t\t\t\t\tnextTurnInfo.turnType = TurnType.valueOf(\"EXIT\" + (i % (l + exits) - l + 1), true);\n//\t\t\t\t\tnextTurnInfo.exitOut = (i % (l + exits) - l + 1)+\"\";\n//\t\t\t\t\tfloat a = 180 - (i % (l + exits) - l + 1) * 50;\n//\t\t\t\t\tnextTurnInfo.turnType.setTurnAngle(a < 0 ? a + 360 : a);\n//\t\t\t\t} else {\n//\t\t\t\t\tnextTurnInfo.turnType = TurnType.valueOf(TurnType.predefinedTypes[i % (TurnType.predefinedTypes.length + exits)], true);\n//\t\t\t\t\tnextTurnInfo.exitOut = \"\";\n//\t\t\t\t}\n//\t\t\t\tnextTurnInfo.turnImminent = (nextTurnInfo.turnImminent + 1) % 3;\n//\t\t\t\tnextTurnInfo.nextTurnDirection = 580;\n//\t\t\t\tTurnPathHelper.calcTurnPath(nextTurnInfo.pathForTurn, nexsweepAngletTurnInfo.turnType,nextTurnInfo.pathTransform);\n\t\t\t\t\n//\t\t\t\tshowMiniMap = true;\n\t\t\t\tview.refreshMap();\n\t\t\t}\n\t\t});\n\t\t// initial state\n//\t\tnextTurnInfo.setVisibility(View.GONE);\n\t\treturn nextTurnInfo;\n\t}","commit_id":"c0e72be99b75740b282c888daeb13092c3c518ac","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void calcTurnPath(Path pathForTurn, TurnType turnType, Matrix transform) {\n\t\tif(turnType == null){\n\t\t\treturn;\n\t\t}\n\t\tpathForTurn.reset();\n\t\tint ha = 72;\n\t\tint wa = 72;\n\n\t\tint th = 12; // thickness\n\t\tpathForTurn.moveTo(wa / 2, ha - 1);\n\t\tfloat sarrowL = 22; // side of arrow ?\n\t\tfloat harrowL = (float) Math.sqrt(2) * sarrowL; // hypotenuse of arrow\n\t\tfloat spartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\tfloat hpartArrowL = (float) (harrowL - th) / 2;\n\n\t\tif (TurnType.C.equals(turnType.getValue())) {\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th / 2, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TR.equals(turnType.getValue())|| TurnType.TL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TR.equals(turnType.getValue())? 1 : -1;\n\t\t\tfloat quadShiftX = 18;\n\t\t\tfloat quadShiftY = 18;\n\t\t\tint wl = 10; // width\n\t\t\tint h = (int) (ha - quadShiftY - harrowL + hpartArrowL - 5);\n\t\t\tint sl = wl + th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * sl, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rLineTo(b * wl, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\tpathForTurn.rLineTo(b * harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b * harrowL / 2, -harrowL / 2);\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * wl, 0);\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.KL.equals(turnType.getValue()) || TurnType.KR.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.KR.equals(turnType.getValue())? 1 : -1;\n\t\t\tfloat quadShiftX = 14;\n\t\t\tfloat quadShiftY = 14;\n\t\t\tth = 10;\n\t\t\tspartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\t\thpartArrowL = (float) (harrowL - th) / 2;\n\t\t\tint h = 12;\n\t\t\tint lh = 15;\n\t\t\tint sl = th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * (sl + 10), 0);\n\t\t\tpathForTurn.rLineTo(0, -lh);\n\t\t\t// 1st arc\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, -quadShiftY);\n\t\t\t// center\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h );\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(0, quadShiftY - th, -b * (quadShiftX - th), quadShiftY- th);\n\t\t\t//1st arc\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th ), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, lh );\n\n\t\t} else if (TurnType.TSLR.equals(turnType.getValue()) || TurnType.TSLL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TSLR.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tint h = 24;\n\t\t\tint quadShiftY = 22;\n\t\t\tfloat quadShiftX = (float) (quadShiftY / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = (sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShifty = quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * 4, 0);\n\t\t\tpathForTurn.rLineTo(0, -h /* + partArrowL */);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY + quadShiftX /*- partArrowL*/, b * quadShiftX, -quadShiftY /*- partArrowL*/);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(0, -sarrowL); // center\n\t\t\tpathForTurn.rLineTo(-b * sarrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rQuadTo(b * nQuadShiftX, -nQuadShiftX, b * nQuadShiftX, nQuadShifty);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TSHR.equals(turnType.getValue()) || TurnType.TSHL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TSHR.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tint h = 28;\n\t\t\tfloat quadShiftX = 22;\n\t\t\tint sh = 10;\n\t\t\tfloat quadShiftY = -(float) (quadShiftX / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = -(sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShiftY = -quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * sh, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftX - quadShiftY), b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(b * sarrowL, 0); // center\n\t\t\tpathForTurn.rLineTo(0, -sarrowL);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rCubicTo(b * nQuadShiftX / 2, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if(TurnType.TU.equals(turnType.getValue()) || TurnType.TRU.equals(turnType.getValue())) {\n\t\t\tint h = 40;\n\t\t\t// right left\n\t\t\tint b = TurnType.TU.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tfloat quadShiftX = 10; // 13\n\t\t\tfloat quadShiftY = 10; // 13\n\t\t\tint sm = 10;\n\n\t\t\tpathForTurn.rMoveTo(b * 28, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftY+th), -b * (quadShiftX+th), -(quadShiftY+th));\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX+th), 0, -b * (quadShiftX+th), (quadShiftY+th));\n\t\t\tpathForTurn.rLineTo(0, sm);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, harrowL/2); // center\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, -harrowL/2);\n\t\t\tpathForTurn.rLineTo(-b  *hpartArrowL, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, -sm);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftX, b *quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (turnType != null && turnType.isRoundAbout()) {\n\t\t\tfloat t = turnType.getTurnAngle();\n\t\t\tif (t >= 170 && t < 220) {\n\t\t\t\tt = 220;\n\t\t\t} else if (t > 160 && t < 170) {\n\t\t\t\tt = 160;\n\t\t\t}\n\t\t\tfloat sweepAngle = (t - 360) - 180;\n\t\t\tif (sweepAngle < -360) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\t\n\t\t\tfloat r1 = ha / 3f - 1;\n\t\t\tfloat r2 = r1 - 9;\n\t\t\tfloat angleToRot = 0.3f;\n\t\t\tint cx = wa / 2 ;\n\t\t\tint cy = ha / 2 - 2;\n\t\t\tpathForTurn.moveTo(cx, ha - 1);\n\t\t\tpathForTurn.lineTo(cx, cy + r1);\n\t\t\tRectF r = new RectF(cx - r1, cy - r1, cx + r1, cy + r1);\n\t\t\t\n\t\t\tint out = turnType.getExitOut();\n\t\t\tif (out < 1) {\n\t\t\t\tout = 1;\n\t\t\t}\n\t\t\tfloat prev = 90;\n\t\t\tfloat init = 90;\n\t\t\tfloat step = sweepAngle / out;\n\t\t\tboolean leftSide = turnType.isLeftSide();\n\t\t\tfor (int i = 1; i <= out; i++) {\n\t\t\t\tfloat to = step * i;\n\t\t\t\tif (i == out) {\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - prev + init);\n\t\t\t\t} else {\n\t\t\t\t\tfloat tsRad = (float) ((to - step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tfloat tsRad2 = (float) ((to + step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - step / 6 - prev + init );\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad), cy - (r1 + 10) * FloatMath.cos(tsRad));\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad2), cy - (r1 + 10) * FloatMath.cos(tsRad2));\n\t\t\t\t\t// not necessary for next arcTo\n\t\t\t\t\t//pathForTurn.lineTo(cx + (r1 + 0) * FloatMath.sin(tsRad2), cy - (r1 + 0) * FloatMath.cos(tsRad2));\n\t\t\t\t\tprev = to + step / 6 + init;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfloat angleRad = (float) ((180 + sweepAngle) * Math.PI / 180f);\n\t\t\t\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad), cy - (r1 + 4) * FloatMath.cos(angleRad));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad + angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad + angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 14) * FloatMath.sin(angleRad - angleToRot/2), cy - (r1 + 12) * FloatMath.cos(angleRad - angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad - 3*angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad - 3*angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad - angleToRot), cy - (r1 + 4) * FloatMath.cos(angleRad - angleToRot));\n\t\t\tpathForTurn.lineTo(cx + r2 * FloatMath.sin(angleRad - angleToRot), cy - r2 * FloatMath.cos(angleRad - angleToRot));\n\t\t\t\n\t\t\tr.set(cx - r2, cy - r2, cx + r2, cy + r2);\n\t\t\tpathForTurn.arcTo(r, 360 + sweepAngle + 90, -sweepAngle);\n\t\t\tpathForTurn.lineTo(cx - 8, cy + r2);\n\t\t\tpathForTurn.lineTo(cx - 8, ha - 1);\n\t\t\tpathForTurn.close();\n\t\t}\n\t\tpathForTurn.close();\n\t\tif(transform != null){\n\t\t\tpathForTurn.transform(transform);\n\t\t}\n\t}","id":106007,"modified_method":"public static void calcTurnPath(Path pathForTurn, TurnType turnType, Matrix transform) {\n\t\tif(turnType == null){\n\t\t\treturn;\n\t\t}\n\t\tpathForTurn.reset();\n\t\tint ha = 72;\n\t\tint wa = 72;\n\n\t\tint th = 12; // thickness\n\t\tpathForTurn.moveTo(wa / 2, ha - 1);\n\t\tfloat sarrowL = 22; // side of arrow ?\n\t\tfloat harrowL = (float) Math.sqrt(2) * sarrowL; // hypotenuse of arrow\n\t\tfloat spartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\tfloat hpartArrowL = (float) (harrowL - th) / 2;\n\n\t\tif (TurnType.C.equals(turnType.getValue())) {\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th / 2, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TR.equals(turnType.getValue())|| TurnType.TL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TR.equals(turnType.getValue())? 1 : -1;\n\t\t\tfloat quadShiftX = 18;\n\t\t\tfloat quadShiftY = 18;\n\t\t\tint wl = 10; // width\n\t\t\tint h = (int) (ha - quadShiftY - harrowL + hpartArrowL - 5);\n\t\t\tint sl = wl + th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * sl, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rLineTo(b * wl, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\tpathForTurn.rLineTo(b * harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b * harrowL / 2, -harrowL / 2);\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * wl, 0);\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.KL.equals(turnType.getValue()) || TurnType.KR.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.KR.equals(turnType.getValue())? 1 : -1;\n\t\t\tfloat quadShiftX = 14;\n\t\t\tfloat quadShiftY = 14;\n\t\t\tth = 10;\n\t\t\tspartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\t\thpartArrowL = (float) (harrowL - th) / 2;\n\t\t\tint h = 12;\n\t\t\tint lh = 15;\n\t\t\tint sl = th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * (sl + 10), 0);\n\t\t\tpathForTurn.rLineTo(0, -lh);\n\t\t\t// 1st arc\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, -quadShiftY);\n\t\t\t// center\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h );\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(0, quadShiftY - th, -b * (quadShiftX - th), quadShiftY- th);\n\t\t\t//1st arc\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th ), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, lh );\n\n\t\t} else if (TurnType.TSLR.equals(turnType.getValue()) || TurnType.TSLL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TSLR.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tint h = 24;\n\t\t\tint quadShiftY = 22;\n\t\t\tfloat quadShiftX = (float) (quadShiftY / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = (sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShifty = quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * 4, 0);\n\t\t\tpathForTurn.rLineTo(0, -h /* + partArrowL */);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY + quadShiftX /*- partArrowL*/, b * quadShiftX, -quadShiftY /*- partArrowL*/);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(0, -sarrowL); // center\n\t\t\tpathForTurn.rLineTo(-b * sarrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rQuadTo(b * nQuadShiftX, -nQuadShiftX, b * nQuadShiftX, nQuadShifty);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TSHR.equals(turnType.getValue()) || TurnType.TSHL.equals(turnType.getValue())) {\n\t\t\tint b = TurnType.TSHR.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tint h = 28;\n\t\t\tfloat quadShiftX = 22;\n\t\t\tint sh = 10;\n\t\t\tfloat quadShiftY = -(float) (quadShiftX / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = -(sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShiftY = -quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * sh, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftX - quadShiftY), b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(b * sarrowL, 0); // center\n\t\t\tpathForTurn.rLineTo(0, -sarrowL);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rCubicTo(b * nQuadShiftX / 2, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if(TurnType.TU.equals(turnType.getValue()) || TurnType.TRU.equals(turnType.getValue())) {\n\t\t\tint h = 40;\n\t\t\t// right left\n\t\t\tint b = TurnType.TU.equals(turnType.getValue()) ? 1 : -1;\n\t\t\tfloat quadShiftX = 10; // 13\n\t\t\tfloat quadShiftY = 10; // 13\n\t\t\tint sm = 10;\n\n\t\t\tpathForTurn.rMoveTo(b * 28, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftY+th), -b * (quadShiftX+th), -(quadShiftY+th));\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX+th), 0, -b * (quadShiftX+th), (quadShiftY+th));\n\t\t\tpathForTurn.rLineTo(0, sm);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, harrowL/2); // center\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, -harrowL/2);\n\t\t\tpathForTurn.rLineTo(-b  *hpartArrowL, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, -sm);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftX, b *quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (turnType != null && turnType.isRoundAbout()) {\n\t\t\tfloat t = turnType.getTurnAngle();\n\t\t\tif (t >= 170 && t < 220) {\n\t\t\t\tt = 220;\n\t\t\t} else if (t > 160 && t < 170) {\n\t\t\t\tt = 160;\n\t\t\t}\n\t\t\tboolean leftSide = turnType.isLeftSide();\n\t\t\tfloat sweepAngle = (t - 360) - 180;\n\t\t\tif (sweepAngle < -360) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\tif(leftSide && sweepAngle < 0) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\t\n\t\t\tfloat r1 = ha / 3f - 1;\n\t\t\tfloat r2 = r1 - 9;\n\t\t\tfloat angleToRot = leftSide ? -0.3f : 0.3f;\n\t\t\tint cx = wa / 2 ;\n\t\t\tint cy = ha / 2 - 2;\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.moveTo(cx - 8, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.moveTo(cx, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx, cy + r1);\n\t\t\t}\n\t\t\tRectF r = new RectF(cx - r1, cy - r1, cx + r1, cy + r1);\n\t\t\t\n\t\t\tint out = turnType.getExitOut();\n\t\t\tif (out < 1) {\n\t\t\t\tout = 1;\n\t\t\t}\n\t\t\tfloat prev = 90;\n\t\t\tfloat init = 90;\n\t\t\t\n\t\t\tfloat step = sweepAngle / out;\n\t\t\tfor (int i = 1; i <= out; i++) {\n\t\t\t\tfloat to = step * i;\n\t\t\t\tif (i == out) {\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - prev + init);\n\t\t\t\t} else {\n\t\t\t\t\tfloat tsRad = (float) ((to - step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tfloat tsRad2 = (float) ((to + step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - step / 6 - prev + init );\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad), cy - (r1 + 10) * FloatMath.cos(tsRad));\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad2), cy - (r1 + 10) * FloatMath.cos(tsRad2));\n\t\t\t\t\t// not necessary for next arcTo\n\t\t\t\t\t//pathForTurn.lineTo(cx + (r1 + 0) * FloatMath.sin(tsRad2), cy - (r1 + 0) * FloatMath.cos(tsRad2));\n\t\t\t\t\tprev = to + step / 6 + init;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfloat angleRad = (float) ((180 + sweepAngle) * Math.PI / 180f);\n\t\t\t\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad), cy - (r1 + 4) * FloatMath.cos(angleRad));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad + angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad + angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 14) * FloatMath.sin(angleRad - angleToRot/2), cy - (r1 + 12) * FloatMath.cos(angleRad - angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad - 3*angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad - 3*angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad - angleToRot), cy - (r1 + 4) * FloatMath.cos(angleRad - angleToRot));\n\t\t\tpathForTurn.lineTo(cx + r2 * FloatMath.sin(angleRad - angleToRot), cy - r2 * FloatMath.cos(angleRad - angleToRot));\n\t\t\t\n\t\t\tr.set(cx - r2, cy - r2, cx + r2, cy + r2);\n\t\t\tpathForTurn.arcTo(r, 360 + sweepAngle + 90, -sweepAngle);\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.lineTo(cx, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx, ha - 1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx - 8, ha - 1);\n\t\t\t}\n\t\t\tpathForTurn.close();\n\t\t}\n\t\tpathForTurn.close();\n\t\tif(transform != null){\n\t\t\tpathForTurn.transform(transform);\n\t\t}\n\t}","commit_id":"c0e72be99b75740b282c888daeb13092c3c518ac","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Cell(Placeholder placeholder, boolean horizontalToolbars, PlaceInGrid placeInGrid) {\n      myPlaceInGrid = placeInGrid;\n      myPlaceholder = placeholder;\n      myTabs = new JBTabs(myActionManager, GridContentContainer.this);\n      myTabs.setSideComponentVertical(!horizontalToolbars);\n    }","id":106008,"modified_method":"public Cell(Placeholder placeholder, boolean horizontalToolbars, PlaceInGrid placeInGrid) {\n      myPlaceInGrid = placeInGrid;\n      myPlaceholder = placeholder;\n      myTabs = new JBTabs(myActionManager, GridContentContainer.this);\n      myTabs.setUiDecorator(new JBTabs.UiDecorator() {\n        public JBTabs.UiDecoration getDecoration() {\n          return new JBTabs.UiDecoration(null, new Insets(0, -1, 0, -1));\n        }\n      });\n      myTabs.setSideComponentVertical(!horizontalToolbars);\n      myTabs.setStealthTabMode(true);\n    }","commit_id":"ad2260f41fa194b277e0bcf46a23d344c2ac2fa5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n\n    final TabInfo selected = getSelectedInfo();\n    if (selected == null) return;\n\n\n    final JBTabs.TabLabel selectedLabel = myInfo2Label.get(selected);\n    if (selectedLabel == null) return;\n\n    Rectangle selectedTabBounds = selectedLabel.getBounds();\n\n\n    final GraphicsConfig config = new GraphicsConfig(g);\n    config.setAntialiasing(true);\n\n    Graphics2D g2d = (Graphics2D)g;\n    final GeneralPath path = new GeneralPath();\n    Insets insets = getLayoutInsets();\n    final int bottomY = (int)selectedTabBounds.getMaxY();\n    final int topY = selectedTabBounds.y;\n    int leftX = selectedTabBounds.x;\n    int rightX = selectedTabBounds.x + selectedTabBounds.width;\n    int arc = getArcSize();\n\n    path.moveTo(insets.left, bottomY);\n    path.lineTo(leftX, bottomY);\n    path.lineTo(leftX, topY + arc);\n    path.quadTo(leftX, topY, leftX + arc, topY);\n    path.lineTo(rightX - arc, topY);\n    path.quadTo(rightX, topY, rightX, topY + arc);\n    path.lineTo(rightX, bottomY - arc);\n    path.quadTo(rightX, bottomY, rightX + arc, bottomY);\n    path.lineTo(getWidth() - insets.right - 1, bottomY);\n    path.closePath();\n\n    final Color from;\n    final Color to;\n    final int alpha;\n    final boolean paintFocused = myFocused || myActivePopup != null;\n    if (paintFocused) {\n      from = UIUtil.getFocusedFillColor();\n      to = UIUtil.getFocusedFillColor();\n    }\n    else {\n      alpha = 150;\n      from = UIUtil.toAlpha(UIUtil.getPanelBackgound().brighter(), alpha);\n      to = UIUtil.toAlpha(UIUtil.getPanelBackgound(), alpha);\n    }\n\n    g2d.setPaint(new GradientPaint(selectedTabBounds.x, topY, from, selectedTabBounds.x, bottomY, to));\n    g2d.fill(path);\n    if (paintFocused) {\n      g2d.setColor(UIUtil.getFocusedBoundsColor());\n    }\n    else {\n      g2d.setColor(CaptionPanel.CNT_ACTIVE_COLOR.darker());\n    }\n    g2d.draw(path);\n\n    g2d.drawRect(insets.left, bottomY, getWidth() - insets.left - insets.right - 1, getHeight() - bottomY - insets.bottom - 1);\n\n    config.restore();\n  }","id":106009,"modified_method":"protected void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n\n    final TabInfo selected = getSelectedInfo();\n    if (selected == null) return;\n\n\n    final JBTabs.TabLabel selectedLabel = myInfo2Label.get(selected);\n    if (selectedLabel == null) return;\n\n    Rectangle selectedTabBounds = selectedLabel.getBounds();\n\n\n    final GraphicsConfig config = new GraphicsConfig(g);\n    config.setAntialiasing(true);\n\n    Graphics2D g2d = (Graphics2D)g;\n\n    int arc = getArcSize();\n\n    final GeneralPath path = new GeneralPath();\n    Insets insets = getLayoutInsets();\n    final int bottomY = (int)selectedTabBounds.getMaxY();\n    final int topY = selectedTabBounds.y;\n    int leftX = selectedTabBounds.x;\n\n    int rightX = selectedTabBounds.x + selectedTabBounds.width;\n\n    path.moveTo(insets.left, bottomY);\n    path.lineTo(leftX, bottomY);\n    path.lineTo(leftX, topY + arc);\n    path.quadTo(leftX, topY, leftX + arc, topY);\n\n    int lastX = getWidth() - insets.right - 1;\n\n    if (isStealthModeEffective()) {\n      path.lineTo(lastX - arc, topY);\n      path.quadTo(lastX, topY, lastX, topY + arc);\n      path.lineTo(lastX, bottomY);\n    } else {\n      path.lineTo(rightX - arc, topY);\n      path.quadTo(rightX, topY, rightX, topY + arc);\n      path.lineTo(rightX, bottomY - arc);\n      path.quadTo(rightX, bottomY, rightX + arc, bottomY);\n    }\n\n    path.lineTo(lastX, bottomY);\n    path.closePath();\n\n    final Color from;\n    final Color to;\n    final int alpha;\n    final boolean paintFocused = myFocused || myActivePopup != null;\n    if (paintFocused) {\n      from = UIUtil.getFocusedFillColor();\n      to = UIUtil.getFocusedFillColor();\n    }\n    else {\n      alpha = 150;\n      from = UIUtil.toAlpha(UIUtil.getPanelBackgound().brighter(), alpha);\n      to = UIUtil.toAlpha(UIUtil.getPanelBackgound(), alpha);\n    }\n\n    g2d.setPaint(new GradientPaint(selectedTabBounds.x, topY, from, selectedTabBounds.x, bottomY, to));\n    g2d.fill(path);\n    if (paintFocused) {\n      g2d.setColor(UIUtil.getFocusedBoundsColor());\n    }\n    else {\n      g2d.setColor(CaptionPanel.CNT_ACTIVE_COLOR.darker());\n    }\n    g2d.draw(path);\n\n    g2d.drawRect(insets.left, bottomY, getWidth() - insets.left - insets.right - 1, getHeight() - bottomY - insets.bottom - 1);\n\n    config.restore();\n  }","commit_id":"ad2260f41fa194b277e0bcf46a23d344c2ac2fa5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) {\n    System.out.println(\"JBTabs.main\");\n\n    IconLoader.activate();\n\n    final JFrame frame = new JFrame();\n    frame.getContentPane().setLayout(new BorderLayout());\n    final int[] count = new int[1];\n    final JBTabs tabs = new JBTabs(null, new Disposable() {\n      public void dispose() {\n      }\n    }) {\n      protected JComponent createToolbarComponent(final TabInfo tabInfo) {\n        final JLabel jLabel = new JLabel(\"X\" + (++count[0])) {\n          protected void paintComponent(final Graphics g) {\n            super.paintComponent(g);\n            System.out.println(tabInfo.getText());\n          }\n        };\n        jLabel.setBorder(new LineBorder(Color.red));\n        return jLabel;\n      }\n    };\n    frame.getContentPane().add(tabs, BorderLayout.CENTER);\n\n    JPanel south = new JPanel(new FlowLayout());\n\n    final JCheckBox f = new JCheckBox(\"Focused\");\n    f.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setFocused(f.isSelected());\n      }\n    });\n    south.add(f);\n\n\n    final JCheckBox v = new JCheckBox(\"Vertical\");\n    v.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setSideComponentVertical(v.isSelected());\n      }\n    });\n    south.add(v);\n\n    final JCheckBox row = new JCheckBox(\"Single row\", true);\n    row.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setSingleRow(row.isSelected());\n      }\n    });\n    south.add(row);\n\n    frame.getContentPane().add(south, BorderLayout.SOUTH);\n\n    tabs.addListener(new TabsListener() {\n      public void selectionChanged(final TabInfo oldSelection, final TabInfo newSelection) {\n        System.out.println(\"TabsWithActions.selectionChanged old=\" + oldSelection + \" new=\" + newSelection);\n      }\n    });\n\n    tabs.addTab(new TabInfo(new JTree())).setText(\"Tree1\").setActions(new DefaultActionGroup(), null)\n      .setIcon(IconLoader.getIcon(\"/debugger/frame.png\"));\n    tabs.addTab(new TabInfo(new JTree())).setText(\"Tree2\");\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 1\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 2\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 3\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 4\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 5\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 6\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 7\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 8\").setActions(new DefaultActionGroup(), null);\n    tabs.addTab(new TabInfo(new JTable())).setText(\"Table 9\").setActions(new DefaultActionGroup(), null);\n\n\n    tabs.setBorder(new EmptyBorder(6, 6, 20, 6));\n\n    frame.setBounds(200, 200, 300, 200);\n    frame.show();\n  }","id":106010,"modified_method":"public static void main(String[] args) {\n    System.out.println(\"JBTabs.main\");\n\n    IconLoader.activate();\n\n    final JFrame frame = new JFrame();\n    frame.getContentPane().setLayout(new BorderLayout());\n    final int[] count = new int[1];\n    final JBTabs tabs = new JBTabs(null, new Disposable() {\n      public void dispose() {\n      }\n    }) {\n      protected JComponent createToolbarComponent(final TabInfo tabInfo) {\n        final JLabel jLabel = new JLabel(\"X\" + (++count[0])) {\n          protected void paintComponent(final Graphics g) {\n            super.paintComponent(g);\n            System.out.println(tabInfo.getText());\n          }\n        };\n        jLabel.setBorder(new LineBorder(Color.red));\n        return jLabel;\n      }\n    };\n    frame.getContentPane().add(tabs, BorderLayout.CENTER);\n\n    JPanel south = new JPanel(new FlowLayout());\n\n    final JCheckBox f = new JCheckBox(\"Focused\");\n    f.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setFocused(f.isSelected());\n      }\n    });\n    south.add(f);\n\n\n    final JCheckBox v = new JCheckBox(\"Vertical\");\n    v.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setSideComponentVertical(v.isSelected());\n      }\n    });\n    south.add(v);\n\n    final JCheckBox row = new JCheckBox(\"Single row\", true);\n    row.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setSingleRow(row.isSelected());\n      }\n    });\n    south.add(row);\n\n    final JCheckBox stealth = new JCheckBox(\"Stealth tab\", tabs.isStealthTabMode());\n    stealth.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        tabs.setStealthTabMode(stealth.isSelected());\n      }\n    });\n    south.add(stealth);\n\n    frame.getContentPane().add(south, BorderLayout.SOUTH);\n\n    tabs.addListener(new TabsListener() {\n      public void selectionChanged(final TabInfo oldSelection, final TabInfo newSelection) {\n        System.out.println(\"TabsWithActions.selectionChanged old=\" + oldSelection + \" new=\" + newSelection);\n      }                                              \n    });\n\n    tabs.addTab(new TabInfo(new JTree())).setText(\"Tree1\").setActions(new DefaultActionGroup(), null)\n      .setIcon(IconLoader.getIcon(\"/debugger/frame.png\"));\n    //tabs.addTab(new TabInfo(new JTree())).setText(\"Tree2\");\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 1\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 2\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 3\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 4\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 5\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 6\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 7\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 8\").setActions(new DefaultActionGroup(), null);\n    //tabs.addTab(new TabInfo(new JTable())).setText(\"Table 9\").setActions(new DefaultActionGroup(), null);\n\n\n    tabs.setBorder(new EmptyBorder(6, 6, 20, 6));\n\n    tabs.setUiDecorator(new UiDecorator() {\n      public UiDecoration getDecoration() {\n        return new UiDecoration(null, new Insets(1, -1, 1, -1));\n      }\n    });\n\n\n    frame.setBounds(200, 200, 600, 200);\n    frame.show();\n  }","commit_id":"ad2260f41fa194b277e0bcf46a23d344c2ac2fa5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ItemListenerConfigReadOnly(ItemListenerConfig config) {\n        this.setImplementation(config.getImplementation());\n        this.setClassName(config.getClassName());\n        this.setIncludeValue(config.isIncludeValue());\n    }","id":106011,"modified_method":"public ItemListenerConfigReadOnly(ItemListenerConfig config) {\n        super.setImplementation(config.getImplementation());\n        super.setClassName(config.getClassName());\n        super.setIncludeValue(config.isIncludeValue());\n    }","commit_id":"7d35cf44a01832b04695dfc676760937da0eef25","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ListenerConfigReadOnly(ListenerConfig config) {\n        this.setClassName(config.getClassName());\n        this.setImplementation(config.getImplementation());\n    }","id":106012,"modified_method":"public ListenerConfigReadOnly(ListenerConfig config) {\n        super.setClassName(config.getClassName());\n        super.setImplementation(config.getImplementation());\n    }","commit_id":"7d35cf44a01832b04695dfc676760937da0eef25","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public QueueStoreConfig getQueueStoreConfig() {\n        return super.getQueueStoreConfig().getAsReadOnly();\n    }","id":106013,"modified_method":"public QueueStoreConfig getQueueStoreConfig() {\n        final QueueStoreConfig queueStoreConfig = super.getQueueStoreConfig();\n        if (queueStoreConfig == null ){\n            return null;\n        }\n        return queueStoreConfig.getAsReadOnly();\n    }","commit_id":"7d35cf44a01832b04695dfc676760937da0eef25","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public QueueStoreConfigReadOnly(QueueStoreConfig config) {\n        this.setClassName(config.getClassName());\n        this.setStoreImplementation(config.getStoreImplementation());\n        this.setFactoryClassName(config.getFactoryClassName());\n        this.setFactoryImplementation(config.getFactoryImplementation());\n        this.setProperties(config.getProperties());\n        this.setEnabled(config.isEnabled());\n    }","id":106014,"modified_method":"public QueueStoreConfigReadOnly(QueueStoreConfig config) {\n        super.setClassName(config.getClassName());\n        super.setStoreImplementation(config.getStoreImplementation());\n        super.setFactoryClassName(config.getFactoryClassName());\n        super.setFactoryImplementation(config.getFactoryImplementation());\n        super.setProperties(config.getProperties());\n        super.setEnabled(config.isEnabled());\n    }","commit_id":"7d35cf44a01832b04695dfc676760937da0eef25","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\r\n\tpublic void config(final OServer iServer, final OServerParameterConfiguration[] iParams) {\r\n\t\tfor (OServerParameterConfiguration param : iParams) {\r\n\t\t\tif (param.name.equalsIgnoreCase(\"enabled\")) {\r\n\t\t\t\tif (!Boolean.parseBoolean(param.value))\r\n\t\t\t\t\t// DISABLE IT\r\n\t\t\t\t\treturn;\r\n\t\t\t} else if (param.name.equalsIgnoreCase(\"delay\"))\r\n\t\t\t\tdelay = OIOUtils.getTimeAsMillisecs(param.value);\r\n\t\t\telse if (param.name.equalsIgnoreCase(\"target.directory\"))\r\n\t\t\t\ttargetDirectory = param.value;\r\n\t\t\telse if (param.name.equalsIgnoreCase(\"db.include\") && param.value.trim().length() > 0)\r\n\t\t\t\tfor (String db : param.value.split(\",\"))\r\n\t\t\t\t\tincludeDatabases.add(db);\r\n\t\t\telse if (param.name.equalsIgnoreCase(\"db.exclude\") && param.value.trim().length() > 0)\r\n\t\t\t\tfor (String db : param.value.split(\",\"))\r\n\t\t\t\t\texcludeDatabases.add(db);\r\n\t\t\telse if (param.name.equalsIgnoreCase(\"target.fileName\"))\r\n\t\t\t\ttargetFileName = param.value;\r\n\t\t}\r\n\r\n\t\tif (delay <= 0)\r\n\t\t\tthrow new OConfigurationException(\"Cannot find mandatory parameter 'delay'\");\r\n\t\tif (!targetDirectory.endsWith(\"/\"))\r\n\t\t\ttargetDirectory += \"/\";\r\n\r\n\t\tfinal File filePath = new File(targetDirectory);\r\n\t\tif (filePath.exists()) {\r\n\t\t\tif (!filePath.isDirectory())\r\n\t\t\t\tthrow new OConfigurationException(\"Parameter 'path' points to a file, not a directory\");\r\n\t\t} else\r\n\t\t\t// CREATE BACKUP FOLDER(S) IF ANY\r\n\t\t\tfilePath.mkdirs();\r\n\r\n\t\tOLogManager.instance().info(this, \"Automatic backup handler installed and active: delay=%dms, targetDirectory=%s\", delay,\r\n\t\t\t\ttargetDirectory);\r\n\r\n\t\tOrient.getTimer().schedule(new TimerTask() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tOLogManager.instance().info(this, \"[OAutomaticBackup] Scanning databases to backup...\");\r\n\r\n\t\t\t\tint ok = 0, errors = 0;\r\n\r\n\t\t\t\tfinal Map<String, String> databaseNames = OServerMain.server().getAvailableStorageNames();\r\n\t\t\t\tfor (final Entry<String, String> dbName : databaseNames.entrySet()) {\r\n\t\t\t\t\tboolean include;\r\n\r\n\t\t\t\t\tif (includeDatabases.size() > 0)\r\n\t\t\t\t\t\tinclude = includeDatabases.contains(dbName.getKey());\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinclude = true;\r\n\r\n\t\t\t\t\tif (excludeDatabases.contains(dbName.getKey()))\r\n\t\t\t\t\t\tinclude = false;\r\n\r\n\t\t\t\t\tif (include) {\r\n\t\t\t\t\t\tfinal String fileName = OVariableParser.resolveVariables(targetFileName, OSystemVariableResolver.VAR_BEGIN,\r\n\t\t\t\t\t\t\t\tOSystemVariableResolver.VAR_END, new OVariableParserListener() {\r\n\t\t\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\t\t\tpublic String resolve(final String iVariable) {\r\n\t\t\t\t\t\t\t\t\t\tif (iVariable.equalsIgnoreCase(VARIABLES.DBNAME.toString()))\r\n\t\t\t\t\t\t\t\t\t\t\treturn dbName.getKey();\r\n\t\t\t\t\t\t\t\t\t\telse if (iVariable.startsWith(VARIABLES.DATE.toString())) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn new SimpleDateFormat(iVariable.substring(VARIABLES.DATE.toString().length() + 1)).format(new Date());\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// NOT FOUND\r\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Variable '\" + iVariable + \"' wasn't found\");\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tfinal String exportFilePath = targetDirectory + fileName;\r\n\t\t\t\t\t\tfinal ODatabaseDocumentTx db = new ODatabaseDocumentTx(dbName.getValue());\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tdb.setProperty(ODatabase.OPTIONS.SECURITY.toString(), Boolean.FALSE);\r\n\t\t\t\t\t\t\tdb.open(\"admin\", \"aaa\");\r\n\r\n\t\t\t\t\t\t\tfinal long begin = System.currentTimeMillis();\r\n\r\n\t\t\t\t\t\t\tnew ODatabaseExport(db, exportFilePath, new OCommandOutputListener() {\r\n\t\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\t\tpublic void onMessage(final String iText) {\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}).exportDatabase();\r\n\r\n\t\t\t\t\t\t\tOLogManager.instance().info(\r\n\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\"[OAutomaticBackup] - Backup of database '\" + dbName.getValue() + \"' completed in \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ (System.currentTimeMillis() - begin) + \"ms\");\r\n\t\t\t\t\t\t\tok++;\r\n\r\n\t\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t\t\tOLogManager.instance().error(this,\r\n\t\t\t\t\t\t\t\t\t\"[OAutomaticBackup] - Error on exporting database '\" + dbName.getValue() + \"' to file: \" + exportFilePath, e);\r\n\t\t\t\t\t\t\terrors++;\r\n\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\tdb.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tOLogManager.instance().info(this, \"[OAutomaticBackup] Backup finished: %d ok, %d errors\", ok, errors);\r\n\t\t\t}\r\n\t\t}, delay, delay);\r\n\t}","id":106015,"modified_method":"@Override\r\n  public void config(final OServer iServer, final OServerParameterConfiguration[] iParams) {\r\n    for (OServerParameterConfiguration param : iParams) {\r\n      if (param.name.equalsIgnoreCase(\"enabled\")) {\r\n        if (!Boolean.parseBoolean(param.value))\r\n          // DISABLE IT\r\n          return;\r\n      } else if (param.name.equalsIgnoreCase(\"delay\"))\r\n        delay = OIOUtils.getTimeAsMillisecs(param.value);\r\n      else if (param.name.equalsIgnoreCase(\"firsttime\")) {\r\n        try {\r\n          firstTime = OIOUtils.getTodayWithTime(param.value);\r\n        } catch (ParseException e) {\r\n          throw new OConfigurationException(\"Parameter 'firstTime' has invalid format, expected: HH:mm:ss\", e);\r\n        }\r\n      } else if (param.name.equalsIgnoreCase(\"target.directory\"))\r\n        targetDirectory = param.value;\r\n      else if (param.name.equalsIgnoreCase(\"db.include\") && param.value.trim().length() > 0)\r\n        for (String db : param.value.split(\",\"))\r\n          includeDatabases.add(db);\r\n      else if (param.name.equalsIgnoreCase(\"db.exclude\") && param.value.trim().length() > 0)\r\n        for (String db : param.value.split(\",\"))\r\n          excludeDatabases.add(db);\r\n      else if (param.name.equalsIgnoreCase(\"target.fileName\"))\r\n        targetFileName = param.value;\r\n    }\r\n\r\n    if (delay <= 0)\r\n      throw new OConfigurationException(\"Cannot find mandatory parameter 'delay'\");\r\n    if (!targetDirectory.endsWith(\"/\"))\r\n      targetDirectory += \"/\";\r\n\r\n    final File filePath = new File(targetDirectory);\r\n    if (filePath.exists()) {\r\n      if (!filePath.isDirectory())\r\n        throw new OConfigurationException(\"Parameter 'path' points to a file, not a directory\");\r\n    } else\r\n      // CREATE BACKUP FOLDER(S) IF ANY\r\n      filePath.mkdirs();\r\n\r\n    OLogManager.instance().info(this,\r\n        \"Automatic backup handler installed and active: delay=%dms, firstTime=%s, targetDirectory=%s\", delay, firstTime,\r\n        targetDirectory);\r\n\r\n    final TimerTask timerTask = new TimerTask() {\r\n      @Override\r\n      public void run() {\r\n        OLogManager.instance().info(this, \"[OAutomaticBackup] Scanning databases to backup...\");\r\n\r\n        int ok = 0, errors = 0;\r\n\r\n        final Map<String, String> databaseNames = OServerMain.server().getAvailableStorageNames();\r\n        for (final Entry<String, String> dbName : databaseNames.entrySet()) {\r\n          boolean include;\r\n\r\n          if (includeDatabases.size() > 0)\r\n            include = includeDatabases.contains(dbName.getKey());\r\n          else\r\n            include = true;\r\n\r\n          if (excludeDatabases.contains(dbName.getKey()))\r\n            include = false;\r\n\r\n          if (include) {\r\n            final String fileName = OVariableParser.resolveVariables(targetFileName, OSystemVariableResolver.VAR_BEGIN,\r\n                OSystemVariableResolver.VAR_END, new OVariableParserListener() {\r\n                  @Override\r\n                  public String resolve(final String iVariable) {\r\n                    if (iVariable.equalsIgnoreCase(VARIABLES.DBNAME.toString()))\r\n                      return dbName.getKey();\r\n                    else if (iVariable.startsWith(VARIABLES.DATE.toString())) {\r\n                      return new SimpleDateFormat(iVariable.substring(VARIABLES.DATE.toString().length() + 1)).format(new Date());\r\n                    }\r\n\r\n                    // NOT FOUND\r\n                    throw new IllegalArgumentException(\"Variable '\" + iVariable + \"' wasn't found\");\r\n                  }\r\n                });\r\n\r\n            final String exportFilePath = targetDirectory + fileName;\r\n            final ODatabaseDocumentTx db = new ODatabaseDocumentTx(dbName.getValue());\r\n\r\n            try {\r\n              db.setProperty(ODatabase.OPTIONS.SECURITY.toString(), Boolean.FALSE);\r\n              db.open(\"admin\", \"aaa\");\r\n\r\n              final long begin = System.currentTimeMillis();\r\n\r\n              new ODatabaseExport(db, exportFilePath, new OCommandOutputListener() {\r\n                @Override\r\n                public void onMessage(final String iText) {\r\n\r\n                }\r\n              }).exportDatabase();\r\n\r\n              OLogManager.instance().info(\r\n                  this,\r\n                  \"[OAutomaticBackup] - Backup of database '\" + dbName.getValue() + \"' completed in \"\r\n                      + (System.currentTimeMillis() - begin) + \"ms\");\r\n              ok++;\r\n\r\n            } catch (IOException e) {\r\n              OLogManager.instance().error(this,\r\n                  \"[OAutomaticBackup] - Error on exporting database '\" + dbName.getValue() + \"' to file: \" + exportFilePath, e);\r\n              errors++;\r\n            } finally {\r\n              db.close();\r\n            }\r\n          }\r\n        }\r\n        OLogManager.instance().info(this, \"[OAutomaticBackup] Backup finished: %d ok, %d errors\", ok, errors);\r\n      }\r\n    };\r\n\r\n    if (firstTime == null)\r\n      Orient.getTimer().schedule(timerTask, delay, delay);\r\n    else\r\n      Orient.getTimer().schedule(timerTask, firstTime, delay);\r\n  }","commit_id":"139b1e7e6c67864c7e20758fffd034b18a4b1531","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void scheduleTask(TimerTask task, long delay, long period) {\r\n    engineLock.readLock().lock();\r\n    try {\r\n      if (active)\r\n        timer.schedule(task, delay, period);\r\n      else\r\n        OLogManager.instance().warn(this, \"OrientDB engine is down. Task will not be scheduled.\");\r\n    } finally {\r\n      engineLock.readLock().unlock();\r\n    }\r\n  }","id":106016,"modified_method":"public void scheduleTask(final TimerTask task, final long delay, final long period) {\r\n    engineLock.readLock().lock();\r\n    try {\r\n      if (active) {\r\n        if (period > 0)\r\n          timer.schedule(task, delay, period);\r\n        else\r\n          timer.schedule(task, delay);\r\n      } else\r\n        OLogManager.instance().warn(this, \"OrientDB engine is down. Task will not be scheduled.\");\r\n    } finally {\r\n      engineLock.readLock().unlock();\r\n    }\r\n  }","commit_id":"a2f1c9220aaa0be07af6ef9d27ba4a1df70aae15","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void scheduleTask(TimerTask task, Date firstTime, long period) {\r\n    engineLock.readLock().lock();\r\n    try {\r\n      if (active)\r\n        timer.schedule(task, firstTime, period);\r\n      else\r\n        OLogManager.instance().warn(this, \"OrientDB engine is down. Task will not be scheduled.\");\r\n    } finally {\r\n      engineLock.readLock().unlock();\r\n    }\r\n  }","id":106017,"modified_method":"public void scheduleTask(final TimerTask task, final Date firstTime, final long period) {\r\n    engineLock.readLock().lock();\r\n    try {\r\n      if (active)\r\n        if (period > 0)\r\n          timer.schedule(task, firstTime, period);\r\n        else\r\n          timer.schedule(task, firstTime);\r\n      else\r\n        OLogManager.instance().warn(this, \"OrientDB engine is down. Task will not be scheduled.\");\r\n    } finally {\r\n      engineLock.readLock().unlock();\r\n    }\r\n  }","commit_id":"a2f1c9220aaa0be07af6ef9d27ba4a1df70aae15","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void setValue(String key, String value) {\n\t\t_settings.setValue(key, value);\n\t}","id":106018,"modified_method":"public void setValue(String key, String value) {\n\t\tModifiableSettings modifiableSettings =\n\t\t\t_settings.getModifiableSettings();\n\n\t\tmodifiableSettings.setValue(key, value);\n\t}","commit_id":"470738711b5522c93f12274e331f9426410a5b6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setValues(String key, String[] values) {\n\t\t_settings.setValues(key, values);\n\t}","id":106019,"modified_method":"public void setValues(String key, String[] values) {\n\t\tModifiableSettings modifiableSettings =\n\t\t\t_settings.getModifiableSettings();\n\n\t\tmodifiableSettings.setValues(key, values);\n\t}","commit_id":"470738711b5522c93f12274e331f9426410a5b6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reset(String key) {\n\t\t_settings.reset(key);\n\t}","id":106020,"modified_method":"public void reset(String key) {\n\t\tModifiableSettings modifiableSettings =\n\t\t\t_settings.getModifiableSettings();\n\n\t\tmodifiableSettings.reset(key);\n\t}","commit_id":"470738711b5522c93f12274e331f9426410a5b6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public TypedSettingsTest() {\n\t\tLocalizationUtil localizationUtil = new LocalizationUtil();\n\n\t\tlocalizationUtil.setLocalization(new LocalizationImpl());\n\n\t\t_settings = mock(Settings.class);\n\n\t\twhen(\n\t\t\t_settings.getValue(_KEY, null)\n\t\t).thenReturn(\n\t\t\t\"valueDefault\"\n\t\t);\n\n\t\twhen(\n\t\t\t_settings.getValue(_KEY + \"_en_GB\", null)\n\t\t).thenReturn(\n\t\t\t\"value_en_GB\"\n\t\t);\n\n\t\twhen(\n\t\t\t_settings.getValue(_KEY + \"_en_US\", null)\n\t\t).thenReturn(\n\t\t\t\"value_en_US\"\n\t\t);\n\n\t\twhen(\n\t\t\t_settings.getValue(_KEY + \"_es_ES\", null)\n\t\t).thenReturn(\n\t\t\t\"value_es_ES\"\n\t\t);\n\n\t\t_typedSettings = new TypedSettings(\n\t\t\t_settings, _DEFAULT_LOCALE, _AVAILABLE_LOCALES);\n\t}","id":106021,"modified_method":"public TypedSettingsTest() {\n\t\tLocalizationUtil localizationUtil = new LocalizationUtil();\n\n\t\tlocalizationUtil.setLocalization(new LocalizationImpl());\n\n\t\tMemorySettings settings = new MemorySettings();\n\n\t\tsettings.setValue(_KEY, \"valueDefault\");\n\n\t\tsettings.setValue(_KEY + \"_en_GB\", \"value_en_GB\");\n\n\t\tsettings.setValue(_KEY + \"_en_US\", \"value_en_US\");\n\n\t\tsettings.setValue(_KEY + \"_es_ES\", \"value_es_ES\");\n\n\t\t_typedSettings = new TypedSettings(\n\t\t\tsettings, _DEFAULT_LOCALE, _AVAILABLE_LOCALES);\n\t}","commit_id":"470738711b5522c93f12274e331f9426410a5b6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String toString() {\n\t\treturn \"node()\";\n\t}","id":106022,"modified_method":"public String toString() {\n\t\treturn \"any-node-test[]\";\n\t}","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n        StringBuffer result = new StringBuffer();\n        result.append(\"atomize#(\");\n        result.append(expression.toString());\n        result.append(\")\");\n        return result.toString();\n    }","id":106023,"modified_method":"public String toString() {\n        StringBuffer result = new StringBuffer();\n        result.append(\"atomize[\");\n        result.append(expression.toString());\n        result.append(\"]\");\n        return result.toString();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1)\n            dumper.display(\"atomize#(\");\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(\")\");\n    }","id":106024,"modified_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1)\n            dumper.display(\"atomize[\");\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(\"]\");\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"cardinality-check#(\");        \n    \tresult.append(expression.toString());\n    \tresult.append(\")\");\n    \treturn result.toString();\n    }","id":106025,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n        result.append(\"dynamic-cardinality-check\"); \n        result.append(\"[\"); \n        result.append(Cardinality.getDescription(requiredCardinality));\n        result.append(\", \"); \n        result.append(expression.toString());\n        result.append(\"]\");\n    \treturn result.toString();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1) {\n\t        dumper.display(\"cardinality-check#(\");\n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n\t        dumper.display(')');\n    }","id":106026,"modified_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1) {            \n            dumper.display(\"dynamic-cardinality-check\"); \n            dumper.display(\"[\"); \n            dumper.display(Cardinality.getDescription(requiredCardinality));\n            dumper.display(\", \");             \n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n\t        dumper.display(\"]\");\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n\t\tStringBuffer result = new StringBuffer();\n\t\tresult.append(Type.getTypeName(test.nodeType));\n\t\tresult.append('(');\n\t\tresult.append(expression.toString());\n\t\tresult.append(')');\n\t\treturn result.toString();\n\t}","id":106027,"modified_method":"public String toString() {\n\t\tStringBuffer result = new StringBuffer();\n        result.append(\"dynamic-name-check\");   \n        result.append(\"[\"); \n        result.append(Type.getTypeName(test.nodeType));\n        result.append(\", \"); \n        result.append(expression.toString());\n        result.append(\"]\");\n\t\treturn result.toString();\n\t}","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n\t\tif(dumper.verbosity() > 1) {\n\t        dumper.display(Type.getTypeName(test.nodeType));\n\t        dumper.display('(');\n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(')');\n\t}","id":106028,"modified_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1) {            \n            dumper.display(\"dynamic-name-check\"); \n            dumper.display(\"[\"); \n            dumper.display(Type.getTypeName(test.nodeType));\n            dumper.display(\", \"); \n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(\"]\");\n\t}","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1) {\n\t        dumper.display(Type.getTypeName(requiredType));\n\t        dumper.display('(');\n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(')');\n    }","id":106029,"modified_method":"public void dump(ExpressionDumper dumper) {\n        if(dumper.verbosity() > 1) {            \n            dumper.display(\"dynamic-type-check\"); \n            dumper.display(\"[\"); \n            dumper.display(Type.getTypeName(requiredType));\n            dumper.display(\", \"); \n        }\n        expression.dump(dumper);\n        if(dumper.verbosity() > 1)\n            dumper.display(\"]\");\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n        StringBuffer result = new StringBuffer();\n        result.append(Type.getTypeName(requiredType));\n        result.append('(');        \n        result.append(expression.toString());\n        result.append(')');\n        return result.toString();\n    }","id":106030,"modified_method":"public String toString() {\n        StringBuffer result = new StringBuffer();\n        result.append(\"dynamic-type-check\");   \n        result.append(\"[\"); \n        result.append(Type.getTypeName(requiredType));\n        result.append(\", \"); \n        result.append(expression.toString());\n        result.append(\"]\");\n        return result.toString();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"for \");           \n        result.append(\"$\").append(varName);\n        if(positionalVariable != null)\n        \tresult.append(\" at \").append(positionalVariable);\n        if(sequenceType != null)\n        \tresult.append(\" as \").append(sequenceType);\n        result.append(\" in \");\n        result.append(inputSequence.toString());\n        result.append(\" \");\n        if(whereExpr != null) {\n        \tresult.append(\"where\");\n        \tresult.append(\" \");\n        \tresult.append(whereExpr.toString());\n        \tresult.append(\" \");\n        }\n        if(orderSpecs != null) {\n        \tresult.append(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                \tresult.append(\", \");\n                result.append(orderSpecs[i].toString());\n            }\n            result.append(\" \");\n        }\n        result.append(\"return\");\n        result.append(\" \");\n        result.append(returnExpr.toString());\n        return result.toString();\n    }","id":106031,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"for \");           \n        result.append(\"$\").append(varName);\n        if(positionalVariable != null)\n        \tresult.append(\" at \").append(positionalVariable);\n        if(sequenceType != null)\n        \tresult.append(\" as \").append(sequenceType);\n        result.append(\" in \");\n        result.append(inputSequence.toString());\n        result.append(\" \");\n        if(whereExpr != null) {\n        \tresult.append(\"where\");\n        \tresult.append(\" \");\n        \tresult.append(whereExpr.toString());\n        \tresult.append(\" \");\n        }\n        if(orderSpecs != null) {\n        \tresult.append(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                \tresult.append(\", \");\n                result.append(orderSpecs[i].toString());\n            }\n            result.append(\" \");\n        }\n        //TODO : QuantifiedExpr\n        if (returnExpr instanceof LetExpr)\n            result.append(\" \");  \n        else\n            result.append(\"return \");        \n        result.append(returnExpr.toString());\n        return result.toString();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"for \", getASTNode());\n        dumper.startIndent();\n        dumper.display(\"$\").display(varName);\n        if(positionalVariable != null)\n            dumper.display(\" at \").display(positionalVariable);\n        if(sequenceType != null)\n            dumper.display(\" as \").display(sequenceType);\n        dumper.display(\" in \");\n        inputSequence.dump(dumper);\n        dumper.endIndent().nl();\n        if(whereExpr != null) {\n            dumper.display(\"where\", whereExpr.getASTNode());\n            dumper.startIndent();\n            whereExpr.dump(dumper);\n            dumper.endIndent().nl();\n        }\n        if(orderSpecs != null) {\n            dumper.display(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                    dumper.display(\", \");\n                dumper.display(orderSpecs[i]);\n            }\n            dumper.nl();\n        }\n        dumper.display(\"return\", returnExpr.getASTNode());\n        dumper.startIndent();\n        returnExpr.dump(dumper);\n        dumper.endIndent().nl();\n    }","id":106032,"modified_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"for \", getASTNode());\n        dumper.startIndent();\n        dumper.display(\"$\").display(varName);\n        if(positionalVariable != null)\n            dumper.display(\" at \").display(positionalVariable);\n        if(sequenceType != null)\n            dumper.display(\" as \").display(sequenceType);\n        dumper.display(\" in \");\n        inputSequence.dump(dumper);\n        dumper.endIndent().nl();\n        if(whereExpr != null) {\n            dumper.display(\"where\", whereExpr.getASTNode());\n            dumper.startIndent();\n            whereExpr.dump(dumper);\n            dumper.endIndent().nl();\n        }\n        if(orderSpecs != null) {\n            dumper.display(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                    dumper.display(\", \");\n                dumper.display(orderSpecs[i]);\n            }\n            dumper.nl();\n        }\n        //TODO : QuantifiedExpr\n        if (returnExpr instanceof LetExpr)\n            dumper.display(\" \", returnExpr.getASTNode());\n        else\n            dumper.display(\"return\", returnExpr.getASTNode()); \n        dumper.startIndent();\n        returnExpr.dump(dumper);\n        dumper.endIndent().nl();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"let \", getASTNode());\n        dumper.startIndent();\n        dumper.display(\"$\").display(varName);\n        dumper.display(\" := \");\n        inputSequence.dump(dumper);\n        dumper.endIndent();\n        if(whereExpr != null) {\n            dumper.nl().display(\"where \");\n            whereExpr.dump(dumper);\n        }\n        if(orderSpecs != null) {\n            dumper.nl().display(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                    dumper.display(\", \");\n                //TODO : toString() or... dump ?\n                dumper.display(orderSpecs[i].toString());\n            }\n        }\n        dumper.nl().display(\"return \");\n        dumper.startIndent();\n        returnExpr.dump(dumper);\n        dumper.endIndent();\n    }","id":106033,"modified_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"let \", getASTNode());\n        dumper.startIndent();\n        dumper.display(\"$\").display(varName);\n        dumper.display(\" := \");\n        inputSequence.dump(dumper);\n        dumper.endIndent();\n        if(whereExpr != null) {\n            dumper.nl().display(\"where \");\n            whereExpr.dump(dumper);\n        }\n        if(orderSpecs != null) {\n            dumper.nl().display(\"order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                    dumper.display(\", \");\n                //TODO : toString() or... dump ?\n                dumper.display(orderSpecs[i].toString());\n            }\n        }\n        //TODO : QuantifiedExpr\n        if (returnExpr instanceof LetExpr)\n            dumper.display(\", \");\n        else\n            dumper.nl().display(\"return \"); \n        dumper.startIndent();\n        returnExpr.dump(dumper);\n        dumper.endIndent();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"let \");        \n    \tresult.append(\"$\").append(varName);\n    \tresult.append(\" := \");\n    \tresult.append(inputSequence.toString());        \n        if(whereExpr != null) {\n        \tresult.append(\" where \");\n        \tresult.append(whereExpr.toString());\n        }\n        if(orderSpecs != null) {\n        \tresult.append(\" order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                \tresult.append(\", \");\n                result.append(orderSpecs[i].toString());\n            }\n        }\n        result.append(\"return \");       \n        result.append(returnExpr.toString());\n        return result.toString();\n    }","id":106034,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"let \");        \n    \tresult.append(\"$\").append(varName);\n    \tresult.append(\" := \");\n    \tresult.append(inputSequence.toString());        \n        if(whereExpr != null) {\n        \tresult.append(\" where \");\n        \tresult.append(whereExpr.toString());\n        }\n        if(orderSpecs != null) {\n        \tresult.append(\" order by \");\n            for(int i = 0; i < orderSpecs.length; i++) {\n                if(i > 0)\n                \tresult.append(\", \");\n                result.append(orderSpecs[i].toString());\n            }\n        }\n        //TODO : QuantifiedExpr\n        if (returnExpr instanceof LetExpr)\n            result.append(\", \");\n        else\n            result.append(\"return \");       \n        result.append(returnExpr.toString());\n        return result.toString();\n    }","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n\t    if(nodeName.getLocalName() == null)\n\t        return nodeName.getPrefix() + \":*\";\n\t    else\n\t        return nodeName.toString();\n\t}","id":106035,"modified_method":"public String toString() {\n        StringBuffer result = new StringBuffer();\n        if(nodeName.getLocalName() == null)\n            result.append(nodeName.getPrefix() + \":*\");\n        else\n            result.append(nodeName.toString());            \n        return result.toString();\t    \n\t}","commit_id":"cf9fd691f97357313effadf6856453e18cd9ef42","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"attribute {\").append(qname);\n    \tresult.append(\"} {\");        \n        Object next;\n\t\tfor(Iterator i = contents.iterator(); i.hasNext(); ) {\n\t\t\tnext = i.next();\n\t\t\tif(next instanceof Expression)\n\t\t\t\tresult.append(((Expression)next).toString());\n\t\t\telse\n\t\t\t\tresult.append(next.toString());\n\t\t}      \n\t\tresult.append(\"}\");\n\t\treturn result.toString();\n    }","id":106036,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"attribute \");\n        //TODO : remove curly braces if Qname\n        result.append(\"{\"); \n        result.append(qname);\n        result.append(\"} \"); \n        result.append(\"{\");        \n        Object next;\n\t\tfor(Iterator i = contents.iterator(); i.hasNext(); ) {\n\t\t\tnext = i.next();\n\t\t\tif(next instanceof Expression)\n\t\t\t\tresult.append(((Expression)next).toString());\n\t\t\telse\n\t\t\t\tresult.append(next.toString());\n\t\t}      \n\t\tresult.append(\"} \");\n\t\treturn result.toString();\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"attribute {\").display(qname);\n        dumper.display(\"} {\");\n        dumper.startIndent();\n        Object next;\n\t\tfor(Iterator i = contents.iterator(); i.hasNext(); ) {\n\t\t\tnext = i.next();\n\t\t\tif(next instanceof Expression)\n\t\t\t\t((Expression)next).dump(dumper);\n\t\t\telse\n\t\t\t\tdumper.display(next);\n\t\t}\n        dumper.endIndent();\n        dumper.nl().display(\"}\");\n    }","id":106037,"modified_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"attribute \");\n        //TODO : remove curly braces if Qname\n        dumper.display(\"{\");\n        dumper.display(qname);\n        dumper.display(\"} \");\n        dumper.display(\"{\");\n        dumper.startIndent();\n        Object next;\n\t\tfor(Iterator i = contents.iterator(); i.hasNext(); ) {\n\t\t\tnext = i.next();\n\t\t\tif(next instanceof Expression)\n\t\t\t\t((Expression)next).dump(dumper);\n\t\t\telse\n\t\t\t\tdumper.display(next);\n\t\t}\n        dumper.endIndent();\n        dumper.nl().display(\"} \");\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"attribute {\");\n        qnameExpr.dump(dumper);\n        dumper.display(\"} {\");\n        dumper.startIndent();\n        valueExpr.dump(dumper);\n        dumper.endIndent();\n        dumper.nl().display(\"}\");\n    }","id":106038,"modified_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"attribute \");\n        //TODO : remove curly braces if Qname\n        dumper.display(\"{\");\n        qnameExpr.dump(dumper);\n        dumper.display(\"} \");\n        //TODO : handle empty value\n        dumper.display(\"{\");\n        dumper.startIndent();\n        valueExpr.dump(dumper);\n        dumper.endIndent();\n        dumper.nl().display(\"}\");\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"attribute {\");\n    \tresult.append(qnameExpr.toString());\n    \tresult.append(\"} {\");        \n    \tresult.append(valueExpr.toString());        \n    \tresult.append(\"} \");\n    \treturn result.toString();\n    }","id":106039,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"attribute \");\n        //TODO : remove curly braces if Qname\n        result.append(\"{\");  \n    \tresult.append(qnameExpr.toString());\n        result.append(\"} \");\n        //TODO : handle empty value\n        result.append(\"{\");        \n    \tresult.append(valueExpr.toString());        \n        result.append(\"} \");\n    \treturn result.toString();\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"processing-instruction {\");\n    \tresult.append(name.toString());\n    \tresult.append(\"} {\");        \n    \tresult.append(content.toString());\n    \tresult.append(\"}\");\n    \treturn result.toString();\n    }","id":106040,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"processing-instruction {\");\n    \tresult.append(name.toString());\n    \tresult.append(\"} {\");        \n    \tresult.append(content.toString());\n    \tresult.append(\"} \");\n    \treturn result.toString();\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"element {\");\n    \tresult.append(qnameExpr.toString());\n    \tresult.append(\"} {\");        \n        if(attributes != null) {\n\t\t\tAttributeConstructor attr;\n\t\t\tfor(int i = 0; i < attributes.length; i++) {\n\t\t\t    if(i > 0)\n\t\t\t    \tresult.append(\" \");\n\t\t\t\tattr = (AttributeConstructor)attributes[i];\n\t\t\t\tresult.append(attr.toString());\n\t\t\t}\n\t\t}\n        if(content != null) {\n            for(Iterator i = content.steps.iterator(); i.hasNext(); ) {\n                Expression expr = (Expression) i.next();\n                result.append(expr.toString());\n                if(i.hasNext())\n                \tresult.append(\" \");\n            }\n        }        \n        result.append(\"} \");\n        return result.toString();\n    }","id":106041,"modified_method":"public String toString() {\n    \tStringBuffer result = new StringBuffer();\n    \tresult.append(\"element \");\n        //TODO : remove curly braces if Qname\n        result.append(\"{\");    \n    \tresult.append(qnameExpr.toString());\n        result.append(\"} \");    \n        result.append(\"{\");        \n        if(attributes != null) {\n\t\t\tAttributeConstructor attr;\n\t\t\tfor(int i = 0; i < attributes.length; i++) {\n\t\t\t    if(i > 0)\n\t\t\t    \tresult.append(\" \");\n\t\t\t\tattr = (AttributeConstructor)attributes[i];\n\t\t\t\tresult.append(attr.toString());\n\t\t\t}\n\t\t}\n        if(content != null) {\n            for(Iterator i = content.steps.iterator(); i.hasNext(); ) {\n                Expression expr = (Expression) i.next();\n                result.append(expr.toString());\n                if(i.hasNext())\n                \tresult.append(\" \");\n            }\n        }        \n        result.append(\"} \");\n        return result.toString();\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"element {\");\n        qnameExpr.dump(dumper);\n        dumper.display(\"} {\");\n        dumper.startIndent();\n        if(attributes != null) {\n\t\t\tAttributeConstructor attr;\n\t\t\tfor(int i = 0; i < attributes.length; i++) {\n\t\t\t    if(i > 0)\n\t\t\t        dumper.nl();\n\t\t\t\tattr = (AttributeConstructor)attributes[i];\n\t\t\t\tattr.dump(dumper);\n\t\t\t}\n\t        dumper.endIndent();\n\t        dumper.startIndent();\n\t    }\n        if(content != null) {\n            for(Iterator i = content.steps.iterator(); i.hasNext(); ) {\n                Expression expr = (Expression) i.next();\n                expr.dump(dumper);\n                if(i.hasNext())\n                    dumper.nl();\n            }\n            dumper.endIndent().nl();\n        }        \n        dumper.display(\"}\");\n    }","id":106042,"modified_method":"public void dump(ExpressionDumper dumper) {\n        dumper.display(\"element \");\n        //TODO : remove curly braces if Qname\n        dumper.display(\"{\");\n        qnameExpr.dump(dumper);\n        dumper.display(\"} \");\n        dumper.display(\"{\");\n        dumper.startIndent();\n        if(attributes != null) {\n\t\t\tAttributeConstructor attr;\n\t\t\tfor(int i = 0; i < attributes.length; i++) {\n\t\t\t    if(i > 0)\n\t\t\t        dumper.nl();\n\t\t\t\tattr = (AttributeConstructor)attributes[i];\n\t\t\t\tattr.dump(dumper);\n\t\t\t}\n\t        dumper.endIndent();\n\t        dumper.startIndent();\n\t    }\n        if(content != null) {\n            for(Iterator i = content.steps.iterator(); i.hasNext(); ) {\n                Expression expr = (Expression) i.next();\n                expr.dump(dumper);\n                if(i.hasNext())\n                    dumper.nl();\n            }\n            dumper.endIndent().nl();\n        }        \n        dumper.display(\"} \");\n    }","commit_id":"abbc14741645f13d4df5da841dd93ab2c4c877bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString title = name;\n\t\t\tString description = StringPool.BLANK;\n\t\t\tString extraSettings = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\ttry {\n\t\t\t\tDLFileEntry entry = DLFileEntryServiceUtil.getFileEntryByTitle(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tif (isLocked(entry, webDavRequest.getLockUuid())) {\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tname = entry.getName();\n\t\t\t\tdescription = entry.getDescription();\n\t\t\t\textraSettings = entry.getExtraSettings();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tDLFileEntry.class.getName(), entry.getFileEntryId());\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tDLFileEntryServiceUtil.updateFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, parentFolderId, name, title, title,\n\t\t\t\t\tdescription, extraSettings,\n\t\t\t\t\tFileUtil.getBytes(request.getInputStream()),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\tfile = FileUtil.createTempFile(FileUtil.getExtension(name));\n\n\t\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\t\tDLFileEntryServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\t\textraSettings, file, serviceContext);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","id":106043,"modified_method":"public int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString title = name;\n\t\t\tString description = StringPool.BLANK;\n\t\t\tString extraSettings = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\ttry {\n\t\t\t\tDLFileEntry entry = DLFileEntryServiceUtil.getFileEntryByTitle(\n\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tif (isLocked(entry, webDavRequest.getLockUuid())) {\n\t\t\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t\t\t}\n\n\t\t\t\tname = entry.getName();\n\t\t\t\tdescription = entry.getDescription();\n\t\t\t\textraSettings = entry.getExtraSettings();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tDLFileEntry.class.getName(), entry.getFileEntryId());\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tDLFileEntryServiceUtil.updateFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, parentFolderId, name, title, title,\n\t\t\t\t\tdescription, extraSettings,\n\t\t\t\t\tFileUtil.getBytes(request.getInputStream()),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\tfile = FileUtil.createTempFile(FileUtil.getExtension(name));\n\n\t\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\t\tDLFileEntryServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\t\textraSettings, file, serviceContext);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"de28c9572787904663ce6a5b3d2bcb3ac968323d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int copyCollectionResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite, long depth)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = DLFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tDLFolder folder = (DLFolder)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = folder.getDescription();\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, parentFolderId, name,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (depth == 0) {\n\t\t\t\tDLFolderServiceUtil.addFolder(\n\t\t\t\t\tgroupId, parentFolderId, name, description, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDLFolderServiceUtil.copyFolder(\n\t\t\t\t\tgroupId, folder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tdescription, serviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":106044,"modified_method":"public int copyCollectionResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite, long depth)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = DLFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tDLFolder folder = (DLFolder)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = folder.getDescription();\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, parentFolderId, name,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (depth == 0) {\n\t\t\t\tDLFolderServiceUtil.addFolder(\n\t\t\t\t\tgroupId, parentFolderId, name, description, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDLFolderServiceUtil.copyFolder(\n\t\t\t\t\tgroupId, folder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tdescription, serviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"de28c9572787904663ce6a5b3d2bcb3ac968323d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int copySimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = DLFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tDLFileEntry fileEntry = (DLFileEntry)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tlong userId = webDavRequest.getUserId();\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString title = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = fileEntry.getDescription();\n\t\t\tString extraSettings = fileEntry.getExtraSettings();\n\n\t\t\tfile = FileUtil.createTempFile(\n\t\t\t\tFileUtil.getExtension(fileEntry.getName()));\n\n\t\t\tInputStream is = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\t\tfileEntry.getCompanyId(), userId, fileEntry.getGroupId(),\n\t\t\t\tfileEntry.getFolderId(), fileEntry.getName());\n\n\t\t\tFileUtil.write(file, is);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, parentFolderId, title,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDLFileEntryServiceUtil.addFileEntry(\n\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\textraSettings, file, serviceContext);\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (LockException le) {\n\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","id":106045,"modified_method":"public int copySimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = DLFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tDLFileEntry fileEntry = (DLFileEntry)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tlong userId = webDavRequest.getUserId();\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString title = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = fileEntry.getDescription();\n\t\t\tString extraSettings = fileEntry.getExtraSettings();\n\n\t\t\tfile = FileUtil.createTempFile(\n\t\t\t\tFileUtil.getExtension(fileEntry.getName()));\n\n\t\t\tInputStream is = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\t\tfileEntry.getCompanyId(), userId, fileEntry.getGroupId(),\n\t\t\t\tfileEntry.getFolderId(), fileEntry.getName());\n\n\t\t\tFileUtil.write(file, is);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(\n\t\t\t\t\t\tgroupId, parentFolderId, title,\n\t\t\t\t\t\twebDavRequest.getLockUuid())) {\n\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDLFileEntryServiceUtil.addFileEntry(\n\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\textraSettings, file, serviceContext);\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (LockException le) {\n\t\t\treturn WebDAVUtil.SC_LOCKED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"de28c9572787904663ce6a5b3d2bcb3ac968323d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Status lockResource(\n\t\t\tWebDAVRequest webDavRequest, String owner, long timeout)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\tLock lock = null;\n\t\tint status = HttpServletResponse.SC_OK;\n\n\t\ttry {\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_CREATED;\n\n\t\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\n\t\t\t\tString title = name;\n\t\t\t\tString description = StringPool.BLANK;\n\t\t\t\tString extraSettings = StringPool.BLANK;\n\n\t\t\t\tFile file = FileUtil.createTempFile(\n\t\t\t\t\tFileUtil.getExtension(name));\n\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\t\tDLFileEntry fileEntry = DLFileEntryServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\t\textraSettings, file, serviceContext);\n\n\t\t\t\tresource = toResource(webDavRequest, fileEntry, false);\n\t\t\t}\n\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tDLFileEntry fileEntry = (DLFileEntry)resource.getModel();\n\n\t\t\t\tlock = DLFileEntryServiceUtil.lockFileEntry(\n\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\tfileEntry.getName(), owner, timeout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean inheritable = false;\n\n\t\t\t\tlong depth = WebDAVUtil.getDepth(\n\t\t\t\t\twebDavRequest.getHttpServletRequest());\n\n\t\t\t\tif (depth != 0) {\n\t\t\t\t\tinheritable = true;\n\t\t\t\t}\n\n\t\t\t\tDLFolder folder = (DLFolder)resource.getModel();\n\n\t\t\t\tlock = DLFolderServiceUtil.lockFolder(\n\t\t\t\t\tfolder.getFolderId(), owner, inheritable, timeout);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\n\t\t\t// DuplicateLock is 423 not 501\n\n\t\t\tif (!(e instanceof DuplicateLockException)) {\n\t\t\t\tthrow new WebDAVException(e);\n\t\t\t}\n\n\t\t\tstatus = WebDAVUtil.SC_LOCKED;\n\t\t}\n\n\t\treturn new Status(lock, status);\n\t}","id":106046,"modified_method":"public Status lockResource(\n\t\t\tWebDAVRequest webDavRequest, String owner, long timeout)\n\t\tthrows WebDAVException {\n\n\t\tResource resource = getResource(webDavRequest);\n\n\t\tLock lock = null;\n\t\tint status = HttpServletResponse.SC_OK;\n\n\t\ttry {\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_CREATED;\n\n\t\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\n\t\t\t\tString title = name;\n\t\t\t\tString description = StringPool.BLANK;\n\t\t\t\tString extraSettings = StringPool.BLANK;\n\n\t\t\t\tFile file = FileUtil.createTempFile(\n\t\t\t\t\tFileUtil.getExtension(name));\n\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\t\tDLFileEntry fileEntry = DLFileEntryServiceUtil.addFileEntry(\n\t\t\t\t\tgroupId, parentFolderId, name, title, description,\n\t\t\t\t\textraSettings, file, serviceContext);\n\n\t\t\t\tresource = toResource(webDavRequest, fileEntry, false);\n\t\t\t}\n\n\t\t\tif (resource instanceof DLFileEntryResourceImpl) {\n\t\t\t\tDLFileEntry fileEntry = (DLFileEntry)resource.getModel();\n\n\t\t\t\tlock = DLFileEntryServiceUtil.lockFileEntry(\n\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\tfileEntry.getName(), owner, timeout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean inheritable = false;\n\n\t\t\t\tlong depth = WebDAVUtil.getDepth(\n\t\t\t\t\twebDavRequest.getHttpServletRequest());\n\n\t\t\t\tif (depth != 0) {\n\t\t\t\t\tinheritable = true;\n\t\t\t\t}\n\n\t\t\t\tDLFolder folder = (DLFolder)resource.getModel();\n\n\t\t\t\tlock = DLFolderServiceUtil.lockFolder(\n\t\t\t\t\tfolder.getFolderId(), owner, inheritable, timeout);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\n\t\t\t// DuplicateLock is 423 not 501\n\n\t\t\tif (!(e instanceof DuplicateLockException)) {\n\t\t\t\tthrow new WebDAVException(e);\n\t\t\t}\n\n\t\t\tstatus = WebDAVUtil.SC_LOCKED;\n\t\t}\n\n\t\treturn new Status(lock, status);\n\t}","commit_id":"de28c9572787904663ce6a5b3d2bcb3ac968323d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Status makeCollection(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tif (request.getContentLength() > 0) {\n\t\t\t\treturn new Status(\n\t\t\t\t\tHttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n\t\t\t}\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tDLFolderServiceUtil.addFolder(\n\t\t\t\twebDavRequest.getGroupId(), parentFolderId, name, description,\n\t\t\t\tserviceContext);\n\n\t\t\tString location = StringUtil.merge(pathArray, StringPool.SLASH);\n\n\t\t\treturn new Status(location, HttpServletResponse.SC_CREATED);\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn new Status(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn new Status(HttpServletResponse.SC_CONFLICT);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn new Status(HttpServletResponse.SC_FORBIDDEN);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":106047,"modified_method":"public Status makeCollection(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tif (request.getContentLength() > 0) {\n\t\t\t\treturn new Status(\n\t\t\t\t\tHttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n\t\t\t}\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tDLFolderServiceUtil.addFolder(\n\t\t\t\tgroupId, parentFolderId, name, description, serviceContext);\n\n\t\t\tString location = StringUtil.merge(pathArray, StringPool.SLASH);\n\n\t\t\treturn new Status(location, HttpServletResponse.SC_CREATED);\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn new Status(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn new Status(HttpServletResponse.SC_CONFLICT);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn new Status(HttpServletResponse.SC_FORBIDDEN);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"de28c9572787904663ce6a5b3d2bcb3ac968323d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Status makeCollection(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tif (request.getContentLength() > 0) {\n\t\t\t\treturn new Status(\n\t\t\t\t\tHttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n\t\t\t}\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\tserviceContext.setPlid(getPlid(webDavRequest.getGroupId()));\n\t\t\tserviceContext.setScopeGroupId(webDavRequest.getGroupId());\n\n\t\t\tIGFolderServiceUtil.addFolder(\n\t\t\t\tparentFolderId, name, description, serviceContext);\n\n\t\t\tString location = StringUtil.merge(pathArray, StringPool.SLASH);\n\n\t\t\treturn new Status(location, HttpServletResponse.SC_CREATED);\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn new Status(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn new Status(HttpServletResponse.SC_CONFLICT);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn new Status(HttpServletResponse.SC_FORBIDDEN);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":106048,"modified_method":"public Status makeCollection(WebDAVRequest webDavRequest)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tif (request.getContentLength() > 0) {\n\t\t\t\treturn new Status(\n\t\t\t\t\tHttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n\t\t\t}\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\tserviceContext.setPlid(getPlid(webDavRequest.getGroupId()));\n\t\t\tserviceContext.setScopeGroupId(webDavRequest.getGroupId());\n\n\t\t\tIGFolderServiceUtil.addFolder(\n\t\t\t\tparentFolderId, name, description, serviceContext);\n\n\t\t\tString location = StringUtil.merge(pathArray, StringPool.SLASH);\n\n\t\t\treturn new Status(location, HttpServletResponse.SC_CREATED);\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn new Status(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\treturn new Status(HttpServletResponse.SC_CONFLICT);\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn new Status(HttpServletResponse.SC_FORBIDDEN);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"1a7724bd57b2cc248712a62a9164f5697353aa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tfile = FileUtil.createTempFile(FileUtil.getExtension(name));\n\n\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\tString contentType = ContentTypeUtil.getContentType(name);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\ttry {\n\t\t\t\tIGImage image =\n\t\t\t\t\tIGImageServiceUtil.getImageByFolderIdAndNameWithExtension(\n\t\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tlong imageId = image.getImageId();\n\n\t\t\t\tdescription = image.getDescription();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tIGImage.class.getName(), imageId);\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tIGImageServiceUtil.updateImage(\n\t\t\t\t\timageId, groupId, parentFolderId, name, description, file,\n\t\t\t\t\tcontentType, serviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\tIGImageServiceUtil.addImage(\n\t\t\t\t\tgroupId, parentFolderId, name, description, file,\n\t\t\t\t\tcontentType, serviceContext);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","id":106049,"modified_method":"public int putResource(WebDAVRequest webDavRequest) throws WebDAVException {\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tHttpServletRequest request = webDavRequest.getHttpServletRequest();\n\n\t\t\tString[] pathArray = webDavRequest.getPathArray();\n\n\t\t\tlong groupId = webDavRequest.getGroupId();\n\t\t\tlong parentFolderId = getParentFolderId(pathArray);\n\t\t\tString name = WebDAVUtil.getResourceName(pathArray);\n\t\t\tString description = StringPool.BLANK;\n\n\t\t\tfile = FileUtil.createTempFile(FileUtil.getExtension(name));\n\n\t\t\tFileUtil.write(file, request.getInputStream());\n\n\t\t\tString contentType = ContentTypeUtil.getContentType(name);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\ttry {\n\t\t\t\tIGImage image =\n\t\t\t\t\tIGImageServiceUtil.getImageByFolderIdAndNameWithExtension(\n\t\t\t\t\t\tgroupId, parentFolderId, name);\n\n\t\t\t\tlong imageId = image.getImageId();\n\n\t\t\t\tdescription = image.getDescription();\n\n\t\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tIGImage.class.getName(), imageId);\n\n\t\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\t\t\tIGImageServiceUtil.updateImage(\n\t\t\t\t\timageId, groupId, parentFolderId, name, description, file,\n\t\t\t\t\tcontentType, serviceContext);\n\t\t\t}\n\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\tIGImageServiceUtil.addImage(\n\t\t\t\t\tgroupId, parentFolderId, name, description, file,\n\t\t\t\t\tcontentType, serviceContext);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CREATED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(pe, pe);\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"1a7724bd57b2cc248712a62a9164f5697353aa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int copyCollectionResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite, long depth)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = IGFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tIGFolder folder = (IGFolder)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = folder.getDescription();\n\t\t\tboolean addCommunityPermissions = true;\n\t\t\tboolean addGuestPermissions = true;\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(groupId, parentFolderId, name)) {\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\t\tif (depth == 0) {\n\t\t\t\tIGFolderServiceUtil.addFolder(\n\t\t\t\t\tparentFolderId, name, description, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIGFolderServiceUtil.copyFolder(\n\t\t\t\t\tfolder.getFolderId(), parentFolderId, name, description,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":106050,"modified_method":"public int copyCollectionResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite, long depth)\n\t\tthrows WebDAVException {\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = IGFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tIGFolder folder = (IGFolder)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = folder.getDescription();\n\t\t\tboolean addCommunityPermissions = true;\n\t\t\tboolean addGuestPermissions = true;\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(groupId, parentFolderId, name)) {\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(\n\t\t\t\t\taddCommunityPermissions);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\t\tif (depth == 0) {\n\t\t\t\tIGFolderServiceUtil.addFolder(\n\t\t\t\t\tparentFolderId, name, description, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIGFolderServiceUtil.copyFolder(\n\t\t\t\t\tfolder.getFolderId(), parentFolderId, name, description,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"1a7724bd57b2cc248712a62a9164f5697353aa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int copySimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = IGFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tIGImage image = (IGImage)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = image.getDescription();\n\t\t\tString contentType = ContentTypeUtil.getContentType(\n\t\t\t\timage.getNameWithExtension());\n\n\t\t\tfile = FileUtil.createTempFile(image.getImageType());\n\n\t\t\tInputStream is = resource.getContentAsStream();\n\n\t\t\tFileUtil.write(file, is);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(groupId, parentFolderId, name)) {\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIGImageServiceUtil.addImage(\n\t\t\t\tgroupId, parentFolderId, name, description, file, contentType,\n\t\t\t\tserviceContext);\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","id":106051,"modified_method":"public int copySimpleResource(\n\t\t\tWebDAVRequest webDavRequest, Resource resource, String destination,\n\t\t\tboolean overwrite)\n\t\tthrows WebDAVException {\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tString[] destinationArray = WebDAVUtil.getPathArray(\n\t\t\t\tdestination, true);\n\n\t\t\tlong parentFolderId = IGFolderConstants.DEFAULT_PARENT_FOLDER_ID;\n\n\t\t\ttry {\n\t\t\t\tparentFolderId = getParentFolderId(destinationArray);\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\treturn HttpServletResponse.SC_CONFLICT;\n\t\t\t}\n\n\t\t\tIGImage image = (IGImage)resource.getModel();\n\n\t\t\tlong groupId = WebDAVUtil.getGroupId(destination);\n\t\t\tString name = WebDAVUtil.getResourceName(destinationArray);\n\t\t\tString description = image.getDescription();\n\t\t\tString contentType = ContentTypeUtil.getContentType(\n\t\t\t\timage.getNameWithExtension());\n\n\t\t\tfile = FileUtil.createTempFile(image.getImageType());\n\n\t\t\tInputStream is = resource.getContentAsStream();\n\n\t\t\tFileUtil.write(file, is);\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tif (!group.isUser()) {\n\t\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\t}\n\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tint status = HttpServletResponse.SC_CREATED;\n\n\t\t\tif (overwrite) {\n\t\t\t\tif (deleteResource(groupId, parentFolderId, name)) {\n\t\t\t\t\tstatus = HttpServletResponse.SC_NO_CONTENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIGImageServiceUtil.addImage(\n\t\t\t\tgroupId, parentFolderId, name, description, file, contentType,\n\t\t\t\tserviceContext);\n\n\t\t\treturn status;\n\t\t}\n\t\tcatch (DuplicateFolderNameException dfne) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (DuplicateFileException dfe) {\n\t\t\treturn HttpServletResponse.SC_PRECONDITION_FAILED;\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\treturn HttpServletResponse.SC_FORBIDDEN;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"1a7724bd57b2cc248712a62a9164f5697353aa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void maybeTryAdditionalReplicas()\n        {\n            // no latency information, or we're overloaded\n            if (cfs.sampleLatencyNanos > TimeUnit.MILLISECONDS.toNanos(command.getTimeout()))\n                return;\n\n            if (!handler.await(cfs.sampleLatencyNanos, TimeUnit.NANOSECONDS))\n            {\n                // Could be waiting on the data, or on enough digests.\n                ReadCommand retryCommand = command;\n                if (resolver.getData() != null)\n                {\n                    retryCommand = command.copy();\n                    retryCommand.setDigestQuery(true);\n                }\n\n                InetAddress extraReplica = Iterables.getLast(targetReplicas);\n                logger.trace(\"speculating read retry on {}\", extraReplica);\n                MessagingService.instance().sendRR(retryCommand.createMessage(), extraReplica, handler);\n                speculated = true;\n\n                cfs.metric.speculativeRetries.inc();\n            }\n        }","id":106052,"modified_method":"public void maybeTryAdditionalReplicas()\n        {\n            // no latency information, or we're overloaded\n            if (cfs.sampleLatencyNanos > TimeUnit.MILLISECONDS.toNanos(command.getTimeout()))\n                return;\n\n            if (!handler.await(cfs.sampleLatencyNanos, TimeUnit.NANOSECONDS))\n            {\n                // Could be waiting on the data, or on enough digests.\n                ReadCommand retryCommand = command;\n                if (resolver.getData() != null)\n                    retryCommand = command.copy().setIsDigestQuery(true);\n\n                InetAddress extraReplica = Iterables.getLast(targetReplicas);\n                logger.trace(\"speculating read retry on {}\", extraReplica);\n                MessagingService.instance().sendRR(retryCommand.createMessage(), extraReplica, handler);\n                speculated = true;\n\n                cfs.metric.speculativeRetries.inc();\n            }\n        }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"protected void makeDataRequests(Iterable<InetAddress> endpoints)\n    {\n        boolean readLocal = false;\n        for (InetAddress endpoint : endpoints)\n        {\n            if (isLocalRequest(endpoint))\n            {\n                readLocal = true;\n            }\n            else\n            {\n                logger.trace(\"reading data from {}\", endpoint);\n                MessagingService.instance().sendRR(command.createMessage(), endpoint, handler);\n            }\n        }\n        if (readLocal)\n        {\n            logger.trace(\"reading data locally\");\n            StageManager.getStage(Stage.READ).maybeExecuteImmediately(new LocalReadRunnable(command, handler));\n        }\n    }","id":106053,"modified_method":"protected void makeDataRequests(Iterable<InetAddress> endpoints)\n    {\n        makeRequests(command, endpoints);\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"protected void makeDigestRequests(Iterable<InetAddress> endpoints)\n    {\n        ReadCommand digestCommand = command.copy();\n        digestCommand.setDigestQuery(true);\n        MessageOut<?> message = digestCommand.createMessage();\n        for (InetAddress endpoint : endpoints)\n        {\n            if (isLocalRequest(endpoint))\n            {\n                logger.trace(\"reading digest locally\");\n                StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));\n            }\n            else\n            {\n                logger.trace(\"reading digest from {}\", endpoint);\n                MessagingService.instance().sendRR(message, endpoint, handler);\n            }\n        }\n    }","id":106054,"modified_method":"protected void makeDigestRequests(Iterable<InetAddress> endpoints)\n    {\n        makeRequests(command.copy().setIsDigestQuery(true), endpoints);\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"public void setDigestQuery(boolean isDigestQuery)\n    {\n        this.isDigestQuery = isDigestQuery;\n    }","id":106055,"modified_method":"public ReadCommand setIsDigestQuery(boolean isDigestQuery)\n    {\n        this.isDigestQuery = isDigestQuery;\n        return this;\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n    public ReadCommand copy()\n    {\n        ReadCommand readCommand = new RetriedSliceFromReadCommand(ksName, key, cfName, timestamp, filter, originalCount);\n        readCommand.setDigestQuery(isDigestQuery());\n        return readCommand;\n    }","id":106056,"modified_method":"@Override\n    public ReadCommand copy()\n    {\n        return new RetriedSliceFromReadCommand(ksName, key, cfName, timestamp, filter, originalCount).setIsDigestQuery(isDigestQuery());\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"public ReadCommand copy()\n    {\n        ReadCommand readCommand= new SliceByNamesReadCommand(ksName, key, cfName, timestamp, filter);\n        readCommand.setDigestQuery(isDigestQuery());\n        return readCommand;\n    }","id":106057,"modified_method":"public ReadCommand copy()\n    {\n        return new SliceByNamesReadCommand(ksName, key, cfName, timestamp, filter).setIsDigestQuery(isDigestQuery());\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"public ReadCommand deserialize(DataInput in, int version) throws IOException\n    {\n        boolean isDigest = in.readBoolean();\n        String keyspaceName = in.readUTF();\n        ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n        String cfName = in.readUTF();\n        long timestamp = in.readLong();\n        CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);\n        NamesQueryFilter filter = metadata.comparator.namesQueryFilterSerializer().deserialize(in, version);\n        ReadCommand command = new SliceByNamesReadCommand(keyspaceName, key, cfName, timestamp, filter);\n        command.setDigestQuery(isDigest);\n        return command;\n    }","id":106058,"modified_method":"public ReadCommand deserialize(DataInput in, int version) throws IOException\n    {\n        boolean isDigest = in.readBoolean();\n        String keyspaceName = in.readUTF();\n        ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n        String cfName = in.readUTF();\n        long timestamp = in.readLong();\n        CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);\n        NamesQueryFilter filter = metadata.comparator.namesQueryFilterSerializer().deserialize(in, version);\n        return new SliceByNamesReadCommand(keyspaceName, key, cfName, timestamp, filter).setIsDigestQuery(isDigest);\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"public ReadCommand copy()\n    {\n        ReadCommand readCommand = new SliceFromReadCommand(ksName, key, cfName, timestamp, filter);\n        readCommand.setDigestQuery(isDigestQuery());\n        return readCommand;\n    }","id":106059,"modified_method":"public ReadCommand copy()\n    {\n        return new SliceFromReadCommand(ksName, key, cfName, timestamp, filter).setIsDigestQuery(isDigestQuery());\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"public ReadCommand deserialize(DataInput in, int version) throws IOException\n    {\n        boolean isDigest = in.readBoolean();\n        String keyspaceName = in.readUTF();\n        ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n        String cfName = in.readUTF();\n        long timestamp = in.readLong();\n        CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);\n        SliceQueryFilter filter = metadata.comparator.sliceQueryFilterSerializer().deserialize(in, version);\n        ReadCommand command = new SliceFromReadCommand(keyspaceName, key, cfName, timestamp, filter);\n        command.setDigestQuery(isDigest);\n        return command;\n    }","id":106060,"modified_method":"public ReadCommand deserialize(DataInput in, int version) throws IOException\n    {\n        boolean isDigest = in.readBoolean();\n        String keyspaceName = in.readUTF();\n        ByteBuffer key = ByteBufferUtil.readWithShortLength(in);\n        String cfName = in.readUTF();\n        long timestamp = in.readLong();\n        CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);\n        SliceQueryFilter filter = metadata.comparator.sliceQueryFilterSerializer().deserialize(in, version);\n        return new SliceFromReadCommand(keyspaceName, key, cfName, timestamp, filter).setIsDigestQuery(isDigest);\n    }","commit_id":"e2d140fff752e757f40c812dcd1b7bed3ea5fed2","url":"https://github.com/apache/cassandra"},{"original_method":"private void createListOfPlugins(final JPanel installedPluginsPanel, final JPanel bundledPluginsPanel) {\n    //Create the list of installed plugins\n    IdeaPluginDescriptor[] myInstalledPlugins = ApplicationManager.getApplication().getPlugins();\n\n    if (myInstalledPlugins == null || myInstalledPlugins.length == 0) {\n      addListItemToPlugins(installedPluginsPanel, makeItalic(UIBundle\n        .message(\"welcome.screen.plugins.panel.no.plugins.currently.installed.message.text\")), null, null, null, null, true);\n      addListItemToPlugins(bundledPluginsPanel, makeItalic(UIBundle\n        .message(\"welcome.screen.plugins.panel.all.bundled.plugins.were.uninstalled.message.text\")), null, null, null, null, true);\n    }\n    else {\n      final Comparator<IdeaPluginDescriptor> pluginsComparator = new Comparator<IdeaPluginDescriptor>() {\n        public int compare(final IdeaPluginDescriptor o1, final IdeaPluginDescriptor o2) {\n          final boolean e1 = ((IdeaPluginDescriptorImpl)o1).isEnabled();\n          final boolean e2 = ((IdeaPluginDescriptorImpl)o2).isEnabled();\n          if (e1 && !e2) return -1;\n          if (!e1 && e2) return 1;\n          return o1.getName().compareTo(o2.getName());\n        }\n      };\n      Arrays.sort(myInstalledPlugins, pluginsComparator);\n\n      int embeddedPlugins = 0;\n      int installedPlugins = 0;\n      String preinstalledPrefix = PathManager.getPreinstalledPluginsPath();\n\n      for (IdeaPluginDescriptor plugin : myInstalledPlugins) {\n        if (plugin.getName().equals(\"IDEA CORE\")) {\n          // this is not really a plugin, so it shouldn't be displayed\n          continue;\n        }\n        final boolean enabled = ((IdeaPluginDescriptorImpl)plugin).isEnabled();\n        if (plugin.getPath().getAbsolutePath().startsWith(preinstalledPrefix)) {\n          embeddedPlugins++;\n          addListItemToPlugins(bundledPluginsPanel, plugin.getName(), plugin.getDescription(), plugin.getVendorLogoPath(),\n                               plugin.getPluginClassLoader(), plugin.getUrl(), enabled);\n        }\n        else {\n          installedPlugins++;\n          addListItemToPlugins(installedPluginsPanel, plugin.getName(), plugin.getDescription(), plugin.getVendorLogoPath(),\n                               plugin.getPluginClassLoader(), plugin.getUrl(), enabled);\n        }\n      }\n      if (embeddedPlugins == 0) {\n        addListItemToPlugins(bundledPluginsPanel, makeItalic(UIBundle\n          .message(\"welcome.screen.plugins.panel.all.bundled.plugins.were.uninstalled.message.text\")), null, null, null, null, true);\n      }\n      if (installedPlugins == 0) {\n        addListItemToPlugins(installedPluginsPanel, makeItalic(UIBundle\n          .message(\"welcome.screen.plugins.panel.no.plugins.currently.installed.message.text\")), null, null, null, null, true);\n      }\n    }\n  }","id":106061,"modified_method":"private void createListOfPlugins(final JPanel installedPluginsPanel, final JPanel bundledPluginsPanel) {\n    //Create the list of installed plugins\n    IdeaPluginDescriptor[] myInstalledPlugins = ApplicationManager.getApplication().getPlugins();\n\n    if (myInstalledPlugins == null || myInstalledPlugins.length == 0) {\n      addListItemToPlugins(installedPluginsPanel, makeItalic(UIBundle\n        .message(\"welcome.screen.plugins.panel.no.plugins.currently.installed.message.text\")));\n      addListItemToPlugins(bundledPluginsPanel, makeItalic(UIBundle\n        .message(\"welcome.screen.plugins.panel.all.bundled.plugins.were.uninstalled.message.text\")));\n    }\n    else {\n      final Comparator<IdeaPluginDescriptor> pluginsComparator = new Comparator<IdeaPluginDescriptor>() {\n        public int compare(final IdeaPluginDescriptor o1, final IdeaPluginDescriptor o2) {\n          final boolean e1 = ((IdeaPluginDescriptorImpl)o1).isEnabled();\n          final boolean e2 = ((IdeaPluginDescriptorImpl)o2).isEnabled();\n          if (e1 && !e2) return -1;\n          if (!e1 && e2) return 1;\n          return o1.getName().compareTo(o2.getName());\n        }\n      };\n      Arrays.sort(myInstalledPlugins, pluginsComparator);\n\n      int embeddedPlugins = 0;\n      int installedPlugins = 0;\n      String preinstalledPrefix = PathManager.getPreinstalledPluginsPath();\n\n      for (IdeaPluginDescriptor plugin : myInstalledPlugins) {\n        if (plugin.getName().equals(\"IDEA CORE\")) {\n          // this is not really a plugin, so it shouldn't be displayed\n          continue;\n        }\n        if (plugin.getPath().getAbsolutePath().startsWith(preinstalledPrefix)) {\n          embeddedPlugins++;\n          addListItemToPlugins(bundledPluginsPanel, (IdeaPluginDescriptorImpl)plugin);\n        }\n        else {\n          installedPlugins++;\n          addListItemToPlugins(installedPluginsPanel, (IdeaPluginDescriptorImpl)plugin);\n        }\n      }\n      if (embeddedPlugins == 0) {\n        addListItemToPlugins(bundledPluginsPanel, makeItalic(UIBundle\n          .message(\"welcome.screen.plugins.panel.all.bundled.plugins.were.uninstalled.message.text\")));\n      }\n      if (installedPlugins == 0) {\n        addListItemToPlugins(installedPluginsPanel, makeItalic(UIBundle\n          .message(\"welcome.screen.plugins.panel.no.plugins.currently.installed.message.text\")));\n      }\n    }\n  }","commit_id":"d05f1499f2ec06b85e91a977e76a73614eeb4655","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addListItemToPlugins(JPanel panel, String name, String description, String iconPath, ClassLoader pluginClassLoader, final String url,\n                                   final boolean enabled) {\n\n    if (StringUtil.isEmptyOrSpaces(name)) {\n      return;\n    }\n    else {\n      name = name.trim();\n    }\n\n    final int y = myPluginsIdx += 2;\n    Icon logoImage;\n\n    // Check the iconPath and insert empty icon in case of empty or invalid value\n    if (StringUtil.isEmptyOrSpaces(iconPath)) {\n      logoImage = new EmptyIcon(PLUGIN_LOGO_SIZE.width, PLUGIN_LOGO_SIZE.height);\n    }\n    else {\n      logoImage = IconLoader.findIcon(iconPath, pluginClassLoader);\n      if (logoImage == null) logoImage = new EmptyIcon(PLUGIN_LOGO_SIZE.width, PLUGIN_LOGO_SIZE.height);\n    }\n    JLabel imageLabel = new JLabel(logoImage);\n    GridBagConstraints gBC = new GridBagConstraints(0, y, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                                    new Insets(15, 20, 0, 0), 0, 0);\n    panel.add(imageLabel, gBC);\n\n    String shortenedName = adjustStringBreaksByWidth(name + \" \" + (enabled ? \"\": UIBundle.message(\"welcome.screen.disabled.plugins.description\")), LINK_FONT, false, PLUGIN_NAME_MAX_WIDTH, PLUGIN_NAME_MAX_ROWS);\n    JLabel logoName = new JLabel(shortenedName);\n    logoName.setFont(LINK_FONT);\n    logoName.setForeground(enabled ? CAPTION_COLOR : DISABLED_CAPTION_COLOR);\n    if (shortenedName.endsWith(___HTML_SUFFIX)) {\n      logoName.setToolTipText(adjustStringBreaksByWidth(name, UIUtil.getToolTipFont(), false, MAX_TOOLTIP_WIDTH, 0));\n    }\n\n    gBC = new GridBagConstraints(1, y, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                 new Insets(15, 7, 0, 0), 0, 0);\n    panel.add(logoName, gBC);\n\n    if (!StringUtil.isEmpty(description)) {\n      description = description.trim();\n      if (description.startsWith(ActionGroupDescriptor.HTML_PREFIX)) {\n        description = description.replaceAll(ActionGroupDescriptor.HTML_PREFIX, \"\");\n        if (description.endsWith(ActionGroupDescriptor.HTML_SUFFIX)) {\n          description = description.replaceAll(ActionGroupDescriptor.HTML_SUFFIX, \"\");\n        }\n      }\n      description = description.replaceAll(ESC_NEW_LINE, \"\");\n      String shortenedDcs = adjustStringBreaksByWidth(description, TEXT_FONT, false, PLUGIN_DSC_MAX_WIDTH, PLUGIN_DSC_MAX_ROWS);\n      JLabel pluginDescription = new JLabel(shortenedDcs);\n      pluginDescription.setFont(TEXT_FONT);\n      if (shortenedDcs.endsWith(___HTML_SUFFIX)) {\n        pluginDescription.setToolTipText(adjustStringBreaksByWidth(description, UIUtil.getToolTipFont(), false, MAX_TOOLTIP_WIDTH, 0));\n      }\n\n      gBC = new GridBagConstraints(1, y + 1, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                   new Insets(5, 7, 0, 0), 5, 0);\n      panel.add(pluginDescription, gBC);\n    }\n\n    if (!StringUtil.isEmptyOrSpaces(url)) {\n      gBC = new GridBagConstraints(2, y + 1, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 7, 0, 10), 0, 0);\n      MyActionButton learnMore = new PluginsActionButton(LEARN_MORE_ICON, null) {\n        protected void onPress(InputEvent e) {\n          try {\n            BrowserUtil.launchBrowser(url);\n          }\n          catch (IllegalThreadStateException ex) {\n            // it's not a problem\n          }\n        }\n      };\n      learnMore.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n      learnMore.setToolTipText(UIBundle.message(\"welcome.screen.plugins.panel.learn.more.tooltip.text\"));\n      panel.add(learnMore, gBC);\n      learnMore.setupWithinPanel(myPluginsPanel, PLUGINS_GROUP, myPluginsButtonsCount, 0);\n      myPluginsButtonsCount++;\n    }\n    gBC = new GridBagConstraints(2, y, 2, 2, 1, 0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 10), 0, 0);\n    JPanel emptyPane = new JPanel();\n    emptyPane.setBackground(PLUGINS_PANEL_COLOR);\n    panel.add(emptyPane, gBC);\n  }","id":106062,"modified_method":"public void addListItemToPlugins(JPanel panel, String name, String description, String iconPath, ClassLoader pluginClassLoader, final String url,\n                                   final boolean enabled, final boolean incompatible) {\n\n    if (StringUtil.isEmptyOrSpaces(name)) {\n      return;\n    }\n    else {\n      name = name.trim();\n    }\n\n    final int y = myPluginsIdx += 2;\n    Icon logoImage;\n\n    // Check the iconPath and insert empty icon in case of empty or invalid value\n    if (StringUtil.isEmptyOrSpaces(iconPath)) {\n      logoImage = new EmptyIcon(PLUGIN_LOGO_SIZE.width, PLUGIN_LOGO_SIZE.height);\n    }\n    else {\n      logoImage = IconLoader.findIcon(iconPath, pluginClassLoader);\n      if (logoImage == null) logoImage = new EmptyIcon(PLUGIN_LOGO_SIZE.width, PLUGIN_LOGO_SIZE.height);\n    }\n    JLabel imageLabel = new JLabel(logoImage);\n    GridBagConstraints gBC = new GridBagConstraints(0, y, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                                    new Insets(15, 20, 0, 0), 0, 0);\n    panel.add(imageLabel, gBC);\n\n    String shortenedName = adjustStringBreaksByWidth(name + \" \" + (incompatible ? UIBundle.message(\"welcome.screen.incompatible.plugins.description\") : (enabled ? \"\": UIBundle.message(\"welcome.screen.disabled.plugins.description\"))), LINK_FONT, false, PLUGIN_NAME_MAX_WIDTH, PLUGIN_NAME_MAX_ROWS);\n    JLabel logoName = new JLabel(shortenedName);\n    logoName.setFont(LINK_FONT);\n    logoName.setForeground(enabled ? CAPTION_COLOR : DISABLED_CAPTION_COLOR);\n    if (shortenedName.endsWith(___HTML_SUFFIX)) {\n      logoName.setToolTipText(adjustStringBreaksByWidth(name, UIUtil.getToolTipFont(), false, MAX_TOOLTIP_WIDTH, 0));\n    }\n\n    gBC = new GridBagConstraints(1, y, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                                 new Insets(15, 7, 0, 0), 0, 0);\n    panel.add(logoName, gBC);\n\n    if (!StringUtil.isEmpty(description)) {\n      description = description.trim();\n      if (description.startsWith(ActionGroupDescriptor.HTML_PREFIX)) {\n        description = description.replaceAll(ActionGroupDescriptor.HTML_PREFIX, \"\");\n        if (description.endsWith(ActionGroupDescriptor.HTML_SUFFIX)) {\n          description = description.replaceAll(ActionGroupDescriptor.HTML_SUFFIX, \"\");\n        }\n      }\n      description = description.replaceAll(ESC_NEW_LINE, \"\");\n      String shortenedDcs = adjustStringBreaksByWidth(description, TEXT_FONT, false, PLUGIN_DSC_MAX_WIDTH, PLUGIN_DSC_MAX_ROWS);\n      JLabel pluginDescription = new JLabel(shortenedDcs);\n      pluginDescription.setFont(TEXT_FONT);\n      if (shortenedDcs.endsWith(___HTML_SUFFIX)) {\n        pluginDescription.setToolTipText(adjustStringBreaksByWidth(description, UIUtil.getToolTipFont(), false, MAX_TOOLTIP_WIDTH, 0));\n      }\n\n      gBC = new GridBagConstraints(1, y + 1, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                   new Insets(5, 7, 0, 0), 5, 0);\n      panel.add(pluginDescription, gBC);\n    }\n\n    if (!StringUtil.isEmptyOrSpaces(url)) {\n      gBC = new GridBagConstraints(2, y + 1, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 7, 0, 10), 0, 0);\n      MyActionButton learnMore = new PluginsActionButton(LEARN_MORE_ICON, null) {\n        protected void onPress(InputEvent e) {\n          try {\n            BrowserUtil.launchBrowser(url);\n          }\n          catch (IllegalThreadStateException ex) {\n            // it's not a problem\n          }\n        }\n      };\n      learnMore.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n      learnMore.setToolTipText(UIBundle.message(\"welcome.screen.plugins.panel.learn.more.tooltip.text\"));\n      panel.add(learnMore, gBC);\n      learnMore.setupWithinPanel(myPluginsPanel, PLUGINS_GROUP, myPluginsButtonsCount, 0);\n      myPluginsButtonsCount++;\n    }\n    gBC = new GridBagConstraints(2, y, 2, 2, 1, 0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 10), 0, 0);\n    JPanel emptyPane = new JPanel();\n    emptyPane.setBackground(PLUGINS_PANEL_COLOR);\n    panel.add(emptyPane, gBC);\n  }","commit_id":"d05f1499f2ec06b85e91a977e76a73614eeb4655","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addDefaultQuickStartActions(final ActionGroupDescriptor quickStarts, final ActionManager actionManager) {\n    MyActionButton newProject = new MyActionButton(NEW_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e) {\n        ProjectUtil.createNewProject(null, null);\n      }\n    };\n    quickStarts.addButton(newProject, UIBundle.message(\"welcome.screen.create.new.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.create.new.project.action.description\"));\n\n    MyActionButton openProject = new ButtonWithExtension(OPEN_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new OpenProjectAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n\n    quickStarts.addButton(openProject, UIBundle.message(\"welcome.screen.open.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.open.project.action.description\", ApplicationNamesInfo.getInstance().getFullProductName()));\n\n    MyActionButton openRecentProject = new ButtonWithExtension(REOPEN_RECENT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        new RecentProjectsAction().showPopup(button, e);\n      }\n    };\n    quickStarts.addButton(openRecentProject, UIBundle.message(\"welcome.screen.reopen.recent.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.reopen.recent.project.action.description\"));\n\n    MyActionButton getFromVCS = new ButtonWithExtension(FROM_VCS_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        new GetFromVcsAction().showPopup(button, e);\n      }\n    };\n\n    quickStarts.addButton(getFromVCS, UIBundle.message(\"welcome.screen.check.out.from.version.control.action.name\"),\n                          UIBundle.message(\"welcome.screen.check.out.from.version.control.action.description\"));\n\n    MyActionButton importProjects = new ButtonWithExtension(IMPORT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        new ProjectImportPopupAction().showPopup(button, e);\n      }\n    };\n\n    quickStarts.addButton(importProjects,\n                          UIBundle.message(\"welcome.screen.import.projects.action.name\"),\n                          UIBundle.message(\"welcome.screen.import.projects.action.description\"));\n\n    /*\n    MyActionButton checkForUpdate = new MyActionButton (CHECK_FOR_UPDATE_ICON, null) {\n      protected void onPress(InputEvent e) {\n        CheckForUpdateAction.actionPerformed(true);\n      }\n    };\n\n    quickStarts.addButton(checkForUpdate, \"Check for Update\", ApplicationNamesInfo.getInstance().getFullProductName() +\n                                                              \" will check for a new available update of itself, \" +\n                                                              \"using your internet connection.\");\n    */\n  }","id":106063,"modified_method":"private void addDefaultQuickStartActions(final ActionGroupDescriptor quickStarts, final ActionManager actionManager) {\n    MyActionButton newProject = new MyActionButton(NEW_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e) {\n        ProjectUtil.createNewProject(null, null);\n      }\n    };\n    quickStarts.addButton(newProject, UIBundle.message(\"welcome.screen.create.new.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.create.new.project.action.description\"));\n\n    MyActionButton openProject = new ButtonWithExtension(OPEN_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new OpenProjectAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n\n    quickStarts.addButton(openProject, UIBundle.message(\"welcome.screen.open.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.open.project.action.description\", ApplicationNamesInfo.getInstance().getFullProductName()));\n\n    MyActionButton openRecentProject = new ButtonWithExtension(REOPEN_RECENT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        new RecentProjectsAction().showPopup(button, e);\n      }\n    };\n    quickStarts.addButton(openRecentProject, UIBundle.message(\"welcome.screen.reopen.recent.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.reopen.recent.project.action.description\"));\n\n    MyActionButton getFromVCS = new ButtonWithExtension(FROM_VCS_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        new GetFromVcsAction().showPopup(button, e);\n      }\n    };\n\n    quickStarts.addButton(getFromVCS, UIBundle.message(\"welcome.screen.check.out.from.version.control.action.name\"),\n                          UIBundle.message(\"welcome.screen.check.out.from.version.control.action.description\"));\n\n\n    /*\n    MyActionButton checkForUpdate = new MyActionButton (CHECK_FOR_UPDATE_ICON, null) {\n      protected void onPress(InputEvent e) {\n        CheckForUpdateAction.actionPerformed(true);\n      }\n    };\n\n    quickStarts.addButton(checkForUpdate, \"Check for Update\", ApplicationNamesInfo.getInstance().getFullProductName() +\n                                                              \" will check for a new available update of itself, \" +\n                                                              \"using your internet connection.\");\n    */\n  }","commit_id":"d05f1499f2ec06b85e91a977e76a73614eeb4655","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            if (clientResponse.getStatus() == ClientResponse.SUCCESS) {\n                VoltTable results = clientResponse.getResults()[0];\n                long tuplesDeleted = results.fetchRow(0).getLong(\"deleted\");\n                long tuplesNotDeleted = results.fetchRow(0).getLong(\"not_deleted\");\n\n                state.addToDeletedTuples(tuplesDeleted);\n                totalTuplesNotDeleted.addAndGet(tuplesNotDeleted);\n            }\n            else {\n                System.err.println(clientResponse.getStatusString());\n            }\n            // failure cases don't increment partitionsUnfinished because it is desirable to wait\n            // a bit before trying again\n            latch.countDown();\n        }","id":106064,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            if (clientResponse.getStatus() == ClientResponse.SUCCESS) {\n                VoltTable results = clientResponse.getResults()[0];\n                long tuplesDeleted = results.fetchRow(0).getLong(\"deleted\");\n                long tuplesNotDeleted = results.fetchRow(0).getLong(\"not_deleted\");\n\n                app.addToDeletedTuples(tuplesDeleted);\n                totalTuplesNotDeleted.addAndGet(tuplesNotDeleted);\n            }\n            else {\n                System.err.println(clientResponse.getStatusString());\n            }\n            // failure cases don't increment partitionsUnfinished because it is desirable to wait\n            // a bit before trying again\n            latch.countDown();\n        }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected void deleteSomeTuples(int rounds) {\n        final Map<Long, GlobalState.PartitionInfo> currentPartitionInfo = state.getPartitionData();\n        final long partitionCount = currentPartitionInfo.size();\n\n        final CountDownLatch latch = new CountDownLatch((int) partitionCount * rounds);\n        AtomicLong tuplesNotDeleted = null;\n\n        for (int round = 0; round < rounds; round++) {\n            final AtomicLong tuplesNotDeletedForRound = new AtomicLong(0);\n\n            TimestampType dateTarget = new TimestampType((System.currentTimeMillis() - 30 * 1000) * 1000);\n\n            for (GlobalState.PartitionInfo pinfo : currentPartitionInfo.values()) {\n                try {\n                    state.client.callProcedure(new Callback(latch, tuplesNotDeletedForRound),\n                                         \"DeleteAfterDate\",\n                                         pinfo.partitionKey,\n                                         dateTarget,\n                                         CHUNK_SIZE);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    latch.countDown();\n                }\n            }\n\n            tuplesNotDeleted = tuplesNotDeletedForRound;\n        }\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        long finalTuplesNotDeleted = tuplesNotDeleted.get();\n        if (tuplesNotDeleted.get() > 0) {\n            double avgOutstandingPerPartition = finalTuplesNotDeleted / (double) state.getPartitionCount();\n            int desiredRounds = (int) Math.ceil(avgOutstandingPerPartition / ContinuousDeleter.CHUNK_SIZE);\n            assert(desiredRounds > 0);\n            state.scheduler.execute(getRunnableForMulitpleRounds(desiredRounds));\n        }\n        else {\n            state.scheduler.schedule(this, DELETE_YIELD_MS, TimeUnit.MILLISECONDS);\n        }\n    }","id":106065,"modified_method":"protected void deleteSomeTuples(int rounds) {\n        final Map<Long, PartitionInfo> currentPartitionInfo = app.getPartitionData();\n        final long partitionCount = currentPartitionInfo.size();\n\n        final CountDownLatch latch = new CountDownLatch((int) partitionCount * rounds);\n        AtomicLong tuplesNotDeleted = null;\n\n        for (int round = 0; round < rounds; round++) {\n            final AtomicLong tuplesNotDeletedForRound = new AtomicLong(0);\n\n            TimestampType dateTarget = app.getTargetDate();\n            long rowTarget = app.getTargetRowsPerPartition();\n\n            for (PartitionInfo pinfo : currentPartitionInfo.values()) {\n                try {\n                    if (app.config.historyseconds > 0) {\n                        app.client.callProcedure(new Callback(latch, tuplesNotDeletedForRound),\n                                                 \"DeleteAfterDate\",\n                                                 pinfo.partitionKey,\n                                                 dateTarget,\n                                                 app.config.deletechunksize);\n                    }\n                    else /* if (app.config.maxrows > 0) */ {\n                        app.client.callProcedure(new Callback(latch, tuplesNotDeletedForRound),\n                                                 \"DeleteOldestToTarget\",\n                                                 pinfo.partitionKey,\n                                                 rowTarget,\n                                                 app.config.deletechunksize);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    latch.countDown();\n                }\n            }\n\n            tuplesNotDeleted = tuplesNotDeletedForRound;\n        }\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        long finalTuplesNotDeleted = tuplesNotDeleted.get();\n        if (tuplesNotDeleted.get() > 0) {\n            double avgOutstandingPerPartition = finalTuplesNotDeleted / (double) app.getPartitionCount();\n            int desiredRounds = (int) Math.ceil(avgOutstandingPerPartition / app.config.deletechunksize);\n            assert(desiredRounds > 0);\n            app.scheduler.execute(getRunnableForMulitpleRounds(desiredRounds));\n        }\n        else {\n            app.scheduler.schedule(this, app.config.deleteyieldtime, TimeUnit.MILLISECONDS);\n        }\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"ContinuousDeleter(GlobalState state) {\n        this.state = state;\n    }","id":106066,"modified_method":"ContinuousDeleter(WindowingApp app) {\n        this.app = app;\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable run(String partitionValue, TimestampType newestToDiscard, long maxRowsToDeletePerProc) {\n        if (newestToDiscard == null) {\n            throw new VoltAbortException(\"newestToDiscard shouldn't be null.\");\n            // It might be Long.MIN_VALUE as a TimestampType though.\n        }\n        if (maxRowsToDeletePerProc <= 0) {\n            throw new VoltAbortException(\"maxRowsToDeletePerProc must be > 0.\");\n        }\n\n        voltQueueSQL(countMatchingRows, EXPECT_SCALAR_LONG, newestToDiscard);\n        VoltTable[] countResults = voltExecuteSQL();\n        long agedOutCount = countResults[0].asScalarLong();\n\n        if (agedOutCount > maxRowsToDeletePerProc) {\n            voltQueueSQL(getNthOldestTimestamp, EXPECT_SCALAR, maxRowsToDeletePerProc);\n            newestToDiscard = voltExecuteSQL()[0].fetchRow(0).getTimestampAsTimestamp(0);\n        }\n\n        voltQueueSQL(deleteOlderThanDate, EXPECT_SCALAR_LONG, newestToDiscard);\n        long deletedCount = voltExecuteSQL(true)[0].asScalarLong();\n\n        VoltTable retval = retvalTemplate.clone(20); // 20b to hold two longs in one row\n        retval.addRow(deletedCount, agedOutCount - deletedCount);\n        return retval;\n    }","id":106067,"modified_method":"/**\n     *\n     * @param partitionValue Partitioning key for this procedure.\n     * @param newestToDiscard Try to remove any tuples as old or older than this value.\n     * @param maxRowsToDeletePerProc The upper limit on the number of rows to delete per transaction.\n     * @return A table with one row containing the number of deleted rows and the number that could\n     * have been deleted (but weren't) if there were no per-transaction delete limits.\n     * @throws VoltAbortException on bad input.\n     */\n    public VoltTable run(String partitionValue, TimestampType newestToDiscard, long maxRowsToDeletePerProc) {\n        if (newestToDiscard == null) {\n            throw new VoltAbortException(\"newestToDiscard shouldn't be null.\");\n            // It might be Long.MIN_VALUE as a TimestampType though.\n        }\n        if (maxRowsToDeletePerProc <= 0) {\n            throw new VoltAbortException(\"maxRowsToDeletePerProc must be > 0.\");\n        }\n\n        // Get the total number of rows older than the given timestamp.\n        voltQueueSQL(countMatchingRows, EXPECT_SCALAR_LONG, newestToDiscard);\n        long agedOutCount = voltExecuteSQL()[0].asScalarLong();\n\n        if (agedOutCount > maxRowsToDeletePerProc) {\n            // Find the timestamp of the row at position N in the sorter order, where N is the chunk size\n            voltQueueSQL(getNthOldestTimestamp, EXPECT_SCALAR, maxRowsToDeletePerProc);\n            newestToDiscard = voltExecuteSQL()[0].fetchRow(0).getTimestampAsTimestamp(0);\n        }\n\n        // Delete all rows >= the timestamp found in the previous statement.\n        // This will delete AT LEAST N rows, but since timestamps may be non-unique,\n        //  it might delete more than N. In the worst case, it could delete all rows\n        //  if every row has an indentical timestamp value. It is guaranteed to make\n        //  progress. If we used strictly less than, it might not make progress.\n        voltQueueSQL(deleteOlderThanDate, EXPECT_SCALAR_LONG, newestToDiscard);\n        long deletedCount = voltExecuteSQL(true)[0].asScalarLong();\n\n        // Return a table containing the number of rows deleted and the number\n        // of rows that could have been deleted (but weren't) if there were no\n        // per-transaction delete limits.\n        // VoltTable.clone(int) copies the schema of a table but not the data.\n        VoltTable retval = retvalTemplate.clone(20); // 20b is plenty to hold two longs\n        retval.addRow(deletedCount, agedOutCount - deletedCount);\n        return retval;\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public long run(String partitionValue, long maxTotalRows, long maxRowsToDeletePerProc) {\n        if (maxRowsToDeletePerProc <= 0) {\n            throw new VoltAbortException(\"maxRowsToDeletePerProc must be > 0.\");\n        }\n        if (maxTotalRows < 0) {\n            throw new VoltAbortException(\"maxTotalRows must be >= 0.\");\n        }\n\n        voltQueueSQL(countRows, EXPECT_SCALAR_LONG);\n        long count = voltExecuteSQL()[0].asScalarLong();\n\n        if (count < maxTotalRows) {\n            return 0;\n        }\n\n        if ((maxTotalRows == 0) && (count < maxRowsToDeletePerProc)) {\n            voltQueueSQL(deleteAll, EXPECT_SCALAR_MATCH(count));\n            voltExecuteSQL(true);\n            return count;\n        }\n\n        long rowsToConsider = Math.min(count - maxTotalRows, maxRowsToDeletePerProc);\n\n        voltQueueSQL(getNthOldestTimestamp, EXPECT_SCALAR, rowsToConsider);\n        TimestampType newestToDiscard = voltExecuteSQL()[0].fetchRow(0).getTimestampAsTimestamp(0);\n\n        voltQueueSQL(deleteOlderThanDate, EXPECT_SCALAR_LONG, newestToDiscard);\n        long deletedCount = voltExecuteSQL(true)[0].asScalarLong();\n\n        return deletedCount;\n    }","id":106068,"modified_method":"/**\n     *\n     * @param partitionValue Partitioning key for this procedure.\n     * @param maxTotalRows The desired number of rows per partition.\n     * @param maxRowsToDeletePerProc The upper limit on the number of rows to delete per transaction.\n     * @return A table with one row containing the number of deleted rows and the number that could\n     * have been deleted (but weren't) if there were no per-transaction delete limits.\n     * @throws VoltAbortException on bad input.\n     */\n    public VoltTable run(String partitionValue, long maxTotalRows, long maxRowsToDeletePerProc) {\n        if (maxRowsToDeletePerProc <= 0) {\n            throw new VoltAbortException(\"maxRowsToDeletePerProc must be > 0.\");\n        }\n        if (maxTotalRows < 0) {\n            throw new VoltAbortException(\"maxTotalRows must be >= 0.\");\n        }\n\n        // Count the rows in the current partition.\n        voltQueueSQL(countRows, EXPECT_SCALAR_LONG);\n        long count = voltExecuteSQL()[0].asScalarLong();\n\n        // Return a table containing the number of rows deleted and the number\n        // of rows that could have been deleted (but weren't) if there were no\n        // per-transaction delete limits.\n        // VoltTable.clone(int) copies the schema of a table but not the data.\n        VoltTable retval = retvalTemplate.clone(20); // 20b is plenty to hold two longs\n\n        // If partition is smaller than desired, return\n        if (count < maxTotalRows) {\n            retval.addRow(0, 0);\n            return retval;\n        }\n\n        // If asked to remove all rows, go ahead\n        if ((maxTotalRows == 0) && (count < maxRowsToDeletePerProc)) {\n            voltQueueSQL(deleteAll, EXPECT_SCALAR_MATCH(count));\n            voltExecuteSQL(true);\n            retval.addRow(count, 0);\n            return retval;\n        }\n\n        // Figure out how many rows to try to delete.\n        long agedOutCount = count - maxTotalRows;\n        long rowsToConsider = Math.min(agedOutCount, maxRowsToDeletePerProc);\n\n        // Find the timestamp of the row at position N in the sorter order, where N is the chunk size\n        voltQueueSQL(getNthOldestTimestamp, EXPECT_SCALAR, rowsToConsider);\n        TimestampType newestToDiscard = voltExecuteSQL()[0].fetchRow(0).getTimestampAsTimestamp(0);\n\n        // Delete all rows >= the timestamp found in the previous statement.\n        // This will delete AT LEAST N rows, but since timestamps may be non-unique,\n        //  it might delete more than N. In the worst case, it could delete all rows\n        //  if every row has an indentical timestamp value. It is guaranteed to make\n        //  progress. If we used strictly less than, it might not make progress.\n        voltQueueSQL(deleteOlderThanDate, EXPECT_SCALAR_LONG, newestToDiscard);\n        long deletedCount = voltExecuteSQL(true)[0].asScalarLong();\n\n        retval.addRow(deletedCount, agedOutCount - deletedCount);\n        return retval;\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        try {\n            ClientResponse cr = state.client.callProcedure(\"MaxValue\");\n            long currentMax = cr.getResults()[0].asScalarLong();\n            long previousMaxCopy = previousMax;\n\n            synchronized(this) {\n                if (currentMax == previousMax) {\n                    return;\n                }\n                previousMax = currentMax;\n            }\n\n            // Output synchronized on global state to make this line not print in the middle\n            // of other reporting lines.\n            synchronized(state) {\n                if (previousMaxCopy == Long.MIN_VALUE) {\n                    System.out.printf(\"The initial maximum value for the dataset has been set to %d.\\n\\n\",\n                                      currentMax);\n                }\n                else {\n                    System.out.printf(\"The maximum value for the dataset has changed from %d to %d.\\n\\n\",\n                                      previousMaxCopy, currentMax);\n                }\n            }\n        }\n        catch (IOException | ProcCallException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","id":106069,"modified_method":"@Override\n    public void run() {\n        try {\n            ClientResponse cr = app.client.callProcedure(\"MaxValue\");\n            long currentMax = cr.getResults()[0].asScalarLong();\n            long previousMaxCopy = previousMax;\n\n            synchronized(this) {\n                if (currentMax == previousMax) {\n                    return;\n                }\n                previousMax = currentMax;\n            }\n\n            // Output synchronized on global state to make this line not print in the middle\n            // of other reporting lines.\n            synchronized(app) {\n                if (previousMaxCopy == Long.MIN_VALUE) {\n                    System.out.printf(\"The initial maximum value for the dataset has been set to %d.\\n\\n\",\n                                      currentMax);\n                }\n                else {\n                    System.out.printf(\"The maximum value for the dataset has changed from %d to %d.\\n\\n\",\n                                      previousMaxCopy, currentMax);\n                }\n            }\n        }\n        catch (IOException | ProcCallException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        try {\n            Map<Long, GlobalState.PartitionInfo> partitionData = new HashMap<Long, GlobalState.PartitionInfo>();\n\n            VoltTable partitionKeys = null, tableStats = null;\n\n            try {\n                tableStats = state.client.callProcedure(\"@Statistics\", \"TABLE\").getResults()[0];\n                partitionKeys = state.client.callProcedure(\"@GetPartitionKeys\", \"STRING\").getResults()[0];\n            }\n            catch (IOException | ProcCallException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return;\n            }\n\n            while (tableStats.advanceRow()) {\n                if (!tableStats.getString(\"TABLE_NAME\").equalsIgnoreCase(\"timedata\")) {\n                    continue;\n                }\n\n                GlobalState.PartitionInfo pinfo = new GlobalState.PartitionInfo();\n                long partitionId = tableStats.getLong(\"PARTITION_ID\");\n                pinfo.tupleCount = tableStats.getLong(\"TUPLE_COUNT\");\n                pinfo.partitionKey = null;\n\n                // If redundancy (k-safety) is enabled, this will put k+1 times per partition,\n                // but the tuple count will be the same so it will be ok.\n                partitionData.put(partitionId, pinfo);\n            }\n\n            while (partitionKeys.advanceRow()) {\n                long partitionId = partitionKeys.getLong(\"PARTITION_ID\");\n                GlobalState.PartitionInfo pinfo = partitionData.get(partitionId);\n                if (pinfo == null) {\n                    // The set of partitions from the two calls don't match.\n                    // Try again next time this is called... Maybe things\n                    // will have settled down.\n                    return;\n                }\n\n                pinfo.partitionKey = partitionKeys.getString(\"PARTITION_KEY\");\n            }\n\n            // this is a sanity check to see that every partition has\n            // a partition value\n            boolean allMatched = true;\n            for (GlobalState.PartitionInfo pinfo : partitionData.values()) {\n                // a partition has a count, but no key\n                if (pinfo.partitionKey == null) {\n                    allMatched = false;\n                }\n            }\n            if (!allMatched) {\n                // The set of partitions from the two calls don't match.\n                // Try again next time this is called... Maybe things\n                // will have settled down.\n                return;\n            }\n\n            // atomically update the new map for the old one\n            state.updatePartitionInfoAndRedundancy(partitionData, tableStats.getRowCount() / partitionData.size());\n        }\n        catch (Throwable t) {\n            t.printStackTrace();\n            throw t;\n        }\n    }","id":106070,"modified_method":"@Override\n    public void run() {\n        try {\n            Map<Long, PartitionInfo> partitionData = new HashMap<Long, PartitionInfo>();\n\n            VoltTable partitionKeys = null, tableStats = null;\n\n            try {\n                tableStats = app.client.callProcedure(\"@Statistics\", \"TABLE\").getResults()[0];\n                partitionKeys = app.client.callProcedure(\"@GetPartitionKeys\", \"STRING\").getResults()[0];\n            }\n            catch (IOException | ProcCallException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return;\n            }\n\n            while (tableStats.advanceRow()) {\n                if (!tableStats.getString(\"TABLE_NAME\").equalsIgnoreCase(\"timedata\")) {\n                    continue;\n                }\n\n                PartitionInfo pinfo = new PartitionInfo();\n                long partitionId = tableStats.getLong(\"PARTITION_ID\");\n                pinfo.tupleCount = tableStats.getLong(\"TUPLE_COUNT\");\n                pinfo.partitionKey = null;\n\n                // If redundancy (k-safety) is enabled, this will put k+1 times per partition,\n                // but the tuple count will be the same so it will be ok.\n                partitionData.put(partitionId, pinfo);\n            }\n\n            while (partitionKeys.advanceRow()) {\n                long partitionId = partitionKeys.getLong(\"PARTITION_ID\");\n                PartitionInfo pinfo = partitionData.get(partitionId);\n                if (pinfo == null) {\n                    // The set of partitions from the two calls don't match.\n                    // Try again next time this is called... Maybe things\n                    // will have settled down.\n                    return;\n                }\n\n                pinfo.partitionKey = partitionKeys.getString(\"PARTITION_KEY\");\n            }\n\n            // this is a sanity check to see that every partition has\n            // a partition value\n            boolean allMatched = true;\n            for (PartitionInfo pinfo : partitionData.values()) {\n                // a partition has a count, but no key\n                if (pinfo.partitionKey == null) {\n                    allMatched = false;\n                }\n            }\n            if (!allMatched) {\n                // The set of partitions from the two calls don't match.\n                // Try again next time this is called... Maybe things\n                // will have settled down.\n                return;\n            }\n\n            // atomically update the new map for the old one\n            app.updatePartitionInfoAndRedundancy(partitionData, tableStats.getRowCount() / partitionData.size());\n        }\n        catch (Throwable t) {\n            t.printStackTrace();\n            throw t;\n        }\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public PartitionDataTracker(GlobalState state) {\n        this.state = state;\n    }","id":106071,"modified_method":"public PartitionDataTracker(WindowingApp app) {\n        this.app = app;\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void run() {\n        // reset the stats\n        fullStatsContext.fetchAndResetBaseline();\n        periodicStatsContext.fetchAndResetBaseline();\n\n        final long benchmarkEndTime = state.benchmarkStartTS + (1000l * state.config.duration);\n        while (benchmarkEndTime > System.currentTimeMillis()) {\n            // unique identifier and partition key\n            String uuid = UUID.randomUUID().toString();\n\n            // millisecond timestamp\n            Date now = new Date();\n\n            // for some odd reason, this will give LONG_MAX if the\n            // computed value is > LONG_MAX.\n            long val = (long) (rand.nextGaussian() * 1000.0);\n\n            try {\n                client.callProcedure(new InsertCallback(),\n                                     \"TIMEDATA.insert\",\n                                     uuid,\n                                     val,\n                                     now);\n            }\n            catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        isDone.set(true);\n\n        try {\n            client.drain();\n            client.close();\n        }\n        catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }","id":106072,"modified_method":"/**\n     * Run a loop inserting tuples into the database for the amount\n     * of time specified in config.duration.\n     */\n    public void run() {\n        // reset the stats\n        periodicStatsContext.fetchAndResetBaseline();\n\n        final long benchmarkEndTime = app.benchmarkStartTS + (1000l * app.config.duration);\n        while (benchmarkEndTime > System.currentTimeMillis()) {\n            // unique identifier and partition key\n            String uuid = UUID.randomUUID().toString();\n\n            // millisecond timestamp\n            Date now = new Date();\n\n            // for some odd reason, this will give LONG_MAX if the\n            // computed value is > LONG_MAX.\n            long val = (long) (rand.nextGaussian() * 1000.0);\n\n            try {\n                // Do an vanilla insert.\n                if (!app.config.inline) {\n                    basicInsert(uuid, val, now);\n                }\n                // Do an insert with date-based deleting\n                else if (app.config.historyseconds > 0) {\n                    insertWithDateDelete(uuid, val, now);\n                }\n                // Do an insert with timestamp-based deleting\n                else if (app.config.maxrows > 0) {\n                    insertWithRowcountDelete(uuid, val, now);\n                }\n            }\n            catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        try {\n            client.drain();\n            client.close();\n        }\n        catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void printReport() {\n        ClientStats stats = periodicStatsContext.fetchAndResetBaseline().getStats();\n\n        System.out.printf(\"  Insert Statistics:\\n    Throughput %d/s, \", stats.getTxnThroughput());\n        System.out.printf(\"Aborts/Failures %d/%d, \",\n                          stats.getInvocationAborts(),\n                          stats.getInvocationErrors());\n        System.out.printf(\"Avg/95%% Latency %.2f/%dms\",\n                          stats.getAverageLatency(),\n                          stats.kPercentileLatency(0.95));\n        System.out.printf(\"\\n\");\n    }","id":106073,"modified_method":"void printReport() {\n        // Get the client stats since the last time this method was called.\n        ClientStats stats = periodicStatsContext.fetchAndResetBaseline().getStats();\n\n        System.out.printf(\"  Insert Statistics:\\n\" +\n                          \"    Throughput %d/s, Aborts/Failures %d/%d, Avg/95%% Latency %.2f/%dms\\n\",\n                          stats.getTxnThroughput(),\n                          stats.getInvocationAborts(),\n                          stats.getInvocationErrors(),\n                          stats.getAverageLatency(),\n                          stats.kPercentileLatency(0.95));\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"RandomDataInserter(GlobalState state, Client client) {\n        this.state = state;\n        this.client = client;\n\n        periodicStatsContext = client.createStatsContext();\n        fullStatsContext = client.createStatsContext();\n    }","id":106074,"modified_method":"RandomDataInserter(WindowingApp app, Client client) {\n        this.app = app;\n        this.client = client;\n\n        // Tracks client-side stats like invocation counts and end2end latency\n        periodicStatsContext = client.createStatsContext();\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        Map<Integer, Long> averagesForWindows = new TreeMap<Integer, Long>();\n        for (int seconds : new int[] { 1, 5, 10, 30 }) {\n            try {\n                ClientResponse cr = state.client.callProcedure(\"Average\", seconds);\n                long average = cr.getResults()[0].asScalarLong();\n                averagesForWindows.put(seconds, average);\n            } catch (IOException | ProcCallException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        synchronized(state) {\n            long now = System.currentTimeMillis();\n            long time = Math.round((now - state.benchmarkStartTS) / 1000.0);\n\n            System.out.printf(\"%02d:%02d:%02d Report:\\n\", time / 3600, (time / 60) % 60, time % 60);\n\n            System.out.println(\"  Average values over time windows:\");\n            for (Entry<Integer, Long> e : averagesForWindows.entrySet()) {\n                System.out.printf(\"    Average for past %2ds: %d\\n\", e.getKey(), e.getValue());\n            }\n\n            inserter.printReport();\n\n            System.out.println();\n            System.out.flush();\n        }\n    }","id":106075,"modified_method":"@Override\n    public void run() {\n        Map<Integer, Long> averagesForWindows = new TreeMap<Integer, Long>();\n        for (int seconds : new int[] { 1, 5, 10, 30 }) {\n            try {\n                ClientResponse cr = app.client.callProcedure(\"Average\", seconds);\n                long average = cr.getResults()[0].asScalarLong();\n                averagesForWindows.put(seconds, average);\n            } catch (IOException | ProcCallException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        synchronized(app) {\n            long now = System.currentTimeMillis();\n            long time = Math.round((now - app.benchmarkStartTS) / 1000.0);\n\n            System.out.printf(\"%02d:%02d:%02d Report:\\n\", time / 3600, (time / 60) % 60, time % 60);\n\n            System.out.println(\"  Average values over time windows:\");\n            for (Entry<Integer, Long> e : averagesForWindows.entrySet()) {\n                System.out.printf(\"    Average for past %2ds: %d\\n\", e.getKey(), e.getValue());\n            }\n\n            app.inserter.printReport();\n\n            System.out.println();\n            System.out.flush();\n        }\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Main routine creates a benchmark instance and kicks off the run method.\n     *\n     * @param args Command line arguments.\n     * @throws Exception if anything goes wrong.\n     * @see {@link VoterConfig}\n     */\n    public static void main(String[] args) throws Exception {\n        // create a configuration from the arguments\n        WindowingConfig config = new WindowingConfig();\n        config.parse(WindowingApp.class.getName(), args);\n\n        WindowingApp app = new WindowingApp(config);\n        app.runBenchmark();\n    }","id":106076,"modified_method":"/**\n     * Main routine creates an instance of this app and kicks off the run method.\n     *\n     * @param args Command line arguments.\n     * @throws Exception if anything goes wrong.\n     * @see {@link WindowingConfig}\n     */\n    public static void main(String[] args) throws Exception {\n        // create a configuration from the arguments\n        WindowingConfig config = new WindowingConfig();\n        config.parse(WindowingApp.class.getName(), args);\n\n        WindowingApp app = new WindowingApp(config);\n        app.run();\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    public WindowingApp(WindowingConfig config) {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Command Line Configuration\");\n        System.out.println(HORIZONTAL_RULE);\n\n        System.out.println(config.getConfigDumpString());\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        ClientConfig clientConfig = new ClientConfig(config.user, config.password, new StatusListener());\n        clientConfig.setMaxTransactionsPerSecond(config.ratelimit);\n\n        Client insertsClient = ClientFactory.createClient(clientConfig);\n        Client nonInsertsClient = ClientFactory.createClient(clientConfig);\n\n        // connect to one or more servers, loop until success\n        try {\n            connect(insertsClient, config.servers);\n            connect(nonInsertsClient, config.servers);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        state = new GlobalState(config, nonInsertsClient);\n\n        partitionTracker = new PartitionDataTracker(state);\n        deleter = new ContinuousDeleter(state);\n        inserter = new RandomDataInserter(state, insertsClient);\n        maxTracker = new MaxTracker(state);\n        reporter = new Reporter(state, inserter);\n    }","id":106077,"modified_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    public WindowingApp(WindowingConfig config) {\n        this.config = config;\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Command Line Configuration\");\n        System.out.println(HORIZONTAL_RULE);\n\n        System.out.println(config.getConfigDumpString());\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        ClientConfig clientConfig = new ClientConfig(config.user, config.password, new StatusListener());\n        clientConfig.setMaxTransactionsPerSecond(config.ratelimit);\n\n        Client insertsClient = ClientFactory.createClient(clientConfig);\n        client = ClientFactory.createClient(clientConfig);\n\n        // connect to one or more servers, loop until success\n        try {\n            connect(insertsClient, config.servers);\n            connect(client, config.servers);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        partitionTracker = new PartitionDataTracker(this);\n        deleter = new ContinuousDeleter(this);\n        inserter = new RandomDataInserter(this, insertsClient);\n        maxTracker = new MaxTracker(this);\n        reporter = new Reporter(this);\n    }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            // if the benchmark is still active\n            if (inserter.isDone() == false) {\n                System.err.printf(\"Connection to %s:%d was lost.\\n\", hostname, port);\n            }\n        }","id":106078,"modified_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            // if the benchmark is still active, note if a server disconnects\n            final long benchmarkEndTime = benchmarkStartTS + (1000l * config.duration);\n            if (System.currentTimeMillis() < benchmarkEndTime) {\n                System.err.printf(\"Connection to %s:%d was lost.\\n\", hostname, port);\n            }\n        }","commit_id":"df2a115747fac1f8ec2e00c95d060ff53c69b287","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static boolean check(Client client) {\n        long mirrorRows = MatchChecks.getMirrorTableRowCount(client);\n        long importRows = MatchChecks.getImportTableRowCount(client);\n\n        System.out.println(\"Rows remaining in the Mirror Table: \" + mirrorRows);\n        System.out.println(\"Rows remaining in the Import Table: \" + importRows);\n        if (importRows != 0 || mirrorRows != 0) {\n            return false;\n        }\n        return true;\n    }","id":106079,"modified_method":"static boolean check(Client client) {\n        long mirrorRows = MatchChecks.getMirrorTableRowCount(client);\n        long importRows = MatchChecks.getImportTableRowCount(client);\n\n        log.info(\"Rows remaining in the Mirror Table: \" + mirrorRows);\n        log.info(\"Rows remaining in the Import Table: \" + importRows);\n        if (importRows != 0 || mirrorRows != 0) {\n            return false;\n        }\n        return true;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void insertFinal(long key, long value) {\n        try {\n            m_client.callProcedure(new InsertCallback(INSERT_PN, key, value), INSERT_PN, key, value);\n        } catch (IOException e) {\n            System.out.println(\"Exception calling stored procedure InsertFinal\");\n            e.printStackTrace();\n        }\n    }","id":106080,"modified_method":"public void insertFinal(long key, long value) {\n        try {\n            m_client.callProcedure(new InsertCallback(INSERT_PN, key, value), INSERT_PN, key, value);\n        } catch (IOException e) {\n            log.info(\"Exception calling stored procedure InsertFinal\");\n            e.printStackTrace();\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void insertExport(long key, long value) {\n        try {\n            m_client.callProcedure(new InsertCallback(EXPORT_PN, key, value), EXPORT_PN, key, value);\n        } catch (IOException e) {\n            System.out.println(\"Exception calling stored procedure InsertExport\");\n            e.printStackTrace();\n        }\n    }","id":106081,"modified_method":"public void insertExport(long key, long value) {\n        try {\n            m_client.callProcedure(new InsertCallback(EXPORT_PN, key, value), EXPORT_PN, key, value);\n        } catch (IOException e) {\n            log.info(\"Exception calling stored procedure InsertExport\");\n            e.printStackTrace();\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse)\n                throws Exception {\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                String msg = String.format(\"%s k: %12d, v: %12d callback fault: %s\", proc, key, value, clientResponse.getStatusString());\n                System.err.println(msg);\n            }\n        }","id":106082,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse)\n                throws Exception {\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                String msg = String.format(\"%s k: %12d, v: %12d callback fault: %s\", proc, key, value, clientResponse.getStatusString());\n                log.error(msg);\n            }\n        }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Prints a one line update on performance that can be printed\n     * periodically during a benchmark.\n     */\n    public synchronized void printStatistics() {\n        ClientStats stats = periodicStatsContext.fetchAndResetBaseline().getStats();\n        long time = Math.round((stats.getEndTimestamp() - benchmarkStartTS) / 1000.0);\n        long thrup;\n\n        System.out.printf(\"%02d:%02d:%02d \", time / 3600, (time / 60) % 60, time % 60);\n        thrup = stats.getTxnThroughput();\n        System.out.printf(\"Throughput %d/s, \", thrup);\n        System.out.printf(\"Aborts/Failures %d/%d, \",\n                stats.getInvocationAborts(), stats.getInvocationErrors());\n        System.out.printf(\"Avg/95%% Latency %.2f/%.2fms\\n\", stats.getAverageLatency(),\n                stats.kPercentileLatencyAsDouble(0.95));\n    }","id":106083,"modified_method":"/**\n     * Prints a one line update on performance that can be printed\n     * periodically during a benchmark.\n     */\n    public synchronized void printStatistics() {\n        ClientStats stats = periodicStatsContext.fetchAndResetBaseline().getStats();\n        long time = Math.round((stats.getEndTimestamp() - benchmarkStartTS) / 1000.0);\n        long thrup;\n\n        thrup = stats.getTxnThroughput();\n        log.info(String.format(\"Throughput %d/s, Aborts/Failures %d/%d, Avg/95%% Latency %.2f/%.2fms\",\n                    thrup, stats.getInvocationAborts(), stats.getInvocationErrors(),\n                    stats.getAverageLatency(), stats.kPercentileLatencyAsDouble(0.95)));\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Connect to one or more VoltDB servers.\n     *\n     * @param servers A comma separated list of servers using the hostname:port\n     * syntax (where :port is optional). Assumes 21212 if not specified otherwise.\n     * @throws InterruptedException if anything bad happens with the threads.\n     */\n    static void dbconnect(String servers) throws InterruptedException, Exception {\n        final Splitter COMMA_SPLITTER = Splitter.on(\",\").omitEmptyStrings().trimResults();\n\n        System.out.println(\"Connecting to VoltDB Interface...\");\n        client = ClientFactory.createClient();\n\n        for (String server: COMMA_SPLITTER.split(servers)) {\n            System.out.println(\"...\" + server);\n            client.createConnection(server);\n        }\n    }","id":106084,"modified_method":"/**\n     * Connect to one or more VoltDB servers.\n     *\n     * @param servers A comma separated list of servers using the hostname:port\n     * syntax (where :port is optional). Assumes 21212 if not specified otherwise.\n     * @throws InterruptedException if anything bad happens with the threads.\n     */\n    static void dbconnect(String servers) throws InterruptedException, Exception {\n        final Splitter COMMA_SPLITTER = Splitter.on(\",\").omitEmptyStrings().trimResults();\n\n        log.info(\"Connecting to VoltDB Interface...\");\n        client = ClientFactory.createClient();\n\n        for (String server: COMMA_SPLITTER.split(servers)) {\n            log.info(\"...\" + server);\n            client.createConnection(server);\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void validate() {\n            if (duration <= 0) exitWithMessageAndUsage(\"duration must be > 0\");\n            if (warmup < 0) exitWithMessageAndUsage(\"warmup must be >= 0\");\n            if (displayinterval <= 0) exitWithMessageAndUsage(\"displayinterval must be > 0\");\n            System.out.println(\"finished arg validate\");\n        }","id":106085,"modified_method":"@Override\n        public void validate() {\n            if (duration <= 0) exitWithMessageAndUsage(\"duration must be > 0\");\n            if (warmup < 0) exitWithMessageAndUsage(\"warmup must be >= 0\");\n            if (displayinterval <= 0) exitWithMessageAndUsage(\"displayinterval must be > 0\");\n            log.info(\"finished arg validate\");\n        }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        SecureRandom rnd = new SecureRandom();\n        rnd.setSeed(System.identityHashCode(Thread.currentThread()));\n        long icnt = 0;\n        try {\n            // Run the benchmark loop for the requested warmup time\n            // The throughput may be throttled depending on client configuration\n            System.out.println(\"Warming up...\");\n            final long warmupEndTime = System.currentTimeMillis() + (1000l * config.warmup);\n            while (warmupEndTime > System.currentTimeMillis()) {\n                long value = System.currentTimeMillis();\n                long key = rnd.nextLong();\n                exportProc.insertExport(key, value);\n                icnt++;\n            }\n\n            // print periodic statistics to the console\n            benchmarkStartTS = System.currentTimeMillis();\n            schedulePeriodicStats();\n\n            System.out.println(\"starting data checker...\");\n            checkTimer = matchChecks.checkTimer(5000, client);\n\n            // Run the benchmark loop for the requested duration\n            // The throughput may be throttled depending on client configuration\n            // Save the key/value pairs so they can be verified through the database\n            System.out.println(\"\\nRunning benchmark...\");\n            final long benchmarkEndTime = System.currentTimeMillis() + (1000l * config.duration);\n            while (benchmarkEndTime > System.currentTimeMillis()) {\n                long value = System.currentTimeMillis();\n                long key = rnd.nextLong();\n                exportProc.insertExport(key, value);\n                icnt++;\n            }\n            // check for export completion\n            exportMon.waitForStreamedAllocatedMemoryZero();\n            importMon.waitForStreamedAllocatedMemoryZero();\n            exportProc.insertFinal(-1, -1);\n            System.out.println(\"Done waiting for import & export tables\");\n        } finally {\n            // cancel periodic stats printing\n            System.out.println(\"Cancel periodic stats\");\n            statsTimer.cancel();\n            finalInsertCount.addAndGet(icnt);\n        }\n    }","id":106086,"modified_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        log.info(HORIZONTAL_RULE);\n        log.info(\"Setup & Initialization\");\n        log.info(HORIZONTAL_RULE);\n\n        log.info(HORIZONTAL_RULE);\n        log.info(\"Starting Benchmark\");\n        log.info(HORIZONTAL_RULE);\n\n        SecureRandom rnd = new SecureRandom();\n        rnd.setSeed(System.identityHashCode(Thread.currentThread()));\n        long icnt = 0;\n        try {\n            // Run the benchmark loop for the requested warmup time\n            // The throughput may be throttled depending on client configuration\n            log.info(\"Warming up...\");\n            final long warmupEndTime = System.currentTimeMillis() + (1000l * config.warmup);\n            while (warmupEndTime > System.currentTimeMillis()) {\n                long value = System.currentTimeMillis();\n                long key = rnd.nextLong();\n                exportProc.insertExport(key, value);\n                icnt++;\n            }\n\n            // print periodic statistics to the console\n            benchmarkStartTS = System.currentTimeMillis();\n            schedulePeriodicStats();\n\n            log.info(\"Starting data checker...\");\n            checkTimer = matchChecks.checkTimer(5000, client);\n\n            // Run the benchmark loop for the requested duration\n            // The throughput may be throttled depending on client configuration\n            // Save the key/value pairs so they can be verified through the database\n            log.info(\"Running benchmark...\");\n            final long benchmarkEndTime = System.currentTimeMillis() + (1000l * config.duration);\n            while (benchmarkEndTime > System.currentTimeMillis()) {\n                long value = System.currentTimeMillis();\n                long key = rnd.nextLong();\n                exportProc.insertExport(key, value);\n                icnt++;\n            }\n            // check for export completion\n            exportMon.waitForStreamedAllocatedMemoryZero();\n            importMon.waitForStreamedAllocatedMemoryZero();\n            exportProc.insertFinal(-1, -1);\n            log.info(\"Done waiting for import & export tables\");\n        } finally {\n            // cancel periodic stats printing\n            log.info(\"Cancel periodic stats\");\n            statsTimer.cancel();\n            finalInsertCount.addAndGet(icnt);\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    public KafkaImportBenchmark(Config config) {\n        this.config = config;\n        periodicStatsContext = client.createStatsContext();\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Command Line Configuration\");\n        System.out.println(HORIZONTAL_RULE);\n        System.out.println(config.getConfigDumpString());\n        if(config.latencyreport) {\n            System.out.println(\"NOTICE: Option latencyreport is ON for async run, please set a reasonable ratelimit.\\n\");\n        }\n    }","id":106087,"modified_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    public KafkaImportBenchmark(Config config) {\n        this.config = config;\n        periodicStatsContext = client.createStatsContext();\n\n        log.info(HORIZONTAL_RULE);\n        log.info(\" Command Line Configuration\");\n        log.info(HORIZONTAL_RULE);\n        log.info(config.getConfigDumpString());\n        if(config.latencyreport) {\n            log.warn(\"Option latencyreport is ON for async run, please set a reasonable ratelimit.\\n\");\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a Timer task to display performance data on the Vote procedure\n     * It calls printStatistics() every displayInterval seconds\n     */\n    public void schedulePeriodicStats() {\n        statsTimer = new Timer();\n        TimerTask statsPrinting = new TimerTask() {\n            @Override\n            public void run() { printStatistics(); }\n        };\n        statsTimer.scheduleAtFixedRate(statsPrinting,\n                                  config.displayinterval * 1000,\n                                  config.displayinterval * 1000);\n    }","id":106088,"modified_method":"/**\n     * Create a Timer task to display performance data on the Vote procedure\n     * It calls printStatistics() every displayInterval seconds\n     */\n    public void schedulePeriodicStats() {\n        statsTimer = new Timer(\"periodicStats\", true);\n        TimerTask statsPrinting = new TimerTask() {\n            @Override\n            public void run() { printStatistics(); }\n        };\n        statsTimer.scheduleAtFixedRate(statsPrinting,\n                                  config.displayinterval * 1000,\n                                  config.displayinterval * 1000);\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Main routine creates a benchmark instance and kicks off the run method.\n     *\n     * @param args Command line arguments.\n     * @throws Exception if anything goes wrong.\n     * @see {@link VoterConfig}\n     */\n    public static void main(String[] args) throws Exception {\n        // create a configuration from the arguments\n        Config config = new Config();\n        config.parse(KafkaImportBenchmark.class.getName(), args);\n\n        // connect to one or more servers, loop until success\n        dbconnect(config.servers);\n\n        // instance handles inserts to Kafka export table and its mirror DB table\n        exportProc = new InsertExport(client);\n\n        // get instances to track track export completion using @Statistics\n        exportMon = new TableChangeMonitor(client, \"StreamedTable\", \"KAFKAEXPORTTABLE1\");\n        importMon = new TableChangeMonitor(client, \"PersistentTable\", \"KAFKAIMPORTTABLE1\");\n\n        System.out.println(\"starting KafkaImportBenchmark...\");\n        KafkaImportBenchmark benchmark = new KafkaImportBenchmark(config);\n        BenchmarkRunner runner = new BenchmarkRunner(benchmark);\n        runner.start();\n\n        // start watcher that compares mirror table which contains all\n        // the export data with the import table that's rows back from Kafka.\n        // Arg is interval to wait between checks\n        // System.out.println(\"starting data checker...\");\n        // @SuppressWarnings(\"static-access\")\n        // Timer t = matchChecks.checkTimer(5000, client);\n\n        runner.join(); // writers are done\n\n        // final check time since the import and export tables have quiesced.\n        // check that the mirror table is empty. If not, that indicates that\n        // not all the rows got to Kafka or not all the rows got imported back.\n        boolean testResult = FinalCheck.check(client);\n\n        checkTimer.cancel();\n        client.drain();\n        client.close();\n\n        if (testResult == true) {\n            System.out.println(\"Test passed!\");\n            System.exit(0);\n        } else {\n            System.out.println(\"Test failed!\");\n            System.exit(1);\n        }\n    }","id":106089,"modified_method":"/**\n     * Main routine creates a benchmark instance and kicks off the run method.\n     *\n     * @param args Command line arguments.\n     * @throws Exception if anything goes wrong.\n     * @see {@link VoterConfig}\n     */\n    public static void main(String[] args) throws Exception {\n        VoltLogger log = new VoltLogger(\"Benchmark.main\");\n        // create a configuration from the arguments\n        Config config = new Config();\n        config.parse(KafkaImportBenchmark.class.getName(), args);\n\n        // connect to one or more servers, loop until success\n        dbconnect(config.servers);\n\n        // instance handles inserts to Kafka export table and its mirror DB table\n        exportProc = new InsertExport(client);\n\n        // get instances to track track export completion using @Statistics\n        exportMon = new TableChangeMonitor(client, \"StreamedTable\", \"KAFKAEXPORTTABLE1\");\n        importMon = new TableChangeMonitor(client, \"PersistentTable\", \"KAFKAIMPORTTABLE1\");\n\n        log.info(\"starting KafkaImportBenchmark...\");\n        KafkaImportBenchmark benchmark = new KafkaImportBenchmark(config);\n        BenchmarkRunner runner = new BenchmarkRunner(benchmark);\n        runner.start();\n\n        // start watcher that compares mirror table which contains all\n        // the export data with the import table that's rows back from Kafka.\n        // Arg is interval to wait between checks\n        // log.info(\"starting data checker...\");\n        // @SuppressWarnings(\"static-access\")\n        // Timer t = matchChecks.checkTimer(5000, client);\n\n        runner.join(); // writers are done\n\n        // final check time since the import and export tables have quiesced.\n        // check that the mirror table is empty. If not, that indicates that\n        // not all the rows got to Kafka or not all the rows got imported back.\n        boolean testResult = FinalCheck.check(client);\n\n        checkTimer.cancel();\n        client.drain();\n        client.close();\n\n        if (testResult == true) {\n            log.info(\"Test passed!\");\n            System.exit(0);\n        } else {\n            log.info(\"Test failed!\");\n            System.exit(1);\n        }\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) {\n\n            // Make sure the procedure succeeded. If not,\n            // report the error.\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                String msg = String.format(\"%s k: %12d, callback fault: %s\", proc, key, clientResponse.getStatusString());\n                System.err.println(msg);\n              }\n         }","id":106090,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) {\n\n            // Make sure the procedure succeeded. If not,\n            // report the error.\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                String msg = String.format(\"%s k: %12d, callback fault: %s\", proc, key, clientResponse.getStatusString());\n                log.error(msg);\n              }\n         }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static long getImportTableRowCount(Client client) {\n        // check row count in import table\n        long importRowCount = 0;\n        try {\n            VoltTable[] countQueryResult = client.callProcedure(\"CountImport\").getResults();\n            importRowCount = countQueryResult[0].asScalarLong();\n        } catch (IOException | ProcCallException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Import table row count: \" + importRowCount);\n        return importRowCount;\n    }","id":106091,"modified_method":"public static long getImportTableRowCount(Client client) {\n        // check row count in import table\n        long importRowCount = 0;\n        try {\n            VoltTable[] countQueryResult = client.callProcedure(\"CountImport\").getResults();\n            importRowCount = countQueryResult[0].asScalarLong();\n        } catch (IOException | ProcCallException e) {\n            e.printStackTrace();\n        }\n        log.info(\"Import table row count: \" + importRowCount);\n        return importRowCount;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected static Timer checkTimer(long interval, Client client) {\n        final Timer timer = new Timer();\n        final Client innerClient = client;\n        timer.scheduleAtFixedRate(new TimerTask() {\n            private long mirrorRowCount = 0;\n\n            @Override\n            public void run() {\n                mirrorRowCount = getMirrorTableRowCount(innerClient);\n                System.out.println(\"\\tDelete rows: \" + findAndDeleteMatchingRows(innerClient));\n                System.out.println(\"\\tMirror table row count: \" + mirrorRowCount);\n                if (mirrorRowCount == 0) { // indicates everything matched and mirror table empty\n                    System.out.println(\"mirrorRowCount is 0. Stopping...\");\n                    timer.cancel();\n                    timer.purge();\n                }\n            }\n        }, 0, interval);\n        return timer;\n    }","id":106092,"modified_method":"protected static Timer checkTimer(long interval, Client client) {\n        final Timer timer = new Timer(\"checkTimer\", true);\n        final Client innerClient = client;\n        timer.scheduleAtFixedRate(new TimerTask() {\n            private long mirrorRowCount = 0;\n\n            @Override\n            public void run() {\n                mirrorRowCount = getMirrorTableRowCount(innerClient);\n                log.info(\"checkTimer: Delete rows: \" + findAndDeleteMatchingRows(innerClient));\n                log.info(\"checkTimer: Mirror table row count: \" + mirrorRowCount);\n                if (mirrorRowCount == 0) { // indicates everything matched and mirror table empty\n                    log.info(\"checkTimer: mirrorRowCount is 0. Stopping...\");\n                    timer.cancel();\n                    timer.purge();\n                }\n            }\n        }, 0, interval);\n        return timer;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected static long getMirrorTableRowCount(Client client) {\n        // check row count in mirror table -- the \"master\" of what should come back\n        // eventually via import\n        long mirrorRowCount = 0;\n        try {\n            VoltTable[] countQueryResult = client.callProcedure(\"CountMirror\").getResults();\n            mirrorRowCount = countQueryResult[0].asScalarLong();\n        } catch (IOException | ProcCallException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Mirror table row count: \" + mirrorRowCount);\n        return mirrorRowCount;\n    }","id":106093,"modified_method":"protected static long getMirrorTableRowCount(Client client) {\n        // check row count in mirror table -- the \"master\" of what should come back\n        // eventually via import\n        long mirrorRowCount = 0;\n        try {\n            VoltTable[] countQueryResult = client.callProcedure(\"CountMirror\").getResults();\n            mirrorRowCount = countQueryResult[0].asScalarLong();\n        } catch (IOException | ProcCallException e) {\n            e.printStackTrace();\n        }\n        log.info(\"Mirror table row count: \" + mirrorRowCount);\n        return mirrorRowCount;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected static long findAndDeleteMatchingRows(Client client) {\n        long rows = 0;\n        VoltTable results = null;\n\n        try {\n            results = client.callProcedure(\"MatchRows\").getResults()[0];\n        } catch (Exception e) {\n             e.printStackTrace();\n             System.exit(-1);\n        }\n\n        System.out.println(\"getRowCount(): \" + results.getRowCount());\n        while (results.advanceRow()) {\n            long key = results.getLong(0);\n            // System.out.println(\"Key: \" + key);\n            try {\n                client.callProcedure(new DeleteCallback(DELETE_ROWS, key), DELETE_ROWS, key);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            rows++;\n        }\n        return rows;\n    }","id":106094,"modified_method":"protected static long findAndDeleteMatchingRows(Client client) {\n        long rows = 0;\n        VoltTable results = null;\n\n        try {\n            results = client.callProcedure(\"MatchRows\").getResults()[0];\n        } catch (Exception e) {\n             e.printStackTrace();\n             System.exit(-1);\n        }\n\n        log.info(\"Matched row count: \" + results.getRowCount());\n        while (results.advanceRow()) {\n            long key = results.getLong(0);\n            // System.out.println(\"Key: \" + key);\n            try {\n                client.callProcedure(new DeleteCallback(DELETE_ROWS, key), DELETE_ROWS, key);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            rows++;\n        }\n        return rows;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Checks the export table to make sure that everything has been successfully\n     * processed.\n     * @throws ProcCallException\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    public boolean waitForStreamedAllocatedMemoryZero() throws ProcCallException,IOException,InterruptedException {\n        boolean passed = false;\n\n        VoltTable stats = null;\n        long ftime = 0;\n        long st = System.currentTimeMillis();\n        //Wait 10 mins only\n        long end = st + (10 * 60 * 1000);\n        while (true) {\n            stats = client.callProcedure(\"@Statistics\", \"table\", 0).getResults()[0];\n            boolean passedThisTime = true;\n            long ctime = System.currentTimeMillis();\n            if (ctime > end) {\n                System.out.println(\"Waited too long...\");\n                System.out.println(stats);\n                break;\n            }\n            if (ctime - st > (3 * 60 * 1000)) {\n                System.out.println(stats);\n                st = System.currentTimeMillis();\n            }\n            long ts = 0;\n            while (stats.advanceRow()) {\n                String ttable = stats.getString(\"TABLE_NAME\");\n                String ttype = stats.getString(\"TABLE_TYPE\");\n                Long tts = stats.getLong(\"TIMESTAMP\");\n                //Get highest timestamp and watch it change\n                if (tts > ts) {\n                    ts = tts;\n                }\n                if (type.equals(ttype) && table.equals(ttable)) {\n                    if (stats.getLong(\"TUPLE_ALLOCATED_MEMORY\") != 0) {\n                        passedThisTime = false;\n                        System.out.println(ttable + \": Partition Not Zero.\");\n                        break;\n                    }\n                }\n            }\n            if (passedThisTime) {\n                if (ftime == 0) {\n                    ftime = ts;\n                    continue;\n                }\n                //we got 0 stats 2 times in row with diff highest timestamp.\n                if (ftime != ts) {\n                    passed = true;\n                    break;\n                }\n                System.out.println(table + \" quiescing but not ready to declare victory.\");\n            }\n            Thread.sleep(5000);\n        }\n        System.out.println(table + \" status is: \" + passed);\n        System.out.println(stats);\n        return passed;\n    }","id":106095,"modified_method":"/**\n     * Checks the export table to make sure that everything has been successfully\n     * processed.\n     * @throws ProcCallException\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    public boolean waitForStreamedAllocatedMemoryZero() throws ProcCallException,IOException,InterruptedException {\n        boolean passed = false;\n\n        VoltTable stats = null;\n        long ftime = 0;\n        long st = System.currentTimeMillis();\n        //Wait 10 mins only\n        long end = st + (10 * 60 * 1000);\n        while (true) {\n            stats = client.callProcedure(\"@Statistics\", \"table\", 0).getResults()[0];\n            boolean passedThisTime = true;\n            long ctime = System.currentTimeMillis();\n            if (ctime > end) {\n                log.info(\"Waited too long...\");\n                log.info(stats);\n                break;\n            }\n            if (ctime - st > (3 * 60 * 1000)) {\n                log.info(stats);\n                st = System.currentTimeMillis();\n            }\n            long ts = 0;\n            while (stats.advanceRow()) {\n                String ttable = stats.getString(\"TABLE_NAME\");\n                //log.info(\"foo \" + ttable);\n                String ttype = stats.getString(6); //(\"TABLE_TYPE\");\n                //log.info(ttype);\n                Long tts = stats.getLong(\"TIMESTAMP\");\n                //Get highest timestamp and watch it change\n                if (tts > ts) {\n                    ts = tts;\n                }\n                if (type.equals(ttype) && table.equals(ttable)) {\n                    if (stats.getLong(\"TUPLE_ALLOCATED_MEMORY\") != 0) {\n                        passedThisTime = false;\n                        log.info(ttable + \": Partition Not Zero.\");\n                        break;\n                    }\n                }\n            }\n            if (passedThisTime) {\n                if (ftime == 0) {\n                    ftime = ts;\n                    continue;\n                }\n                //we got 0 stats 2 times in row with diff highest timestamp.\n                if (ftime != ts) {\n                    passed = true;\n                    break;\n                }\n                log.info(table + \" quiescing but not ready to declare victory.\");\n            }\n            Thread.sleep(5000);\n        }\n        log.info(table + \" status is: \" + passed);\n        log.info(stats);\n        return passed;\n    }","commit_id":"fa50084c51976e75b6c0917f3a17177e3983186e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":106096,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n        try\n        {\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA server: \" + rootPath, e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","id":106097,"modified_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            cachedMaster = new Pair<Master, Machine>( null, Machine.NO_MACHINE );\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master, storeDir );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":106098,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        MasterClient masterClient = null;\n        if ( cachedMaster.other().getMachineId() != master.getMachineId() )\n        {\n            invalidateMaster();\n            if ( master != Machine.NO_MACHINE && \n                    master.getMachineId() != getMyMachineId() )\n            {\n                masterClient = new MasterClient( master, storeDir );\n            }\n            cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        }\n        return cachedMaster;\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        if ( type == RequestType.FINISH )\n        {\n            server.unmapSlave( channel, context );\n        }\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","id":106099,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        if ( type == RequestType.FINISH || type == RequestType.PULL_UPDATES )\n        {\n            server.unmapSlave( channel, context );\n        }\n        return targetBuffer;\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeMillis = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        e.printStackTrace();\n                    }\n                }\n            }, timeMillis, timeMillis, TimeUnit.SECONDS );\n        }\n    }","id":106100,"modified_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeSeconds = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        msgLog.logMessage( \"Pull updates failed\", e  );\n                    }\n                }\n            }, timeSeconds, timeSeconds, TimeUnit.SECONDS );\n        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( master );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","id":106101,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                throw new RuntimeException( msg );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" );\n//                }\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","id":106102,"modified_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                shutdown();\n                throw new RuntimeException( msg );\n            }\n        }\n        catch ( IOException e )\n        {\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","id":106103,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            if ( masterServer == null )\n            {\n                receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n            }\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"231f5ad33cd3b51624a3360c702967eb10d3d85c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master, storeDir );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":106104,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        MasterClient masterClient = null;\n        if ( cachedMaster.other().getMachineId() != master.getMachineId() )\n        {\n            invalidateMaster();\n            if ( master != Machine.NO_MACHINE && \n                    master.getMachineId() != getMyMachineId() )\n            {\n                masterClient = new MasterClient( master, storeDir );\n            }\n            cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        }\n        return cachedMaster;\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":106105,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n        try\n        {\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA server: \" + rootPath, e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","id":106106,"modified_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            cachedMaster = new Pair<Master, Machine>( null, Machine.NO_MACHINE );\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        if ( type == RequestType.FINISH )\n        {\n            server.unmapSlave( channel, context );\n        }\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","id":106107,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        if ( type == RequestType.FINISH || type == RequestType.PULL_UPDATES )\n        {\n            server.unmapSlave( channel, context );\n        }\n        return targetBuffer;\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeMillis = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        e.printStackTrace();\n                    }\n                }\n            }, timeMillis, timeMillis, TimeUnit.SECONDS );\n        }\n    }","id":106108,"modified_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeSeconds = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        msgLog.logMessage( \"Pull updates failed\", e  );\n                    }\n                }\n            }, timeSeconds, timeSeconds, TimeUnit.SECONDS );\n        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                throw new RuntimeException( msg );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" );\n//                }\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","id":106109,"modified_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                shutdown();\n                throw new RuntimeException( msg );\n            }\n        }\n        catch ( IOException e )\n        {\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","id":106110,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            if ( masterServer == null )\n            {\n                receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n            }\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( master );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","id":106111,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","commit_id":"f08fecc2651c4a26ab53f4284a898467d500da8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":106112,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n        try\n        {\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            msgLog.logMessage( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA server: \" + rootPath, e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","id":106113,"modified_method":"public void shutdown()\n    {\n        try\n        {\n            invalidateMaster();\n            cachedMaster = new Pair<Master, Machine>( null, Machine.NO_MACHINE );\n            getZooKeeper().close();\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \n                \"Error closing zookeeper connection\", e );\n        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master, storeDir );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":106114,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        MasterClient masterClient = null;\n        if ( cachedMaster.other().getMachineId() != master.getMachineId() )\n        {\n            invalidateMaster();\n            if ( master != Machine.NO_MACHINE && \n                    master.getMachineId() != getMyMachineId() )\n            {\n                masterClient = new MasterClient( master, storeDir );\n            }\n            cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        }\n        return cachedMaster;\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        if ( type == RequestType.FINISH )\n        {\n            server.unmapSlave( channel, context );\n        }\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","id":106115,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer, Channel channel, MasterServer server ) throws IOException\n    {\n        // TODO Not very pretty solution (to pass in MasterServer here)\n        // but what the heck.\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = null;\n        if ( type.includesSlaveContext() )\n        {\n            context = readSlaveContext( buffer );\n            server.mapSlave( channel, context );\n        }\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        if ( type == RequestType.FINISH || type == RequestType.PULL_UPDATES )\n        {\n            server.unmapSlave( channel, context );\n        }\n        return targetBuffer;\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","id":106116,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            if ( masterServer == null )\n            {\n                receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n            }\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeMillis = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        e.printStackTrace();\n                    }\n                }\n            }, timeMillis, timeMillis, TimeUnit.SECONDS );\n        }\n    }","id":106117,"modified_method":"private void instantiateAutoUpdatePullerIfConfigSaysSo()\n    {\n        String pullInterval = this.config.get( CONFIG_KEY_HA_PULL_INTERVAL );\n        if ( pullInterval != null )\n        {\n            long timeSeconds = TimeUtil.parseTimeMillis( pullInterval );\n            updatePuller = new ScheduledThreadPoolExecutor( 1 );\n            updatePuller.scheduleWithFixedDelay( new Runnable()\n            {\n                public void run()\n                {\n                    try\n                    {\n                        pullUpdates();\n                    }\n                    catch ( Exception e )\n                    {\n                        msgLog.logMessage( \"Pull updates failed\", e  );\n                    }\n                }\n            }, timeSeconds, timeSeconds, TimeUnit.SECONDS );\n        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( master );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","id":106118,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n//        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n//        {\n//            return;\n//        }\n//        try\n//        {\n        if ( master == null )\n        {\n            master = broker.getMasterReally();\n        }\n\n        boolean restarted = false;\n        boolean iAmCurrentlyMaster = masterServer != null;\n        msgLog.logMessage( \"ReevaluateMyself: machineId=\" + machineId + \" with master[\" + master +\n                \"] (I am master=\" + iAmCurrentlyMaster + \")\" );\n        if ( master.other().getMachineId() == machineId )\n        {\n            // I am master\n            if ( this.localGraph == null || !iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsMaster();\n                restarted = true;\n            }\n            // fire rebound event\n            broker.rebindMaster();\n        }\n        else\n        {\n            if ( this.localGraph == null || iAmCurrentlyMaster )\n            {\n                internalShutdown();\n                startAsSlave();\n                restarted = true;\n            }\n            tryToEnsureIAmNotABrokenMachine( broker.getMaster() );\n        }\n\n        if ( restarted )\n        {\n            for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n            {\n                this.localGraph.registerTransactionEventHandler( handler );\n            }\n            for ( KernelEventHandler handler : kernelEventHandlers )\n            {\n                this.localGraph.registerKernelEventHandler( handler );\n            }\n            this.localDataSourceManager =\n                    localGraph.getConfig().getTxModule().getXaDataSourceManager();\n        }\n//        }\n//        finally\n//        {\n//            reevaluatingMyself.set( false );\n//        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                throw new RuntimeException( msg );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" );\n//                }\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","id":106119,"modified_method":"private void tryToEnsureIAmNotABrokenMachine( Pair<Master, Machine> master )\n    {\n        try\n        {\n            if ( master.other().getMachineId() == machineId )\n            {\n                return;\n            }\n\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long myLastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long highestCommonTxId = Math.min( myLastCommittedTx, master.other().getLastCommittedTxId() );\n            int masterForMyHighestCommonTxId = nioneoDataSource.getMasterForCommittedTx( highestCommonTxId );\n            int masterForMastersHighestCommonTxId = master.first().getMasterIdForCommittedTx( highestCommonTxId );\n\n            // Compare those two, if equal -> good\n            if ( masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId )\n            {\n                return;\n            }\n            else\n            {\n                String msg = \"Broken store, my last committed tx,machineId[\" +\n                    myLastCommittedTx + \",\" + masterForMyHighestCommonTxId +\n                    \"] but master says machine id for that txId is \" + masterForMastersHighestCommonTxId;\n                msgLog.logMessage( msg );\n                shutdown();\n                throw new RuntimeException( msg );\n            }\n        }\n        catch ( IOException e )\n        {\n            shutdown();\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"a07412af6d1c3187e19688ca39299ea3e84d8584","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        if (containers != null && !containers.isEmpty()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Adding containers:\");\n            for (String container : containers) {\n                builder.append(\" \").append(container);\n            }\n            builder.append(\" to the ensemble. This may take a while.\");\n            System.out.println(builder.toString());\n            service.addToCluster(containers);\n        }\n        return null;\n    }","id":106120,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        if (containers != null && !containers.isEmpty()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Adding containers:\");\n            for (String container : containers) {\n                builder.append(\" \").append(container);\n            }\n            builder.append(\" to the ensemble. This may take a while.\");\n            System.out.println(builder.toString());\n\t\t\tif (generateZookeeperPassword) {\n\t\t\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build();\n\t\t\t\tservice.addToCluster(containers, options);\n\t\t\t} else if (zookeeperPassword == null || zookeeperPassword.isEmpty()) {\n\t\t\t\tservice.addToCluster(containers);\n\t\t\t} else {\n\t\t\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build().zookeeperPassword(zookeeperPassword);\n\t\t\t\tservice.addToCluster(containers, options);\n\t\t\t}\n\t\t}\n        return null;\n    }","commit_id":"51f91d49a6e2a043ffdf7a0b1a33dd68304bf4a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        service.removeFromCluster(containers);\n        return null;\n    }","id":106121,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"Removing containers:\");\n\t\tfor (String container : containers) {\n\t\t\tbuilder.append(\" \").append(container);\n\t\t}\n\t\tbuilder.append(\" from the ensemble. This may take a while.\");\n\t\tSystem.out.println(builder.toString());\n\n\t\tif (generateZookeeperPassword) {\n\t\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build();\n\t\t\tservice.removeFromCluster(containers, options);\n\t\t} else if (zookeeperPassword == null || zookeeperPassword.isEmpty()) {\n\t\t\tservice.removeFromCluster(containers);\n\t\t} else {\n\t\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build().zookeeperPassword(zookeeperPassword);\n\t\t\tservice.removeFromCluster(containers, options);\n\t\t}\n        return null;\n    }","commit_id":"51f91d49a6e2a043ffdf7a0b1a33dd68304bf4a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void addToCluster(List<String> containers) {\n        try {\n            List<String> current = getEnsembleContainers();\n            current.addAll(containers);\n            createCluster(current);\n        } catch (Exception e) {\n            throw new FabricException(\"Unable to add containers to fabric ensemble: \" + e.getMessage(), e);\n        }\n    }","id":106122,"modified_method":"public void addToCluster(List<String> containers) {\n\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build();\n\t\toptions.setZookeeperPassword(fabricService.getZookeeperPassword());\n\t\taddToCluster(containers, options);\n    }","commit_id":"51f91d49a6e2a043ffdf7a0b1a33dd68304bf4a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void removeFromCluster(List<String> containers) {\n        try {\n            List<String> current = getEnsembleContainers();\n            current.removeAll(containers);\n            createCluster(current);\n        } catch (Exception e) {\n            throw new FabricException(\"Unable to remove containers to fabric ensemble: \" + e.getMessage(), e);\n        }\n    }","id":106123,"modified_method":"public void removeFromCluster(List<String> containers) {\n\t\tCreateEnsembleOptions options = CreateEnsembleOptions.build();\n\t\toptions.setZookeeperPassword(fabricService.getZookeeperPassword());\n\t\tremoveFromCluster(containers, options);\n    }","commit_id":"51f91d49a6e2a043ffdf7a0b1a33dd68304bf4a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        Set<String> providers = computeProviderListener.getInstalledProviders();\n        if (providers != null && !providers.isEmpty()) {\n            printComputeProviders(providers,computeServices, \"\", System.out);\n        } else {\n            System.out.print(\"No providers have been found.\");\n        }\n        return null;\n    }","id":106124,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        Set<String> providers = computeProviderListener.getInstalledProviders();\n        if (providers != null && !providers.isEmpty()) {\n            printComputeProviders(providers,computeServices, \"\", System.out);\n        } else {\n            System.out.println(\"No providers have been found.\");\n        }\n        return null;\n    }","commit_id":"7ea13e37494961d04f6a2faba1732b840d727d18","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        service.addToCluster(containers);\n        return null;\n    }","id":106125,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        if (containers != null && !containers.isEmpty()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Adding containers:\");\n            for (String container : containers) {\n                builder.append(\" \").append(container);\n            }\n            builder.append(\" to the ensemble. This may take a while.\");\n            System.out.println(builder.toString());\n            service.addToCluster(containers);\n        }\n        return null;\n    }","commit_id":"7ea13e37494961d04f6a2faba1732b840d727d18","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        Set<String> providers = computeProviderListener.getInstalledProviders();\n        if (providers != null && !providers.isEmpty()) {\n            printComputeProviders(providers,computeServices, \"\", System.out);\n        } else {\n            System.out.print(\"No providers have been found.\");\n        }\n        return null;\n    }","id":106126,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        Set<String> providers = computeProviderListener.getInstalledProviders();\n        if (providers != null && !providers.isEmpty()) {\n            printComputeProviders(providers,computeServices, \"\", System.out);\n        } else {\n            System.out.println(\"No providers have been found.\");\n        }\n        return null;\n    }","commit_id":"a221480ed3ede47b61413f9c4bf11913cb796658","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        service.addToCluster(containers);\n        return null;\n    }","id":106127,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        if (containers != null && !containers.isEmpty()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Adding containers:\");\n            for (String container : containers) {\n                builder.append(\" \").append(container);\n            }\n            builder.append(\" to the ensemble. This may take a while.\");\n            System.out.println(builder.toString());\n            service.addToCluster(containers);\n        }\n        return null;\n    }","commit_id":"a221480ed3ede47b61413f9c4bf11913cb796658","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected Artifact createArtifact( String artifactId, String version, String type )\n    {\n        return new DefaultArtifact( \"maven\", artifactId, version, type );\n    }","id":106128,"modified_method":"protected Artifact createArtifact( String artifactId, String version, String type )\n    {\n        return createArtifact( \"maven\", artifactId, version, type );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0\" );\n        deleteLocalArtifact( j );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"i\" ) )\n                {\n                    dependencies.add( new DefaultArtifact( \"maven\", \"j\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( i,\n                                                                                remoteRepositories(),\n                                                                                localRepository(),\n                                                                                mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().containsKey( i.getId() ) );\n\n        assertTrue( result.getArtifacts().containsKey( j.getId() ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","id":106129,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0\" );\n        deleteLocalArtifact( j );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"i\" ) )\n                {\n                    dependencies.add( createArtifact( \"maven\", \"j\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( i, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().containsKey( i.getId() ) );\n\n        assertTrue( result.getArtifacts().containsKey( j.getId() ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"g\" ) )\n                {\n                    dependencies.add( new DefaultArtifact( \"maven\", \"h\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( g,\n                                                                                remoteRepositories(),\n                                                                                localRepository(),\n                                                                                mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().containsKey( g.getId() ) );\n\n        assertTrue( result.getArtifacts().containsKey( h.getId() ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","id":106130,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"g\" ) )\n                {\n                    dependencies.add( createArtifact( \"maven\", \"h\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( g, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().containsKey( g.getId() ) );\n\n        assertTrue( result.getArtifacts().containsKey( h.getId() ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public DefaultArtifact( String groupId, String artifactId, String version, String scope, String type, \n                            String extension )\n    {\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n        this.type = type;\n        this.scope = scope;\n        this.extension = extension;\n    }","id":106131,"modified_method":"/**\n     * @todo this should be replaced by type handler\n     */\n    public DefaultArtifact( String groupId, String artifactId, String version, String scope, String type,\n                            String extension )\n    {\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n        this.type = type;\n        this.scope = scope;\n        this.extension = extension;\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public DefaultArtifact( String groupId, String artifactId, String version, String type )\n    {\n        this( groupId, artifactId, version, type, type );\n    }","id":106132,"modified_method":"public DefaultArtifact( String groupId, String artifactId, String version, String type )\n    {\n        this( groupId, artifactId, version, null, type, type );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public Set createArtifacts( List dependencies, ArtifactRepository localRepository )\n    {\n        Set projectArtifacts = new HashSet();\n\n        for ( Iterator i = dependencies.iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n\n            Artifact artifact = createArtifact( d, localRepository );\n\n            projectArtifacts.add( artifact );\n        }\n\n        return projectArtifacts;\n    }","id":106133,"modified_method":"public Set createArtifacts( List dependencies, ArtifactRepository localRepository, String inheritedScope )\n    {\n        Set projectArtifacts = new HashSet();\n\n        for ( Iterator i = dependencies.iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n\n            Artifact artifact = createArtifact( d, localRepository, inheritedScope );\n            if ( artifact != null )\n            {\n                projectArtifacts.add( artifact );\n            }\n        }\n\n        return projectArtifacts;\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public Artifact createArtifact( Dependency dependency, ArtifactRepository localRepository )\n    {\n        Artifact artifact = new DefaultArtifact( dependency.getGroupId(),\n                                                 dependency.getArtifactId(),\n                                                 dependency.getVersion(),\n                                                 dependency.getScope(),\n                                                 dependency.getType(),\n                                                 dependency.getType() );\n\n        return artifact;\n    }","id":106134,"modified_method":"public Artifact createArtifact( Dependency dependency, ArtifactRepository localRepository, String inheritedScope )\n    {\n        return createArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(),\n                               dependency.getScope(), dependency.getType(), dependency.getType(), inheritedScope );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject build( File projectDescriptor, ArtifactRepository localRepository, boolean resolveDependencies )\n        throws ProjectBuildingException\n    {\n        try\n        {\n            Model superModel = getSuperModel();\n\n            LinkedList lineage = new LinkedList();\n\n            Set aggregatedRemoteWagonRepositories = RepositoryUtils.mavenToWagon( superModel.getRepositories() );\n            MavenProject project = assembleLineage( projectDescriptor, localRepository, lineage,\n                                                    aggregatedRemoteWagonRepositories );\n\n            Model previous = superModel;\n\n            for ( Iterator i = lineage.iterator(); i.hasNext(); )\n            {\n                Model current = ( (MavenProject) i.next() ).getModel();\n\n                modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n                previous = current;\n            }\n\n            Model model = modelInterpolator.interpolate( project.getModel() );\n\n            // interpolation is before injection, because interpolation is off-limits in the injected variables\n            modelDefaultsInjector.injectDefaults( model );\n\n            MavenProject parentProject = project.getParent();\n\n            project = new MavenProject( model );\n            project.setFile( projectDescriptor );\n            project.setParent( parentProject );\n            project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository ) );\n\n            // ----------------------------------------------------------------------\n            // Typically when the project builder is being used from maven proper\n            // the transitive dependencies will not be resolved here because this\n            // requires a lot of work when we may only be interested in running\n            // something simple like 'm2 clean'. So the artifact collector is used\n            // in the dependency resolution phase if it is required by any of the\n            // goals being executed. But when used as a component in another piece\n            // of code people may just want to build maven projects and have the\n            // dependencies resolved for whatever reason: this is why we keep\n            // this snippet of code here.\n            // ----------------------------------------------------------------------\n\n            if ( resolveDependencies )\n            {\n                Set repos = RepositoryUtils.mavenToWagon( project.getRepositories() );\n\n                MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(), repos,\n                                                                                        localRepository, sourceReader );\n\n                project.getArtifacts().addAll( result.getArtifacts().values() );\n            }\n\n            ModelValidationResult validationResult = validator.validate( project.getModel() );\n\n            if ( validationResult.getMessageCount() > 0 )\n            {\n                throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n            }\n\n            project.setFile( projectDescriptor );\n\n            pathTranslator.alignToBaseDirectory( project.getModel(), projectDescriptor );\n\n            project.addCompileSourceRoot( project.getBuild().getSourceDirectory() );\n            project.addTestCompileSourceRoot( project.getBuild().getUnitTestSourceDirectory() );\n\n            return project;\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \" + projectDescriptor, e );\n        }\n    }","id":106135,"modified_method":"public MavenProject build( File projectDescriptor, ArtifactRepository localRepository, boolean resolveDependencies )\n        throws ProjectBuildingException\n    {\n        try\n        {\n            Model superModel = getSuperModel();\n\n            LinkedList lineage = new LinkedList();\n\n            Set aggregatedRemoteWagonRepositories = RepositoryUtils.mavenToWagon( superModel.getRepositories() );\n            MavenProject project = assembleLineage( projectDescriptor, localRepository, lineage,\n                                                    aggregatedRemoteWagonRepositories );\n\n            Model previous = superModel;\n\n            for ( Iterator i = lineage.iterator(); i.hasNext(); )\n            {\n                Model current = ( (MavenProject) i.next() ).getModel();\n\n                modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n                previous = current;\n            }\n\n            Model model = modelInterpolator.interpolate( project.getModel() );\n\n            // interpolation is before injection, because interpolation is off-limits in the injected variables\n            modelDefaultsInjector.injectDefaults( model );\n\n            MavenProject parentProject = project.getParent();\n\n            project = new MavenProject( model );\n            project.setFile( projectDescriptor );\n            project.setParent( parentProject );\n            project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository, null ) );\n\n            // ----------------------------------------------------------------------\n            // Typically when the project builder is being used from maven proper\n            // the transitive dependencies will not be resolved here because this\n            // requires a lot of work when we may only be interested in running\n            // something simple like 'm2 clean'. So the artifact collector is used\n            // in the dependency resolution phase if it is required by any of the\n            // goals being executed. But when used as a component in another piece\n            // of code people may just want to build maven projects and have the\n            // dependencies resolved for whatever reason: this is why we keep\n            // this snippet of code here.\n            // ----------------------------------------------------------------------\n\n            if ( resolveDependencies )\n            {\n                Set repos = RepositoryUtils.mavenToWagon( project.getRepositories() );\n\n                MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(), repos,\n                                                                                        localRepository, sourceReader );\n\n                project.getArtifacts().addAll( result.getArtifacts().values() );\n            }\n\n            ModelValidationResult validationResult = validator.validate( project.getModel() );\n\n            if ( validationResult.getMessageCount() > 0 )\n            {\n                throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n            }\n\n            project.setFile( projectDescriptor );\n\n            pathTranslator.alignToBaseDirectory( project.getModel(), projectDescriptor );\n\n            project.addCompileSourceRoot( project.getBuild().getSourceDirectory() );\n            project.addTestCompileSourceRoot( project.getBuild().getUnitTestSourceDirectory() );\n\n            return project;\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \" + projectDescriptor, e );\n        }\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"private File findParentModel( Parent parent, Set remoteArtifactRepositories, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(),\n                                                 \"pom\" );\n\n        try\n        {\n            artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            // @todo use parent.toString() if modello could generate it, or specify in a code segment\n            throw new ProjectBuildingException( \"Missing parent POM: \" + parent.getGroupId() + \":\" +\n                                                parent.getArtifactId() + \"-\" + parent.getVersion(), e );\n        }\n\n        return artifact.getFile();\n    }","id":106136,"modified_method":"private File findParentModel( Parent parent, Set remoteArtifactRepositories, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Artifact artifact = artifactFactory.createArtifact( parent.getGroupId(), parent.getArtifactId(),\n                                                            parent.getVersion(), null, \"pom\", \"pom\", null );\n\n        try\n        {\n            artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            // @todo use parent.toString() if modello could generate it, or specify in a code segment\n            throw new ProjectBuildingException( \"Missing parent POM: \" + parent.getGroupId() + \":\" +\n                                                parent.getArtifactId() + \"-\" + parent.getVersion(), e );\n        }\n\n        return artifact.getFile();\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public void verifyPlugin( String pluginId, MavenSession session ) throws Exception\n    {\n        if ( !isPluginInstalled( pluginId ) )\n        {\n            //!! This is entirely crappy. We need a better naming for plugin\n            // artifact ids and\n            //   we definitely need better version extraction support.\n\n            String artifactId = \"maven-\" + pluginId + \"-plugin\";\n\n            String version = \"1.0-SNAPSHOT\";\n\n            Artifact pluginArtifact = new DefaultArtifact( \"maven\", artifactId, version, DefaultArtifact.SCOPE_RUNTIME,\n                                                           \"plugin\", \"jar\" );\n\n            addPlugin( pluginArtifact, session );\n        }\n    }","id":106137,"modified_method":"public void verifyPlugin( String pluginId, MavenSession session )\n        throws Exception\n    {\n        if ( !isPluginInstalled( pluginId ) )\n        {\n            //!! This is entirely crappy. We need a better naming for plugin\n            // artifact ids and\n            //   we definitely need better version extraction support.\n\n            String artifactId = \"maven-\" + pluginId + \"-plugin\";\n\n            String version = \"1.0-SNAPSHOT\";\n\n            ArtifactFactory artifactFactory = null;\n            try\n            {\n                artifactFactory = (ArtifactFactory) container.lookup( ArtifactFactory.ROLE );\n\n                Artifact pluginArtifact = artifactFactory.createArtifact( \"maven\", artifactId, version, null, \"plugin\",\n                                                                          \"jar\", null );\n\n                addPlugin( pluginArtifact, session );\n            }\n            finally\n            {\n                if ( artifactFactory != null )\n                {\n                    container.release( artifactFactory );\n                }\n            }\n        }\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public PluginExecutionResponse executeMojo( MavenSession session, String goalName ) throws GoalExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request;\n\n        PluginExecutionResponse response;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new GoalExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.requiresDependencyResolution() )\n            {\n                resolveTransitiveDependencies( session );\n\n                downloadDependencies( session );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new GoalExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        try\n        {\n            //            getLogger().info( \"[\" + mojoDescriptor.getId() + \"]\" );\n\n            request = new PluginExecutionRequest( DefaultPluginManager.createParameters( mojoDescriptor, session ) );\n\n            request.setLog( session.getLog() );\n        }\n        catch ( PluginConfigurationException e )\n        {\n            throw new GoalExecutionException( \"Error configuring plugin for execution.\", e );\n        }\n\n        response = new PluginExecutionResponse();\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute( request, response );\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( Exception e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n            releaseComponents( mojoDescriptor, request );\n\n            container.release( plugin );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new GoalExecutionException( \"Error looking up plugin: \", e );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Error executing plugin: \", e );\n        }\n\n        return response;\n    }","id":106138,"modified_method":"public PluginExecutionResponse executeMojo( MavenSession session, String goalName )\n        throws GoalExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request;\n\n        PluginExecutionResponse response;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new GoalExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.requiresDependencyResolution() )\n            {\n\n                ArtifactResolver artifactResolver = null;\n                MavenProjectBuilder mavenProjectBuilder = null;\n\n                // TODO: should these be released\n                try\n                {\n                    artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                    mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                    resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder );\n                    downloadDependencies( session, artifactResolver );\n                }\n                finally\n                {\n                    // TODO: watch out for the exceptions being thrown\n                    if ( artifactResolver != null )\n                    {\n                        container.release( artifactResolver );\n                    }\n                    if ( mavenProjectBuilder != null )\n                    {\n                        container.release( mavenProjectBuilder );\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        try\n        {\n            //            getLogger().info( \"[\" + mojoDescriptor.getId() + \"]\" );\n\n            request = new PluginExecutionRequest( DefaultPluginManager.createParameters( mojoDescriptor, session ) );\n\n            request.setLog( session.getLog() );\n        }\n        catch ( PluginConfigurationException e )\n        {\n            throw new GoalExecutionException( \"Error configuring plugin for execution.\", e );\n        }\n\n        response = new PluginExecutionResponse();\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute( request, response );\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( Exception e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n            releaseComponents( mojoDescriptor, request );\n\n            container.release( plugin );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new GoalExecutionException( \"Error looking up plugin: \", e );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Error executing plugin: \", e );\n        }\n\n        return response;\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"private void resolveTransitiveDependencies( MavenSession context ) throws ArtifactResolutionException\n    {\n        MavenProject project = context.getProject();\n\n        MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(),\n                                                                                context.getRemoteRepositories(),\n                                                                                context.getLocalRepository(),\n                                                                                sourceReader );\n\n        project.getArtifacts().addAll( result.getArtifacts().values() );\n    }","id":106139,"modified_method":"private void resolveTransitiveDependencies( MavenSession context, ArtifactResolver artifactResolver,\n                                                MavenProjectBuilder mavenProjectBuilder )\n        throws ArtifactResolutionException\n    {\n        MavenProject project = context.getProject();\n\n        MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(),\n                                                                                context.getRemoteRepositories(),\n                                                                                context.getLocalRepository(),\n                                                                                sourceReader );\n\n        project.getArtifacts().addAll( result.getArtifacts().values() );\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"protected void addPlugin( Artifact pluginArtifact, MavenSession session ) throws Exception\n    {\n        // TODO: these should be configured, not instantiated here\n\n        artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n\n        mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n        MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n        ((ArtifactEnabledContainer) container).addComponent( pluginArtifact,\n                                                             artifactResolver,\n                                                             remotePluginRepositories,\n                                                             session.getLocalRepository(),\n                                                             metadataSource,\n                                                             artifactFilter );\n    }","id":106140,"modified_method":"protected void addPlugin( Artifact pluginArtifact, MavenSession session )\n        throws Exception\n    {\n        ArtifactResolver artifactResolver = null;\n        MavenProjectBuilder mavenProjectBuilder = null;\n\n        try\n        {\n            artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n            mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n            MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n            ( (ArtifactEnabledContainer) container ).addComponent( pluginArtifact, artifactResolver,\n                                                                   remotePluginRepositories,\n                                                                   session.getLocalRepository(), metadataSource,\n                                                                   artifactFilter );\n        }\n        finally\n        {\n            // TODO: watch out for the exceptions being thrown\n            if ( artifactResolver != null )\n            {\n                container.release( artifactResolver );\n            }\n            if ( mavenProjectBuilder != null )\n            {\n                container.release( mavenProjectBuilder );\n            }\n        }\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"private void downloadDependencies( MavenSession context ) throws GoalExecutionException\n    {\n        try\n        {\n            for ( Iterator it = context.getProject().getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new GoalExecutionException( \"Can't resolve artifact: \", e );\n        }\n    }","id":106141,"modified_method":"private void downloadDependencies( MavenSession context, ArtifactResolver artifactResolver )\n        throws GoalExecutionException\n    {\n        try\n        {\n            for ( Iterator it = context.getProject().getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new GoalExecutionException( \"Can't resolve artifact: \", e );\n        }\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        Set artifacts;\n        Artifact metadataArtifact = new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                         artifact.getVersion(), \"pom\" );\n        try\n        {\n            artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n\n            // [jdcasey/03-Feb-2005]: Replacing with ProjectBuilder, to enable\n            // post-processing and inheritance calculation before retrieving the \n            // associated artifacts. This should improve consistency.\n            if ( mavenProjectBuilder != null )\n            {\n                MavenProject project = mavenProjectBuilder.build( metadataArtifact.getFile(), localRepository );\n                artifacts = createArtifacts( project.getDependencies(), artifact.getScope(), localRepository );\n            }\n            else\n            {\n                Model model = reader.read( new FileReader( metadataArtifact.getFile() ) );\n                artifacts = createArtifacts( model.getDependencies(), artifact.getScope(), localRepository );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n        }\n        catch ( Exception e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Cannot read artifact source: \" + metadataArtifact.getFile(),\n                                                          e );\n        }\n        return artifacts;\n    }","id":106142,"modified_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        Set artifacts;\n        Artifact metadataArtifact = artifactFactory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                                    artifact.getVersion(), artifact.getScope(), \"pom\",\n                                                                    \"pom\", null );\n        try\n        {\n            artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n\n            // [jdcasey/03-Feb-2005]: Replacing with ProjectBuilder, to enable\n            // post-processing and inheritance calculation before retrieving the \n            // associated artifacts. This should improve consistency.\n            if ( mavenProjectBuilder != null )\n            {\n                MavenProject project = mavenProjectBuilder.build( metadataArtifact.getFile(), localRepository );\n                artifacts =\n                    artifactFactory.createArtifacts( project.getDependencies(), localRepository, artifact.getScope() );\n            }\n            else\n            {\n                Model model = reader.read( new FileReader( metadataArtifact.getFile() ) );\n                artifacts =\n                    artifactFactory.createArtifacts( model.getDependencies(), localRepository, artifact.getScope() );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n        }\n        catch ( Exception e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Cannot read artifact source: \" + metadataArtifact.getFile(),\n                                                          e );\n        }\n        return artifacts;\n    }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            MavenXpp3Reader reader = new MavenXpp3Reader();\n            Model model = null;\n            try\n            {\n                String scope = artifact.getArtifactId().substring( \"scope-\".length() );\n                String name = \"/projects/scope/transitive-\" + scope + \"-dep.xml\";\n                model = reader.read( new InputStreamReader( getClass().getResourceAsStream( name ) ) );\n            }\n            catch ( Exception e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            return createArtifacts( model.getDependencies(), artifact.getScope(), localRepository );\n        }","id":106143,"modified_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, Set remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            MavenXpp3Reader reader = new MavenXpp3Reader();\n            Model model = null;\n            try\n            {\n                String scope = artifact.getArtifactId().substring( \"scope-\".length() );\n                String name = \"/projects/scope/transitive-\" + scope + \"-dep.xml\";\n                model = reader.read( new InputStreamReader( getClass().getResourceAsStream( name ) ) );\n            }\n            catch ( Exception e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            return artifactFactory.createArtifacts( model.getDependencies(), localRepository, artifact.getScope() );\n        }","commit_id":"1fe8c76a3da0d1dc17d605863bd8a98322a2a9dd","url":"https://github.com/apache/maven"},{"original_method":"public MetadataResolution retrieve( ArtifactMetadata artifactMetadata,\n                                        ArtifactRepository localRepository,\n                                        List remoteRepositories )\n        throws MetadataRetrievalException\n    {\n        try\n        {\n            loadProjectBuilder();\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MetadataRetrievalException(\n                \"Cannot lookup MavenProjectBuilder component instance: \" + e.getMessage(), e );\n        }\n\n        MavenProject project = null;\n\n        Artifact pomArtifact = artifactFactory.createProjectArtifact( artifactMetadata.getGroupId(), artifactMetadata.getArtifactId(),\n            artifactMetadata.getVersion(), artifactMetadata.getScope() );\n\n        try\n        {\n            project = mavenProjectBuilder.buildFromRepository( pomArtifact, remoteRepositories, localRepository );\n        }\n        catch ( InvalidProjectModelException e )\n        {\n            // We want to capture this in the graph so that we can display the error to the user\n        \tartifactMetadata.setError( e.getMessage() );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            if ( strictlyEnforceThePresenceOfAValidMavenPOM )\n            {\n                throw new MetadataRetrievalException(\n                    \"Unable to read the metadata file for artifactMetadata '\" +\n                        artifactMetadata.getDependencyConflictId() + \"': \" + e.getMessage(), e, artifactMetadata );\n            }\n        }\n\n        Set artifacts = new HashSet();\n\n        for ( Iterator i = project.getDependencies().iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n            artifacts.add( new ArtifactMetadata( d.getGroupId(), d.getArtifactId(), d.getVersion() ) );\n        }\n\n        // The remote repositories is intentially null here while working in the graph in the least invasive way\n        // and making sure repositories added for a POM are scope only for a particular POM. We don't want\n        // repositories lingering around or being aggregated after they are used. jvz\n\n        artifactMetadata.setDependencies( artifacts );\n        return new MetadataResolution( artifactMetadata );\n    }","id":106144,"modified_method":"public MetadataResolution retrieve( ArtifactMetadata artifactMetadata,\n                                        ArtifactRepository localRepository,\n                                        List remoteRepositories )\n        throws MetadataRetrievalException\n    {\n        try\n        {\n            loadProjectBuilder();\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MetadataRetrievalException(\n                \"Cannot lookup MavenProjectBuilder component instance: \" + e.getMessage(), e );\n        }\n\n        MavenProject project = null;\n\n        Artifact pomArtifact = artifactFactory.createProjectArtifact(\n            artifactMetadata.getGroupId()\n            , artifactMetadata.getArtifactId()\n            , artifactMetadata.getVersion()\n        );\n\n        try\n        {\n            project = mavenProjectBuilder.buildFromRepository( pomArtifact, remoteRepositories, localRepository );\n            if ( pomArtifact.getFile() != null )\n            {\n                artifactMetadata.setArtifactUri( pomArtifact.getFile().toURI().toString() );\n            }\n        }\n        catch ( InvalidProjectModelException e )\n        {\n            // We want to capture this in the graph so that we can display the error to the user\n            artifactMetadata.setError( e.getMessage() );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            if ( strictlyEnforceThePresenceOfAValidMavenPOM )\n            {\n                throw new MetadataRetrievalException(\n                    \"Unable to read the metadata file for artifactMetadata '\" +\n                        artifactMetadata.getDependencyConflictId() + \"': \" + e.getMessage(), e, artifactMetadata );\n            }\n        }\n\n        Set artifacts = new HashSet();\n\n        for ( Iterator i = project.getDependencies().iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n\n            artifacts.add( new ArtifactMetadata( d.getGroupId(), d.getArtifactId(), d.getVersion(), d.getType(),\n                d.getScope(), d.getClassifier(), null, null, false, null ) );\n        }\n\n        // The remote repositories is intentially null here while working in the graph in the least invasive way\n        // and making sure repositories added for a POM are scope only for a particular POM. We don't want\n        // repositories lingering around or being aggregated after they are used. jvz\n\n        artifactMetadata.setDependencies( artifacts );\n\n        return new MetadataResolution( artifactMetadata );\n    }","commit_id":"291d6a9199fad1b6a83a5eb25b81c394da21f201","url":"https://github.com/apache/maven"},{"original_method":"private void runInitializeLibrariesAndModuleThread() {\n    LibraryManager.getInstance().setAppDir(DesignerApplicationManager.APP_DIR);\n    initializeThread = ApplicationManager.getApplication().executeOnPooledThread(new Callable<ProjectComponentReferenceCounter>() {\n      @Nullable\n      @Override\n      public ProjectComponentReferenceCounter call() {\n        LibraryManager.getInstance().garbageCollection(indicator);\n        indicator.checkCanceled();\n\n        try {\n          if (!StringRegistry.getInstance().isEmpty()) {\n            Client.getInstance().initStringRegistry();\n          }\n          indicator.setText(FlashUIDesignerBundle.message(\"collect.libraries\"));\n          return LibraryManager.getInstance().initLibrarySets(module, problemsHolder);\n        }\n        catch (Throwable e) {\n          if (initializeThread == null || initializeThread.isCancelled()) {\n            return null;\n          }\n\n          //noinspection InstanceofCatchParameter\n          if (e instanceof InitException) {\n            processInitException((InitException)e, module, debug);\n          }\n          else {\n            LOG.error(e);\n          }\n\n          indicator.cancel();\n          return null;\n        }\n      }\n    });\n  }","id":106145,"modified_method":"private void runInitializeLibrariesAndModuleThread() {\n    initializeThread = ApplicationManager.getApplication().executeOnPooledThread(new Callable<ProjectComponentReferenceCounter>() {\n      @Nullable\n      @Override\n      public ProjectComponentReferenceCounter call() {\n        LibraryManager.getInstance().garbageCollection(indicator);\n        indicator.checkCanceled();\n\n        try {\n          if (!StringRegistry.getInstance().isEmpty()) {\n            Client.getInstance().initStringRegistry();\n          }\n          indicator.setText(FlashUIDesignerBundle.message(\"collect.libraries\"));\n          return LibraryManager.getInstance().initLibrarySets(module, problemsHolder);\n        }\n        catch (Throwable e) {\n          if (initializeThread == null || initializeThread.isCancelled()) {\n            return null;\n          }\n\n          //noinspection InstanceofCatchParameter\n          if (e instanceof InitException) {\n            processInitException((InitException)e, module, debug);\n          }\n          else {\n            LOG.error(e);\n          }\n\n          indicator.cancel();\n          return null;\n        }\n      }\n    });\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public FlexLibrarySet(int id, @Nullable LibrarySet parent, List<Library> items, ContainsCondition contains, AssetCounter demanded) {\n    super(id, parent, items);\n    this.contains = contains;\n    assetCounterInfo = new AssetCounterInfo(demanded);\n  }","id":106146,"modified_method":"FlexLibrarySet(LibrarySorter.SortResult sortResult, @Nullable LibrarySet parent, ContainsCondition contains, AssetCounter demanded) {\n    super(sortResult.id, parent, sortResult.libraries);\n    this.contains = contains;\n    assetCounterInfo = new AssetCounterInfo(demanded);\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private String createKey(List<Library> libraries) {\n    // we don't depend on library order\n    final String[] filenames = new String[libraries.size()];\n    for (int i = 0, librariesSize = libraries.size(); i < librariesSize; i++) {\n      filenames[i] = libraries.get(i).getFile().getPath();\n    }\n    \n    Arrays.sort(filenames);\n    \n    final StringBuilder stringBuilder = StringBuilderSpinAllocator.alloc();\n    try {\n      for (String filename : filenames) {\n        stringBuilder.append(filename).append(':');\n      }\n\n      return stringBuilder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(stringBuilder);\n    }\n  }","id":106147,"modified_method":"private String createKey(List<Library> libraries, boolean isSdk) {\n    // we don't depend on library order\n    final VirtualFile[] files = new VirtualFile[libraries.size()];\n    for (int i = 0, librariesSize = libraries.size(); i < librariesSize; i++) {\n      files[i] = libraries.get(i).getFile();\n    }\n    \n    Arrays.sort(files, new Comparator<VirtualFile>() {\n      @Override\n      public int compare(VirtualFile o1, VirtualFile o2) {\n        return StringUtil.compare(o1.getPath(), o2.getPath(), false);\n      }\n    });\n    \n    final StringBuilder stringBuilder = StringBuilderSpinAllocator.alloc();\n    try {\n      if (isSdk) {\n        stringBuilder.append('_');\n      }\n\n      for (VirtualFile file : files) {\n        stringBuilder.append(file.getTimeStamp()).append(file.getPath()).append(':');\n      }\n\n      return stringBuilder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(stringBuilder);\n    }\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public ProjectComponentReferenceCounter initLibrarySets(@NotNull final Module module,\n                                                         ProblemsHolder problemsHolder,\n                                                         boolean collectLocalStyleHolders) throws InitException {\n    final Project project = module.getProject();\n    final StringRegistry.StringWriter stringWriter = new StringRegistry.StringWriter(16384);\n    stringWriter.startChange();\n    final AssetCounter assetCounter = new AssetCounter();\n    final LibraryCollector libraryCollector = new LibraryCollector(this, new LibraryStyleInfoCollector(assetCounter, problemsHolder, module, stringWriter), module);\n    final Client client;\n    try {\n      final AccessToken token = ReadAction.start();\n      try {\n        libraryCollector.collect(module);\n      }\n      finally {\n        token.finish();\n      }\n\n      client = Client.getInstance();\n      if (stringWriter.hasChanges()) {\n        client.updateStringRegistry(stringWriter);\n      }\n      else {\n        stringWriter.finishChange();\n      }\n    }\n    catch (Throwable e) {\n      stringWriter.rollbackChange();\n      throw new InitException(e, \"error.collect.libraries\");\n    }\n\n    assert !libraryCollector.sdkLibraries.isEmpty();\n    final FlexLibrarySet flexLibrarySet = getOrCreateFlexLibrarySet(libraryCollector, assetCounter);\n    final InfoMap<Project, ProjectInfo> registeredProjects = client.getRegisteredProjects();\n    ProjectInfo info = registeredProjects.getNullableInfo(project);\n    if (info == null) {\n      info = new ProjectInfo(project);\n      registeredProjects.add(info);\n      client.openProject(project);\n    }\n\n    LibrarySet librarySet;\n    if (libraryCollector.externalLibraries.isEmpty()) {\n      librarySet = null;\n    }\n    else {\n      final String key = createKey(libraryCollector.externalLibraries);\n      librarySet = librarySets.get(key);\n      if (librarySet == null) {\n        final int id = librarySetIdPool.allocate();\n        final SortResult sortResult = sortLibraries(new LibrarySorter(), id, libraryCollector.externalLibraries,\n          libraryCollector.getFlexSdkVersion(), flexLibrarySet.contains);\n        librarySet = new LibrarySet(id, flexLibrarySet, sortResult.items);\n        registerLibrarySet(key, librarySet);\n      }\n    }\n\n    final ModuleInfo moduleInfo = new ModuleInfo(module,\n      Collections.singletonList(librarySet == null ? flexLibrarySet : librarySet), ModuleInfoUtil.isApp(module));\n    final ProjectComponentReferenceCounter projectComponentReferenceCounter = new ProjectComponentReferenceCounter();\n    if (collectLocalStyleHolders) {\n      // client.registerModule finalize it\n      stringWriter.startChange();\n      try {\n        ModuleInfoUtil.collectLocalStyleHolders(moduleInfo, libraryCollector.getFlexSdkVersion(), stringWriter, problemsHolder,\n                                                projectComponentReferenceCounter, assetCounter);\n      }\n      catch (Throwable e) {\n        stringWriter.rollbackChange();\n        throw new InitException(e, \"error.collect.local.style.holders\");\n      }\n    }\n\n    client.registerModule(project, moduleInfo, stringWriter);\n    client.fillAssetClassPoolIfNeed(flexLibrarySet);\n\n    module.getMessageBus().connect(moduleInfo).subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      @Override\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      @Override\n      public void rootsChanged(ModuleRootEvent event) {\n        new Notification(FlashUIDesignerBundle.message(\"plugin.name\"), FlashUIDesignerBundle.message(\"plugin.name\"),\n          \"Please reopen your project to update on library changes.\",\n          NotificationType.WARNING).notify(project);\n      }\n    });\n\n    return projectComponentReferenceCounter;\n  }","id":106148,"modified_method":"@NotNull\n  public ProjectComponentReferenceCounter initLibrarySets(@NotNull final Module module,\n                                                         ProblemsHolder problemsHolder,\n                                                         boolean collectLocalStyleHolders) throws InitException {\n    final Project project = module.getProject();\n    final StringRegistry.StringWriter stringWriter = new StringRegistry.StringWriter(16384);\n    stringWriter.startChange();\n    final AssetCounter assetCounter = new AssetCounter();\n    final LibraryCollector libraryCollector = new LibraryCollector(this, new LibraryStyleInfoCollector(assetCounter, problemsHolder, module, stringWriter), module);\n    final Client client;\n    try {\n      final AccessToken token = ReadAction.start();\n      try {\n        libraryCollector.collect(module);\n      }\n      finally {\n        token.finish();\n      }\n\n      client = Client.getInstance();\n      if (stringWriter.hasChanges()) {\n        client.updateStringRegistry(stringWriter);\n      }\n      else {\n        stringWriter.finishChange();\n      }\n    }\n    catch (Throwable e) {\n      stringWriter.rollbackChange();\n      throw new InitException(e, \"error.collect.libraries\");\n    }\n\n    assert !libraryCollector.sdkLibraries.isEmpty();\n    final FlexLibrarySet flexLibrarySet = getOrCreateFlexLibrarySet(libraryCollector, assetCounter);\n    final InfoMap<Project, ProjectInfo> registeredProjects = client.getRegisteredProjects();\n    ProjectInfo info = registeredProjects.getNullableInfo(project);\n    if (info == null) {\n      info = new ProjectInfo(project);\n      registeredProjects.add(info);\n      client.openProject(project);\n    }\n\n    LibrarySet librarySet;\n    if (libraryCollector.externalLibraries.isEmpty()) {\n      librarySet = null;\n    }\n    else {\n      final String key = createKey(libraryCollector.externalLibraries, false);\n      librarySet = librarySets.get(key);\n      if (librarySet == null) {\n        final SortResult sortResult = sortLibraries(new LibrarySorter(), libraryCollector, flexLibrarySet.contains, key, false);\n        librarySet = new LibrarySet(sortResult.id, flexLibrarySet, sortResult.libraries);\n        registerLibrarySet(key, librarySet);\n      }\n    }\n\n    final ModuleInfo moduleInfo = new ModuleInfo(module,\n      Collections.singletonList(librarySet == null ? flexLibrarySet : librarySet), ModuleInfoUtil.isApp(module));\n    final ProjectComponentReferenceCounter projectComponentReferenceCounter = new ProjectComponentReferenceCounter();\n    if (collectLocalStyleHolders) {\n      // client.registerModule finalize it\n      stringWriter.startChange();\n      try {\n        ModuleInfoUtil.collectLocalStyleHolders(moduleInfo, libraryCollector.getFlexSdkVersion(), stringWriter, problemsHolder,\n                                                projectComponentReferenceCounter, assetCounter);\n      }\n      catch (Throwable e) {\n        stringWriter.rollbackChange();\n        throw new InitException(e, \"error.collect.local.style.holders\");\n      }\n    }\n\n    client.registerModule(project, moduleInfo, stringWriter);\n    client.fillAssetClassPoolIfNeed(flexLibrarySet);\n\n    module.getMessageBus().connect(moduleInfo).subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      @Override\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      @Override\n      public void rootsChanged(ModuleRootEvent event) {\n        new Notification(FlashUIDesignerBundle.message(\"plugin.name\"), FlashUIDesignerBundle.message(\"plugin.name\"),\n          \"Please reopen your project to update on library changes.\",\n          NotificationType.WARNING).notify(project);\n      }\n    });\n\n    return projectComponentReferenceCounter;\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private SortResult sortLibraries(LibrarySorter librarySorter, int librarySetId, List<Library> libraries, String flexSdkVersion,\n                                   Condition<String> isExternal)\n    throws InitException {\n    try {\n      return librarySorter.sort(libraries, new File(appDir, librarySetId + SWF_EXTENSION), isExternal);\n    }\n    catch (ClosedByInterruptException e) {\n      throw new InitException(e);\n    }\n    catch (Throwable e) {\n      String technicalMessage = \"Flex SDK \" + flexSdkVersion;\n      final Attachment[] attachments = new Attachment[libraries.size()];\n      try {\n        for (int i = 0, librariesSize = libraries.size(); i < librariesSize; i++) {\n          Library library = libraries.get(i);\n          technicalMessage += \" \" + library.getFile().getPath();\n          attachments[i] = new Attachment(library.getCatalogFile());\n        }\n      }\n      catch (Throwable innerE) {\n        technicalMessage += \" Cannot collect library catalog files due to \" + ExceptionUtil.getThrowableText(innerE);\n      }\n\n      throw new InitException(e, \"error.sort.libraries\", attachments, technicalMessage);\n    }\n  }","id":106149,"modified_method":"@NotNull\n  private SortResult sortLibraries(LibrarySorter sorter, LibraryCollector collector, Condition<String> isExternal, String key, boolean isSdk)\n    throws InitException {\n    final List<Library> libraries = isSdk ? collector.sdkLibraries : collector.externalLibraries;\n    try {\n      final int id = persistentCache.enumerate(key);\n      SortResult result = persistentCache.get(key);\n      if (result == null) {\n        result = sorter.sort(libraries, new File(appDir, NAME_PREFIX + Integer.toString(id) + SWF_EXTENSION), isExternal, isSdk);\n        persistentCache.put(key, result);\n      }\n      else {\n        final String[] libraryPathes = result.libraryPathes;\n        final List<Library> filteredLibraries = new ArrayList<Library>(libraryPathes.length);\n        for (Library library : libraries) {\n          if (ArrayUtil.indexOf(libraryPathes, library.getFile().getPath()) != -1) {\n            filteredLibraries.add(library);\n          }\n        }\n\n        result = new SortResult(result.definitionMap, filteredLibraries);\n      }\n\n      result.id = id;\n      return result;\n    }\n    catch (ClosedByInterruptException e) {\n      throw new InitException(e);\n    }\n    catch (Throwable e) {\n      String technicalMessage = \"Flex SDK \" + collector.getFlexSdkVersion();\n      final Attachment[] attachments = new Attachment[libraries.size()];\n      try {\n        for (int i = 0, librariesSize = libraries.size(); i < librariesSize; i++) {\n          Library library = libraries.get(i);\n          technicalMessage += \" \" + library.getFile().getPath();\n          attachments[i] = new Attachment(library.getCatalogFile());\n        }\n      }\n      catch (Throwable innerE) {\n        technicalMessage += \" Cannot collect library catalog files due to \" + ExceptionUtil.getThrowableText(innerE);\n      }\n\n      throw new InitException(e, \"error.sort.libraries\", attachments, technicalMessage);\n    }\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void unregister(final int[] ids) {\n    librarySets.retainEntries(new RetainCondition<String, LibrarySet>(ids));\n    librarySetIdPool.dispose(ids);\n  }","id":106150,"modified_method":"public void unregister(final int[] ids) {\n    librarySets.retainEntries(new RetainCondition<String, LibrarySet>(ids));\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private FlexLibrarySet getOrCreateFlexLibrarySet(LibraryCollector libraryCollector, AssetCounter assetCounter) throws InitException {\n    final String key = createKey(libraryCollector.sdkLibraries);\n    FlexLibrarySet flexLibrarySet = (FlexLibrarySet)librarySets.get(key);\n    if (flexLibrarySet == null) {\n      final Set<CharSequence> globalDefinitions = getGlobalDefinitions(libraryCollector.getGlobalLibrary());\n      final int id = librarySetIdPool.allocate();\n      Condition<String> globalContains = new Condition<String>() {\n        @Override\n        public boolean value(String name) {\n          return globalDefinitions.contains(name);\n        }\n      };\n      final SortResult sortResult = sortLibraries(\n        new LibrarySorter(new FlexDefinitionProcessor(libraryCollector.getFlexSdkVersion()), new FlexDefinitionMapProcessor(\n          libraryCollector.getFlexSdkVersion(), globalContains)), id, libraryCollector.sdkLibraries,\n        libraryCollector.getFlexSdkVersion(),\n        globalContains);\n\n      flexLibrarySet = new FlexLibrarySet(id, null, sortResult.items, new ContainsCondition(globalDefinitions, sortResult.definitionMap), assetCounter);\n      registerLibrarySet(key, flexLibrarySet);\n    }\n\n    return flexLibrarySet;\n  }","id":106151,"modified_method":"private FlexLibrarySet getOrCreateFlexLibrarySet(LibraryCollector libraryCollector, AssetCounter assetCounter) throws InitException {\n    final String key = createKey(libraryCollector.sdkLibraries, true);\n    FlexLibrarySet flexLibrarySet = (FlexLibrarySet)librarySets.get(key);\n    if (flexLibrarySet == null) {\n      final Set<CharSequence> globalDefinitions = getGlobalDefinitions(libraryCollector.getGlobalLibrary());\n      final Condition<String> globalContains = new Condition<String>() {\n        @Override\n        public boolean value(String name) {\n          return globalDefinitions.contains(name);\n        }\n      };\n      final SortResult sortResult = sortLibraries(new LibrarySorter(new FlexDefinitionProcessor(libraryCollector.getFlexSdkVersion()),\n                                                                    new FlexDefinitionMapProcessor(libraryCollector.getFlexSdkVersion(),\n                                                                                                   globalContains)), libraryCollector,\n                                                  globalContains, key, true);\n      flexLibrarySet =\n        new FlexLibrarySet(sortResult, null, new ContainsCondition(globalDefinitions, sortResult.definitionMap), assetCounter);\n      registerLibrarySet(key, flexLibrarySet);\n    }\n\n    return flexLibrarySet;\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public SortResult sort(final List<Library> libraries, File outFile, Condition<String> isExternal) throws IOException {\n    final THashMap<CharSequence, Definition> definitionMap = new THashMap<CharSequence, Definition>(libraries.size() * 128, AbcTranscoder.HASHING_STRATEGY);\n    final List<LibrarySetItem> unsortedItems = collectItems(libraries, definitionMap, isExternal);\n    final AbcMerger abcMerger = new AbcMerger(definitionMap, outFile, definitionProcessor);\n    try {\n      final ArrayList<Library> items = new ArrayList<Library>(unsortedItems.size());\n      for (LibrarySetItem item : unsortedItems) {\n        if (!item.hasDefinitions()) {\n          if (item.library.hasResourceBundles()) {\n            items.add(item.library);\n          }\n          continue;\n        }\n\n        items.add(item.library);\n        abcMerger.process(item.library);\n      }\n      \n      if (definitionMapProcessor != null) {\n        definitionMapProcessor.process(definitionMap, abcMerger);\n      }\n\n      final List<Decoder> decoders = new ArrayList<Decoder>(definitionMap.size());\n      final String[] singleStringArray = new String[1];\n      definitionMap.forEachValue(new TObjectProcedure<Definition>() {\n        @Override\n        public boolean execute(Definition definition) {\n          if (definition.doAbcData != null &&\n              (definition.resolved == ResolvedState.YES || (definition.resolved == ResolvedState.UNKNOWN &&\n                                                            processDependencies(decoders, definition, definitionMap, singleStringArray)))) {\n            decoders.add(createDecoder(definition));\n          }\n\n          return true;\n        }\n      });\n\n      final Encoder encoder = new Encoder();\n      abcMerger.end(decoders, encoder);\n      return new SortResult(definitionMap, items);\n    }\n    finally {\n      abcMerger.close();\n    }\n  }","id":106152,"modified_method":"public SortResult sort(final List<Library> libraries, File outFile, Condition<String> isExternal, boolean returnDefinitionMap) throws IOException {\n    final THashMap<CharSequence, Definition> definitionMap = new THashMap<CharSequence, Definition>(libraries.size() * 128, AbcTranscoder.HASHING_STRATEGY);\n    final List<LibrarySetItem> unsortedItems = collectItems(libraries, definitionMap, isExternal);\n    final AbcMerger abcMerger = new AbcMerger(definitionMap, outFile, definitionProcessor);\n    try {\n      final ArrayList<Library> items = new ArrayList<Library>(unsortedItems.size());\n      for (LibrarySetItem item : unsortedItems) {\n        if (!item.hasDefinitions()) {\n          if (item.library.hasResourceBundles()) {\n            items.add(item.library);\n          }\n          continue;\n        }\n\n        items.add(item.library);\n        abcMerger.process(item.library);\n      }\n      \n      if (definitionMapProcessor != null) {\n        definitionMapProcessor.process(definitionMap, abcMerger);\n      }\n\n      final List<Decoder> decoders = new ArrayList<Decoder>(definitionMap.size());\n      final String[] singleStringArray = new String[1];\n      definitionMap.forEachValue(new TObjectProcedure<Definition>() {\n        @Override\n        public boolean execute(Definition definition) {\n          if (definition.doAbcData != null &&\n              (definition.resolved == ResolvedState.YES || (definition.resolved == ResolvedState.UNKNOWN &&\n                                                            processDependencies(decoders, definition, definitionMap, singleStringArray)))) {\n            decoders.add(createDecoder(definition));\n          }\n\n          return true;\n        }\n      });\n\n      final Encoder encoder = new Encoder();\n      abcMerger.end(decoders, encoder);\n      return new SortResult(returnDefinitionMap ? definitionMap : null, items);\n    }\n    finally {\n      abcMerger.close();\n    }\n  }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private SortResult(THashMap<CharSequence, Definition> definitionMap, List<Library> items) {\n      this.definitionMap = definitionMap;\n      this.items = items;\n    }","id":106153,"modified_method":"SortResult(@Nullable THashMap<CharSequence, Definition> definitionMap, List<Library> libraries) {\n      this.definitionMap = definitionMap;\n      this.libraries = libraries;\n      libraryPathes = null;\n    }","commit_id":"7660f64aea9198d98fd88ee666b6cb52e2c0a574","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/** Sorts the rows ({@link Row}) based on {@link #getSortAscending}\n\t * and {@link #getSortDescending}, if {@link #getSortDirection} doesn't\n\t * matches the ascending argument.\n\t *\n\t * <p>It checks {@link #getSortDirection} to see whether sorting\n\t * is required, and update {@link #setSortDirection} after sorted.\n\t * For example, if {@link #getSortDirection} returns \"ascending\" and\n\t * the ascending argument is false, nothing happens.\n\t * To enforce the sorting, you can invoke {@link #setSortDirection}\n\t * with \"natural\" before invoking this method.\n\t * Alternatively, you can invoke {@link #sort(boolean, boolean)} instead.\n\t *\n\t * <p>It sorts the rows by use of {@link Components#sort}.\n\t *\n\t * @param ascending whether to use {@link #getSortAscending}.\n\t * If the corresponding comparator is not set, it returns false\n\t * and does nothing.\n\t * @return whether the rows are sorted.\n\t */\n\tpublic boolean sort(boolean ascending) {\n\t\tfinal String dir = getSortDirection();\n\t\tif (ascending) {\n\t\t\tif (\"ascending\".equals(dir)) return false;\n\t\t} else {\n\t\t\tif (\"descending\".equals(dir)) return false;\n\t\t}\n\n\t\tfinal Comparator cpr = ascending ? _sortAsc: _sortDsc;\n\t\tif (cpr == null) return false;\n\n\t\tfinal Grid grid = getGrid();\n\t\tif (grid == null) return false;\n\t\tComponents.sort(grid.getRows().getChildren(), cpr);\n\n\t\t//maintain\n\t\tfor (Iterator it = grid.getColumns().getChildren().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Column hd = (Column)it.next();\n\t\t\thd.setSortDirection(\n\t\t\t\thd != this ? \"natural\": ascending ? \"ascending\": \"descending\");\n\t\t}\n\t\treturn true;\n\t}","id":106154,"modified_method":"/** Sorts the rows ({@link Row}) based on {@link #getSortAscending}\n\t * and {@link #getSortDescending}, if {@link #getSortDirection} doesn't\n\t * matches the ascending argument.\n\t *\n\t * <p>It checks {@link #getSortDirection} to see whether sorting\n\t * is required, and update {@link #setSortDirection} after sorted.\n\t * For example, if {@link #getSortDirection} returns \"ascending\" and\n\t * the ascending argument is false, nothing happens.\n\t * To enforce the sorting, you can invoke {@link #setSortDirection}\n\t * with \"natural\" before invoking this method.\n\t * Alternatively, you can invoke {@link #sort(boolean, boolean)} instead.\n\t *\n\t * <p>It sorts the rows by use of {@link Components#sort}, if not live\n\t * data (i.e., {@link Grid#getModel} is null).\n\t *\n\t * <p>On the other hand, it invokes {@link ListModelExt#sort} to sort\n\t * the rows, if live data (i.e., {@link Grid#getModel} is not null).\n\t * In other words, if you use the live data, you have to implement\n\t * {@link ListModelExt} to sort the live data explicitly.\n\t *\n\t * @param ascending whether to use {@link #getSortAscending}.\n\t * If the corresponding comparator is not set, it returns false\n\t * and does nothing.\n\t * @return whether the rows are sorted.\n\t * @exception UiException if {@link Grid#getModel} is not\n\t * null but {@link ListModelExt} is not implemented.\n\t */\n\tpublic boolean sort(boolean ascending) {\n\t\tfinal String dir = getSortDirection();\n\t\tif (ascending) {\n\t\t\tif (\"ascending\".equals(dir)) return false;\n\t\t} else {\n\t\t\tif (\"descending\".equals(dir)) return false;\n\t\t}\n\n\t\tfinal Comparator cmpr = ascending ? _sortAsc: _sortDsc;\n\t\tif (cmpr == null) return false;\n\n\t\tfinal Grid grid = getGrid();\n\t\tif (grid == null) return false;\n\n\t\tfinal ListModel model = grid.getModel();\n\t\tif (model != null) { //live data\n\t\t\tif (!(model instanceof ListModelExt))\n\t\t\t\tthrow new UiException(\"ListModelExt must be implemented in \"+model.getClass().getName());\n\t\t\t((ListModelExt)model).sort(cmpr, ascending);\n\t\t} else { //not live data\n\t\t\tComponents.sort(grid.getRows().getChildren(), cmpr);\n\t\t}\n\n\t\t//maintain\n\t\tfor (Iterator it = grid.getColumns().getChildren().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Column hd = (Column)it.next();\n\t\t\thd.setSortDirection(\n\t\t\t\thd != this ? \"natural\": ascending ? \"ascending\": \"descending\");\n\t\t}\n\t\treturn true;\n\t}","commit_id":"cd409b1c83277788f9eca905ecd5a20b9a1cf82b","url":"https://github.com/zkoss/zk"},{"original_method":"public ListDataEvent(ListModel model, int type, int index0, int index1) {\n\t\tif (model == null)\n\t\t\tthrow new NullPointerException();\n\t\t_model = model;\n\t\t_type = type;\n\t\t_index0 = index0;\n\t\t_index1 = index1;\n\t}","id":106155,"modified_method":"/** Contructor.\n\t *\n\t * @param type one of {@link #CONTENTS_CHANGED},\n\t * {@link #INTERVAL_ADDED}, or {@link #INTERVAL_REMOVED}.\n\t * @param index0 the lower index of the change range.\n\t * For simple element, index0 is the same as index1.\n\t * -1 means the first element (the same as 0).\n\t * @param index1 the upper index of the change range.\n\t * -1 means the last element.\n\t */\n\tpublic ListDataEvent(ListModel model, int type, int index0, int index1) {\n\t\tif (model == null)\n\t\t\tthrow new NullPointerException();\n\t\t_model = model;\n\t\t_type = type;\n\t\t_index0 = index0;\n\t\t_index1 = index1;\n\t}","commit_id":"cd409b1c83277788f9eca905ecd5a20b9a1cf82b","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sorts the list items based on {@link #getSortAscending}\n\t * and {@link #getSortDescending}, if {@link #getSortDirection} doesn't\n\t * matches the ascending argument.\n\t *\n\t * <p>It checks {@link #getSortDirection} to see whether sorting\n\t * is required, and update {@link #setSortDirection} after sorted.\n\t * For example, if {@link #getSortDirection} returns \"ascending\" and\n\t * the ascending argument is false, nothing happens.\n\t * To enforce the sorting, you can invoke {@link #setSortDirection}\n\t * with \"natural\" before invoking this method.\n\t * Alternatively, you can invoke {@link #sort(boolean, boolean)} instead.\n\t *\n\t * <p>It sorts the listitem by use of {@link Components#sort}.\n\t *\n\t * <p>Note: it invokes {@link Listbox#renderAll} to load all list items.\n\t * If you want to use different way (such as issuing SQL with different ORDER BY)\n\t * you have to override this method or listen to the onSort event.\n\t *\n\t * @param ascending whether to use {@link #getSortAscending}.\n\t * If the corresponding comparator is not set, it returns false\n\t * and does nothing.\n\t * @return whether the list items are sorted.\n\t */\n\tpublic boolean sort(boolean ascending) {\n\t\tfinal String dir = getSortDirection();\n\t\tif (ascending) {\n\t\t\tif (\"ascending\".equals(dir)) return false;\n\t\t} else {\n\t\t\tif (\"descending\".equals(dir)) return false;\n\t\t}\n\n\t\tfinal Comparator cpr = ascending ? _sortAsc: _sortDsc;\n\t\tif (cpr == null) return false;\n\n\t\tfinal Listbox box = getListbox();\n\t\tif (box == null) return false;\n\n\t\tbox.renderAll(); //make sure all items are loaded before sorting\n\t\tComponents.sort(box.getItems(), cpr);\n\n\t\t//maintain\n\t\tfor (Iterator it = box.getListhead().getChildren().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Listheader hd = (Listheader)it.next();\n\t\t\thd.setSortDirection(\n\t\t\t\thd != this ? \"natural\": ascending ? \"ascending\": \"descending\");\n\t\t}\n\t\treturn true;\n\t}","id":106156,"modified_method":"/** Sorts the list items based on {@link #getSortAscending}\n\t * and {@link #getSortDescending}, if {@link #getSortDirection} doesn't\n\t * matches the ascending argument.\n\t *\n\t * <p>It checks {@link #getSortDirection} to see whether sorting\n\t * is required, and update {@link #setSortDirection} after sorted.\n\t * For example, if {@link #getSortDirection} returns \"ascending\" and\n\t * the ascending argument is false, nothing happens.\n\t * To enforce the sorting, you can invoke {@link #setSortDirection}\n\t * with \"natural\" before invoking this method.\n\t * Alternatively, you can invoke {@link #sort(boolean, boolean)} instead.\n\t *\n\t * <p>It sorts the listitem by use of {@link Components#sort}\n\t * data (i.e., {@link Grid#getModel} is null).\n\t *\n\t * <p>On the other hand, it invokes {@link ListModelExt#sort} to sort\n\t * the list item, if live data (i.e., {@link Listbox#getModel} is not null).\n\t * In other words, if you use the live data, you have to implement\n\t * {@link ListModelExt} to sort the live data explicitly.\n\t *\n\t * @param ascending whether to use {@link #getSortAscending}.\n\t * If the corresponding comparator is not set, it returns false\n\t * and does nothing.\n\t * @return whether the list items are sorted.\n\t * @exception UiException if {@link Listbox#getModel} is not\n\t * null but {@link ListModelExt} is not implemented.\n\t */\n\tpublic boolean sort(boolean ascending) {\n\t\tfinal String dir = getSortDirection();\n\t\tif (ascending) {\n\t\t\tif (\"ascending\".equals(dir)) return false;\n\t\t} else {\n\t\t\tif (\"descending\".equals(dir)) return false;\n\t\t}\n\n\t\tfinal Comparator cmpr = ascending ? _sortAsc: _sortDsc;\n\t\tif (cmpr == null) return false;\n\n\t\tfinal Listbox box = getListbox();\n\t\tif (box == null) return false;\n\n\t\tfinal ListModel model = box.getModel();\n\t\tif (model != null) { //live data\n\t\t\tif (!(model instanceof ListModelExt))\n\t\t\t\tthrow new UiException(\"ListModelExt must be implemented in \"+model.getClass().getName());\n\t\t\t((ListModelExt)model).sort(cmpr, ascending);\n\t\t} else { //not live data\n\t\t\tComponents.sort(box.getItems(), cmpr);\n\t\t}\n\n\t\t//maintain\n\t\tfor (Iterator it = box.getListhead().getChildren().iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Listheader hd = (Listheader)it.next();\n\t\t\thd.setSortDirection(\n\t\t\t\thd != this ? \"natural\": ascending ? \"ascending\": \"descending\");\n\t\t}\n\t\treturn true;\n\t}","commit_id":"cd409b1c83277788f9eca905ecd5a20b9a1cf82b","url":"https://github.com/zkoss/zk"},{"original_method":"public void updateLibIgnores(File libDir, String[] jars) throws Exception {\n\t\tif (!_isSVNDir(libDir)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile tempFile = null;\n\n\t\ttry {\n\t\t\tString libPath = libDir.getCanonicalPath();\n\n\t\t\tString[] oldIgnores = _exec(_SVN_GET_IGNORES + libPath);\n\n\t\t\tArrays.sort(oldIgnores);\n\n\t\t\tif (Arrays.equals(oldIgnores, jars)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttempFile = File.createTempFile(\"svn-ignores-\", null, null);\n\n\t\t\t_exec(_SVN_DEL_IGNORES + libPath);\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tfor (String jar : jars) {\n\t\t\t\tsb.append(jar + \"\\n\");\n\t\t\t}\n\n\t\t\t_fileUtil.write(tempFile, sb.toString());\n\n\t\t\t_exec(\n\t\t\t\t_SVN_SET_IGNORES + \"-F \\\"\" + tempFile.getCanonicalPath() +\n\t\t\t\t\t\"\\\" \" + libPath);\n\n\t\t\tString[] newIgnores = _exec(_SVN_GET_IGNORES + libPath);\n\n\t\t\tif (newIgnores.length > 0) {\n\t\t\t\tArrays.sort(newIgnores);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (tempFile != null) {\n\t\t\t\ttempFile.delete();\n\t\t\t}\n\t\t}\n\t}","id":106157,"modified_method":"public void updateLibIgnores(File libDir, String[] jars) throws Exception {\n\t\tif (!_isSVNDir(libDir)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile tempFile = null;\n\n\t\ttry {\n\t\t\tString libPath = libDir.getCanonicalPath();\n\n\t\t\tString[] oldIgnores = _exec(_SVN_GET_IGNORES + libPath);\n\n\t\t\tArrays.sort(oldIgnores);\n\n\t\t\tif (Arrays.equals(oldIgnores, jars)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttempFile = File.createTempFile(\"svn-ignores-\", null, null);\n\n\t\t\t_exec(_SVN_DEL_IGNORES + libPath);\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tfor (String jar : jars) {\n\t\t\t\tsb.append(jar + \"\\n\");\n\t\t\t}\n\n\t\t\t_fileUtil.write(tempFile, sb.toString());\n\n\t\t\t_exec(\n\t\t\t\t_SVN_SET_IGNORES + \"-F \" + tempFile.getCanonicalPath() +\n\t\t\t\t\t\" \" + libPath);\n\n\t\t\tString[] newIgnores = _exec(_SVN_GET_IGNORES + libPath);\n\n\t\t\tif (newIgnores.length > 0) {\n\t\t\t\tArrays.sort(newIgnores);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (tempFile != null) {\n\t\t\t\ttempFile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"be6ad9440595b9926d929ebc9670d428a6fe03ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateEclipseFiles(\n\t\t\tFile libDir, File projectDir, List<String> dependencyJars)\n\t\tthrows Exception {\n\n\t\tString projectPath = projectDir.getCanonicalPath();\n\t\tString projectName = StringUtil.extractLast(\n\t\t\tprojectPath, File.separator);\n\n\t\t// .project\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n\");\n\t\tsb.append(\"<projectDescription>\\n\");\n\t\tsb.append(\"\\t<name>\" + projectName + \"<\/name>\\n\");\n\t\tsb.append(\"\\t<comment><\/comment>\\n\");\n\t\tsb.append(\"\\t<projects><\/projects>\\n\");\n\t\tsb.append(\"\\t<buildSpec>\\n\");\n\t\tsb.append(\"\\t\\t<buildCommand>\\n\");\n\t\tsb.append(\"\\t\\t\\t<name>org.eclipse.jdt.core.javabuilder<\/name>\\n\");\n\t\tsb.append(\"\\t\\t\\t<arguments><\/arguments>\\n\");\n\t\tsb.append(\"\\t\\t<\/buildCommand>\\n\");\n\t\tsb.append(\"\\t<\/buildSpec>\\n\");\n\t\tsb.append(\"\\t<natures>\\n\");\n\t\tsb.append(\"\\t\\t<nature>org.eclipse.jdt.core.javanature<\/nature>\\n\");\n\t\tsb.append(\"\\t<\/natures>\\n\");\n\t\tsb.append(\"<\/projectDescription>\");\n\n\t\tFile projectFile = new File(projectPath + \"/.project\");\n\n\t\tSystem.out.println(\"Updating \" + projectFile);\n\n\t\t_fileUtil.write(projectFile, sb.toString());\n\n\t\t// .classpath\n\n\t\tList<String> portalJars = new ArrayList<String>(dependencyJars);\n\n\t\tportalJars.add(\"commons-logging.jar\");\n\t\tportalJars.add(\"log4j.jar\");\n\n\t\tCollections.sort(portalJars);\n\n\t\tList<String> customJars = ListUtil.toList(\n\t\t\tlibDir.list(new GlobFilenameFilter(\"*.jar\")));\n\n\t\tCollections.sort(customJars);\n\n\t\tfor (String jar : portalJars) {\n\t\t\tcustomJars.remove(jar);\n\t\t}\n\n\t\tcustomJars.remove(\"util-bridges.jar\");\n\t\tcustomJars.remove(\"util-java.jar\");\n\t\tcustomJars.remove(\"util-taglib.jar\");\n\n\t\tsb = new StringBuilder();\n\n\t\tsb.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n\");\n\t\tsb.append(\"<classpath>\\n\");\n\t\tsb.append(\"\\t<classpathentry excluding=\\\"**/.svn/**|.svn/\\\" \");\n\t\tsb.append(\"kind=\\\"src\\\" path=\\\"docroot/WEB-INF/src\\\" />\\n\");\n\t\tsb.append(\"\\t<classpathentry kind=\\\"src\\\" path=\\\"/portal\\\" />\\n\");\n\t\tsb.append(\"\\t<classpathentry kind=\\\"con\\\" \");\n\t\tsb.append(\"path=\\\"org.eclipse.jdt.launching.JRE_CONTAINER\\\" />\\n\");\n\n\t\t_addClasspathEntry(sb, \"/portal/lib/development/mail.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/development/servlet.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/container.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/portlet-container.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/portlet.jar\");\n\n\t\tfor (String jar : portalJars) {\n\t\t\t_addClasspathEntry(sb, \"/portal/lib/portal/\" + jar);\n\t\t}\n\n\t\t_addClasspathEntry(sb, \"/portal/portal-kernel/portal-kernel.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/portal-service/portal-service.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-bridges/util-bridges.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-java/util-java.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-taglib/util-taglib.jar\");\n\n\t\tfor (String jar : customJars) {\n\t\t\t_addClasspathEntry(sb, \"docroot/WEB-INF/lib/\" + jar);\n\t\t}\n\n\t\tsb.append(\"\\t<classpathentry kind=\\\"output\\\" path=\\\"bin\\\" />\\n\");\n\t\tsb.append(\"<\/classpath>\");\n\n\t\tFile classpathFile = new File(projectPath + \"/.classpath\");\n\n\t\tSystem.out.println(\"Updating \" + classpathFile);\n\n\t\t_fileUtil.write(classpathFile, sb.toString());\n\n\t\t// SVN\n\n\t\tif (_svn) {\n\t\t\ttry {\n\t\t\t\t_exec(_SVN_INFO + projectFile);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_exec(_SVN_ADD + projectFile);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t_exec(_SVN_INFO + classpathFile);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_exec(_SVN_ADD + classpathFile);\n\t\t\t}\n\n\t\t\t_exec(_SVN_SET_IGNORES + \"bin \" + projectPath);\n\t\t}\n\t}","id":106158,"modified_method":"public void updateEclipseFiles(\n\t\t\tFile libDir, File projectDir, List<String> dependencyJars)\n\t\tthrows Exception {\n\n\t\tString projectPath = projectDir.getCanonicalPath();\n\t\tString projectName = StringUtil.extractLast(\n\t\t\tprojectPath, File.separator);\n\n\t\t// .project\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n\");\n\t\tsb.append(\"<projectDescription>\\n\");\n\t\tsb.append(\"\\t<name>\" + projectName + \"<\/name>\\n\");\n\t\tsb.append(\"\\t<comment><\/comment>\\n\");\n\t\tsb.append(\"\\t<projects><\/projects>\\n\");\n\t\tsb.append(\"\\t<buildSpec>\\n\");\n\t\tsb.append(\"\\t\\t<buildCommand>\\n\");\n\t\tsb.append(\"\\t\\t\\t<name>org.eclipse.jdt.core.javabuilder<\/name>\\n\");\n\t\tsb.append(\"\\t\\t\\t<arguments><\/arguments>\\n\");\n\t\tsb.append(\"\\t\\t<\/buildCommand>\\n\");\n\t\tsb.append(\"\\t<\/buildSpec>\\n\");\n\t\tsb.append(\"\\t<natures>\\n\");\n\t\tsb.append(\"\\t\\t<nature>org.eclipse.jdt.core.javanature<\/nature>\\n\");\n\t\tsb.append(\"\\t<\/natures>\\n\");\n\t\tsb.append(\"<\/projectDescription>\");\n\n\t\tFile projectFile = new File(projectPath + \"/.project\");\n\n\t\tSystem.out.println(\"Updating \" + projectFile);\n\n\t\t_fileUtil.write(projectFile, sb.toString());\n\n\t\t// .classpath\n\n\t\tList<String> portalJars = new ArrayList<String>(dependencyJars);\n\n\t\tportalJars.add(\"commons-logging.jar\");\n\t\tportalJars.add(\"log4j.jar\");\n\n\t\tCollections.sort(portalJars);\n\n\t\tString[] customJarsArray = libDir.list(new GlobFilenameFilter(\"*.jar\"));\n\n\t\tList<String> customJars = null;\n\n\t\tif (customJarsArray != null) {\n\t\t\tcustomJars = ListUtil.toList(customJarsArray);\n\n\t\t\tCollections.sort(customJars);\n\n\t\t\tfor (String jar : portalJars) {\n\t\t\t\tcustomJars.remove(jar);\n\t\t\t}\n\n\t\t\tcustomJars.remove(\"util-bridges.jar\");\n\t\t\tcustomJars.remove(\"util-java.jar\");\n\t\t\tcustomJars.remove(\"util-taglib.jar\");\n\t\t}\n\t\telse {\n\t\t\tcustomJars = new ArrayList<String>();\n\t\t}\n\n\t\tsb = new StringBuilder();\n\n\t\tsb.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n\");\n\t\tsb.append(\"<classpath>\\n\");\n\t\tsb.append(\"\\t<classpathentry excluding=\\\"**/.svn/**|.svn/\\\" \");\n\t\tsb.append(\"kind=\\\"src\\\" path=\\\"docroot/WEB-INF/src\\\" />\\n\");\n\t\tsb.append(\"\\t<classpathentry kind=\\\"src\\\" path=\\\"/portal\\\" />\\n\");\n\t\tsb.append(\"\\t<classpathentry kind=\\\"con\\\" \");\n\t\tsb.append(\"path=\\\"org.eclipse.jdt.launching.JRE_CONTAINER\\\" />\\n\");\n\n\t\t_addClasspathEntry(sb, \"/portal/lib/development/activation.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/development/mail.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/development/servlet.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/container.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/portlet-container.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/lib/global/portlet.jar\");\n\n\t\tfor (String jar : portalJars) {\n\t\t\t_addClasspathEntry(sb, \"/portal/lib/portal/\" + jar);\n\t\t}\n\n\t\t_addClasspathEntry(sb, \"/portal/portal-kernel/portal-kernel.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/portal-service/portal-service.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-bridges/util-bridges.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-java/util-java.jar\");\n\t\t_addClasspathEntry(sb, \"/portal/util-taglib/util-taglib.jar\");\n\n\t\tfor (String jar : customJars) {\n\t\t\t_addClasspathEntry(sb, \"docroot/WEB-INF/lib/\" + jar);\n\t\t}\n\n\t\tsb.append(\"\\t<classpathentry kind=\\\"output\\\" path=\\\"bin\\\" />\\n\");\n\t\tsb.append(\"<\/classpath>\");\n\n\t\tFile classpathFile = new File(projectPath + \"/.classpath\");\n\n\t\tSystem.out.println(\"Updating \" + classpathFile);\n\n\t\t_fileUtil.write(classpathFile, sb.toString());\n\n\t\t// SVN\n\n\t\tif (_svn) {\n\t\t\ttry {\n\t\t\t\t_exec(_SVN_INFO + projectFile);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_exec(_SVN_ADD + projectFile);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t_exec(_SVN_INFO + classpathFile);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_exec(_SVN_ADD + classpathFile);\n\t\t\t}\n\n\t\t\t_exec(_SVN_SET_IGNORES + \"bin \" + projectPath);\n\t\t}\n\t}","commit_id":"be6ad9440595b9926d929ebc9670d428a6fe03ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void visit(ClassDefinition that) {\n        super.visit(that);\n        Class klass = that.getDeclarationModel();\n        List<Parameter> parameters = klass.getParameterLists().get(0).getParameters();\n        for(Parameter param : parameters){\n            if(isPrimitive(param, param))\n                Util.markUnBoxed(param);\n        }\n    }","id":106159,"modified_method":"@Override\n    public void visit(ClassDefinition that) {\n        super.visit(that);\n        Class klass = that.getDeclarationModel();\n        // deal with invalid input\n        if(klass == null)\n            return;\n        List<ParameterList> parameterLists = klass.getParameterLists();\n        // deal with invalid input\n        if(parameterLists.isEmpty())\n            return;\n        List<Parameter> parameters = parameterLists.get(0).getParameters();\n        for(Parameter param : parameters){\n            if(isPrimitive(param, param))\n                Util.markUnBoxed(param);\n        }\n    }","commit_id":"e5e4af57588abe6afd2e72aa20c3f2cdf434d7a1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        if(isPrimitive(method, refinedMethod)) {\n            Util.markUnBoxed(method);\n            Util.markUnBoxed(refinedMethod);\n        }\n        Iterator<Parameter> parameters = method.getParameterLists().get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedMethod.getParameterLists().get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","id":106160,"modified_method":"@Override\n    public void visit(MethodDefinition that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        // deal with invalid input\n        if(method == null)\n            return;\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        // deal with invalid input\n        if(refinedMethod == null)\n            return;\n        if(isPrimitive(method, refinedMethod)) {\n            Util.markUnBoxed(method);\n            Util.markUnBoxed(refinedMethod);\n        }\n        List<ParameterList> methodParameterLists = method.getParameterLists();\n        List<ParameterList> refinedParameterLists = refinedMethod.getParameterLists();\n        // deal with invalid input\n        if(methodParameterLists.isEmpty()\n                || refinedParameterLists.isEmpty())\n            return;\n        Iterator<Parameter> parameters = methodParameterLists.get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedParameterLists.get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","commit_id":"e5e4af57588abe6afd2e72aa20c3f2cdf434d7a1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AttributeSetterDefinition that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel().getParameter();\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","id":106161,"modified_method":"@Override\n    public void visit(AttributeSetterDefinition that) {\n        super.visit(that);\n        Setter declarationModel = that.getDeclarationModel();\n        // deal with invalid input\n        if(declarationModel == null)\n            return;\n        TypedDeclaration declaration = declarationModel.getParameter();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","commit_id":"e5e4af57588abe6afd2e72aa20c3f2cdf434d7a1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Variable that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        if(isPrimitive(declaration, declaration))\n            Util.markUnBoxed(declaration);\n    }","id":106162,"modified_method":"@Override\n    public void visit(Variable that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        if(isPrimitive(declaration, declaration))\n            Util.markUnBoxed(declaration);\n    }","commit_id":"e5e4af57588abe6afd2e72aa20c3f2cdf434d7a1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","id":106163,"modified_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","commit_id":"e5e4af57588abe6afd2e72aa20c3f2cdf434d7a1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public BuildActionRunnerBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, BuildActionRunner buildActionRunner) {\n            this.adapter = adapter;\n            this.versionDetails = versionDetails;\n            this.modelMapping = modelMapping;\n            this.buildActionRunner = buildActionRunner;\n            mapper = new TaskPropertyHandlerFactory().forVersion(versionDetails);\n        }","id":106164,"modified_method":"public BuildActionRunnerBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, BuildActionRunner buildActionRunner) {\n            this.adapter = adapter;\n            this.versionDetails = versionDetails;\n            this.modelMapping = modelMapping;\n            this.buildActionRunner = buildActionRunner;\n            mapper = CompositeMappingAction.builder()\n                .add(new TaskPropertyHandlerFactory().forVersion(versionDetails))\n                .add(new IdeaProjectCompatibilityMapper(versionDetails))\n                .build();\n        }","commit_id":"addd888c6073d4629b5acd61b90359de4594b308","url":"https://github.com/gradle/gradle"},{"original_method":"public CancellableModelBuilderBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, InternalCancellableConnection builder, Transformer<RuntimeException, RuntimeException> exceptionTransformer) {\n        this.adapter = adapter;\n        this.versionDetails = versionDetails;\n        this.modelMapping = modelMapping;\n        this.builder = builder;\n        this.exceptionTransformer = exceptionTransformer;\n        mapper = new TaskPropertyHandlerFactory().forVersion(versionDetails);\n    }","id":106165,"modified_method":"public CancellableModelBuilderBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, InternalCancellableConnection builder, Transformer<RuntimeException, RuntimeException> exceptionTransformer) {\n        this.adapter = adapter;\n        this.versionDetails = versionDetails;\n        this.modelMapping = modelMapping;\n        this.builder = builder;\n        this.exceptionTransformer = exceptionTransformer;\n        this.mapper = CompositeMappingAction.builder()\n            .add(new TaskPropertyHandlerFactory().forVersion(versionDetails))\n            .add(new IdeaProjectCompatibilityMapper(versionDetails))\n            .build();\n    }","commit_id":"addd888c6073d4629b5acd61b90359de4594b308","url":"https://github.com/gradle/gradle"},{"original_method":"public InternalConnectionBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, InternalConnection delegate) {\n            this.adapter = adapter;\n            this.versionDetails = versionDetails;\n            this.modelMapping = modelMapping;\n            this.delegate = delegate;\n            this.mapper = new TaskPropertyHandlerFactory().forVersion(versionDetails);\n        }","id":106166,"modified_method":"public InternalConnectionBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, InternalConnection delegate) {\n            this.adapter = adapter;\n            this.versionDetails = versionDetails;\n            this.modelMapping = modelMapping;\n            this.delegate = delegate;\n            this.mapper = CompositeMappingAction.builder()\n                .add(new TaskPropertyHandlerFactory().forVersion(versionDetails))\n                .add(new IdeaProjectCompatibilityMapper(versionDetails))\n                .build();\n        }","commit_id":"addd888c6073d4629b5acd61b90359de4594b308","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelBuilderBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, ModelBuilder builder) {\n        this.adapter = adapter;\n        this.versionDetails = versionDetails;\n        this.modelMapping = modelMapping;\n        this.builder = builder;\n        mapper = new TaskPropertyHandlerFactory().forVersion(versionDetails);\n    }","id":106167,"modified_method":"public ModelBuilderBackedModelProducer(ProtocolToModelAdapter adapter, VersionDetails versionDetails, ModelMapping modelMapping, ModelBuilder builder) {\n        this.adapter = adapter;\n        this.versionDetails = versionDetails;\n        this.modelMapping = modelMapping;\n        this.builder = builder;\n        this.mapper = CompositeMappingAction.builder()\n            .add(new TaskPropertyHandlerFactory().forVersion(versionDetails))\n            .add(new IdeaProjectCompatibilityMapper(versionDetails))\n            .build();\n    }","commit_id":"addd888c6073d4629b5acd61b90359de4594b308","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        ByteBuffer payload = ByteBuffer.allocate(dataSize);\n        for (int i = 0; i < dataSize; i++)\n        {\n            payload.put((byte)0x44);\n        }\n        binary.setPayload(BufferUtil.toArray(payload));\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + 32);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\", expected, actual);\n    }","id":106168,"modified_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + FUDGE);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + FUDGE);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"071f15e0c9db853af0d549b2ceb8655b3d607b42","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        ByteBuffer payload = ByteBuffer.allocate(dataSize);\n        for (int i = 0; i < dataSize; i++)\n        {\n            payload.put((byte)0x44);\n        }\n        binary.setPayload(BufferUtil.toArray(payload));\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + 10);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        // System.out.println(binary);\n\n        // System.out.println(BufferUtil.toDetailString(expected));\n        // System.out.println(BufferUtil.toDetailString(actual));\n\n        // for (int i = 0; i < 20; ++i)\n        // {\n        // System.out.printf(\"a [%2d] 0x%02x%n\",i,actual.get());\n        // System.out.printf(\"e [%2d] 0x%02x%n\",i,expected.get());\n        // }\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\", expected, actual);\n\n    }","id":106169,"modified_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + 10);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"071f15e0c9db853af0d549b2ceb8655b3d607b42","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@OnWebSocketMessage\n    public void onText(String message)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            if (message == null)\n            {\n                LOG.debug(\"onText() msg=null\");\n            }\n            else\n            {\n                LOG.debug(\"onText() size={}, msg={}\",message.length(),abbreviate(message));\n            }\n        }\n\n        // echo the message back.\n        this.session.getRemote().sendStringByFuture(message);\n    }","id":106170,"modified_method":"@OnWebSocketMessage\n    public void onText(String message)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            if (message == null)\n            {\n                LOG.debug(\"onText() msg=null\");\n            }\n            else\n            {\n                LOG.debug(\"onText() size={}, msg={}\",message.length(),abbreviate(message));\n            }\n        }\n\n        try\n        {\n            // echo the message back.\n            this.session.getRemote().sendStringByFuture(message);\n        }\n        catch (WebSocketException e)\n        {\n            LOG.warn(\"Unable to echo TEXT message\",e);\n        }\n    }","commit_id":"be2cf578ced117440c3b31e5d76c7bc8b7d2e4b6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test for when encountering a \"Transfer-Encoding: chunked\" on a Upgrade Response header.\n     * <ul>\n     * <li><a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=393075\">Eclipse Jetty Bug #393075<\/a><\/li>\n     * <li><a href=\"https://issues.apache.org/bugzilla/show_bug.cgi?id=54067\">Apache Tomcat Bug #54067<\/a><\/li>\n     * <\/ul>\n     * \n     * @throws IOException\n     */\n    @Test\n    public void testTomcat7_0_32_WithTransferEncoding() throws Exception\n    {\n        BlockheadServer server = new BlockheadServer();\n        WebSocketClient client = new WebSocketClient();\n\n        try\n        {\n            int bufferSize = 512;\n\n            server.start();\n\n            // Setup Client Factory\n            client.start();\n\n            // Create End User WebSocket Class\n            LatchedSocket websocket = new LatchedSocket();\n\n            // Open connection\n            URI wsURI = server.getWsUri();\n            client.connect(websocket,wsURI);\n\n            // Accept incoming connection\n            ServerConnection socket = server.accept();\n            socket.setSoTimeout(2000); // timeout\n\n            // Issue upgrade\n            // Add the extra problematic header that triggers bug found in jetty-io\n            socket.addResponseHeader(\"Transfer-Encoding\",\"chunked\");\n            socket.upgrade();\n\n            // Wait for proper upgrade\n            Assert.assertTrue(\"Timed out waiting for Client side WebSocket open event\",websocket.openLatch.await(1,TimeUnit.SECONDS));\n\n            // Have server write frame.\n            int length = bufferSize / 2;\n            ByteBuffer serverFrame = ByteBuffer.allocate(bufferSize);\n            serverFrame.put((byte)(0x80 | 0x01)); // FIN + TEXT\n            serverFrame.put((byte)0x7E); // No MASK and 2 bytes length\n            serverFrame.put((byte)(length >> 8)); // first length byte\n            serverFrame.put((byte)(length & 0xFF)); // second length byte\n            for (int i = 0; i < length; ++i)\n            {\n                serverFrame.put((byte)'x');\n            }\n            serverFrame.flip();\n            byte buf[] = serverFrame.array();\n            socket.write(buf,0,buf.length);\n            socket.flush();\n\n            Assert.assertTrue(websocket.dataLatch.await(1000,TimeUnit.SECONDS));\n        }\n        finally\n        {\n            client.stop();\n            server.stop();\n        }\n    }","id":106171,"modified_method":"/**\n     * Test for when encountering a \"Transfer-Encoding: chunked\" on a Upgrade Response header.\n     * <ul>\n     * <li><a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=393075\">Eclipse Jetty Bug #393075<\/a><\/li>\n     * <li><a href=\"https://issues.apache.org/bugzilla/show_bug.cgi?id=54067\">Apache Tomcat Bug #54067<\/a><\/li>\n     * <\/ul>\n     * \n     * @throws IOException\n     */\n    @Test\n    public void testTomcat7_0_32_WithTransferEncoding() throws Exception\n    {\n        BlockheadServer server = new BlockheadServer();\n        WebSocketClient client = new WebSocketClient();\n\n        try\n        {\n            final int bufferSize = 512;\n\n            server.start();\n\n            // Setup Client Factory\n            client.start();\n\n            // Create End User WebSocket Class\n            LatchedSocket websocket = new LatchedSocket();\n\n            // Open connection\n            URI wsURI = server.getWsUri();\n            client.connect(websocket,wsURI);\n\n            // Accept incoming connection\n            ServerConnection socket = server.accept();\n            socket.setSoTimeout(2000); // timeout\n\n            // Issue upgrade\n            // Add the extra problematic header that triggers bug found in jetty-io\n            socket.addResponseHeader(\"Transfer-Encoding\",\"chunked\");\n            socket.upgrade();\n\n            // Wait for proper upgrade\n            Assert.assertTrue(\"Timed out waiting for Client side WebSocket open event\",websocket.openLatch.await(1,TimeUnit.SECONDS));\n\n            // Have server write frame.\n            byte payload[] = new byte[bufferSize / 2];\n            Arrays.fill(payload,(byte)'x');\n            ByteBuffer serverFrame = BufferUtil.allocate(bufferSize);\n            BufferUtil.flipToFill(serverFrame);\n            serverFrame.put((byte)(0x80 | 0x01)); // FIN + TEXT\n            serverFrame.put((byte)0x7E); // No MASK and 2 bytes length\n            serverFrame.put((byte)(payload.length >> 8)); // first length byte\n            serverFrame.put((byte)(payload.length & 0xFF)); // second length byte\n            serverFrame.put(payload);\n            BufferUtil.flipToFlush(serverFrame,0);\n            byte buf[] = BufferUtil.toArray(serverFrame);\n            socket.write(buf,0,buf.length);\n            socket.flush();\n\n            Assert.assertTrue(websocket.dataLatch.await(1000,TimeUnit.SECONDS));\n        }\n        finally\n        {\n            client.stop();\n            server.stop();\n        }\n    }","commit_id":"be2cf578ced117440c3b31e5d76c7bc8b7d2e4b6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test the requirement of issuing socket and receiving echo response\n     */\n    @Test\n    public void testEcho() throws Exception\n    {\n        Assert.assertThat(\"server scheme\",server.getServerUri().getScheme(),is(\"wss\"));\n        WebSocketClient client = new WebSocketClient(server.getSslContextFactory());\n        try\n        {\n            client.start();\n\n            CaptureSocket clientSocket = new CaptureSocket();\n            Future<Session> fut = client.connect(clientSocket,server.getServerUri());\n\n            // wait for connect\n            Session session = fut.get(1,TimeUnit.SECONDS);\n\n            // Generate text frame\n            String msg = \"this is an echo ... cho ... ho ... o\";\n            session.getRemote().sendString(msg);\n\n            // Read frame (hopefully text frame)\n            clientSocket.messages.awaitEventCount(1,500,TimeUnit.MILLISECONDS);\n            EventQueue<String> captured = clientSocket.messages;\n            Assert.assertThat(\"Text Message\",captured.poll(),is(msg));\n\n            // Shutdown the socket\n            clientSocket.close();\n        }\n        finally\n        {\n            client.stop();\n        }\n    }","id":106172,"modified_method":"/**\n     * Test the requirement of issuing socket and receiving echo response\n     */\n    @Test\n    public void testEcho() throws Exception\n    {\n        Assert.assertThat(\"server scheme\",server.getServerUri().getScheme(),is(\"wss\"));\n        WebSocketClient client = new WebSocketClient(server.getSslContextFactory());\n        try\n        {\n            client.start();\n\n            CaptureSocket clientSocket = new CaptureSocket();\n            Future<Session> fut = client.connect(clientSocket,server.getServerUri());\n\n            // wait for connect\n            Session session = fut.get(3,TimeUnit.SECONDS);\n\n            // Generate text frame\n            String msg = \"this is an echo ... cho ... ho ... o\";\n            session.getRemote().sendString(msg);\n\n            // Read frame (hopefully text frame)\n            clientSocket.messages.awaitEventCount(1,500,TimeUnit.MILLISECONDS);\n            EventQueue<String> captured = clientSocket.messages;\n            Assert.assertThat(\"Text Message\",captured.poll(),is(msg));\n\n            // Shutdown the socket\n            clientSocket.close();\n        }\n        finally\n        {\n            client.stop();\n        }\n    }","commit_id":"be2cf578ced117440c3b31e5d76c7bc8b7d2e4b6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test the requirement of responding with server terminated close code 1011 when there is an unhandled (internal server error) being produced by the\n     * WebSocket POJO.\n     */\n    @Test\n    public void testInternalError() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            // Generate text frame\n            client.write(WebSocketFrame.text(\"CRASH\"));\n\n            // Read frame (hopefully close frame)\n            IncomingFramesCapture capture = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            Frame cf = capture.getFrames().poll();\n            CloseInfo close = new CloseInfo(cf);\n            Assert.assertThat(\"Close Frame.status code\",close.getStatusCode(),is(StatusCode.SERVER_ERROR));\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":106173,"modified_method":"/**\n     * Test the requirement of responding with server terminated close code 1011 when there is an unhandled (internal server error) being produced by the\n     * WebSocket POJO.\n     */\n    @Test\n    public void testInternalError() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            try (StacklessLogging context = new StacklessLogging(EventDriver.class))\n            {\n                // Generate text frame\n                client.write(WebSocketFrame.text(\"CRASH\"));\n\n                // Read frame (hopefully close frame)\n                IncomingFramesCapture capture = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n                Frame cf = capture.getFrames().poll();\n                CloseInfo close = new CloseInfo(cf);\n                Assert.assertThat(\"Close Frame.status code\",close.getStatusCode(),is(StatusCode.SERVER_ERROR));\n            }\n        }\n        finally\n        {\n            client.close();\n        }\n    }","commit_id":"be2cf578ced117440c3b31e5d76c7bc8b7d2e4b6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    for(LanguageProjectTemplate template : LanguageProjectTemplate.EP_NAME.getExtensions())\n      mpsProjectTemplates.add(template);\n    return mpsProjectTemplates;\n  }","id":106174,"modified_method":"@NotNull\n  @Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    Collections.addAll(mpsProjectTemplates, LanguageProjectTemplate.EP_NAME.getExtensions());\n    return mpsProjectTemplates;\n  }","commit_id":"1f959242d9e8d1aa349ae11c81f3f8fc96e13288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setProjectPath(String projectPath) {\n    String oldProjectPath = myProjectPath;\n    myProjectPath = projectPath;\n    if ((oldProjectPath != null && oldProjectPath.length() > 0) && myLanguageLocation.getText().contains(oldProjectPath)) {\n      setLanguageLocation(myLanguageLocation.getText().replace(oldProjectPath, myProjectPath));\n    } else {\n      setLanguageLocation(generateLanguagePath());\n    }\n    fireChanged();\n  }","id":106175,"modified_method":"public void setProjectPath(String projectPath) {\n    // If path is the same - just return \n    if (myProjectPath != null && myProjectPath.equals(projectPath)) {\n      return;\n    }\n\n    final String oldProjectPath = myProjectPath;\n    myProjectPath = projectPath;\n    if ((oldProjectPath != null && oldProjectPath.length() > 0) && myLanguageLocation.getText().contains(oldProjectPath)) {\n      setLanguageLocation(myLanguageLocation.getText().replace(oldProjectPath, myProjectPath));\n    } else {\n      setLanguageLocation(generateLanguagePath());\n    }\n    fireChanged();\n  }","commit_id":"1f959242d9e8d1aa349ae11c81f3f8fc96e13288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setProjectPath(String projectPath) {\n    String oldProjectPath = myProjectPath;\n    myProjectPath = projectPath;\n    if ((oldProjectPath != null && oldProjectPath.length() > 0) && mySolutionLocation.getText().contains(oldProjectPath)) {\n      setSolutionLocation(mySolutionLocation.getText().replace(oldProjectPath, myProjectPath));\n    } else {\n      setSolutionLocation(myProjectPath + File.separator + \"solutions\" + File.separator + getSolutionLocation());\n    }\n    fireChaged();\n  }","id":106176,"modified_method":"public void setProjectPath(String projectPath) {\n    // If path is the same - just return \n    if (myProjectPath != null && myProjectPath.equals(projectPath)) {\n      return;\n    }\n\n    final String oldProjectPath = myProjectPath;\n    myProjectPath = projectPath;\n    if ((oldProjectPath != null && oldProjectPath.length() > 0) && mySolutionLocation.getText().contains(oldProjectPath)) {\n      setSolutionLocation(mySolutionLocation.getText().replace(oldProjectPath, myProjectPath));\n    } else {\n      setSolutionLocation(generateSolutionPath());\n    }\n    fireChaged();\n  }","commit_id":"1f959242d9e8d1aa349ae11c81f3f8fc96e13288","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    for(OtherProjectTemplate template : OtherProjectTemplate.EP_NAME.getExtensions())\n      mpsProjectTemplates.add(template);\n    return mpsProjectTemplates;\n  }","id":106177,"modified_method":"@NotNull\n  @Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    Collections.addAll(mpsProjectTemplates, OtherProjectTemplate.EP_NAME.getExtensions());\n    return mpsProjectTemplates;\n  }","commit_id":"1f959242d9e8d1aa349ae11c81f3f8fc96e13288","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    for(SolutionProjectTemplate template : SolutionProjectTemplate.EP_NAME.getExtensions())\n      mpsProjectTemplates.add(template);\n    return mpsProjectTemplates;\n  }","id":106178,"modified_method":"@NotNull\n  @Override\n  public Collection<MPSProjectTemplate> getTemplates() {\n    List<MPSProjectTemplate> mpsProjectTemplates = new LinkedList<MPSProjectTemplate>();\n    Collections.addAll(mpsProjectTemplates, SolutionProjectTemplate.EP_NAME.getExtensions());\n    return mpsProjectTemplates;\n  }","commit_id":"1f959242d9e8d1aa349ae11c81f3f8fc96e13288","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public List<DiffTool> getDiffTools() {\n    List<DiffTool> result = new ArrayList<DiffTool>();\n\n    result.add(SimpleDiffTool.INSTANCE);\n    result.add(OnesideDiffTool.INSTANCE);\n    result.add(BinaryDiffTool.INSTANCE);\n    result.add(DirDiffTool.INSTANCE);\n\n    for (DiffTool tool : DiffTool.EP_NAME.getExtensions()) {\n      result.add(tool);\n    }\n\n    return result;\n  }","id":106179,"modified_method":"@NotNull\n  @Override\n  public List<DiffTool> getDiffTools() {\n    List<DiffTool> result = new ArrayList<DiffTool>();\n    result.add(SimpleDiffTool.INSTANCE);\n    result.add(OnesideDiffTool.INSTANCE);\n    result.add(BinaryDiffTool.INSTANCE);\n    result.add(DirDiffTool.INSTANCE);\n    Collections.addAll(result, DiffTool.EP_NAME.getExtensions());\n    return result;\n  }","commit_id":"ad56e564e63d64e27e2a3babbe2bdd3fd6ffcb47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param timeStart start time in milliseconds, used to report training speed\n   * @param dest_key where to store the model with the diagnostics in it\n   * @return true if model building is ongoing\n   */\n  boolean doDiagnostics(Frame ftrain, Frame ftest, long timeStart, Key dest_key) {\n    epoch_counter = (float)model_info().get_processed_total()/model_info().data_info._adaptedFrame.numRows();\n    run_time = (System.currentTimeMillis()-start_time);\n    boolean keep_running = (epoch_counter < model_info().parameters.epochs);\n    _now = System.currentTimeMillis();\n    final long sinceLastScore = _now-_timeLastScoreStart;\n    final long sinceLastPrint = _now-_timeLastPrintStart;\n    final long samples = model_info().get_processed_total();\n    if (sinceLastPrint > model_info().parameters.score_interval*1000) {\n      _timeLastPrintStart = _now;\n      Log.info(\"Training time: \" + PrettyPrint.msecs(_now - start_time, true)\n              + \" processed \" + samples + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((_now - start_time)/1000.)) + \" samples/sec.\");\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running || sinceLastScore > model_info().parameters.score_interval*1000) {\n      Log.info(\"Scoring the model.\");\n      _timeLastScoreStart = _now;\n      boolean printCM = false;\n      // compute errors\n      Errors err = new Errors();\n      err.classification = isClassifier();\n      assert(err.classification == model_info().get_params().classification);\n      err.training_time_ms = _now - timeStart;\n      err.epoch_counter = epoch_counter;\n      err.validation = ftest != null;\n      err.training_samples = model_info().get_processed_total();\n      err.score_training_samples = ftrain.numRows();\n      err.train_confusion_matrix = new ConfusionMatrix();\n      final double trainErr = calcError(ftrain, \"Error on training data:\", printCM, err.train_confusion_matrix);\n      if (err.classification) err.train_err = trainErr;\n      else err.train_mse = trainErr;\n\n      if (err.validation) {\n        err.score_validation_samples = ftest.numRows();\n        err.valid_confusion_matrix = new ConfusionMatrix();\n        final double validErr = calcError(ftest, \"Error on validation data:\", printCM, err.valid_confusion_matrix);\n        if (err.classification) err.valid_err = validErr;\n        else err.valid_mse = validErr;\n      }\n      // enlarge the error array by one, push latest score back\n      if (errors == null) {\n         errors = new Errors[]{err};\n      } else {\n        Errors[] err2 = new Errors[errors.length+1];\n        System.arraycopy(errors, 0, err2, 0, errors.length);\n        err2[err2.length-1] = err;\n        errors = err2;\n      }\n      // print the freshly scored model to ASCII\n      for (String s : toString().split(\"\\n\")) Log.info(s);\n      Log.info(\"Scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - _now, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n      keep_running = false;\n    } else if (ftest == null &&\n            (model_info().parameters.classification && errors[errors.length-1].train_err == 0)\n        || (!model_info().parameters.classification && errors[errors.length-1].train_mse == 0)\n            ) {\n      Log.info(\"Achieved 100% modeling accuracy on the training data. We are done here.\");\n      keep_running = false;\n    } else if (ftest != null &&\n            (model_info().parameters.classification && errors[errors.length-1].valid_err == 0)\n        || (!model_info().parameters.classification && errors[errors.length-1].valid_mse == 0)\n            ) {\n      Log.info(\"Achieved 100% modeling accuracy on the validation data. We are done here.\");\n      keep_running = false;\n    }\n    update(dest_key); //update model in UKV\n//    System.out.println(this);\n    return keep_running;\n  }","id":106180,"modified_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param timeStart start time in milliseconds, used to report training speed\n   * @param dest_key where to store the model with the diagnostics in it\n   * @return true if model building is ongoing\n   */\n  boolean doDiagnostics(Frame ftrain, Frame ftest, long timeStart, Key dest_key) {\n    epoch_counter = (float)model_info().get_processed_total()/model_info().data_info._adaptedFrame.numRows();\n    run_time = (System.currentTimeMillis()-start_time);\n    boolean keep_running = (epoch_counter < model_info().parameters.epochs);\n    _now = System.currentTimeMillis();\n    final long sinceLastScore = _now-_timeLastScoreStart;\n    final long sinceLastPrint = _now-_timeLastPrintStart;\n    final long samples = model_info().get_processed_total();\n    if (sinceLastPrint > model_info().parameters.score_interval*1000) {\n      _timeLastPrintStart = _now;\n      Log.info(\"Training time: \" + PrettyPrint.msecs(_now - start_time, true)\n              + \" processed \" + samples + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((_now - start_time)/1000.)) + \" samples/sec.\");\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running || sinceLastScore > model_info().parameters.score_interval*1000) {\n      Log.info(\"Scoring the model.\");\n      _timeLastScoreStart = _now;\n      boolean printCM = false;\n      // compute errors\n      Errors err = new Errors();\n      err.classification = isClassifier();\n      assert(err.classification == model_info().get_params().classification);\n      err.training_time_ms = _now - timeStart;\n      err.epoch_counter = epoch_counter;\n      err.validation = ftest != null;\n      err.training_samples = model_info().get_processed_total();\n      err.score_training_samples = ftrain.numRows();\n      err.train_confusion_matrix = new ConfusionMatrix();\n      final double trainErr = calcError(ftrain, \"Error on training data:\", printCM, err.train_confusion_matrix);\n      if (err.classification) err.train_err = trainErr;\n      else err.train_mse = trainErr;\n\n      if (err.validation) {\n        err.score_validation_samples = ftest.numRows();\n        err.valid_confusion_matrix = new ConfusionMatrix();\n        final double validErr = calcError(ftest, \"Error on validation data:\", printCM, err.valid_confusion_matrix);\n        if (err.classification) err.valid_err = validErr;\n        else err.valid_mse = validErr;\n      }\n      // enlarge the error array by one, push latest score back\n      if (errors == null) {\n         errors = new Errors[]{err};\n      } else {\n        Errors[] err2 = new Errors[errors.length+1];\n        System.arraycopy(errors, 0, err2, 0, errors.length);\n        err2[err2.length-1] = err;\n        errors = err2;\n      }\n      // print the freshly scored model to ASCII\n      for (String s : toString().split(\"\\n\")) Log.info(s);\n      Log.info(\"Scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - _now, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n      keep_running = false;\n    } else if (ftest == null &&\n            (model_info().get_params().classification && errors[errors.length-1].train_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].train_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved 100% modeling accuracy on the training data. We are done here.\");\n      keep_running = false;\n    } else if (ftest != null &&\n            (model_info().get_params().classification && errors[errors.length-1].valid_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].valid_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved 100% modeling accuracy on the validation data. We are done here.\");\n      keep_running = false;\n    }\n    update(dest_key); //update model in UKV\n//    System.out.println(this);\n    return keep_running;\n  }","commit_id":"75626055d785d24fb2fa0091906bcc9ee5cb1e90","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private Resource searchAddedResources(Requirement req)\n    {\n        for (Iterator iter = m_addedSet.iterator(); iter.hasNext(); )\n        {\n            Resource resource = (Resource) iter.next();\n            Capability[] caps = resource.getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (req.isSatisfied(caps[capIdx]))\n                {\n                    // The requirement is already satisfied an existing\n                    // resource, return the resource.\n                    return resource;\n                }\n            }\n        }\n\n        return null;\n    }","id":106181,"modified_method":"private Resource searchAddedResources(Requirement req)\n    {\n        for (Iterator iter = m_addedSet.iterator(); iter.hasNext(); )\n        {\n            Resource resource = (Resource) iter.next();\n            Capability[] caps = resource.getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (caps[capIdx].getName().equals(req.getName())\n                    && req.isSatisfied(caps[capIdx]))\n                {\n                    // The requirement is already satisfied an existing\n                    // resource, return the resource.\n                    return resource;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"a1dbe0d7429ebaa48f14827a2dc9f9ec1b2ee362","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Searches for remote resources that do meet the given requirement\n     * @param req\n     * @return all remote resources meeting the given requirement\n     */\n    private List searchRemoteResources(Requirement req)\n    {\n        List matchingCandidates = new ArrayList();\n\n        Repository[] repos = m_admin.listRepositories();\n        for (int repoIdx = 0; (repos != null) && (repoIdx < repos.length); repoIdx++)\n        {\n            Resource[] resources = repos[repoIdx].getResources();\n            for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n            {\n                Capability[] caps = resources[resIdx].getCapabilities();\n                for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n                {\n                    if (req.isSatisfied(caps[capIdx]))\n                    {\n                        matchingCandidates.add(resources[resIdx]);\n                    }\n                }\n            }\n        }\n\n        return matchingCandidates;\n    }","id":106182,"modified_method":"/**\n     * Searches for remote resources that do meet the given requirement\n     * @param req\n     * @return all remote resources meeting the given requirement\n     */\n    private List searchRemoteResources(Requirement req)\n    {\n        List matchingCandidates = new ArrayList();\n\n        Repository[] repos = m_admin.listRepositories();\n        for (int repoIdx = 0; (repos != null) && (repoIdx < repos.length); repoIdx++)\n        {\n            Resource[] resources = repos[repoIdx].getResources();\n            for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n            {\n                Capability[] caps = resources[resIdx].getCapabilities();\n                for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n                {\n                    if (caps[capIdx].getName().equals(req.getName())\n                        && req.isSatisfied(caps[capIdx]))\n                    {\n                        matchingCandidates.add(resources[resIdx]);\n                    }\n                }\n            }\n        }\n\n        return matchingCandidates;\n    }","commit_id":"a1dbe0d7429ebaa48f14827a2dc9f9ec1b2ee362","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns a local resource meeting the given requirement\n     * @param req The requirement that the local resource must meet\n     * @return Returns the found local resource if available\n     */\n    private List searchLocalResources(Requirement req)\n    {\n        List matchingCandidates = new ArrayList();\n        Resource[] resources = m_local.getResources();\n        for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n        {\n            Capability[] caps = resources[resIdx].getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (req.isSatisfied(caps[capIdx]))\n                {\n                    matchingCandidates.add(resources[resIdx]);\n                }\n            }\n        }\n\n        return matchingCandidates;\n    }","id":106183,"modified_method":"/**\n     * Returns a local resource meeting the given requirement\n     * @param req The requirement that the local resource must meet\n     * @return Returns the found local resource if available\n     */\n    private List searchLocalResources(Requirement req)\n    {\n        List matchingCandidates = new ArrayList();\n        Resource[] resources = m_local.getResources();\n        for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n        {\n            Capability[] caps = resources[resIdx].getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (caps[capIdx].getName().equals(req.getName())\n                    && req.isSatisfied(caps[capIdx]))\n                {\n                    matchingCandidates.add(resources[resIdx]);\n                }\n            }\n        }\n\n        return matchingCandidates;\n    }","commit_id":"a1dbe0d7429ebaa48f14827a2dc9f9ec1b2ee362","url":"https://github.com/apache/felix"},{"original_method":"private Resource searchResolvingResources(Requirement req)\n    {\n        Resource[] resources = (Resource[])\n            m_resolveSet.toArray(new Resource[m_resolveSet.size()]);\n        for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n        {\n            Capability[] caps = resources[resIdx].getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (req.isSatisfied(caps[capIdx]))\n                {\n                    return resources[resIdx];\n                }\n            }\n        }\n\n        return null;\n    }","id":106184,"modified_method":"private Resource searchResolvingResources(Requirement req)\n    {\n        Resource[] resources = (Resource[])\n            m_resolveSet.toArray(new Resource[m_resolveSet.size()]);\n        for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n        {\n            Capability[] caps = resources[resIdx].getCapabilities();\n            for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n            {\n                if (caps[capIdx].getName().equals(req.getName())\n                    && req.isSatisfied(caps[capIdx]))\n                {\n                    return resources[resIdx];\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"a1dbe0d7429ebaa48f14827a2dc9f9ec1b2ee362","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * This pulls the podcasts from Resourses and stuffs it in a list to be\n\t * added to the feed\n\t * \n\t * @param siteId\n\t *            The site to pull the individual podcasts from\n\t * \n\t * @return List The list of podcast entries from ContentHosting\n\t */\n\tprivate List populatePodcastArray(String siteId) {\n\t\tList podEntries = null;\n\t\tList entries = new ArrayList();\n\n\t\ttry {\n\t\t\tenablePodfeedSecurityAdvisor();\n\t\t\t\n\t\t\t// get the individual podcasts\n\t\t\tpodEntries = podcastService.getPodcasts(siteId);\n\t\t\t\n\t\t\t// remove any that are in the future\n\t\t\tpodEntries = podcastService.filterPodcasts(podEntries);\n\n\t\t} \n\t\tcatch (PermissionException e) {\n\t\t\tLOG.error(\"PermissionException getting podcasts in order to generate podfeed for site: \"\n\t\t\t\t\t\t+ siteId + \". \" + e.getMessage(), e);\n\t\t\tthrow new Error(e);\n\t\t\t\n\t\t} \n\t\tcatch (Exception e) {\n\t\t\tLOG.info(e.getMessage() + \"for site: \" + siteId, e);\n\t\t\tthrow new Error(e);\n\t\t} \n\t\tfinally {\n\t\t\tsecurityService.clearAdvisors();\n\t\t}\n\n\t\tif (podEntries != null) {\n\t\t\t// get the iterator\n\t\t\tIterator podcastIter = podEntries.iterator();\n\n\t\t\twhile (podcastIter.hasNext()) {\n\n\t\t\t\t// get its properties from ContentHosting\n\t\t\t\tContentResource podcastResource = (ContentResource) podcastIter.next();\n\t\t\t\tResourceProperties podcastProperties = podcastResource.getProperties();\n\n\t\t\t\t// publish date for this particular podcast\n\t\t\t\tDate publishDate = null;\n\n\t\t\t\ttry {\n\t\t\t\t\t// need to put in GMT for the feed\n\t\t\t\t\tpublishDate = podcastService.getGMTdate(podcastProperties.getTimeProperty(PodcastService.DISPLAY_DATE).getTime());\n\n\t\t\t\t} \n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t// catches EntityPropertyNotDefinedException, EntityPropertyTypeException\n\t\t\t\t\tLOG.warn(e.getMessage() + \" generating podfeed getting DISPLAY_DATE for entry for site: \"\n\t\t\t\t\t\t\t\t\t+ siteId + \"while building feed. SKIPPING... \" + e.getMessage());\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if getting the date generates an error, skip this podcast.\n\t\t\t\tif (publishDate != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal String title = podcastProperties.getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\n\t\t\t\t\t\tenablePodfeedSecurityAdvisor();\n\t\t\t\t\t\tString fileUrl = podcastService.getPodcastFileURL(podcastResource.getId());\n\t\t\t\t\t\tfinal String podcastFolderId = podcastService.retrievePodcastFolderId(siteId);\n\t\t\t\t\t\tsecurityService.clearAdvisors();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if site Display to Site, need to access actual podcasts thru Dav servlet\n\t\t\t\t\t\t// so change item URLs to do so\n\t\t\t\t\t\tif (!podcastService.isPublic(podcastFolderId)) {\n\t\t\t\t\t\t\tfileUrl = convertToDavUrl(fileUrl);\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tfinal String description = podcastProperties.getPropertyFormatted(ResourceProperties.PROP_DESCRIPTION);\n\t\t\t\t\t\tfinal String author = podcastProperties.getPropertyFormatted(ResourceProperties.PROP_CREATOR);\n\t\t\t\t\t\tfinal long contentLength = Long.parseLong(podcastProperties.getProperty(ResourceProperties.PROP_CONTENT_LENGTH));\n\t\t\t\t\t\tfinal String contentType = podcastProperties.getProperty(ResourceProperties.PROP_CONTENT_TYPE);\n\n\t\t\t\t\t\tentries.add(addPodcast(title, fileUrl, publishDate, description, author,\n\t\t\t\t\t\t\t\tcontentLength, contentType));\n\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PermissionException e) {\n\t\t\t\t\t\t// Problem with this podcast file - LOG and skip\n\t\t\t\t\t\tLOG.error(\"PermissionException generating podfeed while adding entry for site: \"\n\t\t\t\t\t\t\t+ siteId + \". SKIPPING... \" + e.getMessage());\n\n\t\t\t\t\t} \n\t\t\t\t\tcatch (IdUnusedException e) {\n\t\t\t\t\t\t// Problem with this podcast file - LOG and skip\n\t\t\t\t\t\tLOG.warn(\"IdUnusedException generating podfeed while adding entry for site: \"\n\t\t\t\t\t\t\t+ siteId + \".  SKIPPING... \" + e.getMessage());\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\tsecurityService.clearAdvisors();\n\n\t\treturn entries;\n\n\t}","id":106185,"modified_method":"/**\n\t * This pulls the podcasts from Resourses and stuffs it in a list to be\n\t * added to the feed\n\t * \n\t * @param siteId\n\t *            The site to pull the individual podcasts from\n\t * \n\t * @return List The list of podcast entries from ContentHosting\n\t */\n\tprivate List populatePodcastArray(String siteId) {\n\t\tList podEntries = null;\n\t\tList entries = new ArrayList();\n\n\t\ttry {\n\t\t\tenablePodfeedSecurityAdvisor();\n\t\t\t\n\t\t\t// get the individual podcasts\n\t\t\tpodEntries = podcastService.getPodcasts(siteId);\n\t\t\t\n\t\t\t// remove any that are in the future\n\t\t\tpodEntries = podcastService.filterPodcasts(podEntries);\n\n\t\t} \n\t\tcatch (PermissionException e) {\n\t\t\tLOG.error(\"PermissionException getting podcasts in order to generate podfeed for site: \"\n\t\t\t\t\t\t+ siteId + \". \" + e.getMessage(), e);\n\t\t\tthrow new Error(e);\n\t\t\t\n\t\t} \n\t\tcatch (Exception e) {\n\t\t\tLOG.info(e.getMessage() + \"for site: \" + siteId, e);\n\t\t\tthrow new Error(e);\n\t\t} \n\t\tfinally {\n\t\t\tsecurityService.clearAdvisors();\n\t\t}\n\n\t\tif (podEntries != null) {\n\t\t\t// get the iterator\n\t\t\tIterator podcastIter = podEntries.iterator();\n\n\t\t\twhile (podcastIter.hasNext()) {\n\n\t\t\t\t// get its properties from ContentHosting\n\t\t\t\tContentResource podcastResource = (ContentResource) podcastIter.next();\n\t\t\t\tResourceProperties podcastProperties = podcastResource.getProperties();\n\n\t\t\t\t// publish date for this particular podcast\n\t\t\t\tDate publishDate = null;\n\n\t\t\t\ttry {\n\t\t\t\t\t// need to put in GMT for the feed\n\t\t\t\t\tpublishDate = podcastService.getGMTdate(podcastProperties.getTimeProperty(PodcastService.DISPLAY_DATE).getTime());\n\n\t\t\t\t} \n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t// catches EntityPropertyNotDefinedException, EntityPropertyTypeException\n\t\t\t\t\tLOG.warn(e.getMessage() + \" generating podfeed getting DISPLAY_DATE for entry for site: \"\n\t\t\t\t\t\t\t\t\t+ siteId + \"while building feed. SKIPPING... \" + e.getMessage());\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if getting the date generates an error, skip this podcast.\n\t\t\t\tif (publishDate != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMap podcastMap = new HashMap();\n\t\t\t\t\t\tpodcastMap.put(\"date\", publishDate);\n\t\t\t\t\t\tpodcastMap.put(\"title\", podcastProperties.getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME));\n\t\t\t\t\t\t\n\t\t\t\t\t\tenablePodfeedSecurityAdvisor();\n\t\t\t\t\t\tString fileUrl = podcastService.getPodcastFileURL(podcastResource.getId());\n\t\t\t\t\t\tpodcastMap.put(\"guid\", fileUrl);\n\t\t\t\t\t\tfinal String podcastFolderId = podcastService.retrievePodcastFolderId(siteId);\n\t\t\t\t\t\tsecurityService.clearAdvisors();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if site Display to Site, need to access actual podcasts thru Dav servlet\n\t\t\t\t\t\t// so change item URLs to do so\n\t\t\t\t\t\tif (!podcastService.isPublic(podcastFolderId)) {\n\t\t\t\t\t\t\tfileUrl = convertToDavUrl(fileUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tpodcastMap.put(\"url\", fileUrl);\n\t\t\t\t\t\tpodcastMap.put(\"description\",podcastProperties.getPropertyFormatted(ResourceProperties.PROP_DESCRIPTION));\n\t\t\t\t\t\tpodcastMap.put(\"author\", podcastProperties.getPropertyFormatted(ResourceProperties.PROP_CREATOR));\n\t\t\t\t\t\tpodcastMap.put(\"len\", Long.parseLong(podcastProperties.getProperty(ResourceProperties.PROP_CONTENT_LENGTH)));\n\t\t\t\t\t\tpodcastMap.put(\"type\", podcastProperties.getProperty(ResourceProperties.PROP_CONTENT_TYPE));\n\t\t\t\t\t\t\n\t\t\t\t\t\tentries.add(addPodcast(podcastMap));\n\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PermissionException e) {\n\t\t\t\t\t\t// Problem with this podcast file - LOG and skip\n\t\t\t\t\t\tLOG.error(\"PermissionException generating podfeed while adding entry for site: \"\n\t\t\t\t\t\t\t+ siteId + \". SKIPPING... \" + e.getMessage());\n\n\t\t\t\t\t} \n\t\t\t\t\tcatch (IdUnusedException e) {\n\t\t\t\t\t\t// Problem with this podcast file - LOG and skip\n\t\t\t\t\t\tLOG.warn(\"IdUnusedException generating podfeed while adding entry for site: \"\n\t\t\t\t\t\t\t+ siteId + \".  SKIPPING... \" + e.getMessage());\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\tsecurityService.clearAdvisors();\n\n\t\treturn entries;\n\n\t}","commit_id":"7ac6dc0c12b725e87a117a5be7e46f323933e975","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void appendToResponse(WOResponse response, WOContext context) {\n\t  WOComponent component = context.component();\n\n\t  response.appendContentString(\"<input \");\n\t  String name = nameInContext(context, component);\n\t  appendTagAttributeToResponse(response, \"type\", \"button\");\n\t  appendTagAttributeToResponse(response, \"name\", name);\n\t  appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component ));\n\t  appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component ));\n\t  appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component ));\n\t  appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component ));\n\t  if(disabledInComponent(component)) {\n          appendTagAttributeToResponse(response, \"disabled\", \"disabled\");\n\t  }\n\t  StringBuffer sb = new StringBuffer();\n\t  sb.append(\"new Ajax.Request(this.form.action,\");\n\t  NSDictionary options = createAjaxOptions(component);\n\t  AjaxOptions.appendToBuffer(options, sb, context);\n\t  sb.append(\")\");\n          String onClick = (String)valueForBinding(\"onClick\", component);\n          if(onClick != null) {\n              sb.append(\";\");\n              sb.append(onClick);\n          }\n\t  appendTagAttributeToResponse(response, \"onClick\", sb.toString());\n\t  response.appendContentString(\" />\");\n\t  super.appendToResponse(response, context);\n  }","id":106186,"modified_method":"public void appendToResponse(WOResponse response, WOContext context) {\n    WOComponent component = context.component();\n\n    boolean showButton = booleanValueForBinding(\"button\", true, component);\n    String formName = (String)valueForBinding(\"formName\", component);\n    String formReference;\n    if (!showButton && formName == null) {\n      throw new WODynamicElementCreationException(\"If button = false, you must specify a formName.\");\n    }\n    else if (formName == null) {\n      formReference = \"this.form\";\n    }\n    else {\n      formReference = \"document.\" + formName;\n    }\n    if (showButton) {\n      response.appendContentString(\"<input \");\n      appendTagAttributeToResponse(response, \"type\", \"button\");\n      String name = nameInContext(context, component);\n      appendTagAttributeToResponse(response, \"name\", name);\n      appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component));\n    }\n    else {\n      response.appendContentString(\"<a href = \\\"javascript:void(0)\\\" \");\n    }\n    appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component));\n    appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component));\n    appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component));\n    if (disabledInComponent(component)) {\n      appendTagAttributeToResponse(response, \"disabled\", \"disabled\");\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"new Ajax.Request(\" + formReference + \".action,\");\n    NSDictionary options = createAjaxOptions(component, formReference);\n    AjaxOptions.appendToBuffer(options, sb, context);\n    sb.append(\")\");\n    String onClick = (String) valueForBinding(\"onClick\", component);\n    if (onClick != null) {\n      sb.append(\";\");\n      sb.append(onClick);\n    }\n    appendTagAttributeToResponse(response, \"onclick\", sb.toString());\n    if (showButton) {\n      response.appendContentString(\" />\");\n    }\n    else {\n      response.appendContentString(\">\");\n      if (hasChildrenElements()) {\n        appendChildrenToResponse(response, context);\n      }\n      response.appendContentString(\"<\/a>\");\n    }\n    super.appendToResponse(response, context);\n  }","commit_id":"1eaa6d47bdb920f650a62ccfc1abd6eb78c00ed3","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSDictionary createAjaxOptions(WOComponent component) {\n\t  String name = nameInContext(component.context(), component);\n\t  NSMutableArray ajaxOptionsArray = new NSMutableArray();\n\t  ajaxOptionsArray.addObject(new AjaxOption(\"onSuccess\", AjaxOption.SCRIPT));\n\t  ajaxOptionsArray.addObject(new AjaxOption(\"onFailure\", AjaxOption.SCRIPT));\n\t  NSMutableDictionary options = AjaxOption.createAjaxOptionsDictionary(ajaxOptionsArray, component, associations());\n\t  options.setObjectForKey(\"Form.serialize(this.form) + \\\"&\" + KEY_AJAX_SUBMIT_BUTTON_NAME + \"=\" + name + \"\\\"\", \"parameters\");\n\t  return options;\n  }","id":106187,"modified_method":"public NSDictionary createAjaxOptions(WOComponent component, String formReference) {\n    String name = nameInContext(component.context(), component);\n    NSMutableArray ajaxOptionsArray = new NSMutableArray();\n    ajaxOptionsArray.addObject(new AjaxOption(\"onSuccess\", AjaxOption.SCRIPT));\n    ajaxOptionsArray.addObject(new AjaxOption(\"onFailure\", AjaxOption.SCRIPT));\n    NSMutableDictionary options = AjaxOption.createAjaxOptionsDictionary(ajaxOptionsArray, component, associations());\n    options.setObjectForKey(\"Form.serialize(\" + formReference + \") + \\\"&\" + KEY_AJAX_SUBMIT_BUTTON_NAME + \"=\" + name + \"\\\"\", \"parameters\");\n    return options;\n  }","commit_id":"1eaa6d47bdb920f650a62ccfc1abd6eb78c00ed3","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendToResponse(WOResponse response, WOContext context) {\n    WOComponent component = context.component();\n    boolean disabled = booleanValueForBinding(\"disabled\", false, component);\n    Object stringValue = valueForBinding(\"string\", component);\n    if (!disabled) {\n      response.appendContentString(\"<a \");\n      appendTagAttributeToResponse(response, \"href\", \"javascript:void(0);\");\n      appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      appendTagAttributeToResponse(response, \"title\", valueForBinding(\"title\", component));\n      appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component));\n      appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component));\n      appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component));\n      appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component));\n      // appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      response.appendContentString(\">\");\n    }\n    if (stringValue != null) {\n      response.appendContentHTMLString(stringValue.toString());\n    }\n    appendChildrenToResponse(response, context);\n    if (!disabled) {\n      response.appendContentString(\"<\/a>\");\n    }\n    super.appendToResponse(response, context);\n  }","id":106188,"modified_method":"public void appendToResponse(WOResponse response, WOContext context) {\n    WOComponent component = context.component();\n    boolean disabled = booleanValueForBinding(\"disabled\", false, component);\n    Object stringValue = valueForBinding(\"string\", component);\n    String elementName = (String)valueForBinding(\"elementName\", \"a\", component);\n    boolean isATag = \"a\".equalsIgnoreCase(elementName);\n    boolean renderTags = (!disabled || !isATag);\n    if (renderTags) {\n      response.appendContentString(\"<\");\n      response.appendContentString(elementName);\n      response.appendContentString(\" \");\n      if (isATag) {\n    \t  appendTagAttributeToResponse(response, \"href\", \"javascript:void(0);\");\n      }\n      appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      appendTagAttributeToResponse(response, \"title\", valueForBinding(\"title\", component));\n      appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component));\n      appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component));\n      appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component));\n      appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component));\n      // appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      response.appendContentString(\">\");\n    }\n    if (stringValue != null) {\n      response.appendContentHTMLString(stringValue.toString());\n    }\n    appendChildrenToResponse(response, context);\n    if (renderTags) {\n      response.appendContentString(\"<\/\");\n      response.appendContentString(elementName);\n      response.appendContentString(\">\");\n    }\n    super.appendToResponse(response, context);\n  }","commit_id":"483866b2c1395c9319d1a18918bbf18ceedd0342","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void handle(String target, Request baseRequest, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException, ServletException {\n    \tSwitchboard sb = Switchboard.getSwitchboard();\n    \t\n\t\tSystem.err.println(\"Page: \" + target);\n\t\t\n\t\tString localeSelection = \"default\";\n        File targetFile = getLocalizedFile(target, localeSelection);\n        File targetClass = rewriteClassFile(new File(htDefaultPath, target));\n        String targetExt = target.substring(target.lastIndexOf('.') + 1, target.length());\n              \n        if ((targetClass != null)) {\n\t\t\tserverObjects args = new serverObjects();\n        \t@SuppressWarnings(\"unchecked\")\n\t\t\tEnumeration<String> argNames = request.getParameterNames();\n        \twhile (argNames.hasMoreElements()) {\n        \t\tString argName = argNames.nextElement();\n        \t\targs.put(argName, request.getParameter(argName));\n        \t}\n                //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\n                //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \n                @SuppressWarnings(\"unchecked\")\n                Enumeration<String> attNames = request.getAttributeNames();\n                while (attNames.hasMoreElements()) {\n                    String argName = attNames.nextElement();\n                    args.put (argName,request.getAttribute(argName).toString());\n                } \n                \n                // add multipart-form fields to parameter\n                if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n                    parseMultipart(request, args);\n                }\n                // eof modification to read attribute\n        \tRequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\n        \t\n            Object tmp;\n\t\t\ttry {\n\t\t\t\ttmp = invokeServlet(targetClass, legacyRequestHeader, args);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t}\n\t\t\t\n\t\t\tif ( tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\n\t\t\t\t\n\t\t\t\tByteBuffer result = null;\n\t\t\t\n                            if (tmp instanceof RasterPlotter) {\n                                final RasterPlotter yp = (RasterPlotter) tmp;\n                                // send an image to client\n                                result = RasterPlotter.exportImage(yp.getImage(), \"png\");\n                            }\n                            if (tmp instanceof EncodedImage) {\n                                final EncodedImage yp = (EncodedImage) tmp;\n                                result = yp.getImage();\n                            }\n\t\t\t\t\n\t            if (tmp instanceof Image) {\n\t                final Image i = (Image) tmp;\n\t\n\t                // generate an byte array from the generated image\n\t                int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n\t                int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n\t                final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n\t                bi.createGraphics().drawImage(i, 0, 0, width, height, null); \n\t                result = RasterPlotter.exportImage(bi, targetExt);\n\t            }\n                \n                final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                response.setContentType(mimeType);\n                response.setContentLength(result.length());\n                response.setStatus(HttpServletResponse.SC_OK);\n                \n                result.writeTo(response.getOutputStream());\n                \n                // we handled this request, break out of handler chain\n        \t\tRequest base_request = (request instanceof Request) ? (Request)request:HttpConnection.getCurrentConnection().getRequest();\n        \t\tbase_request.setHandled(true);\n\n        \t\treturn;\n\t\t\t}\n\n\t\t\t\n            servletProperties templatePatterns = null;\n            if (tmp == null) {\n                // if no args given, then tp will be an empty Hashtable object (not null)\n                templatePatterns = new servletProperties();\n            } else if (tmp instanceof servletProperties) {\n                templatePatterns = (servletProperties) tmp;\n            } else {\n                templatePatterns = new servletProperties((serverObjects) tmp);\n            }\n            // add the application version, the uptime and the client name to every rewrite table\n            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\n            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n            Seed myPeer = sb.peers.mySeed();\n            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1); \n            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n            \n            if(targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n            \tString mimeType = Classification.ext2mime(targetExt, \"text/html\");\n            \t\n                InputStream fis = null;\n                long fileSize = targetFile.length();\n\n            \tif (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                    // read file completely into ram, avoid that too many files are open at the same time\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                } else {\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\n                }\n            \t\n            \t// set response header\n                response.setContentType(mimeType);\n                response.setStatus(HttpServletResponse.SC_OK);\n\n                // apply templates\n                TemplateEngine.writeTemplate(fis, response.getOutputStream(), templatePatterns, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                fis.close();\n                \n                // we handled this request, break out of handler chain\n        \t\tRequest base_request = (request instanceof Request) ? (Request)request:HttpConnection.getCurrentConnection().getRequest();\n        \t\tbase_request.setHandled(true);\n            }\n        }\n\t}","id":106189,"modified_method":"@Override\n\tpublic void handle(String target, Request baseRequest, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException, ServletException {\n    \tSwitchboard sb = Switchboard.getSwitchboard();\n    \t\n\t\tSystem.err.println(\"Page: \" + target);\n\t\t\n\t\tString localeSelection = \"default\";\n        File targetFile = getLocalizedFile(target, localeSelection);\n        File targetClass = rewriteClassFile(new File(htDefaultPath, target));\n        String targetExt = target.substring(target.lastIndexOf('.') + 1, target.length());\n              \n        if ((targetClass != null)) {\n\t\t\tserverObjects args = new serverObjects();\n        \t@SuppressWarnings(\"unchecked\")\n\t\t\tEnumeration<String> argNames = request.getParameterNames();\n        \twhile (argNames.hasMoreElements()) {\n        \t\tString argName = argNames.nextElement();\n        \t\targs.put(argName, request.getParameter(argName));\n        \t}\n                //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\n                //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \n                @SuppressWarnings(\"unchecked\")\n                Enumeration<String> attNames = request.getAttributeNames();\n                while (attNames.hasMoreElements()) {\n                    String argName = attNames.nextElement();\n                    args.put (argName,request.getAttribute(argName).toString());\n                } \n                \n                // add multipart-form fields to parameter\n                if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n                    parseMultipart(request, args);\n                }\n                // eof modification to read attribute\n        \tRequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\n        \t\n            Object tmp;\n\t\t\ttry {\n\t\t\t\ttmp = invokeServlet(targetClass, legacyRequestHeader, args);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\tthrow new ServletException();\n\t\t\t}\n\t\t\t\n\t\t\tif ( tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\n\t\t\t\t\n\t\t\t\tByteBuffer result = null;\n\t\t\t\n                            if (tmp instanceof RasterPlotter) {\n                                final RasterPlotter yp = (RasterPlotter) tmp;\n                                // send an image to client\n                                result = RasterPlotter.exportImage(yp.getImage(), \"png\");\n                            }\n                            if (tmp instanceof EncodedImage) {\n                                final EncodedImage yp = (EncodedImage) tmp;\n                                result = yp.getImage();\n                            }\n\t\t\t\t\n\t            if (tmp instanceof Image) {\n\t                final Image i = (Image) tmp;\n\t\n\t                // generate an byte array from the generated image\n\t                int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n\t                int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n\t                final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n\t                bi.createGraphics().drawImage(i, 0, 0, width, height, null); \n\t                result = RasterPlotter.exportImage(bi, targetExt);\n\t            }\n                \n                final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                response.setContentType(mimeType);\n                response.setContentLength(result.length());\n                response.setStatus(HttpServletResponse.SC_OK);\n                \n                result.writeTo(response.getOutputStream());\n                \n                // we handled this request, break out of handler chain \n                // is null on SSI template\n                if (baseRequest != null)  baseRequest.setHandled(true);\n                return;\n            }\n\n\t\t\t\n            servletProperties templatePatterns = null;\n            if (tmp == null) {\n                // if no args given, then tp will be an empty Hashtable object (not null)\n                templatePatterns = new servletProperties();\n            } else if (tmp instanceof servletProperties) {\n                templatePatterns = (servletProperties) tmp;\n            } else {\n                templatePatterns = new servletProperties((serverObjects) tmp);\n            }\n            // add the application version, the uptime and the client name to every rewrite table\n            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\n            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n            Seed myPeer = sb.peers.mySeed();\n            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1); \n            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n            \n            if(targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n            \tString mimeType = Classification.ext2mime(targetExt, \"text/html\");\n            \t\n                InputStream fis = null;\n                long fileSize = targetFile.length();\n\n            \tif (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                    // read file completely into ram, avoid that too many files are open at the same time\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                } else {\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\n                }\n            \t\n            \t// set response header\n                response.setContentType(mimeType);\n                response.setStatus(HttpServletResponse.SC_OK);\n\n                // apply templates\n                TemplateEngine.writeTemplate(fis, response.getOutputStream(), templatePatterns, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                fis.close();\n                \n                // we handled this request, break out of handler chain\n                // is null on SSI template\n         \tif (baseRequest != null) baseRequest.setHandled(true);\n            }\n        }\n    }","commit_id":"b8da176c5d6d3ad09e5f36a81f645b73ed20ddde","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server();\n        Connector connector=new SelectChannelConnector();\n        connector.setPort(8080);\n        server.setConnectors(new Connector[]{connector});\n        \n        ContextHandler context0 = new ContextHandler();\n        context0.setContextPath(\"/zero\");\n        Handler handler0=new HelloHandler();\n        context0.setHandler(handler0);\n\n        ContextHandler context1 = new ContextHandler();\n        context1.setContextPath(\"/one\");\n        Handler handler1=new HelloHandler();\n        context1.setHandler(handler1);   \n        \n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        contexts.setHandlers(new Handler[]{context0,context1});\n        \n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{contexts,new DefaultHandler()});\n        \n        server.setHandler(handlers);\n        \n        server.start();\n        server.join();\n    }","id":106190,"modified_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server();\n        Connector connector=new SelectChannelConnector();\n        connector.setPort(8080);\n        server.setConnectors(new Connector[]{connector});\n        \n        ContextHandler context0 = new ContextHandler();\n        context0.setContextPath(\"/\");\n        Handler handler0=new HelloHandler(\"Root Context\");\n        context0.setHandler(handler0);\n\n        ContextHandler context1 = new ContextHandler();\n        context1.setContextPath(\"/context\");\n        Handler handler1=new HelloHandler(\"A Context\");\n        context1.setHandler(handler1);   \n\n        ContextHandler context2 = new ContextHandler();\n        context2.setContextPath(\"/context\");\n        context2.setVirtualHosts(new String[]{\"127.0.0.2\"});\n        Handler handler2=new HelloHandler(\"A Virtual Context\");\n        context2.setHandler(handler2);   \n        \n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        contexts.setHandlers(new Handler[]{context0,context1,context2});\n        \n        server.setHandler(contexts);\n        \n        server.start();\n        server.join();\n    }","commit_id":"aa3b4ce2b1a1ddd5ea27d312e179a06c5b5fe2d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            Request base_request = (request instanceof Request) ? (Request)request:HttpConnection.getCurrentConnection().getRequest();\n            base_request.setHandled(true);\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<h1>Hello OneContext \"+hello+\"<\/h1>\");\n        }","id":106191,"modified_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            ((Request)request).setHandled(true);\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<h1>\"+_welcome+\" \"+request.getContextPath()+\"<\/h1>\");\n            response.getWriter().println(\"<a href='/'>root context<\/a><br/>\");\n            response.getWriter().println(\"<a href='http://127.0.0.1:8080/context'>normal context<\/a><br/>\");\n            response.getWriter().println(\"<a href='http://127.0.0.2:8080/context'>virtual context<\/a><br/>\");\n            \n        }","commit_id":"aa3b4ce2b1a1ddd5ea27d312e179a06c5b5fe2d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            Request base_request = (request instanceof Request) ? (Request)request:HttpConnection.getCurrentConnection().getRequest();\n            base_request.setHandled(true);\n            response.setContentType(\"text/html\");\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.getWriter().println(\"<h1>Hello ManyHandler<\/h1>\");\n        }","id":106192,"modified_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            response.setContentType(\"text/html\");\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.getWriter().println(\"<h1>\"+request.getAttribute(\"welcome\") +\" ManyHandler<\/h1>\");\n            ((Request)request).setHandled(true);\n        }","commit_id":"aa3b4ce2b1a1ddd5ea27d312e179a06c5b5fe2d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server();\n        Connector connector=new SelectChannelConnector();\n        connector.setPort(8080);\n        server.setConnectors(new Connector[]{connector});\n        \n        Handler param=new ParamHandler();\n        Handler hello=new HelloHandler();\n        \n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{param,hello});\n        server.setHandler(handlers);\n        \n        server.start();\n        server.join();\n    }","id":106193,"modified_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server(8080);\n        \n        // create the handlers\n        Handler param=new ParamHandler();\n        HandlerWrapper wrapper = new HandlerWrapper()\n        {\n            public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                request.setAttribute(\"welcome\",\"Hello\");\n                super.handle(target,request,response);\n            }\n        };\n        Handler hello=new HelloHandler();\n        Handler dft=new DefaultHandler();\n        RequestLogHandler log=new RequestLogHandler();\n        \n        // configure logs\n        log.setRequestLog(new NCSARequestLog(File.createTempFile(\"demo\",\"log\").getAbsolutePath()));\n        \n        // create the handler collections\n        HandlerCollection handlers = new HandlerCollection();\n        HandlerList list = new HandlerList();\n        \n        // link them all together\n        wrapper.addHandler(hello);\n        list.setHandlers(new Handler[]{param,wrapper,dft});\n        handlers.setHandlers(new Handler[]{list,log});\n        \n        server.setHandler(handlers);\n        \n        server.start();\n        server.join();\n    }","commit_id":"aa3b4ce2b1a1ddd5ea27d312e179a06c5b5fe2d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            System.err.println(request.getParameterMap());\n        }","id":106194,"modified_method":"public void handle(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n        {\n            Map params = request.getParameterMap();\n            if (params.size()>0)\n            {\n                response.setContentType(\"text/plain\");\n                response.getWriter().println(JSON.toString(params));\n                ((Request)request).setHandled(true);\n            }\n        }","commit_id":"aa3b4ce2b1a1ddd5ea27d312e179a06c5b5fe2d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public CharSequence javaScriptDocumentStart() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<script\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"src=\\\"js/twitter.js\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery-1.7.1.min.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.prettyPhoto.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"     \");\n    _builder.append(\"$(document).ready(function() {\");\n    _builder.newLine();\n    _builder.newLine();\n    {\n      boolean _isPrettyPrint = this.isPrettyPrint();\n      if (_isPrettyPrint) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"prettyPrint();\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"         \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t \");\n    _builder.append(\"$(\\'a[data-rel]\\').each(function() {\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"$(this).attr(\\'rel\\', $(this).data(\\'rel\\'));\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t \");\n    _builder.append(\"$(\\\"a[rel^=\\'prettyPhoto\\']\\\").prettyPhoto({\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"animation_speed: \\'fast\\',\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"slideshow: 5000,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"autoplay_slideshow: false,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"opacity: 0.80,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"show_title: true,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"theme: \\'ligh_square\\',\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"overlay_gallery: false,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"social_tools: false\");\n    _builder.newLine();\n    _builder.append(\"       \");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.newLine();\n    {\n      boolean _isOutline = this.isOutline();\n      if (_isOutline) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"$(\\'#nav-outline > li > a\\').live(\\'click\\', function() {        \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"$(this).parent().find(\\'ul\\').slideToggle();      \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"});\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"         \");\n    _builder.newLine();\n    {\n      boolean _isPopover = this.isPopover();\n      if (_isPopover) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"$(\\'.has-popover\\').popover();\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t \\t     \");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"getTwitters(\\'tweet\\', { \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"id: \\'xtext\\', \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"count: 5,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"includeRT: true,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"enableLinks: true, \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"clearContents: true,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"template: \\'\\\"%text%\\\" <a href=\\\"http://twitter.com/%user_screen_name%/statuses/%id_str%/\\\">%time%<\/a><br/><br/>\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t     \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"var po = document.createElement(\\'script\\'); po.type = \\'text/javascript\\'; po.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"po.src = \\'https://apis.google.com/js/plusone.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0]; s.parentNode.insertBefore(po, s);\");\n    _builder.newLine();\n    _builder.append(\"     \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"var _gaq = _gaq || [];\\t\");\n    _builder.newLine();\n    _builder.append(\"  \\t\");\n    _builder.append(\"_gaq.push([ \\'_setAccount\\', \\'UA-2429174-4\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"_gaq.push([ \\'_trackPageview\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"(function() {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var ga = document.createElement(\\'script\\');\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.type = \\'text/javascript\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.src = (\\'https:\\' == document.location.protocol ? \\'https://ssl\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\": \\'http://www\\')\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"+ \\'.google-analytics.com/ga.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0];\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"s.parentNode.insertBefore(ga, s);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"})();\");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","id":106195,"modified_method":"public CharSequence javaScriptDocumentStart() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<script src=\\\"js/twitter.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery-1.7.1.min.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.prettyPhoto.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"     \");\n    _builder.append(\"$(document).ready(function() {\");\n    _builder.newLine();\n    {\n      boolean _isPrettyPrint = this.isPrettyPrint();\n      if (_isPrettyPrint) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"prettyPrint();\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"         \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t \");\n    _builder.append(\"$(\\'a[data-rel]\\').each(function() {\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"$(this).attr(\\'rel\\', $(this).data(\\'rel\\'));\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t \");\n    _builder.append(\"$(\\\"a[rel^=\\'prettyPhoto\\']\\\").prettyPhoto({\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"animation_speed: \\'fast\\',\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"slideshow: 5000,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"autoplay_slideshow: false,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"opacity: 0.80,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"show_title: true,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"theme: \\'ligh_square\\',\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"overlay_gallery: false,\");\n    _builder.newLine();\n    _builder.append(\"             \");\n    _builder.append(\"social_tools: false\");\n    _builder.newLine();\n    _builder.append(\"       \");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.newLine();\n    {\n      boolean _isOutline = this.isOutline();\n      if (_isOutline) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"$(\\'#nav-outline > li > a\\').live(\\'click\\', function() {        \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"$(this).parent().find(\\'ul\\').slideToggle();      \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"});\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"         \");\n    _builder.newLine();\n    {\n      boolean _isPopover = this.isPopover();\n      if (_isPopover) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"$(\\'.has-popover\\').popover();\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t \\t     \");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"getTwitters(\\'tweet\\', { \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"id: \\'\");\n    String _twitterID = this.twitterID();\n    _builder.append(_twitterID, \"\t\t        \");\n    _builder.append(\"\\', \");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"count: 5,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"includeRT: true,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"enableLinks: true, \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"clearContents: true,\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t        \");\n    _builder.append(\"template: \\'\\\"%text%\\\" <a href=\\\"http://twitter.com/%user_screen_name%/statuses/%id_str%/\\\">%time%<\/a><br/><br/>\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t     \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.newLine();\n    _builder.append(\"         \");\n    _builder.append(\"var po = document.createElement(\\'script\\'); po.type = \\'text/javascript\\'; po.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"po.src = \\'https://apis.google.com/js/plusone.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t \\t     \");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0]; s.parentNode.insertBefore(po, s);\");\n    _builder.newLine();\n    _builder.append(\"     \");\n    _builder.append(\"});\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"var _gaq = _gaq || [];\\t\");\n    _builder.newLine();\n    _builder.append(\"  \\t\");\n    _builder.append(\"_gaq.push([ \\'_setAccount\\', \\'\");\n    String _analyticsAccount = this.analyticsAccount();\n    _builder.append(_analyticsAccount, \"  \t\");\n    _builder.append(\"\\' ]);\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    _builder.append(\"_gaq.push([ \\'_trackPageview\\' ]);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"(function() {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var ga = document.createElement(\\'script\\');\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.type = \\'text/javascript\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.async = true;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"ga.src = (\\'https:\\' == document.location.protocol ? \\'https://ssl\\'\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\": \\'http://www\\')\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"+ \\'.google-analytics.com/ga.js\\';\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"var s = document.getElementsByTagName(\\'script\\')[0];\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"s.parentNode.insertBefore(ga, s);\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"})();\");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence website() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!DOCTYPE html>\");\n    _builder.newLine();\n    _builder.append(\"<html lang=\\\"en\\\">\");\n    _builder.newLine();\n    _builder.append(\"<head>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta charset=\\\"utf-8\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<title>Xtext - Language Development Made Easy!<\/title>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"description\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"content=\\\"The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"author\\\" content=\\\"Sven Efftinge\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    CharSequence _stylesheets = this.stylesheets();\n    _builder.append(_stylesheets, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _javaScriptDocumentStart = this.javaScriptDocumentStart();\n    _builder.append(_javaScriptDocumentStart, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"<\/head>\");\n    _builder.newLine();\n    _builder.append(\"<body>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    CharSequence _navBar = this.navBar();\n    _builder.append(_navBar, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _contents = this.contents();\n    _builder.append(_contents, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _quickLinksAndTweets = this.quickLinksAndTweets();\n    _builder.append(_quickLinksAndTweets, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _javaScriptAtTheEnd = this.javaScriptAtTheEnd();\n    _builder.append(_javaScriptAtTheEnd, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"<\/body>\");\n    _builder.newLine();\n    _builder.append(\"<\/html>\");\n    _builder.newLine();\n    return _builder;\n  }","id":106196,"modified_method":"public CharSequence website() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!DOCTYPE html>\");\n    _builder.newLine();\n    _builder.append(\"<html lang=\\\"en\\\">\");\n    _builder.newLine();\n    _builder.append(\"<head>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta charset=\\\"utf-8\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<title>\");\n    String _websiteTitle = this.websiteTitle();\n    _builder.append(_websiteTitle, \"\t\");\n    _builder.append(\"<\/title>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"description\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"content=\\\"\");\n    String _websiteDescription = this.websiteDescription();\n    _builder.append(_websiteDescription, \"\t\t\");\n    _builder.append(\"\\\">\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    _builder.append(\"<meta name=\\\"author\\\" content=\\\"Sven Efftinge\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    CharSequence _stylesheets = this.stylesheets();\n    _builder.append(_stylesheets, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _javaScriptDocumentStart = this.javaScriptDocumentStart();\n    _builder.append(_javaScriptDocumentStart, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"<\/head>\");\n    _builder.newLine();\n    _builder.append(\"<body>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    CharSequence _navBar = this.navBar();\n    _builder.append(_navBar, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _contents = this.contents();\n    _builder.append(_contents, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _quickLinksAndTweets = this.quickLinksAndTweets();\n    _builder.append(_quickLinksAndTweets, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\");\n    CharSequence _javaScriptAtTheEnd = this.javaScriptAtTheEnd();\n    _builder.append(_javaScriptAtTheEnd, \"\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"<\/body>\");\n    _builder.newLine();\n    _builder.append(\"<\/html>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence quickLinksAndTweets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<div id=\\\"extra\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"inner\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"row\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3>Quick Links<\/h3>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/privacy.php\\\">Privacy Policy<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/termsofuse.php\\\">Terms of Use<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/copyright.php\\\">Copyright Agent<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/\\\">Legal<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"            \\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"/index.html\\\">Home<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://marketplace.eclipse.org/\\\">Market Place<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://live.eclipse.org/\\\">Eclipse Live<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.planeteclipse.org/\\\">Eclipse Planet<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3><a href=\\\"https://twitter.com/#!/xtext\\\" style=\\\"color: white;\\\">@Xtext<\/a> Tweets<\/h3>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<br />\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<div id=\\\"tweet\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>Please wait while my tweets load<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<a href=\\\"http://twitter.com/rem\\\">If you can\\'t wait - check\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"out what I\\'ve been twittering<\/a>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    return _builder;\n  }","id":106197,"modified_method":"public CharSequence quickLinksAndTweets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<div id=\\\"extra\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"inner\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"row\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3>Quick Links<\/h3>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/privacy.php\\\">Privacy Policy<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/termsofuse.php\\\">Terms of Use<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/copyright.php\\\">Copyright Agent<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org/legal/\\\">Legal<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"footer-links clearfix\\\">\");\n    _builder.newLine();\n    _builder.append(\"      \\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"/index.html\\\">Home<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://marketplace.eclipse.org/\\\">Market Place<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://live.eclipse.org/\\\">Eclipse Live<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.planeteclipse.org/\\\">Eclipse Planet<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"span6\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<h3><a href=\\\"https://twitter.com/#!/xtext\\\" style=\\\"color: white;\\\">@\");\n    String _twitterID = this.twitterID();\n    String _firstUpper = StringExtensions.toFirstUpper(_twitterID);\n    _builder.append(_firstUpper, \"\t\t\t\t\t\");\n    _builder.append(\"<\/a> Tweets<\/h3>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<br />\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<div id=\\\"tweet\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>Please wait while my tweets load<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<a href=\\\"http://twitter.com/rem\\\">If you can\\'t wait - check\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"out what I\\'ve been twittering<\/a>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/p>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence navBar() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Navbar -->\");\n    _builder.newLine();\n    _builder.append(\"<div class=\\\"navbar navbar-fixed-top\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"style=\\\"border-bottom: 1px solid #000;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"navbar-inner\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<a class=\\\"btn btn-navbar\\\" data-toggle=\\\"collapse\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"data-target=\\\".nav-collapse\\\"> <span class=\\\"icon-bar\\\"><\/span> <span\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"class=\\\"icon-bar\\\"><\/span> <span class=\\\"icon-bar\\\"><\/span>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/a> <a class=\\\"brand\\\" href=\\\"index.html\\\"><\/a>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"      \");\n    _builder.append(\"<div class=\\\"btn-group pull-right\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<g:plusone href=\\\"http://www.xtext.org\\\"><\/g:plusone>\");\n    _builder.newLine();\n    _builder.append(\"      \");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"nav-collapse collapse\\\" style=\\\"height: 0px;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"nav\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path = this.path();\n      boolean _equals = Objects.equal(_path, \"download.html\");\n      if (_equals) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"download.html\\\">Download<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_1 = this.path();\n      boolean _equals_1 = Objects.equal(_path_1, \"documentation.html\");\n      if (_equals_1) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"documentation.html\\\">Documentation<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_2 = this.path();\n      boolean _equals_2 = Objects.equal(_path_2, \"community.html\");\n      if (_equals_2) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"community.html\\\">Community<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org\\\">Eclipse.org<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<!--/.nav-collapse -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<!-- Navbar End -->\");\n    _builder.newLine();\n    return _builder;\n  }","id":106198,"modified_method":"public CharSequence navBar() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Navbar -->\");\n    _builder.newLine();\n    _builder.append(\"<div class=\\\"navbar navbar-fixed-top\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"style=\\\"border-bottom: 1px solid #000;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<div class=\\\"navbar-inner\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<div class=\\\"container\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<a class=\\\"btn btn-navbar\\\" data-toggle=\\\"collapse\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"data-target=\\\".nav-collapse\\\"> <span class=\\\"icon-bar\\\"><\/span> <span\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"class=\\\"icon-bar\\\"><\/span> <span class=\\\"icon-bar\\\"><\/span>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/a> <a class=\\\"brand\\\" href=\\\"index.html\\\"><\/a>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"      \");\n    _builder.append(\"<div class=\\\"btn-group pull-right\\\">\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"<g:plusone href=\\\"\");\n    String _plusoneURL = this.plusoneURL();\n    _builder.append(_plusoneURL, \"        \");\n    _builder.append(\"\\\"><\/g:plusone>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"      \");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<div class=\\\"nav-collapse collapse\\\" style=\\\"height: 0px;\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<ul class=\\\"nav\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path = this.path();\n      boolean _equals = Objects.equal(_path, \"download.html\");\n      if (_equals) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"download.html\\\">Download<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_1 = this.path();\n      boolean _equals_1 = Objects.equal(_path_1, \"documentation.html\");\n      if (_equals_1) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"documentation.html\\\">Documentation<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li \");\n    {\n      String _path_2 = this.path();\n      boolean _equals_2 = Objects.equal(_path_2, \"community.html\");\n      if (_equals_2) {\n        _builder.append(\"class=\\\"active\\\"\");\n      }\n    }\n    _builder.append(\"><a href=\\\"community.html\\\">Community<\/a><\/li>\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"<li><a href=\\\"http://www.eclipse.org\\\">Eclipse.org<\/a><\/li>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"<\/ul>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"<!--/.nav-collapse -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<\/div>\");\n    _builder.newLine();\n    _builder.append(\"<!-- Navbar End -->\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence stylesheets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<style>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"#header_wrapper {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"padding-top: 10px;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"/* 60px to make the container go all the way to the bottom of the topbar */\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"code.prettyprint {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"padding: 0px;\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"background-color: white;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"border: none;\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"<\/style>\");\n    _builder.newLine();\n    _builder.append(\"<!--  styles -->\");\n    _builder.newLine();\n    _builder.append(\"<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->\");\n    _builder.newLine();\n    _builder.append(\"<!--[if lt IE 9]>\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"<script src=\\\"http://html5shim.googlecode.com/svn/trunk/html5.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<![endif]-->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<!-- Le fav and touch icons -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"shortcut icon\\\" href=\\\"images/favicon.png\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/bootstrap.css\\\" rel=\\\"stylesheet\\\">\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/bootstrap-responsive.css\\\" rel=\\\"stylesheet\\\">\");\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"stylesheet\\\" href=\\\"css/style.css\\\">\");\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"stylesheet\\\" href=\\\"css/shield-responsive.css\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link href=\\'css/fonts.css\\' rel=\\'stylesheet\\' type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"stylesheet\\\" media=\\\"screen\\\" href=\\\"css/prettyPhoto.css\\\" />\");\n    _builder.newLine();\n    return _builder;\n  }","id":106199,"modified_method":"public CharSequence stylesheets() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<style>\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"#header_wrapper {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"padding-top: 10px;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"/* 60px to make the container go all the way to the bottom of the topbar */\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"code.prettyprint {\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"padding: 0px;\");\n    _builder.newLine();\n    _builder.append(\"        \");\n    _builder.append(\"background-color: white;\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"border: none;\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"<\/style>\");\n    _builder.newLine();\n    _builder.append(\"<!--  styles -->\");\n    _builder.newLine();\n    _builder.append(\"<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->\");\n    _builder.newLine();\n    _builder.append(\"<!--[if lt IE 9]>\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"<script src=\\\"http://html5shim.googlecode.com/svn/trunk/html5.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<![endif]-->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<!-- Le fav and touch icons -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link rel=\\\"shortcut icon\\\" href=\\\"images/favicon.png\\\">\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/bootstrap.css\\\" rel=\\\"stylesheet\\\" type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/bootstrap-responsive.css\\\" rel=\\\"stylesheet\\\" type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/style.css\\\" rel=\\\"stylesheet\\\" type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/shield-responsive.css\\\" rel=\\\"stylesheet\\\" type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\'css/fonts.css\\' rel=\\'stylesheet\\' type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"css/prettyPhoto.css\\\" rel=\\\"stylesheet\\\" media=\\\"screen\\\" type=\\'text/css\\'>\");\n    _builder.newLine();\n    _builder.append(\"<link href=\\\"google-code-prettify/prettify.css\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\"/>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence javaScriptAtTheEnd() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Le javascript\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"================================================== -->\");\n    _builder.newLine();\n    _builder.append(\"<!-- Placed at the end of the document so the pages load faster -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-transition.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-alert.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-modal.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-dropdown.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-scrollspy.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-tab.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-tooltip.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-popover.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-button.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-collapse.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-carousel.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-typeahead.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\">\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"$(function () { \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"$(\\\".has-popover\\\").popover();  \");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"});  \");\n    _builder.newLine();\n    _builder.append(\"<\/script>\");\n    _builder.newLine();\n    _builder.append(\"<!-- Include the plug-in -->\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.easing.1.3.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/custom.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","id":106200,"modified_method":"public CharSequence javaScriptAtTheEnd() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<!-- Le javascript\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"================================================== -->\");\n    _builder.newLine();\n    _builder.append(\"<!-- Placed at the end of the document so the pages load faster -->\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-transition.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-alert.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-modal.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-dropdown.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-scrollspy.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-tab.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-tooltip.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-popover.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-button.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-collapse.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-carousel.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/bootstrap-typeahead.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.newLine();\n    {\n      boolean _isPrettyPrint = this.isPrettyPrint();\n      if (_isPrettyPrint) {\n        _builder.append(\"<!-- include pretty-print files -->\");\n        _builder.newLine();\n        _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/prettify.js\\\"><\/script>\");\n        _builder.newLine();\n        _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/lang-common.js\\\"><\/script>\");\n        _builder.newLine();\n      }\n    }\n    _builder.newLine();\n    _builder.append(\"<!-- Include the plug-in -->\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/jquery.easing.1.3.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script src=\\\"js/custom.js\\\" type=\\\"text/javascript\\\"><\/script>\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence prettify() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"<link href=\\\"google-code-prettify/prettify.css\\\" type=\\\"text/css\\\" rel=\\\"stylesheet\\\" />\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/prettify.js\\\"><\/script>\");\n    _builder.newLine();\n    _builder.append(\"<script type=\\\"text/javascript\\\" src=\\\"google-code-prettify/lang-common.js\\\"><\/script>\");\n    CharSequence result = _builder;\n    Document _document = this.getDocument();\n    boolean _notEquals = (!Objects.equal(_document, null));\n    if (_notEquals) {\n      Document _document_1 = this.getDocument();\n      final EList<LangDef> languages = _document_1.getLangDefs();\n      int _size = languages.size();\n      boolean _greaterThan = (_size > 0);\n      if (_greaterThan) {\n        StringConcatenation _builder_1 = new StringConcatenation();\n        _builder_1.append(\"<script type=\\\"text/javascript\\\">\");\n        _builder_1.newLine();\n        {\n          for(final LangDef lang : languages) {\n            {\n              boolean _or = false;\n              String _name = lang.getName();\n              boolean _equalsIgnoreCase = _name.equalsIgnoreCase(\"java\");\n              if (_equalsIgnoreCase) {\n                _or = true;\n              } else {\n                String _name_1 = lang.getName();\n                boolean _equalsIgnoreCase_1 = _name_1.equalsIgnoreCase(\"xml\");\n                _or = (_equalsIgnoreCase || _equalsIgnoreCase_1);\n              }\n              boolean _not = (!_or);\n              if (_not) {\n                _builder_1.append(\"\\t\");\n                _builder_1.append(\"registerLanguage(\\'\");\n                {\n                  EList<String> _keywords = lang.getKeywords();\n                  boolean _hasElements = false;\n                  for(final String keyword : _keywords) {\n                    if (!_hasElements) {\n                      _hasElements = true;\n                    } else {\n                      _builder_1.appendImmediate(\"|\", \"\t\");\n                    }\n                    _builder_1.append(keyword, \"\t\");\n                  }\n                }\n                _builder_1.append(\"\\', \\'\");\n                String _name_2 = lang.getName();\n                String _lowerCase = _name_2.toLowerCase();\n                _builder_1.append(_lowerCase, \"\t\");\n                _builder_1.append(\"\\');\");\n                _builder_1.newLineIfNotEmpty();\n              }\n            }\n          }\n        }\n        _builder_1.append(\"<\/script>\");\n        _builder_1.newLine();\n        String _plus = (result + _builder_1.toString());\n        result = _plus;\n      }\n    }\n    return result;\n  }","id":106201,"modified_method":"public CharSequence prettify() {\n    StringConcatenation _builder = new StringConcatenation();\n    CharSequence result = _builder;\n    Document _document = this.getDocument();\n    boolean _notEquals = (!Objects.equal(_document, null));\n    if (_notEquals) {\n      Document _document_1 = this.getDocument();\n      final EList<LangDef> languages = _document_1.getLangDefs();\n      int _size = languages.size();\n      boolean _greaterThan = (_size > 0);\n      if (_greaterThan) {\n        StringConcatenation _builder_1 = new StringConcatenation();\n        _builder_1.append(\"<script type=\\\"text/javascript\\\">\");\n        _builder_1.newLine();\n        {\n          for(final LangDef lang : languages) {\n            {\n              boolean _or = false;\n              String _name = lang.getName();\n              boolean _equalsIgnoreCase = _name.equalsIgnoreCase(\"java\");\n              if (_equalsIgnoreCase) {\n                _or = true;\n              } else {\n                String _name_1 = lang.getName();\n                boolean _equalsIgnoreCase_1 = _name_1.equalsIgnoreCase(\"xml\");\n                _or = (_equalsIgnoreCase || _equalsIgnoreCase_1);\n              }\n              boolean _not = (!_or);\n              if (_not) {\n                _builder_1.append(\"\\t\");\n                _builder_1.append(\"registerLanguage(\\'\");\n                {\n                  EList<String> _keywords = lang.getKeywords();\n                  boolean _hasElements = false;\n                  for(final String keyword : _keywords) {\n                    if (!_hasElements) {\n                      _hasElements = true;\n                    } else {\n                      _builder_1.appendImmediate(\"|\", \"\t\");\n                    }\n                    _builder_1.append(keyword, \"\t\");\n                  }\n                }\n                _builder_1.append(\"\\', \\'\");\n                String _name_2 = lang.getName();\n                String _lowerCase = _name_2.toLowerCase();\n                _builder_1.append(_lowerCase, \"\t\");\n                _builder_1.append(\"\\');\");\n                _builder_1.newLineIfNotEmpty();\n              }\n            }\n          }\n        }\n        _builder_1.append(\"<\/script>\");\n        _builder_1.newLine();\n        String _plus = (result + _builder_1.toString());\n        result = _plus;\n      }\n    }\n    return result;\n  }","commit_id":"368bcb9ebc7bf74f49a38f31757eca534d04965c","url":"https://github.com/eclipse/xtext"},{"original_method":"@NotNull\n  public static List<Url> getUrls(@NotNull VirtualFile file, @NotNull Project project, @Nullable String currentAuthority) {\n    if (currentAuthority != null && !compareAuthority(currentAuthority)) {\n      return Collections.emptyList();\n    }\n\n    String path = WebServerPathToFileManager.getInstance(project).getPath(file);\n    if (path == null) {\n      return Collections.emptyList();\n    }\n\n    int effectiveBuiltInServerPort = BuiltInServerOptions.getInstance().getEffectiveBuiltInServerPort();\n    Url url = Urls.newHttpUrl(currentAuthority == null ? \"localhost:\" + effectiveBuiltInServerPort : currentAuthority, '/' + project.getName() + '/' + path);\n    int defaultPort = BuiltInServerManager.getInstance().getPort();\n    if (currentAuthority != null || defaultPort == effectiveBuiltInServerPort) {\n      return Collections.singletonList(url);\n    }\n    return Arrays.asList(url, Urls.newHttpUrl(\"localhost:\" + defaultPort, '/' + project.getName() + '/' + path));\n  }","id":106202,"modified_method":"@NotNull\n  public static List<Url> getUrls(@NotNull VirtualFile file, @NotNull Project project, @Nullable String currentAuthority) {\n    if (currentAuthority != null && !compareAuthority(currentAuthority)) {\n      return Collections.emptyList();\n    }\n\n    PathInfo info = WebServerPathToFileManager.getInstance(project).getPathInfo(file);\n    if (info == null) {\n      return Collections.emptyList();\n    }\n\n    int effectiveBuiltInServerPort = BuiltInServerOptions.getInstance().getEffectiveBuiltInServerPort();\n    String path = info.getPath();\n\n    String authority = currentAuthority == null ? \"localhost:\" + effectiveBuiltInServerPort : currentAuthority;\n    List<Url> urls = new SmartList<>(Urls.newHttpUrl(authority, '/' + project.getName() + '/' + path));\n\n    String path2 = info.getRootLessPathIfPossible();\n    if (path2 != null) {\n      urls.add(Urls.newHttpUrl(authority, '/' + project.getName() + '/' + path2));\n    }\n\n    int defaultPort = BuiltInServerManager.getInstance().getPort();\n    if (currentAuthority == null && defaultPort != effectiveBuiltInServerPort) {\n      String defaultAuthority = \"localhost:\" + defaultPort;\n      urls.add(Urls.newHttpUrl(defaultAuthority, '/' + project.getName() + '/' + path));\n      if (path2 != null) {\n        urls.add(Urls.newHttpUrl(defaultAuthority, '/' + project.getName() + '/' + path2));\n      }\n    }\n\n    return urls;\n  }","commit_id":"0c93edf02d5a9f46bd3f4350416be7fc177918eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Source files associated with this sample.\n     */\n    public List<SourceFile> getSourceFiles() {\n        return Arrays.asList(new SourceFile(getClass().getSimpleName()+\".java\"),\n                             new SourceFile(\"index.jelly\"));\n    }","id":106203,"modified_method":"/**\n     * Source files associated with this sample.\n     */\n    public List<SourceFile> getSourceFiles() {\n        List<SourceFile> r = new ArrayList<SourceFile>();\n\n        r.add(new SourceFile(getClass().getSimpleName()+\".java\"));\n        for (String name : new String[]{\"index.jelly\",\"index.groovy\"}) {\n            SourceFile s = new SourceFile(name);\n            if (s.resolve()!=null)\n                r.add(s);\n        }\n        return r;\n    }","commit_id":"17d9b6258f921f53ab003f2bff9c07b52f51b2b6","url":"https://github.com/kohsuke/hudson"},{"original_method":"public List<HgAnnotationLine> execute(@NotNull HgFile hgFile) {\n    HgCommandExecutor executor = new HgCommandExecutor(project);\n    HgCommandResult result = executor.executeInCurrentThread(hgFile.getRepo(), \"annotate\", Arrays.asList(\"-cqnudl\", hgFile.getRelativePath()));\n\n    final List<HgAnnotationLine> annotations = new ArrayList<HgAnnotationLine>();\n    if (result == null) {\n      return annotations;\n    }\n\n    for (String line : result.getOutputLines()) {\n      Matcher matcher = LINE_PATTERN.matcher(line);\n      if (matcher.matches()) {\n        String user = matcher.group(USER_GROUP);\n        HgRevisionNumber revision = HgRevisionNumber.getInstance(\n          matcher.group(REVISION_GROUP),\n          matcher.group(CHANGESET_GROUP)\n        );\n        String date = matcher.group(DATE_GROUP);\n        Integer lineNumber = Integer.valueOf(matcher.group(LINE_NUMBER_GROUP));\n        String content = matcher.group(CONTENT_GROUP);\n        HgAnnotationLine annotationLine = new HgAnnotationLine(\n          user, revision, date, lineNumber, content\n        );\n        annotations.add(annotationLine);\n      }\n    }\n    return annotations;\n  }","id":106204,"modified_method":"public List<HgAnnotationLine> execute(@NotNull HgFile hgFile, VcsFileRevision revision) {\n    final List<String> arguments = new ArrayList<String>();\n    arguments.add(\"-cqnudl\");\n    if (revision != null) {\n      arguments.add(\"-r\");\n      HgRevisionNumber revisionNumber = (HgRevisionNumber)revision.getRevisionNumber();\n      arguments.add(revisionNumber.getChangeset());\n    }\n    arguments.add(hgFile.getRelativePath());\n    final HgCommandResult result = new HgCommandExecutor(project).executeInCurrentThread(hgFile.getRepo(), \"annotate\", arguments);\n\n    final List<HgAnnotationLine> annotations = new ArrayList<HgAnnotationLine>();\n    if (result == null) {\n      return annotations;\n    }\n\n    for (String line : result.getOutputLines()) {\n      Matcher matcher = LINE_PATTERN.matcher(line);\n      if (matcher.matches()) {\n        String user = matcher.group(USER_GROUP);\n        HgRevisionNumber rev = HgRevisionNumber.getInstance(matcher.group(REVISION_GROUP), matcher.group(CHANGESET_GROUP));\n        String date = matcher.group(DATE_GROUP);\n        Integer lineNumber = Integer.valueOf(matcher.group(LINE_NUMBER_GROUP));\n        String content = matcher.group(CONTENT_GROUP);\n        HgAnnotationLine annotationLine = new HgAnnotationLine(\n          user, rev, date, lineNumber, content\n        );\n        annotations.add(annotationLine);\n      }\n    }\n    return annotations;\n  }","commit_id":"b56360d25e40a3b903c73b8f9c849c3d86293913","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileAnnotation annotate(VirtualFile file) throws VcsException {\n    final VirtualFile vcsRoot = VcsUtil.getVcsRootFor(myProject, VcsUtil.getFilePath(file.getPath()));\n    if (vcsRoot == null) {\n      throw new VcsException(\"vcs root is null\");\n    }\n    final HgFile hgFile = new HgFile(vcsRoot, VfsUtil.virtualToIoFile(file));\n    return new HgAnnotation(\n      hgFile,\n      (new HgAnnotateCommand(myProject)).execute(hgFile),\n      (new HgLogCommand(myProject)).execute(hgFile, DEFAULT_LIMIT, false)\n    );\n  }","id":106205,"modified_method":"public FileAnnotation annotate(VirtualFile file) throws VcsException {\n    return annotate(file, null);\n  }","commit_id":"b56360d25e40a3b903c73b8f9c849c3d86293913","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileAnnotation annotate(VirtualFile file, VcsFileRevision revision) throws VcsException {\n    return annotate(file);\n  }","id":106206,"modified_method":"public FileAnnotation annotate(VirtualFile file, VcsFileRevision revision) throws VcsException {\n    final VirtualFile vcsRoot = VcsUtil.getVcsRootFor(myProject, VcsUtil.getFilePath(file.getPath()));\n    if (vcsRoot == null) {\n      throw new VcsException(\"vcs root is null\");\n    }\n    final HgFile hgFile = new HgFile(vcsRoot, VfsUtil.virtualToIoFile(file));\n    final List<HgAnnotationLine> annotationResult = (new HgAnnotateCommand(myProject)).execute(hgFile, revision);\n    final List<HgFileRevision> logResult = (new HgLogCommand(myProject)).execute(hgFile, DEFAULT_LIMIT, false);\n    return new HgAnnotation(hgFile, annotationResult, logResult);\n  }","commit_id":"b56360d25e40a3b903c73b8f9c849c3d86293913","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Return the element type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getElementTypeDescriptor() {\n\t\treturn forElementType(getElementType());\n\t}","id":106207,"modified_method":"/**\n\t * Return the element type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getElementTypeDescriptor() {\n\t\tif (elementType != null) { \n\t\t\treturn elementType;\n\t\t} else {\n\t\t\telementType = forElementType(resolveElementType());\n\t\t\treturn elementType;\n\t\t}\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine the generic key type of the wrapped Map parameter/field, if any.\n\t * @return the generic type, or <code>null<\/code> if none\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<?> getMapKeyType() {\n\t\tif (isMap()) {\n\t\t\tif (this.field != null) {\n\t\t\t\treturn GenericCollectionTypeResolver.getMapKeyFieldType(this.field);\n\t\t\t}\n\t\t\telse if (this.methodParameter != null) {\n\t\t\t\treturn GenericCollectionTypeResolver.getMapKeyParameterType(this.methodParameter);\n\t\t\t}\n\t\t\telse if (this.value instanceof Map) {\n\t\t\t\tMap map = (Map) this.value;\n\t\t\t\tif (!map.isEmpty()) {\n\t\t\t\t\tObject key = map.keySet().iterator().next();\n\t\t\t\t\tif (key != null) {\n\t\t\t\t\t\treturn key.getClass();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn GenericCollectionTypeResolver.getMapKeyType((Class<? extends Map>) this.type);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":106208,"modified_method":"/**\n\t * Determine the generic key type of the wrapped Map parameter/field, if any.\n\t * @return the generic type, or <code>null<\/code> if none\n\t */\n\tpublic Class<?> getMapKeyType() {\n\t\treturn getMapKeyTypeDescriptor().getType();\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * If this type is an array type or {@link Collection} type, returns the underlying element type.\n\t * Returns <code>null<\/code> if the type is neither an array or collection.\n\t */\n\tpublic Class<?> getElementType() {\n\t\tif (isArray()) {\n\t\t\treturn getArrayComponentType();\n\t\t}\n\t\telse if (isCollection()) {\n\t\t\treturn getCollectionElementType();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":106209,"modified_method":"/**\n\t * If this type is an array type or {@link Collection} type, returns the underlying element type.\n\t * Returns <code>null<\/code> if the type is neither an array or collection.\n\t */\n\tpublic Class<?> getElementType() {\n\t\treturn getElementTypeDescriptor().getType();\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine the generic value type of the wrapped Map parameter/field, if any.\n\t * @return the generic type, or <code>null<\/code> if none\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<?> getMapValueType() {\n\t\tif (isMap()) {\n\t\t\tif (this.field != null) {\n\t\t\t\treturn GenericCollectionTypeResolver.getMapValueFieldType(this.field);\n\t\t\t}\n\t\t\telse if (this.methodParameter != null) {\n\t\t\t\treturn GenericCollectionTypeResolver.getMapValueParameterType(this.methodParameter);\n\t\t\t}\n\t\t\telse if (this.value instanceof Map) {\n\t\t\t\tMap map = (Map) this.value;\n\t\t\t\tif (!map.isEmpty()) {\n\t\t\t\t\tObject val = map.values().iterator().next();\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\treturn val.getClass();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn GenericCollectionTypeResolver.getMapValueType((Class<? extends Map>) this.type);\t\t\t\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":106210,"modified_method":"/**\n\t * Determine the generic value type of the wrapped Map parameter/field, if any.\n\t * @return the generic type, or <code>null<\/code> if none\n\t */\n\tpublic Class<?> getMapValueType() {\n\t\treturn getMapValueTypeDescriptor().getType();\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns map value type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getMapValueTypeDescriptor() {\n\t\treturn forElementType(getMapValueType());\n\t}","id":106211,"modified_method":"/**\n\t * Returns map value type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getMapValueTypeDescriptor() {\n\t\tif (mapValueType != null) {\n\t\t\treturn mapValueType;\n\t\t} else {\n\t\t\tmapValueType = isMap() ? forElementType(resolveMapValueType()) : null;\n\t\t\treturn mapValueType;\n\t\t}\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate Class<?> getCollectionElementType() {\n\t\tif (this.field != null) {\n\t\t\treturn GenericCollectionTypeResolver.getCollectionFieldType(this.field);\n\t\t}\n\t\telse if (this.methodParameter != null) {\n\t\t\treturn GenericCollectionTypeResolver.getCollectionParameterType(this.methodParameter);\n\t\t}\n\t\telse if (this.value instanceof Collection) {\n\t\t\tCollection coll = (Collection) this.value;\n\t\t\tif (!coll.isEmpty()) {\n\t\t\t\tObject elem = coll.iterator().next();\n\t\t\t\tif (elem != null) {\n\t\t\t\t\treturn elem.getClass();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.type != null) {\n\t\t\treturn GenericCollectionTypeResolver.getCollectionType((Class<? extends Collection>) this.type);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":106212,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate Class<?> resolveCollectionElementType() {\n\t\tif (this.field != null) {\n\t\t\treturn GenericCollectionTypeResolver.getCollectionFieldType(this.field);\n\t\t}\n\t\telse if (this.methodParameter != null) {\n\t\t\treturn GenericCollectionTypeResolver.getCollectionParameterType(this.methodParameter);\n\t\t}\n\t\telse if (this.value instanceof Collection) {\n\t\t\tCollection coll = (Collection) this.value;\n\t\t\tif (!coll.isEmpty()) {\n\t\t\t\tObject elem = coll.iterator().next();\n\t\t\t\tif (elem != null) {\n\t\t\t\t\treturn elem.getClass();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn type != null ? GenericCollectionTypeResolver.getCollectionType((Class<? extends Collection>) this.type) : null;\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the map value type as a type descriptor; if the value type is null (cannot be determined), the type descriptor is derived from the value argument.\n\t * @param value the value\n\t * @return the map value type descriptor\n\t */\n\tpublic TypeDescriptor getMapValueTypeDescriptor(Object value) {\n\t\treturn getMapValueType() != null ? getMapValueTypeDescriptor() : TypeDescriptor.forObject(value);\n\t}","id":106213,"modified_method":"/**\n\t * Return the map value type as a type descriptor; if the value type is null (cannot be determined), the type descriptor is derived from the value argument.\n\t * @param value the value\n\t * @return the map value type descriptor\n\t */\n\tpublic TypeDescriptor getMapValueTypeDescriptor(Object value) {\n\t\tTypeDescriptor valueType = getMapValueTypeDescriptor();\n\t\treturn valueType != TypeDescriptor.NULL ? valueType : TypeDescriptor.forObject(value);\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the element type as a type descriptor; if the element type is null (cannot be determined), the type descriptor is derived from the element argument.\n\t * @param element the element\n\t * @return the element type descriptor\n\t */\n\tpublic TypeDescriptor getElementTypeDescriptor(Object element) {\n\t\treturn getElementType() != null ? getElementTypeDescriptor() : TypeDescriptor.forObject(element);\n\t}","id":106214,"modified_method":"/**\n\t * Return the element type as a type descriptor; if the element type is null (cannot be determined), the type descriptor is derived from the element argument.\n\t * @param element the element\n\t * @return the element type descriptor\n\t */\n\tpublic TypeDescriptor getElementTypeDescriptor(Object element) {\n\t\tTypeDescriptor elementType = getElementTypeDescriptor();\n\t\treturn elementType != TypeDescriptor.NULL ? elementType : TypeDescriptor.forObject(element); \n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the map key type as a type descriptor; if the key type is null (cannot be determined), the type descriptor is derived from the key argument.\n\t * @param key the key\n\t * @return the map key type descriptor\n\t */\n\tpublic TypeDescriptor getMapKeyTypeDescriptor(Object key) {\n\t\treturn getMapKeyType() != null ? getMapKeyTypeDescriptor() : TypeDescriptor.forObject(key);\n\t}","id":106215,"modified_method":"/**\n\t * Return the map key type as a type descriptor; if the key type is null (cannot be determined), the type descriptor is derived from the key argument.\n\t * @param key the key\n\t * @return the map key type descriptor\n\t */\n\tpublic TypeDescriptor getMapKeyTypeDescriptor(Object key) {\n\t\tTypeDescriptor keyType = getMapKeyTypeDescriptor();\n\t\treturn keyType != TypeDescriptor.NULL ? keyType : TypeDescriptor.forObject(key);\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns map key type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getMapKeyTypeDescriptor() {\n\t\treturn forElementType(getMapKeyType());\n\t}","id":106216,"modified_method":"/**\n\t * Returns map key type as a type descriptor.\n\t */\n\tpublic TypeDescriptor getMapKeyTypeDescriptor() {\n\t\tif (mapKeyType != null) {\n\t\t\treturn mapKeyType;\n\t\t} else {\n\t\t\tmapKeyType = isMap() ? forElementType(resolveMapKeyType()) : null;\n\t\t\treturn mapKeyType;\n\t\t}\n\t}","commit_id":"e60389283dc8e1f32b1b358dafa807d3784448b1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public List<String> getAllMetrics() {\n        List<String> r = Lists.newArrayList();\n\n        int now = Tools.getUTCTimestamp();\n\n        // Overall count.\n        String overall = prefix() + \"total \" + counter.getTotalCount() + \" \" + now;\n        r.add(overall);\n\n        // Streams.\n        for(Entry<String, Counter> stream : counter.getStreamCounts().entrySet()) {\n            String sval = prefix() + \"streams.\" + stream.getKey() + \" \" + stream.getValue().get() + \" \" + now;\n            r.add(sval);\n        }\n\n        // Hosts.\n        for(Entry<String, Counter> host : counter.getHostCounts().entrySet()) {\n            String hval = prefix() + \"hosts.\" + Tools.decodeBase64(host.getKey()).replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"\") + \" \" + host.getValue().get() + \" \" + Tools.getUTCTimestamp();\n            r.add(hval);\n        }\n\n        return r;\n    }","id":106217,"modified_method":"public List<String> getAllMetrics() {\n        List<String> r = Lists.newArrayList();\n\n        int now = Tools.getUTCTimestamp();\n\n        // Overall count.\n        String overall = prefix() + \"total \" + counter.getTotalCount() + \" \" + now;\n        r.add(overall);\n\n        // Streams.\n        for(Entry<String, Integer> stream : counter.getStreamCounts().entrySet()) {\n            String sval = prefix() + \"streams.\" + stream.getKey() + \" \" + stream.getValue() + \" \" + now;\n            r.add(sval);\n        }\n\n        // Hosts.\n        for(Entry<String, Integer> host : counter.getHostCounts().entrySet()) {\n            String hval = prefix() + \"hosts.\" + Tools.decodeBase64(host.getKey()).replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"\") + \" \" + host.getValue() + \" \" + Tools.getUTCTimestamp();\n            r.add(hval);\n        }\n\n        return r;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String asJson() {\n        Map<String, Object> m = Maps.newHashMap();\n        List<Map<String, Object>> gauges = Lists.newArrayList();\n\n        // Overall\n        Map<String, Object> overall = Maps.newHashMap();\n        overall.put(\"value\", counter.getTotalCount());\n        overall.put(\"source\", source);\n        overall.put(\"name\", \"gl2-total\");\n        gauges.add(overall);\n        \n        // Streams.\n        for(Entry<String, Counter> stream : counter.getStreamCounts().entrySet()) {\n            if (streamFilter.contains(stream.getKey())) {\n                LOG.debug(\"Not sending stream <{}> to Librato Metrics because it is listed in libratometrics_stream_filter\", stream.getKey());\n                continue;\n            }\n\n            Map<String, Object> s = Maps.newHashMap();\n            s.put(\"value\", stream.getValue().get());\n            s.put(\"source\", source);\n            s.put(\"name\", \"gl2-stream-\" + buildStreamMetricName(stream.getKey()));\n            gauges.add(s);\n        }\n\n        // Hosts.\n        for(Entry<String, Counter> host : counter.getHostCounts().entrySet()) {\n            if (Tools.decodeBase64(host.getKey()).matches(hostFilter)) {\n                LOG.debug(\"Not sending host <{}> to Librato Metrics because it was matched by libratometrics_host_filter\", host.getKey());\n                continue;\n            }\n\n            Map<String, Object> h = Maps.newHashMap();\n            h.put(\"value\", host.getValue().get());\n            h.put(\"source\", source);\n            h.put(\"name\", \"gl2-host-\" + Tools.decodeBase64(host.getKey()).replaceAll(\"[^a-zA-Z0-9]\", \"\"));\n            gauges.add(h);\n        }\n\n        m.put(\"gauges\", gauges);\n\n        return JSONValue.toJSONString(m);\n    }","id":106218,"modified_method":"public String asJson() {\n        Map<String, Object> m = Maps.newHashMap();\n        List<Map<String, Object>> gauges = Lists.newArrayList();\n\n        // Overall\n        Map<String, Object> overall = Maps.newHashMap();\n        overall.put(\"value\", counter.getTotalCount());\n        overall.put(\"source\", source);\n        overall.put(\"name\", \"gl2-total\");\n        gauges.add(overall);\n        \n        // Streams.\n        for(Entry<String, Integer> stream : counter.getStreamCounts().entrySet()) {\n            if (streamFilter.contains(stream.getKey())) {\n                LOG.debug(\"Not sending stream <{}> to Librato Metrics because it is listed in libratometrics_stream_filter\", stream.getKey());\n                continue;\n            }\n\n            Map<String, Object> s = Maps.newHashMap();\n            s.put(\"value\", stream.getValue());\n            s.put(\"source\", source);\n            s.put(\"name\", \"gl2-stream-\" + buildStreamMetricName(stream.getKey()));\n            gauges.add(s);\n        }\n\n        // Hosts.\n        for(Entry<String, Integer> host : counter.getHostCounts().entrySet()) {\n            if (Tools.decodeBase64(host.getKey()).matches(hostFilter)) {\n                LOG.debug(\"Not sending host <{}> to Librato Metrics because it was matched by libratometrics_host_filter\", host.getKey());\n                continue;\n            }\n\n            Map<String, Object> h = Maps.newHashMap();\n            h.put(\"value\", host.getValue());\n            h.put(\"source\", source);\n            h.put(\"name\", \"gl2-host-\" + Tools.decodeBase64(host.getKey()).replaceAll(\"[^a-zA-Z0-9]\", \"\"));\n            gauges.add(h);\n        }\n\n        m.put(\"gauges\", gauges);\n\n        return JSONValue.toJSONString(m);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, Counter> getStreamCounts() {\n        return this.streams;\n    }","id":106219,"modified_method":"public Map<String, Integer> getStreamCounts() {\n        return this.streams;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, Counter> getHostCounts() {\n        return this.hosts;\n    }","id":106220,"modified_method":"public Map<String, Integer> getHostCounts() {\n        return this.hosts;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Count up the total count.\n     *\n     * @param x The value to add on top of current total count.\n     */\n    public void countUpTotal(final int x) {\n        this.total.add(x);\n    }","id":106221,"modified_method":"/**\n     * Count up the total count.\n     *\n     * @param x The value to add on top of current total count.\n     */\n    public void countUpTotal(final int x) {\n        this.total += x;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Count up the count of a stream.\n     *\n     * @param streamId The ID of the stream which count to increment.\n     * @param x The value to add on top of the current stream count.\n     */\n    public synchronized void countUpStream(final ObjectId streamId, final int x) {\n    \tCounter counter = this.streams.get(streamId.toString());\n    \tif (counter == null) {\n    \t\tcounter = CounterFactory.newCounter();\n    \t}\n\n    \tcounter.add(x);\n    \tthis.streams.put(streamId.toString(), counter);\n    }","id":106222,"modified_method":"/**\n     * Count up the count of a stream.\n     *\n     * @param streamId The ID of the stream which count to increment.\n     * @param x The value to add on top of the current stream count.\n     */\n    public synchronized void countUpStream(final ObjectId streamId, final int x) {\n        if (this.streams.containsKey(streamId.toString())) {\n            // There already is an entry. Increment.\n            final int oldCount = this.streams.get(streamId.toString());\n            this.streams.put(streamId.toString(), oldCount+x); // Overwrites old entry.\n        } else {\n            // First entry for this stream.\n            this.streams.put(streamId.toString(), x);\n        }\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void resetTotal() {\n        this.total.reset();\n    }","id":106223,"modified_method":"public void resetTotal() {\n        this.total = 0;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Count up the count of a host.\n     *\n     * @param hostname The name of the host which count to increment.\n     * @param x The value to add on top of the current host count.\n     */\n    public synchronized void countUpHost(String hostname, final int x) {\n        hostname = Tools.encodeBase64(hostname);\n        Counter counter = this.hosts.get(hostname);\n        if (counter == null) {\n        \tcounter = CounterFactory.newCounter();\n        }\n\n        counter.add(x);\n        this.hosts.put(hostname, counter);\n    }","id":106224,"modified_method":"/**\n     * Count up the count of a host.\n     *\n     * @param hostname The name of the host which count to increment.\n     * @param x The value to add on top of the current host count.\n     */\n    public synchronized void countUpHost(String hostname, final int x) {\n        hostname = Tools.encodeBase64(hostname);\n        if (this.hosts.containsKey(hostname)) {\n            // There already is an entry. Increment.\n            final int oldCount = this.hosts.get(hostname);\n            this.hosts.put(hostname, oldCount+x); // Overwrites old entry.\n        } else {\n            // First entry for this stream.\n            this.hosts.put(hostname, x);\n        }\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Counter getTotalCount() {\n        return this.total;\n    }","id":106225,"modified_method":"public int getTotalCount() {\n        return this.total;\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testIncrementTotal() {\n        counter.countUpTotal(10);\n        counter.incrementTotal();\n        assertEquals(CounterFactory.newCounter(11), counter.getTotalCount());\n    }","id":106226,"modified_method":"@Test\n    public void testIncrementTotal() {\n        counter.countUpTotal(10);\n        counter.incrementTotal();\n        assertEquals(11, counter.getTotalCount());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testIncrementHost() {\n        String hostname = \"foobar\";\n        counter.countUpHost(hostname, 10);\n        counter.incrementHost(hostname);\n\n        Counter res = counter.getHostCounts().get(Tools.encodeBase64(hostname));\n        assertEquals(CounterFactory.newCounter(11), res);\n    }","id":106227,"modified_method":"@Test\n    public void testIncrementHost() {\n        String hostname = \"foobar\";\n        counter.countUpHost(hostname, 10);\n        counter.incrementHost(hostname);\n\n        int res = counter.getHostCounts().get(Tools.encodeBase64(hostname));\n        assertEquals(11, res);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testCountUpHost() {\n        String hostname = \"foo.example.org\";\n        counter.countUpHost(hostname, 25);\n        counter.countUpHost(hostname, 40);\n\n        Counter res = counter.getHostCounts().get(Tools.encodeBase64(hostname));\n        assertEquals(CounterFactory.newCounter(65), res);\n    }","id":106228,"modified_method":"@Test\n    public void testCountUpHost() {\n        String hostname = \"foo.example.org\";\n        counter.countUpHost(hostname, 25);\n        counter.countUpHost(hostname, 40);\n\n        int res = counter.getHostCounts().get(Tools.encodeBase64(hostname));\n        assertEquals(65, res);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testCountUpStream() {\n        ObjectId streamId = new ObjectId();\n        counter.countUpStream(streamId, 100);\n        counter.countUpStream(streamId, 150);\n\n        Counter res = counter.getStreamCounts().get(streamId.toString());\n        assertEquals(CounterFactory.newCounter(250), res);\n    }","id":106229,"modified_method":"@Test\n    public void testCountUpStream() {\n        ObjectId streamId = new ObjectId();\n        counter.countUpStream(streamId, 100);\n        counter.countUpStream(streamId, 150);\n\n        int res = counter.getStreamCounts().get(streamId.toString());\n        assertEquals(250, res);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testGetHostCounts() {\n        String host1 = \"example.org\";\n        String host2 = \"foo.example.org\";\n        String host3 = \"example.com\";\n\n        Map<String, Counter> expected = Maps.newHashMap();\n        expected.put(Tools.encodeBase64(host1), CounterFactory.newCounter(5));\n        expected.put(Tools.encodeBase64(host2), CounterFactory.newCounter(1));\n        expected.put(Tools.encodeBase64(host3), CounterFactory.newCounter(3));\n\n        counter.countUpStream(new ObjectId(), 5); // Add a stream count for complexity.\n        counter.countUpHost(host1, 4);\n        counter.countUpHost(host1, 1);\n        counter.incrementHost(host2);\n        counter.countUpHost(host3, 3);\n\n        assertEquals(expected, counter.getHostCounts());\n    }","id":106230,"modified_method":"@Test\n    public void testGetHostCounts() {\n        String host1 = \"example.org\";\n        String host2 = \"foo.example.org\";\n        String host3 = \"example.com\";\n\n        Map<String, Integer> expected = Maps.newHashMap();\n        expected.put(Tools.encodeBase64(host1), 5);\n        expected.put(Tools.encodeBase64(host2), 1);\n        expected.put(Tools.encodeBase64(host3), 3);\n\n        counter.countUpStream(new ObjectId(), 5); // Add a stream count for complexity.\n        counter.countUpHost(host1, 4);\n        counter.countUpHost(host1, 1);\n        counter.incrementHost(host2);\n        counter.countUpHost(host3, 3);\n\n        assertEquals(expected, counter.getHostCounts());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testGetTotalCount() {\n        counter.countUpTotal(5);\n        counter.incrementTotal();\n        assertEquals(CounterFactory.newCounter(6), counter.getTotalCount());\n    }","id":106231,"modified_method":"@Test\n    public void testGetTotalCount() {\n        counter.countUpTotal(5);\n        counter.incrementTotal();\n        assertEquals(6, counter.getTotalCount());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testIncrementStream() {\n        ObjectId streamId = new ObjectId();\n        counter.countUpStream(streamId, 100);\n        counter.incrementStream(streamId);\n\n        Counter res = counter.getStreamCounts().get(streamId.toString());\n        assertEquals(CounterFactory.newCounter(101), res);\n    }","id":106232,"modified_method":"@Test\n    public void testIncrementStream() {\n        ObjectId streamId = new ObjectId();\n        counter.countUpStream(streamId, 100);\n        counter.incrementStream(streamId);\n\n        int res = counter.getStreamCounts().get(streamId.toString());\n        assertEquals(101, res);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testResetTotal() {\n        counter.countUpTotal(1000);\n        assertEquals(CounterFactory.newCounter(1000), counter.getTotalCount());\n        counter.resetTotal();\n        assertEquals(CounterFactory.newCounter(0), counter.getTotalCount());\n    }","id":106233,"modified_method":"@Test\n    public void testResetTotal() {\n        counter.countUpTotal(1000);\n        assertEquals(1000, counter.getTotalCount());\n        counter.resetTotal();\n        assertEquals(0, counter.getTotalCount());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testGetStreamCounts() {\n        ObjectId stream1 = new ObjectId();\n        ObjectId stream2 = new ObjectId();\n        ObjectId stream3 = new ObjectId();\n\n        Map<String, Counter> expected = Maps.newHashMap();\n        expected.put(stream1.toString(), CounterFactory.newCounter(1));\n        expected.put(stream2.toString(), CounterFactory.newCounter(5));\n        expected.put(stream3.toString(), CounterFactory.newCounter(2));\n\n        counter.countUpStream(stream1, 1);\n        counter.countUpStream(stream2, 3);\n        counter.countUpStream(stream2, 2);\n        counter.countUpStream(stream3, 1);\n        counter.incrementStream(stream3);\n\n        assertEquals(expected, counter.getStreamCounts());\n    }","id":106234,"modified_method":"@Test\n    public void testGetStreamCounts() {\n        ObjectId stream1 = new ObjectId();\n        ObjectId stream2 = new ObjectId();\n        ObjectId stream3 = new ObjectId();\n\n        Map<String, Integer> expected = Maps.newHashMap();\n        expected.put(stream1.toString(), 1);\n        expected.put(stream2.toString(), 5);\n        expected.put(stream3.toString(), 2);\n\n        counter.countUpStream(stream1, 1);\n        counter.countUpStream(stream2, 3);\n        counter.countUpStream(stream2, 2);\n        counter.countUpStream(stream3, 1);\n        counter.incrementStream(stream3);\n\n        assertEquals(expected, counter.getStreamCounts());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testResetAllCounts() {\n        counter.countUpTotal(100);\n        counter.countUpHost(\"foo.example.org\", 9001);\n        counter.countUpStream(new ObjectId(), 5);\n\n        assertEquals(CounterFactory.newCounter(100), counter.getTotalCount()); // Just to make sure.\n\n        counter.resetAllCounts();\n\n        assertEquals(CounterFactory.newCounter(0), counter.getTotalCount());\n        assertEquals(0, counter.getHostCounts().size());\n        assertEquals(0, counter.getStreamCounts().size());\n    }","id":106235,"modified_method":"@Test\n    public void testResetAllCounts() {\n        counter.countUpTotal(100);\n        counter.countUpHost(\"foo.example.org\", 9001);\n        counter.countUpStream(new ObjectId(), 5);\n\n        assertEquals(100, counter.getTotalCount()); // Just to make sure.\n\n        counter.resetAllCounts();\n\n        assertEquals(0, counter.getTotalCount());\n        assertEquals(0, counter.getHostCounts().size());\n        assertEquals(0, counter.getStreamCounts().size());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void testCountUpTotal() {\n        counter.countUpTotal(500);\n        counter.countUpTotal(50);\n        assertEquals(CounterFactory.newCounter(550), counter.getTotalCount());\n    }","id":106236,"modified_method":"@Test\n    public void testCountUpTotal() {\n        counter.countUpTotal(500);\n        counter.countUpTotal(50);\n        assertEquals(550, counter.getTotalCount());\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void writeMessageCounts(Counter total, Map<String, Counter> streams, Map<String, Counter> hosts) {\n        // We store the first second of the current minute, to allow syncing (summing) message counts\n        // from different graylog-server nodes later\n        DateTime dt = new DateTime();\n        int startOfMinute = Tools.getUTCTimestamp()-dt.getSecondOfMinute();;\n        \n        BasicDBObject obj = new BasicDBObject();\n        obj.put(\"timestamp\", startOfMinute);\n        obj.put(\"total\", total.get());\n        obj.put(\"streams\", streams);\n        obj.put(\"hosts\", hosts);\n        obj.put(\"server_id\", server.getServerId());\n\n        getConnection().getMessageCountsColl().insert(obj);\n    }","id":106237,"modified_method":"public void writeMessageCounts(int total, Map<String, Integer> streams, Map<String, Integer> hosts) {\n        // We store the first second of the current minute, to allow syncing (summing) message counts\n        // from different graylog-server nodes later\n        DateTime dt = new DateTime();\n        int startOfMinute = Tools.getUTCTimestamp()-dt.getSecondOfMinute();;\n        \n        BasicDBObject obj = new BasicDBObject();\n        obj.put(\"timestamp\", startOfMinute);\n        obj.put(\"total\", total);\n        obj.put(\"streams\", streams);\n        obj.put(\"hosts\", hosts);\n        obj.put(\"server_id\", server.getServerId());\n\n        getConnection().getMessageCountsColl().insert(obj);\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Start the thread. Runs forever.\n     */\n    @Override\n    public void run() {\n        try {\n            // ohai, we are alive. \\o/\n            graylogServer.getServerValues().ping();\n\n            // Current throughput.\n            MessageCounter c = this.graylogServer.getMessageCounterManager().get(Core.THROUGHPUT_COUNTER_NAME);\n            graylogServer.getServerValues().writeThroughput(c.getTotalCount().get());\n            c.resetTotal(); // Reset five second throughput count.\n\n            /*\n             * Message queue size is written in BulkIndexerThread. More about the\n             * reason for that can be found there.\n             */\n        } catch (Exception e) {\n            LOG.warn(\"Error in ServerValue  WriterThread: \" + e.getMessage(), e);\n        }\n    }","id":106238,"modified_method":"/**\n     * Start the thread. Runs forever.\n     */\n    @Override\n    public void run() {\n        try {\n            // ohai, we are alive. \\o/\n            graylogServer.getServerValues().ping();\n\n            // Current throughput.\n            MessageCounter c = this.graylogServer.getMessageCounterManager().get(Core.THROUGHPUT_COUNTER_NAME);\n            graylogServer.getServerValues().writeThroughput(c.getTotalCount());\n            c.resetTotal(); // Reset five second throughput count.\n\n            /*\n             * Message queue size is written in BulkIndexerThread. More about the\n             * reason for that can be found there.\n             */\n        } catch (Exception e) {\n            LOG.warn(\"Error in ServerValue  WriterThread: \" + e.getMessage(), e);\n        }\n    }","commit_id":"f0754b7509374252458f5ebfa95cb0a5461b21be","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void validateBounds(final BlockRequest req, final long fileLength) {\n    if (req.getOffset() > fileLength) {\n      final String msg =\n          String.format(\"Offset(%d) is larger than file length(%d)\", req.getOffset(), fileLength);\n      throw new IllegalArgumentException(msg);\n    }\n    if (req.getLength() != -1 && req.getOffset() + req.getLength() > fileLength) {\n      final String msg =\n          String.format(\"Offset(%d) plus length(%d) is larger than file length(%d)\",\n              req.getOffset(), req.getLength(), fileLength);\n      throw new IllegalArgumentException(msg);\n    }\n  }","id":106239,"modified_method":"private void validateBounds(final BlockRequest req, final long fileLength) {\n    Preconditions.checkArgument(req.getOffset() <= fileLength,\n        \"Offset(%s) is larger than file length(%s)\", req.getOffset(), fileLength);\n    Preconditions.checkArgument(req.getLength() == -1\n        || req.getOffset() + req.getLength() <= fileLength,\n        \"Offset(%s) plus length(%s) is larger than file length(%s)\", req.getOffset(),\n        req.getLength(), fileLength);\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"private void validateInput(final BlockRequest req) {\n    if (req.getOffset() < 0) {\n      throw new IllegalArgumentException(\"Offset can not be negative: \" + req.getOffset());\n    }\n    if (req.getLength() < 0 && req.getLength() != -1) {\n      String msg = \"Length can not be negative except -1: \" + req.getLength();\n      throw new IllegalArgumentException(msg);\n    }\n  }","id":106240,"modified_method":"private void validateInput(final BlockRequest req) {\n    Preconditions.checkArgument(req.getOffset() >= 0, \"Offset can not be negative: %s\",\n        req.getOffset());\n    Preconditions.checkArgument(req.getLength() >= 0 || req.getLength() == -1,\n        \"Length can not be negative except -1: %s\", req.getLength());\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"public DataServerHandler(final BlocksLocker locker, final TachyonConf tachyonConf) {\n    mLocker = locker;\n  }","id":106241,"modified_method":"public DataServerHandler(final BlocksLocker locker) {\n    mLocker = locker;\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Returns how much of a file to read. When {@code len} is {@code -1}, then\n   * {@code fileLength - offset} is used.\n   */\n  private long returnLength(final long offset, final long len, final long fileLength) {\n    if (len == -1) {\n      return fileLength - offset;\n    } else {\n      return len;\n    }\n  }","id":106242,"modified_method":"/**\n   * Returns how much of a file to read. When {@code len} is {@code -1}, then\n   * {@code fileLength - offset} is used.\n   */\n  private long returnLength(final long offset, final long len, final long fileLength) {\n    return (len == -1) ? fileLength - offset : len;\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a default {@link io.netty.bootstrap.ServerBootstrap} where the channel and groups are\n   * preset. Current channel types supported are nio and epoll.\n   */\n  private ServerBootstrap createBootstrapOfType(final ChannelType type) {\n    final ServerBootstrap boot = new ServerBootstrap();\n    final int bossThreadCount = mTachyonConf.getInt(Constants.WORKER_NETTY_BOSS_THREADS, 1);\n    final int workerThreadCount = mTachyonConf.getInt(Constants.WORKER_NETTY_WORKER_THREADS, 0);\n    final EventLoopGroup bossGroup =\n        NettyUtils.createEventLoop(type, bossThreadCount, \"data-server-boss-%d\");\n    final EventLoopGroup workerGroup =\n        NettyUtils.createEventLoop(type, workerThreadCount, \"data-server-worker-%d\");\n\n    final Class<? extends ServerChannel> socketChannelClass =\n        NettyUtils.getServerChannelClass(type);\n    boot.group(bossGroup, workerGroup).channel(socketChannelClass);\n\n    return boot;\n  }","id":106243,"modified_method":"/**\n   * Creates a default {@link io.netty.bootstrap.ServerBootstrap} where the channel and groups are\n   * preset.\n   *\n   * @param type The channel type. Current channel types supported are nio and epoll.\n   * @return an instance of ServerBootstrap\n   */\n  private ServerBootstrap createBootstrapOfType(final ChannelType type) {\n    final ServerBootstrap boot = new ServerBootstrap();\n    final int bossThreadCount = mTachyonConf.getInt(Constants.WORKER_NETTY_BOSS_THREADS, 1);\n    final int workerThreadCount = mTachyonConf.getInt(Constants.WORKER_NETTY_WORKER_THREADS, 0);\n    final EventLoopGroup bossGroup =\n        NettyUtils.createEventLoop(type, bossThreadCount, \"data-server-boss-%d\");\n    final EventLoopGroup workerGroup =\n        NettyUtils.createEventLoop(type, workerThreadCount, \"data-server-worker-%d\");\n\n    final Class<? extends ServerChannel> socketChannelClass =\n        NettyUtils.getServerChannelClass(type);\n    boot.group(bossGroup, workerGroup).channel(socketChannelClass);\n\n    return boot;\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  protected void initChannel(SocketChannel ch) throws Exception {\n    ChannelPipeline pipeline = ch.pipeline();\n    pipeline.addLast(\"nioChunkedWriter\", new ChunkedWriteHandler());\n    pipeline.addLast(\"blockRequestDecoder\", new BlockRequest.Decoder());\n    pipeline.addLast(\"blockResponseEncoder\", new BlockResponse.Encoder(mTachyonConf));\n    pipeline.addLast(\"dataServerHandler\", new DataServerHandler(mLocker, mTachyonConf));\n  }","id":106244,"modified_method":"@Override\n  protected void initChannel(SocketChannel ch) throws Exception {\n    ChannelPipeline pipeline = ch.pipeline();\n    pipeline.addLast(\"nioChunkedWriter\", new ChunkedWriteHandler());\n    pipeline.addLast(\"blockRequestDecoder\", new BlockRequest.Decoder());\n    pipeline.addLast(\"blockResponseEncoder\", new BlockResponse.Encoder(mTachyonConf));\n    pipeline.addLast(\"dataServerHandler\", new DataServerHandler(mLocker));\n  }","commit_id":"8c8124ce02fcedd77c9fdea04a19f4f7a38c7284","url":"https://github.com/amplab/tachyon"},{"original_method":"@CheckForNull\n  private String readParamOrDefaultValue(String key, @Nullable WebService.Param definition) {\n    if (definition == null) {\n      String message = String.format(\"BUG - parameter '%s' is undefined for action '%s'\", key, action.key());\n      Loggers.get(getClass()).error(message);\n      throw new IllegalArgumentException(message);\n    }\n    String deprecatedKey = definition.deprecatedKey();\n    String value = deprecatedKey != null ? StringUtils.defaultString(readParam(deprecatedKey), readParam(key)) : readParam(key);\n    value = StringUtils.defaultString(value, definition.defaultValue());\n    if (value == null) {\n      return null;\n    }\n    return value;\n  }","id":106245,"modified_method":"@CheckForNull\n  private String readParamOrDefaultValue(String key, @Nullable WebService.Param definition) {\n    checkArgument(definition != null, \"BUG - parameter '%s' is undefined for action '%s'\", key, action.key());\n\n    String deprecatedKey = definition.deprecatedKey();\n    String value = deprecatedKey != null ? StringUtils.defaultString(readParam(deprecatedKey), readParam(key)) : readParam(key);\n    value = StringUtils.defaultString(value, definition.defaultValue());\n    return value == null ? null : value;\n  }","commit_id":"ebf15f10287a07cc593233132f930616e29fd6be","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<String> readMultiParamOrDefaultValue(String key, @Nullable WebService.Param definition) {\n    if (definition == null) {\n      String message = String.format(\"BUG - parameter '%s' is undefined for action '%s'\", key, action.key());\n      Loggers.get(getClass()).error(message);\n      throw new IllegalArgumentException(message);\n    }\n\n    List<String> keyValues = readMultiParam(key);\n    if (!keyValues.isEmpty()) {\n      return keyValues;\n    }\n\n    String deprecatedKey = definition.deprecatedKey();\n    List<String> deprecatedKeyValues = deprecatedKey == null ? emptyList() : readMultiParam(deprecatedKey);\n    if (!deprecatedKeyValues.isEmpty()) {\n      return deprecatedKeyValues;\n    }\n\n    String defaultValue = definition.defaultValue();\n    return defaultValue == null ? emptyList() : singletonList(defaultValue);\n  }","id":106246,"modified_method":"private List<String> readMultiParamOrDefaultValue(String key, @Nullable WebService.Param definition) {\n    checkArgument(definition != null, \"BUG - parameter '%s' is undefined for action '%s'\", key, action.key());\n\n    List<String> keyValues = readMultiParam(key);\n    if (!keyValues.isEmpty()) {\n      return keyValues;\n    }\n\n    String deprecatedKey = definition.deprecatedKey();\n    List<String> deprecatedKeyValues = deprecatedKey == null ? emptyList() : readMultiParam(deprecatedKey);\n    if (!deprecatedKeyValues.isEmpty()) {\n      return deprecatedKeyValues;\n    }\n\n    String defaultValue = definition.defaultValue();\n    return defaultValue == null ? emptyList() : singletonList(defaultValue);\n  }","commit_id":"ebf15f10287a07cc593233132f930616e29fd6be","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Verify that the serialization form of List and CopyOnWriteList are the same.\n     */\n    public void testSerialization() throws Exception {\n        XStream2 xs = new XStream2();\n        TestData td = new TestData();\n        StringWriter out = new StringWriter();\n\n        xs.toXML(td, out);\n        assertEquals(\"empty lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\"\n                + \"<list1/><list2/><\/hudson.util.CopyOnWriteListTest_-TestData>\",\n                out.toString().replaceAll(\"\\\\s+\", \"\"));\n        TestData td2 = (TestData)xs.fromXML(out.toString());\n        assertTrue(td2.list1.isEmpty());\n        assertTrue(td2.list2.isEmpty());\n\n        td.list1.add(\"foobar1\");\n        td.list2.add(\"foobar2\");\n        xs.toXML(td, out = new StringWriter());\n        assertEquals(\"lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\"\n                + \"<list1><string>foobar1<\/string><\/list1><list2><string>foobar2\"\n                + \"<\/string><\/list2><\/hudson.util.CopyOnWriteListTest_-TestData>\",\n                out.toString().replaceAll(\"\\\\s+\", \"\"));\n        td2 = (TestData)xs.fromXML(out.toString());\n        assertEquals(\"foobar1\", td2.list1.getView().get(0));\n        assertEquals(\"foobar2\", td2.list2.get(0));\n    }","id":106247,"modified_method":"/**\n     * Verify that the serialization form of List and CopyOnWriteList are the same.\n     */\n    public void testSerialization() throws Exception {\n        XStream2 xs = new XStream2();\n        TestData td = new TestData();\n\n        String out = xs.toXML(td);\n        assertEquals(\"empty lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\"\n                + \"<list1/><list2/><\/hudson.util.CopyOnWriteListTest_-TestData>\",\n                out.replaceAll(\"\\\\s+\", \"\"));\n        TestData td2 = (TestData)xs.fromXML(out.toString());\n        assertTrue(td2.list1.isEmpty());\n        assertTrue(td2.list2.isEmpty());\n\n        td.list1.add(\"foobar1\");\n        td.list2.add(\"foobar2\");\n        out = xs.toXML(td);\n        assertEquals(\"lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\"\n                + \"<list1><string>foobar1<\/string><\/list1><list2><string>foobar2\"\n                + \"<\/string><\/list2><\/hudson.util.CopyOnWriteListTest_-TestData>\",\n                out.replaceAll(\"\\\\s+\", \"\"));\n        td2 = (TestData)xs.fromXML(out.toString());\n        assertEquals(\"foobar1\", td2.list1.getView().get(0));\n        assertEquals(\"foobar2\", td2.list2.get(0));\n    }","commit_id":"d07feb625e958d253c3e0f5d63f2ace0d030211a","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Verify that serialization form of CopyOnWriteMap.Hash and HashMap are the same.\n     */\n    public void testHashSerialization() throws Exception {\n        HashData td = new HashData();\n        XStream2 xs = new XStream2();\n        StringWriter out = new StringWriter();\n        xs.toXML(td, out);\n        assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData>\"\n                + \"<map1/><map2/><\/hudson.util.CopyOnWriteMapTest_-HashData>\",\n                out.toString().replaceAll(\"\\\\s+\", \"\"));\n        HashData td2 = (HashData)xs.fromXML(out.toString());\n        assertTrue(td2.map1.isEmpty());\n        assertTrue(td2.map2.isEmpty());\n\n        td.map1.put(\"foo1\", \"bar1\");\n        td.map2.put(\"foo2\", \"bar2\");\n        xs.toXML(td, out = new StringWriter());\n        assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData><map1>\"\n                + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\"\n                + \"<map2><entry><string>foo2<\/string><string>bar2<\/string><\/entry>\"\n                + \"<\/map2><\/hudson.util.CopyOnWriteMapTest_-HashData>\",\n                out.toString().replaceAll(\"\\\\s+\", \"\"));\n        td2 = (HashData)xs.fromXML(out.toString());\n        assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\n        assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\n    }","id":106248,"modified_method":"/**\n     * Verify that serialization form of CopyOnWriteMap.Hash and HashMap are the same.\n     */\n    public void testHashSerialization() throws Exception {\n        HashData td = new HashData();\n        XStream2 xs = new XStream2();\n\n        String out = xs.toXML(td);\n        assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData>\"\n                + \"<map1/><map2/><\/hudson.util.CopyOnWriteMapTest_-HashData>\",\n                out.replaceAll(\"\\\\s+\", \"\"));\n        HashData td2 = (HashData)xs.fromXML(out);\n        assertTrue(td2.map1.isEmpty());\n        assertTrue(td2.map2.isEmpty());\n\n        td.map1.put(\"foo1\", \"bar1\");\n        td.map2.put(\"foo2\", \"bar2\");\n        out = xs.toXML(td);\n        assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData><map1>\"\n                + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\"\n                + \"<map2><entry><string>foo2<\/string><string>bar2<\/string><\/entry>\"\n                + \"<\/map2><\/hudson.util.CopyOnWriteMapTest_-HashData>\",\n                out.replaceAll(\"\\\\s+\", \"\"));\n        td2 = (HashData)xs.fromXML(out);\n        assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\n        assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\n    }","commit_id":"d07feb625e958d253c3e0f5d63f2ace0d030211a","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Verify that an empty CopyOnWriteMap.Tree can be serialized,\n     * and that serialization form is the same as a standard TreeMap.\n     */\n    public void testTreeSerialization() throws Exception {\n        TreeData td = new TreeData();\n        XStream2 xs = new XStream2();\n        StringWriter out = new StringWriter();\n        xs.toXML(td, out);\n        assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData>\"\n                + \"<map1><no-comparator/><\/map1><map2><no-comparator/><\/map2>\"\n                + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\",\n                out.toString().replaceAll(\"\\\\s+\", \"\"));\n        TreeData td2 = (TreeData)xs.fromXML(out.toString());\n        assertTrue(td2.map1.isEmpty());\n        assertTrue(td2.map2.isEmpty());\n\n        td = new TreeData(String.CASE_INSENSITIVE_ORDER);\n        td.map1.put(\"foo1\", \"bar1\");\n        td.map2.put(\"foo2\", \"bar2\");\n        xs.toXML(td, out = new StringWriter());\n        assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData><map1>\"\n                + \"<comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"/>\"\n                + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\"\n                + \"<map2><comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"\"\n                + \" reference=\\\"../../map1/comparator\\\"/>\"\n                + \"<entry><string>foo2<\/string><string>bar2<\/string><\/entry><\/map2>\"\n                + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\",\n                out.toString().replaceAll(\">\\\\s+<\", \"><\"));\n        td2 = (TreeData)xs.fromXML(out.toString());\n        assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\n        assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\n    }","id":106249,"modified_method":"/**\n     * Verify that an empty CopyOnWriteMap.Tree can be serialized,\n     * and that serialization form is the same as a standard TreeMap.\n     */\n    public void testTreeSerialization() throws Exception {\n        TreeData td = new TreeData();\n        XStream2 xs = new XStream2();\n\n        String out = xs.toXML(td);\n        assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData>\"\n                + \"<map1><no-comparator/><\/map1><map2><no-comparator/><\/map2>\"\n                + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\",\n                out.replaceAll(\"\\\\s+\", \"\"));\n        TreeData td2 = (TreeData)xs.fromXML(out);\n        assertTrue(td2.map1.isEmpty());\n        assertTrue(td2.map2.isEmpty());\n\n        td = new TreeData(String.CASE_INSENSITIVE_ORDER);\n        td.map1.put(\"foo1\", \"bar1\");\n        td.map2.put(\"foo2\", \"bar2\");\n        out = xs.toXML(td);\n        assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData><map1>\"\n                + \"<comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"/>\"\n                + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\"\n                + \"<map2><comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"\"\n                + \" reference=\\\"../../map1/comparator\\\"/>\"\n                + \"<entry><string>foo2<\/string><string>bar2<\/string><\/entry><\/map2>\"\n                + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\",\n                out.replaceAll(\">\\\\s+<\", \"><\"));\n        td2 = (TreeData)xs.fromXML(out);\n        assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\n        assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\n    }","commit_id":"d07feb625e958d253c3e0f5d63f2ace0d030211a","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static boolean isBinaryOperatorApplicable(final IElementType tokenType, final PsiType ltype, final PsiType rtype, final boolean strict) {\n    if (ltype == null || rtype == null) return true;\n    int resultTypeRank = BOOL_RANK;\n    boolean isApplicable = false;\n    final int ltypeRank = getTypeRank(ltype);\n    final int rtypeRank = getTypeRank(rtype);\n    Label:\n    if (tokenType == JavaTokenType.LT || tokenType == JavaTokenType.LE || tokenType == JavaTokenType.GT || tokenType == JavaTokenType.GE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.EQEQ || tokenType == JavaTokenType.NE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype) &&\n          (isPrimitiveAndNotNull(ltype) || isPrimitiveAndNotNull(rtype))) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK\n                       || ltypeRank == BOOL_RANK && rtypeRank == BOOL_RANK;\n      }\n      else {\n        if (isPrimitiveAndNotNull(ltype)) {\n          if (rtype instanceof PsiClassType) {\n            final LanguageLevel languageLevel = ((PsiClassType)rtype).getLanguageLevel();\n            if (languageLevel.isAtLeast(LanguageLevel.JDK_1_5) &&\n                !languageLevel.isAtLeast(LanguageLevel.JDK_1_8) &&\n                areTypesConvertible(ltype, rtype)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        if (isPrimitiveAndNotNull(rtype)) {\n          return ltype instanceof PsiClassType &&\n                 ((PsiClassType)ltype).getLanguageLevel().isAtLeast(LanguageLevel.JDK_1_7) &&\n                 areTypesConvertible(rtype, ltype);\n        }\n        isApplicable = areTypesConvertible(ltype, rtype) || areTypesConvertible(rtype, ltype);\n      }\n    }\n    else if (tokenType == JavaTokenType.PLUS) {\n      if (ltype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(rtype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      else if (rtype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(ltype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      //fallthrough\n\n\n\n\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ASTERISK || tokenType == JavaTokenType.DIV || tokenType == JavaTokenType.PERC ||\n             tokenType == JavaTokenType.MINUS) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.LTLT || tokenType == JavaTokenType.GTGT || tokenType == JavaTokenType.GTGTGT) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK;\n        resultTypeRank = INT_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.AND || tokenType == JavaTokenType.OR || tokenType == JavaTokenType.XOR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK\n                       || isBooleanType(ltype) && isBooleanType(rtype);\n        resultTypeRank = ltypeRank <= LONG_RANK ? INT_RANK : BOOL_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ANDAND || tokenType == JavaTokenType.OROR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = isBooleanType(ltype) && isBooleanType(rtype);\n      }\n    }\n    if (isApplicable && strict) {\n      if (resultTypeRank > MAX_NUMERIC_RANK) {\n        isApplicable = ltypeRank == resultTypeRank || ltype.equalsToText(CommonClassNames.JAVA_LANG_OBJECT);\n      }\n      else {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    return isApplicable;\n  }","id":106250,"modified_method":"public static boolean isBinaryOperatorApplicable(final IElementType tokenType, final PsiType ltype, final PsiType rtype, final boolean strict) {\n    if (ltype == null || rtype == null) return true;\n    int resultTypeRank = BOOL_RANK;\n    boolean isApplicable = false;\n    final int ltypeRank = getTypeRank(ltype);\n    final int rtypeRank = getTypeRank(rtype);\n    Label:\n    if (tokenType == JavaTokenType.LT || tokenType == JavaTokenType.LE || tokenType == JavaTokenType.GT || tokenType == JavaTokenType.GE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.EQEQ || tokenType == JavaTokenType.NE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype) &&\n          (isPrimitiveAndNotNull(ltype) || isPrimitiveAndNotNull(rtype))) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK\n                       || ltypeRank == BOOL_RANK && rtypeRank == BOOL_RANK;\n      }\n      else {\n        if (isPrimitiveAndNotNull(ltype)) {\n          if (rtype instanceof PsiClassType) {\n            final LanguageLevel languageLevel = ((PsiClassType)rtype).getLanguageLevel();\n            if (languageLevel.isAtLeast(LanguageLevel.JDK_1_5) &&\n                !languageLevel.isAtLeast(LanguageLevel.JDK_1_8) &&\n                areTypesConvertible(ltype, rtype)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        if (isPrimitiveAndNotNull(rtype)) {\n          if (ltype instanceof PsiClassType) {\n            final LanguageLevel level = ((PsiClassType)ltype).getLanguageLevel();\n            if (level.isAtLeast(LanguageLevel.JDK_1_7) && !level.isAtLeast(LanguageLevel.JDK_1_8) && areTypesConvertible(rtype, ltype)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        isApplicable = areTypesConvertible(ltype, rtype) || areTypesConvertible(rtype, ltype);\n      }\n    }\n    else if (tokenType == JavaTokenType.PLUS) {\n      if (ltype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(rtype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      else if (rtype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(ltype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      //fallthrough\n\n\n\n\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ASTERISK || tokenType == JavaTokenType.DIV || tokenType == JavaTokenType.PERC ||\n             tokenType == JavaTokenType.MINUS) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.LTLT || tokenType == JavaTokenType.GTGT || tokenType == JavaTokenType.GTGTGT) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK;\n        resultTypeRank = INT_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.AND || tokenType == JavaTokenType.OR || tokenType == JavaTokenType.XOR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK\n                       || isBooleanType(ltype) && isBooleanType(rtype);\n        resultTypeRank = ltypeRank <= LONG_RANK ? INT_RANK : BOOL_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ANDAND || tokenType == JavaTokenType.OROR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = isBooleanType(ltype) && isBooleanType(rtype);\n      }\n    }\n    if (isApplicable && strict) {\n      if (resultTypeRank > MAX_NUMERIC_RANK) {\n        isApplicable = ltypeRank == resultTypeRank || ltype.equalsToText(CommonClassNames.JAVA_LANG_OBJECT);\n      }\n      else {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    return isApplicable;\n  }","commit_id":"a0bd7a02ae49d20f8da949eaad41e4aae15d4949","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isBinaryOperatorApplicable(final IElementType tokenType, final PsiType ltype, final PsiType rtype, final boolean strict) {\n    if (ltype == null || rtype == null) return true;\n    int resultTypeRank = BOOL_RANK;\n    boolean isApplicable = false;\n    final int ltypeRank = getTypeRank(ltype);\n    final int rtypeRank = getTypeRank(rtype);\n    Label:\n    if (tokenType == JavaTokenType.LT || tokenType == JavaTokenType.LE || tokenType == JavaTokenType.GT || tokenType == JavaTokenType.GE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.EQEQ || tokenType == JavaTokenType.NE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype) &&\n          (isPrimitiveAndNotNull(ltype) || isPrimitiveAndNotNull(rtype))) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK\n                       || ltypeRank == BOOL_RANK && rtypeRank == BOOL_RANK;\n      }\n      else {\n        if (isPrimitiveAndNotNull(ltype)) {\n          return rtype instanceof PsiClassType &&\n                 ((PsiClassType)rtype).getLanguageLevel().isAtLeast(LanguageLevel.JDK_1_5) &&\n                 areTypesConvertible(ltype, rtype);\n        }\n        if (isPrimitiveAndNotNull(rtype)) {\n          return ltype instanceof PsiClassType &&\n                 ((PsiClassType)ltype).getLanguageLevel().isAtLeast(LanguageLevel.JDK_1_7) &&\n                 areTypesConvertible(rtype, ltype);\n        }\n        isApplicable = areTypesConvertible(ltype, rtype) || areTypesConvertible(rtype, ltype);\n      }\n    }\n    else if (tokenType == JavaTokenType.PLUS) {\n      if (ltype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(rtype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      else if (rtype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(ltype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      //fallthrough\n\n\n\n\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ASTERISK || tokenType == JavaTokenType.DIV || tokenType == JavaTokenType.PERC ||\n             tokenType == JavaTokenType.MINUS) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.LTLT || tokenType == JavaTokenType.GTGT || tokenType == JavaTokenType.GTGTGT) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK;\n        resultTypeRank = INT_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.AND || tokenType == JavaTokenType.OR || tokenType == JavaTokenType.XOR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK\n                       || isBooleanType(ltype) && isBooleanType(rtype);\n        resultTypeRank = ltypeRank <= LONG_RANK ? INT_RANK : BOOL_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ANDAND || tokenType == JavaTokenType.OROR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = isBooleanType(ltype) && isBooleanType(rtype);\n      }\n    }\n    if (isApplicable && strict) {\n      if (resultTypeRank > MAX_NUMERIC_RANK) {\n        isApplicable = ltypeRank == resultTypeRank || ltype.equalsToText(CommonClassNames.JAVA_LANG_OBJECT);\n      }\n      else {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    return isApplicable;\n  }","id":106251,"modified_method":"public static boolean isBinaryOperatorApplicable(final IElementType tokenType, final PsiType ltype, final PsiType rtype, final boolean strict) {\n    if (ltype == null || rtype == null) return true;\n    int resultTypeRank = BOOL_RANK;\n    boolean isApplicable = false;\n    final int ltypeRank = getTypeRank(ltype);\n    final int rtypeRank = getTypeRank(rtype);\n    Label:\n    if (tokenType == JavaTokenType.LT || tokenType == JavaTokenType.LE || tokenType == JavaTokenType.GT || tokenType == JavaTokenType.GE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.EQEQ || tokenType == JavaTokenType.NE) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype) &&\n          (isPrimitiveAndNotNull(ltype) || isPrimitiveAndNotNull(rtype))) {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK\n                       || ltypeRank == BOOL_RANK && rtypeRank == BOOL_RANK;\n      }\n      else {\n        if (isPrimitiveAndNotNull(ltype)) {\n          if (rtype instanceof PsiClassType) {\n            final LanguageLevel languageLevel = ((PsiClassType)rtype).getLanguageLevel();\n            if (languageLevel.isAtLeast(LanguageLevel.JDK_1_5) &&\n                !languageLevel.isAtLeast(LanguageLevel.JDK_1_8) &&\n                areTypesConvertible(ltype, rtype)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        if (isPrimitiveAndNotNull(rtype)) {\n          return ltype instanceof PsiClassType &&\n                 ((PsiClassType)ltype).getLanguageLevel().isAtLeast(LanguageLevel.JDK_1_7) &&\n                 areTypesConvertible(rtype, ltype);\n        }\n        isApplicable = areTypesConvertible(ltype, rtype) || areTypesConvertible(rtype, ltype);\n      }\n    }\n    else if (tokenType == JavaTokenType.PLUS) {\n      if (ltype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(rtype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      else if (rtype.equalsToText(\"java.lang.String\")) {\n        isApplicable = !isVoidType(ltype);\n        resultTypeRank = STRING_RANK;\n        break Label;\n      }\n      //fallthrough\n\n\n\n\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ASTERISK || tokenType == JavaTokenType.DIV || tokenType == JavaTokenType.PERC ||\n             tokenType == JavaTokenType.MINUS) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        resultTypeRank = Math.max(ltypeRank, rtypeRank);\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK && rtypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.LTLT || tokenType == JavaTokenType.GTGT || tokenType == JavaTokenType.GTGTGT) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK;\n        resultTypeRank = INT_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.AND || tokenType == JavaTokenType.OR || tokenType == JavaTokenType.XOR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = ltypeRank <= LONG_RANK && rtypeRank <= LONG_RANK\n                       || isBooleanType(ltype) && isBooleanType(rtype);\n        resultTypeRank = ltypeRank <= LONG_RANK ? INT_RANK : BOOL_RANK;\n      }\n    }\n    else if (tokenType == JavaTokenType.ANDAND || tokenType == JavaTokenType.OROR) {\n      if (isPrimitiveAndNotNullOrWrapper(ltype) && isPrimitiveAndNotNullOrWrapper(rtype)) {\n        isApplicable = isBooleanType(ltype) && isBooleanType(rtype);\n      }\n    }\n    if (isApplicable && strict) {\n      if (resultTypeRank > MAX_NUMERIC_RANK) {\n        isApplicable = ltypeRank == resultTypeRank || ltype.equalsToText(CommonClassNames.JAVA_LANG_OBJECT);\n      }\n      else {\n        isApplicable = ltypeRank <= MAX_NUMERIC_RANK;\n      }\n    }\n    return isApplicable;\n  }","commit_id":"a1cf88fb78929fff38d9ad95834f269a56810b59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitCallExpression(PsiCallExpression callExpression) {\n      super.visitCallExpression(callExpression);\n      if (!PsiUtil.isLanguageLevel5OrHigher(callExpression)) return;\n      final JavaResolveResult result = callExpression.resolveMethodGenerics();\n      final String description = getUncheckedCallDescription(result);\n      if (description != null) {\n        if (IGNORE_UNCHECKED_CALL) return;\n        final PsiExpression element = callExpression instanceof PsiMethodCallExpression\n                                         ? ((PsiMethodCallExpression)callExpression).getMethodExpression()\n                                         : callExpression;\n        registerProblem(description, element, myGenerifyFixes);\n      }\n      else {\n        if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n        final PsiSubstitutor substitutor = result.getSubstitutor();\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        if (argumentList != null) {\n          final PsiMethod method = (PsiMethod)result.getElement();\n          if (method != null) {\n            final PsiExpression[] expressions = argumentList.getExpressions();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            if (parameters.length != 0) {\n              for (int i = 0; i < expressions.length; i++) {\n                PsiParameter parameter = parameters[Math.min(i, parameters.length - 1)];\n                final PsiExpression expression = expressions[i];\n                final PsiType parameterType = substitutor.substitute(parameter.getType());\n                final PsiType expressionType = expression.getType();\n                if (expressionType != null) {\n                  checkRawToGenericsAssignment(expression, parameterType, expressionType, true, myGenerifyFixes);\n                }\n              }\n            }\n          }\n        }\n      }\n    }","id":106252,"modified_method":"@Override\n    public void visitCallExpression(PsiCallExpression callExpression) {\n      super.visitCallExpression(callExpression);\n      final JavaResolveResult result = callExpression.resolveMethodGenerics();\n      final String description = getUncheckedCallDescription(result);\n      if (description != null) {\n        if (IGNORE_UNCHECKED_CALL) return;\n        final PsiExpression element = callExpression instanceof PsiMethodCallExpression\n                                         ? ((PsiMethodCallExpression)callExpression).getMethodExpression()\n                                         : callExpression;\n        registerProblem(description, element, myGenerifyFixes);\n      }\n      else {\n        if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n        final PsiSubstitutor substitutor = result.getSubstitutor();\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        if (argumentList != null) {\n          final PsiMethod method = (PsiMethod)result.getElement();\n          if (method != null) {\n            final PsiExpression[] expressions = argumentList.getExpressions();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            if (parameters.length != 0) {\n              for (int i = 0; i < expressions.length; i++) {\n                PsiParameter parameter = parameters[Math.min(i, parameters.length - 1)];\n                final PsiExpression expression = expressions[i];\n                final PsiType parameterType = substitutor.substitute(parameter.getType());\n                final PsiType expressionType = expression.getType();\n                if (expressionType != null) {\n                  checkRawToGenericsAssignment(expression, parameterType, expressionType, true, myGenerifyFixes);\n                }\n              }\n            }\n          }\n        }\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n      super.visitAssignmentExpression(expression);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(expression)) return;\n      if (!\"=\".equals(expression.getOperationSign().getText())) return;\n      PsiExpression lExpr = expression.getLExpression();\n      PsiExpression rExpr = expression.getRExpression();\n      if (rExpr == null) return;\n      PsiType lType = lExpr.getType();\n      PsiType rType = rExpr.getType();\n      if (rType == null) return;\n      PsiVariable leftVar = null;\n      if (lExpr instanceof PsiReferenceExpression) {\n        PsiElement element = ((PsiReferenceExpression)lExpr).resolve();\n        if (element instanceof PsiVariable) {\n          leftVar = (PsiVariable)element;\n        }\n      }\n      checkRawToGenericsAssignment(rExpr, lType, rType, true, myOnTheFly && leftVar != null ? getChangeVariableTypeFixes(leftVar, rType) : LocalQuickFix.EMPTY_ARRAY);\n    }","id":106253,"modified_method":"@Override\n    public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n      super.visitAssignmentExpression(expression);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!\"=\".equals(expression.getOperationSign().getText())) return;\n      PsiExpression lExpr = expression.getLExpression();\n      PsiExpression rExpr = expression.getRExpression();\n      if (rExpr == null) return;\n      PsiType lType = lExpr.getType();\n      PsiType rType = rExpr.getType();\n      if (rType == null) return;\n      PsiVariable leftVar = null;\n      if (lExpr instanceof PsiReferenceExpression) {\n        PsiElement element = ((PsiReferenceExpression)lExpr).resolve();\n        if (element instanceof PsiVariable) {\n          leftVar = (PsiVariable)element;\n        }\n      }\n      checkRawToGenericsAssignment(rExpr, lType, rType, true, myOnTheFly && leftVar != null ? getChangeVariableTypeFixes(leftVar, rType) : LocalQuickFix.EMPTY_ARRAY);\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReturnStatement(PsiReturnStatement statement) {\n      super.visitReturnStatement(statement);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(statement)) return;\n      final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n      if (method != null) {\n        final PsiType returnType = method.getReturnType();\n        if (returnType != null && returnType != PsiType.VOID) {\n          final PsiExpression returnValue = statement.getReturnValue();\n          if (returnValue != null) {\n            final PsiType valueType = returnValue.getType();\n            if (valueType != null) {\n              checkRawToGenericsAssignment(returnValue, returnType, valueType,\n                                           false,\n                                           new LocalQuickFix[]{QuickFixFactory.getInstance().createMethodReturnFix(method, valueType, true)});\n            }\n          }\n        }\n      }\n    }","id":106254,"modified_method":"@Override\n    public void visitReturnStatement(PsiReturnStatement statement) {\n      super.visitReturnStatement(statement);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n      if (method != null) {\n        final PsiType returnType = method.getReturnType();\n        if (returnType != null && returnType != PsiType.VOID) {\n          final PsiExpression returnValue = statement.getReturnValue();\n          if (returnValue != null) {\n            final PsiType valueType = returnValue.getType();\n            if (valueType != null) {\n              checkRawToGenericsAssignment(returnValue, returnType, valueType,\n                                           false,\n                                           new LocalQuickFix[]{QuickFixFactory.getInstance().createMethodReturnFix(method, valueType, true)});\n            }\n          }\n        }\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitForeachStatement(PsiForeachStatement statement) {\n      super.visitForeachStatement(statement);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(statement)) return;\n      final PsiParameter parameter = statement.getIterationParameter();\n      final PsiType parameterType = parameter.getType();\n      final PsiExpression iteratedValue = statement.getIteratedValue();\n      if (iteratedValue == null) return;\n      final PsiType itemType = JavaGenericsUtil.getCollectionItemType(iteratedValue);\n      if (!PsiUtil.isLanguageLevel5OrHigher(statement)) return;\n      checkRawToGenericsAssignment(parameter, parameterType, itemType, true, myOnTheFly ? getChangeVariableTypeFixes(parameter, itemType) : LocalQuickFix.EMPTY_ARRAY);\n    }","id":106255,"modified_method":"@Override\n    public void visitForeachStatement(PsiForeachStatement statement) {\n      super.visitForeachStatement(statement);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      final PsiParameter parameter = statement.getIterationParameter();\n      final PsiType parameterType = parameter.getType();\n      final PsiExpression iteratedValue = statement.getIteratedValue();\n      if (iteratedValue == null) return;\n      final PsiType itemType = JavaGenericsUtil.getCollectionItemType(iteratedValue);\n      checkRawToGenericsAssignment(parameter, parameterType, itemType, true, myOnTheFly ? getChangeVariableTypeFixes(parameter, itemType) : LocalQuickFix.EMPTY_ARRAY);\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitVariable(PsiVariable variable) {\n      super.visitVariable(variable);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(variable)) return;\n      PsiExpression initializer = variable.getInitializer();\n      if (initializer == null || initializer instanceof PsiArrayInitializerExpression) return;\n      final PsiType initializerType = initializer.getType();\n      checkRawToGenericsAssignment(initializer, variable.getType(), initializerType, true,\n                                   myOnTheFly ? getChangeVariableTypeFixes(variable, initializerType) : LocalQuickFix.EMPTY_ARRAY);\n    }","id":106256,"modified_method":"@Override\n    public void visitVariable(PsiVariable variable) {\n      super.visitVariable(variable);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      PsiExpression initializer = variable.getInitializer();\n      if (initializer == null || initializer instanceof PsiArrayInitializerExpression) return;\n      final PsiType initializerType = initializer.getType();\n      checkRawToGenericsAssignment(initializer, variable.getType(), initializerType, true,\n                                   myOnTheFly ? getChangeVariableTypeFixes(variable, initializerType) : LocalQuickFix.EMPTY_ARRAY);\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitNewExpression(PsiNewExpression expression) {\n      super.visitNewExpression(expression);\n      if (IGNORE_UNCHECKED_GENERICS_ARRAY_CREATION) return;\n      if (!myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_5)) return;\n      final PsiJavaCodeReferenceElement classReference = expression.getClassOrAnonymousClassReference();\n      if (classReference != null && JavaGenericsUtil.isUncheckedWarning(classReference, expression.resolveMethodGenerics(), myLanguageLevel)) {\n        registerProblem(\"Unchecked generics array creation for varargs parameter\", classReference, LocalQuickFix.EMPTY_ARRAY);\n      }\n    }","id":106257,"modified_method":"@Override\n    public void visitNewExpression(PsiNewExpression expression) {\n      super.visitNewExpression(expression);\n      if (IGNORE_UNCHECKED_GENERICS_ARRAY_CREATION) return;\n      final PsiJavaCodeReferenceElement classReference = expression.getClassOrAnonymousClassReference();\n      if (classReference != null && JavaGenericsUtil.isUncheckedWarning(classReference, expression.resolveMethodGenerics(), myLanguageLevel)) {\n        registerProblem(\"Unchecked generics array creation for varargs parameter\", classReference, LocalQuickFix.EMPTY_ARRAY);\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitTypeCastExpression(PsiTypeCastExpression expression) {\n      super.visitTypeCastExpression(expression);\n      if (IGNORE_UNCHECKED_CAST) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(expression)) return;\n      final PsiTypeElement typeElement = expression.getCastType();\n      if (typeElement == null) return;\n      final PsiType castType = typeElement.getType();\n      final PsiExpression operand = expression.getOperand();\n      if (operand == null) return;\n      final PsiType exprType = operand.getType();\n      if (exprType == null) return;\n      if (!TypeConversionUtil.areTypesConvertible(exprType, castType)) return;\n      if (JavaGenericsUtil.isUncheckedCast(castType, exprType)) {\n        final String description =\n          JavaErrorMessages.message(\"generics.unchecked.cast\", JavaHighlightUtil.formatType(exprType), JavaHighlightUtil\n            .formatType(castType));\n        registerProblem(description, expression, myGenerifyFixes);\n      }\n    }","id":106258,"modified_method":"@Override\n    public void visitTypeCastExpression(PsiTypeCastExpression expression) {\n      super.visitTypeCastExpression(expression);\n      if (IGNORE_UNCHECKED_CAST) return;\n      final PsiTypeElement typeElement = expression.getCastType();\n      if (typeElement == null) return;\n      final PsiType castType = typeElement.getType();\n      final PsiExpression operand = expression.getOperand();\n      if (operand == null) return;\n      final PsiType exprType = operand.getType();\n      if (exprType == null) return;\n      if (!TypeConversionUtil.areTypesConvertible(exprType, castType)) return;\n      if (JavaGenericsUtil.isUncheckedCast(castType, exprType)) {\n        final String description =\n          JavaErrorMessages.message(\"generics.unchecked.cast\", JavaHighlightUtil.formatType(exprType), JavaHighlightUtil\n            .formatType(castType));\n        registerProblem(description, expression, myGenerifyFixes);\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder,\n                                        boolean isOnTheFly,\n                                        @NotNull LocalInspectionToolSession session) {\n    return new UncheckedWarningsVisitor(isOnTheFly, PsiUtil.getLanguageLevel(session.getFile())){\n      @Override\n      protected void registerProblem(@NotNull String message, @NotNull PsiElement psiElement, @NotNull LocalQuickFix[] quickFixes) {\n        holder.registerProblem(psiElement, message, quickFixes);\n      }\n    };\n  }","id":106259,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder,\n                                        boolean isOnTheFly,\n                                        @NotNull LocalInspectionToolSession session) {\n    LanguageLevel languageLevel = PsiUtil.getLanguageLevel(session.getFile());\n    if (!languageLevel.isAtLeast(LanguageLevel.JDK_1_5)) return super.buildVisitor(holder, isOnTheFly, session);\n\n    return new UncheckedWarningsVisitor(isOnTheFly, languageLevel){\n      @Override\n      protected void registerProblem(@NotNull String message, @NotNull PsiElement psiElement, @NotNull LocalQuickFix[] quickFixes) {\n        holder.registerProblem(psiElement, message, quickFixes);\n      }\n    };\n  }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReferenceExpression(PsiReferenceExpression expression) {\n      if (IGNORE_UNCHECKED_GENERICS_ARRAY_CREATION) return;\n      if (!myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_5)) return;\n      final JavaResolveResult result = expression.advancedResolve(false);\n      if (JavaGenericsUtil.isUncheckedWarning(expression, result, PsiUtil.getLanguageLevel(expression))) {\n        registerProblem(\"Unchecked generics array creation for varargs parameter\", expression, LocalQuickFix.EMPTY_ARRAY);\n      }\n    }","id":106260,"modified_method":"@Override\n    public void visitReferenceExpression(PsiReferenceExpression expression) {\n      if (IGNORE_UNCHECKED_GENERICS_ARRAY_CREATION) return;\n      final JavaResolveResult result = expression.advancedResolve(false);\n      if (JavaGenericsUtil.isUncheckedWarning(expression, result, myLanguageLevel)) {\n        registerProblem(\"Unchecked generics array creation for varargs parameter\", expression, LocalQuickFix.EMPTY_ARRAY);\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitArrayInitializerExpression(PsiArrayInitializerExpression arrayInitializer) {\n      super.visitArrayInitializerExpression(arrayInitializer);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(arrayInitializer)) return;\n      final PsiType type = arrayInitializer.getType();\n      if (!(type instanceof PsiArrayType)) return;\n      final PsiType componentType = ((PsiArrayType)type).getComponentType();\n\n\n      boolean arrayTypeFixChecked = false;\n      VariableArrayTypeFix fix = null;\n\n      final PsiExpression[] initializers = arrayInitializer.getInitializers();\n      for (PsiExpression expression : initializers) {\n        final PsiType itemType = expression.getType();\n\n        if (itemType == null) continue;\n        if (!TypeConversionUtil.isAssignable(componentType, itemType)) continue;\n        if (JavaGenericsUtil.isRawToGeneric(componentType, itemType)) {\n          String description = JavaErrorMessages.message(\"generics.unchecked.assignment\",\n                                                         JavaHighlightUtil.formatType(itemType),\n                                                         JavaHighlightUtil.formatType(componentType));\n          if (!arrayTypeFixChecked) {\n            final PsiType checkResult = JavaHighlightUtil.sameType(initializers);\n            fix = checkResult != null ? new VariableArrayTypeFix(arrayInitializer, checkResult) : null;\n            arrayTypeFixChecked = true;\n          }\n\n          if (fix != null) {\n            registerProblem(description, expression, new LocalQuickFix[]{fix});\n          }\n        }\n      }\n    }","id":106261,"modified_method":"@Override\n    public void visitArrayInitializerExpression(PsiArrayInitializerExpression arrayInitializer) {\n      super.visitArrayInitializerExpression(arrayInitializer);\n      if (IGNORE_UNCHECKED_ASSIGNMENT) return;\n      final PsiType type = arrayInitializer.getType();\n      if (!(type instanceof PsiArrayType)) return;\n      final PsiType componentType = ((PsiArrayType)type).getComponentType();\n\n\n      boolean arrayTypeFixChecked = false;\n      VariableArrayTypeFix fix = null;\n\n      final PsiExpression[] initializers = arrayInitializer.getInitializers();\n      for (PsiExpression expression : initializers) {\n        final PsiType itemType = expression.getType();\n\n        if (itemType == null) continue;\n        if (!TypeConversionUtil.isAssignable(componentType, itemType)) continue;\n        if (JavaGenericsUtil.isRawToGeneric(componentType, itemType)) {\n          String description = JavaErrorMessages.message(\"generics.unchecked.assignment\",\n                                                         JavaHighlightUtil.formatType(itemType),\n                                                         JavaHighlightUtil.formatType(componentType));\n          if (!arrayTypeFixChecked) {\n            final PsiType checkResult = JavaHighlightUtil.sameType(initializers);\n            fix = checkResult != null ? new VariableArrayTypeFix(arrayInitializer, checkResult) : null;\n            arrayTypeFixChecked = true;\n          }\n\n          if (fix != null) {\n            registerProblem(description, expression, new LocalQuickFix[]{fix});\n          }\n        }\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      if (IGNORE_UNCHECKED_OVERRIDING) return;\n      if (!PsiUtil.isLanguageLevel5OrHigher(method)) return;\n      if (!method.isConstructor()) {\n        List<HierarchicalMethodSignature> superMethodSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        if (!superMethodSignatures.isEmpty() && !method.hasModifierProperty(PsiModifier.STATIC)) {\n          final MethodSignature signature = method.getSignature(PsiSubstitutor.EMPTY);\n          for (MethodSignatureBackedByPsiMethod superSignature : superMethodSignatures) {\n            PsiMethod baseMethod = superSignature.getMethod();\n            PsiSubstitutor substitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(signature, superSignature);\n            if (substitutor == null) substitutor = superSignature.getSubstitutor();\n            if (PsiUtil.isRawSubstitutor(baseMethod, superSignature.getSubstitutor())) continue;\n            final PsiType baseReturnType = substitutor.substitute(baseMethod.getReturnType());\n            final PsiType overriderReturnType = method.getReturnType();\n            if (baseReturnType == null || overriderReturnType == null) return;\n            if (JavaGenericsUtil.isRawToGeneric(baseReturnType, overriderReturnType)) {\n              final String message = JavaErrorMessages.message(\"unchecked.overriding.incompatible.return.type\",\n                                                               JavaHighlightUtil.formatType(overriderReturnType),\n                                                               JavaHighlightUtil.formatType(baseReturnType));\n\n              final PsiTypeElement returnTypeElement = method.getReturnTypeElement();\n              LOG.assertTrue(returnTypeElement != null);\n              registerProblem(message, returnTypeElement, LocalQuickFix.EMPTY_ARRAY);\n            }\n          }\n        }\n      }\n    }","id":106262,"modified_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      if (IGNORE_UNCHECKED_OVERRIDING) return;\n      if (!method.isConstructor()) {\n        List<HierarchicalMethodSignature> superMethodSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        if (!superMethodSignatures.isEmpty() && !method.hasModifierProperty(PsiModifier.STATIC)) {\n          final MethodSignature signature = method.getSignature(PsiSubstitutor.EMPTY);\n          for (MethodSignatureBackedByPsiMethod superSignature : superMethodSignatures) {\n            PsiMethod baseMethod = superSignature.getMethod();\n            PsiSubstitutor substitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(signature, superSignature);\n            if (substitutor == null) substitutor = superSignature.getSubstitutor();\n            if (PsiUtil.isRawSubstitutor(baseMethod, superSignature.getSubstitutor())) continue;\n            final PsiType baseReturnType = substitutor.substitute(baseMethod.getReturnType());\n            final PsiType overriderReturnType = method.getReturnType();\n            if (baseReturnType == null || overriderReturnType == null) return;\n            if (JavaGenericsUtil.isRawToGeneric(baseReturnType, overriderReturnType)) {\n              final String message = JavaErrorMessages.message(\"unchecked.overriding.incompatible.return.type\",\n                                                               JavaHighlightUtil.formatType(overriderReturnType),\n                                                               JavaHighlightUtil.formatType(baseReturnType));\n\n              final PsiTypeElement returnTypeElement = method.getReturnTypeElement();\n              LOG.assertTrue(returnTypeElement != null);\n              registerProblem(message, returnTypeElement, LocalQuickFix.EMPTY_ARRAY);\n            }\n          }\n        }\n      }\n    }","commit_id":"d9d95cf7dd7267776513c7fcfda15f03cd623bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        optionsList = new javax.swing.JList();\n        selectAllButton = new javax.swing.JButton();\n        deselectAllButton = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n\n        optionsList.setModel(new javax.swing.AbstractListModel() {\n            String[] strings = { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\" };\n            public int getSize() { return strings.length; }\n            public Object getElementAt(int i) { return strings[i]; }\n        });\n        jScrollPane1.setViewportView(optionsList);\n\n        org.openide.awt.Mnemonics.setLocalizedText(selectAllButton, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.selectAllButton.text\")); // NOI18N\n        selectAllButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                selectAllButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deselectAllButton, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.deselectAllButton.text\")); // NOI18N\n        deselectAllButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deselectAllButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.jLabel1.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 297, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                            .addComponent(deselectAllButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                            .addComponent(selectAllButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(10, 10, 10)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(selectAllButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(deselectAllButton)\n                        .addGap(0, 202, Short.MAX_VALUE))\n                    .addComponent(jScrollPane1))\n                .addContainerGap())\n        );\n    }","id":106263,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        optionsList = new javax.swing.JList();\n        selectAllButton = new javax.swing.JButton();\n        deselectAllButton = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n\n        optionsList.setModel(new javax.swing.AbstractListModel() {\n            String[] strings = { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\" };\n            public int getSize() { return strings.length; }\n            public Object getElementAt(int i) { return strings[i]; }\n        });\n        jScrollPane1.setViewportView(optionsList);\n\n        org.openide.awt.Mnemonics.setLocalizedText(selectAllButton, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.selectAllButton.text\")); // NOI18N\n        selectAllButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                selectAllButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deselectAllButton, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.deselectAllButton.text\")); // NOI18N\n        deselectAllButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deselectAllButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(ReportWizardFileOptionsVisualPanel.class, \"ReportWizardFileOptionsVisualPanel.jLabel1.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel1)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(selectAllButton, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(deselectAllButton)))\n                        .addGap(0, 210, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(10, 10, 10)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 220, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(deselectAllButton)\n                    .addComponent(selectAllButton))\n                .addContainerGap())\n        );\n    }","commit_id":"41f238c60bf9c66765c76205dccafc2d1ec9b5ea","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jSeparator1 = new javax.swing.JSeparator();\n        lblUsername = new javax.swing.JLabel();\n        txtUsername = new javax.swing.JTextField();\n        lblFullName = new javax.swing.JLabel();\n        txtFullName = new javax.swing.JTextField();\n        lblDescription = new javax.swing.JLabel();\n        txtDescription = new javax.swing.JTextField();\n        lblPassword = new javax.swing.JLabel();\n        txtPassword = new javax.swing.JPasswordField();\n        lblPasswordConfirm = new javax.swing.JLabel();\n        txtPasswordConfirm = new javax.swing.JPasswordField();\n        cbDisabled = new javax.swing.JCheckBox();\n        jSeparator2 = new javax.swing.JSeparator();\n        spnUmask = new javax.swing.JSpinner();\n        lblUmask = new javax.swing.JLabel();\n        jSeparator3 = new javax.swing.JSeparator();\n        btnClose = new javax.swing.JButton();\n        btnCreate = new javax.swing.JButton();\n        cbPersonalGroup = new javax.swing.JCheckBox();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        lstMemberOfGroups = new javax.swing.JList();\n        lblMemberOfGroups = new javax.swing.JLabel();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        lstAvailableGroups = new javax.swing.JList();\n        lblAvailableGroups = new javax.swing.JLabel();\n        btnAddGroup = new javax.swing.JButton();\n        btnRemoveGroup = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"New User\");\n\n        lblUsername.setText(\"User name:\");\n\n        txtUsername.setInputVerifier(getUsernameInputVerifier());\n\n        lblFullName.setText(\"Full name:\");\n\n        lblDescription.setText(\"Description:\");\n\n        lblPassword.setText(\"Password:\");\n\n        txtPassword.setInputVerifier(getPasswordInputVerifier());\n\n        lblPasswordConfirm.setText(\"Confirm password:\");\n\n        txtPasswordConfirm.setInputVerifier(getPasswordInputVerifier());\n\n        cbDisabled.setText(\"Account is disabled\");\n\n        spnUmask.setModel(new UmaskSpinnerModel());\n        spnUmask.setEditor(new UmaskEditor(spnUmask));\n        spnUmask.setValue(getUmask());\n\n        lblUmask.setText(\"umask:\");\n\n        btnClose.setText(\"Close\");\n        btnClose.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCloseActionPerformed(evt);\n            }\n        });\n\n        btnCreate.setText(\"Create\");\n        btnCreate.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCreateActionPerformed(evt);\n            }\n        });\n\n        cbPersonalGroup.setSelected(true);\n        cbPersonalGroup.setText(\"Create personal user group\");\n\n        lstMemberOfGroups.setModel(getMemberOfGroupsListModel());\n        jScrollPane1.setViewportView(lstMemberOfGroups);\n\n        lblMemberOfGroups.setText(\"Member of Groups:\");\n\n        lstAvailableGroups.setModel(getAvailableGroupsListModel());\n        jScrollPane2.setViewportView(lstAvailableGroups);\n\n        lblAvailableGroups.setText(\"Available Groups:\");\n\n        btnAddGroup.setText(\"->\");\n        btnAddGroup.setToolTipText(\"Add to Group\");\n        btnAddGroup.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnAddGroupActionPerformed(evt);\n            }\n        });\n\n        btnRemoveGroup.setText(\"<-\");\n        btnRemoveGroup.setToolTipText(\"Remove from Group\");\n        btnRemoveGroup.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnRemoveGroupActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(16, 16, 16)\n                .addComponent(cbDisabled)\n                .addGap(0, 0, Short.MAX_VALUE))\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addGap(6, 6, 6)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(cbPersonalGroup)\n                                .addGap(57, 57, 57))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(btnClose)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(btnCreate)\n                                .addGap(6, 6, 6))\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(6, 6, 6)\n                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(btnAddGroup, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addComponent(btnRemoveGroup, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))\n                                    .addComponent(lblAvailableGroups))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(lblMemberOfGroups)\n                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)))))\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(25, 25, 25)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addComponent(lblDescription)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(lblFullName)\n                                            .addGap(24, 24, 24)))\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(lblUsername)\n                                        .addGap(3, 3, 3)))\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                    .addComponent(txtUsername, javax.swing.GroupLayout.DEFAULT_SIZE, 296, Short.MAX_VALUE)\n                                    .addComponent(txtFullName, javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(txtDescription, javax.swing.GroupLayout.Alignment.LEADING)))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(24, 24, 24)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(lblPasswordConfirm)\n                                    .addComponent(lblPassword))\n                                .addGap(18, 18, 18)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                    .addComponent(txtPassword, javax.swing.GroupLayout.DEFAULT_SIZE, 248, Short.MAX_VALUE)\n                                    .addComponent(txtPasswordConfirm))))\n                        .addGap(0, 35, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(jSeparator4)\n                            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.LEADING))))\n                .addContainerGap())\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(16, 16, 16)\n                        .addComponent(lblUmask)\n                        .addGap(18, 18, 18)\n                        .addComponent(spnUmask, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jSeparator2)\n                            .addComponent(jSeparator3))\n                        .addContainerGap())))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGap(22, 22, 22)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblUsername)\n                    .addComponent(txtUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblFullName)\n                    .addComponent(txtFullName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblDescription)\n                    .addComponent(txtDescription, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblPassword)\n                    .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPasswordConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblPasswordConfirm))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(cbDisabled)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(spnUmask, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblUmask))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(cbPersonalGroup)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(lblMemberOfGroups, javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(lblAvailableGroups))\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(52, 52, 52)\n                        .addComponent(btnAddGroup)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnRemoveGroup)))\n                .addGap(10, 10, 10)\n                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(btnClose)\n                    .addComponent(btnCreate))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","id":106264,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jSeparator1 = new javax.swing.JSeparator();\n        lblUsername = new javax.swing.JLabel();\n        txtUsername = new javax.swing.JTextField();\n        lblFullName = new javax.swing.JLabel();\n        txtFullName = new javax.swing.JTextField();\n        lblDescription = new javax.swing.JLabel();\n        txtDescription = new javax.swing.JTextField();\n        lblPassword = new javax.swing.JLabel();\n        txtPassword = new javax.swing.JPasswordField();\n        lblPasswordConfirm = new javax.swing.JLabel();\n        txtPasswordConfirm = new javax.swing.JPasswordField();\n        cbDisabled = new javax.swing.JCheckBox();\n        jSeparator2 = new javax.swing.JSeparator();\n        spnUmask = new javax.swing.JSpinner();\n        lblUmask = new javax.swing.JLabel();\n        jSeparator3 = new javax.swing.JSeparator();\n        btnClose = new javax.swing.JButton();\n        btnCreate = new javax.swing.JButton();\n        cbPersonalGroup = new javax.swing.JCheckBox();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        lstMemberOfGroups = new javax.swing.JList();\n        lblMemberOfGroups = new javax.swing.JLabel();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        lstAvailableGroups = new javax.swing.JList();\n        lblAvailableGroups = new javax.swing.JLabel();\n        btnAddGroup = new javax.swing.JButton();\n        btnRemoveGroup = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"New User\");\n\n        lblUsername.setText(\"User name:\");\n\n        txtUsername.setInputVerifier(getUsernameInputVerifier());\n\n        lblFullName.setText(\"Full name:\");\n\n        lblDescription.setText(\"Description:\");\n\n        lblPassword.setText(\"Password:\");\n\n        txtPassword.setInputVerifier(getPasswordInputVerifier());\n\n        lblPasswordConfirm.setText(\"Confirm password:\");\n\n        txtPasswordConfirm.setInputVerifier(getPasswordInputVerifier());\n\n        cbDisabled.setText(\"Account is disabled\");\n\n        spnUmask.setModel(new UmaskSpinnerModel());\n        spnUmask.setEditor(new UmaskEditor(spnUmask));\n        spnUmask.setValue(getUmask());\n\n        lblUmask.setText(\"umask:\");\n\n        btnClose.setText(\"Close\");\n        btnClose.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCloseActionPerformed(evt);\n            }\n        });\n\n        btnCreate.setText(\"Create\");\n        btnCreate.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCreateActionPerformed(evt);\n            }\n        });\n\n        cbPersonalGroup.setSelected(true);\n        cbPersonalGroup.setText(\"Create personal user group\");\n\n        lstMemberOfGroups.setModel(getMemberOfGroupsListModel());\n        jScrollPane1.setViewportView(lstMemberOfGroups);\n\n        lblMemberOfGroups.setText(\"Member of Groups:\");\n\n        lstAvailableGroups.setModel(getAvailableGroupsListModel());\n        jScrollPane2.setViewportView(lstAvailableGroups);\n\n        lblAvailableGroups.setText(\"Available Groups:\");\n\n        btnAddGroup.setText(\"->\");\n        btnAddGroup.setToolTipText(\"Add to Group\");\n        btnAddGroup.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnAddGroupActionPerformed(evt);\n            }\n        });\n\n        btnRemoveGroup.setText(\"<-\");\n        btnRemoveGroup.setToolTipText(\"Remove from Group\");\n        btnRemoveGroup.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnRemoveGroupActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addGap(6, 6, 6)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(btnClose)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(btnCreate)\n                                .addGap(6, 6, 6))\n                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(6, 6, 6)\n                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(btnAddGroup, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addComponent(btnRemoveGroup, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))\n                                    .addComponent(lblAvailableGroups))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(lblMemberOfGroups)\n                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)))))\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(25, 25, 25)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addComponent(lblDescription)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(lblFullName)\n                                            .addGap(24, 24, 24)))\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(lblUsername)\n                                        .addGap(3, 3, 3)))\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                    .addComponent(txtUsername, javax.swing.GroupLayout.DEFAULT_SIZE, 296, Short.MAX_VALUE)\n                                    .addComponent(txtFullName, javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(txtDescription, javax.swing.GroupLayout.Alignment.LEADING)))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(24, 24, 24)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(lblPasswordConfirm)\n                                    .addComponent(lblPassword))\n                                .addGap(18, 18, 18)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                    .addComponent(txtPassword, javax.swing.GroupLayout.DEFAULT_SIZE, 248, Short.MAX_VALUE)\n                                    .addComponent(txtPasswordConfirm))))\n                        .addGap(0, 35, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(jSeparator4)\n                            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.LEADING))))\n                .addContainerGap())\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(16, 16, 16)\n                        .addComponent(lblUmask)\n                        .addGap(18, 18, 18)\n                        .addComponent(spnUmask, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jSeparator2)\n                            .addComponent(jSeparator3))\n                        .addContainerGap())))\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(16, 16, 16)\n                        .addComponent(cbDisabled))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(cbPersonalGroup)))\n                .addGap(0, 0, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGap(22, 22, 22)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblUsername)\n                    .addComponent(txtUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblFullName)\n                    .addComponent(txtFullName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblDescription)\n                    .addComponent(txtDescription, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblPassword)\n                    .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPasswordConfirm, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblPasswordConfirm))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(cbDisabled)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(spnUmask, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblUmask))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(cbPersonalGroup)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(lblMemberOfGroups, javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(lblAvailableGroups))\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(52, 52, 52)\n                        .addComponent(btnAddGroup)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnRemoveGroup)))\n                .addGap(10, 10, 10)\n                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(btnClose)\n                    .addComponent(btnCreate))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","commit_id":"9f515f537229c026783e7170c5214fe1c3053baf","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashTable = new javax.swing.JTable();\n        hashField = new javax.swing.JTextField();\n        addButton = new javax.swing.JButton();\n        hashLabel = new javax.swing.JLabel();\n        cancelButton = new javax.swing.JButton();\n        searchButton = new javax.swing.JButton();\n        removeButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        titleLabel = new javax.swing.JLabel();\n        errorField = new javax.swing.JLabel();\n\n        hashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n                \"MD5 Hashes\"\n            }\n        ) {\n            Class[] types = new Class [] {\n                java.lang.String.class\n            };\n            boolean[] canEdit = new boolean [] {\n                false\n            };\n\n            public Class getColumnClass(int columnIndex) {\n                return types [columnIndex];\n            }\n\n            public boolean isCellEditable(int rowIndex, int columnIndex) {\n                return canEdit [columnIndex];\n            }\n        });\n        jScrollPane1.setViewportView(hashTable);\n        hashTable.getColumnModel().getColumn(0).setHeaderValue(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashTable.columnModel.title0\")); // NOI18N\n\n        hashField.setText(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(addButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.addButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(cancelButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.cancelButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.searchButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(removeButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.removeButton.text\")); // NOI18N\n\n        titleLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(titleLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.titleLabel.text\")); // NOI18N\n\n        errorField.setForeground(new java.awt.Color(255, 0, 0));\n        org.openide.awt.Mnemonics.setLocalizedText(errorField, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.errorField.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(errorField)\n                        .addGap(18, 18, 18)\n                        .addComponent(searchButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(cancelButton))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane1)\n                            .addComponent(jSeparator1)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(titleLabel)\n                                .addGap(0, 0, Short.MAX_VALUE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(hashLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(addButton)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                        .addComponent(removeButton)\n                                        .addGap(0, 0, Short.MAX_VALUE))\n                                    .addComponent(hashField))))))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(titleLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 355, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(26, 26, 26)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(hashLabel)\n                    .addComponent(hashField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addButton)\n                    .addComponent(removeButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 27, Short.MAX_VALUE)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(cancelButton)\n                    .addComponent(searchButton)\n                    .addComponent(errorField))\n                .addContainerGap())\n        );\n    }","id":106265,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashTable = new javax.swing.JTable();\n        hashField = new javax.swing.JTextField();\n        addButton = new javax.swing.JButton();\n        hashLabel = new javax.swing.JLabel();\n        cancelButton = new javax.swing.JButton();\n        searchButton = new javax.swing.JButton();\n        removeButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        titleLabel = new javax.swing.JLabel();\n        errorField = new javax.swing.JLabel();\n\n        hashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n                \"MD5 Hashes\"\n            }\n        ) {\n            Class[] types = new Class [] {\n                java.lang.String.class\n            };\n            boolean[] canEdit = new boolean [] {\n                false\n            };\n\n            public Class getColumnClass(int columnIndex) {\n                return types [columnIndex];\n            }\n\n            public boolean isCellEditable(int rowIndex, int columnIndex) {\n                return canEdit [columnIndex];\n            }\n        });\n        jScrollPane1.setViewportView(hashTable);\n        hashTable.getColumnModel().getColumn(0).setHeaderValue(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashTable.columnModel.title0\")); // NOI18N\n\n        hashField.setText(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(addButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.addButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(cancelButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.cancelButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.searchButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(removeButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.removeButton.text\")); // NOI18N\n\n        titleLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(titleLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.titleLabel.text\")); // NOI18N\n\n        errorField.setForeground(new java.awt.Color(255, 0, 0));\n        org.openide.awt.Mnemonics.setLocalizedText(errorField, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.errorField.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(errorField)\n                        .addGap(18, 18, 18)\n                        .addComponent(searchButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(cancelButton))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane1)\n                            .addComponent(jSeparator1)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(hashLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(hashField))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(titleLabel)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(61, 61, 61)\n                                        .addComponent(addButton)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                        .addComponent(removeButton)))\n                                .addGap(0, 0, Short.MAX_VALUE)))))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(titleLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 355, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(26, 26, 26)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(hashLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(hashField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addButton)\n                    .addComponent(removeButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 27, Short.MAX_VALUE)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(cancelButton)\n                    .addComponent(searchButton)\n                    .addComponent(errorField))\n                .addContainerGap())\n        );\n    }","commit_id":"d911801c80741a9f17d5c895c28e1130e1ff1759","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void attachTaskAction(final Method method, Collection<Action<Task>> actions, Collection<String> methods) {\n        if (method.getAnnotation(TaskAction.class) == null) {\n            return;\n        }\n        if (Modifier.isStatic(method.getModifiers())) {\n            throw new GradleException(String.format(\"Cannot use @TaskAction annotation on static method %s.%s().\",\n                    method.getDeclaringClass().getSimpleName(), method.getName()));\n        }\n        if (method.getParameterTypes().length > 0) {\n            throw new GradleException(String.format(\n                    \"Cannot use @TaskAction annotation on method %s.%s() as this method takes parameters.\",\n                    method.getDeclaringClass().getSimpleName(), method.getName()));\n        }\n        if (methods.contains(method.getName())) {\n            return;\n        }\n        methods.add(method.getName());\n        actions.add(new Action<Task>() {\n            public void execute(Task task) {\n                ClassLoader original = Thread.currentThread().getContextClassLoader();\n                Thread.currentThread().setContextClassLoader(method.getDeclaringClass().getClassLoader());\n                try {\n                    ReflectionUtil.invoke(task, method.getName());\n                } finally {\n                    Thread.currentThread().setContextClassLoader(original);\n                }\n            }\n        });\n    }","id":106266,"modified_method":"private void attachTaskAction(final Method method, Collection<Action<Task>> actions, Collection<String> methods) {\n        if (method.getAnnotation(TaskAction.class) == null) {\n            return;\n        }\n        if (Modifier.isStatic(method.getModifiers())) {\n            throw new GradleException(String.format(\"Cannot use @TaskAction annotation on static method %s.%s().\",\n                    method.getDeclaringClass().getSimpleName(), method.getName()));\n        }\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 1) {\n            if (!parameterTypes[0].equals(TaskExecutionContext.class)) {\n                throw new GradleException(String.format(\n                        \"Cannot use @TaskAction annotation on method %s.%s() because %s is not a valid parameter to an action method.\",\n                        method.getDeclaringClass().getSimpleName(), method.getName(), parameterTypes[0]));\n            }\n        } else if (parameterTypes.length > 1) {\n            throw new GradleException(String.format(\n                    \"Cannot use @TaskAction annotation on method %s.%s() as this method takes multiple parameters.\",\n                    method.getDeclaringClass().getSimpleName(), method.getName()));\n        }\n        if (methods.contains(method.getName())) {\n            return;\n        }\n        methods.add(method.getName());\n        if (parameterTypes.length == 1) {\n            actions.add(new IncrementalTaskAction(method));\n        } else {\n            actions.add(new StandardTaskAction(method));\n        }\n    }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, FileSnapshotter inputFilesSnapshotter, FileSnapshotter outputFilesSnapshotter) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        upToDateRule = new CompositeUpToDateRule(\n                new TaskTypeChangedUpToDateRule(),\n                new InputPropertiesChangedUpToDateRule(),\n                new OutputFilesChangedUpToDateRule(outputFilesSnapshotter),\n                new InputFilesChangedUpToDateRule(inputFilesSnapshotter));\n    }","id":106267,"modified_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, FileSnapshotter inputFilesSnapshotter, FileSnapshotter outputFilesSnapshotter) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        upToDateRule = new CompositeUpToDateRule(\n                new TaskTypeChangedUpToDateRule(),\n                new InputPropertiesChangedUpToDateRule(),\n                new OutputFilesChangedUpToDateRule(outputFilesSnapshotter),\n                new InputFilesChangedUpToDateRule(inputFilesSnapshotter));\n        incrementalUpToDateRule = new CompositeUpToDateRule(\n                new TaskTypeChangedUpToDateRule(),\n                new InputPropertiesChangedUpToDateRule(),\n                new OutputFilesChangedUpToDateRule(outputFilesSnapshotter));\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n    }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskExecutionState getExecution() {\n            return new HistoricExecution(task, history, upToDateRule);\n        }","id":106268,"modified_method":"public TaskExecutionState getExecution() {\n            return new HistoricExecution(task, history, upToDateRule, incrementalUpToDateRule, inputFilesSnapshotter);\n        }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public HistoricExecution(TaskInternal task, TaskHistoryRepository.History history, UpToDateRule rule) {\n            this.task = task;\n            this.lastExecution = history.getPreviousExecution();\n            this.thisExecution = history.getCurrentExecution();\n            this.rule = rule;\n        }","id":106269,"modified_method":"public HistoricExecution(TaskInternal task, TaskHistoryRepository.History history, UpToDateRule rule, UpToDateRule incrementalRule, FileSnapshotter inputFilesSnapshotter) {\n            this.task = task;\n            this.inputFilesSnapshotter = inputFilesSnapshotter;\n            this.lastExecution = history.getPreviousExecution();\n            this.thisExecution = history.getCurrentExecution();\n            this.rule = rule;\n            this.incrementalRule = incrementalRule;\n        }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        final TaskArtifactState state = repository.getStateFor(task);\n        return new TaskArtifactState() {\n            public boolean isUpToDate() {\n                listener.cacheable(task.getInputs().getFiles());\n                listener.cacheable(task.getOutputs().getFiles());\n\n                return state.isUpToDate();\n            }\n\n            public void beforeTask() {\n                if (task.getOutputs().getHasOutput()) {\n                    listener.invalidate(task.getOutputs().getFiles());\n                } else {\n                    listener.invalidateAll();\n                }\n                state.beforeTask();\n            }\n\n            public void afterTask() {\n                listener.cacheable(task.getOutputs().getFiles());\n                state.afterTask();\n            }\n\n            public void finished() {\n                state.finished();\n            }\n\n            public TaskExecutionHistory getExecutionHistory() {\n                return state.getExecutionHistory();\n            }\n        };\n    }","id":106270,"modified_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        final TaskArtifactState state = repository.getStateFor(task);\n        return new TaskArtifactState() {\n            public boolean isUpToDate() {\n                listener.cacheable(task.getInputs().getFiles());\n                listener.cacheable(task.getOutputs().getFiles());\n\n                return state.isUpToDate();\n            }\n\n            public TaskExecutionContext getExecutionContext() {\n                return state.getExecutionContext();\n            }\n\n            public void beforeTask() {\n                if (task.getOutputs().getHasOutput()) {\n                    listener.invalidate(task.getOutputs().getFiles());\n                } else {\n                    listener.invalidateAll();\n                }\n                state.beforeTask();\n            }\n\n            public void afterTask() {\n                listener.cacheable(task.getOutputs().getFiles());\n                state.afterTask();\n            }\n\n            public void finished() {\n                state.finished();\n            }\n\n            public TaskExecutionHistory getExecutionHistory() {\n                return state.getExecutionHistory();\n            }\n        };\n    }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public void finished() {\n        }","id":106271,"modified_method":"public NoHistoryArtifactState(TaskInternal task) {\n            this.task = task;\n        }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        if (task.getOutputs().getHasOutput()) {\n            return new ShortCircuitArtifactState(task, repository.getStateFor(task));\n        }\n        LOGGER.info(String.format(\"%s has not declared any outputs, assuming that it is out-of-date.\", StringUtils.capitalize(task.toString())));\n        return new NoHistoryArtifactState();\n    }","id":106272,"modified_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        if (task.getOutputs().getHasOutput()) {\n            return new ShortCircuitArtifactState(task, repository.getStateFor(task));\n        }\n        LOGGER.info(String.format(\"%s has not declared any outputs, assuming that it is out-of-date.\", StringUtils.capitalize(task.toString())));\n        return new NoHistoryArtifactState(task);\n    }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(TaskInternal task, TaskStateInternal state) {\n        LOGGER.debug(\"Determining if {} is up-to-date\", task);\n        TaskArtifactState taskArtifactState = repository.getStateFor(task);\n        try {\n            if (taskArtifactState.isUpToDate()) {\n                LOGGER.info(\"Skipping {} as it is up-to-date\", task);\n                state.upToDate();\n                return;\n\n            }\n            LOGGER.debug(\"{} is not up-to-date\", task);\n\n            taskArtifactState.beforeTask();\n            task.getOutputs().setHistory(taskArtifactState.getExecutionHistory());\n            try {\n                executer.execute(task, state);\n                if (state.getFailure() == null) {\n                    taskArtifactState.afterTask();\n                }\n            } finally {\n                task.getOutputs().setHistory(null);\n            }\n        } finally {\n            taskArtifactState.finished();\n        }\n    }","id":106273,"modified_method":"public void execute(TaskInternal task, TaskStateInternal state) {\n        LOGGER.debug(\"Determining if {} is up-to-date\", task);\n        TaskArtifactState taskArtifactState = repository.getStateFor(task);\n        try {\n            // TODO: If this is an incremental task, don't do this.\n//            if (taskArtifactState.isUpToDate()) {\n//                LOGGER.info(\"Skipping {} as it is up-to-date\", task);\n//                state.upToDate();\n//                return;\n//\n//            }\n//            LOGGER.debug(\"{} is not up-to-date\", task);\n\n            taskArtifactState.beforeTask();\n            task.getOutputs().setHistory(taskArtifactState.getExecutionHistory());\n            // TODO This is a crappy place for this\n            task.getOutputs().setExecutionContext(taskArtifactState.getExecutionContext());\n            try {\n                executer.execute(task, state);\n                if (state.getFailure() == null) {\n                    taskArtifactState.afterTask();\n                }\n            } finally {\n                task.getOutputs().setHistory(null);\n            }\n        } finally {\n            taskArtifactState.finished();\n        }\n    }","commit_id":"c1c08bf276c874506bb2b947f7b3f0a525d2c50a","url":"https://github.com/gradle/gradle"},{"original_method":"protected static MethodsBag extractMethods(Class<?> clazz) {\n\t\tList<Method> idMethods = new ArrayList<Method>();\n\t\tList<Method> proxyMethods = new ArrayList<Method>();\n\t\tList<Method> emptyMethods = new ArrayList<Method>();\n\n\t\tfor (Method method : ReflectionUtil.getVisibleMethods(clazz)) {\n\t\t\tId id = method.getAnnotation(Id.class);\n\n\t\t\tif (id != null) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers()) ||\n\t\t\t\t\t(method.getParameterTypes().length > 0) ||\n\t\t\t\t\t(method.getReturnType() != String.class)) {\n\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Invalid id for method \" + method);\n\t\t\t\t}\n\n\t\t\t\tidMethods.add(method);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tProxy proxy = method.getAnnotation(Proxy.class);\n\n\t\t\tif (proxy != null) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Static proxy method violation for \" + method);\n\t\t\t\t}\n\n\t\t\t\tproxyMethods.add(method);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Modifier.isAbstract(method.getModifiers())) {\n\t\t\t\temptyMethods.add(method);\n\t\t\t}\n\t\t}\n\n\t\treturn new MethodsBag(idMethods, proxyMethods, emptyMethods);\n\t}","id":106274,"modified_method":"protected static MethodsBag extractMethods(Class<?> clazz) {\n\t\tList<Method> idMethods = new ArrayList<Method>();\n\t\tList<Method> proxyMethods = new ArrayList<Method>();\n\t\tList<Method> emptyMethods = new ArrayList<Method>();\n\n\t\tfor (Method method : ReflectionUtil.getVisibleMethods(clazz)) {\n\t\t\tId id = method.getAnnotation(Id.class);\n\n\t\t\tif (id != null) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The @Id annotated method \" + method +\n\t\t\t\t\t\t\t\" must not be static\");\n\t\t\t\t}\n\n\t\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\t\t\tif ((parameterTypes.length > 0)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The @Id annotated method \" + method +\n\t\t\t\t\t\t\t\" must not have parameters\");\n\t\t\t\t}\n\n\t\t\t\tif (method.getReturnType() != String.class) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The @Id annotated method \" + method +\n\t\t\t\t\t\t\t\" must not return String\");\n\t\t\t\t}\n\n\t\t\t\tidMethods.add(method);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tProxy proxy = method.getAnnotation(Proxy.class);\n\n\t\t\tif (proxy != null) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Static proxy method violation for \" + method);\n\t\t\t\t}\n\n\t\t\t\tproxyMethods.add(method);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Modifier.isAbstract(method.getModifiers())) {\n\t\t\t\temptyMethods.add(method);\n\t\t\t}\n\t\t}\n\n\t\treturn new MethodsBag(idMethods, proxyMethods, emptyMethods);\n\t}","commit_id":"72ddf7b73a6bc32d2451a70881b7e18be1074817","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void executeRuleClosure(ModuleVersionMetaData metadata, ComponentMetadataDetails details, Closure<?> closure) {\n        List<Object> args = Lists.newArrayList();\n        // TODO: make sure that same argType doesn't occur multiple times?\n        for (Class<?> argType : closure.getParameterTypes()) {\n            if (argType == ComponentMetadataDetails.class || argType == Object.class) {\n                args.add(details);\n            } else if (argType == IvyModuleMetadata.class) {\n                if (!(metadata instanceof IvyModuleVersionMetaData)) {\n                    return;\n                }\n                args.add(new DefaultIvyModuleMetadata(((IvyModuleVersionMetaData) metadata).getExtraInfo()));\n            } else {\n                throw new GradleException(String.format(\"Unsupported parameter type for component metadata rule: %s\", argType.getName()));\n            }\n        }\n        closure.call(args.toArray());\n    }","id":106275,"modified_method":"private void executeRuleClosure(ModuleVersionMetaData metadata, ComponentMetadataDetails details, Closure<?> closure) {\n        Class<?>[] parameterTypes = closure.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new InvalidUserCodeException(\"A component metadata rule needs to have at least one parameter.\");\n        }\n\n        List<Object> args = Lists.newArrayList();\n\n        if (parameterTypes[0].isAssignableFrom(ComponentMetadataDetails.class)) {\n            args.add(details);\n        } else {\n            throw new InvalidUserCodeException(\n                    String.format(\"First parameter of a component metadata rule needs to be of type '%s'.\",\n                            ComponentMetadataDetails.class.getSimpleName()));\n        }\n\n        for (Class<?> parameterType : Arrays.asList(parameterTypes).subList(1, parameterTypes.length)) {\n            if (parameterType == IvyModuleMetadata.class) {\n                if (!(metadata instanceof IvyModuleVersionMetaData)) {\n                    return;\n                }\n                args.add(new DefaultIvyModuleMetadata(((IvyModuleVersionMetaData) metadata).getExtraInfo()));\n            } else {\n                throw new InvalidUserCodeException(String.format(\"Unsupported parameter type for component metadata rule: %s\", parameterType.getName()));\n            }\n        }\n        closure.call(args.toArray());\n    }","commit_id":"20f24b705234c852b84c7e484c4fe1be4cca9707","url":"https://github.com/gradle/gradle"},{"original_method":"public void addGui(final PreferenceDialog gui) {\n\t\t// initial fill with colors from preferences:\n\t\tMap<String,String> prefColorMap = new TreeMap<String, String>(Main.pref.getAllPrefix(\"color.\"));\n\t\tfixColorPrefixes(prefColorMap);\n\t\tMap<String,String> colorMap = new TreeMap<String, String>();\n\t\tfor(String key : prefColorMap.keySet()) {\n\t\t\tcolorMap.put(key.substring(\"color.\".length()), prefColorMap.get(key));\n\t\t}\n\t\tsetColorModel(colorMap);\n\t\t\n\t\tcolors = new JTable(tableModel) {\n\t\t\t@Override public boolean isCellEditable(int row, int column) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tcolors.setPreferredSize(new Dimension(200,200));\n\t\tcolors.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\t\tfinal TableCellRenderer oldColorsRenderer = colors.getDefaultRenderer(Object.class);\n\t\tcolors.setDefaultRenderer(Object.class, new TableCellRenderer(){\n\t\t\tpublic Component getTableCellRendererComponent(JTable t, Object o, boolean selected, boolean focus, int row, int column) {\n\t\t\t\tif (column == 1) {\n\t\t\t\t\tJLabel l = new JLabel(ColorHelper.color2html((Color)o));\n\t\t\t\t\tl.setBackground((Color)o);\n\t\t\t\t\tl.setOpaque(true);\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\treturn oldColorsRenderer.getTableCellRendererComponent(t,tr(o.toString()),selected,focus,row,column);\n\t\t\t}\n\t\t});\n\t\tcolors.getColumnModel().getColumn(1).setWidth(100);\n\n\t\tJButton colorEdit = new JButton(tr(\"Choose\"));\n\t\tcolorEdit.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (colors.getSelectedRowCount() == 0) {\n\t\t\t\t\tJOptionPane.showMessageDialog(gui, tr(\"Please select a color.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint sel = colors.getSelectedRow();\n\t\t\t\tJColorChooser chooser = new JColorChooser((Color)colors.getValueAt(sel, 1));\n\t\t\t\tint answer = JOptionPane.showConfirmDialog(gui, chooser, tr(\"Choose a color for {0}\", colors.getValueAt(sel, 0)), JOptionPane.OK_CANCEL_OPTION);\n\t\t\t\tif (answer == JOptionPane.OK_OPTION)\n\t\t\t\t\tcolors.setValueAt(chooser.getColor(), sel, 1);\n\t\t\t}\n\t\t});\n\t\tcolors.setToolTipText(tr(\"Colors used by different objects in JOSM.\"));\n\t\tcolors.setPreferredScrollableViewportSize(new Dimension(100,112));\n\t\tgui.display.add(new JLabel(tr(\"Colors\")), GBC.eol());\n\t\tgui.display.add(new JScrollPane(colors), GBC.eol().fill(GBC.BOTH));\n\t\tgui.display.add(colorEdit, GBC.eol().anchor(GBC.EAST));\n    }","id":106276,"modified_method":"public void addGui(final PreferenceDialog gui) {\n\t\t// initial fill with colors from preferences:\n\t\tMap<String,String> prefColorMap = new TreeMap<String, String>(Main.pref.getAllPrefix(\"color.\"));\n\t\tfixColorPrefixes(prefColorMap);\n\t\tMap<String,String> colorMap = new TreeMap<String, String>();\n\t\tfor(String key : prefColorMap.keySet()) {\n\t\t\tcolorMap.put(key.substring(\"color.\".length()), prefColorMap.get(key));\n\t\t}\n\t\tsetColorModel(colorMap);\n\t\t\n\t\tcolors = new JTable(tableModel) {\n\t\t\t@Override public boolean isCellEditable(int row, int column) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tcolors.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\t\tfinal TableCellRenderer oldColorsRenderer = colors.getDefaultRenderer(Object.class);\n\t\tcolors.setDefaultRenderer(Object.class, new TableCellRenderer(){\n\t\t\tpublic Component getTableCellRendererComponent(JTable t, Object o, boolean selected, boolean focus, int row, int column) {\n\t\t\t\tif (column == 1) {\n\t\t\t\t\tJLabel l = new JLabel(ColorHelper.color2html((Color)o));\n\t\t\t\t\tl.setBackground((Color)o);\n\t\t\t\t\tl.setOpaque(true);\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\treturn oldColorsRenderer.getTableCellRendererComponent(t,tr(o.toString()),selected,focus,row,column);\n\t\t\t}\n\t\t});\n\t\tcolors.getColumnModel().getColumn(1).setWidth(100);\n\n\t\tJButton colorEdit = new JButton(tr(\"Choose\"));\n\t\tcolorEdit.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (colors.getSelectedRowCount() == 0) {\n\t\t\t\t\tJOptionPane.showMessageDialog(gui, tr(\"Please select a color.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint sel = colors.getSelectedRow();\n\t\t\t\tJColorChooser chooser = new JColorChooser((Color)colors.getValueAt(sel, 1));\n\t\t\t\tint answer = JOptionPane.showConfirmDialog(gui, chooser, tr(\"Choose a color for {0}\", colors.getValueAt(sel, 0)), JOptionPane.OK_CANCEL_OPTION);\n\t\t\t\tif (answer == JOptionPane.OK_OPTION)\n\t\t\t\t\tcolors.setValueAt(chooser.getColor(), sel, 1);\n\t\t\t}\n\t\t});\n\t\tcolors.setToolTipText(tr(\"Colors used by different objects in JOSM.\"));\n\t\tcolors.setPreferredScrollableViewportSize(new Dimension(100,112));\n\n\t\tJPanel panel = new JPanel(new GridBagLayout());\n\t\tpanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\t\tJScrollPane scrollpane = new JScrollPane(colors);\n\t\tscrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n\t\tpanel.add(scrollpane, GBC.eol().fill(GBC.BOTH));\n\t\tpanel.add(colorEdit, GBC.eol().anchor(GBC.EAST));\n\t\tgui.displaycontent.addTab(tr(\"Colors\"), panel);\n    }","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(PreferenceDialog gui) {\n\t    gui.display.setPreferredSize(new Dimension(400,600));\n\t    // drawRawGpsLines\n\t\tdrawRawGpsLines.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n                            drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            colorTracks.setEnabled(drawRawGpsLines.isSelected());\n\t\t\t}\n\t\t});\n\t\tdrawRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines\"));\n\t\tdrawRawGpsLines.setToolTipText(tr(\"If your gps device draw too few lines, select this to draw lines along your way.\"));\n\t\tgui.display.add(drawRawGpsLines, GBC.eol().insets(20,0,0,0));\n\n\t\t// drawRawGpsMaxLineLength\n\t\tdrawRawGpsMaxLineLength.setText(Main.pref.get(\"draw.rawgps.max-line-length\", \"-1\"));\n\t\tdrawRawGpsMaxLineLength.setToolTipText(tr(\"Maximum length (in meters) to draw lines. Set to '-1' to draw all lines.\"));\n\t\tdrawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n\t\tgui.display.add(new JLabel(tr(\"Maximum length (meters)\")), GBC.std().insets(40,0,0,0));\n\t\tgui.display.add(drawRawGpsMaxLineLength, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n\t\t// forceRawGpsLines\n\t\tforceRawGpsLines.setToolTipText(tr(\"Force drawing of lines if the imported data contain no line information.\"));\n\t\tforceRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines.force\"));\n\t\tforceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n\t\tgui.display.add(forceRawGpsLines, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// drawGpsArrows\n\t\tdrawGpsArrows.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n\t\t\t}\n\t\t});\n\t\tdrawGpsArrows.setToolTipText(tr(\"Draw direction arrows for lines, connecting GPS points.\"));\n\t\tdrawGpsArrows.setSelected(Main.pref.getBoolean(\"draw.rawgps.direction\"));\n\t\tdrawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n\t\tgui.display.add(drawGpsArrows, GBC.eop().insets(40,0,0,0));\n\n\t\t// drawGpsArrowsFast\n\t\tdrawGpsArrowsFast.setToolTipText(tr(\"Draw the direction arrows using table lookups instead of complex math.\"));\n\t\tdrawGpsArrowsFast.setSelected(Main.pref.getBoolean(\"draw.rawgps.alternatedirection\"));\n\t\tdrawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n\t\tgui.display.add(drawGpsArrowsFast, GBC.eop().insets(60,0,0,0));\n\n\t\t// colorTracks\n\t\tcolorTracks.setSelected(Main.pref.getBoolean(\"draw.rawgps.colors\"));\n\t\tcolorTracks.setToolTipText(tr(\"Choose the hue for the track color by the velocity at that point.\"));\n\t\tcolorTracks.setEnabled(drawRawGpsLines.isSelected());\n\t\tgui.display.add(colorTracks, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// largeGpsPoints\n\t\tlargeGpsPoints.setSelected(Main.pref.getBoolean(\"draw.rawgps.large\"));\n\t\tlargeGpsPoints.setToolTipText(tr(\"Draw larger dots for the GPS points.\"));\n\t\tgui.display.add(largeGpsPoints, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\t// directionHint\n\t\tdirectionHint.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            if (directionHint.isSelected()){\n                                interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\"));\n                            }else{\n                                interestingDirections.setSelected(false);\n                            }\n                            interestingDirections.setEnabled(directionHint.isSelected());\n\t\t\t}\n\t\t});\n\t\tdirectionHint.setToolTipText(tr(\"Draw direction hints for way segments.\"));\n\t\tdirectionHint.setSelected(Main.pref.getBoolean(\"draw.segment.direction\"));\n\t\tgui.display.add(directionHint, GBC.eop().insets(20,0,0,0));\n\n\t\t// only interesting directions\n\t\tinterestingDirections.setToolTipText(tr(\"Only interesting direction hints (e.g. with oneway tag).\"));\n\t\tinterestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\"));\n\t\tinterestingDirections.setEnabled(directionHint.isSelected());\n\t\tgui.display.add(interestingDirections, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// segment order number\n\t\tsegmentOrderNumber.setToolTipText(tr(\"Draw the order numbers of all segments within their way.\"));\n\t\tsegmentOrderNumber.setSelected(Main.pref.getBoolean(\"draw.segment.order_number\"));\n\t\tgui.display.add(segmentOrderNumber, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\t// antialiasing\n\t\tuseAntialiasing.setToolTipText(tr(\"Apply antialiasing to the map view resulting in a smoother appearance.\"));\n\t\tuseAntialiasing.setSelected(Main.pref.getBoolean(\"mappaint.use-antialiasing\"));\n\t\tgui.display.add(useAntialiasing, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\t// downloaded area\n\t\tsourceBounds.setToolTipText(tr(\"Draw the boundaries of data loaded from the server.\"));\n\t\tsourceBounds.setSelected(Main.pref.getBoolean(\"draw.data.downloaded_area\", true));\n\t\tgui.display.add(sourceBounds, GBC.eop().insets(20,0,0,0));\n\n\t\t// virtual nodes\n\t\tvirtualNodes.setToolTipText(tr(\"Draw virtual nodes in select mode for easy way modification.\"));\n\t\tvirtualNodes.setSelected(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) != 0);\n\t\tgui.display.add(virtualNodes, GBC.eop().insets(20,0,0,0));\n\n\t\t// background layers in inactive color\n\t\tinactive.setToolTipText(tr(\"Draw the inactive data layers in a different color.\"));\n\t\tinactive.setSelected(Main.pref.getBoolean(\"draw.data.inactive_color\", true));\n\t\tgui.display.add(inactive, GBC.eop().insets(20,0,0,0));\n\n\t\t// Show splash screen on startup\n\t\tshowSplashScreen.setToolTipText(tr(\"Show splash screen at startup\"));\n\t\tshowSplashScreen.setSelected(Main.pref.getBoolean(\"draw.splashscreen\", true));\n\t\tgui.display.add(showSplashScreen, GBC.eop().insets(20, 0, 0, 0));\n\t}","id":106277,"modified_method":"public void addGui(PreferenceDialog gui) {\n\t    gui.display.setPreferredSize(new Dimension(400,600));\n        JPanel panel = new JPanel(new GridBagLayout());\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n\t    // drawRawGpsLines\n\t\tdrawRawGpsLines.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n                            drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            colorTracks.setEnabled(drawRawGpsLines.isSelected());\n\t\t\t}\n\t\t});\n\t\tdrawRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines\"));\n\t\tdrawRawGpsLines.setToolTipText(tr(\"If your gps device draw too few lines, select this to draw lines along your way.\"));\n\t\tpanel.add(drawRawGpsLines, GBC.eol().insets(20,0,0,0));\n\n\t\t// drawRawGpsMaxLineLength\n\t\tdrawRawGpsMaxLineLength.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.max-line-length\", -1)));\n\t\tdrawRawGpsMaxLineLength.setToolTipText(tr(\"Maximum length (in meters) to draw lines. Set to '-1' to draw all lines.\"));\n\t\tdrawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n\t\tpanel.add(new JLabel(tr(\"Maximum length (meters)\")), GBC.std().insets(40,0,0,0));\n\t\tpanel.add(drawRawGpsMaxLineLength, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n\t\t// forceRawGpsLines\n\t\tforceRawGpsLines.setToolTipText(tr(\"Force drawing of lines if the imported data contain no line information.\"));\n\t\tforceRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines.force\"));\n\t\tforceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n\t\tpanel.add(forceRawGpsLines, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// drawGpsArrows\n\t\tdrawGpsArrows.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n\t\t\t}\n\t\t});\n\t\tdrawGpsArrows.setToolTipText(tr(\"Draw direction arrows for lines, connecting GPS points.\"));\n\t\tdrawGpsArrows.setSelected(Main.pref.getBoolean(\"draw.rawgps.direction\"));\n\t\tdrawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n\t\tpanel.add(drawGpsArrows, GBC.eop().insets(40,0,0,0));\n\n\t\t// drawGpsArrowsFast\n\t\tdrawGpsArrowsFast.setToolTipText(tr(\"Draw the direction arrows using table lookups instead of complex math.\"));\n\t\tdrawGpsArrowsFast.setSelected(Main.pref.getBoolean(\"draw.rawgps.alternatedirection\"));\n\t\tdrawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n\t\tpanel.add(drawGpsArrowsFast, GBC.eop().insets(60,0,0,0));\n\n\t\t// drawGpsArrowsMinDist\n\t\tdrawGpsArrowsMinDist.setToolTipText(tr(\"Don't draw arrows if they are not at least this distance away from the last one.\"));\n\t\tdrawGpsArrowsMinDist.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.min-arrow-distance\", 0)));\n\t\tdrawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n\t\tpanel.add(new JLabel(tr(\"Minimum distance (pixels)\")), GBC.std().insets(60,0,0,0));\n\t\tpanel.add(drawGpsArrowsMinDist, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n\t\t// colorTracks\n\t\tcolorTracks.setSelected(Main.pref.getBoolean(\"draw.rawgps.colors\"));\n\t\tcolorTracks.setToolTipText(tr(\"Choose the hue for the track color by the velocity at that point.\"));\n\t\tcolorTracks.setEnabled(drawRawGpsLines.isSelected());\n\t\tpanel.add(colorTracks, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// largeGpsPoints\n\t\tlargeGpsPoints.setSelected(Main.pref.getBoolean(\"draw.rawgps.large\"));\n\t\tlargeGpsPoints.setToolTipText(tr(\"Draw larger dots for the GPS points.\"));\n\t\tpanel.add(largeGpsPoints, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\tpanel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n\t\tJScrollPane scrollpane = new JScrollPane(panel);\n\t\tscrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n\t\tgui.displaycontent.addTab(tr(\"GPS Points\"), scrollpane);\n\t\tpanel = new JPanel(new GridBagLayout());\n\t\tpanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n\t\t// directionHint\n\t\tdirectionHint.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n                            if (directionHint.isSelected()){\n                                interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\"));\n                            }else{\n                                interestingDirections.setSelected(false);\n                            }\n                            interestingDirections.setEnabled(directionHint.isSelected());\n\t\t\t}\n\t\t});\n\t\tdirectionHint.setToolTipText(tr(\"Draw direction hints for way segments.\"));\n\t\tdirectionHint.setSelected(Main.pref.getBoolean(\"draw.segment.direction\"));\n\t\tpanel.add(directionHint, GBC.eop().insets(20,0,0,0));\n\n\t\t// only interesting directions\n\t\tinterestingDirections.setToolTipText(tr(\"Only interesting direction hints (e.g. with oneway tag).\"));\n\t\tinterestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\"));\n\t\tinterestingDirections.setEnabled(directionHint.isSelected());\n\t\tpanel.add(interestingDirections, GBC.eop().insets(40,0,0,0));\n\t\t\n\t\t// segment order number\n\t\tsegmentOrderNumber.setToolTipText(tr(\"Draw the order numbers of all segments within their way.\"));\n\t\tsegmentOrderNumber.setSelected(Main.pref.getBoolean(\"draw.segment.order_number\"));\n\t\tpanel.add(segmentOrderNumber, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\t// antialiasing\n\t\tuseAntialiasing.setToolTipText(tr(\"Apply antialiasing to the map view resulting in a smoother appearance.\"));\n\t\tuseAntialiasing.setSelected(Main.pref.getBoolean(\"mappaint.use-antialiasing\"));\n\t\tpanel.add(useAntialiasing, GBC.eop().insets(20,0,0,0));\n\t\t\n\t\t// downloaded area\n\t\tsourceBounds.setToolTipText(tr(\"Draw the boundaries of data loaded from the server.\"));\n\t\tsourceBounds.setSelected(Main.pref.getBoolean(\"draw.data.downloaded_area\", true));\n\t\tpanel.add(sourceBounds, GBC.eop().insets(20,0,0,0));\n\n\t\t// virtual nodes\n\t\tvirtualNodes.setToolTipText(tr(\"Draw virtual nodes in select mode for easy way modification.\"));\n\t\tvirtualNodes.setSelected(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) != 0);\n\t\tpanel.add(virtualNodes, GBC.eop().insets(20,0,0,0));\n\n\t\t// background layers in inactive color\n\t\tinactive.setToolTipText(tr(\"Draw the inactive data layers in a different color.\"));\n\t\tinactive.setSelected(Main.pref.getBoolean(\"draw.data.inactive_color\", true));\n\t\tpanel.add(inactive, GBC.eop().insets(20,0,0,0));\n\n \t\tpanel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n \t\tscrollpane = new JScrollPane(panel);\n \t\tscrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n \t\tgui.displaycontent.addTab(tr(\"OSM Data\"), scrollpane);\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void ok() {\n\t\tMain.pref.put(\"draw.rawgps.lines\", drawRawGpsLines.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.max-line-length\", drawRawGpsMaxLineLength.getText());\n\t\tMain.pref.put(\"draw.rawgps.lines.force\", forceRawGpsLines.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.direction\", drawGpsArrows.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.alternatedirection\", drawGpsArrowsFast.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.colors\", colorTracks.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.large\", largeGpsPoints.isSelected());\n\t\tMain.pref.put(\"draw.segment.direction\", directionHint.isSelected());\n\t\tMain.pref.put(\"draw.segment.relevant_directions_only\", interestingDirections.isSelected());\n\t\tMain.pref.put(\"draw.segment.order_number\", segmentOrderNumber.isSelected());\n\t\tMain.pref.put(\"draw.data.downloaded_area\", sourceBounds.isSelected());\n\t\tMain.pref.put(\"draw.data.inactive_color\", inactive.isSelected());\n\t\tMain.pref.put(\"mappaint.use-antialiasing\", useAntialiasing.isSelected());\n\t\tMain.pref.put(\"draw.splashscreen\", showSplashScreen.isSelected());\n\t\tint vn = Main.pref.getInteger(\"mappaint.node.virtual-size\", 8);\n\t\tif(virtualNodes.isSelected()) {\tif (vn < 1) vn = 8; }\n\t\telse { vn = 0; }\n\t\tMain.pref.put(\"mappaint.node.virtual-size\", Integer.toString(vn));\n\t}","id":106278,"modified_method":"public void ok() {\n\t\tMain.pref.put(\"draw.rawgps.lines\", drawRawGpsLines.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.max-line-length\", drawRawGpsMaxLineLength.getText());\n\t\tMain.pref.put(\"draw.rawgps.lines.force\", forceRawGpsLines.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.direction\", drawGpsArrows.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.alternatedirection\", drawGpsArrowsFast.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.min-arrow-distance\", drawGpsArrowsMinDist.getText());\n\t\tMain.pref.put(\"draw.rawgps.colors\", colorTracks.isSelected());\n\t\tMain.pref.put(\"draw.rawgps.large\", largeGpsPoints.isSelected());\n\t\tMain.pref.put(\"draw.segment.direction\", directionHint.isSelected());\n\t\tMain.pref.put(\"draw.segment.relevant_directions_only\", interestingDirections.isSelected());\n\t\tMain.pref.put(\"draw.segment.order_number\", segmentOrderNumber.isSelected());\n\t\tMain.pref.put(\"draw.data.downloaded_area\", sourceBounds.isSelected());\n\t\tMain.pref.put(\"draw.data.inactive_color\", inactive.isSelected());\n\t\tMain.pref.put(\"mappaint.use-antialiasing\", useAntialiasing.isSelected());\n\t\tint vn = Main.pref.getInteger(\"mappaint.node.virtual-size\", 8);\n\t\tif(virtualNodes.isSelected()) {\tif (vn < 1) vn = 8; }\n\t\telse { vn = 0; }\n\t\tMain.pref.put(\"mappaint.node.virtual-size\", Integer.toString(vn));\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void paint(Graphics g, MapView mv) {\n\n\t\t/****************************************************************\n\t\t ********** STEP 1 - GET CONFIG VALUES **************************\n\t\t ****************************************************************/\n\t\t// Long startTime = System.currentTimeMillis();\n\t\tColor neutralColor = Main.pref.getColor(marktr(\"gps point\"), \"layer \"+name, Color.GRAY);\n\t\tboolean forceLines = Main.pref.getBoolean(\"draw.rawgps.lines.force\");                     // also draw lines between points belonging to different segments\n\t\tboolean direction = Main.pref.getBoolean(\"draw.rawgps.direction\");                        // draw direction arrows on the lines\n\t\tint maxLineLength = -1;\n\t\ttry {\n\t\t\tmaxLineLength = Integer.parseInt(Main.pref.get(\"draw.rawgps.max-line-length\", \"-1\"));   // don't draw lines if longer than x meters\n\t\t} catch (java.lang.NumberFormatException e) {\n\t\t\tMain.pref.put(\"draw.rawgps.max-line-length\", \"-1\");\n\t\t}\n\t\tboolean lines = Main.pref.getBoolean(\"draw.rawgps.lines\");                                // draw line between points, global setting\n\t\tString linesKey = \"draw.rawgps.lines.layer \"+name;\n\t\tif (Main.pref.hasKey(linesKey))\n\t\t\tlines = Main.pref.getBoolean(linesKey);                                                 // draw lines, per-layer setting\n\t\tboolean large = Main.pref.getBoolean(\"draw.rawgps.large\");                                // paint large dots for points\n\t\tboolean colored = Main.pref.getBoolean(\"draw.rawgps.colors\");                             // color the lines\n\t\tboolean alternatedirection = Main.pref.getBoolean(\"draw.rawgps.alternatedirection\");      // paint direction arrow with alternate math. may be faster\n\n\t\t/****************************************************************\n\t\t ********** STEP 2a - CHECK CACHE VALIDITY **********************\n\t\t ****************************************************************/\n\t\tif (computeCacheInSync && ((computeCacheMaxLineLengthUsed != maxLineLength) ||\n\t\t\t\t\t\t\t\t   (!neutralColor.equals(computeCacheColorUsed)) ||\n\t\t\t\t\t\t\t\t   (computeCacheColored != colored))) {\n//          System.out.println(\"(re-)computing gpx line styles, reason: CCIS=\" + computeCacheInSync + \" CCMLLU=\" + (computeCacheMaxLineLengthUsed != maxLineLength) + \" CCCU=\" +  (!neutralColor.equals(computeCacheColorUsed)) + \" CCC=\" + (computeCacheColored != colored));\n\t\t\tcomputeCacheMaxLineLengthUsed = maxLineLength;\n\t\t\tcomputeCacheInSync = false;\n\t\t\tcomputeCacheColorUsed = neutralColor;\n\t\t\tcomputeCacheColored = colored;\n\t\t}\n\n\t\t/****************************************************************\n\t\t ********** STEP 2b - RE-COMPUTE CACHE DATA *********************\n\t\t ****************************************************************/\n\t\tif (!computeCacheInSync) { // don't compute if the cache is good\n\t\t\tWayPoint oldWp = null;\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tif (!forceLines) { // don't draw lines between segments, unless forced to\n\t\t\t\t\toldWp = null;\n\t\t\t\t}\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (oldWp != null) {\n\t\t\t\t\t\t\tdouble dist = trkPnt.latlon.greatCircleDistance(oldWp.latlon);\n\t\t\t\t\t\t\tdouble dtime = trkPnt.time - oldWp.time;\n\t\t\t\t\t\t\tdouble vel = dist/dtime;\n\n\t\t\t\t\t\t\tif (!colored) {\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = neutralColor;\n\t\t\t\t\t\t\t} else if (dtime <= 0 || vel < 0 || vel > 36) { // attn: bad case first\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[255];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[(int) (7*vel)];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (maxLineLength == -1 || dist <= maxLineLength) {\n\t\t\t\t\t\t\t\ttrkPnt.drawLine = true;\n\t\t\t\t\t\t\t\ttrkPnt.dir = (int)(Math.atan2(-trkPnt.eastNorth.north()+oldWp.eastNorth.north(), trkPnt.eastNorth.east()-oldWp.eastNorth.east()) / Math.PI * 4 + 3.5); // crude but works\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttrkPnt.drawLine = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // make sure we reset outdated data\n\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[255];\n\t\t\t\t\t\t\ttrkPnt.drawLine = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toldWp = trkPnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomputeCacheInSync = true;\n\t\t}\n\n\t\t/****************************************************************\n\t\t ********** STEP 3a - DRAW LINES ********************************\n\t\t ****************************************************************/\n\t\tif (lines) {\n\t\tPoint old = null;\n\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && ((old.x != screen.x) || (old.y != screen.y))) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tg.drawLine(old.x, old.y, screen.x, screen.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\told = screen;\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3b - DRAW NICE ARROWS **************************\n\t\t ****************************************************************/\n\t\tif (lines && direction && !alternatedirection) {\n\t\t\tPoint old = null;\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && ((old.x != screen.x) || (old.y != screen.y))) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tdouble t = Math.atan2(screen.y-old.y, screen.x-old.x) + Math.PI;\n\t\t\t\t\t\t\t\tg.drawLine(screen.x,screen.y, (int)(screen.x + 10*Math.cos(t-PHI)), (int)(screen.y\n\t\t\t\t\t\t\t\t+ 10*Math.sin(t-PHI)));\n\t\t\t\t\t\t\t\tg.drawLine(screen.x,screen.y, (int)(screen.x + 10*Math.cos(t+PHI)), (int)(screen.y\n\t\t\t\t\t\t\t\t+ 10*Math.sin(t+PHI)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told = screen;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3c - DRAW FAST ARROWS **************************\n\t\t ****************************************************************/\n\t\tif (lines && direction && alternatedirection) {\n\t\t\tPoint old = null;\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && ((old.x != screen.x) || (old.y != screen.y))) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tg.drawLine(screen.x, screen.y, screen.x + dir[trkPnt.dir][0], screen.y + dir[trkPnt.dir][1]);\n\t\t\t\t\t\t\t\tg.drawLine(screen.x, screen.y, screen.x + dir[trkPnt.dir][2], screen.y + dir[trkPnt.dir][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told = screen;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3d - DRAW LARGE POINTS *************************\n\t\t ****************************************************************/\n\t\tif (large) {\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\tg.fillRect(screen.x-1, screen.y-1, 3, 3);\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t/****************************************************************\n\t\t ********** STEP 3e - DRAW SMALL POINTS FOR LINES ***************\n\t\t ****************************************************************/\n\t\tif (!large && lines){\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tg.drawRect(screen.x, screen.y, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t/****************************************************************\n\t\t ********** STEP 3f - DRAW SMALL POINTS INSTEAD OF LINES ********\n\t\t ****************************************************************/\n\t\tif (!large && !lines){\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tg.drawRect(screen.x, screen.y, 0, 0);\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t//Long duration = System.currentTimeMillis() - startTime;\n\t\t//System.out.println(duration);\n\t}","id":106279,"modified_method":"@Override public void paint(Graphics g, MapView mv) {\n\n\t\t/****************************************************************\n\t\t ********** STEP 1 - GET CONFIG VALUES **************************\n\t\t ****************************************************************/\n\t\t// Long startTime = System.currentTimeMillis();\n\t\tColor neutralColor = Main.pref.getColor(marktr(\"gps point\"), \"layer \"+name, Color.GRAY);\n\t\tboolean forceLines = Main.pref.getBoolean(\"draw.rawgps.lines.force\");                     // also draw lines between points belonging to different segments\n\t\tboolean direction = Main.pref.getBoolean(\"draw.rawgps.direction\");                        // draw direction arrows on the lines\n\t\tint maxLineLength = -1;\n\t\ttry {\n\t\t\tmaxLineLength = Integer.parseInt(Main.pref.get(\"draw.rawgps.max-line-length\", \"-1\"));   // don't draw lines if longer than x meters\n\t\t} catch (java.lang.NumberFormatException e) {\n\t\t\tMain.pref.put(\"draw.rawgps.max-line-length\", \"-1\");\n\t\t}\n\t\tboolean lines = Main.pref.getBoolean(\"draw.rawgps.lines\");                                // draw line between points, global setting\n\t\tString linesKey = \"draw.rawgps.lines.layer \"+name;\n\t\tif (Main.pref.hasKey(linesKey))\n\t\t\tlines = Main.pref.getBoolean(linesKey);                                                 // draw lines, per-layer setting\n\t\tboolean large = Main.pref.getBoolean(\"draw.rawgps.large\");                                // paint large dots for points\n\t\tboolean colored = Main.pref.getBoolean(\"draw.rawgps.colors\");                             // color the lines\n\t\tboolean alternatedirection = Main.pref.getBoolean(\"draw.rawgps.alternatedirection\");      // paint direction arrow with alternate math. may be faster\n\t\tint delta = 0;\n\t\ttry {\n\t\t\tdelta = Integer.parseInt(Main.pref.get(\"draw.rawgps.min-arrow-distance\", \"0\"));         // don't draw arrows nearer to each other than this\n\t\t} catch (java.lang.NumberFormatException e) {\n\t\t\tMain.pref.put(\"draw.rawgps.min-arrow-distance\", \"0\");\n\t\t}\n\n\t\t/****************************************************************\n\t\t ********** STEP 2a - CHECK CACHE VALIDITY **********************\n\t\t ****************************************************************/\n\t\tif (computeCacheInSync && ((computeCacheMaxLineLengthUsed != maxLineLength) ||\n\t\t\t\t\t\t\t\t   (!neutralColor.equals(computeCacheColorUsed)) ||\n\t\t\t\t\t\t\t\t   (computeCacheColored != colored))) {\n//          System.out.println(\"(re-)computing gpx line styles, reason: CCIS=\" + computeCacheInSync + \" CCMLLU=\" + (computeCacheMaxLineLengthUsed != maxLineLength) + \" CCCU=\" +  (!neutralColor.equals(computeCacheColorUsed)) + \" CCC=\" + (computeCacheColored != colored));\n\t\t\tcomputeCacheMaxLineLengthUsed = maxLineLength;\n\t\t\tcomputeCacheInSync = false;\n\t\t\tcomputeCacheColorUsed = neutralColor;\n\t\t\tcomputeCacheColored = colored;\n\t\t}\n\n\t\t/****************************************************************\n\t\t ********** STEP 2b - RE-COMPUTE CACHE DATA *********************\n\t\t ****************************************************************/\n\t\tif (!computeCacheInSync) { // don't compute if the cache is good\n\t\t\tWayPoint oldWp = null;\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tif (!forceLines) { // don't draw lines between segments, unless forced to\n\t\t\t\t\toldWp = null;\n\t\t\t\t}\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (oldWp != null) {\n\t\t\t\t\t\t\tdouble dist = trkPnt.latlon.greatCircleDistance(oldWp.latlon);\n\t\t\t\t\t\t\tdouble dtime = trkPnt.time - oldWp.time;\n\t\t\t\t\t\t\tdouble vel = dist/dtime;\n\n\t\t\t\t\t\t\tif (!colored) {\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = neutralColor;\n\t\t\t\t\t\t\t} else if (dtime <= 0 || vel < 0 || vel > 36) { // attn: bad case first\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[255];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[(int) (7*vel)];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (maxLineLength == -1 || dist <= maxLineLength) {\n\t\t\t\t\t\t\t\ttrkPnt.drawLine = true;\n\t\t\t\t\t\t\t\ttrkPnt.dir = (int)(Math.atan2(-trkPnt.eastNorth.north()+oldWp.eastNorth.north(), trkPnt.eastNorth.east()-oldWp.eastNorth.east()) / Math.PI * 4 + 3.5); // crude but works\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttrkPnt.drawLine = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // make sure we reset outdated data\n\t\t\t\t\t\t\ttrkPnt.speedLineColor = colors[255];\n\t\t\t\t\t\t\ttrkPnt.drawLine = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toldWp = trkPnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomputeCacheInSync = true;\n\t\t}\n\n\t\t/****************************************************************\n\t\t ********** STEP 3a - DRAW LINES ********************************\n\t\t ****************************************************************/\n\t\tif (lines) {\n\t\tPoint old = null;\n\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && ((old.x != screen.x) || (old.y != screen.y))) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tg.drawLine(old.x, old.y, screen.x, screen.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\told = screen;\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3b - DRAW NICE ARROWS **************************\n\t\t ****************************************************************/\n\t\tif (lines && direction && !alternatedirection) {\n\t\t\tPoint old = null;\n\t\t\tPoint oldA = null; // last arrow painted\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && (oldA == null || screen.x < oldA.x-delta || screen.x > oldA.x+delta || screen.y < oldA.y-delta || screen.y > oldA.y+delta)) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tdouble t = Math.atan2(screen.y-old.y, screen.x-old.x) + Math.PI;\n\t\t\t\t\t\t\t\tg.drawLine(screen.x,screen.y, (int)(screen.x + 10*Math.cos(t-PHI)), (int)(screen.y\n\t\t\t\t\t\t\t\t+ 10*Math.sin(t-PHI)));\n\t\t\t\t\t\t\t\tg.drawLine(screen.x,screen.y, (int)(screen.x + 10*Math.cos(t+PHI)), (int)(screen.y\n\t\t\t\t\t\t\t\t+ 10*Math.sin(t+PHI)));\n\t\t\t\t\t\t\t\toldA = screen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told = screen;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3c - DRAW FAST ARROWS **************************\n\t\t ****************************************************************/\n\t\tif (lines && direction && alternatedirection) {\n\t\t\tPoint old = null;\n\t\t\tPoint oldA = null; // last arrow painted\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\t// skip points that are on the same screenposition\n\t\t\t\t\t\t\tif (old != null && (oldA == null || screen.x < oldA.x-delta || screen.x > oldA.x+delta || screen.y < oldA.y-delta || screen.y > oldA.y+delta)) {\n\t\t\t\t\t\t\t\tg.setColor(trkPnt.speedLineColor);\n\t\t\t\t\t\t\t\tg.drawLine(screen.x, screen.y, screen.x + dir[trkPnt.dir][0], screen.y + dir[trkPnt.dir][1]);\n\t\t\t\t\t\t\t\tg.drawLine(screen.x, screen.y, screen.x + dir[trkPnt.dir][2], screen.y + dir[trkPnt.dir][3]);\n\t\t\t\t\t\t\t\toldA = screen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told = screen;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if lines\n\n\t\t/****************************************************************\n\t\t ********** STEP 3d - DRAW LARGE POINTS *************************\n\t\t ****************************************************************/\n\t\tif (large) {\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\t\tg.fillRect(screen.x-1, screen.y-1, 3, 3);\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t/****************************************************************\n\t\t ********** STEP 3e - DRAW SMALL POINTS FOR LINES ***************\n\t\t ****************************************************************/\n\t\tif (!large && lines){\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!trkPnt.drawLine) {\n\t\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tg.drawRect(screen.x, screen.y, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t/****************************************************************\n\t\t ********** STEP 3f - DRAW SMALL POINTS INSTEAD OF LINES ********\n\t\t ****************************************************************/\n\t\tif (!large && !lines){\n\t\t\tg.setColor(neutralColor);\n\t\t\tfor (GpxTrack trk : data.tracks) {\n\t\t\t\tfor (Collection<WayPoint> segment : trk.trackSegs) {\n\t\t\t\t\tfor (WayPoint trkPnt : segment) {\n\t\t\t\t\t\tif (Double.isNaN(trkPnt.latlon.lat()) || Double.isNaN(trkPnt.latlon.lon()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoint screen = mv.getPoint(trkPnt.eastNorth);\n\t\t\t\t\t\tg.drawRect(screen.x, screen.y, 0, 0);\n\t\t\t\t\t} // end for trkpnt\n\t\t\t\t} // end for segment\n\t\t\t} // end for trk\n\t\t} // end if large\n\n\t\t//Long duration = System.currentTimeMillis() - startTime;\n\t\t//System.out.println(duration);\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void ok() {\n\t\tMain.pref.put(\"laf\", ((LookAndFeelInfo)lafCombo.getSelectedItem()).getClassName());\n    }","id":106280,"modified_method":"public void ok() {\n\t\tMain.pref.put(\"laf\", ((LookAndFeelInfo)lafCombo.getSelectedItem()).getClassName());\n\t\tMain.pref.put(\"draw.splashscreen\", showSplashScreen.isSelected());\n\t\tMain.pref.put(\"osm-primitives.showid\", showID.isSelected());\n    }","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(PreferenceDialog gui) {\n\t\tlafCombo = new JComboBox(UIManager.getInstalledLookAndFeels());\n\n\t\t// let's try to load additional LookAndFeels and put them into the list\n\t\ttry {\n\t\t\tClass<?> Cquaqua = Class.forName(\"ch.randelshofer.quaqua.QuaquaLookAndFeel\");\n\t\t\tObject Oquaqua = Cquaqua.getConstructor((Class[])null).newInstance((Object[])null);\n\t\t\t// no exception? Then Go!\n\t\t\tlafCombo.addItem(\n\t\t\t\tnew UIManager.LookAndFeelInfo(((javax.swing.LookAndFeel)Oquaqua).getName(), \"ch.randelshofer.quaqua.QuaquaLookAndFeel\")\n\t\t\t);\n\t\t} catch (Exception ex) {\n\t\t\t// just ignore, Quaqua may not even be installed...\n\t\t\t//System.out.println(\"Failed to load Quaqua: \" + ex);\n\t\t}\n\n\t\tString laf = Main.pref.get(\"laf\");\n\t\tfor (int i = 0; i < lafCombo.getItemCount(); ++i) {\n\t\t\tif (((LookAndFeelInfo)lafCombo.getItemAt(i)).getClassName().equals(laf)) {\n\t\t\t\tlafCombo.setSelectedIndex(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfinal ListCellRenderer oldRenderer = lafCombo.getRenderer();\n\t\tlafCombo.setRenderer(new DefaultListCellRenderer(){\n\t\t\t@Override public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n\t\t\t\treturn oldRenderer.getListCellRendererComponent(list, ((LookAndFeelInfo)value).getName(), index, isSelected, cellHasFocus);\n\t\t\t}\n\t\t});\n\t\tlafCombo.addActionListener(gui.requireRestartAction);\n\n\t\tgui.display.add(new JLabel(tr(\"Look and Feel\")), GBC.std());\n\t\tgui.display.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n\t\tgui.display.add(lafCombo, GBC.eol().fill(GBC.HORIZONTAL));\n\t}","id":106281,"modified_method":"public void addGui(PreferenceDialog gui) {\n\t\tlafCombo = new JComboBox(UIManager.getInstalledLookAndFeels());\n\n\t\t// let's try to load additional LookAndFeels and put them into the list\n\t\ttry {\n\t\t\tClass<?> Cquaqua = Class.forName(\"ch.randelshofer.quaqua.QuaquaLookAndFeel\");\n\t\t\tObject Oquaqua = Cquaqua.getConstructor((Class[])null).newInstance((Object[])null);\n\t\t\t// no exception? Then Go!\n\t\t\tlafCombo.addItem(\n\t\t\t\tnew UIManager.LookAndFeelInfo(((javax.swing.LookAndFeel)Oquaqua).getName(), \"ch.randelshofer.quaqua.QuaquaLookAndFeel\")\n\t\t\t);\n\t\t} catch (Exception ex) {\n\t\t\t// just ignore, Quaqua may not even be installed...\n\t\t\t//System.out.println(\"Failed to load Quaqua: \" + ex);\n\t\t}\n\n\t\tString laf = Main.pref.get(\"laf\");\n\t\tfor (int i = 0; i < lafCombo.getItemCount(); ++i) {\n\t\t\tif (((LookAndFeelInfo)lafCombo.getItemAt(i)).getClassName().equals(laf)) {\n\t\t\t\tlafCombo.setSelectedIndex(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfinal ListCellRenderer oldRenderer = lafCombo.getRenderer();\n\t\tlafCombo.setRenderer(new DefaultListCellRenderer(){\n\t\t\t@Override public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n\t\t\t\treturn oldRenderer.getListCellRendererComponent(list, ((LookAndFeelInfo)value).getName(), index, isSelected, cellHasFocus);\n\t\t\t}\n\t\t});\n\t\tlafCombo.addActionListener(gui.requireRestartAction);\n\n\t\tpanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n\t\t// Show splash screen on startup\n\t\tshowSplashScreen.setToolTipText(tr(\"Show splash screen at startup\"));\n\t\tshowSplashScreen.setSelected(Main.pref.getBoolean(\"draw.splashscreen\", true));\n\t\tpanel.add(showSplashScreen, GBC.eop().insets(20, 0, 0, 0));\n\n\t\t// Show ID in selection\n\t\tshowID.setToolTipText(tr(\"Show object ID in selection lists\"));\n\t\tshowID.setSelected(Main.pref.getBoolean(\"osm-primitives.showid\", false));\n\t\tpanel.add(showID, GBC.eop().insets(20, 0, 0, 0));\n\n\t\tpanel.add(Box.createVerticalGlue(), GBC.eol().insets(0, 20, 0, 0));\n\n\t\tpanel.add(new JLabel(tr(\"Look and Feel\")), GBC.std().insets(20, 0, 0, 0));\n\t\tpanel.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n\t\tpanel.add(lafCombo, GBC.eol().fill(GBC.HORIZONTAL));\n\n\t\tJScrollPane scrollpane = new JScrollPane(panel);\n\t\tscrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n\t\tgui.displaycontent.addTab(tr(\"Look and Feel\"), scrollpane);\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(PreferenceDialog gui) {\n\t\tlangCombo = new JComboBox(I18n.getAvailableTranslations());\n\t\tlangCombo.insertItemAt(AUTO_LANGUAGE, 0); // Default\n\t\tlangCombo.insertItemAt(Locale.ENGLISH, 1); // Built-in language\n\t\tString ln = Main.pref.get(\"language\");\n\t\tlangCombo.setSelectedIndex(0);\n\t\t\n\t\tif (ln != null) {\n\t\t\tfor (int i = 1; i < langCombo.getItemCount(); ++i) {\n\t\t\t\tif (((Locale) langCombo.getItemAt(i)).toString().equals(ln)) {\n\t\t\t\t\tlangCombo.setSelectedIndex(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal ListCellRenderer oldRenderer = langCombo.getRenderer();\n\t\tlangCombo.setRenderer(new DefaultListCellRenderer() {\n\t\t\t@Override\n\t\t\tpublic Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,\n\t\t\t\t\tboolean cellHasFocus) {\n\t\t\t\tLocale l = (Locale) value;\n\t\t\t\treturn oldRenderer.getListCellRendererComponent(list,\n\t\t\t\t\t\tl == AUTO_LANGUAGE ? tr(\"Default (Auto determined)\") : l.getDisplayName(),\n\t\t\t\t\t\tindex, isSelected, cellHasFocus);\n\t\t\t}\n\t\t});\n\t\tlangCombo.addActionListener(gui.requireRestartAction);\n\n\t\tgui.display.add(new JLabel(tr(\"Language\")), GBC.std());\n\t\tgui.display.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n\t\tgui.display.add(langCombo, GBC.eol().fill(GBC.HORIZONTAL));\n\t}","id":106282,"modified_method":"public void addGui(PreferenceDialog gui) {\n\t\tlangCombo = new JComboBox(I18n.getAvailableTranslations());\n\t\tlangCombo.insertItemAt(AUTO_LANGUAGE, 0); // Default\n\t\tlangCombo.insertItemAt(Locale.ENGLISH, 1); // Built-in language\n\t\tString ln = Main.pref.get(\"language\");\n\t\tlangCombo.setSelectedIndex(0);\n\t\t\n\t\tif (ln != null) {\n\t\t\tfor (int i = 1; i < langCombo.getItemCount(); ++i) {\n\t\t\t\tif (((Locale) langCombo.getItemAt(i)).toString().equals(ln)) {\n\t\t\t\t\tlangCombo.setSelectedIndex(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal ListCellRenderer oldRenderer = langCombo.getRenderer();\n\t\tlangCombo.setRenderer(new DefaultListCellRenderer() {\n\t\t\t@Override\n\t\t\tpublic Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,\n\t\t\t\t\tboolean cellHasFocus) {\n\t\t\t\tLocale l = (Locale) value;\n\t\t\t\treturn oldRenderer.getListCellRendererComponent(list,\n\t\t\t\t\t\tl == AUTO_LANGUAGE ? tr(\"Default (Auto determined)\") : l.getDisplayName(),\n\t\t\t\t\t\tindex, isSelected, cellHasFocus);\n\t\t\t}\n\t\t});\n\t\tlangCombo.addActionListener(gui.requireRestartAction);\n\n\t\tJPanel panel = null;\n\t\tfor(PreferenceSetting s : gui.settings)\n\t\t{\n\t\t\tif(s instanceof LafPreference)\n\t\t\t\tpanel = ((LafPreference)s).panel;\n\t\t}\n\t\tpanel.add(new JLabel(tr(\"Language\")), GBC.std().insets(20, 0, 0, 0));\n\t\tpanel.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n\t\tpanel.add(langCombo, GBC.eol().fill(GBC.HORIZONTAL));\n\t\tpanel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * If the dialog is closed with Ok, the preferences will be stored to the preferences-\n\t * file, otherwise no change of the file happens.\n\t */\n\tpublic PreferenceDialog() {\n\t\tsuper(JTabbedPane.LEFT, JTabbedPane.SCROLL_TAB_LAYOUT);\n\t\tfor (Iterator<PreferenceSetting> it = settings.iterator(); it.hasNext();) {\n\t\t\ttry {\n\t            it.next().addGui(this);\n            } catch (SecurityException e) {\n            \tit.remove();\n            }\n\t\t}\n\t}","id":106283,"modified_method":"/**\n\t * If the dialog is closed with Ok, the preferences will be stored to the preferences-\n\t * file, otherwise no change of the file happens.\n\t */\n\tpublic PreferenceDialog() {\n\t\tsuper(JTabbedPane.LEFT, JTabbedPane.SCROLL_TAB_LAYOUT);\n\t\tdisplay.add(displaycontent, GBC.eol().fill(GBC.BOTH));\n\t\tfor (Iterator<PreferenceSetting> it = settings.iterator(); it.hasNext();) {\n\t\t\ttry {\n\t            it.next().addGui(this);\n            } catch (SecurityException e) {\n            \tit.remove();\n            }\n\t\t}\n\t}","commit_id":"9e80eb3afe32bdb2892c8794695c5bf4e66a6f04","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns the preset icon.\n     * @return The preset icon, or {@code null} if none defined\n     * @since 6403\n     */\n    public final ImageIcon getIcon() {\n        Object icon = getValue(Action.SMALL_ICON);\n        if (icon instanceof ImageIcon) {\n            return (ImageIcon) icon;\n        }\n        return null;\n    }","id":106284,"modified_method":"/**\n     * Returns the preset icon (16px).\n     * @return The preset icon, or {@code null} if none defined\n     * @since 6403\n     */\n    public final ImageIcon getIcon() {\n        return getIcon(Action.SMALL_ICON);\n    }","commit_id":"fca2875bc6c812006f5de5aa5df1cba2a68038c8","url":"https://github.com/openstreetmap/josm"},{"original_method":"PresetDialog(Component content, String title, ImageIcon icon, boolean disableApply, boolean showNewRelation) {\n            super(Main.parent, title,\n                    showNewRelation ?\n                            new String[] {tr(\"Apply Preset\"), tr(\"New relation\"), tr(\"Cancel\")} :\n                                new String[] {tr(\"Apply Preset\"), tr(\"Cancel\")},\n                                true);\n            if (icon != null)\n                setIconImage(icon.getImage());\n            contentInsets = new Insets(10, 5, 0, 5);\n            if (showNewRelation) {\n                setButtonIcons(new String[] {\"ok\", \"dialogs/addrelation\", \"cancel\" });\n            } else {\n                setButtonIcons(new String[] {\"ok\", \"cancel\" });\n            }\n            setContent(content);\n            setDefaultButton(1);\n            setupDialog();\n            buttons.get(0).setEnabled(!disableApply);\n            buttons.get(0).setToolTipText(title);\n            // Prevent dialogs of being too narrow (fix #6261)\n            Dimension d = getSize();\n            if (d.width < 350) {\n                d.width = 350;\n                setSize(d);\n            }\n            showDialog();\n        }","id":106285,"modified_method":"/**\n         * Constructs a new {@code PresetDialog}.\n         * @param content the content that will be displayed in this dialog\n         * @param title the text that will be shown in the window titlebar\n         * @param icon the image to be displayed as the icon for this window\n         * @param disableApply whether to disable \"Apply\" button\n         * @param showNewRelation whether to display \"New relation\" button\n         */\n        PresetDialog(Component content, String title, ImageIcon icon, boolean disableApply, boolean showNewRelation) {\n            super(Main.parent, title,\n                    showNewRelation ?\n                            (new String[] {tr(\"Apply Preset\"), tr(\"New relation\"), tr(\"Cancel\")}) :\n                            (new String[] {tr(\"Apply Preset\"), tr(\"Cancel\")}),\n                    true);\n            if (icon != null)\n                setIconImage(icon.getImage());\n            contentInsets = new Insets(10, 5, 0, 5);\n            if (showNewRelation) {\n                setButtonIcons(new String[] {\"ok\", \"dialogs/addrelation\", \"cancel\" });\n            } else {\n                setButtonIcons(new String[] {\"ok\", \"cancel\" });\n            }\n            setContent(content);\n            setDefaultButton(1);\n            setupDialog();\n            buttons.get(0).setEnabled(!disableApply);\n            buttons.get(0).setToolTipText(title);\n            // Prevent dialogs of being too narrow (fix #6261)\n            Dimension d = getSize();\n            if (d.width < 350) {\n                d.width = 350;\n                setSize(d);\n            }\n            super.showDialog();\n        }","commit_id":"fca2875bc6c812006f5de5aa5df1cba2a68038c8","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a panel for this preset. This includes general information such as name and supported {@link TaggingPresetType types}.\n     * This includes the elements from the individual {@link TaggingPresetItem items}.\n     *\n     * @param selected the selected primitives\n     * @return the newly created panel\n     */\n    public PresetPanel createPanel(Collection<OsmPrimitive> selected) {\n        PresetPanel p = new PresetPanel();\n        List<Link> l = new LinkedList<>();\n        List<PresetLink> presetLink = new LinkedList<>();\n\n        final JPanel pp = new JPanel();\n        if (types != null) {\n            for (TaggingPresetType t : types) {\n                JLabel la = new JLabel(ImageProvider.get(t.getIconName()));\n                la.setToolTipText(tr(\"Elements of type {0} are supported.\", tr(t.getName())));\n                pp.add(la);\n            }\n        }\n        final List<Tag> directlyAppliedTags = getDirectlyAppliedTags();\n        if (!directlyAppliedTags.isEmpty()) {\n            final JLabel label = new JLabel(ImageProvider.get(\"pastetags\"));\n            label.setToolTipText(\"<html>\" + tr(\"This preset also sets: {0}\", Utils.joinAsHtmlUnorderedList(directlyAppliedTags)));\n            pp.add(label);\n        }\n        if (pp.getComponentCount() > 0) {\n            p.add(pp, GBC.eol());\n        }\n        if (preset_name_label) {\n            Label.addLabel(p, getIcon(), getName());\n        }\n\n        boolean presetInitiallyMatches = !selected.isEmpty() && selected.stream().allMatch(this);\n        JPanel items = new JPanel(new GridBagLayout());\n        for (TaggingPresetItem i : data) {\n            if (i instanceof Link) {\n                l.add((Link) i);\n                p.hasElements = true;\n            } else if (i instanceof PresetLink) {\n                presetLink.add((PresetLink) i);\n            } else {\n                if (i.addToPanel(items, selected, presetInitiallyMatches)) {\n                    p.hasElements = true;\n                }\n            }\n        }\n        p.add(items, GBC.eol().fill());\n        if (selected.isEmpty() && !supportsRelation()) {\n            GuiHelper.setEnabledRec(items, false);\n        }\n\n        // add PresetLink\n        if (!presetLink.isEmpty()) {\n            p.add(new JLabel(tr(\"Edit also \u2026\")), GBC.eol().insets(0, 8, 0, 0));\n            for (PresetLink link : presetLink) {\n                link.addToPanel(p, selected, presetInitiallyMatches);\n            }\n        }\n\n        // add Link\n        for (Link link : l) {\n            link.addToPanel(p, selected, presetInitiallyMatches);\n        }\n\n        // \"Add toolbar button\"\n        JToggleButton tb = new JToggleButton(new ToolbarButtonAction());\n        tb.setFocusable(false);\n        p.add(tb, GBC.std(0, 0).anchor(GBC.LINE_END));\n        return p;\n    }","id":106286,"modified_method":"/**\n     * Creates a panel for this preset. This includes general information such as name and supported {@link TaggingPresetType types}.\n     * This includes the elements from the individual {@link TaggingPresetItem items}.\n     *\n     * @param selected the selected primitives\n     * @return the newly created panel\n     */\n    public PresetPanel createPanel(Collection<OsmPrimitive> selected) {\n        PresetPanel p = new PresetPanel();\n        List<Link> l = new LinkedList<>();\n        List<PresetLink> presetLink = new LinkedList<>();\n\n        final JPanel pp = new JPanel();\n        if (types != null) {\n            for (TaggingPresetType t : types) {\n                JLabel la = new JLabel(ImageProvider.get(t.getIconName()));\n                la.setToolTipText(tr(\"Elements of type {0} are supported.\", tr(t.getName())));\n                pp.add(la);\n            }\n        }\n        final List<Tag> directlyAppliedTags = getDirectlyAppliedTags();\n        if (!directlyAppliedTags.isEmpty()) {\n            final JLabel label = new JLabel(ImageProvider.get(\"pastetags\"));\n            label.setToolTipText(\"<html>\" + tr(\"This preset also sets: {0}\", Utils.joinAsHtmlUnorderedList(directlyAppliedTags)));\n            pp.add(label);\n        }\n        final int count = pp.getComponentCount();\n        if (preset_name_label) {\n            p.add(new JLabel(getIcon(Action.LARGE_ICON_KEY)), GBC.std(0, 0).span(1, count > 0 ? 2 : 1).insets(0, 0, 5, 0));\n        }\n        if (count > 0) {\n            p.add(pp, GBC.std(1, 0).span(GBC.REMAINDER));\n        }\n        if (preset_name_label) {\n            p.add(new JLabel(getName()), GBC.std(1, count > 0 ? 1 : 0).insets(5, 0, 0, 0).span(GBC.REMAINDER).fill(GBC.HORIZONTAL));\n        }\n\n        boolean presetInitiallyMatches = !selected.isEmpty() && selected.stream().allMatch(this);\n        JPanel items = new JPanel(new GridBagLayout());\n        for (TaggingPresetItem i : data) {\n            if (i instanceof Link) {\n                l.add((Link) i);\n                p.hasElements = true;\n            } else if (i instanceof PresetLink) {\n                presetLink.add((PresetLink) i);\n            } else {\n                if (i.addToPanel(items, selected, presetInitiallyMatches)) {\n                    p.hasElements = true;\n                }\n            }\n        }\n        p.add(items, GBC.eol().fill());\n        if (selected.isEmpty() && !supportsRelation()) {\n            GuiHelper.setEnabledRec(items, false);\n        }\n\n        // add PresetLink\n        if (!presetLink.isEmpty()) {\n            p.add(new JLabel(tr(\"Edit also \u2026\")), GBC.eol().insets(0, 8, 0, 0));\n            for (PresetLink link : presetLink) {\n                link.addToPanel(p, selected, presetInitiallyMatches);\n            }\n        }\n\n        // add Link\n        for (Link link : l) {\n            link.addToPanel(p, selected, presetInitiallyMatches);\n        }\n\n        // \"Add toolbar button\"\n        JToggleButton tb = new JToggleButton(new ToolbarButtonAction());\n        tb.setFocusable(false);\n        p.add(tb, GBC.std(1, 0).anchor(GBC.LINE_END));\n        return p;\n    }","commit_id":"fca2875bc6c812006f5de5aa5df1cba2a68038c8","url":"https://github.com/openstreetmap/josm"},{"original_method":"public int showDialog(Collection<OsmPrimitive> sel, boolean showNewRelation) {\n        PresetPanel p = createPanel(sel);\n        if (p == null)\n            return DIALOG_ANSWER_CANCEL;\n\n        int answer = 1;\n        boolean canCreateRelation = types == null || types.contains(TaggingPresetType.RELATION);\n        if (originalSelectionEmpty && !canCreateRelation) {\n            new Notification(\n                    tr(\"The preset <i>{0}<\/i> cannot be applied since nothing has been selected!\", getLocaleName()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return DIALOG_ANSWER_CANCEL;\n        } else if (sel.isEmpty() && !canCreateRelation) {\n            new Notification(\n                    tr(\"The preset <i>{0}<\/i> cannot be applied since the selection is unsuitable!\", getLocaleName()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return DIALOG_ANSWER_CANCEL;\n        } else if (p.getComponentCount() != 0 && (sel.isEmpty() || p.hasElements)) {\n            String title = trn(\"Change {0} object\", \"Change {0} objects\", sel.size(), sel.size());\n            if (sel.isEmpty()) {\n                if (originalSelectionEmpty) {\n                    title = tr(\"Nothing selected!\");\n                } else {\n                    title = tr(\"Selection unsuitable!\");\n                }\n            }\n\n            answer = new PresetDialog(p, title, preset_name_label ? null : (ImageIcon) getValue(Action.SMALL_ICON),\n                    sel.isEmpty(), showNewRelation).getValue();\n        }\n        if (!showNewRelation && answer == 2)\n            return DIALOG_ANSWER_CANCEL;\n        else\n            return answer;\n    }","id":106287,"modified_method":"/**\n     * Shows the preset dialog.\n     * @param sel selection\n     * @param showNewRelation whether to display \"New relation\" button\n     * @return the user choice after the dialog has been closed\n     */\n    public int showDialog(Collection<OsmPrimitive> sel, boolean showNewRelation) {\n        PresetPanel p = createPanel(sel);\n\n        int answer = 1;\n        boolean canCreateRelation = types == null || types.contains(TaggingPresetType.RELATION);\n        if (originalSelectionEmpty && !canCreateRelation) {\n            new Notification(\n                    tr(\"The preset <i>{0}<\/i> cannot be applied since nothing has been selected!\", getLocaleName()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return DIALOG_ANSWER_CANCEL;\n        } else if (sel.isEmpty() && !canCreateRelation) {\n            new Notification(\n                    tr(\"The preset <i>{0}<\/i> cannot be applied since the selection is unsuitable!\", getLocaleName()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return DIALOG_ANSWER_CANCEL;\n        } else if (p.getComponentCount() != 0 && (sel.isEmpty() || p.hasElements)) {\n            String title = trn(\"Change {0} object\", \"Change {0} objects\", sel.size(), sel.size());\n            if (sel.isEmpty()) {\n                if (originalSelectionEmpty) {\n                    title = tr(\"Nothing selected!\");\n                } else {\n                    title = tr(\"Selection unsuitable!\");\n                }\n            }\n\n            answer = new PresetDialog(p, title, preset_name_label ? null : (ImageIcon) getValue(Action.SMALL_ICON),\n                    sel.isEmpty(), showNewRelation).getValue();\n        }\n        if (!showNewRelation && answer == 2)\n            return DIALOG_ANSWER_CANCEL;\n        else\n            return answer;\n    }","commit_id":"fca2875bc6c812006f5de5aa5df1cba2a68038c8","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.I_CmsUpdateDBPart#getDbInstance(String, Map)\n     */\n    public I_CmsUpdateDBPart getDbInstance(String dbName, Map dbPoolData) {\n\n        m_poolData = new HashMap(dbPoolData);\n        if (dbName.indexOf(\"mysql\") > -1) {\n            String engine = \"MYISAM\";\n            CmsSetupDb setupDb = new CmsSetupDb(null);\n\n            try {\n                setupDb.setConnection(\n                    (String)m_poolData.get(\"driver\"),\n                    (String)m_poolData.get(\"url\"),\n                    (String)m_poolData.get(\"params\"),\n                    (String)m_poolData.get(\"user\"),\n                    (String)m_poolData.get(\"pwd\"));\n\n                ResultSet res = setupDb.executeSqlStatement(\"SHOW TABLE STATUS LIKE 'CMS_GROUPS';\", null);\n                if (res.next()) {\n                    engine = res.getString(\"Engine\").toUpperCase();\n                }\n                res.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            } finally {\n                setupDb.closeConnection();\n            }\n            m_poolData.put(\"engine\", engine);\n            System.out.println(\"Table engine:               \" + engine);\n\n            return getInstanceForDb(\"mysql\");\n        } else if (dbName.indexOf(\"oracle\") > -1) {\n\n            String dataTablespace = \"users\";\n            String indexTablespace = \"users\";\n            CmsSetupDb setupDb = new CmsSetupDb(null);\n\n            try {\n                setupDb.setConnection(\n                    (String)m_poolData.get(\"driver\"),\n                    (String)m_poolData.get(\"url\"),\n                    (String)m_poolData.get(\"params\"),\n                    (String)m_poolData.get(\"user\"),\n                    (String)m_poolData.get(\"pwd\"));\n\n                // read tablespace for data\n                ResultSet res = setupDb.executeSqlStatement(\"SELECT DISTINCT tablespace_name FROM user_tables\", null);\n                if (res.next()) {\n                    dataTablespace = res.getString(1).toLowerCase();\n                }\n                res.close();\n\n                // read tablespace for indexes\n                res = setupDb.executeSqlStatement(\"SELECT DISTINCT tablespace_name FROM user_indexes\", null);\n                if (res.next()) {\n                    indexTablespace = res.getString(1).toLowerCase();\n                }\n                res.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            } finally {\n                setupDb.closeConnection();\n            }\n\n            m_poolData.put(\"indexTablespace\", indexTablespace);\n            System.out.println(\"Index Tablespace:           \" + indexTablespace);\n\n            m_poolData.put(\"dataTablespace\", dataTablespace);\n            System.out.println(\"Data Tablespace:            \" + dataTablespace);\n\n            return getInstanceForDb(\"oracle\");\n        } else {\n            System.out.println(\"db \" + dbName + \" not supported\");\n            return null;\n        }\n    }","id":106288,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.I_CmsUpdateDBPart#getDbInstance(String, Map)\n     */\n    public I_CmsUpdateDBPart getDbInstance(String dbName, Map dbPoolData) {\n\n        m_poolData = new HashMap(dbPoolData);\n        if (dbName.indexOf(\"mysql\") > -1) {\n            String engine = \"MYISAM\";\n            CmsSetupDb setupDb = new CmsSetupDb(null);\n            CmsSetupDBWrapper db = null;\n            try {\n                setupDb.setConnection(\n                    (String)m_poolData.get(\"driver\"),\n                    (String)m_poolData.get(\"url\"),\n                    (String)m_poolData.get(\"params\"),\n                    (String)m_poolData.get(\"user\"),\n                    (String)m_poolData.get(\"pwd\"));\n\n                db = setupDb.executeSqlStatement(\"SHOW TABLE STATUS LIKE 'CMS_GROUPS';\", null);\n                if (db.getResultSet().next()) {\n                    engine = db.getResultSet().getString(\"Engine\").toUpperCase();\n                }\n\n            } catch (SQLException e) {\n                e.printStackTrace();\n            } finally {\n                if (db != null) {\n                    db.close();\n                }\n                setupDb.closeConnection();\n            }\n            m_poolData.put(\"engine\", engine);\n            System.out.println(\"Table engine:               \" + engine);\n\n            return getInstanceForDb(\"mysql\");\n        } else if (dbName.indexOf(\"oracle\") > -1) {\n\n            String dataTablespace = \"users\";\n            String indexTablespace = \"users\";\n            CmsSetupDb setupDb = new CmsSetupDb(null);\n\n            try {\n                setupDb.setConnection(\n                    (String)m_poolData.get(\"driver\"),\n                    (String)m_poolData.get(\"url\"),\n                    (String)m_poolData.get(\"params\"),\n                    (String)m_poolData.get(\"user\"),\n                    (String)m_poolData.get(\"pwd\"));\n\n                // read tablespace for data\n                CmsSetupDBWrapper db = null;\n                try {\n                    db = setupDb.executeSqlStatement(\"SELECT DISTINCT tablespace_name FROM user_tables\", null);\n                    if (db.getResultSet().next()) {\n                        dataTablespace = db.getResultSet().getString(1).toLowerCase();\n                    }\n                } finally {\n                    if (db != null) {\n                        db.close();\n                    }\n                }\n                // read tablespace for indexes\n                try {\n                    db = setupDb.executeSqlStatement(\"SELECT DISTINCT tablespace_name FROM user_indexes\", null);\n                    if (db.getResultSet().next()) {\n                        indexTablespace = db.getResultSet().getString(1).toLowerCase();\n                    }\n                } finally {\n                    if (db != null) {\n                        db.close();\n                    }\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            } finally {\n                setupDb.closeConnection();\n            }\n\n            m_poolData.put(\"indexTablespace\", indexTablespace);\n            System.out.println(\"Index Tablespace:           \" + indexTablespace);\n\n            m_poolData.put(\"dataTablespace\", dataTablespace);\n            System.out.println(\"Data Tablespace:            \" + dataTablespace);\n\n            return getInstanceForDb(\"oracle\");\n        } else {\n            System.out.println(\"db \" + dbName + \" not supported\");\n            return null;\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates and executes a database statment from a String returning the result set.<p>\n     * \n     * @param query the query to execute\n     * @param replacer the replacements to perform in the script\n     * \n     * @return the result set of the query \n     * \n     * @throws SQLException if something goes wrong\n     */\n    public ResultSet executeSqlStatement(String query, Map replacer) throws SQLException {\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n\n        stmt = m_con.createStatement();\n        String queryToExecute = query;\n\n        // Check if a map of replacements is given\n        if (replacer != null) {\n            queryToExecute = replaceTokens(query, replacer);\n        }\n\n        // do the query\n        resultSet = stmt.executeQuery(queryToExecute);\n\n        return resultSet;\n    }","id":106289,"modified_method":"/**\n     * Creates and executes a database statment from a String returning the result set.<p>\n     * \n     * @param query the query to execute\n     * @param replacer the replacements to perform in the script\n     * \n     * @return the result set of the query \n     * \n     * @throws SQLException if something goes wrong\n     */\n    public CmsSetupDBWrapper executeSqlStatement(String query, Map replacer) throws SQLException {\n\n        CmsSetupDBWrapper dbwrapper = new CmsSetupDBWrapper(m_con);\n        dbwrapper.createStatement();\n \n        String queryToExecute = query;\n\n        // Check if a map of replacements is given\n        if (replacer != null) {\n            queryToExecute = replaceTokens(query, replacer);\n        }\n        // do the query\n        dbwrapper.excecuteQuery(queryToExecute);\n\n        // return the result\n        return dbwrapper; \n        \n    \n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    public void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        // Update the CMS_OFFLINE_CONTENTS table\n        // drop column content_id\n        if (dbCon.hasTableOrColumn(TABLE_CMS_OFFLINE_CONTENTS, COLUMN_CMS_OFFLINE_CONTENTS_CONTENT_ID)) {\n            for (Iterator it = CMS_OFFLINE_CONTENTS_QUERIES_LIST.iterator(); it.hasNext();) {\n                String query = readQuery((String)it.next());\n                dbCon.updateSqlStatement(query, null, null);\n            }\n        } else {\n            System.out.println(\"no column \"\n                + COLUMN_CMS_OFFLINE_CONTENTS_CONTENT_ID\n                + \" in table \"\n                + TABLE_CMS_OFFLINE_CONTENTS);\n        }\n\n        // Update the CMS_ONLINE/OFFLINE_PROPERTYDEF tables\n        // Add the column PROPERTYDEF_TYPE\n        for (Iterator it = CMS_PROPERTYDEF_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            if (!dbCon.hasTableOrColumn(table, COLUMN_CMS_PROPERTYDEF_TYPE)) {\n                String query = readQuery(QUERY_PROPERTYDEF_TYPE);\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                dbCon.updateSqlStatement(query, replacer, null);\n                replacer.clear();\n            } else {\n                System.out.println(\"column \" + COLUMN_CMS_PROPERTYDEF_TYPE + \" in table \" + table + \" already exists\");\n            }\n        }\n\n        // Update the ONLINE/OFFLINE_STRUCTURE \n        // Add the STRUCTURE_VERSION\n        for (Iterator it = CMS_STRUCTURE_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            // Add the column if needed\n            if (!dbCon.hasTableOrColumn(table, COLUMN_CMS_STRUCTURE_STRUCTURE_VERSION)) {\n                String addColumn = readQuery(QUERY_CMS_STRUCTURE_ADD_STRUCTURE_VERSION);\n                // Add the column\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                dbCon.updateSqlStatement(addColumn, replacer, null);\n\n                // Update the entries of the newly created column\n                String structureVersion = readQuery(QUERY_SELECT_CMS_STRUCTURE_VERSION);\n                ResultSet set = dbCon.executeSqlStatement(structureVersion, replacer);\n                // update each row\n                while (set.next()) {\n                    String updateQuery = readQuery(QUERY_UPDATE_STRUCTURE_VERSION);\n                    String structureId = set.getString(\"STRUCTURE_ID\");\n                    int version = set.getInt(\"STRUCTURE_VERSION\");\n                    List params = new ArrayList();\n                    params.add(new Integer(version)); // add the version\n                    params.add(structureId);\n                    dbCon.updateSqlStatement(updateQuery, replacer, params);\n                }\n            } else {\n                System.out.println(\"column \"\n                    + COLUMN_CMS_STRUCTURE_STRUCTURE_VERSION\n                    + \" in table \"\n                    + table\n                    + \" already exists\");\n            }\n        } // end update structure_version\n\n        // Drop the TASK_ID column from CMS_PROJECTS\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, COLUMN_PROJECTS_TASK_ID)) {\n            String dropTaskId = readQuery(QUERY_CMS_PROJECTS_DROP_TASK_ID);\n            dbCon.updateSqlStatement(dropTaskId, null, null);\n        } else {\n            System.out.println(\"no column \" + COLUMN_PROJECTS_TASK_ID + \" in table \" + TABLE_CMS_PROJECTS);\n        }\n\n        // Change the size of the project names\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, COLUMN_PROJECTS_PROJECT_NAME)) {\n            String changeProjectName = readQuery(QUERY_CMS_PROJECTS_CHANGE_PROJECT_NAME);\n            dbCon.updateSqlStatement(changeProjectName, null, null);\n        } else {\n            System.out.println(\"no column \" + COLUMN_PROJECTS_PROJECT_NAME + \" in table \" + TABLE_CMS_PROJECTS);\n        }\n\n        // Update project flags for temporary projects\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, null)) {\n            String updateProjectFlags = readQuery(QUERY_CMS_PROJECTS_UPDATE_PROJECT_FLAGS);\n            dbCon.updateSqlStatement(updateProjectFlags, null, null);\n        } else {\n            System.out.println(\"table \" + TABLE_CMS_PROJECTS + \" does not exists\");\n        }\n\n        // Update CMS_GROUPS and add the system roles\n\n        // Update CMS_RESOURCES tables\n        for (Iterator it = CMS_RESOURCES_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            HashMap replacer = new HashMap();\n            replacer.put(REPLACEMENT_TABLENAME, table);\n            if (!dbCon.hasTableOrColumn(table, COLUMN_RESOURCES_DATE_CONTENT)) {\n                String addDateContent = readQuery(QUERY_UPDATE_RESOURCES_DATE_CONTENT);\n                // add the DATE_CONTENT column\n                dbCon.updateSqlStatement(addDateContent, replacer, null);\n            } else {\n                System.out.println(\"column \" + COLUMN_RESOURCES_DATE_CONTENT + \" in table \" + table + \" already exists\");\n            }\n\n            if (!dbCon.hasTableOrColumn(table, COLUMN_RESOURCES_RESOURCE_VERSION)) {\n                // add the RESOURCE_VERISION column\n                String addResourceVersion = readQuery(QUERY_UPDATE_RESOURCES_RESOURCE_VERSION);\n                dbCon.updateSqlStatement(addResourceVersion, replacer, null);\n            } else {\n                System.out.println(\"column \"\n                    + COLUMN_RESOURCES_RESOURCE_VERSION\n                    + \" in table \"\n                    + table\n                    + \" already exists\");\n            }\n        }\n    }","id":106290,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    public void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        // Update the CMS_OFFLINE_CONTENTS table\n        // drop column content_id\n        if (dbCon.hasTableOrColumn(TABLE_CMS_OFFLINE_CONTENTS, COLUMN_CMS_OFFLINE_CONTENTS_CONTENT_ID)) {\n            for (Iterator it = CMS_OFFLINE_CONTENTS_QUERIES_LIST.iterator(); it.hasNext();) {\n                String query = readQuery((String)it.next());\n                dbCon.updateSqlStatement(query, null, null);\n            }\n        } else {\n            System.out.println(\"no column \"\n                + COLUMN_CMS_OFFLINE_CONTENTS_CONTENT_ID\n                + \" in table \"\n                + TABLE_CMS_OFFLINE_CONTENTS);\n        }\n\n        // Update the CMS_ONLINE/OFFLINE_PROPERTYDEF tables\n        // Add the column PROPERTYDEF_TYPE\n        for (Iterator it = CMS_PROPERTYDEF_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            if (!dbCon.hasTableOrColumn(table, COLUMN_CMS_PROPERTYDEF_TYPE)) {\n                String query = readQuery(QUERY_PROPERTYDEF_TYPE);\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                dbCon.updateSqlStatement(query, replacer, null);\n                replacer.clear();\n            } else {\n                System.out.println(\"column \" + COLUMN_CMS_PROPERTYDEF_TYPE + \" in table \" + table + \" already exists\");\n            }\n        }\n\n        // Update the ONLINE/OFFLINE_STRUCTURE \n        // Add the STRUCTURE_VERSION\n        for (Iterator it = CMS_STRUCTURE_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            // Add the column if needed\n            if (!dbCon.hasTableOrColumn(table, COLUMN_CMS_STRUCTURE_STRUCTURE_VERSION)) {\n                String addColumn = readQuery(QUERY_CMS_STRUCTURE_ADD_STRUCTURE_VERSION);\n                // Add the column\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                dbCon.updateSqlStatement(addColumn, replacer, null);\n\n                // Update the entries of the newly created column\n                String structureVersion = readQuery(QUERY_SELECT_CMS_STRUCTURE_VERSION);\n                CmsSetupDBWrapper db = null;\n                try {\n                    db = dbCon.executeSqlStatement(structureVersion, replacer);\n                    // update each row\n                    while (db.getResultSet().next()) {\n                        String updateQuery = readQuery(QUERY_UPDATE_STRUCTURE_VERSION);\n                        String structureId = db.getResultSet().getString(\"STRUCTURE_ID\");\n                        int version = db.getResultSet().getInt(\"STRUCTURE_VERSION\");\n                        List params = new ArrayList();\n                        params.add(new Integer(version)); // add the version\n                        params.add(structureId);\n                        dbCon.updateSqlStatement(updateQuery, replacer, params);\n                    }\n                } finally {\n                    if (db != null) {\n                        db.close();\n                    }\n                }\n            } else {\n                System.out.println(\"column \"\n                    + COLUMN_CMS_STRUCTURE_STRUCTURE_VERSION\n                    + \" in table \"\n                    + table\n                    + \" already exists\");\n            }\n        } // end update structure_version\n\n        // Drop the TASK_ID column from CMS_PROJECTS\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, COLUMN_PROJECTS_TASK_ID)) {\n            String dropTaskId = readQuery(QUERY_CMS_PROJECTS_DROP_TASK_ID);\n            dbCon.updateSqlStatement(dropTaskId, null, null);\n        } else {\n            System.out.println(\"no column \" + COLUMN_PROJECTS_TASK_ID + \" in table \" + TABLE_CMS_PROJECTS);\n        }\n\n        // Change the size of the project names\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, COLUMN_PROJECTS_PROJECT_NAME)) {\n            String changeProjectName = readQuery(QUERY_CMS_PROJECTS_CHANGE_PROJECT_NAME);\n            dbCon.updateSqlStatement(changeProjectName, null, null);\n        } else {\n            System.out.println(\"no column \" + COLUMN_PROJECTS_PROJECT_NAME + \" in table \" + TABLE_CMS_PROJECTS);\n        }\n\n        // Update project flags for temporary projects\n        if (dbCon.hasTableOrColumn(TABLE_CMS_PROJECTS, null)) {\n            String updateProjectFlags = readQuery(QUERY_CMS_PROJECTS_UPDATE_PROJECT_FLAGS);\n            dbCon.updateSqlStatement(updateProjectFlags, null, null);\n        } else {\n            System.out.println(\"table \" + TABLE_CMS_PROJECTS + \" does not exists\");\n        }\n\n        // Update CMS_GROUPS and add the system roles\n\n        // Update CMS_RESOURCES tables\n        for (Iterator it = CMS_RESOURCES_LIST.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            HashMap replacer = new HashMap();\n            replacer.put(REPLACEMENT_TABLENAME, table);\n            if (!dbCon.hasTableOrColumn(table, COLUMN_RESOURCES_DATE_CONTENT)) {\n                String addDateContent = readQuery(QUERY_UPDATE_RESOURCES_DATE_CONTENT);\n                // add the DATE_CONTENT column\n                dbCon.updateSqlStatement(addDateContent, replacer, null);\n            } else {\n                System.out.println(\"column \" + COLUMN_RESOURCES_DATE_CONTENT + \" in table \" + table + \" already exists\");\n            }\n\n            if (!dbCon.hasTableOrColumn(table, COLUMN_RESOURCES_RESOURCE_VERSION)) {\n                // add the RESOURCE_VERISION column\n                String addResourceVersion = readQuery(QUERY_UPDATE_RESOURCES_RESOURCE_VERSION);\n                dbCon.updateSqlStatement(addResourceVersion, replacer, null);\n            } else {\n                System.out.println(\"column \"\n                    + COLUMN_RESOURCES_RESOURCE_VERSION\n                    + \" in table \"\n                    + table\n                    + \" already exists\");\n            }\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    public void internalExecute(CmsSetupDb dbCon) {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        try {\n            if (dbCon.hasTableOrColumn(CMS_USERS_TABLE, USER_TYPE)) {\n                CmsUUID id = createWebusersGroup(dbCon);\n                addWebusersToGroup(dbCon, id);\n            } else {\n                System.out.println(\"table \" + CHECK_CMS_USERDATA + \" already exists\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            // Check if the CMS_USERDATA table exists            \n            if (!checkUserDataTable(dbCon)) {\n                createUserDataTable(dbCon); // Could throw Exception during table creation\n\n                String query = readQuery(QUERY_SELECT_USER_DATA);\n                ResultSet set = dbCon.executeSqlStatement(query, null);\n                while (set.next()) {\n                    String userID = (String)set.getObject(RESULTSET_USER_ID);\n                    System.out.println(\"UserId: \" + userID);\n\n                    try {\n                        Blob blob = set.getBlob(RESULTSET_USER_INFO);\n\n                        ByteArrayInputStream bin = new ByteArrayInputStream(blob.getBytes(1, (int)blob.length()));\n                        ObjectInputStream oin = new ObjectInputStream(bin);\n\n                        Map infos = (Map)oin.readObject();\n\n                        if (infos == null) {\n                            infos = new HashMap();\n                        }\n\n                        // Add user address and user description of the current user\n                        String userAddress = (String)set.getObject(USER_ADDRESS);\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userAddress)) {\n                            infos.put(USER_ADDRESS, userAddress);\n                        }\n                        String userDescription = (String)set.getObject(USER_DESCRIPTION);\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userDescription)) {\n                            infos.put(USER_DESCRIPTION, userDescription);\n                        }\n\n                        // Write the user data to the table\n                        writeAdditionalUserInfo(dbCon, userID, infos);\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                // add the column USER_DATECREATED\n                addUserDateCreated(dbCon);\n\n                // remove the unnecessary columns from CMS_USERS\n                removeUnnecessaryColumns(dbCon);\n\n            } else {\n                System.out.println(\"table \" + CHECK_CMS_USERDATA + \" already exists\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }","id":106291,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    public void internalExecute(CmsSetupDb dbCon) {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        try {\n            if (dbCon.hasTableOrColumn(CMS_USERS_TABLE, USER_TYPE)) {\n                CmsUUID id = createWebusersGroup(dbCon);\n                addWebusersToGroup(dbCon, id);\n            } else {\n                System.out.println(\"table \" + CHECK_CMS_USERDATA + \" already exists\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            // Check if the CMS_USERDATA table exists            \n            if (!checkUserDataTable(dbCon)) {\n                createUserDataTable(dbCon); // Could throw Exception during table creation\n\n                String query = readQuery(QUERY_SELECT_USER_DATA);\n                CmsSetupDBWrapper db = null;\n                try {\n                    db = dbCon.executeSqlStatement(query, null);\n                    while (db.getResultSet().next()) {\n                        String userID = (String)db.getResultSet().getObject(RESULTSET_USER_ID);\n                        System.out.println(\"UserId: \" + userID);\n\n                        try {\n                            Blob blob = db.getResultSet().getBlob(RESULTSET_USER_INFO);\n\n                            ByteArrayInputStream bin = new ByteArrayInputStream(blob.getBytes(1, (int)blob.length()));\n                            ObjectInputStream oin = new ObjectInputStream(bin);\n\n                            Map infos = (Map)oin.readObject();\n\n                            if (infos == null) {\n                                infos = new HashMap();\n                            }\n\n                            // Add user address and user description of the current user\n                            String userAddress = (String)db.getResultSet().getObject(USER_ADDRESS);\n                            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userAddress)) {\n                                infos.put(USER_ADDRESS, userAddress);\n                            }\n                            String userDescription = (String)db.getResultSet().getObject(USER_DESCRIPTION);\n                            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userDescription)) {\n                                infos.put(USER_DESCRIPTION, userDescription);\n                            }\n\n                            // Write the user data to the table\n                            writeAdditionalUserInfo(dbCon, userID, infos);\n                        } catch (Throwable e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } finally {\n                    if (db != null) {\n                        db.close();\n                    }\n                }\n\n                // add the column USER_DATECREATED\n                addUserDateCreated(dbCon);\n\n                // remove the unnecessary columns from CMS_USERS\n                removeUnnecessaryColumns(dbCon);\n\n            } else {\n                System.out.println(\"table \" + CHECK_CMS_USERDATA + \" already exists\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        createContentsTable(dbCon);\n\n        // Transfer the online contents if the table exists\n        if (dbCon.hasTableOrColumn(TABLE_CMS_ONLINE_CONTENTS, null)) {\n            int pubTag = 1;\n            String query = readQuery(QUERY_READ_MAX_PUBTAG);\n            ResultSet res = dbCon.executeSqlStatement(query, null);\n            if (res.next()) {\n                pubTag = res.getInt(1);\n            }\n            res.close();\n            transferOnlineContents(dbCon, pubTag);\n        } else {\n            System.out.println(\"no table \" + TABLE_CMS_ONLINE_CONTENTS + \" found\");\n        }\n\n        if (isKeepHistory()) {\n            // Transfer the backup contents if the table exists\n            if (dbCon.hasTableOrColumn(TABLE_CMS_BACKUP_CONTENTS, null)) {\n                String query = readQuery(QUERY_TRANSFER_BACKUP_CONTENTS);\n                dbCon.updateSqlStatement(query, null, null);\n            } else {\n                System.out.println(\"no table \" + TABLE_CMS_BACKUP_CONTENTS + \" found\");\n            }\n        }\n\n        // Drop the tables CMS_BACKUP_CONTENTS and CMS_ONLINE_CONTENTS\n        cleanUpContentsTables(dbCon);\n    }","id":106292,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        createContentsTable(dbCon);\n\n        // Transfer the online contents if the table exists\n        if (dbCon.hasTableOrColumn(TABLE_CMS_ONLINE_CONTENTS, null)) {\n            int pubTag = 1;\n            String query = readQuery(QUERY_READ_MAX_PUBTAG);\n            CmsSetupDBWrapper db = null;\n            try {\n                db = dbCon.executeSqlStatement(query, null);\n                if (db.getResultSet().next()) {\n                    pubTag = db.getResultSet().getInt(1);\n                }\n            } finally {\n                if (db != null) {\n                    db.close();\n                }\n            }\n            transferOnlineContents(dbCon, pubTag);\n        } else {\n            System.out.println(\"no table \" + TABLE_CMS_ONLINE_CONTENTS + \" found\");\n        }\n\n        if (isKeepHistory()) {\n            // Transfer the backup contents if the table exists\n            if (dbCon.hasTableOrColumn(TABLE_CMS_BACKUP_CONTENTS, null)) {\n                String query = readQuery(QUERY_TRANSFER_BACKUP_CONTENTS);\n                dbCon.updateSqlStatement(query, null, null);\n            } else {\n                System.out.println(\"no table \" + TABLE_CMS_BACKUP_CONTENTS + \" found\");\n            }\n        }\n\n        // Drop the tables CMS_BACKUP_CONTENTS and CMS_ONLINE_CONTENTS\n        cleanUpContentsTables(dbCon);\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the list of the indexes that shall be dropped before adding the final new indexes.<p>\n     * \n     * @param dbCon the connection to the database\n     * @param tablename the table to drop the indexes from\n     * \n     * @return the list of indexes to drop\n     */\n    private List getIndexesToDrop(CmsSetupDb dbCon, String tablename) {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        try {\n            ResultSet set = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (set.next()) {\n                String index = set.getString(FIELD_INDEX);\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n            }\n            set.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        return indexes;\n    }","id":106293,"modified_method":"/**\n     * Returns the list of the indexes that shall be dropped before adding the final new indexes.<p>\n     * \n     * @param dbCon the connection to the database\n     * @param tablename the table to drop the indexes from\n     * \n     * @return the list of indexes to drop\n     */\n    private List getIndexesToDrop(CmsSetupDb dbCon, String tablename) {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (db.getResultSet().next()) {\n                String index = db.getResultSet().getString(FIELD_INDEX);\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n        return indexes;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the constraints for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of constraints\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getConstraintsTopDrop(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList constraints = new ArrayList();\n        String tableConstraints = readQuery(QUERY_SHOW_CONSTRAINTS);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(tableConstraints, replacer);\n        while (set.next()) {\n            String constraint = set.getString(FIELD_CONSTRAINT);\n            if (!constraints.contains(constraint)) {\n                constraints.add(constraint);\n            }\n\n        }\n        set.close();\n        return constraints;\n    }","id":106294,"modified_method":"/**\n     * Gets the constraints for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of constraints\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getConstraintsTopDrop(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList constraints = new ArrayList();\n        String tableConstraints = readQuery(QUERY_SHOW_CONSTRAINTS);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableConstraints, replacer);\n            while (db.getResultSet().next()) {\n                String constraint = db.getResultSet().getString(FIELD_CONSTRAINT);\n                if (!constraints.contains(constraint)) {\n                    constraints.add(constraint);\n                }\n\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        return constraints;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the string of the indexes that shall be dropped before adding the final new indexes.<p>\n     * \n     * @param dbCon the connection to the database\n     * @param tablename the table to drop the indexes from\n     * \n     * @return the string to drop the temporary indexes\n     */\n    private String getIndexesToDrop(CmsSetupDb dbCon, String tablename) {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        try {\n            ResultSet set = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (set.next()) {\n                String index = set.getString(FIELD_INDEX);\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n            }\n            set.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        StringBuffer dropIndex = new StringBuffer();\n        for (Iterator it = indexes.iterator(); it.hasNext();) {\n            String index = (String)it.next();\n            if (index.equals(PRIMARY_KEY)) {\n                dropIndex.append(\"DROP PRIMARY KEY, \");\n            } else {\n                dropIndex.append(\"DROP INDEX \");\n                dropIndex.append(index);\n                dropIndex.append(\", \");\n            }\n        }\n        return dropIndex.toString();\n    }","id":106295,"modified_method":"/**\n     * Returns the string of the indexes that shall be dropped before adding the final new indexes.<p>\n     * \n     * @param dbCon the connection to the database\n     * @param tablename the table to drop the indexes from\n     * \n     * @return the string to drop the temporary indexes\n     */\n    private String getIndexesToDrop(CmsSetupDb dbCon, String tablename) {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (db.getResultSet().next()) {\n                String index = db.getResultSet().getString(FIELD_INDEX);\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n        StringBuffer dropIndex = new StringBuffer();\n        for (Iterator it = indexes.iterator(); it.hasNext();) {\n            String index = (String)it.next();\n            if (index.equals(PRIMARY_KEY)) {\n                dropIndex.append(\"DROP PRIMARY KEY, \");\n            } else {\n                dropIndex.append(\"DROP INDEX \");\n                dropIndex.append(index);\n                dropIndex.append(\", \");\n            }\n        }\n        return dropIndex.toString();\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the indexes for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of indexes\n     * \n     * @throws SQLException if somehting goes wrong \n     */\n    private List getIndexes(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(tableIndex, replacer);\n        while (set.next()) {\n            String index = set.getString(FIELD_INDEX);\n\n            if (!indexes.contains(index)) {\n                indexes.add(index);\n            }\n\n        }\n        set.close();\n        return indexes;\n    }","id":106296,"modified_method":"/**\n     * Gets the indexes for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of indexes\n     * \n     * @throws SQLException if somehting goes wrong \n     */\n    private List getIndexes(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        List indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (db.getResultSet().next()) {\n                String index = db.getResultSet().getString(FIELD_INDEX);\n\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        return indexes;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the constraints for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of constraints\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getConstraints(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList constraints = new ArrayList();\n        String tableConstraints = readQuery(QUERY_SHOW_CONSTRAINTS);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(tableConstraints, replacer);\n        while (set.next()) {\n            String constraint = set.getString(FIELD_CONSTRAINT_ORACLE);\n            if (!constraints.contains(constraint)) {\n                constraints.add(constraint);\n            }\n\n        }\n        set.close();\n        return constraints;\n    }","id":106297,"modified_method":"/**\n     * Gets the constraints for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of constraints\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getConstraints(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList constraints = new ArrayList();\n        String tableConstraints = readQuery(QUERY_SHOW_CONSTRAINTS);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableConstraints, replacer);\n            while (db.getResultSet().next()) {\n                String constraint = db.getResultSet().getString(FIELD_CONSTRAINT_ORACLE);\n                if (!constraints.contains(constraint)) {\n                    constraints.add(constraint);\n                }\n\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n        return constraints;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the indexes for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of indexes\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getIndexes(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(tableIndex, replacer);\n        while (set.next()) {\n            String index = set.getString(FIELD_INDEX_ORACLE);\n            if (!indexes.contains(index)) {\n                indexes.add(index);\n            }\n\n        }\n        set.close();\n        return indexes;\n    }","id":106298,"modified_method":"/**\n     * Gets the indexes for a table.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to get the indexes from\n     * \n     * @return a list of indexes\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private List getIndexes(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        ArrayList indexes = new ArrayList();\n        String tableIndex = readQuery(QUERY_SHOW_INDEX);\n        HashMap replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(tableIndex, replacer);\n            while (db.getResultSet().next()) {\n                String index = db.getResultSet().getString(FIELD_INDEX_ORACLE);\n                if (!indexes.contains(index)) {\n                    indexes.add(index);\n                }\n\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        return indexes;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the CMS_HISTORY_PRINCIPALS already has data in it.<p>\n     * \n     * @param dbCon the db connection interface\n     * @return true if there is already data in the table, false if it is empty\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private boolean hasData(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = false;\n        String query = readQuery(QUERY_SELECT_COUNT_HISTORY_PRINCIPALS);\n        ResultSet set = dbCon.executeSqlStatement(query, null);\n        if (set.next()) {\n            if (set.getInt(\"COUNT\") > 0) {\n                result = true;\n            }\n        }\n\n        return result;\n    }","id":106299,"modified_method":"/**\n     * Checks if the CMS_HISTORY_PRINCIPALS already has data in it.<p>\n     * \n     * @param dbCon the db connection interface\n     * @return true if there is already data in the table, false if it is empty\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private boolean hasData(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = false;\n        String query = readQuery(QUERY_SELECT_COUNT_HISTORY_PRINCIPALS);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(query, null);\n            if (db.getResultSet().next()) {\n                if (db.getResultSet().getInt(\"COUNT\") > 0) {\n                    result = true;\n                }\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n        return result;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n\n        List elements = new ArrayList();\n        elements.add(\"CMS_HISTORY_PROPERTYDEF\");\n        if (isKeepHistory()) {\n            elements.add(\"CMS_HISTORY_PROJECTRESOURCES\");\n            elements.add(\"CMS_HISTORY_PROPERTIES\");\n            elements.add(\"CMS_HISTORY_RESOURCES\");\n            elements.add(\"CMS_HISTORY_STRUCTURE\");\n        }\n        for (Iterator it = elements.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            System.out.println(\"Updating table \" + table);\n            if (dbCon.hasTableOrColumn(table, null)) {\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                ResultSet set = dbCon.executeSqlStatement(readQuery(QUERY_SELECT_COUNT_HISTORY_TABLE), replacer);\n                boolean update = false;\n                if (set.next()) {\n                    if (set.getInt(\"COUNT\") <= 0) {\n                        update = true;\n                    }\n                }\n                set.close();\n                if (update) {\n                    String query = readQuery(table);\n                    dbCon.updateSqlStatement(query, null, null);\n                } else {\n                    System.out.println(\"table \" + table + \" already has data\");\n                }\n            } else {\n                System.out.println(\"table \" + table + \" does not exists\");\n            }\n        }\n    }","id":106300,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n\n        List elements = new ArrayList();\n        elements.add(\"CMS_HISTORY_PROPERTYDEF\");\n        if (isKeepHistory()) {\n            elements.add(\"CMS_HISTORY_PROJECTRESOURCES\");\n            elements.add(\"CMS_HISTORY_PROPERTIES\");\n            elements.add(\"CMS_HISTORY_RESOURCES\");\n            elements.add(\"CMS_HISTORY_STRUCTURE\");\n        }\n        for (Iterator it = elements.iterator(); it.hasNext();) {\n            String table = (String)it.next();\n            System.out.println(\"Updating table \" + table);\n            if (dbCon.hasTableOrColumn(table, null)) {\n                HashMap replacer = new HashMap();\n                replacer.put(REPLACEMENT_TABLENAME, table);\n                CmsSetupDBWrapper db = null;\n                boolean update = false;\n                try {\n                    db = dbCon.executeSqlStatement(readQuery(QUERY_SELECT_COUNT_HISTORY_TABLE), replacer);\n\n                    if (db.getResultSet().next()) {\n                        if (db.getResultSet().getInt(\"COUNT\") <= 0) {\n                            update = true;\n                        }\n                    }\n                } finally {\n                    if (db != null) {\n                        db.close();\n                    }\n                }\n                if (update) {\n                    String query = readQuery(table);\n                    dbCon.updateSqlStatement(query, null, null);\n                } else {\n                    System.out.println(\"table \" + table + \" already has data\");\n                }\n            } else {\n                System.out.println(\"table \" + table + \" does not exists\");\n            }\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.generic.CmsUpdateDBProjectId#needsUpdating(org.opencms.setup.CmsSetupDb, java.lang.String)\n     */\n    protected boolean needsUpdating(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = true;\n\n        String query = readQuery(QUERY_DESCRIBE_TABLE);\n        Map replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(query, replacer);\n\n        while (set.next()) {\n            String fieldname = set.getString(\"COLUMN_NAME\");\n            if (fieldname.equals(COLUMN_PROJECT_ID) || fieldname.equals(COLUMN_PROJECT_LASTMODIFIED)) {\n                try {\n                    String fieldtype = set.getString(\"DATA_TYPE\");\n                    // If the type is varchar then no update needs to be done.\n                    if (fieldtype.indexOf(\"VARCHAR\") > -1) {\n                        return false;\n                    }\n                } catch (SQLException e) {\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }","id":106301,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.generic.CmsUpdateDBProjectId#needsUpdating(org.opencms.setup.CmsSetupDb, java.lang.String)\n     */\n    protected boolean needsUpdating(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = true;\n\n        String query = readQuery(QUERY_DESCRIBE_TABLE);\n        Map replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(query, replacer);\n\n            while (db.getResultSet().next()) {\n                String fieldname = db.getResultSet().getString(\"COLUMN_NAME\");\n                if (fieldname.equals(COLUMN_PROJECT_ID) || fieldname.equals(COLUMN_PROJECT_LASTMODIFIED)) {\n                    try {\n                        String fieldtype = db.getResultSet().getString(\"DATA_TYPE\");\n                        // If the type is varchar then no update needs to be done.\n                        if (fieldtype.indexOf(\"VARCHAR\") > -1) {\n                            return false;\n                        }\n                    } catch (SQLException e) {\n                        result = true;\n                    }\n                }\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n        return result;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n\n        generateUUIDs(dbCon);\n\n        createHistProjectsTable(dbCon);\n\n        Map uuids = getUUIDs(dbCon); // Get the UUIDS\n\n        /*\n         * Add the temporary column for the new UUIDs and fill it with data\n         */\n        for (Iterator it = TABLES_LIST.iterator(); it.hasNext();) {\n            String tablename = (String)it.next();\n\n            if (needsUpdating(dbCon, tablename)) {\n                addUUIDColumnToTable(dbCon, tablename, TEMP_UUID_COLUMN);\n                boolean isInResourcesList = RESOURCES_TABLES_LIST.contains(tablename);\n                // Add the new uuids\n                Iterator entries = uuids.entrySet().iterator();\n                while (entries.hasNext()) {\n                    Map.Entry entry = (Map.Entry)entries.next();\n                    if (entry.getKey() != null && entry.getValue() != null) {\n                        if (isInResourcesList) {\n                            fillUUIDSColumn(\n                                dbCon,\n                                tablename,\n                                TEMP_UUID_COLUMN,\n                                (String)entry.getValue(),\n                                COLUMN_PROJECT_LASTMODIFIED,\n                                (String)entry.getKey());\n                        } else {\n                            fillUUIDSColumn(\n                                dbCon,\n                                tablename,\n                                TEMP_UUID_COLUMN,\n                                (String)entry.getValue(),\n                                COLUMN_PROJECT_ID,\n                                (String)entry.getKey());\n                        }\n                    }\n                }\n\n                /*\n                 * In this phase the primary keys or indexes are dropped and the old columns containing the \n                 * old project ids are dropped. After that the temporary columns are renamed and the new\n                 * indexes and primary keys are added.\n                 */\n                if (isInResourcesList) {\n                    // fix lost project ids\n                    Map replacer = Collections.singletonMap(\"${tablename}\", tablename);\n                    List params = Collections.singletonList(CmsUUID.getNullUUID().toString());\n                    String query = readQuery(QUERY_UPDATE_NULL_PROJECTID);\n                    dbCon.updateSqlStatement(query, replacer, params);\n\n                    // Drop the column PROJECT_LASTMODIFIED\n                    dropColumn(dbCon, tablename, COLUMN_PROJECT_LASTMODIFIED);\n                    // rename the column TEMP_PROJECT_UUID to PROJECT_LASTMODIFIED\n                    renameColumn(dbCon, tablename, COLUMN_TEMP_PROJECT_UUID, COLUMN_PROJECT_LASTMODIFIED);\n                } else {\n                    // drop the columns\n                    dropColumn(dbCon, tablename, COLUMN_PROJECT_ID);\n\n                    // rename the column TEMP_PROJECT_UUID to PROJECT_ID\n                    renameColumn(dbCon, tablename, COLUMN_TEMP_PROJECT_UUID, COLUMN_PROJECT_ID);\n\n                    // add the new primary key\n                    if (tablename.equals(\"CMS_PROJECTRESOURCES\")) {\n                        addPrimaryKey(dbCon, tablename, getColumnProjectIdResourcePath());\n                    }\n                    if (tablename.equals(\"CMS_PROJECTS\")) {\n                        addPrimaryKey(dbCon, tablename, COLUMN_PROJECT_ID);\n                    }\n                }\n            } else {\n                System.out.println(\"table \" + tablename + \" does not need to be updated\");\n            }\n        }\n\n        ResultSet set = dbCon.executeSqlStatement(readQuery(QUERY_SELECT_COUNT_HISTORY_TABLE), null);\n        boolean update = false;\n        if (set.next()) {\n            if (set.getInt(\"COUNT\") <= 0) {\n                update = true;\n            }\n        }\n        set.close();\n        if (update) {\n            System.out.println(\"table \" + HISTORY_PROJECTS_TABLE + \" has no content, create a dummy entry\");\n\n            CmsUUID userId = CmsUUID.getNullUUID();\n            set = dbCon.executeSqlStatement(readQuery(QUERY_READ_ADMIN_USER), null);\n            if (set.next()) {\n                userId = new CmsUUID(set.getString(1));\n            }\n            CmsUUID groupId = CmsUUID.getNullUUID();\n            set = dbCon.executeSqlStatement(readQuery(QUERY_READ_ADMIN_GROUP), null);\n            if (set.next()) {\n                groupId = new CmsUUID(set.getString(1));\n            }\n\n            // read publish tag\n            int pubTag = 1;\n            String query = readQuery(QUERY_READ_MAX_PUBTAG);\n            ResultSet res = dbCon.executeSqlStatement(query, null);\n            if (res.next()) {\n                pubTag = res.getInt(1);\n            }\n            res.close();\n\n            List params = new ArrayList();\n            params.add(new CmsUUID().toString());\n            params.add(\"updateWizardDummyProject\");\n            params.add(\"dummy project just for having an entry\");\n            params.add(new Integer(1));\n            params.add(userId.toString());\n            params.add(groupId.toString());\n            params.add(groupId.toString());\n            params.add(new Long(System.currentTimeMillis()));\n            params.add(new Integer(pubTag));\n            params.add(new Long(System.currentTimeMillis()));\n            params.add(userId.toString());\n            params.add(CmsOrganizationalUnit.SEPARATOR);\n\n            query = readQuery(QUERY_INSERT_CMS_HISTORY_TABLE);\n            dbCon.updateSqlStatement(query, null, params);\n        } else {\n            System.out.println(\"table \" + HISTORY_PROJECTS_TABLE + \" has content\");\n        }\n    }","id":106302,"modified_method":"/**\n     * @see org.opencms.setup.update6to7.A_CmsUpdateDBPart#internalExecute(org.opencms.setup.CmsSetupDb)\n     */\n    protected void internalExecute(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n\n        generateUUIDs(dbCon);\n\n        createHistProjectsTable(dbCon);\n\n        Map uuids = getUUIDs(dbCon); // Get the UUIDS\n\n        /*\n         * Add the temporary column for the new UUIDs and fill it with data\n         */\n        for (Iterator it = TABLES_LIST.iterator(); it.hasNext();) {\n            String tablename = (String)it.next();\n\n            if (needsUpdating(dbCon, tablename)) {\n                addUUIDColumnToTable(dbCon, tablename, TEMP_UUID_COLUMN);\n                boolean isInResourcesList = RESOURCES_TABLES_LIST.contains(tablename);\n                // Add the new uuids\n                Iterator entries = uuids.entrySet().iterator();\n                while (entries.hasNext()) {\n                    Map.Entry entry = (Map.Entry)entries.next();\n                    if (entry.getKey() != null && entry.getValue() != null) {\n                        if (isInResourcesList) {\n                            fillUUIDSColumn(\n                                dbCon,\n                                tablename,\n                                TEMP_UUID_COLUMN,\n                                (String)entry.getValue(),\n                                COLUMN_PROJECT_LASTMODIFIED,\n                                (String)entry.getKey());\n                        } else {\n                            fillUUIDSColumn(\n                                dbCon,\n                                tablename,\n                                TEMP_UUID_COLUMN,\n                                (String)entry.getValue(),\n                                COLUMN_PROJECT_ID,\n                                (String)entry.getKey());\n                        }\n                    }\n                }\n\n                /*\n                 * In this phase the primary keys or indexes are dropped and the old columns containing the \n                 * old project ids are dropped. After that the temporary columns are renamed and the new\n                 * indexes and primary keys are added.\n                 */\n                if (isInResourcesList) {\n                    // fix lost project ids\n                    Map replacer = Collections.singletonMap(\"${tablename}\", tablename);\n                    List params = Collections.singletonList(CmsUUID.getNullUUID().toString());\n                    String query = readQuery(QUERY_UPDATE_NULL_PROJECTID);\n                    dbCon.updateSqlStatement(query, replacer, params);\n\n                    // Drop the column PROJECT_LASTMODIFIED\n                    dropColumn(dbCon, tablename, COLUMN_PROJECT_LASTMODIFIED);\n                    // rename the column TEMP_PROJECT_UUID to PROJECT_LASTMODIFIED\n                    renameColumn(dbCon, tablename, COLUMN_TEMP_PROJECT_UUID, COLUMN_PROJECT_LASTMODIFIED);\n                } else {\n                    // drop the columns\n                    dropColumn(dbCon, tablename, COLUMN_PROJECT_ID);\n\n                    // rename the column TEMP_PROJECT_UUID to PROJECT_ID\n                    renameColumn(dbCon, tablename, COLUMN_TEMP_PROJECT_UUID, COLUMN_PROJECT_ID);\n\n                    // add the new primary key\n                    if (tablename.equals(\"CMS_PROJECTRESOURCES\")) {\n                        addPrimaryKey(dbCon, tablename, getColumnProjectIdResourcePath());\n                    }\n                    if (tablename.equals(\"CMS_PROJECTS\")) {\n                        addPrimaryKey(dbCon, tablename, COLUMN_PROJECT_ID);\n                    }\n                }\n            } else {\n                System.out.println(\"table \" + tablename + \" does not need to be updated\");\n            }\n        }\n\n        CmsSetupDBWrapper db = null;\n        boolean update = false;\n        try {\n            db = dbCon.executeSqlStatement(readQuery(QUERY_SELECT_COUNT_HISTORY_TABLE), null);\n\n            if (db.getResultSet().next()) {\n                if (db.getResultSet().getInt(\"COUNT\") <= 0) {\n                    update = true;\n                }\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        if (update) {\n            System.out.println(\"table \" + HISTORY_PROJECTS_TABLE + \" has no content, create a dummy entry\");\n\n            CmsUUID userId = CmsUUID.getNullUUID();\n            try {\n                db = dbCon.executeSqlStatement(readQuery(QUERY_READ_ADMIN_USER), null);\n                if (db.getResultSet().next()) {\n                    userId = new CmsUUID(db.getResultSet().getString(1));\n                }\n            } finally {\n                if (db != null) {\n                    db.close();\n                }\n            }\n            CmsUUID groupId = CmsUUID.getNullUUID();\n            try {\n                db = dbCon.executeSqlStatement(readQuery(QUERY_READ_ADMIN_GROUP), null);\n                if (db.getResultSet().next()) {\n                    groupId = new CmsUUID(db.getResultSet().getString(1));\n                }\n            } finally {\n                if (db != null) {\n                    db.close();\n                }\n            }\n            // read publish tag\n            int pubTag = 1;\n            String query = readQuery(QUERY_READ_MAX_PUBTAG);\n            try {\n                db = dbCon.executeSqlStatement(query, null);\n                if (db.getResultSet().next()) {\n                    pubTag = db.getResultSet().getInt(1);\n                }\n            } finally {\n                if (db != null) {\n                    db.close();\n                }\n            }\n\n            List params = new ArrayList();\n            params.add(new CmsUUID().toString());\n            params.add(\"updateWizardDummyProject\");\n            params.add(\"dummy project just for having an entry\");\n            params.add(new Integer(1));\n            params.add(userId.toString());\n            params.add(groupId.toString());\n            params.add(groupId.toString());\n            params.add(new Long(System.currentTimeMillis()));\n            params.add(new Integer(pubTag));\n            params.add(new Long(System.currentTimeMillis()));\n            params.add(userId.toString());\n            params.add(CmsOrganizationalUnit.SEPARATOR);\n\n            query = readQuery(QUERY_INSERT_CMS_HISTORY_TABLE);\n            dbCon.updateSqlStatement(query, null, params);\n        } else {\n            System.out.println(\"table \" + HISTORY_PROJECTS_TABLE + \" has content\");\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the given table needs an update of the uuids.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to check\n     * \n     * @return true if the project ids are not yet updated, false if nothing needs to be done\n     * \n     * @throws SQLException if something goes wrong \n     */\n    protected boolean needsUpdating(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = true;\n\n        String query = readQuery(QUERY_DESCRIBE_TABLE);\n        Map replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        ResultSet set = dbCon.executeSqlStatement(query, replacer);\n\n        while (set.next()) {\n            String fieldname = set.getString(\"Field\");\n            if (fieldname.equals(COLUMN_PROJECT_ID) || fieldname.equals(COLUMN_PROJECT_LASTMODIFIED)) {\n                try {\n                    String fieldtype = set.getString(\"Type\");\n                    // If the type is varchar then no update needs to be done.\n                    if (fieldtype.indexOf(\"varchar\") > 0) {\n                        return false;\n                    }\n                } catch (SQLException e) {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }","id":106303,"modified_method":"/**\n     * Checks if the given table needs an update of the uuids.<p>\n     * \n     * @param dbCon the db connection interface\n     * @param tablename the table to check\n     * \n     * @return true if the project ids are not yet updated, false if nothing needs to be done\n     * \n     * @throws SQLException if something goes wrong \n     */\n    protected boolean needsUpdating(CmsSetupDb dbCon, String tablename) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        boolean result = true;\n\n        String query = readQuery(QUERY_DESCRIBE_TABLE);\n        Map replacer = new HashMap();\n        replacer.put(REPLACEMENT_TABLENAME, tablename);\n        CmsSetupDBWrapper db = null;\n\n        try {\n            db = dbCon.executeSqlStatement(query, replacer);\n\n            while (db.getResultSet().next()) {\n                String fieldname = db.getResultSet().getString(\"Field\");\n                if (fieldname.equals(COLUMN_PROJECT_ID) || fieldname.equals(COLUMN_PROJECT_LASTMODIFIED)) {\n                    try {\n                        String fieldtype = db.getResultSet().getString(\"Type\");\n                        // If the type is varchar then no update needs to be done.\n                        if (fieldtype.indexOf(\"varchar\") > 0) {\n                            return false;\n                        }\n                    } catch (SQLException e) {\n                        result = true;\n                    }\n                }\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        return result;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Generates the new UUIDs for the project ids.<p>\n     * The new uuids are stored in the temporary table.<p>\n     * \n     * @param dbCon the db connection interface\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private void generateUUIDs(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        String query = readQuery(QUERY_GET_PROJECT_IDS);\n\n        ResultSet set = dbCon.executeSqlStatement(query, null);\n        ResultSetMetaData metaData = set.getMetaData();\n        // Check the type of the column if it is integer, then create the new uuids\n        int columnType = metaData.getColumnType(1);\n        if (checkColumnTypeProjectId(columnType)) {\n            if (!dbCon.hasTableOrColumn(TEMPORARY_TABLE_NAME, null)) {\n                createTempTable(dbCon);\n\n                String updateQuery = readQuery(QUERY_INSERT_UUIDS);\n                List params = new ArrayList();\n                // Get the project id and insert it with a new uuid into the temp table\n                boolean hasNullId = false;\n                while (set.next()) {\n                    int id = set.getInt(\"PROJECT_ID\");\n                    params.add(new Integer(id)); // Add the number\n                    CmsUUID uuid = new CmsUUID();\n\n                    // Check for 0 project id\n                    if (id == 0) {\n                        hasNullId = true;\n                        uuid = CmsUUID.getNullUUID();\n                    }\n                    // Check for the online project\n                    if (id == 1) {\n                        uuid = CmsProject.ONLINE_PROJECT_ID;\n                    }\n                    params.add(uuid.toString()); // Add the uuid\n\n                    // Insert the values to the temp table\n                    dbCon.updateSqlStatement(updateQuery, null, params);\n\n                    params.clear();\n                }\n\n                // If no project id with value 0 was found \n                if (!hasNullId) {\n                    params.add(new Integer(0));\n                    params.add(CmsUUID.getNullUUID().toString());\n                    dbCon.updateSqlStatement(updateQuery, null, params);\n                }\n            } else {\n                System.out.println(\"table \" + TEMPORARY_TABLE_NAME + \" already exists\");\n            }\n        }\n    }","id":106304,"modified_method":"/**\n     * Generates the new UUIDs for the project ids.<p>\n     * The new uuids are stored in the temporary table.<p>\n     * \n     * @param dbCon the db connection interface\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private void generateUUIDs(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        String query = readQuery(QUERY_GET_PROJECT_IDS);\n\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(query, null);\n            ResultSetMetaData metaData = db.getResultSet().getMetaData();\n            // Check the type of the column if it is integer, then create the new uuids\n            int columnType = metaData.getColumnType(1);\n            if (checkColumnTypeProjectId(columnType)) {\n                if (!dbCon.hasTableOrColumn(TEMPORARY_TABLE_NAME, null)) {\n                    createTempTable(dbCon);\n\n                    String updateQuery = readQuery(QUERY_INSERT_UUIDS);\n                    List params = new ArrayList();\n                    // Get the project id and insert it with a new uuid into the temp table\n                    boolean hasNullId = false;\n                    while (db.getResultSet().next()) {\n                        int id = db.getResultSet().getInt(\"PROJECT_ID\");\n                        params.add(new Integer(id)); // Add the number\n                        CmsUUID uuid = new CmsUUID();\n\n                        // Check for 0 project id\n                        if (id == 0) {\n                            hasNullId = true;\n                            uuid = CmsUUID.getNullUUID();\n                        }\n                        // Check for the online project\n                        if (id == 1) {\n                            uuid = CmsProject.ONLINE_PROJECT_ID;\n                        }\n                        params.add(uuid.toString()); // Add the uuid\n\n                        // Insert the values to the temp table\n                        dbCon.updateSqlStatement(updateQuery, null, params);\n\n                        params.clear();\n                    }\n\n                    // If no project id with value 0 was found \n                    if (!hasNullId) {\n                        params.add(new Integer(0));\n                        params.add(CmsUUID.getNullUUID().toString());\n                        dbCon.updateSqlStatement(updateQuery, null, params);\n                    }\n                } else {\n                    System.out.println(\"table \" + TEMPORARY_TABLE_NAME + \" already exists\");\n                }\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the UUIDs from the temporary table TEMP_CMS_UUIDS.<p>\n     *  \n     * @param dbCon the db connection interface\n     * \n     * @return a map with the old project ids and the new uuids\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private Map getUUIDs(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        Map result = new HashMap();\n\n        String query = readQuery(QUERY_GET_UUIDS);\n        ResultSet set = dbCon.executeSqlStatement(query, null);\n        while (set.next()) {\n            String key = Integer.toString(set.getInt(COLUMN_PROJECT_ID));\n            String value = set.getString(COLUMN_PROJECT_UUID);\n\n            result.put(key, value);\n        }\n        return result;\n    }","id":106305,"modified_method":"/**\n     * Gets the UUIDs from the temporary table TEMP_CMS_UUIDS.<p>\n     *  \n     * @param dbCon the db connection interface\n     * \n     * @return a map with the old project ids and the new uuids\n     * \n     * @throws SQLException if something goes wrong \n     */\n    private Map getUUIDs(CmsSetupDb dbCon) throws SQLException {\n\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        Map result = new HashMap();\n\n        String query = readQuery(QUERY_GET_UUIDS);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(query, null);\n            while (db.getResultSet().next()) {\n                String key = Integer.toString(db.getResultSet().getInt(COLUMN_PROJECT_ID));\n                String value = db.getResultSet().getString(COLUMN_PROJECT_UUID);\n\n                result.put(key, value);\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n        return result;\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Transfers the data from the CMS_BACKUP_PROJECTS to the CMS_HISTORY_PROJECTS table.<p>\n     * \n     * The datetime type for the column PROJECT_PUBLISHDATE is converted to the new long value.<p>\n     * \n     * @param dbCon the db connection interface\n     * \n     * @throws SQLException if something goes wrong\n     */\n    protected void transferDataToHistoryTable(CmsSetupDb dbCon) throws SQLException {\n\n        if (!isKeepHistory()) {\n            return;\n        }\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        // Get the data from the CMS_BACKUP table\n        String query = readQuery(QUERY_SELECT_DATA_FROM_BACKUP_PROJECTS);\n        ResultSet set = dbCon.executeSqlStatement(query, null);\n\n        String insertQuery = readQuery(QUERY_INSERT_CMS_HISTORY_TABLE);\n        while (set.next()) {\n            // Add the values to be inserted into the CMS_HISTORY_PROJECTS table\n            List params = new ArrayList();\n            params.add(set.getString(\"PROJECT_UUID\"));\n            params.add(set.getString(\"PROJECT_NAME\"));\n            params.add(set.getString(\"PROJECT_DESCRIPTION\"));\n            params.add(new Integer(set.getInt(\"PROJECT_TYPE\")));\n            params.add(set.getString(\"USER_ID\"));\n            params.add(set.getString(\"GROUP_ID\"));\n            params.add(set.getString(\"MANAGERGROUP_ID\"));\n            params.add(new Long(set.getLong(\"DATE_CREATED\")));\n            params.add(new Integer(set.getInt(\"PUBLISH_TAG\")));\n            Date date = set.getDate(\"PROJECT_PUBLISHDATE\");\n            params.add(new Long(date.getTime()));\n            params.add(set.getString(\"PROJECT_PUBLISHED_BY\"));\n            params.add(set.getString(\"PROJECT_OU\"));\n\n            dbCon.updateSqlStatement(insertQuery, null, params);\n        }\n    }","id":106306,"modified_method":"/**\n     * Transfers the data from the CMS_BACKUP_PROJECTS to the CMS_HISTORY_PROJECTS table.<p>\n     * \n     * The datetime type for the column PROJECT_PUBLISHDATE is converted to the new long value.<p>\n     * \n     * @param dbCon the db connection interface\n     * \n     * @throws SQLException if something goes wrong\n     */\n    protected void transferDataToHistoryTable(CmsSetupDb dbCon) throws SQLException {\n\n        if (!isKeepHistory()) {\n            return;\n        }\n        System.out.println(new Exception().getStackTrace()[0].toString());\n        // Get the data from the CMS_BACKUP table\n        String query = readQuery(QUERY_SELECT_DATA_FROM_BACKUP_PROJECTS);\n        CmsSetupDBWrapper db = null;\n        try {\n            db = dbCon.executeSqlStatement(query, null);\n\n            String insertQuery = readQuery(QUERY_INSERT_CMS_HISTORY_TABLE);\n            while (db.getResultSet().next()) {\n                // Add the values to be inserted into the CMS_HISTORY_PROJECTS table\n                List params = new ArrayList();\n                params.add(db.getResultSet().getString(\"PROJECT_UUID\"));\n                params.add(db.getResultSet().getString(\"PROJECT_NAME\"));\n                params.add(db.getResultSet().getString(\"PROJECT_DESCRIPTION\"));\n                params.add(new Integer(db.getResultSet().getInt(\"PROJECT_TYPE\")));\n                params.add(db.getResultSet().getString(\"USER_ID\"));\n                params.add(db.getResultSet().getString(\"GROUP_ID\"));\n                params.add(db.getResultSet().getString(\"MANAGERGROUP_ID\"));\n                params.add(new Long(db.getResultSet().getLong(\"DATE_CREATED\")));\n                params.add(new Integer(db.getResultSet().getInt(\"PUBLISH_TAG\")));\n                Date date = db.getResultSet().getDate(\"PROJECT_PUBLISHDATE\");\n                params.add(new Long(date.getTime()));\n                params.add(db.getResultSet().getString(\"PROJECT_PUBLISHED_BY\"));\n                params.add(db.getResultSet().getString(\"PROJECT_OU\"));\n\n                dbCon.updateSqlStatement(insertQuery, null, params);\n            }\n        } finally {\n            if (db != null) {\n                db.close();\n            }\n        }\n\n    }","commit_id":"22f7e50ce696bf69923c5cd652e8f46f076c0311","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void visitAll(DataSet data, Boolean virtual) {\n\n        //boolean profiler = Main.pref.getBoolean(\"mappaint.profiler\",false);\n        //profilerOmitDraw = Main.pref.getBoolean(\"mappaint.profiler.omitdraw\",false);\n\n        useStyleCache = Main.pref.getBoolean(\"mappaint.cache\",true);\n        fillAreas = Main.pref.getInteger(\"mappaint.fillareas\", 10000000);\n        fillAlpha = Math.min(255, Math.max(0, Integer.valueOf(Main.pref.getInteger(\"mappaint.fillalpha\", 50))));\n        showNames = Main.pref.getInteger(\"mappaint.shownames\", 10000000);\n        showIcons = Main.pref.getInteger(\"mappaint.showicons\", 10000000);\n        useStrokes = Main.pref.getInteger(\"mappaint.strokes\", 10000000);\n        LatLon ll1 = nc.getLatLon(0,0);\n        LatLon ll2 = nc.getLatLon(100,0);\n        dist = ll1.greatCircleDistance(ll2);\n\n        //long profilerStart = java.lang.System.currentTimeMillis();\n        //long profilerLast = profilerStart;\n        //int profilerN;\n        //if(profiler)\n        //    System.out.println(\"Mappaint Profiler (\" +\n        //        (useStyleCache ? \"cache=true, \" : \"cache=false, \") +\n        //        \"fillareas \" + fillAreas + \", \" +\n        //        \"fillalpha=\" + fillAlpha + \"%, \" +\n        //        \"dist=\" + (int)dist + \"m)\");\n\n        getSettings(virtual);\n        useRealWidth = Main.pref.getBoolean(\"mappaint.useRealWidth\",false);\n        zoomLevelDisplay = Main.pref.getBoolean(\"mappaint.zoomLevelDisplay\",false);\n        circum = Main.map.mapView.getScale()*100*Main.proj.scaleFactor()*40041455; /* circumference of the earth in meter */\n        styles = MapPaintStyles.getStyles().getStyleSet();\n        drawMultipolygon = Main.pref.getBoolean(\"mappaint.multipolygon\",true);\n        drawRestriction = Main.pref.getBoolean(\"mappaint.restriction\",true);\n        //restrictionDebug = Main.pref.getBoolean(\"mappaint.restriction.debug\",false);\n        leftHandTraffic = Main.pref.getBoolean(\"mappaint.lefthandtraffic\",false);\n        orderFont = new Font(Main.pref.get(\"mappaint.font\",\"Helvetica\"), Font.PLAIN, Main.pref.getInteger(\"mappaint.fontsize\", 8));\n        String currentLocale = Locale.getDefault().getLanguage();\n        regionalNameOrder = Main.pref.get(\"mappaint.nameOrder\", \"name:\"+currentLocale+\";name;int_name;ref;operator;brand\").split(\";\");\n        minEN = nc.getEastNorth(0,nc.getHeight()-1);\n        maxEN = nc.getEastNorth(nc.getWidth()-1,0);\n\n\n        selectedCall = false;\n        ++paintid;\n        viewid = nc.getViewID();\n\n        //profilerVisibleNodes = 0;\n        //profilerVisibleWays = 0;\n        //profilerVisibleAreas = 0;\n        //profilerSegments = 0;\n        //profilerVisibleSegments = 0;\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Prepare  : %5dms\\n\", (java.lang.System.currentTimeMillis()-profilerLast));\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        if (fillAreas > dist && styles != null && styles.hasAreas()) {\n            Collection<Way> noAreaWays = new LinkedList<Way>();\n\n            /*** RELATIONS ***/\n        //    profilerN = 0;\n            for (final Relation osm : data.relations)\n            {\n                if(!osm.deleted && !osm.incomplete && osm.mappaintVisibleCode != viewid)\n                {\n                    osm.visit(this);\n        //            profilerN++;\n                }\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Relations: %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            /*** AREAS ***/\n        //    profilerN = 0;\n            for (final Way osm : data.ways)\n            {\n                if (!osm.incomplete && !osm.deleted\n                && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n                {\n                    if(isPrimitiveArea(osm) && osm.mappaintDrawnAreaCode != paintid)\n                    {\n                        osm.visit(this);\n        //                profilerN++;\n                    } else\n                        noAreaWays.add(osm);\n                }\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Areas    : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleAreas);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            /*** WAYS ***/\n        //    profilerN = 0;\n            fillAreas = 0;\n            for (final OsmPrimitive osm : noAreaWays)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Ways     : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleWays);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n        }\n        else\n        {\n            /*** WAYS (filling disabled)  ***/\n        //    profilerN = 0;\n            for (final OsmPrimitive osm : data.ways)\n                if (!osm.incomplete && !osm.deleted && !osm.selected\n                && osm.mappaintVisibleCode != viewid )\n                {\n                    osm.visit(this);\n        //            profilerN++;\n                }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Ways     : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleWays);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n        }\n\n        /*** SELECTED  ***/\n        selectedCall = true;\n        //profilerN = 0;\n        for (final OsmPrimitive osm : data.getSelected()) {\n            if (!osm.incomplete && !osm.deleted && !(osm instanceof Node)\n            && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n        }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Selected : %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        /*** DISPLAY CACHED SEGMENTS (WAYS) NOW ***/\n        displaySegments();\n\n        /*** NODES ***/\n        //profilerN = 0;\n        for (final OsmPrimitive osm : data.nodes)\n            if (!osm.incomplete && !osm.deleted\n            && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Nodes    : %5dms, calls=%7d, visible=%d\\n\",\n        //        (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleNodes);\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        /*** VIRTUAL  ***/\n        if (virtualNodeSize != 0)\n        {\n        //    profilerN = 0;\n            currentColor = nodeColor;\n            for (final OsmPrimitive osm : data.ways)\n                if (!osm.incomplete && !osm.deleted\n                && osm.mappaintVisibleCode != viewid )\n                {\n                    /* TODO: move this into the SimplePaint code? */\n        //            if(!profilerOmitDraw)\n                        visitVirtual((Way)osm);\n        //            profilerN++;\n                }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Virtual  : %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            displaySegments(null);\n        }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Segments :          calls=%7d, visible=%d\\n\", profilerSegments, profilerVisibleSegments);\n        //    System.out.format(\"All      : %5dms\\n\", (profilerLast-profilerStart));\n        //}\n    }","id":106307,"modified_method":"public void visitAll(DataSet data, Boolean virtual) {\n\n        //boolean profiler = Main.pref.getBoolean(\"mappaint.profiler\",false);\n        //profilerOmitDraw = Main.pref.getBoolean(\"mappaint.profiler.omitdraw\",false);\n\n        useStyleCache = Main.pref.getBoolean(\"mappaint.cache\",true);\n        fillAreas = Main.pref.getInteger(\"mappaint.fillareas\", 10000000);\n        fillAlpha = Math.min(255, Math.max(0, Integer.valueOf(Main.pref.getInteger(\"mappaint.fillalpha\", 50))));\n        showNames = Main.pref.getInteger(\"mappaint.shownames\", 10000000);\n        showIcons = Main.pref.getInteger(\"mappaint.showicons\", 10000000);\n        useStrokes = Main.pref.getInteger(\"mappaint.strokes\", 10000000);\n        LatLon ll1 = nc.getLatLon(0,0);\n        LatLon ll2 = nc.getLatLon(100,0);\n        dist = ll1.greatCircleDistance(ll2);\n\n        //long profilerStart = java.lang.System.currentTimeMillis();\n        //long profilerLast = profilerStart;\n        //int profilerN;\n        //if(profiler)\n        //    System.out.println(\"Mappaint Profiler (\" +\n        //        (useStyleCache ? \"cache=true, \" : \"cache=false, \") +\n        //        \"fillareas \" + fillAreas + \", \" +\n        //        \"fillalpha=\" + fillAlpha + \"%, \" +\n        //        \"dist=\" + (int)dist + \"m)\");\n\n        getSettings(virtual);\n        useRealWidth = Main.pref.getBoolean(\"mappaint.useRealWidth\",false);\n        zoomLevelDisplay = Main.pref.getBoolean(\"mappaint.zoomLevelDisplay\",false);\n        circum = Main.map.mapView.getScale()*100*Main.proj.scaleFactor()*40041455; /* circumference of the earth in meter */\n        styles = MapPaintStyles.getStyles().getStyleSet();\n        drawMultipolygon = Main.pref.getBoolean(\"mappaint.multipolygon\",true);\n        drawRestriction = Main.pref.getBoolean(\"mappaint.restriction\",true);\n        //restrictionDebug = Main.pref.getBoolean(\"mappaint.restriction.debug\",false);\n        leftHandTraffic = Main.pref.getBoolean(\"mappaint.lefthandtraffic\",false);\n        orderFont = new Font(Main.pref.get(\"mappaint.font\",\"Helvetica\"), Font.PLAIN, Main.pref.getInteger(\"mappaint.fontsize\", 8));\n        String[] names = {\"name:\"+Main.getLanguageCode(), \"name\", \"int_name\", \"ref\", \"operator\", \"brand\"};\n        regionalNameOrder = Main.pref.getCollection(\"mappaint.nameOrder\", Arrays.asList(names));\n        minEN = nc.getEastNorth(0,nc.getHeight()-1);\n        maxEN = nc.getEastNorth(nc.getWidth()-1,0);\n\n\n        selectedCall = false;\n        ++paintid;\n        viewid = nc.getViewID();\n\n        //profilerVisibleNodes = 0;\n        //profilerVisibleWays = 0;\n        //profilerVisibleAreas = 0;\n        //profilerSegments = 0;\n        //profilerVisibleSegments = 0;\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Prepare  : %5dms\\n\", (java.lang.System.currentTimeMillis()-profilerLast));\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        if (fillAreas > dist && styles != null && styles.hasAreas()) {\n            Collection<Way> noAreaWays = new LinkedList<Way>();\n\n            /*** RELATIONS ***/\n        //    profilerN = 0;\n            for (final Relation osm : data.relations)\n            {\n                if(!osm.deleted && !osm.incomplete && osm.mappaintVisibleCode != viewid)\n                {\n                    osm.visit(this);\n        //            profilerN++;\n                }\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Relations: %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            /*** AREAS ***/\n        //    profilerN = 0;\n            for (final Way osm : data.ways)\n            {\n                if (!osm.incomplete && !osm.deleted\n                && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n                {\n                    if(isPrimitiveArea(osm) && osm.mappaintDrawnAreaCode != paintid)\n                    {\n                        osm.visit(this);\n        //                profilerN++;\n                    } else\n                        noAreaWays.add(osm);\n                }\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Areas    : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleAreas);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            /*** WAYS ***/\n        //    profilerN = 0;\n            fillAreas = 0;\n            for (final OsmPrimitive osm : noAreaWays)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Ways     : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleWays);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n        }\n        else\n        {\n            /*** WAYS (filling disabled)  ***/\n        //    profilerN = 0;\n            for (final OsmPrimitive osm : data.ways)\n                if (!osm.incomplete && !osm.deleted && !osm.selected\n                && osm.mappaintVisibleCode != viewid )\n                {\n                    osm.visit(this);\n        //            profilerN++;\n                }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Ways     : %5dms, calls=%7d, visible=%d\\n\",\n        //            (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleWays);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n        }\n\n        /*** SELECTED  ***/\n        selectedCall = true;\n        //profilerN = 0;\n        for (final OsmPrimitive osm : data.getSelected()) {\n            if (!osm.incomplete && !osm.deleted && !(osm instanceof Node)\n            && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n        }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Selected : %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        /*** DISPLAY CACHED SEGMENTS (WAYS) NOW ***/\n        displaySegments();\n\n        /*** NODES ***/\n        //profilerN = 0;\n        for (final OsmPrimitive osm : data.nodes)\n            if (!osm.incomplete && !osm.deleted\n            && osm.mappaintVisibleCode != viewid && osm.mappaintDrawnCode != paintid)\n            {\n                osm.visit(this);\n        //        profilerN++;\n            }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Nodes    : %5dms, calls=%7d, visible=%d\\n\",\n        //        (java.lang.System.currentTimeMillis()-profilerLast), profilerN, profilerVisibleNodes);\n        //    profilerLast = java.lang.System.currentTimeMillis();\n        //}\n\n        /*** VIRTUAL  ***/\n        if (virtualNodeSize != 0)\n        {\n        //    profilerN = 0;\n            currentColor = nodeColor;\n            for (final OsmPrimitive osm : data.ways)\n                if (!osm.incomplete && !osm.deleted\n                && osm.mappaintVisibleCode != viewid )\n                {\n                    /* TODO: move this into the SimplePaint code? */\n        //            if(!profilerOmitDraw)\n                        visitVirtual((Way)osm);\n        //            profilerN++;\n                }\n\n        //    if(profiler)\n        //    {\n        //        System.out.format(\"Virtual  : %5dms, calls=%7d\\n\", (java.lang.System.currentTimeMillis()-profilerLast), profilerN);\n        //        profilerLast = java.lang.System.currentTimeMillis();\n        //    }\n\n            displaySegments(null);\n        }\n\n        //if(profiler)\n        //{\n        //    System.out.format(\"Segments :          calls=%7d, visible=%d\\n\", profilerSegments, profilerVisibleSegments);\n        //    System.out.format(\"All      : %5dms\\n\", (profilerLast-profilerStart));\n        //}\n    }","commit_id":"261bfef0559f808d5200a33a887a41f507215d90","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected String getNodeName(Node n) {\n        String name = null;\n        if (n.keys != null) {\n            for (int i = 0; i < regionalNameOrder.length; i++) {\n                name = n.keys.get(regionalNameOrder[i]);\n                if (name != null) break;\n            }\n        }\n        return name;\n    }","id":106308,"modified_method":"protected String getNodeName(Node n) {\n        String name = null;\n        if (n.keys != null) {\n            for (String rn : regionalNameOrder) {\n                name = n.keys.get(rn);\n                if (name != null) break;\n            }\n        }\n        return name;\n    }","commit_id":"261bfef0559f808d5200a33a887a41f507215d90","url":"https://github.com/openstreetmap/josm"},{"original_method":"synchronized public Collection<String> getCollection(String key, Collection<String> def) {\n        String s = get(key);\n        if(s != null && s.length() != 0)\n           return Arrays.asList(s.split(\";\"));\n        return def;\n    }","id":106309,"modified_method":"synchronized public Collection<String> getCollection(String key, Collection<String> def) {\n        String s = get(key);\n        if(def != null)\n        {\n            String d = null;\n            for(String a : def)\n            {\n                if(d != null)\n                    d += \";\" + a;\n                else\n                    d = a;\n            }\n            putDefault(key, d);\n        }\n        if(s != null && s.length() != 0)\n           return Arrays.asList(s.split(\";\"));\n        return def;\n    }","commit_id":"261bfef0559f808d5200a33a887a41f507215d90","url":"https://github.com/openstreetmap/josm"},{"original_method":"public String getName() {\n        String name;\n        if (incomplete) {\n            name = tr(\"incomplete\");\n        } else {\n            name = get(\"type\");\n            if (name == null)\n                name = tr(\"relation\");\n\n            name += \" (\";\n            String nameTag = get(\"name\");\n            if (nameTag == null) nameTag = get(\"ref\");\n            if (nameTag == null) nameTag = get(\"note\");\n            if (nameTag != null) name += \"\\\"\" + nameTag + \"\\\", \";\n            int mbno = members.size();\n            name += trn(\"{0} member\", \"{0} members\", mbno, mbno) + \")\";\n            if(errors != null)\n                name = \"*\"+name;\n        }\n        return name;\n    }","id":106310,"modified_method":"public String getName() {\n        String name;\n        if (incomplete) {\n            name = tr(\"incomplete\");\n        } else {\n            name = get(\"type\");\n            if (name == null)\n                name = tr(\"relation\");\n\n            name += \" (\";\n            if(names == null)\n              names = Main.pref.getCollection(\"relation.nameOrder\", Arrays.asList(defnames));\n            String nameTag = null;\n            for (String n : names) {\n                nameTag = get(n);\n                if (nameTag != null) break;\n            }\n            if (nameTag != null)\n                name += \"\\\"\" + nameTag + \"\\\", \";\n\n            int mbno = members.size();\n            name += trn(\"{0} member\", \"{0} members\", mbno, mbno) + \")\";\n            if(errors != null)\n                name = \"*\"+name;\n        }\n        return name;\n    }","commit_id":"261bfef0559f808d5200a33a887a41f507215d90","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Updates the \"hasDirectionKeys\" flag. \"keys\" property should probably be made private\n     * to make sure this gets called when keys are set.\n     */\n    public void checkDirectionTagged() {\n        hasDirectionKeys = false;\n        if(directionKeys == null)\n            directionKeys = new HashSet<String>(Arrays.asList(Main.pref.get(\"tags.direction\",\n            \"oneway;incline;incline_steep;aerialway\").split(\";\")));\n        if (keys != null) {\n            for (Entry<String,String> e : keys.entrySet()) {\n                if (directionKeys.contains(e.getKey())) {\n                    hasDirectionKeys = true;\n                    break;\n                }\n            }\n        }\n    }","id":106311,"modified_method":"/**\n     * Updates the \"hasDirectionKeys\" flag. \"keys\" property should probably be made private\n     * to make sure this gets called when keys are set.\n     */\n    public void checkDirectionTagged() {\n        hasDirectionKeys = false;\n        if(directionKeys == null)\n            directionKeys = Main.pref.getCollection(\"tags.direction\",\n            Arrays.asList(new String[]{\"oneway\",\"incline\",\"incline_steep\",\"aerialway\"}));\n        if (keys != null) {\n            for (Entry<String,String> e : keys.entrySet()) {\n                if (directionKeys.contains(e.getKey())) {\n                    hasDirectionKeys = true;\n                    break;\n                }\n            }\n        }\n    }","commit_id":"699281c596e9f95f4cb4580f4c9853a624cb0da1","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Updates the \"tagged\" flag. \"keys\" property should probably be made private\n     * to make sure this gets called when keys are set.\n     */\n    public void checkTagged() {\n        tagged = false;\n        if(uninteresting == null)\n            uninteresting = new HashSet<String>(Arrays.asList(Main.pref.get(\"tags.uninteresting\",\n            \"source;note;converted_by;created_by\").split(\";\")));\n        if (keys != null) {\n            for (Entry<String,String> e : keys.entrySet()) {\n                if (!uninteresting.contains(e.getKey())) {\n                    tagged = true;\n                    break;\n                }\n            }\n        }\n    }","id":106312,"modified_method":"/**\n     * Updates the \"tagged\" flag. \"keys\" property should probably be made private\n     * to make sure this gets called when keys are set.\n     */\n    public void checkTagged() {\n        tagged = false;\n        if(uninteresting == null)\n            uninteresting = Main.pref.getCollection(\"tags.uninteresting\",\n            Arrays.asList(new String[]{\"source\",\"note\",\"converted_by\",\"created_by\"}));\n        if (keys != null) {\n            for (Entry<String,String> e : keys.entrySet()) {\n                if (!uninteresting.contains(e.getKey())) {\n                    tagged = true;\n                    break;\n                }\n            }\n        }\n    }","commit_id":"699281c596e9f95f4cb4580f4c9853a624cb0da1","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Whether both {@link JvmTypeReference}s point to the same rawtyp or the second points to a type parameter where\n\t * the its upperBound is the same or a supertype of the first argument's raw type.\n\t */\n\tprotected boolean isSameTypeOrAssignableToUpperBound(JvmTypeReference first, JvmTypeReference second) {\n\t\tif (second == null)\n\t\t\treturn false;\n\t\tif (second.getType() == first.getType()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (second.getType() instanceof JvmTypeParameter) {\n\t\t\tboolean upperBoundSeen = false;\n\t\t\tfor (JvmTypeConstraint constraint : ((JvmTypeParameter) second.getType()).getConstraints()) {\n\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\tupperBoundSeen = true;\n\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(first, constraint.getTypeReference()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!upperBoundSeen) {\n\t\t\t\tif (typeReferences.is(first, Object.class)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":106313,"modified_method":"/**\n\t * Returns <code>true<\/code> if the the first reference points to the same rawtype as the second\n\t * reference's erasure. In other words, the method returns <code>true<\/code> for the following cases:\n\t * <pre>\n\t * isSameTypeOrAssignableToUpperBound(String, String)\n\t * isSameTypeOrAssignableToUpperBound(String, T extends String)\n\t * <\/pre>\n\t * and <code>false<\/code> for\n\t * <pre>\n\t * isSameTypeOrAssignableToUpperBound(CharSequence, String)\n\t * isSameTypeOrAssignableToUpperBound(Object, String)\n\t * <\/pre>\n\t * \n\t */\n\tprotected boolean isSameTypeOrAssignableToUpperBound(JvmTypeReference first, JvmTypeReference second) {\n\t\tif (second == null)\n\t\t\treturn false;\n\t\tif (second.getType() == first.getType()) { // TODO: use #getRawType, handle multi types\n\t\t\treturn true;\n\t\t}\n\t\tif (second.getType() instanceof JvmTypeParameter) {\n\t\t\tboolean upperBoundSeen = false;\n\t\t\tfor (JvmTypeConstraint constraint : ((JvmTypeParameter) second.getType()).getConstraints()) {\n\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\tupperBoundSeen = true;\n\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(first, constraint.getTypeReference()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!upperBoundSeen) {\n\t\t\t\tif (typeReferences.is(first, Object.class)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tSet<JvmFeature> result = Sets.newLinkedHashSet();\n\t\tif (declarator != null) {\n\t\t\tcollectFeatures(name, hierarchy, result);\t\n\t\t} else {\n\t\t\tcollectFeatures(name, null, result);\n\t\t}\n\t\treturn result;\n\t}","id":106314,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tSet<JvmFeature> result = Sets.newLinkedHashSet();\n\t\tif (declarator != null) {\n\t\t\tcollectFeatures(name, hierarchy, result);\t\n\t\t} else {\n\t\t\tcollectFeatures(name, null, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":106315,"modified_method":"protected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = name != null ? ((JvmDeclaredType) rawType).findAllFeaturesByName(name) : ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public final Iterable<JvmFeature> getAllFeatures(JvmTypeReference declarator, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tSet<JvmFeature> result = Sets.newLinkedHashSet();\n\t\tif (declarator != null) {\n\t\t\tcollectFeatures(hierarchy, result);\t\n\t\t} else {\n\t\t\tcollectFeatures(null, result);\n\t\t}\n\t\treturn result;\n\t}","id":106316,"modified_method":"public final Iterable<JvmFeature> getAllFeatures(JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tSet<JvmFeature> result = Sets.newLinkedHashSet();\n\t\tif (declarator != null) {\n\t\t\tcollectFeatures(null, hierarchy, result);\t\n\t\t} else {\n\t\t\tcollectFeatures(null, null, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tSet<JvmFeature> result = Sets.newLinkedHashSet();\n\t\tfor(JvmTypeReference reference: hierarchy) { \n\t\t\tJvmType rawType = typeReferences.getRawType(reference);\n\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\tIterables.addAll(result, ((JvmDeclaredType) rawType).getAllFeatures());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106317,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\treturn doGetFeaturesByName(null, declarator, hierarchy);\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tList<JvmFeature> result = Lists.newArrayList();\n\t\tfor(JvmTypeReference reference: hierarchy) { \n\t\t\tJvmType rawType = typeReferences.getRawType(reference);\n\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\tIterables.addAll(result, ((JvmDeclaredType) rawType).findAllFeaturesByName(name));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106318,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\treturn doGetFeaturesByName(name, declarator, hierarchy);\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public final Iterable<IEObjectDescription> getDescriptionsByName(\n\t\t\tString name, IFeaturesForTypeProvider featureProvider, \n\t\t\tJvmTypeReference typeReference,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tfinal Map<String, IEObjectDescription> descriptions = Maps.newLinkedHashMap();\n\t\tIAcceptor<JvmFeatureDescription> acceptor = new ShadowingAwareAcceptor(descriptions);\n\t\tdoCollectDescriptions(name, featureProvider, typeReference, context, hierarchy, acceptor);\n\t\treturn descriptions.values();\n\t}","id":106319,"modified_method":"public Iterable<IEObjectDescription> getDescriptionsByName(\n\t\t\tString name, IFeaturesForTypeProvider featureProvider, \n\t\t\tJvmTypeReference typeReference,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tfinal Map<String, IEObjectDescription> descriptions = Maps.newLinkedHashMap();\n\t\tIAcceptor<JvmFeatureDescription> acceptor = new ShadowingAwareAcceptor(descriptions);\n\t\tdoCollectDescriptions(name, featureProvider, typeReference, context, hierarchy, acceptor);\n\t\treturn descriptions.values();\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public final Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\treturn featuresForTypeProvider.getFeaturesByName(name, declarator, context, hierarchy);\n\t}","id":106320,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(\n\t\t\tString name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\treturn featuresForTypeProvider.getFeaturesByName(name, declarator, hierarchy);\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\treturn featuresForTypeProvider.getAllFeatures(typeReference, context, hierarchy);\n\t}","id":106321,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference, \n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\treturn featuresForTypeProvider.getAllFeatures(typeReference, hierarchy);\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public final Iterable<IEObjectDescription> getAllDescriptions(IFeaturesForTypeProvider featureProvider,\n\t\t\tJvmTypeReference typeReference, TypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tfinal Map<String, IEObjectDescription> descriptions = Maps.newLinkedHashMap();\n\t\tIAcceptor<JvmFeatureDescription> acceptor = new ShadowingAwareAcceptor(descriptions);\n\t\tdoCollectDescriptions(featureProvider, typeReference, context, hierarchy, acceptor);\n\t\treturn descriptions.values();\n\t}","id":106322,"modified_method":"public Iterable<IEObjectDescription> getAllDescriptions(IFeaturesForTypeProvider featureProvider,\n\t\t\tJvmTypeReference typeReference, TypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tfinal Map<String, IEObjectDescription> descriptions = Maps.newLinkedHashMap();\n\t\tIAcceptor<JvmFeatureDescription> acceptor = new ShadowingAwareAcceptor(descriptions);\n\t\tdoCollectDescriptions(featureProvider, typeReference, context, hierarchy, acceptor);\n\t\treturn descriptions.values();\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doCollectDescriptions(IFeaturesForTypeProvider featureProvider, JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy, IAcceptor<JvmFeatureDescription> acceptor) {\n\t\tIterable<JvmFeature> features = featureProvider.getAllFeatures(typeReference, context, hierarchy);\n\t\tfor (JvmFeature jvmFeature : features) {\n\t\t\taddFeatureDescriptions(jvmFeature, context, acceptor);\n\t\t}\n\t}","id":106323,"modified_method":"protected void doCollectDescriptions(IFeaturesForTypeProvider featureProvider, JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy, IAcceptor<JvmFeatureDescription> acceptor) {\n\t\tIterable<JvmFeature> features = featureProvider.getAllFeatures(typeReference, hierarchy);\n\t\tfor (JvmFeature jvmFeature : features) {\n\t\t\taddFeatureDescriptions(jvmFeature, context, acceptor);\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doCollectDescriptions(String name, IFeaturesForTypeProvider featureProvider, JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy, IAcceptor<JvmFeatureDescription> acceptor) {\n\t\tIterable<JvmFeature> features = featureProvider.getFeaturesByName(name, typeReference, context, hierarchy);\n\t\tfor (JvmFeature jvmFeature : features) {\n\t\t\taddFeatureDescriptions(jvmFeature, context, acceptor);\n\t\t}\n\t}","id":106324,"modified_method":"protected void doCollectDescriptions(String name, IFeaturesForTypeProvider featureProvider, JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy, IAcceptor<JvmFeatureDescription> acceptor) {\n\t\tIterable<JvmFeature> features = featureProvider.getFeaturesByName(name, typeReference, hierarchy);\n\t\tfor (JvmFeature jvmFeature : features) {\n\t\t\taddFeatureDescriptions(jvmFeature, context, acceptor);\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tfor(JvmTypeReference reference: hierarchy) {\n\t\t\t\tfor(JvmFeature candidate: candidates) {\n\t\t\t\t\tif (candidate instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) candidate;\n\t\t\t\t\t\tList<JvmFormalParameter> parameters = operation.getParameters();\n\t\t\t\t\t\tif (!operation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\t\tJvmTypeReference parameterType = parameters.get(0).getParameterType();\n\t\t\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(reference, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106325,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tcollectExtensionMethods(hierarchy, candidates, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = Lists.newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tfor(JvmTypeReference reference: hierarchy) {\n\t\t\t\tfor(JvmFeature candidate: candidates) {\n\t\t\t\t\tif (candidate instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) candidate;\n\t\t\t\t\t\tList<JvmFormalParameter> parameters = operation.getParameters();\n\t\t\t\t\t\tif (!operation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\t\tJvmTypeReference parameterType = parameters.get(0).getParameterType();\n\t\t\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(reference, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106326,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = Lists.newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tcollectExtensionMethods(hierarchy, candidates, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference reference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\tfinal JvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\t\tList<JvmFormalParameter> parameters = jvmOperation.getParameters();\n\t\t\t\t\tif (!jvmOperation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\tJvmFormalParameter parameter = parameters.get(0);\n\t\t\t\t\t\tJvmTypeReference parameterType = parameter.getParameterType();\n\t\t\t\t\t\tfor(JvmTypeReference superType: hierarchy) {\n\t\t\t\t\t\t\tif (parameter.getParameterType() != null && isCompatibleType(superType, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106327,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference reference,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tList<JvmFeature> result = newArrayList();\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tcollectExtensions(hierarchy, features, result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\tfinal JvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\t\tList<JvmFormalParameter> parameters = jvmOperation.getParameters();\n\t\t\t\t\tif (!jvmOperation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\tJvmFormalParameter parameter = parameters.get(0);\n\t\t\t\t\t\tJvmTypeReference parameterType = parameter.getParameterType();\n\t\t\t\t\t\tfor(JvmTypeReference superType: hierarchy) {\n\t\t\t\t\t\t\tif (parameter.getParameterType() != null && isCompatibleType(superType, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106328,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tList<JvmFeature> result = newArrayList();\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tcollectExtensions(hierarchy, features, result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\t// optimization - we know that the list is the same for all types\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t// optimization is here\n\t\t\t\t\t\t\t\tif (e.getKey() == null) {\n\t\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor(JvmTypeReference key: hierarchy) {\n\t\t\t\t\t\t\t\t\t\t// and here\n\t\t\t\t\t\t\t\t\t\tif (isMatchingExtension(key, (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","id":106329,"modified_method":"@Override\n\tprotected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\t// optimization - we know that the list is the same for all types\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = name != null ? ((JvmDeclaredType) rawType).findAllFeaturesByName(name) : ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t// optimization is here\n\t\t\t\t\t\t\t\tif (e.getKey() == null) {\n\t\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor(JvmTypeReference key: hierarchy) {\n\t\t\t\t\t\t\t\t\t\t// and here\n\t\t\t\t\t\t\t\t\t\tif (isMatchingExtension(key, (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmType getRawType(JvmTypeReference reference) {\n\t\tif (reference instanceof JvmParameterizedTypeReference) {\n\t\t\tJvmType rawType = reference.getType();\n\t\t\tif (rawType instanceof JvmTypeParameter) {\n\t\t\t\t// TODO handle multiple upper bounds\n\t\t\t\t// TODO use object if only lower bounds were present (robustness)\n\t\t\t\tList<JvmTypeConstraint> constraints = ((JvmTypeParameter) rawType).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint constraint : constraints) {\n\t\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\t\tJvmTypeReference upperBound = constraint.getTypeReference();\n\t\t\t\t\t\treturn getRawType(upperBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rawType;\n\t\t} else if (reference instanceof JvmGenericArrayTypeReference) {\n\t\t\tJvmArrayType type = ((JvmGenericArrayTypeReference) reference).getType();\n\t\t\tJvmTypeReference componentType = type.getComponentType();\n\t\t\tJvmComponentType rawComponentType = (JvmComponentType) getRawType(componentType);\n\t\t\treturn rawComponentType.getArrayType();\n\t\t} else if (reference instanceof JvmWildcardTypeReference) {\n\t\t\tList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) reference).getConstraints();\n\t\t\t// TODO handle multiple upper bounds\n\t\t\t// TODO use object if only lower bounds were present (robustness)\n\t\t\tfor (JvmTypeConstraint constraint : constraints) {\n\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\tJvmTypeReference upperBound = constraint.getTypeReference();\n\t\t\t\t\treturn getRawType(upperBound);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}","id":106330,"modified_method":"public JvmType getRawType(JvmTypeReference reference) {\n\t\tif (reference instanceof JvmParameterizedTypeReference) {\n\t\t\tJvmType rawType = reference.getType();\n\t\t\tif (rawType instanceof JvmTypeParameter) {\n\t\t\t\t// TODO handle multiple upper bounds\n\t\t\t\t// TODO use object if only lower bounds were present (robustness)\n\t\t\t\tList<JvmTypeConstraint> constraints = ((JvmTypeParameter) rawType).getConstraints();\n\t\t\t\tfor (JvmTypeConstraint constraint : constraints) {\n\t\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\t\tJvmTypeReference upperBound = constraint.getTypeReference();\n\t\t\t\t\t\treturn getRawType(upperBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// no upper bound found\n\t\t\t\treturn findDeclaredType(Object.class, rawType);\n\t\t\t}\n\t\t\treturn rawType;\n\t\t} else if (reference instanceof JvmGenericArrayTypeReference) {\n\t\t\tJvmArrayType type = ((JvmGenericArrayTypeReference) reference).getType();\n\t\t\tJvmTypeReference componentType = type.getComponentType();\n\t\t\tJvmComponentType rawComponentType = (JvmComponentType) getRawType(componentType);\n\t\t\treturn rawComponentType.getArrayType();\n\t\t} else if (reference instanceof JvmWildcardTypeReference) {\n\t\t\tList<JvmTypeConstraint> constraints = ((JvmWildcardTypeReference) reference).getConstraints();\n\t\t\t// TODO handle multiple upper bounds\n\t\t\t// TODO use object if only lower bounds were present (robustness)\n\t\t\tfor (JvmTypeConstraint constraint : constraints) {\n\t\t\t\tif (constraint instanceof JvmUpperBound) {\n\t\t\t\t\tJvmTypeReference upperBound = constraint.getTypeReference();\n\t\t\t\t\treturn getRawType(upperBound);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"dd858b8ac6c31abbd0c1a8b4caa1f0b7570c9c61","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = Lists.newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tfor(JvmTypeReference reference: hierarchy) {\n\t\t\t\tfor(JvmFeature candidate: candidates) {\n\t\t\t\t\tif (candidate instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) candidate;\n\t\t\t\t\t\tList<JvmFormalParameter> parameters = operation.getParameters();\n\t\t\t\t\t\tif (!operation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\t\tJvmTypeReference parameterType = parameters.get(0).getParameterType();\n\t\t\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(reference, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106331,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = Lists.newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tcollectExtensionMethods(hierarchy, candidates, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5bc43b6183e11e2bf2b5b577390deabb417150e8","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tfor(JvmTypeReference reference: hierarchy) {\n\t\t\t\tfor(JvmFeature candidate: candidates) {\n\t\t\t\t\tif (candidate instanceof JvmOperation) {\n\t\t\t\t\t\tJvmOperation operation = (JvmOperation) candidate;\n\t\t\t\t\t\tList<JvmFormalParameter> parameters = operation.getParameters();\n\t\t\t\t\t\tif (!operation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\t\tJvmTypeReference parameterType = parameters.get(0).getParameterType();\n\t\t\t\t\t\t\tif (isSameTypeOrAssignableToUpperBound(reference, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(operation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106332,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference typeReference,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tif(extensionProvidingType == null)\n\t\t\treturn emptyList();\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmType rawType = getTypeReferences().getRawType(extensionProvidingType);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> candidates = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tcollectExtensionMethods(hierarchy, candidates, result);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5bc43b6183e11e2bf2b5b577390deabb417150e8","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference reference, TypeArgumentContext context,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\tfinal JvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\t\tList<JvmFormalParameter> parameters = jvmOperation.getParameters();\n\t\t\t\t\tif (!jvmOperation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\tJvmFormalParameter parameter = parameters.get(0);\n\t\t\t\t\t\tJvmTypeReference parameterType = parameter.getParameterType();\n\t\t\t\t\t\tfor(JvmTypeReference superType: hierarchy) {\n\t\t\t\t\t\t\tif (parameter.getParameterType() != null && isCompatibleType(superType, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106333,"modified_method":"public Iterable<JvmFeature> getAllFeatures(JvmTypeReference reference,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tList<JvmFeature> result = newArrayList();\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\tcollectExtensions(hierarchy, features, result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"5bc43b6183e11e2bf2b5b577390deabb417150e8","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tTypeArgumentContext context, Iterable<JvmTypeReference> hierarchy) {\n\t\tList<JvmFeature> result = newArrayList();\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\tfinal JvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\t\tList<JvmFormalParameter> parameters = jvmOperation.getParameters();\n\t\t\t\t\tif (!jvmOperation.isStatic() && parameters.size()>0) {\n\t\t\t\t\t\tJvmFormalParameter parameter = parameters.get(0);\n\t\t\t\t\t\tJvmTypeReference parameterType = parameter.getParameterType();\n\t\t\t\t\t\tfor(JvmTypeReference superType: hierarchy) {\n\t\t\t\t\t\t\tif (parameter.getParameterType() != null && isCompatibleType(superType, parameterType)) {\n\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":106334,"modified_method":"public Iterable<JvmFeature> getFeaturesByName(String name, JvmTypeReference declarator,\n\t\t\tIterable<JvmTypeReference> hierarchy) {\n\t\tJvmTypeReference typeReference = xtendField.getType();\n\t\tJvmType rawType = typeRefs.getRawType(typeReference);\n\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\tList<JvmFeature> result = newArrayList();\n\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\tcollectExtensions(hierarchy, features, result);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"5bc43b6183e11e2bf2b5b577390deabb417150e8","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\t// optimization - we know that the list is the same for all types\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = ((JvmDeclaredType) rawType).findAllFeaturesByName(name);\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t// optimization is here\n\t\t\t\t\t\t\t\tif (e.getKey() == null) {\n\t\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor(JvmTypeReference key: hierarchy) {\n\t\t\t\t\t\t\t\t\t\t// and here\n\t\t\t\t\t\t\t\t\t\tif (isMatchingExtension(key, (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","id":106335,"modified_method":"@Override\n\tprotected void collectFeatures(String name, Iterable<JvmTypeReference> hierarchy, Collection<JvmFeature> result) {\n\t\tfinal Map<JvmTypeReference, Collection<String>> staticTypeNames = getVisibleTypesContainingStaticMethods(hierarchy);\n\t\tfor (final Map.Entry<JvmTypeReference, Collection<String>> e : staticTypeNames.entrySet()) {\n\t\t\t// optimization - we know that the list is the same for all types\n\t\t\tfor(final String staticTypeName: e.getValue()) {\n\t\t\t\tJvmTypeReference staticType = cache.get(Tuples.create(this, staticTypeName), context, new Provider<JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference get() {\n\t\t\t\t\t\treturn getTypeReferences().getTypeForName(staticTypeName, context);\n\t\t\t\t\t}\n\t\t\t\t}) ;\n\t\t\t\tif (staticType != null) {\n\t\t\t\t\tJvmType rawType = getTypeReferences().getRawType(staticType);\n\t\t\t\t\tif (rawType instanceof JvmDeclaredType) {\n\t\t\t\t\t\tIterable<JvmFeature> features = name != null ? ((JvmDeclaredType) rawType).findAllFeaturesByName(name) : ((JvmDeclaredType) rawType).getAllFeatures();\n\t\t\t\t\t\tfor(JvmFeature feature: features) {\n\t\t\t\t\t\t\tif (feature instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t// optimization is here\n\t\t\t\t\t\t\t\tif (e.getKey() == null) {\n\t\t\t\t\t\t\t\t\tif (isMatchingExtension(e.getKey(), (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor(JvmTypeReference key: hierarchy) {\n\t\t\t\t\t\t\t\t\t\t// and here\n\t\t\t\t\t\t\t\t\t\tif (isMatchingExtension(key, (JvmOperation) feature)) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(feature);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"5bc43b6183e11e2bf2b5b577390deabb417150e8","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     *\n     * Configuration precedence is in this order:\n     *\n     * <ol>\n     *   <li>value from config<\/li>\n     *   <li>system property<\/li>\n     *   <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure(Config config) {\n        Properties props = loadSystemProperties();\n        try {\n            String firstDelayAsString = (String) config.getParams().get(FIRST_DELAY_CONFIG_KEY);\n            if (firstDelayAsString == null) {\n                firstDelayAsString = (String)props.getProperty(FIRST_DELAY_CONFIG_KEY, \"600000\");\n            }\n            firstDelay = Integer.parseInt(firstDelayAsString);\n        } catch (Exception e) {\n           ;\n        }\n        try {\n            String intervalAsString = (String) config.getParams().get(INTERVAL_CONFIG_KEY);\n            if (intervalAsString == null) {\n                intervalAsString = (String)props.getProperty(INTERVAL_CONFIG_KEY, \"86400000\");\n            }\n            interval = Integer.parseInt(intervalAsString);\n        } catch (Exception e) {\n            ;\n        }\n        try {\n            String possibleHost = (String)config.getParams().get(UDC_HOST_ADDRESS_KEY);\n            if (null != possibleHost) hostAddress = possibleHost;\n        } catch (Exception e) {\n            ;\n        }\n\n        String disabledAsString = (String)config.getParams().get(UDC_DISABLE_KEY);\n        if (disabledAsString == null) {\n            disabledAsString = props.getProperty(UDC_DISABLE_KEY, \"false\");\n        }\n        disabled = Boolean.valueOf(disabledAsString);\n    }","id":106336,"modified_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     * <p/>\n     * Configuration precedence is in this order:\n     * <p/>\n     * <ol>\n     * <li>value from config<\/li>\n     * <li>system property<\/li>\n     * <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure( Config config )\n    {\n        Properties props = loadSystemProperties();\n\n        MyConfig configuration = new MyConfig( config, props );\n\n        try\n        {\n            firstDelay = configuration.getInt( FIRST_DELAY_CONFIG_KEY, \"600000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n        try\n        {\n            interval = configuration.getInt( INTERVAL_CONFIG_KEY, \"86400000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            hostAddress = configuration.getString( UDC_HOST_ADDRESS_KEY, hostAddress );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            disabled = configuration.getBool( UDC_DISABLE_KEY, \"false\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            source = configuration.getString( UDC_SOURCE_KEY, null );\n        } catch ( Exception e )\n        {\n            ;\n        }\n    }","commit_id":"280a847e4b09f03a48e745984f157cefed5d1f81","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     *\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load(KernelData kernel) {\n        configure(kernel.getConfig());\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState(this, new Object());\n\n        if (!disabled) {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource) kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(\"nioneodb\");\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString(ds.getRandomIdentifier());\n            UdcTimerTask task = new UdcTimerTask(hostAddress, Version.VERSION.getRevision(), storeId, crashPing);\n            timer.scheduleAtFixedRate(task, firstDelay, interval);\n        }\n    }","id":106337,"modified_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     * <p/>\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load( KernelData kernel )\n    {\n        configure( kernel.getConfig() );\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState( this, new Object() );\n\n        if ( !disabled )\n        {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource)kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource( \"nioneodb\" );\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString( ds.getRandomIdentifier() );\n            UdcTimerTask task = new UdcTimerTask( hostAddress, Version.VERSION.getRevision(), storeId, source, crashPing );\n            timer.scheduleAtFixedRate( task, firstDelay, interval );\n        }\n    }","commit_id":"280a847e4b09f03a48e745984f157cefed5d1f81","url":"https://github.com/neo4j/neo4j"},{"original_method":"public UdcTimerTask( String host, String version, String storeId, boolean crashPing )\n    {\n        successCounts.put(storeId, 0);\n        failureCounts.put(storeId, 0);\n\n        this.storeId = storeId;\n\n        Map<String,String> udcFields = new HashMap<String, String>();\n        udcFields.put(\"id\", storeId);\n        udcFields.put(\"v\", version);\n\n        pinger = new Pinger( host, mergeSystemPropertiesWith( udcFields ), crashPing );\n    }","id":106338,"modified_method":"public UdcTimerTask( String host, String version, String storeId, String source, boolean crashPing )\n    {\n        successCounts.put( storeId, 0 );\n        failureCounts.put( storeId, 0 );\n\n        this.storeId = storeId;\n\n        Map<String, String> udcFields = new HashMap<String, String>();\n        udcFields.put( \"id\", storeId );\n        udcFields.put( \"v\", version );\n\n        Map<String, String> params = mergeSystemPropertiesWith( udcFields );\n        if ( source != null )\n        {\n            params.put( \"source\", source );\n        }\n\n\n        pinger = new Pinger( host, params, crashPing );\n    }","commit_id":"280a847e4b09f03a48e745984f157cefed5d1f81","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     *\n     * Configuration precedence is in this order:\n     *\n     * <ol>\n     *   <li>value from config<\/li>\n     *   <li>system property<\/li>\n     *   <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure(Config config) {\n        Properties props = loadSystemProperties();\n        try {\n            String firstDelayAsString = (String) config.getParams().get(FIRST_DELAY_CONFIG_KEY);\n            if (firstDelayAsString == null) {\n                firstDelayAsString = (String)props.getProperty(FIRST_DELAY_CONFIG_KEY, \"600000\");\n            }\n            firstDelay = Integer.parseInt(firstDelayAsString);\n        } catch (Exception e) {\n           ;\n        }\n        try {\n            String intervalAsString = (String) config.getParams().get(INTERVAL_CONFIG_KEY);\n            if (intervalAsString == null) {\n                intervalAsString = (String)props.getProperty(INTERVAL_CONFIG_KEY, \"86400000\");\n            }\n            interval = Integer.parseInt(intervalAsString);\n        } catch (Exception e) {\n            ;\n        }\n        try {\n            String possibleHost = (String)config.getParams().get(UDC_HOST_ADDRESS_KEY);\n            if (null != possibleHost) hostAddress = possibleHost;\n        } catch (Exception e) {\n            ;\n        }\n\n        String disabledAsString = (String)config.getParams().get(UDC_DISABLE_KEY);\n        if (disabledAsString == null) {\n            disabledAsString = props.getProperty(UDC_DISABLE_KEY, \"false\");\n        }\n        disabled = Boolean.valueOf(disabledAsString);\n    }","id":106339,"modified_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     * <p/>\n     * Configuration precedence is in this order:\n     * <p/>\n     * <ol>\n     * <li>value from config<\/li>\n     * <li>system property<\/li>\n     * <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure( Config config )\n    {\n        Properties props = loadSystemProperties();\n\n        MyConfig configuration = new MyConfig( config, props );\n\n        try\n        {\n            firstDelay = configuration.getInt( FIRST_DELAY_CONFIG_KEY, \"600000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n        try\n        {\n            interval = configuration.getInt( INTERVAL_CONFIG_KEY, \"86400000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            hostAddress = configuration.getString( UDC_HOST_ADDRESS_KEY, hostAddress );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            disabled = configuration.getBool( UDC_DISABLE_KEY, \"false\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            source = configuration.getString( UDC_SOURCE_KEY, null );\n        } catch ( Exception e )\n        {\n            ;\n        }\n    }","commit_id":"00f4fdb89f46e4c3c082d6da8715e1a0f91a3cf2","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     *\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load(KernelData kernel) {\n        configure(kernel.getConfig());\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState(this, new Object());\n\n        if (!disabled) {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource) kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(\"nioneodb\");\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString(ds.getRandomIdentifier());\n            UdcTimerTask task = new UdcTimerTask(hostAddress, Version.VERSION.getRevision(), storeId, crashPing);\n            timer.scheduleAtFixedRate(task, firstDelay, interval);\n        }\n    }","id":106340,"modified_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     * <p/>\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load( KernelData kernel )\n    {\n        configure( kernel.getConfig() );\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState( this, new Object() );\n\n        if ( !disabled )\n        {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource)kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource( \"nioneodb\" );\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString( ds.getRandomIdentifier() );\n            UdcTimerTask task = new UdcTimerTask( hostAddress, Version.VERSION.getRevision(), storeId, source, crashPing );\n            timer.scheduleAtFixedRate( task, firstDelay, interval );\n        }\n    }","commit_id":"00f4fdb89f46e4c3c082d6da8715e1a0f91a3cf2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public UdcTimerTask( String host, String version, String storeId, boolean crashPing )\n    {\n        successCounts.put(storeId, 0);\n        failureCounts.put(storeId, 0);\n\n        this.storeId = storeId;\n\n        Map<String,String> udcFields = new HashMap<String, String>();\n        udcFields.put(\"id\", storeId);\n        udcFields.put(\"v\", version);\n\n        pinger = new Pinger( host, mergeSystemPropertiesWith( udcFields ), crashPing );\n    }","id":106341,"modified_method":"public UdcTimerTask( String host, String version, String storeId, String source, boolean crashPing )\n    {\n        successCounts.put( storeId, 0 );\n        failureCounts.put( storeId, 0 );\n\n        this.storeId = storeId;\n\n        Map<String, String> udcFields = new HashMap<String, String>();\n        udcFields.put( \"id\", storeId );\n        udcFields.put( \"v\", version );\n\n        Map<String, String> params = mergeSystemPropertiesWith( udcFields );\n        if ( source != null )\n        {\n            params.put( \"source\", source );\n        }\n\n\n        pinger = new Pinger( host, params, crashPing );\n    }","commit_id":"00f4fdb89f46e4c3c082d6da8715e1a0f91a3cf2","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     *\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load(KernelData kernel) {\n        configure(kernel.getConfig());\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState(this, new Object());\n\n        if (!disabled) {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource) kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(\"nioneodb\");\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString(ds.getRandomIdentifier());\n            UdcTimerTask task = new UdcTimerTask(hostAddress, Version.VERSION.getRevision(), storeId, crashPing);\n            timer.scheduleAtFixedRate(task, firstDelay, interval);\n        }\n    }","id":106342,"modified_method":"/**\n     * Lifecycle load event, which occurs during the startup of\n     * a new GraphDbInstance.\n     * <p/>\n     * Configuration information is retrieved from the KernelData,\n     * then a daemon thread is started to periodically collect\n     * and submit usage data.\n     *\n     * @param kernel reference to the loading graph database kernel.\n     */\n    @Override\n    protected void load( KernelData kernel )\n    {\n        configure( kernel.getConfig() );\n\n        // ABK: a hack to register this extension with the kernel, which\n        // only knows about extensions that have a saved state\n        kernel.setState( this, new Object() );\n\n        if ( !disabled )\n        {\n            timer = new Timer();\n            NeoStoreXaDataSource ds = (NeoStoreXaDataSource)kernel.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource( \"nioneodb\" );\n            boolean crashPing = ds.getXaContainer().getLogicalLog().wasNonClean();\n            String storeId = Long.toHexString( ds.getRandomIdentifier() );\n            UdcTimerTask task = new UdcTimerTask( hostAddress, Version.VERSION.getRevision(), storeId, source, crashPing );\n            timer.scheduleAtFixedRate( task, firstDelay, interval );\n        }\n    }","commit_id":"d0104a6f20a347fd2c7d2190b0fe41e1d83a89a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     *\n     * Configuration precedence is in this order:\n     *\n     * <ol>\n     *   <li>value from config<\/li>\n     *   <li>system property<\/li>\n     *   <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure(Config config) {\n        Properties props = loadSystemProperties();\n        try {\n            String firstDelayAsString = (String) config.getParams().get(FIRST_DELAY_CONFIG_KEY);\n            if (firstDelayAsString == null) {\n                firstDelayAsString = (String)props.getProperty(FIRST_DELAY_CONFIG_KEY, \"600000\");\n            }\n            firstDelay = Integer.parseInt(firstDelayAsString);\n        } catch (Exception e) {\n           ;\n        }\n        try {\n            String intervalAsString = (String) config.getParams().get(INTERVAL_CONFIG_KEY);\n            if (intervalAsString == null) {\n                intervalAsString = (String)props.getProperty(INTERVAL_CONFIG_KEY, \"86400000\");\n            }\n            interval = Integer.parseInt(intervalAsString);\n        } catch (Exception e) {\n            ;\n        }\n        try {\n            String possibleHost = (String)config.getParams().get(UDC_HOST_ADDRESS_KEY);\n            if (null != possibleHost) hostAddress = possibleHost;\n        } catch (Exception e) {\n            ;\n        }\n\n        String disabledAsString = (String)config.getParams().get(UDC_DISABLE_KEY);\n        if (disabledAsString == null) {\n            disabledAsString = props.getProperty(UDC_DISABLE_KEY, \"false\");\n        }\n        disabled = Boolean.valueOf(disabledAsString);\n    }","id":106343,"modified_method":"/**\n     * Attempt to retrieve configuration provided by user.\n     * <p/>\n     * Configuration precedence is in this order:\n     * <p/>\n     * <ol>\n     * <li>value from config<\/li>\n     * <li>system property<\/li>\n     * <li>hard-coded default value<\/li>\n     * <ol>\n     *\n     * @param config user defined configuration parameters\n     */\n    private void configure( Config config )\n    {\n        Properties props = loadSystemProperties();\n\n        MyConfig configuration = new MyConfig( config, props );\n\n        try\n        {\n            firstDelay = configuration.getInt( FIRST_DELAY_CONFIG_KEY, \"600000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n        try\n        {\n            interval = configuration.getInt( INTERVAL_CONFIG_KEY, \"86400000\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            hostAddress = configuration.getString( UDC_HOST_ADDRESS_KEY, hostAddress );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            disabled = configuration.getBool( UDC_DISABLE_KEY, \"false\" );\n        } catch ( Exception e )\n        {\n            ;\n        }\n\n        try\n        {\n            source = configuration.getString( UDC_SOURCE_KEY, null );\n        } catch ( Exception e )\n        {\n            ;\n        }\n    }","commit_id":"d0104a6f20a347fd2c7d2190b0fe41e1d83a89a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public UdcTimerTask( String host, String version, String storeId, boolean crashPing )\n    {\n        successCounts.put(storeId, 0);\n        failureCounts.put(storeId, 0);\n\n        this.storeId = storeId;\n\n        Map<String,String> udcFields = new HashMap<String, String>();\n        udcFields.put(\"id\", storeId);\n        udcFields.put(\"v\", version);\n\n        pinger = new Pinger( host, mergeSystemPropertiesWith( udcFields ), crashPing );\n    }","id":106344,"modified_method":"public UdcTimerTask( String host, String version, String storeId, String source, boolean crashPing )\n    {\n        successCounts.put( storeId, 0 );\n        failureCounts.put( storeId, 0 );\n\n        this.storeId = storeId;\n\n        Map<String, String> udcFields = new HashMap<String, String>();\n        udcFields.put( \"id\", storeId );\n        udcFields.put( \"v\", version );\n\n        Map<String, String> params = mergeSystemPropertiesWith( udcFields );\n        if ( source != null )\n        {\n            params.put( \"source\", source );\n        }\n\n\n        pinger = new Pinger( host, params, crashPing );\n    }","commit_id":"d0104a6f20a347fd2c7d2190b0fe41e1d83a89a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n  public String toString() {\n    final int sz = size();\n    final TokenBuilder tb = new TokenBuilder();\n    tb.add(text ? \"Text\" : \"Attribute\").add(\" index of '\").add(data.meta.name).add(\"':\\n\");\n    if(sz != 0) {\n      tb.add(\"- entries: \").addInt(sz).add(\"\\n\");\n      tb.add(\"- references:\").add(\"\\n\");\n      for(int m = 0; m < sz; m++) {\n        final long pos = idxr.read5(m * 5L);\n        final int oc = idxl.readNum(pos);\n        int id = idxl.readNum();\n        final byte[] txt = data.text(pre(id), text);\n        tb.add(\"  \").addInt(m).add(\": key \\\"\").add(txt).add(\"\\\", offset \").addLong(pos);\n        tb.add(\", id dists \").addInt(id).add('/').addInt(pre(id));\n        for(int n = 1; n < oc; n++) {\n          final int x = idxl.readNum();\n          id += x;\n          tb.add(\",\").addInt(id).add('/').addInt(pre(id));\n        }\n        tb.add(\"\\n\");\n      }\n    }\n    return tb.toString().trim();\n  }","id":106345,"modified_method":"@Override\n  public String toString() {\n    final int sz = size();\n    final TokenBuilder tb = new TokenBuilder();\n    tb.add(text ? \"TEXT\" : \"ATTRIBUTE\").add(\" INDEX, '\").add(data.meta.name).add(\"':\\n\");\n    if(sz != 0) {\n      tb.add(\"- entries: \").addInt(sz).add(\"\\n\");\n      tb.add(\"- references:\").add(\"\\n\");\n      for(int m = 0; m < sz; m++) {\n        final long pos = idxr.read5(m * 5L);\n        final int oc = idxl.readNum(pos);\n        int id = idxl.readNum();\n        tb.add(\"  \").addInt(m).add(\". key: \\\"\").add(data.text(pre(id), text)).add(\"\\\"; offset: \");\n        tb.addLong(pos).add(\"; id/dists: \").addInt(id).add('/').addInt(pre(id));\n        for(int n = 1; n < oc; n++) {\n          id += idxl.readNum();\n          tb.add(\",\").addInt(id).add('/').addInt(pre(id));\n        }\n        tb.add(\"\\n\");\n      }\n    }\n    return tb.toString();\n  }","commit_id":"89d6a8a336c405e57ac143abb7716aac0e720c9f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    final StringBuilder b = new StringBuilder();\n\n    b.append(\"pres, fids, nids, incs, oids\");\n    for(int i = 0; i < rows; i++) {\n      b.append('\\n');\n      b.append(pres[i]); b.append(\", \");\n      b.append(fids[i]); b.append(\", \");\n      b.append(nids[i]); b.append(\", \");\n      b.append(incs[i]); b.append(\", \");\n      b.append(oids[i]);\n    }\n\n    return b.toString();\n  }","id":106346,"modified_method":"@Override\n  public String toString() {\n    final Table t = new Table();\n    t.header.add(\"pres\");\n    t.header.add(\"fids\");\n    t.header.add(\"nids\");\n    t.header.add(\"incs\");\n    t.header.add(\"oids\");\n    for(int i = 0; i < 5; ++i) t.align.add(true);\n\n    for(int i = 0; i < rows; i++) {\n      final TokenList tl = new TokenList();\n      tl.add(Token.token(pres[i]));\n      tl.add(Token.token(fids[i]));\n      tl.add(Token.token(nids[i]));\n      tl.add(Token.token(incs[i]));\n      tl.add(Token.token(oids[i]));\n      t.contents.add(tl);\n    }\n    return t.toString();\n  }","commit_id":"89d6a8a336c405e57ac143abb7716aac0e720c9f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    final TokenBuilder tb = new TokenBuilder();\n    for(final byte[] b : header) tb.add(b).add('\\t');\n    tb.add(NL);\n    for(final TokenList e : contents) {\n      for(final byte[] b : e) tb.add(b).add('\\t');\n    }\n    return tb.toString();\n  }","id":106347,"modified_method":"@Override\n  public String toString() {\n    return string(finish());\n  }","commit_id":"89d6a8a336c405e57ac143abb7716aac0e720c9f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public void applyURI(Request request, String oldTarget, String newTarget) throws IOException \n    {\n        String uri = URIUtil.addPaths(_replacement, PathMap.pathInfo(_pattern,request.getRequestURI()));\n        request.setRequestURI(uri);\n    }","id":106348,"modified_method":"/**\n     * This method will add _query to the requests's queryString and also combine it with existing queryStrings in\n     * the request. However it won't take care for duplicate. E.g. if request.getQueryString contains a parameter\n     * \"param1 = true\" and _query will contain \"param1=false\" the result will be param1=true&param1=false.\n     * To cover this use case some more complex pattern matching is necessary. We can implement this if there's use\n     * cases.\n     *\n     * @param request\n     * @param oldTarget\n     * @param newTarget\n     * @throws IOException\n     */\n    @Override\n    public void applyURI(Request request, String oldTarget, String newTarget) throws IOException\n    {\n        if (_query == null)\n        {\n            request.setRequestURI(newTarget);\n        }\n        else\n        {\n            String queryString = request.getQueryString();\n            if (queryString != null)\n                queryString = queryString + \"&\" + _query;\n            else\n                queryString = _query;\n            HttpURI uri = new HttpURI(newTarget + \"?\" + queryString);\n            request.setUri(uri);\n            request.setRequestURI(newTarget);\n            request.setQueryString(queryString);\n        }\n    }","commit_id":"41a0e06e439e7c4d274fa5f89e1d7594684ad84d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Whenever a match is found, it replaces with this value.\n     * \n     * @param value the replacement string.\n     */\n    public void setReplacement(String value)\n    {\n        _replacement = value;\n    }","id":106349,"modified_method":"/**\n     * Whenever a match is found, it replaces with this value.\n     *\n     * @param replacement the replacement string.\n     */\n    public void setReplacement(String replacement)\n    {\n        String[] split = replacement.split(\"\\\\?\", 2);\n        _replacement = split[0];\n        _query = split.length == 2 ? split[1] : null;\n    }","commit_id":"41a0e06e439e7c4d274fa5f89e1d7594684ad84d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Whenever a match is found, it replaces with this value.\n     * \n     * @param value the replacement string.\n     */\n    public void setReplacement(String value)\n    {\n        _replacement = value;\n    }","id":106350,"modified_method":"/**\n     * Whenever a match is found, it replaces with this value.\n     *\n     * @param replacement the replacement string.\n     */\n    public void setReplacement(String replacement)\n    {\n        String[] split = replacement.split(\"\\\\?\", 2);\n        _replacement = split[0];\n        _query = split.length == 2 ? split[1] : null;\n    }","commit_id":"ebfa3b97ba069c55b2205b104230635f1494f13b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void applyURI(Request request, String oldTarget, String newTarget) throws IOException \n    {\n        String uri = URIUtil.addPaths(_replacement, PathMap.pathInfo(_pattern,request.getRequestURI()));\n        request.setRequestURI(uri);\n    }","id":106351,"modified_method":"/**\n     * This method will add _query to the requests's queryString and also combine it with existing queryStrings in\n     * the request. However it won't take care for duplicate. E.g. if request.getQueryString contains a parameter\n     * \"param1 = true\" and _query will contain \"param1=false\" the result will be param1=true&param1=false.\n     * To cover this use case some more complex pattern matching is necessary. We can implement this if there's use\n     * cases.\n     *\n     * @param request\n     * @param oldTarget\n     * @param newTarget\n     * @throws IOException\n     */\n    @Override\n    public void applyURI(Request request, String oldTarget, String newTarget) throws IOException\n    {\n        if (_query == null)\n        {\n            request.setRequestURI(newTarget);\n        }\n        else\n        {\n            String queryString = request.getQueryString();\n            if (queryString != null)\n                queryString = queryString + \"&\" + _query;\n            else\n                queryString = _query;\n            HttpURI uri = new HttpURI(newTarget + \"?\" + queryString);\n            request.setUri(uri);\n            request.setRequestURI(newTarget);\n            request.setQueryString(queryString);\n        }\n    }","commit_id":"ebfa3b97ba069c55b2205b104230635f1494f13b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void record(String room, String meetingid){\n    \tString RECORD_DIR = \"/var/freeswitch/meetings\";        \n    \tString voicePath = RECORD_DIR + File.separatorChar + meetingid + \"-\" + System.currentTimeMillis() + \".wav\";\n    \t\n    \tif (log.isDebugEnabled())\n    \t\tlog.debug(\"Asking Freeswitch to start recording in {}\", voicePath);\n    \t\n    \tRecordConferenceCommand rcc = new RecordConferenceCommand(room, USER, true, voicePath);\n    \tlog.debug(rcc.getCommand() + rcc.getCommandArgs());\n    \tEslMessage response = manager.getESLClient().sendSyncApiCommand(rcc.getCommand(), rcc.getCommandArgs());\n        rcc.handleResponse(response, conferenceEventListener);\n    }","id":106352,"modified_method":"@Override\n    public void record(String room, String meetingid){\n    \tString RECORD_DIR = \"/var/freeswitch/meetings\";        \n    \tString voicePath = RECORD_DIR + File.separatorChar + meetingid + \"-\" + System.currentTimeMillis() + \".wav\";\n    \t\n    \tif (log.isDebugEnabled())\n    \t\tlog.debug(\"Asking Freeswitch to start recording in {}\", voicePath);\n    \t\n    \tClient c = manager.getESLClient();\n        if (c.canSend()) {\n        \tRecordConferenceCommand rcc = new RecordConferenceCommand(room, USER, true, voicePath);\n        \tlog.debug(rcc.getCommand() + rcc.getCommandArgs());\n        \tEslMessage response = manager.getESLClient().sendSyncApiCommand(rcc.getCommand(), rcc.getCommandArgs());\n            rcc.handleResponse(response, conferenceEventListener);       \t\n        }else {\n        \tlog.warn(\"Can't send record request to FreeSWITCH as we are not connected.\");\n        \t// Let's see if we can recover the connection.\n        \tstartHeartbeatMonitor();\n        }\n    }","commit_id":"c858a6919b681cd04a4f18856c70ab6bf10c0af2","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n    public void mute(String room, Integer participant, Boolean mute) {\n        MuteParticipantCommand mpc = new MuteParticipantCommand(room, participant, mute, USER);\n        String jobId = manager.getESLClient().sendAsyncApiCommand( mpc.getCommand(), mpc.getCommandArgs());\n        log.debug(\"mute called for room [{}] jobid [{}]\", room, jobId);\n    }","id":106353,"modified_method":"@Override\n    public void mute(String room, Integer participant, Boolean mute) {\n    \tClient c = manager.getESLClient();\n        if (c.canSend()) {\n            MuteParticipantCommand mpc = new MuteParticipantCommand(room, participant, mute, USER);\n            String jobId = c.sendAsyncApiCommand( mpc.getCommand(), mpc.getCommandArgs());\n            log.debug(\"mute called for room [{}] jobid [{}]\", room, jobId);        \t\n        }else {\n        \tlog.warn(\"Can't send mute request to FreeSWITCH as we are not connected.\");\n        \t// Let's see if we can recover the connection.\n        \tstartHeartbeatMonitor();\n        }\n\n    }","commit_id":"c858a6919b681cd04a4f18856c70ab6bf10c0af2","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n    public void startup() {\n        Client c = manager.getESLClient();\n        c.addEventListener( this );\n        c.cancelEventSubscriptions();\n        c.setEventSubscriptions( \"plain\", \"all\" );\n        c.addEventFilter( \"Event-Name\", \"heartbeat\" );\n        c.addEventFilter( \"Event-Name\", \"custom\" );\n        c.addEventFilter( \"Event-Name\", \"background_job\" );\n        \n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException ex) {\n            java.util.logging.Logger.getLogger(FreeswitchApplication.class.getName()).log(Level.SEVERE, null, ex);\n        }\n\n\n        //Start Heartbeat and exception Event Observer Monitor\n        if(heartbeatMonitor == null) { //Only startup once. as startup will be called for reconnect.\n            heartbeatMonitor = new FreeswitchHeartbeatMonitor(manager, this);\n            this.addObserver(heartbeatMonitor);\n            heartbeatMonitor.start();\n        }\n    }","id":106354,"modified_method":"@Override\n    public void startup() {    \t\n        Client c = manager.getESLClient();\n        if (c.canSend()) {\n            c.addEventListener( this );\n            c.cancelEventSubscriptions();\n            c.setEventSubscriptions( \"plain\", \"all\" );\n            c.addEventFilter( \"Event-Name\", \"heartbeat\" );\n            c.addEventFilter( \"Event-Name\", \"custom\" );\n            c.addEventFilter( \"Event-Name\", \"background_job\" );\n            \n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException ex) {\n                java.util.logging.Logger.getLogger(FreeswitchApplication.class.getName()).log(Level.SEVERE, null, ex);\n            }        \t\n        }\n\n        //Start Heartbeat and exception Event Observer Monitor\n        startHeartbeatMonitor();\n    }","commit_id":"c858a6919b681cd04a4f18856c70ab6bf10c0af2","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n    public void populateRoom(String room) {\n        PopulateRoomCommand prc = new PopulateRoomCommand(room, USER);\n        EslMessage response = manager.getESLClient().sendSyncApiCommand(prc.getCommand(), prc.getCommandArgs());\n        prc.handleResponse(response, conferenceEventListener);\n    }","id":106355,"modified_method":"@Override\n    public void populateRoom(String room) {       \n        Client c = manager.getESLClient();\n        if (c.canSend()) {\n        \tPopulateRoomCommand prc = new PopulateRoomCommand(room, USER);\n            EslMessage response = c.sendSyncApiCommand(prc.getCommand(), prc.getCommandArgs());\n            prc.handleResponse(response, conferenceEventListener);        \t\n        } else {\n        \tlog.warn(\"Can't send populate room request to FreeSWITCH as we are not connected.\");\n        \t// Let's see if we can recover the connection.\n        \tstartHeartbeatMonitor();\n        }\n    }","commit_id":"c858a6919b681cd04a4f18856c70ab6bf10c0af2","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n    public void eject(String room, Integer participant) {\n        EjectParticipantCommand mpc = new EjectParticipantCommand(room, participant, USER);\n        String jobId = manager.getESLClient().sendAsyncApiCommand( mpc.getCommand(), mpc.getCommandArgs());\n        log.debug(\"eject/kick called for room [{}] jobid [{}]\", room, jobId);\n    }","id":106356,"modified_method":"@Override\n    public void eject(String room, Integer participant) {\n        Client c = manager.getESLClient();\n        if (c.canSend()) {\n        \tEjectParticipantCommand mpc = new EjectParticipantCommand(room, participant, USER);\n            String jobId = c.sendAsyncApiCommand( mpc.getCommand(), mpc.getCommandArgs());\n            log.debug(\"eject/kick called for room [{}] jobid [{}]\", room, jobId);        \t\n        }else {\n        \tlog.warn(\"Can't send eject request to FreeSWITCH as we are not connected.\");\n        \t// Let's see if we can recover the connection.\n        \tstartHeartbeatMonitor();\n        }\n    }","commit_id":"c858a6919b681cd04a4f18856c70ab6bf10c0af2","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Test\n    public void shouldSilentlyNotRemoveMissingNodeProperty() throws Exception\n    {\n        // GIVEN\n        int propertyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n            propertyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // WHEN\n            Property result = statement.nodeRemoveProperty( nodeId, propertyId );\n\n            // THEN\n            assertFalse( \"Return no property if removing missing\", result.isDefined() );\n        }\n    }","id":106357,"modified_method":"@Test\n    public void shouldSilentlyNotRemoveMissingNodeProperty() throws Exception\n    {\n        // GIVEN\n        int propertyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n            propertyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // WHEN\n            Property result = statement.nodeRemoveProperty( nodeId, propertyId );\n\n            // THEN\n            assertFalse( \"Return no property if removing missing\", result.isDefined() );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void nodeHasPropertyIfSet() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), isDefinedProperty() );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), isDefinedProperty() );\n        }\n    }","id":106358,"modified_method":"@Test\n    public void nodeHasPropertyIfSet() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), isDefinedProperty() );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), isDefinedProperty() );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void nodeHasStringPropertyIfSetAndLazyPropertyIfRead() throws Exception\n    {\n        // GIVEN\n        dbWithNoCache();\n\n        int propertyKeyId;\n        long nodeId;\n        String value = \"Bozo the Clown is a clown character very popular in the United States, peaking in the 1960s\";\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, value ) );\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"StringProperty\" ) );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"LazyStringProperty\" ) );\n            assertEquals( value, statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n            assertEquals( value.hashCode(), statement.nodeGetProperty( nodeId, propertyKeyId ).hashCode() );\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).valueEquals( value ) );\n        }\n    }","id":106359,"modified_method":"@Test\n    public void nodeHasStringPropertyIfSetAndLazyPropertyIfRead() throws Exception\n    {\n        // GIVEN\n        dbWithNoCache();\n\n        int propertyKeyId;\n        long nodeId;\n        String value = \"Bozo the Clown is a clown character very popular in the United States, peaking in the 1960s\";\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, value ) );\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"StringProperty\" ) );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"LazyStringProperty\" ) );\n            assertEquals( value, statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n            assertEquals( value.hashCode(), statement.nodeGetProperty( nodeId, propertyKeyId ).hashCode() );\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).valueEquals( value ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUpdateNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n            propertyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyId, \"bozo\" ) );\n            commit();\n        }\n\n        // WHEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            statement.nodeSetProperty( nodeId, Property.intProperty( propertyId, 42 ) );\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertEquals( 42, statement.nodeGetProperty( nodeId, propertyId ).value() );\n        }\n    }","id":106360,"modified_method":"@Test\n    public void shouldUpdateNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n            propertyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyId, \"bozo\" ) );\n            commit();\n        }\n\n        // WHEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            statement.nodeSetProperty( nodeId, Property.intProperty( propertyId, 42 ) );\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertEquals( 42, statement.nodeGetProperty( nodeId, propertyId ).value() );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRemoveSetNodePropertyAcrossTransactions() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // WHEN\n            Object previous = statement.nodeRemoveProperty( nodeId, propertyKeyId ).value();\n\n            // THEN\n            assertEquals( \"bozo\", previous );\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","id":106361,"modified_method":"@Test\n    public void shouldRemoveSetNodePropertyAcrossTransactions() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // WHEN\n            Object previous = statement.nodeRemoveProperty( nodeId, propertyKeyId ).value();\n\n            // THEN\n            assertEquals( \"bozo\", previous );\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void nodeHasArrayPropertyIfSetAndLazyPropertyIfRead() throws Exception\n    {\n        // GIVEN\n        dbWithNoCache();\n\n        int propertyKeyId;\n        long nodeId;\n        int[] value = new int[] {-1,0,1,2,3,4,5,6,7,8,9,10};\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"numbers\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.intArrayProperty( propertyKeyId, value ) );\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"IntArrayProperty\" ) );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"LazyArrayProperty\" ) );\n            assertArrayEquals( value, (int[]) statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n            assertEquals( Arrays.hashCode( value ), statement.nodeGetProperty( nodeId, propertyKeyId ).hashCode() );\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).valueEquals( value ) );\n        }\n    }","id":106362,"modified_method":"@Test\n    public void nodeHasArrayPropertyIfSetAndLazyPropertyIfRead() throws Exception\n    {\n        // GIVEN\n        dbWithNoCache();\n\n        int propertyKeyId;\n        long nodeId;\n        int[] value = new int[] {-1,0,1,2,3,4,5,6,7,8,9,10};\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"numbers\" );\n            statement.nodeSetProperty( nodeId, Property.intArrayProperty( propertyKeyId, value ) );\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"IntArrayProperty\" ) );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).getClass().getSimpleName().equals( \"LazyArrayProperty\" ) );\n            assertArrayEquals( value, (int[]) statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n            assertEquals( Arrays.hashCode( value ), statement.nodeGetProperty( nodeId, propertyKeyId ).hashCode() );\n            assertTrue( statement.nodeGetProperty( nodeId, propertyKeyId ).valueEquals( value ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRollbackSetNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            commit();\n        }\n\n        // WHEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n            rollback();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","id":106363,"modified_method":"@Test\n    public void shouldRollbackSetNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            commit();\n        }\n\n        // WHEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n            rollback();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void nodeHasNotPropertyIfUnset() throws Exception\n    {\n        int propertyKeyId;\n        long nodeId;\n        {\n            // GIVEN\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","id":106364,"modified_method":"@Test\n    public void nodeHasNotPropertyIfUnset() throws Exception\n    {\n        int propertyKeyId;\n        long nodeId;\n        {\n            // GIVEN\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRemoveSetNodeProperty() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // WHEN\n            statement.nodeRemoveProperty( nodeId, propertyKeyId );\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","id":106365,"modified_method":"@Test\n    public void shouldRemoveSetNodeProperty() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // WHEN\n            statement.nodeRemoveProperty( nodeId, propertyKeyId );\n\n            // THEN\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n\n            // WHEN\n            commit();\n        }\n\n        // THEN\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            assertThat( statement.nodeGetProperty( nodeId, propertyKeyId ), not( isDefinedProperty() ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldSetNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            Node node = db.createNode();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            nodeId = node.getId();\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // THEN\n            assertEquals( \"bozo\", statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertEquals( \"bozo\", statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n        }\n    }","id":106366,"modified_method":"@Test\n    public void shouldSetNodePropertyValue() throws Exception\n    {\n        // GIVEN\n        int propertyKeyId;\n        long nodeId;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            nodeId = statement.nodeCreate();\n\n            // WHEN\n            propertyKeyId = statement.propertyKeyGetOrCreateForName( \"clown\" );\n            statement.nodeSetProperty( nodeId, Property.stringProperty( propertyKeyId, \"bozo\" ) );\n\n            // THEN\n            assertEquals( \"bozo\", statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n\n            // WHEN\n            commit();\n        }\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            // THEN\n            assertEquals( \"bozo\", statement.nodeGetProperty( nodeId, propertyKeyId ).value() );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates a store with a truncated property store file that remains like\n     * that during recovery by truncating the logical log as well. Id\n     * regeneration should proceed without exceptions, even though the last\n     * property record is incomplete.\n     * \n     * @throws Exception\n     */\n    @Test\n    public void testTruncatedPropertyStore() throws Exception\n    {\n        File storeDir = TargetDirectory.forTest(\n                TestBrokenStoreRecovery.class ).cleanDirectory( \"propertyStore\"\n        );\n        Process process = Runtime.getRuntime().exec(\n            new String[]{\n                \"java\", \"-cp\",\n                System.getProperty( \"java.class.path\" ),\n                ProduceUncleanStore.class.getName(),\n                storeDir.getAbsolutePath()\n            } );\n\n        assertEquals(\n            0,\n            new ProcessStreamHandler( process, true ).waitForResult() );\n        trimFileToSize( new File( storeDir, \"neostore.propertystore.db\" ), 42 );\n        File log = new File( storeDir, \"nioneo_logical.log.1\" );\n        trimFileToSize( log, 78 );\n        new GraphDatabaseFactory().newEmbeddedDatabase( storeDir.getAbsolutePath() ).shutdown();\n    }","id":106367,"modified_method":"/**\n     * Creates a store with a truncated property store file that remains like\n     * that during recovery by truncating the logical log as well. Id\n     * regeneration should proceed without exceptions, even though the last\n     * property record is incomplete.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testTruncatedPropertyStore() throws Exception\n    {\n        File storeDir = TargetDirectory.forTest(\n                TestBrokenStoreRecovery.class ).cleanDirectory( \"propertyStore\"\n        );\n        Process process = Runtime.getRuntime().exec(\n            new String[]{\n                \"java\", \"-cp\",\n                System.getProperty( \"java.class.path\" ),\n                ProduceUncleanStore.class.getName(),\n                storeDir.getAbsolutePath()\n            } );\n\n        assertEquals(\n            0,\n            new ProcessStreamHandler( process, true ).waitForResult() );\n        trimFileToSize( new File( storeDir, \"neostore.propertystore.db\" ), 42 );\n        File log = new File( storeDir, \"nioneo_logical.log.v0\" );\n        trimFileToSize( log, 78 );\n        new GraphDatabaseFactory().newEmbeddedDatabase( storeDir.getAbsolutePath() ).shutdown();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAbortConstraintCreationWhenDuplicatesExist() throws Exception\n    {\n        // given\n        long node1, node2;\n        int foo, name;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            // name is not unique for Foo in the existing data\n            Node node = db.createNode( label( \"Foo\" ) );\n            node1 = node.getId();\n            node.setProperty( \"name\", \"foo\" );\n            node = db.createNode( label( \"Foo\" ) );\n            node2 = node.getId();\n            node.setProperty( \"name\", \"foo\" );\n            foo = statement.labelGetForName( \"Foo\" );\n            name = statement.propertyKeyGetForName( \"name\" );\n            commit();\n        }\n\n        // when\n        try\n        {\n            SchemaWriteOperations statement = schemaWriteOperationsInNewTransaction();\n            statement.uniquenessConstraintCreate( foo, name );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( CreateConstraintFailureException ex )\n        {\n            assertEquals( new UniquenessConstraint( foo, name ), ex.constraint() );\n            Throwable cause = ex.getCause();\n            assertThat( cause, instanceOf( ConstraintVerificationFailedKernelException.class ) );\n            assertEquals( asSet( new ConstraintVerificationFailedKernelException.Evidence(\n                    new PreexistingIndexEntryConflictException( \"foo\", node1, node2 ) ) ),\n                    ((ConstraintVerificationFailedKernelException) cause).evidence() );\n        }\n    }","id":106368,"modified_method":"@Test\n    public void shouldAbortConstraintCreationWhenDuplicatesExist() throws Exception\n    {\n        // given\n        long node1, node2;\n        int foo, name;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            // name is not unique for Foo in the existing data\n\n            foo = statement.labelGetOrCreateForName( \"Foo\" );\n            name = statement.propertyKeyGetOrCreateForName( \"name\" );\n\n            long node = statement.nodeCreate();\n            node1 = node;\n            statement.nodeAddLabel( node, foo );\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n\n            node = statement.nodeCreate();\n            statement.nodeAddLabel( node, foo );\n            node2 = node;\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n            commit();\n        }\n\n        // when\n        try\n        {\n            SchemaWriteOperations statement = schemaWriteOperationsInNewTransaction();\n            statement.uniquenessConstraintCreate( foo, name );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( CreateConstraintFailureException ex )\n        {\n            assertEquals( new UniquenessConstraint( foo, name ), ex.constraint() );\n            Throwable cause = ex.getCause();\n            assertThat( cause, instanceOf( ConstraintVerificationFailedKernelException.class ) );\n            assertEquals( asSet( new ConstraintVerificationFailedKernelException.Evidence(\n                    new PreexistingIndexEntryConflictException( \"foo\", node1, node2 ) ) ),\n                    ((ConstraintVerificationFailedKernelException) cause).evidence() );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowNoopPropertyUpdate() throws KernelException\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.setProperty( \"key1\", \"value1\" );\n\n        // then should not throw exception\n    }","id":106369,"modified_method":"@Test\n    public void shouldAllowNoopPropertyUpdate() throws KernelException\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeSetProperty( node, Property.property(\n                statement.propertyKeyGetOrCreateForName( \"key1\" ), \"value1\" ) );\n\n        // then should not throw exception\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveProperty() throws Exception\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.removeProperty( \"key1\" );\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value1\" );\n        commit();\n    }","id":106370,"modified_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveProperty() throws Exception\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeRemoveProperty( node, statement.propertyKeyGetForName( \"key1\" ) );\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value1\" );\n        commit();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowNoopLabelUpdate() throws KernelException\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.addLabel( label( \"Label1\" ) );\n\n        // then should not throw exception\n    }","id":106371,"modified_method":"@Test\n    public void shouldAllowNoopLabelUpdate() throws KernelException\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeAddLabel( node, statement.labelGetOrCreateForName( \"Label1\" ) );\n\n        // then should not throw exception\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void unrelatedNodesWithSamePropertyShouldNotInterfereWithUniquenessCheck() throws Exception\n    {\n        // given\n        createConstraint( \"Person\", \"id\" );\n\n        Node ourNode;\n        {\n            dataWriteOperationsInNewTransaction();\n\n            ourNode = db.createNode( label( \"Person\" ) );\n            ourNode.setProperty( \"id\", 1 );\n            db.createNode( label( \"Item\" ) ).setProperty( \"id\", 2 );\n\n            commit();\n        }\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n        IndexDescriptor idx = statement.uniqueIndexGetForLabelAndPropertyKey( statement\n                .labelGetForName( \"Person\" ), statement.propertyKeyGetForName( \"id\" ) );\n\n        // when\n        db.createNode( label( \"Item\" ) ).setProperty( \"id\", 2 );\n\n        // then I should find the original node\n        assertThat( statement.nodeGetUniqueFromIndexLookup( idx, 1 ), equalTo( ourNode.getId() ));\n    }","id":106372,"modified_method":"@Test\n    public void unrelatedNodesWithSamePropertyShouldNotInterfereWithUniquenessCheck() throws Exception\n    {\n        // given\n        createConstraint( \"Person\", \"id\" );\n\n        long ourNode;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            ourNode = createLabeledNode( statement, \"Person\", \"id\", 1 );\n            createLabeledNode( statement, \"Item\", \"id\", 2 );\n\n            commit();\n        }\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n        IndexDescriptor idx = statement.uniqueIndexGetForLabelAndPropertyKey( statement\n                .labelGetForName( \"Person\" ), statement.propertyKeyGetForName( \"id\" ) );\n\n        // when\n        createLabeledNode( statement, \"Item\", \"id\", 2 );\n\n        // then I should find the original node\n        assertThat( statement.nodeGetUniqueFromIndexLookup( idx, 1 ), equalTo( ourNode ) );\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void addingUniqueNodeWithUnrelatedValueShouldNotAffectLookup() throws Exception\n    {\n        // given\n        createConstraint( \"Person\", \"id\" );\n\n        Node ourNode;\n        {\n            dataWriteOperationsInNewTransaction();\n\n            ourNode = db.createNode( label( \"Person\" ) );\n            ourNode.setProperty( \"id\", 1 );\n            commit();\n        }\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n        IndexDescriptor idx = statement.uniqueIndexGetForLabelAndPropertyKey( statement\n                .labelGetForName( \"Person\" ), statement.propertyKeyGetForName( \"id\" ) );\n\n        // when\n        db.createNode( label( \"Person\" ) ).setProperty( \"id\", 2 );\n\n        // then I should find the original node\n        assertThat( statement.nodeGetUniqueFromIndexLookup( idx, 1 ), equalTo( ourNode.getId() ));\n    }","id":106373,"modified_method":"@Test\n    public void addingUniqueNodeWithUnrelatedValueShouldNotAffectLookup() throws Exception\n    {\n        // given\n        createConstraint( \"Person\", \"id\" );\n\n        long ourNode;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n            ourNode = createLabeledNode( statement, \"Person\", \"id\", 1 );\n            commit();\n        }\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n        IndexDescriptor idx = statement.uniqueIndexGetForLabelAndPropertyKey( statement\n                .labelGetForName( \"Person\" ), statement.propertyKeyGetForName( \"id\" ) );\n\n        // when\n        createLabeledNode( statement, \"Person\", \"id\", 2 );\n\n        // then I should find the original node\n        assertThat( statement.nodeGetUniqueFromIndexLookup( idx, 1 ), equalTo( ourNode ));\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_DeleteNode() throws Exception\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.delete();\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value1\" );\n        commit();\n    }","id":106374,"modified_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_DeleteNode() throws Exception\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeDelete( node );\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value1\" );\n        commit();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldEnforceUniquenessConstraintOnSetProperty() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        Node node = db.createNode( label( \"Label1\" ) );\n        try\n        {\n            node.setProperty( \"key1\", \"value1\" );\n\n            fail( \"should have thrown exception\" );\n        }\n        // then\n        catch ( ConstraintViolationException e )\n        {\n            assertThat( e.getMessage(), containsString( \"\\\"key1\\\"=[value1]\" ) );\n        }\n    }","id":106375,"modified_method":"@Test\n    public void shouldEnforceUniquenessConstraintOnSetProperty() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        long node = createLabeledNode( statement, \"Label1\" );\n        try\n        {\n            statement.nodeSetProperty( node, Property.property(\n                    statement.propertyKeyGetOrCreateForName( \"key1\" ), \"value1\" ) );\n\n            fail( \"should have thrown exception\" );\n        }\n        // then\n        catch ( UniqueConstraintViolationKernelException e )\n        {\n            assertThat( e.getUserMessage( tokenLookup( statement ) ), containsString( \"\\\"key1\\\"=[value1]\" ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPreventConflictingDataInSameTransaction() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value2\" );\n        try\n        {\n            db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value2\" );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( ConstraintViolationException e )\n        {\n            assertThat( e.getMessage(), containsString( \"\\\"key1\\\"=[value2]\" ) );\n        }\n    }","id":106376,"modified_method":"@Test\n    public void shouldPreventConflictingDataInSameTransaction() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value2\" );\n        try\n        {\n            createLabeledNode( statement, \"Label1\", \"key1\", \"value2\" );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( UniqueConstraintViolationKernelException e )\n        {\n            assertThat( e.getUserMessage( tokenLookup( statement ) ), containsString( \"\\\"key1\\\"=[value2]\" ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldEnforceUniquenessConstraintOnAddLabel() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        Node node = db.createNode();\n        node.setProperty( \"key1\", \"value1\" );\n        try\n        {\n            node.addLabel( label( \"Label1\" ) );\n\n            fail( \"should have thrown exception\" );\n        }\n        // then\n        catch ( ConstraintViolationException e )\n        {\n            assertThat( e.getMessage(), containsString( \"\\\"key1\\\"=[value1]\" ) );\n        }\n    }","id":106377,"modified_method":"@Test\n    public void shouldEnforceUniquenessConstraintOnAddLabel() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        long node = createNode( statement, \"key1\", \"value1\" );\n        try\n        {\n            statement.nodeAddLabel( node, statement.labelGetOrCreateForName( \"Label1\" ) );\n\n            fail( \"should have thrown exception\" );\n        }\n        // then\n        catch ( UniqueConstraintViolationKernelException e )\n        {\n            assertThat( e.getUserMessage( tokenLookup( statement ) ), containsString( \"\\\"key1\\\"=[value1]\" ) );\n        }\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowCreationOfNonConflictingData() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        db.createNode().setProperty( \"key1\", \"value1\" );\n        db.createNode( label( \"Label2\" ) ).setProperty( \"key1\", \"value1\" );\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value2\" );\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key2\", \"value1\" );\n\n        commit();\n\n        // then\n        dataWriteOperationsInNewTransaction();\n        assertEquals( \"number of nodes\", 5, count( GlobalGraphOperations.at( db ).getAllNodes() ) );\n        rollback();\n    }","id":106378,"modified_method":"@Test\n    public void shouldAllowCreationOfNonConflictingData() throws Exception\n    {\n        // given\n        constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        createNode( statement, \"key1\", \"value1\" );\n        createLabeledNode( statement, \"Label2\", \"key1\", \"value1\" );\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value2\" );\n        createLabeledNode( statement, \"Label1\", \"key2\", \"value1\" );\n\n        commit();\n\n        // then\n        statement = dataWriteOperationsInNewTransaction();\n        assertEquals( \"number of nodes\", 5, PrimitiveLongCollections.count( statement.nodesGetAll() ) );\n        rollback();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Node constrainedNode( String labelName, String propertyKey, Object propertyValue )\n            throws KernelException\n    {\n        Node node;\n        {\n            dataWriteOperationsInNewTransaction();\n            node = db.createNode( label( labelName ) );\n            node.setProperty( propertyKey, propertyValue );\n            commit();\n        }\n        createConstraint( labelName, propertyKey );\n        return node;\n    }","id":106379,"modified_method":"private long constrainedNode( String labelName, String propertyKey, Object propertyValue )\n            throws KernelException\n    {\n        long node;\n        {\n            DataWriteOperations dataStatement = dataWriteOperationsInNewTransaction();\n            int label = dataStatement.labelGetOrCreateForName( labelName );\n            node = dataStatement.nodeCreate();\n            dataStatement.nodeAddLabel( node, label );\n            int key = dataStatement.propertyKeyGetOrCreateForName( propertyKey );\n            dataStatement.nodeSetProperty( node, Property.property( key, propertyValue ) );\n            commit();\n        }\n        createConstraint( labelName, propertyKey );\n        return node;\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_ChangeProperty() throws Exception\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.setProperty( \"key1\", \"value2\" );\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value1\" );\n        commit();\n    }","id":106380,"modified_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_ChangeProperty() throws Exception\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeSetProperty( node, Property.property(\n                statement.propertyKeyGetOrCreateForName( \"key1\" ), \"value2\" ) );\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value1\" );\n        commit();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveLabel() throws Exception\n    {\n        // given\n        Node node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        dataWriteOperationsInNewTransaction();\n\n        // when\n        node.removeLabel( label( \"Label1\" ) );\n        db.createNode( label( \"Label1\" ) ).setProperty( \"key1\", \"value1\" );\n        commit();\n    }","id":106381,"modified_method":"@Test\n    public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveLabel() throws Exception\n    {\n        // given\n        long node = constrainedNode( \"Label1\", \"key1\", \"value1\" );\n\n        DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n\n        // when\n        statement.nodeRemoveLabel( node, statement.labelGetOrCreateForName( \"Label1\" ) );\n        createLabeledNode( statement, \"Label1\", \"key1\", \"value1\" );\n        commit();\n    }","commit_id":"735461843b672f4ff4614992e1baad1a288416e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n\t * @param scenario\n\t *            The scenario to run.\n\t * @param resolver\n\t *            A populated type resolved to be used to resolve the types in\n\t *            the scenario.\n\t *\n\t * For info on how to invoke this, see\n\t * ContentPackageAssemblerTest.testPackageWithRuleflow in drools-jbrms This\n\t * requires that the classloader for the thread context be set\n\t * appropriately. The PackageBuilder can provide a suitable TypeResolver for\n\t * a given package header, and the Package config can provide a classloader.\n\t *\n\t */\n\tpublic ScenarioRunner(final Scenario scenario, final TypeResolver resolver,\n\t\t\tfinal InternalWorkingMemory wm) throws ClassNotFoundException {\n\t\tthis.scenario = scenario;\n\t\tthis.workingMemory = wm;\n\t\tscenario.lastRunResult = new Date();\n\n\t\tTestingEventListener listener = null;\n\n\t\tfor (Iterator iterator = scenario.globals.iterator(); iterator.hasNext();) {\n\t\t\tFactData fact = (FactData) iterator.next();\n\t\t\tObject f = eval(\"new \" + resolver.getFullTypeName(fact.type) + \"()\");\n\t\t\tpopulateFields(fact, globalData, f);\n\t\t\tglobalData.put(fact.name, f);\n\t\t\twm.setGlobal(fact.name, f);\n\t\t}\n\n\t\tfor (Iterator<Fixture> iterator = scenario.fixtures.iterator(); iterator.hasNext();) {\n\t\t\tFixture fx = iterator.next();\n\n\t\t\tif (fx instanceof FactData) {\n\t\t\t\t//deal with facts and globals\n\t\t\t\tFactData fact = (FactData)fx;\n\t\t\t\tObject f = (fact.isModify)? this.populatedData.get(fact.name) : eval(\"new \" + resolver.getFullTypeName(fact.type) + \"()\");\n\t\t\t\tif (fact.isModify) {\n\t\t\t\t\tif (!this.factHandles.containsKey(fact.name)) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Was not a previously inserted fact. [\" + fact.name  + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tpopulateFields(fact, populatedData, f);\n\t\t\t\t\tthis.workingMemory.update(this.factHandles.get(fact.name), f);\n\t\t\t\t} else /* a new one */ {\n\t\t\t\t\tpopulateFields(fact, populatedData, f);\n\t\t\t\t\tpopulatedData.put(fact.name, f);\n\t\t\t\t\tthis.factHandles.put(fact.name, wm.insert(f));\n\t\t\t\t}\n\t\t\t} else if (fx instanceof RetractFact) {\n\t\t\t\tRetractFact f = (RetractFact)fx;\n\t\t\t\tthis.workingMemory.retract(this.factHandles.get(f.name));\n\t\t\t\tthis.populatedData.remove(f.name);\n\t\t\t} else if (fx instanceof ExecutionTrace) {\n\t\t\t\tExecutionTrace executionTrace = (ExecutionTrace)fx;\n\t\t\t\t//create the listener to trace rules\n\t\t\t\tHashSet<String> ruleList = new HashSet<String>();\n\t\t\t\truleList.addAll(Arrays.asList(executionTrace.rules));\n\t\t\t\tlistener = new TestingEventListener(ruleList, wm.getRuleBase(), executionTrace.inclusive);\n\t\t\t\twm.addEventListener(listener);\n\n\t\t\t\t//set up the time machine\n\t\t\t\tapplyTimeMachine(wm, executionTrace);\n\n\t\t\t\t//love you\n\t\t\t\tlong time = System.currentTimeMillis();\n\t\t\t\twm.fireAllRules(scenario.maxRuleFirings);\n\t\t\t\texecutionTrace.executionTimeResult = System.currentTimeMillis() - time;\n\t\t\t} else if (fx instanceof Expectation) {\n\t\t\t\t\tExpectation assertion = (Expectation) fx;\n\t\t\t\t\tif (assertion instanceof VerifyFact) {\n\t\t\t\t\t\tverify((VerifyFact) assertion);\n\t\t\t\t\t} else if (assertion instanceof VerifyRuleFired) {\n\t\t\t\t\t\tverify((VerifyRuleFired) assertion,\n\t\t\t\t\t\t\t\t(listener.firingCounts != null) ? listener.firingCounts : new HashMap<String, Integer>());\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"Not sure what to do with \" + fx);\n\t\t\t}\n\n\n\n\t\t}\n\n\n\n\n\n\n\n\t}","id":106382,"modified_method":"/**\n\t * @param scenario\n\t *            The scenario to run.\n\t * @param resolver\n\t *            A populated type resolved to be used to resolve the types in\n\t *            the scenario.\n\t *\n\t * For info on how to invoke this, see\n\t * ContentPackageAssemblerTest.testPackageWithRuleflow in drools-jbrms This\n\t * requires that the classloader for the thread context be set\n\t * appropriately. The PackageBuilder can provide a suitable TypeResolver for\n\t * a given package header, and the Package config can provide a classloader.\n\t *\n\t */\n\tpublic ScenarioRunner(final Scenario scenario, final TypeResolver resolver,\n\t\t\tfinal InternalWorkingMemory wm) throws ClassNotFoundException {\n\t\tthis.scenario = scenario;\n\t\tthis.workingMemory = wm;\n\t\tscenario.lastRunResult = new Date();\n\n\t\t//stub out any rules we don't want to have the consequences firing of.\n\t\tHashSet<String> ruleList = new HashSet<String>();\n\t\truleList.addAll(scenario.rules);\n\t\tTestingEventListener.stubOutRules(ruleList, wm.getRuleBase(), scenario.inclusive);\n\n\t\tTestingEventListener listener = null;\n\n\t\tfor (Iterator iterator = scenario.globals.iterator(); iterator.hasNext();) {\n\t\t\tFactData fact = (FactData) iterator.next();\n\t\t\tObject f = eval(\"new \" + resolver.getFullTypeName(fact.type) + \"()\");\n\t\t\tpopulateFields(fact, globalData, f);\n\t\t\tglobalData.put(fact.name, f);\n\t\t\twm.setGlobal(fact.name, f);\n\t\t}\n\n\t\tfor (Iterator<Fixture> iterator = scenario.fixtures.iterator(); iterator.hasNext();) {\n\t\t\tFixture fx = iterator.next();\n\n\t\t\tif (fx instanceof FactData) {\n\t\t\t\t//deal with facts and globals\n\t\t\t\tFactData fact = (FactData)fx;\n\t\t\t\tObject f = (fact.isModify)? this.populatedData.get(fact.name) : eval(\"new \" + resolver.getFullTypeName(fact.type) + \"()\");\n\t\t\t\tif (fact.isModify) {\n\t\t\t\t\tif (!this.factHandles.containsKey(fact.name)) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Was not a previously inserted fact. [\" + fact.name  + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tpopulateFields(fact, populatedData, f);\n\t\t\t\t\tthis.workingMemory.update(this.factHandles.get(fact.name), f);\n\t\t\t\t} else /* a new one */ {\n\t\t\t\t\tpopulateFields(fact, populatedData, f);\n\t\t\t\t\tpopulatedData.put(fact.name, f);\n\t\t\t\t\tthis.factHandles.put(fact.name, wm.insert(f));\n\t\t\t\t}\n\t\t\t} else if (fx instanceof RetractFact) {\n\t\t\t\tRetractFact f = (RetractFact)fx;\n\t\t\t\tthis.workingMemory.retract(this.factHandles.get(f.name));\n\t\t\t\tthis.populatedData.remove(f.name);\n\t\t\t} else if (fx instanceof ExecutionTrace) {\n\t\t\t\tExecutionTrace executionTrace = (ExecutionTrace)fx;\n\t\t\t\t//create the listener to trace rules\n\n\t\t\t\tif (listener != null) wm.removeEventListener(listener); //remove the old\n\t\t\t\tlistener = new TestingEventListener();\n\n\t\t\t\twm.addEventListener(listener);\n\n\t\t\t\t//set up the time machine\n\t\t\t\tapplyTimeMachine(wm, executionTrace);\n\n\t\t\t\t//love you\n\t\t\t\tlong time = System.currentTimeMillis();\n\t\t\t\twm.fireAllRules(scenario.maxRuleFirings);\n\t\t\t\texecutionTrace.executionTimeResult = System.currentTimeMillis() - time;\n\t\t\t\texecutionTrace.numberOfRulesFired = listener.totalFires;\n\n\t\t\t} else if (fx instanceof Expectation) {\n\t\t\t\t\tExpectation assertion = (Expectation) fx;\n\t\t\t\t\tif (assertion instanceof VerifyFact) {\n\t\t\t\t\t\tverify((VerifyFact) assertion);\n\t\t\t\t\t} else if (assertion instanceof VerifyRuleFired) {\n\t\t\t\t\t\tverify((VerifyRuleFired) assertion,\n\t\t\t\t\t\t\t\t(listener.firingCounts != null) ? listener.firingCounts : new HashMap<String, Integer>());\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"Not sure what to do with \" + fx);\n\t\t\t}\n\n\n\n\t\t}\n\n\n\n\n\n\n\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void applyTimeMachine(final InternalWorkingMemory wm,\n\t\t\tExecutionTrace executionTrace) {\n\t\tif (executionTrace.scenarioSimulatedDate != null) {\n\t\t\tfinal Calendar now = Calendar.getInstance();\n\t\t\tnow.setTimeInMillis(executionTrace.scenarioSimulatedDate.getTime());\n\t\t\twm.setTimeMachine(new TimeMachine() {\n\t\t\t\t@Override\n\t\t\t\tpublic Calendar getNow() {\n\t\t\t\t\treturn now;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}","id":106383,"modified_method":"private void applyTimeMachine(final InternalWorkingMemory wm,\n\t\t\tExecutionTrace executionTrace) {\n\t\tif (executionTrace.scenarioSimulatedDate != null) {\n\t\t\tfinal Calendar now = Calendar.getInstance();\n\t\t\tnow.setTimeInMillis(executionTrace.scenarioSimulatedDate.getTime());\n\t\t\twm.setTimeMachine(new TimeMachine() {\n\t\t\t\t@Override\n\t\t\t\tpublic Calendar getNow() {\n\t\t\t\t\treturn now;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t//normal time.\n\t\t\twm.setTimeMachine(new TimeMachine());\n\t\t}\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n\t * Do a kind of end to end test with some real rules.\n\t */\n\tpublic void testIntegrationWithSuccess() throws Exception {\n\n\t\tScenario sc = new Scenario();\n\t\tFactData[] facts = new FactData[] {\n\t\t\t\tnew FactData(\"Cheese\", \"c1\", new FieldData[] {\n\t\t\t\t\t\tnew FieldData(\"type\", \"cheddar\", false),\n\t\t\t\t\t\tnew FieldData(\"price\", \"42\", false) },  false)\n\n\t\t\t\t};\n\t\tsc.globals.add(new FactData(\"Person\", \"p\", new FieldData[0] , false));\n\t\tsc.fixtures.addAll(Arrays.asList(facts));\n\n\t\tExecutionTrace executionTrace = new ExecutionTrace();\n\n\t\texecutionTrace.rules = new String[] {\"rule1\", \"rule2\" };\n\t\texecutionTrace.inclusive = true;\n\t\tsc.fixtures.add(executionTrace);\n\n\t\tExpectation[] assertions = new Expectation[5];\n\n\t\tassertions[0] =\tnew VerifyFact(\"c1\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"type\", \"cheddar\")\n\n\t\t});\n\n\t\tassertions[1] = new VerifyFact(\"p\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"name\", \"rule1\"),\n\t\t\t\t\tnew VerifyField(\"status\", \"rule2\")\n\n\t\t});\n\n\t\tassertions[2] = new VerifyRuleFired(\"rule1\", 1, null);\n\t\tassertions[3] = new VerifyRuleFired(\"rule2\", 1, null);\n\t\tassertions[4] = new VerifyRuleFired(\"rule3\", 1, null);\n\n\t\tsc.fixtures.addAll(Arrays.asList(assertions));\n\n\t\tTypeResolver resolver = new ClassTypeResolver(new HashSet<Object>(),\n\t\t\t\tThread.currentThread().getContextClassLoader());\n\t\tresolver.addImport(\"org.drools.Cheese\");\n\t\tresolver.addImport(\"org.drools.Person\");\n\n        WorkingMemory wm = getWorkingMemory(\"test_rules2.drl\");\n\n        ScenarioRunner run = new ScenarioRunner(sc, resolver, (InternalWorkingMemory) wm);\n\n        assertSame(run.scenario, sc);\n\n        assertTrue(sc.wasSuccessful());\n\n        Person p = (Person) run.globalData.get(\"p\");\n        assertEquals(\"rule1\", p.getName());\n        assertEquals(\"rule2\", p.getStatus());\n        assertEquals(0, p.getAge());\n\n\n        assertTrue((new Date()).after(sc.lastRunResult));\n        assertTrue(executionTrace.executionTimeResult != -1);\n\n\t}","id":106384,"modified_method":"/**\n\t * Do a kind of end to end test with some real rules.\n\t */\n\tpublic void testIntegrationWithSuccess() throws Exception {\n\n\t\tScenario sc = new Scenario();\n\t\tFactData[] facts = new FactData[] {\n\t\t\t\tnew FactData(\"Cheese\", \"c1\", new FieldData[] {\n\t\t\t\t\t\tnew FieldData(\"type\", \"cheddar\", false),\n\t\t\t\t\t\tnew FieldData(\"price\", \"42\", false) },  false)\n\n\t\t\t\t};\n\t\tsc.globals.add(new FactData(\"Person\", \"p\", new FieldData[0] , false));\n\t\tsc.fixtures.addAll(Arrays.asList(facts));\n\n\t\tExecutionTrace executionTrace = new ExecutionTrace();\n\n\n\t\tsc.rules.add(\"rule1\");\n\t\tsc.rules.add(\"rule2\");\n\t\tsc.inclusive = true;\n\t\tsc.fixtures.add(executionTrace);\n\n\t\tExpectation[] assertions = new Expectation[5];\n\n\t\tassertions[0] =\tnew VerifyFact(\"c1\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"type\", \"cheddar\")\n\n\t\t});\n\n\t\tassertions[1] = new VerifyFact(\"p\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"name\", \"rule1\"),\n\t\t\t\t\tnew VerifyField(\"status\", \"rule2\")\n\n\t\t});\n\n\t\tassertions[2] = new VerifyRuleFired(\"rule1\", 1, null);\n\t\tassertions[3] = new VerifyRuleFired(\"rule2\", 1, null);\n\t\tassertions[4] = new VerifyRuleFired(\"rule3\", 1, null);\n\n\t\tsc.fixtures.addAll(Arrays.asList(assertions));\n\n\t\tTypeResolver resolver = new ClassTypeResolver(new HashSet<Object>(),\n\t\t\t\tThread.currentThread().getContextClassLoader());\n\t\tresolver.addImport(\"org.drools.Cheese\");\n\t\tresolver.addImport(\"org.drools.Person\");\n\n        WorkingMemory wm = getWorkingMemory(\"test_rules2.drl\");\n\n        ScenarioRunner run = new ScenarioRunner(sc, resolver, (InternalWorkingMemory) wm);\n\n        assertEquals(3, executionTrace.numberOfRulesFired);\n\n        assertSame(run.scenario, sc);\n\n        assertTrue(sc.wasSuccessful());\n\n        Person p = (Person) run.globalData.get(\"p\");\n        assertEquals(\"rule1\", p.getName());\n        assertEquals(\"rule2\", p.getStatus());\n        assertEquals(0, p.getAge());\n\n\n        assertTrue((new Date()).after(sc.lastRunResult));\n        assertTrue(executionTrace.executionTimeResult != -1);\n\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testTestingEventListener() throws Exception {\n\t\tScenario sc = new Scenario();\n\t\tExecutionTrace ext = new ExecutionTrace();\n\n\t\text.rules = new String[] { \"foo\", \"bar\" };\n\t\tsc.fixtures.add(ext);\n\n\t\tMockWorkingMemory wm = new MockWorkingMemory();\n\t\tScenarioRunner run = new ScenarioRunner(sc, null, wm);\n\t\tassertEquals(wm, run.workingMemory);\n\t\tassertNotNull(wm.agendaEventListener);\n\t\tassertTrue(wm.agendaEventListener instanceof TestingEventListener);\n\t\tTestingEventListener lnr = (TestingEventListener) wm.agendaEventListener;\n\t\tassertEquals(2, lnr.ruleNames.size());\n\t\tassertTrue(lnr.ruleNames.contains(\"foo\"));\n\t\tassertTrue(lnr.ruleNames.contains(\"bar\"));\n\t}","id":106385,"modified_method":"public void testTestingEventListener() throws Exception {\n\t\tScenario sc = new Scenario();\n\t\tsc.rules.add(\"foo\"); sc.rules.add(\"bar\");\n\t\tExecutionTrace ext = new ExecutionTrace();\n\n\n\n\n\t\tsc.fixtures.add(ext);\n\n\t\tMockWorkingMemory wm = new MockWorkingMemory();\n\t\tScenarioRunner run = new ScenarioRunner(sc, null, wm);\n\t\tassertEquals(wm, run.workingMemory);\n\t\tassertNotNull(wm.agendaEventListener);\n\t\tassertTrue(wm.agendaEventListener instanceof TestingEventListener);\n\t\tTestingEventListener lnr = (TestingEventListener) wm.agendaEventListener;\n\t\tassertEquals(2, sc.rules.size());\n\t\tassertTrue(sc.rules.contains(\"foo\"));\n\t\tassertTrue(sc.rules.contains(\"bar\"));\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testIntegrationWithFailure() throws Exception {\n\t\tScenario sc = new Scenario();\n\t\tFactData[] facts = new FactData[] {\n\t\t\t\tnew FactData(\"Cheese\", \"c1\", new FieldData[] {\n\t\t\t\t\t\tnew FieldData(\"type\", \"cheddar\", false),\n\t\t\t\t\t\tnew FieldData(\"price\", \"42\", false) }, false)\n\n\t\t\t\t};\n\t\tsc.fixtures.addAll(Arrays.asList(facts));\n\t\tsc.globals.add(new FactData(\"Person\", \"p\", new FieldData[0] , false));\n\n\t\tExecutionTrace executionTrace = new ExecutionTrace();\n\t\texecutionTrace.rules = new String[] {\"rule1\", \"rule2\" };\n\t\texecutionTrace.inclusive = true;\n\t\tsc.fixtures.add(executionTrace);\n\n\t\tExpectation[] assertions = new Expectation[5];\n\n\t\tassertions[0] =\tnew VerifyFact(\"c1\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"type\", \"cheddar\")\n\n\t\t});\n\n\t\tassertions[1] = new VerifyFact(\"p\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"name\", \"XXX\"),\n\t\t\t\t\tnew VerifyField(\"status\", \"rule2\")\n\n\t\t});\n\n\t\tassertions[2] = new VerifyRuleFired(\"rule1\", 1, null);\n\t\tassertions[3] = new VerifyRuleFired(\"rule2\", 1, null);\n\t\tassertions[4] = new VerifyRuleFired(\"rule3\", 2, null);\n\n\t\tsc.fixtures.addAll(Arrays.asList(assertions));\n\n\t\tTypeResolver resolver = new ClassTypeResolver(new HashSet<Object>(),\n\t\t\t\tThread.currentThread().getContextClassLoader());\n\t\tresolver.addImport(\"org.drools.Cheese\");\n\t\tresolver.addImport(\"org.drools.Person\");\n\n        WorkingMemory wm = getWorkingMemory(\"test_rules2.drl\");\n\n        ScenarioRunner run = new ScenarioRunner(sc, resolver, (InternalWorkingMemory) wm);\n\n        assertSame(run.scenario, sc);\n\n        assertFalse(sc.wasSuccessful());\n\n        VerifyFact vf = (VerifyFact) assertions[1];\n        assertFalse(vf.fieldValues[0].successResult);\n        assertEquals(\"XXX\", vf.fieldValues[0].expected);\n        assertEquals(\"rule1\", vf.fieldValues[0].actualResult);\n\n        VerifyRuleFired vr = (VerifyRuleFired) assertions[4];\n        assertFalse(vr.successResult);\n\n        assertEquals(2, vr.expectedCount.intValue());\n        assertEquals(1, vr.actualResult.intValue());\n\n\n\t}","id":106386,"modified_method":"public void testIntegrationWithFailure() throws Exception {\n\t\tScenario sc = new Scenario();\n\t\tFactData[] facts = new FactData[] {\n\t\t\t\tnew FactData(\"Cheese\", \"c1\", new FieldData[] {\n\t\t\t\t\t\tnew FieldData(\"type\", \"cheddar\", false),\n\t\t\t\t\t\tnew FieldData(\"price\", \"42\", false) }, false)\n\n\t\t\t\t};\n\t\tsc.fixtures.addAll(Arrays.asList(facts));\n\t\tsc.globals.add(new FactData(\"Person\", \"p\", new FieldData[0] , false));\n\n\t\tExecutionTrace executionTrace = new ExecutionTrace();\n\t\tsc.rules.add(\"rule1\");\n\t\tsc.rules.add(\"rule2\");\n\t\tsc.inclusive = true;\n\t\tsc.fixtures.add(executionTrace);\n\n\t\tExpectation[] assertions = new Expectation[5];\n\n\t\tassertions[0] =\tnew VerifyFact(\"c1\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"type\", \"cheddar\")\n\n\t\t});\n\n\t\tassertions[1] = new VerifyFact(\"p\", new VerifyField[] {\n\t\t\t\t\tnew VerifyField(\"name\", \"XXX\"),\n\t\t\t\t\tnew VerifyField(\"status\", \"rule2\")\n\n\t\t});\n\n\t\tassertions[2] = new VerifyRuleFired(\"rule1\", 1, null);\n\t\tassertions[3] = new VerifyRuleFired(\"rule2\", 1, null);\n\t\tassertions[4] = new VerifyRuleFired(\"rule3\", 2, null);\n\n\t\tsc.fixtures.addAll(Arrays.asList(assertions));\n\n\t\tTypeResolver resolver = new ClassTypeResolver(new HashSet<Object>(),\n\t\t\t\tThread.currentThread().getContextClassLoader());\n\t\tresolver.addImport(\"org.drools.Cheese\");\n\t\tresolver.addImport(\"org.drools.Person\");\n\n        WorkingMemory wm = getWorkingMemory(\"test_rules2.drl\");\n\n        ScenarioRunner run = new ScenarioRunner(sc, resolver, (InternalWorkingMemory) wm);\n\n        assertSame(run.scenario, sc);\n\n        assertFalse(sc.wasSuccessful());\n\n        VerifyFact vf = (VerifyFact) assertions[1];\n        assertFalse(vf.fieldValues[0].successResult);\n        assertEquals(\"XXX\", vf.fieldValues[0].expected);\n        assertEquals(\"rule1\", vf.fieldValues[0].actualResult);\n\n        VerifyRuleFired vr = (VerifyRuleFired) assertions[4];\n        assertFalse(vr.successResult);\n\n        assertEquals(2, vr.expectedCount.intValue());\n        assertEquals(1, vr.actualResult.intValue());\n\n\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void record(Rule rule, Map<String, Integer> counts) {\n\t\tString name = rule.getName();\n\t\tif (!counts.containsKey(name)) {\n\t\t\tcounts.put(name, 1);\n\t\t} else {\n\t\t\tcounts.put(name, counts.get(name) + 1);\n\t\t}\n\t}","id":106387,"modified_method":"private void record(Rule rule, Map<String, Integer> counts) {\n\t\tthis.totalFires++;\n\t\tString name = rule.getName();\n\t\tif (!counts.containsKey(name)) {\n\t\t\tcounts.put(name, 1);\n\t\t} else {\n\t\t\tcounts.put(name, counts.get(name) + 1);\n\t\t}\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testInclusive() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tset.add(\"rule1\");\n\t\tset.add(\"rule2\");\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n        TestingEventListener ls = new TestingEventListener(set, session.getRuleBase(), true);\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertTrue(ls.firingCounts.containsKey(\"rule3\"));\n        assertFalse(ls.firingCounts.containsKey(\"rule4\"));\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule2\"));\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule3\"));\n\n\t}","id":106388,"modified_method":"public void testInclusive() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tset.add(\"rule1\");\n\t\tset.add(\"rule2\");\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n\n        TestingEventListener ls = new TestingEventListener();\n        TestingEventListener.stubOutRules(set, session.getRuleBase(), true);\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertTrue(ls.firingCounts.containsKey(\"rule3\"));\n        assertFalse(ls.firingCounts.containsKey(\"rule4\"));\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule2\"));\n        assertEquals(new Integer(2), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertEquals(6, ls.totalFires);\n\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testNoFilter() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n\n        TestingEventListener ls = new TestingEventListener(set, session.getRuleBase(), false);\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n\n        List<String> list = new ArrayList<String>();\n        session.setGlobal(\"list\", list);\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertEquals(1, list.size());\n\t}","id":106389,"modified_method":"public void testNoFilter() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n\n        TestingEventListener ls = new TestingEventListener();\n        TestingEventListener.stubOutRules(set, session.getRuleBase(), false);\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n\n        List<String> list = new ArrayList<String>();\n        session.setGlobal(\"list\", list);\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertEquals(1, list.size());\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testExclusive() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tset.add(\"rule3\");\n\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n\n        TestingEventListener ls = new TestingEventListener(set, session.getRuleBase(), false);\n\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertTrue(ls.firingCounts.containsKey(\"rule3\"));\n        assertFalse(ls.firingCounts.containsKey(\"rule4\"));\n\n\n\t}","id":106390,"modified_method":"public void testExclusive() throws Exception {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tset.add(\"rule3\");\n\n\n\t\tStatefulSession session  = getWorkingMemory(\"test_rules.drl\");\n\n        TestingEventListener ls = new TestingEventListener();\n        TestingEventListener.stubOutRules(set, session.getRuleBase(), false);\n\n        session.addEventListener(ls);\n\n        session.insert(new Cheese());\n        session.fireAllRules();\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule1\"));\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule2\"));\n\n        assertEquals(new Integer(1), (Integer) ls.firingCounts.get(\"rule3\"));\n        assertTrue(ls.firingCounts.containsKey(\"rule3\"));\n        assertFalse(ls.firingCounts.containsKey(\"rule4\"));\n\n\n\t}","commit_id":"54fb8bdee87e77ae5f55f915af2de0b416fdee36","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected JweDecryptionProvider getInitializedDecryptionProvider(String clientSecret) {\n        JweDecryptionProvider theDecryptionProvider = null;\n        if (decryptWithClientSecret) {\n            SecretKey key = CryptoUtils.decodeSecretKey(clientSecret);\n            theDecryptionProvider = JweUtils.getDirectKeyJweDecryption(key, ContentAlgorithm.A128GCM);\n        }\n        return theDecryptionProvider;\n        \n    }","id":106391,"modified_method":"protected JweDecryptionProvider getInitializedDecryptionProvider(String clientSecret) {\n        JweDecryptionProvider theDecryptionProvider = null;\n        if (decryptWithClientSecret) {\n            SecretKey key = CryptoUtils.decodeSecretKey(clientSecret);\n            Properties props = JweUtils.loadEncryptionInProperties(false);\n            ContentAlgorithm ctAlgo = JweUtils.getContentEncryptionAlgorithm(props, ContentAlgorithm.A128GCM);\n            theDecryptionProvider = JweUtils.getDirectKeyJweDecryption(key, ctAlgo);\n        }\n        return theDecryptionProvider;\n        \n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"protected JweEncryptionProvider getInitializedEncryptionProvider(String clientSecret) {\n        if (encryptWithClientSecret) {\n            SecretKey key = CryptoUtils.decodeSecretKey(clientSecret);\n            return JweUtils.getDirectKeyJweEncryption(key, ContentAlgorithm.A128GCM);\n        }\n        return null;\n    }","id":106392,"modified_method":"protected JweEncryptionProvider getInitializedEncryptionProvider(String clientSecret) {\n        if (encryptWithClientSecret) {\n            SecretKey key = CryptoUtils.decodeSecretKey(clientSecret);\n            Properties props = JweUtils.loadEncryptionOutProperties(false);\n            ContentAlgorithm ctAlgo = JweUtils.getContentEncryptionAlgorithm(props, ContentAlgorithm.A128GCM);\n            return JweUtils.getDirectKeyJweEncryption(key, ctAlgo);\n        }\n        return null;\n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"protected JwsSignatureProvider getInitializedSignatureProvider(String clientSecret) {\n        if (signWithClientSecret) {\n            Properties props = JwsUtils.loadSignatureOutProperties(false);\n            SignatureAlgorithm sigAlgo = JwsUtils.getSignatureAlgorithm(props, SignatureAlgorithm.HS256);\n            if (AlgorithmUtils.isHmacSign(sigAlgo)) {\n                return JwsUtils.getHmacSignatureProvider(clientSecret, SignatureAlgorithm.HS256);\n            }\n        }\n        return null;\n    }","id":106393,"modified_method":"protected JwsSignatureProvider getInitializedSignatureProvider(String clientSecret) {\n        if (signWithClientSecret) {\n            Properties props = JwsUtils.loadSignatureOutProperties(false);\n            SignatureAlgorithm sigAlgo = JwsUtils.getSignatureAlgorithm(props, SignatureAlgorithm.HS256);\n            if (AlgorithmUtils.isHmacSign(sigAlgo)) {\n                return JwsUtils.getHmacSignatureProvider(clientSecret, sigAlgo);\n            }\n        }\n        return null;\n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private static String getContentEncryptionAlgo(Message m, Properties props, String algo) {\n        if (algo == null) {\n            // Check for deprecated identifier first\n            String encAlgo = props.getProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_CONTENT_ALGORITHM);\n            if (encAlgo == null && m != null) {\n                encAlgo = (String)m.getContextualProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_CONTENT_ALGORITHM);\n            }\n            if (encAlgo != null) {\n                return encAlgo;\n            }\n            \n            // Otherwise check newer identifier\n            return KeyManagementUtils.getKeyAlgorithm(m, props, \n                                                      JoseConstants.RSSEC_ENCRYPTION_CONTENT_ALGORITHM, \n                                                      AlgorithmUtils.A128GCM_ALGO);\n        }\n        return algo;\n    }","id":106394,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public static ContentAlgorithm getContentEncryptionAlgorithm(Message m, \n                                                       Properties props, \n                                                       ContentAlgorithm algo,\n                                                       ContentAlgorithm defaultAlgo) {\n        if (algo == null) {\n            // Check for deprecated identifier first\n            String encAlgo = props.getProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_CONTENT_ALGORITHM);\n            if (encAlgo == null && m != null) {\n                encAlgo = (String)m.getContextualProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_CONTENT_ALGORITHM);\n            }\n            if (encAlgo != null) {\n                return ContentAlgorithm.getAlgorithm(encAlgo);\n            }\n            \n            return getContentEncryptionAlgorithm(props, defaultAlgo);\n        }\n        return algo;\n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"public static JweDecryptionProvider loadDecryptionProvider(Properties props, \n                                                               JweHeaders inHeaders, \n                                                               boolean required) {\n        \n        Message m = PhaseInterceptorChain.getCurrentMessage();\n        KeyDecryptionProvider keyDecryptionProvider = null;\n        String contentEncryptionAlgo = getContentEncryptionAlgo(m, props, null);\n        SecretKey ctDecryptionKey = null;\n        KeyAlgorithm keyAlgo = getKeyEncryptionAlgorithm(m, props, null, null);\n        if (inHeaders != null && inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n            // Supporting loading a private key via a certificate for now\n            List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n            KeyManagementUtils.validateCertificateChain(props, chain);\n            X509Certificate cert = chain == null ? null : chain.get(0);\n            PrivateKey privateKey = \n                KeyManagementUtils.loadPrivateKey(m, props, cert, KeyOperation.DECRYPT);\n            contentEncryptionAlgo = inHeaders.getContentEncryptionAlgorithm().getJwaName();\n            keyDecryptionProvider = getPrivateKeyDecryptionProvider(privateKey, \n                                                                 inHeaders.getKeyEncryptionAlgorithm());\n        } else if (inHeaders != null && inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n            X509Certificate foundCert = \n                KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                MessageDigestUtils.ALGO_SHA_1,\n                                                                m, props);\n            if (foundCert != null) {\n                PrivateKey privateKey = \n                    KeyManagementUtils.loadPrivateKey(m, props, foundCert, KeyOperation.DECRYPT);\n                contentEncryptionAlgo = inHeaders.getContentEncryptionAlgorithm().getJwaName();\n                keyDecryptionProvider = getPrivateKeyDecryptionProvider(privateKey, \n                                                                     inHeaders.getKeyEncryptionAlgorithm());\n            }\n        } else {\n            if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.DECRYPT);\n                if (jwk == null) {\n                    LOG.warning(\"Extracting the JsonWebKey failed\");\n                    throw new JweException(JweException.Error.KEY_DECRYPTION_FAILURE);\n                }\n                \n                if (\"direct\".equals(keyAlgo.getJwaName())) {\n                    contentEncryptionAlgo = getContentEncryptionAlgo(m, props, jwk.getAlgorithm());\n                    ctDecryptionKey = getContentDecryptionSecretKey(jwk, contentEncryptionAlgo);\n                } else {\n                    keyAlgo = getKeyEncryptionAlgorithm(m, props, \n                                                        KeyAlgorithm.getAlgorithm(jwk.getAlgorithm()),\n                                                        getDefaultKeyAlgorithm(jwk));\n                    keyDecryptionProvider = getKeyDecryptionProvider(jwk, keyAlgo);\n                }\n            } else {\n                keyDecryptionProvider = getPrivateKeyDecryptionProvider(\n                    KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.DECRYPT), \n                    keyAlgo);\n            }\n        }\n        return createJweDecryptionProvider(keyDecryptionProvider, ctDecryptionKey, \n                                           getContentAlgo(contentEncryptionAlgo));\n    }","id":106395,"modified_method":"public static JweDecryptionProvider loadDecryptionProvider(Properties props, \n                                                               JweHeaders inHeaders, \n                                                               boolean required) {\n        \n        Message m = PhaseInterceptorChain.getCurrentMessage();\n        KeyDecryptionProvider keyDecryptionProvider = null;\n        ContentAlgorithm contentAlgo = \n            getContentEncryptionAlgorithm(m, props, null, ContentAlgorithm.A128GCM);\n        SecretKey ctDecryptionKey = null;\n        KeyAlgorithm keyAlgo = getKeyEncryptionAlgorithm(m, props, null, null);\n        if (inHeaders != null && inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n            // Supporting loading a private key via a certificate for now\n            List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n            KeyManagementUtils.validateCertificateChain(props, chain);\n            X509Certificate cert = chain == null ? null : chain.get(0);\n            PrivateKey privateKey = \n                KeyManagementUtils.loadPrivateKey(m, props, cert, KeyOperation.DECRYPT);\n            contentAlgo = inHeaders.getContentEncryptionAlgorithm();\n            keyDecryptionProvider = getPrivateKeyDecryptionProvider(privateKey, \n                                                                 inHeaders.getKeyEncryptionAlgorithm());\n        } else if (inHeaders != null && inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n            X509Certificate foundCert = \n                KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                MessageDigestUtils.ALGO_SHA_1,\n                                                                m, props);\n            if (foundCert != null) {\n                PrivateKey privateKey = \n                    KeyManagementUtils.loadPrivateKey(m, props, foundCert, KeyOperation.DECRYPT);\n                contentAlgo = inHeaders.getContentEncryptionAlgorithm();\n                keyDecryptionProvider = getPrivateKeyDecryptionProvider(privateKey, \n                                                                     inHeaders.getKeyEncryptionAlgorithm());\n            }\n        } else {\n            if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.DECRYPT);\n                if (jwk == null) {\n                    LOG.warning(\"Extracting the JsonWebKey failed\");\n                    throw new JweException(JweException.Error.KEY_DECRYPTION_FAILURE);\n                }\n                \n                if (\"direct\".equals(keyAlgo.getJwaName())) {\n                    contentAlgo = getContentEncryptionAlgorithm(m, props, \n                                                ContentAlgorithm.getAlgorithm(jwk.getAlgorithm()),\n                                                ContentAlgorithm.A128GCM);\n                    ctDecryptionKey = getContentDecryptionSecretKey(jwk, contentAlgo.getJwaName());\n                } else {\n                    keyAlgo = getKeyEncryptionAlgorithm(m, props, \n                                                        KeyAlgorithm.getAlgorithm(jwk.getAlgorithm()),\n                                                        getDefaultKeyAlgorithm(jwk));\n                    keyDecryptionProvider = getKeyDecryptionProvider(jwk, keyAlgo);\n                }\n            } else {\n                keyDecryptionProvider = getPrivateKeyDecryptionProvider(\n                    KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.DECRYPT), \n                    keyAlgo);\n            }\n        }\n        return createJweDecryptionProvider(keyDecryptionProvider, ctDecryptionKey, \n                                           contentAlgo);\n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    public static JweEncryptionProvider loadEncryptionProvider(Properties props, JweHeaders headers, boolean required) {\n        Message m = PhaseInterceptorChain.getCurrentMessage();\n        \n        boolean includeCert = \n            headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_CERT, false);\n        boolean includeCertSha1 = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_CERT_SHA1, false);\n        \n        KeyEncryptionProvider keyEncryptionProvider = null;\n        KeyAlgorithm keyAlgo = getKeyEncryptionAlgorithm(m, props, null, null);\n        String contentEncryptionAlgo = getContentEncryptionAlgo(m, props, null);\n        if (m != null) {\n            m.put(JoseConstants.RSSEC_ENCRYPTION_CONTENT_ALGORITHM, contentEncryptionAlgo);\n        }\n        ContentEncryptionProvider ctEncryptionProvider = null;\n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.ENCRYPT);\n            if (\"direct\".equals(keyAlgo.getJwaName())) {\n                contentEncryptionAlgo = getContentEncryptionAlgo(m, props, jwk.getAlgorithm());\n                ctEncryptionProvider = getContentEncryptionProvider(jwk, contentEncryptionAlgo);\n            } else {\n                keyAlgo = getKeyEncryptionAlgorithm(m, props, \n                                                    KeyAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                    getDefaultKeyAlgorithm(jwk));\n                keyEncryptionProvider = getKeyEncryptionProvider(jwk, keyAlgo);\n                \n                boolean includePublicKey = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_PUBLIC_KEY, false);\n                boolean includeKeyId = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_KEY_ID, false);\n                \n                if (includeCert) {\n                    JwkUtils.includeCertChain(jwk, headers, keyAlgo.getJwaName());\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n                if (includePublicKey) {\n                    JwkUtils.includePublicKey(jwk, headers, keyAlgo.getJwaName());\n                }\n                if (includeKeyId && jwk.getKeyId() != null && headers != null) {\n                    headers.setKeyId(jwk.getKeyId());\n                }\n            }\n        } else {\n            keyEncryptionProvider = getPublicKeyEncryptionProvider(\n                KeyManagementUtils.loadPublicKey(m, props), \n                keyAlgo);\n            if (includeCert) {\n                headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));\n            }\n            if (includeCertSha1) {\n                String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                if (digest != null) {\n                    headers.setX509Thumbprint(digest);\n                }\n            }\n        }\n        \n        String compression = props.getProperty(JoseConstants.RSSEC_ENCRYPTION_ZIP_ALGORITHM);\n        if (compression == null) {\n            compression = props.getProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_ZIP_ALGORITHM);\n        }\n        return createJweEncryptionProvider(keyEncryptionProvider, \n                                    ctEncryptionProvider, \n                                    contentEncryptionAlgo,\n                                    compression);\n    }","id":106396,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public static JweEncryptionProvider loadEncryptionProvider(Properties props, JweHeaders headers, boolean required) {\n        Message m = PhaseInterceptorChain.getCurrentMessage();\n        \n        boolean includeCert = \n            headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_CERT, false);\n        boolean includeCertSha1 = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_CERT_SHA1, false);\n        \n        KeyEncryptionProvider keyEncryptionProvider = null;\n        KeyAlgorithm keyAlgo = getKeyEncryptionAlgorithm(m, props, null, null);\n        ContentAlgorithm contentAlgo = getContentEncryptionAlgorithm(m, props, null, ContentAlgorithm.A128GCM);\n        if (m != null) {\n            m.put(JoseConstants.RSSEC_ENCRYPTION_CONTENT_ALGORITHM, contentAlgo.getJwaName());\n        }\n        ContentEncryptionProvider ctEncryptionProvider = null;\n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.ENCRYPT);\n            if (\"direct\".equals(keyAlgo.getJwaName())) {\n                contentAlgo = getContentEncryptionAlgorithm(m, props, \n                                            ContentAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                            ContentAlgorithm.A128GCM);\n                ctEncryptionProvider = getContentEncryptionProvider(jwk, contentAlgo.getJwaName());\n            } else {\n                keyAlgo = getKeyEncryptionAlgorithm(m, props, \n                                                    KeyAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                    getDefaultKeyAlgorithm(jwk));\n                keyEncryptionProvider = getKeyEncryptionProvider(jwk, keyAlgo);\n                \n                boolean includePublicKey = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_PUBLIC_KEY, false);\n                boolean includeKeyId = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_ENCRYPTION_INCLUDE_KEY_ID, false);\n                \n                if (includeCert) {\n                    JwkUtils.includeCertChain(jwk, headers, keyAlgo.getJwaName());\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n                if (includePublicKey) {\n                    JwkUtils.includePublicKey(jwk, headers, keyAlgo.getJwaName());\n                }\n                if (includeKeyId && jwk.getKeyId() != null && headers != null) {\n                    headers.setKeyId(jwk.getKeyId());\n                }\n            }\n        } else {\n            keyEncryptionProvider = getPublicKeyEncryptionProvider(\n                KeyManagementUtils.loadPublicKey(m, props), \n                keyAlgo);\n            if (includeCert) {\n                headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));\n            }\n            if (includeCertSha1) {\n                String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                if (digest != null) {\n                    headers.setX509Thumbprint(digest);\n                }\n            }\n        }\n        \n        String compression = props.getProperty(JoseConstants.RSSEC_ENCRYPTION_ZIP_ALGORITHM);\n        if (compression == null) {\n            compression = props.getProperty(JoseConstants.DEPR_RSSEC_ENCRYPTION_ZIP_ALGORITHM);\n        }\n        return createJweEncryptionProvider(keyEncryptionProvider, \n                                    ctEncryptionProvider, \n                                    contentAlgo.getJwaName(),\n                                    compression);\n    }","commit_id":"c392f8cac8692d5f12cd3d7dd6e478e1871379ce","url":"https://github.com/apache/cxf"},{"original_method":"private void checkAlgorithm() {\n        if (getAlgorithm() == null) {\n            Properties sigProps = getSignatureProperties();\n            Message m = PhaseInterceptorChain.getCurrentMessage();\n            String signatureAlgo = JwsUtils.getSignatureAlgorithm(m, sigProps, null, null);\n            if (signatureAlgo != null) {\n                getJwsHeaders().setSignatureAlgorithm(SignatureAlgorithm.getAlgorithm(signatureAlgo));\n            }\n        }\n        \n        if (getAlgorithm() == null) {\n            throw new JwsException(JwsException.Error.INVALID_ALGORITHM);\n        }\n    }","id":106397,"modified_method":"private void checkAlgorithm() {\n        if (getAlgorithm() == null) {\n            Properties sigProps = getSignatureProperties();\n            Message m = PhaseInterceptorChain.getCurrentMessage();\n            SignatureAlgorithm signatureAlgo = JwsUtils.getSignatureAlgorithm(m, sigProps, null, null);\n            if (signatureAlgo != null) {\n                getJwsHeaders().setSignatureAlgorithm(signatureAlgo);\n            }\n        }\n        \n        if (getAlgorithm() == null) {\n            throw new JwsException(JwsException.Error.INVALID_ALGORITHM);\n        }\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"public static String getSignatureAlgorithm(Properties props, String defaultAlgo) {\n        return KeyManagementUtils.getKeyAlgorithm(PhaseInterceptorChain.getCurrentMessage(),\n                                                  props, \n                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM, \n                                                  defaultAlgo);\n    }","id":106398,"modified_method":"public static SignatureAlgorithm getSignatureAlgorithm(Properties props, \n                                               SignatureAlgorithm defaultAlgo) {\n        String algo = KeyManagementUtils.getKeyAlgorithm(PhaseInterceptorChain.getCurrentMessage(),\n                                                  props, \n                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM, \n                                                  defaultAlgo == null ? null : defaultAlgo.getJwaName());\n        return SignatureAlgorithm.getAlgorithm(algo);\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"public static JwsSignatureProvider loadSignatureProvider(Message m, \n                                                             Properties props,\n                                                             JoseHeaders headers,\n                                                             boolean ignoreNullProvider) {\n        JwsSignatureProvider theSigProvider = null;\n        \n        boolean includeCert = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, false);\n        boolean includeCertSha1 = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1, false);\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);\n            if (jwk != null) {\n                String signatureAlgo = getSignatureAlgorithm(m, props, jwk.getAlgorithm(), getDefaultKeyAlgorithm(jwk));\n                theSigProvider = JwsUtils.getSignatureProvider(jwk, SignatureAlgorithm.getAlgorithm(signatureAlgo));\n                \n                boolean includePublicKey = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY, false);\n                boolean includeKeyId = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, false);\n                \n                if (includeCert) {\n                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo);\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n                if (includePublicKey) {\n                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo);\n                }\n                if (includeKeyId && jwk.getKeyId() != null && headers != null) {\n                    headers.setKeyId(jwk.getKeyId());\n                }\n            }\n        } else {\n            String signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (SignatureAlgorithm.getAlgorithm(signatureAlgo) == SignatureAlgorithm.NONE) {\n                theSigProvider = new NoneJwsSignatureProvider();\n            } else {\n                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);\n                theSigProvider = getPrivateKeySignatureProvider(pk, \n                                                                SignatureAlgorithm.getAlgorithm(signatureAlgo));\n                if (includeCert) {\n                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n            }\n        }\n        if (theSigProvider == null && !ignoreNullProvider) {\n            LOG.warning(\"Provider is not available\");\n            throw new JwsException(JwsException.Error.NO_PROVIDER);\n        }\n        return theSigProvider;\n    }","id":106399,"modified_method":"public static JwsSignatureProvider loadSignatureProvider(Message m, \n                                                             Properties props,\n                                                             JoseHeaders headers,\n                                                             boolean ignoreNullProvider) {\n        JwsSignatureProvider theSigProvider = null;\n        \n        boolean includeCert = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, false);\n        boolean includeCertSha1 = headers != null && MessageUtils.getContextualBoolean(\n                m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1, false);\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);\n            if (jwk != null) {\n                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, \n                                                             props, \n                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                             getDefaultKeyAlgorithm(jwk));\n                theSigProvider = JwsUtils.getSignatureProvider(jwk, signatureAlgo);\n                \n                boolean includePublicKey = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY, false);\n                boolean includeKeyId = headers != null && MessageUtils.getContextualBoolean(\n                    m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, false);\n                \n                if (includeCert) {\n                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo.getJwaName());\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n                if (includePublicKey) {\n                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo.getJwaName());\n                }\n                if (includeKeyId && jwk.getKeyId() != null && headers != null) {\n                    headers.setKeyId(jwk.getKeyId());\n                }\n            }\n        } else {\n            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (signatureAlgo == SignatureAlgorithm.NONE) {\n                theSigProvider = new NoneJwsSignatureProvider();\n            } else {\n                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);\n                theSigProvider = getPrivateKeySignatureProvider(pk, signatureAlgo);\n                if (includeCert) {\n                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));\n                }\n                if (includeCertSha1) {\n                    String digest = KeyManagementUtils.loadDigestAndEncodeX509Certificate(m, props);\n                    if (digest != null) {\n                        headers.setX509Thumbprint(digest);\n                    }\n                }\n            }\n        }\n        if (theSigProvider == null && !ignoreNullProvider) {\n            LOG.warning(\"Provider is not available\");\n            throw new JwsException(JwsException.Error.NO_PROVIDER);\n        }\n        return theSigProvider;\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"private static String getDefaultKeyAlgorithm(JsonWebKey jwk) {\n        KeyType keyType = jwk.getKeyType();\n        if (KeyType.OCTET == keyType) {\n            return AlgorithmUtils.HMAC_SHA_256_ALGO;\n        } else if (KeyType.EC == keyType) {\n            return AlgorithmUtils.ES_SHA_256_ALGO;\n        } else {\n            return AlgorithmUtils.RS_SHA_256_ALGO;\n        }\n    }","id":106400,"modified_method":"private static SignatureAlgorithm getDefaultKeyAlgorithm(JsonWebKey jwk) {\n        KeyType keyType = jwk.getKeyType();\n        if (KeyType.OCTET == keyType) {\n            return SignatureAlgorithm.HS256;\n        } else if (KeyType.EC == keyType) {\n            return SignatureAlgorithm.ES256;\n        } else {\n            return SignatureAlgorithm.RS256;\n        }\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"public static JwsSignatureVerifier loadSignatureVerifier(Message m, \n                                                              Properties props,\n                                                              JwsHeaders inHeaders, \n                                                              boolean ignoreNullVerifier) {\n        JwsSignatureVerifier theVerifier = null;\n        String inHeaderKid = null;\n        if (inHeaders != null) {\n            inHeaderKid = inHeaders.getKeyId();\n            //TODO: optionally validate inHeaders.getAlgorithm against a property in props\n            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {\n                JsonWebKey publicJwk = inHeaders.getJsonWebKey();\n                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())\n                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {\n                    throw new JwsException(JwsException.Error.INVALID_KEY);\n                }\n                return getSignatureVerifier(publicJwk, \n                                            inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n                KeyManagementUtils.validateCertificateChain(props, chain);\n                return getPublicKeySignatureVerifier(chain.get(0).getPublicKey(), \n                                                     inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n                X509Certificate foundCert = \n                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                    MessageDigestUtils.ALGO_SHA_1,\n                                                                    m, props);\n                if (foundCert != null) {\n                    return getPublicKeySignatureVerifier(foundCert.getPublicKey(), \n                                                         inHeaders.getSignatureAlgorithm());\n                }\n            }\n        }\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);\n            if (jwk != null) {\n                String signatureAlgo = getSignatureAlgorithm(m, props, jwk.getAlgorithm(), getDefaultKeyAlgorithm(jwk));\n                theVerifier = getSignatureVerifier(jwk, SignatureAlgorithm.getAlgorithm(signatureAlgo));\n            }\n            \n        } else {\n            String signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (SignatureAlgorithm.getAlgorithm(signatureAlgo) == SignatureAlgorithm.NONE \n                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {\n                theVerifier = new NoneJwsSignatureVerifier();\n            } else {\n                theVerifier = getPublicKeySignatureVerifier(\n                              KeyManagementUtils.loadPublicKey(m, props), \n                              SignatureAlgorithm.getAlgorithm(signatureAlgo));\n            }\n        }\n        if (theVerifier == null && !ignoreNullVerifier) {\n            LOG.warning(\"Verifier is not available\");\n            throw new JwsException(JwsException.Error.NO_VERIFIER);\n        }\n        return theVerifier;\n    }","id":106401,"modified_method":"public static JwsSignatureVerifier loadSignatureVerifier(Message m, \n                                                              Properties props,\n                                                              JwsHeaders inHeaders, \n                                                              boolean ignoreNullVerifier) {\n        JwsSignatureVerifier theVerifier = null;\n        String inHeaderKid = null;\n        if (inHeaders != null) {\n            inHeaderKid = inHeaders.getKeyId();\n            //TODO: optionally validate inHeaders.getAlgorithm against a property in props\n            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {\n                JsonWebKey publicJwk = inHeaders.getJsonWebKey();\n                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())\n                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {\n                    throw new JwsException(JwsException.Error.INVALID_KEY);\n                }\n                return getSignatureVerifier(publicJwk, \n                                            inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n                KeyManagementUtils.validateCertificateChain(props, chain);\n                return getPublicKeySignatureVerifier(chain.get(0).getPublicKey(), \n                                                     inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n                X509Certificate foundCert = \n                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                    MessageDigestUtils.ALGO_SHA_1,\n                                                                    m, props);\n                if (foundCert != null) {\n                    return getPublicKeySignatureVerifier(foundCert.getPublicKey(), \n                                                         inHeaders.getSignatureAlgorithm());\n                }\n            }\n        }\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);\n            if (jwk != null) {\n                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, \n                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                             getDefaultKeyAlgorithm(jwk));\n                theVerifier = getSignatureVerifier(jwk, signatureAlgo);\n            }\n            \n        } else {\n            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (signatureAlgo == SignatureAlgorithm.NONE \n                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {\n                theVerifier = new NoneJwsSignatureVerifier();\n            } else {\n                theVerifier = getPublicKeySignatureVerifier(\n                              KeyManagementUtils.loadPublicKey(m, props), \n                              signatureAlgo);\n            }\n        }\n        if (theVerifier == null && !ignoreNullVerifier) {\n            LOG.warning(\"Verifier is not available\");\n            throw new JwsException(JwsException.Error.NO_VERIFIER);\n        }\n        return theVerifier;\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    public static String getSignatureAlgorithm(Message m, Properties props, String algo, String defaultAlgo) {\n        if (algo == null) {\n            if (defaultAlgo == null) {\n                defaultAlgo = AlgorithmUtils.RS_SHA_256_ALGO;\n            }\n            \n            // Check for deprecated identifier first\n            String sigAlgo = null;\n            if (props != null) {\n                sigAlgo = props.getProperty(JoseConstants.DEPR_RSSEC_SIGNATURE_ALGORITHM);\n            }\n            if (sigAlgo == null && m != null) {\n                sigAlgo = (String)m.getContextualProperty(JoseConstants.DEPR_RSSEC_SIGNATURE_ALGORITHM);\n            }\n            if (sigAlgo != null) {\n                return sigAlgo;\n            }\n            \n            // Otherwise check newer identifier\n            if (props != null) {\n                return getSignatureAlgorithm(props, defaultAlgo);\n            }\n        }\n        return algo;\n    }","id":106402,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public static SignatureAlgorithm getSignatureAlgorithm(Message m, Properties props, \n                                               SignatureAlgorithm algo, \n                                               SignatureAlgorithm defaultAlgo) {\n        if (algo == null) {\n            if (defaultAlgo == null) {\n                defaultAlgo = SignatureAlgorithm.RS256;\n            }\n            \n            // Check for deprecated identifier first\n            String sigAlgo = null;\n            if (props != null) {\n                sigAlgo = props.getProperty(JoseConstants.DEPR_RSSEC_SIGNATURE_ALGORITHM);\n            }\n            if (sigAlgo == null && m != null) {\n                sigAlgo = (String)m.getContextualProperty(JoseConstants.DEPR_RSSEC_SIGNATURE_ALGORITHM);\n            }\n            if (sigAlgo != null) {\n                return SignatureAlgorithm.getAlgorithm(sigAlgo);\n            }\n            \n            // Otherwise check newer identifier\n            if (props != null) {\n                return getSignatureAlgorithm(props, defaultAlgo);\n            }\n        }\n        return algo;\n    }","commit_id":"d6043fd1ce22c2e5991345747ac2c0ee3824a198","url":"https://github.com/apache/cxf"},{"original_method":"public void addFace(Face face) {\n    ListSequence.fromList(myFaces).addElement(face);\n    for (Dart dart : ListSequence.fromList(face.getDarts())) {\n      Edge edge = dart.getEdge();\n      if (MapSequence.fromMap(myAdjacentFacesMap).get(edge) == null) {\n        MapSequence.fromMap(myAdjacentFacesMap).put(edge, ListSequence.fromList(new ArrayList<Face>()));\n      }\n      ListSequence.fromList(MapSequence.fromMap(myAdjacentFacesMap).get(edge)).addElement(face);\n    }\n  }","id":106403,"modified_method":"public void addFace(Face face) {\n    ListSequence.fromList(myFaces).addElement(face);\n    for (Dart dart : ListSequence.fromList(face.getDarts())) {\n      Edge edge = dart.getEdge();\n      this.adjustEdge(edge, face);\n    }\n  }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void removeFace(Face face) {\n    ListSequence.fromList(myFaces).removeElement(face);\n    for (Dart dart : ListSequence.fromList(face.getDarts())) {\n      ListSequence.fromList(MapSequence.fromMap(myAdjacentFacesMap).get(dart.getEdge())).removeElement(face);\n    }\n  }","id":106404,"modified_method":"public void removeFace(Face face) {\n    ListSequence.fromList(myFaces).removeElement(face);\n    for (Dart dart : ListSequence.fromList(face.getDarts())) {\n      this.unadjustEdge(dart.getEdge(), face);\n    }\n  }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void splitFace(EmbeddedGraph embeddedGraph, Face face, List<Node> nodes) {\n    Graph originalGraph = embeddedGraph.getGraph();\n    List<Face> newFaces = ListSequence.fromList(new ArrayList<Face>());\n    ListSequence.fromList(newFaces).addElement(new Face(originalGraph));\n    ListSequence.fromList(newFaces).addElement(new Face(originalGraph));\n    Edge newEdge = ListSequence.fromList(nodes).getElement(0).addEdgeTo(ListSequence.fromList(nodes).getElement(1));\n    Iterator<Dart> dartItr = ListSequence.fromList(face.getDarts()).iterator();\n    Dart cur;\n    do {\n      cur = dartItr.next();\n    } while (!(ListSequence.fromList(nodes).contains(cur.getSource())));\n    Dart first = cur;\n    do {\n      ListSequence.fromList(newFaces).getElement(0).addNext(cur);\n      cur = dartItr.next();\n    } while (!(ListSequence.fromList(nodes).contains(cur.getSource())));\n    ListSequence.fromList(newFaces).getElement(0).addNext(new Dart(newEdge, cur.getSource()));\n    ListSequence.fromList(newFaces).getElement(1).addNext(new Dart(newEdge, first.getSource()));\n    ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n    while (dartItr.hasNext()) {\n      cur = dartItr.next();\n      ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n    }\n    dartItr = ListSequence.fromList(face.getDarts()).iterator();\n    cur = dartItr.next();\n    while (cur != first) {\n      ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n      cur = dartItr.next();\n    }\n    embeddedGraph.removeFace(face);\n    for (Face newFace : ListSequence.fromList(newFaces)) {\n      embeddedGraph.addFace(newFace);\n    }\n  }","id":106405,"modified_method":"public void splitFace(EmbeddedGraph embeddedGraph, Face face, List<Node> nodes) {\n    Graph originalGraph = embeddedGraph.getGraph();\n    List<Face> newFaces = ListSequence.fromList(new ArrayList<Face>());\n    ListSequence.fromList(newFaces).addElement(new Face(originalGraph));\n    ListSequence.fromList(newFaces).addElement(new Face(originalGraph));\n    Edge newEdge = ListSequence.fromList(nodes).getElement(0).addEdgeTo(ListSequence.fromList(nodes).getElement(1));\n    Iterator<Dart> dartItr = ListSequence.fromList(face.getDarts()).iterator();\n    Dart cur;\n    do {\n      cur = dartItr.next();\n    } while (!(ListSequence.fromList(nodes).contains(cur.getSource())));\n    Dart first = cur;\n    Node found = cur.getSource();\n    Node toFind = ListSequence.fromList(nodes).getElement(0);\n    if (toFind == found) {\n      toFind = ListSequence.fromList(nodes).getElement(1);\n    }\n    do {\n      ListSequence.fromList(newFaces).getElement(0).addNext(cur);\n      cur = dartItr.next();\n    } while (cur.getSource() != toFind);\n    ListSequence.fromList(newFaces).getElement(0).addNext(new Dart(newEdge, cur.getSource()));\n    ListSequence.fromList(newFaces).getElement(1).addNext(new Dart(newEdge, first.getSource()));\n    ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n    while (dartItr.hasNext()) {\n      cur = dartItr.next();\n      ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n    }\n    dartItr = ListSequence.fromList(face.getDarts()).iterator();\n    cur = dartItr.next();\n    while (cur != first) {\n      ListSequence.fromList(newFaces).getElement(1).addNext(cur);\n      cur = dartItr.next();\n    }\n    embeddedGraph.removeFace(face);\n    for (Face newFace : ListSequence.fromList(newFaces)) {\n      embeddedGraph.addFace(newFace);\n    }\n  }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EmbeddedGraph find(Graph graph) {\n    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);\n    List<Edge> removed = ListSequence.fromList(new ArrayList<Edge>());\n    Face outerFace = getOuterTreeFace(graph, removed);\n    for (Edge edge : ListSequence.fromList(removed)) {\n      edge.removeFromGraph();\n    }\n    embeddedGraph.addFace(outerFace);\n    embeddedGraph.setOuterFace(outerFace);\n    for (Edge removedEdge : ListSequence.fromList(removed)) {\n      DualGraph dualGraph = new DualGraph(embeddedGraph);\n      Map<Edge, List<Face>> adjacentFacesMap = embeddedGraph.getAdjacentFacesMap();\n      List<Node> newNodes = ListSequence.fromList(new ArrayList<Node>());\n      for (Node node : ListSequence.fromList(removedEdge.getAdjacentNodes())) {\n        Node newNode = dualGraph.addDummyNode();\n        for (Edge nodeEdge : ListSequence.fromList(node.getEdges(Edge.Direction.BOTH))) {\n          for (Face face : ListSequence.fromList(MapSequence.fromMap(adjacentFacesMap).get(nodeEdge))) {\n            newNode.addEdgeTo(MapSequence.fromMap(dualGraph.getNodesMap()).get(face));\n          }\n        }\n        ListSequence.fromList(newNodes).addElement(newNode);\n      }\n      System.out.println(\"before: \" + embeddedGraph);\n      System.out.println(dualGraph);\n      System.out.println(\"adding \" + removedEdge);\n      List<Edge> path = ShortestPath.getPath(dualGraph, ListSequence.fromList(newNodes).getElement(0), ListSequence.fromList(newNodes).getElement(1), Edge.Direction.BOTH);\n      List<Node> nodePath = ListSequence.fromList(new ArrayList<Node>());\n      List<Face> facePath = ListSequence.fromList(new ArrayList<Face>());\n      ListSequence.fromList(nodePath).addElement(ListSequence.fromList(removedEdge.getAdjacentNodes()).getElement(0));\n      Node cur = ListSequence.fromList(newNodes).getElement(0);\n      for (Edge edge : ListSequence.fromList(path)) {\n        if (MapSequence.fromMap(adjacentFacesMap).get(edge) != null) {\n          ListSequence.fromList(nodePath).addElement(split(embeddedGraph, MapSequence.fromMap(dualGraph.getEdgesMap()).get(edge)));\n        }\n        cur = edge.getOpposite(cur);\n        Face curFace = MapSequence.fromMap(dualGraph.getFacesMap()).get(cur);\n        if (curFace != null) {\n          ListSequence.fromList(facePath).addElement(curFace);\n        }\n      }\n      ListSequence.fromList(nodePath).addElement(ListSequence.fromList(removedEdge.getAdjacentNodes()).getElement(1));\n      for (int i = 0; i < ListSequence.fromList(nodePath).count() - 1; i++) {\n        splitFace(embeddedGraph, ListSequence.fromList(facePath).getElement(i), ListSequence.fromListAndArray(new ArrayList<Node>(), ListSequence.fromList(nodePath).getElement(i), ListSequence.fromList(nodePath).getElement(i + 1)));\n      }\n      System.out.println(\"after: \" + embeddedGraph);\n    }\n    return embeddedGraph;\n  }","id":106406,"modified_method":"public EmbeddedGraph find(Graph graph) {\n    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);\n    List<Edge> removed = ListSequence.fromList(new ArrayList<Edge>());\n    Face outerFace = getOuterTreeFace(graph, removed);\n    for (Edge edge : ListSequence.fromList(removed)) {\n      edge.removeFromGraph();\n    }\n    embeddedGraph.addFace(outerFace);\n    embeddedGraph.setOuterFace(outerFace);\n    System.out.println(\"initial: \" + embeddedGraph);\n    for (Edge removedEdge : ListSequence.fromList(removed)) {\n      this.restoreEdge(embeddedGraph, removedEdge);\n      CheckEmbeddedGraph.checkEmbeddedGraph(embeddedGraph);\n    }\n    return embeddedGraph;\n  }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Node split(EmbeddedGraph embeddedGraph, Edge edge) {\n    Graph originalGraph = embeddedGraph.getGraph();\n    Node newNode = originalGraph.addDummyNode();\n    edge.removeFromGraph();\n    for (Face face : ListSequence.fromList(MapSequence.fromMap(embeddedGraph.getAdjacentFacesMap()).get(edge))) {\n      List<Dart> darts = face.getDarts();\n      int pos = 0;\n      while (ListSequence.fromList(darts).getElement(pos).getEdge() != edge) {\n        pos++;\n      }\n      ListSequence.fromList(darts).setElement(pos, new Dart(edge.getSource().addEdgeTo(newNode), ListSequence.fromList(darts).getElement(pos).getDirection()));\n      ListSequence.fromList(darts).insertElement(pos + 1, new Dart(newNode.addEdgeTo(edge.getTarget()), ListSequence.fromList(darts).getElement(pos).getDirection()));\n    }\n    return newNode;\n  }","id":106407,"modified_method":"public Node split(EmbeddedGraph embeddedGraph, Edge edge) {\n    Graph originalGraph = embeddedGraph.getGraph();\n    Node newNode = originalGraph.addDummyNode();\n    edge.removeFromGraph();\n    List<Edge> newEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(newEdges).addElement(edge.getSource().addEdgeTo(newNode));\n    ListSequence.fromList(newEdges).addElement(newNode.addEdgeTo(edge.getTarget()));\n    List<Face> facesToProcess = ListSequence.fromList(new ArrayList<Face>());\n    ListSequence.fromList(facesToProcess).addSequence(ListSequence.fromList(MapSequence.fromMap(embeddedGraph.getAdjacentFacesMap()).get(edge)));\n    for (Face face : ListSequence.fromList(facesToProcess)) {\n      List<Dart> darts = face.getDarts();\n      int pos = 0;\n      while (ListSequence.fromList(darts).getElement(pos).getEdge() != edge) {\n        pos++;\n      }\n      Dart dartToReplace = ListSequence.fromList(darts).getElement(pos);\n      for (Edge newEdge : ListSequence.fromList(newEdges)) {\n        if (ListSequence.fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getSource())) {\n          embeddedGraph.setDart(face, pos, new Dart(newEdge, dartToReplace.getSource()));\n        }\n      }\n      for (Edge newEdge : ListSequence.fromList(newEdges)) {\n        if (ListSequence.fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getTarget())) {\n          embeddedGraph.insertDart(face, pos + 1, new Dart(newEdge, newNode));\n        }\n      }\n    }\n    return newNode;\n  }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void doDfs(Graph graph, Edge.Direction direction) {\n      myBackEdges = SetSequence.fromSet(new HashSet<Edge>());\n      myOuterFace = new Face(graph);\n      super.doDfs(graph, direction);\n    }","id":106408,"modified_method":"@Override\n    public void doDfs(Graph graph, Edge.Direction direction) {\n      myBackEdges = SetSequence.fromSet(new LinkedHashSet<Edge>());\n      myOuterFace = new Face(graph);\n      super.doDfs(graph, direction);\n    }","commit_id":"dd8c6d04ba04cc0a94d4e505126599c775a8d3a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode expr, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if ((SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b218L, \"condition\")) || SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfaa4bf0f2fL, 0xfaa4bf0f30L, \"condition\")) || SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11232674988L, 0x11232679422L, \"condition\"))) && !((boolean) Expression__BehaviorDescriptor.constant_id1653mnvAgr2.invoke(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(expr)))) && (boolean) Expression__BehaviorDescriptor.isCompileTimeConstant_idi1LOPRp.invoke(expr)) {\n      Object value = Expression__BehaviorDescriptor.getCompileTimeConstantValue_idi1LP2xI.invoke(expr, SNodeOperations.getModel(expr).getModule());\n      if (value != null && value instanceof Boolean) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(expr, \"The condition is always \" + value, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"8245314650935561947\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.SimplifyCondition_QuickFix\", false);\n            intentionProvider.putArgument(\"newValue\", value.toString());\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n      }\n    }\n  }","id":106409,"modified_method":"public void applyRule(final SNode expr, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if ((SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b218L, \"condition\")) || SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118ceceb41aL, 0x118ced0983eL, \"condition\")) || SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfaa4bf0f2fL, 0xfaa4bf0f30L, \"condition\")) || SNodeOperations.hasRole(expr, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11232674988L, 0x11232679422L, \"condition\"))) && !((boolean) Expression__BehaviorDescriptor.constant_id1653mnvAgr2.invoke(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(expr)))) && (boolean) Expression__BehaviorDescriptor.isCompileTimeConstant_idi1LOPRp.invoke(expr)) {\n      Object value = Expression__BehaviorDescriptor.getCompileTimeConstantValue_idi1LP2xI.invoke(expr, SNodeOperations.getModel(expr).getModule());\n      if (value != null && value instanceof Boolean) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(expr, \"The condition is always \" + value, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"8245314650935561947\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.SimplifyCondition_QuickFix\", false);\n            intentionProvider.putArgument(\"newValue\", value.toString());\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n      }\n    }\n  }","commit_id":"caf8cbf12727d6236a9d919b0fbddc6807c75d1f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode ifStatement, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    SNode trueBranch = SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\"));\n    if ((SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) == null) || ListSequence.fromList(SLinkOperations.getChildren(trueBranch, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isEmpty() || ListSequence.fromList(SLinkOperations.getChildren(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).isNotEmpty()) {\n      return;\n    }\n\n    SNode clonedStatements = SNodeOperations.copyNode(trueBranch);\n    SNode next = SNodeFactoryOperations.addNewChild(clonedStatements, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\")));\n\n    Program program = DataFlow.buildProgram(clonedStatements);\n    Set<SNode> unreachable = DataFlow.getUnreachableNodes(program);\n    if (SetSequence.fromSet(unreachable).contains(next)) {\n      {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(ifStatement, \"The else branch can be unwrapped, since the true branch always exits.\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"4513394054586260670\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.UnwrapRedundantElseBranch_QuickFix\", false);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","id":106410,"modified_method":"public void applyRule(final SNode ifStatement, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    SNode trueBranch = SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\"));\n    if ((SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) == null) || ListSequence.fromList(SLinkOperations.getChildren(trueBranch, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isEmpty()) {\n      return;\n    }\n\n    List<SNode> branches = ListSequence.fromList(new ArrayList<SNode>());\n    ListSequence.fromList(branches).addElement(SNodeOperations.copyNode(trueBranch));\n    ListSequence.fromList(branches).addSequence(ListSequence.fromList(SLinkOperations.getChildren(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.copyNode(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118ceceb41aL, 0x118ced0f8fdL, \"statementList\")));\n      }\n    }));\n\n    boolean allExit = ListSequence.fromList(branches).all(new IWhereFilter<SNode>() {\n      public boolean accept(SNode branch) {\n        SNode clonedStatements = branch;\n        SNode next = SNodeFactoryOperations.addNewChild(clonedStatements, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\")));\n\n        Program program = DataFlow.buildProgram(clonedStatements);\n        Set<SNode> unreachable = DataFlow.getUnreachableNodes(program);\n        return SetSequence.fromSet(unreachable).contains(next);\n      }\n    });\n    if (allExit) {\n      {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(ifStatement, \"The else branch can be unwrapped, since the true branch always exits.\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"4513394054586260670\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.UnwrapRedundantElseBranch_QuickFix\", false);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"caf8cbf12727d6236a9d919b0fbddc6807c75d1f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void modifyEmbeddedGraph(Iterable<Node> nodesWithSize, Map<Node, Dimension> nodeSizes) {\n    myNodesWithSize = nodesWithSize;\n    myEdgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());\n    for (Node node : Sequence.fromIterable(nodesWithSize)) {\n      splitEdges(node);\n      Map<Direction2D, List<Edge>> rectEdges = makeRectangleForNode(node);\n      for (Direction2D dir : Direction2D.values()) {\n        int length = MapSequence.fromMap(nodeSizes).get(node).width;\n        if (dir.isVertical()) {\n          length = MapSequence.fromMap(nodeSizes).get(node).height;\n        }\n        List<Edge> edges = MapSequence.fromMap(rectEdges).get(dir);\n        int edgeLength = length / ListSequence.fromList(edges).count();\n        for (Edge edge : ListSequence.fromList(edges)) {\n          if (edge == ListSequence.fromList(edges).last()) {\n            MapSequence.fromMap(myEdgeLengths).put(edge, length - (edgeLength * (ListSequence.fromList(edges).count() - 1)));\n          } else {\n            MapSequence.fromMap(myEdgeLengths).put(edge, edgeLength);\n          }\n        }\n      }\n    }\n    if (SHOW_INFO > 0) {\n      for (Face face : ListSequence.fromList(myEmbeddedGraph.getFaces())) {\n        System.out.println(\"face: \");\n        if (myEmbeddedGraph.isOuterFace(face)) {\n          System.out.println(\"this is outer face\");\n        }\n        for (Dart dart : ListSequence.fromList(face.getDarts())) {\n          String size = \" \";\n          if (MapSequence.fromMap(myEdgeLengths).containsKey(dart.getEdge())) {\n            size += MapSequence.fromMap(myEdgeLengths).get(dart.getEdge());\n          }\n          System.out.println(\"  \" + dart + \" dir = \" + MapSequence.fromMap(myDirections).get(dart) + size);\n        }\n      }\n    }\n  }","id":106411,"modified_method":"public void modifyEmbeddedGraph(Iterable<Node> nodesWithSize, Map<Node, Dimension> nodeSizes) {\n    myNodesWithSize = nodesWithSize;\n    myEdgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());\n    for (Node node : Sequence.fromIterable(nodesWithSize)) {\n      List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n      ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(node.getEdges()));\n      for (Edge oldEdge : ListSequence.fromList(oldEdges)) {\n        this.splitEdge(oldEdge);\n      }\n      Map<Direction2D, List<Edge>> rectEdges = makeRectangleForNode(node);\n      for (Direction2D dir : Direction2D.values()) {\n        int length = MapSequence.fromMap(nodeSizes).get(node).width;\n        if (dir.isVertical()) {\n          length = MapSequence.fromMap(nodeSizes).get(node).height;\n        }\n        List<Edge> edges = MapSequence.fromMap(rectEdges).get(dir);\n        int edgeLength = length / ListSequence.fromList(edges).count();\n        for (Edge edge : ListSequence.fromList(edges)) {\n          if (edge == ListSequence.fromList(edges).last()) {\n            MapSequence.fromMap(myEdgeLengths).put(edge, length - (edgeLength * (ListSequence.fromList(edges).count() - 1)));\n          } else {\n            MapSequence.fromMap(myEdgeLengths).put(edge, edgeLength);\n          }\n        }\n      }\n    }\n    if (SHOW_INFO > 0) {\n      for (Face face : ListSequence.fromList(myEmbeddedGraph.getFaces())) {\n        System.out.println(\"face: \");\n        if (myEmbeddedGraph.isOuterFace(face)) {\n          System.out.println(\"this is outer face\");\n        }\n        for (Dart dart : ListSequence.fromList(face.getDarts())) {\n          String size = \" \";\n          if (MapSequence.fromMap(myEdgeLengths).containsKey(dart.getEdge())) {\n            size += MapSequence.fromMap(myEdgeLengths).get(dart.getEdge());\n          }\n          System.out.println(\"  \" + dart + \" dir = \" + MapSequence.fromMap(myDirections).get(dart) + size);\n        }\n      }\n    }\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void splitEdges(Node node) {\n    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(node.getEdges()));\n    for (Edge oldEdge : ListSequence.fromList(oldEdges)) {\n      Node source = oldEdge.getSource();\n      Node target = oldEdge.getTarget();\n      Dart sourceDart = myEmbeddedGraph.getSourceDart(oldEdge, source);\n      Dart targetDart = myEmbeddedGraph.getSourceDart(oldEdge, target);\n      List<Edge> edges = ListSequence.fromList(new ArrayList<Edge>());\n      myEmbeddedGraph.splitEdge(oldEdge, edges);\n      for (Edge edge : ListSequence.fromList(edges)) {\n        for (Dart dart : ListSequence.fromList(myEmbeddedGraph.getDarts(edge))) {\n          if (dart.getSource() == source || dart.getTarget() == target) {\n            MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(sourceDart));\n          } else {\n            MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(targetDart));\n          }\n        }\n      }\n      MapSequence.fromMap(myDirections).removeKey(sourceDart);\n      MapSequence.fromMap(myDirections).removeKey(targetDart);\n    }\n  }","id":106412,"modified_method":"private Node splitEdge(Edge oldEdge) {\n    Node source = oldEdge.getSource();\n    Node target = oldEdge.getTarget();\n    Dart sourceDart = myEmbeddedGraph.getSourceDart(oldEdge, source);\n    Dart targetDart = myEmbeddedGraph.getSourceDart(oldEdge, target);\n    List<Edge> edges = ListSequence.fromList(new ArrayList<Edge>());\n    Node node = myEmbeddedGraph.splitEdge(oldEdge, edges);\n    for (Edge edge : ListSequence.fromList(edges)) {\n      for (Dart dart : ListSequence.fromList(myEmbeddedGraph.getDarts(edge))) {\n        if (dart.getSource() == source || dart.getTarget() == target) {\n          MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(sourceDart));\n        } else {\n          MapSequence.fromMap(myDirections).put(dart, MapSequence.fromMap(myDirections).get(targetDart));\n        }\n      }\n    }\n    MapSequence.fromMap(myDirections).removeKey(sourceDart);\n    MapSequence.fromMap(myDirections).removeKey(targetDart);\n    return node;\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Node, Point> getCoordinatesInModifiedGraph() {\n    Map<Edge, Integer> edgeLengths = MapSequence.fromMap(new HashMap<Edge, Integer>());\n    for (Edge edge : ListSequence.fromList(myHorConstraintsGraph.getEdges())) {\n      MapSequence.fromMap(edgeLengths).put(edge, myUnitLength);\n    }\n    for (Edge edge : ListSequence.fromList(myVerConstraintsGraph.getEdges())) {\n      MapSequence.fromMap(edgeLengths).put(edge, myUnitLength);\n    }\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(myEdgeLengths).keySet())) {\n      MapSequence.fromMap(edgeLengths).put(MapSequence.fromMap(myEdgeMap).get(edge), MapSequence.fromMap(myEdgeLengths).get(edge));\n    }\n    for (Node node : Sequence.fromIterable(myNodesWithSize)) {\n      for (Edge edge : ListSequence.fromList(node.getEdges())) {\n        MapSequence.fromMap(edgeLengths).put(MapSequence.fromMap(myEdgeMap).get(edge), 0);\n      }\n    }\n    Map<Node, Integer> horNumbering = WeightedTopologicalNumbering.number(myHorConstraintsGraph, edgeLengths);\n    Map<Node, Integer> verNumbering = WeightedTopologicalNumbering.number(myVerConstraintsGraph, edgeLengths);\n    Map<Node, Point> coordinates = MapSequence.fromMap(new HashMap<Node, Point>());\n    for (Node node : ListSequence.fromList(myGraph.getNodes())) {\n      Node horSeg = MapSequence.fromMap(myHorNodeMap).get(node);\n      Node verSeg = MapSequence.fromMap(myVerNodeMap).get(node);\n      MapSequence.fromMap(coordinates).put(node, new Point(MapSequence.fromMap(verNumbering).get(verSeg), MapSequence.fromMap(horNumbering).get(horSeg)));\n    }\n    return coordinates;\n  }","id":106413,"modified_method":"public Map<Node, Point> getCoordinatesInModifiedGraph() {\n    return getCoordinatesInModifiedGraph(null, null);\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private GraphLayout getLayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, Map<Node, Dimension> nodeSizes) {\n    Graph graph = embeddedGraph.getGraph();\n    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(graph.getEdges()));\n    List<Node> oldNodes = ListSequence.fromList(new ArrayList<Node>());\n    ListSequence.fromList(oldNodes).addSequence(SetSequence.fromSet(MapSequence.fromMap(nodeSizes).keySet()));\n    Map<Dart, Integer> bends = MapSequence.fromMap(new HashMap<Dart, Integer>());\n    Map<Dart, Integer> angles = MapSequence.fromMap(new HashMap<Dart, Integer>());\n    QuasiOrthogonalRepresentation.getRepresentation(embeddedGraph, bends, angles);\n    QuasiRepresentationModifier quasiModifier = new QuasiRepresentationModifier(embeddedGraph, bends, angles);\n    quasiModifier.reduceToOrthogonalRepresentation();\n    List<List<Edge>> modifiedEdges = quasiModifier.getModifiedEdges();\n    if (SHOW_INFO > 0) {\n      System.out.println(\"merged edges: \");\n      for (List<Edge> list : ListSequence.fromList(modifiedEdges)) {\n        System.out.println(list);\n      }\n    }\n    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);\n    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);\n    if (SHOW_INFO > 0) {\n      System.out.println(\"modified graph: \" + embeddedGraph);\n    }\n    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = MapSequence.fromMap(new HashMap<Node, Map<Direction2D, Integer>>());\n    for (Node node : ListSequence.fromList(oldNodes)) {\n      Map<Direction2D, Integer> directionSizes = MapSequence.fromMap(new HashMap<Direction2D, Integer>());\n      Dimension size = MapSequence.fromMap(nodeSizes).get(node);\n      int horSize = size.height;\n      MapSequence.fromMap(directionSizes).put(Direction2D.UP, horSize / 2);\n      MapSequence.fromMap(directionSizes).put(Direction2D.DOWN, horSize - MapSequence.fromMap(directionSizes).get(Direction2D.UP));\n      int verSize = size.width;\n      MapSequence.fromMap(directionSizes).put(Direction2D.LEFT, verSize / 2);\n      MapSequence.fromMap(directionSizes).put(Direction2D.RIGHT, verSize - MapSequence.fromMap(directionSizes).get(Direction2D.LEFT));\n      MapSequence.fromMap(nodeDirectionSizes).put(node, directionSizes);\n    }\n    ConstraintsGraphProcessor processor = new ConstraintsGraphProcessor(embeddedGraph, directions);\n    processor.modifyEmbeddedGraph(oldNodes, nodeSizes);\n    processor.constructGraph();\n    Map<Node, Point> coordinates = processor.getCoordinatesInModifiedGraph();\n    GraphLayout graphLayout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(oldNodes)) {\n      Point center = MapSequence.fromMap(coordinates).get(node);\n      Map<Direction2D, Integer> sizes = MapSequence.fromMap(nodeDirectionSizes).get(node);\n      Dimension nodeSize = MapSequence.fromMap(nodeSizes).get(node);\n      Rectangle rect = new Rectangle(center.x - MapSequence.fromMap(sizes).get(Direction2D.LEFT), center.y - MapSequence.fromMap(sizes).get(Direction2D.DOWN), nodeSize.width, nodeSize.height);\n      graphLayout.setLayoutFor(node, rect);\n    }\n    for (Edge edge : ListSequence.fromList(oldEdges)) {\n      Node source = edge.getSource();\n      Node target = edge.getTarget();\n      List<Edge> history = embeddedGraph.findFullHistory(edge);\n      List<Point> edgeLayout = ListSequence.fromList(new LinkedList<Point>());\n      Node cur = source;\n      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(cur)));\n      for (Edge historyEdge : ListSequence.fromList(history)) {\n        Node next = historyEdge.getOpposite(cur);\n        ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(next)));\n        cur = next;\n      }\n      if (ListSequence.fromList(oldNodes).contains(source)) {\n        Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).first(), source));\n        int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(source)).get(dir);\n        Point first = ListSequence.fromList(edgeLayout).removeElementAt(0);\n        first.translate(size * dir.dx(), size * dir.dy());\n        ListSequence.fromList(edgeLayout).removeElementAt(0);\n        ListSequence.fromList(edgeLayout).insertElement(0, first);\n      }\n      if (ListSequence.fromList(oldNodes).contains(edge.getTarget())) {\n        Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).last(), target));\n        int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(target)).get(dir);\n        Point last = ListSequence.fromList(edgeLayout).removeLastElement();\n        last.translate(size * dir.dx(), size * dir.dy());\n        ListSequence.fromList(edgeLayout).removeLastElement();\n        ListSequence.fromList(edgeLayout).addElement(last);\n      }\n      graphLayout.setLayoutFor(edge, edgeLayout);\n    }\n    List<Node> modificationSources = quasiModifier.getModificationSources();\n    Iterator<List<Edge>> modifiedEdgesItr = ListSequence.fromList(modifiedEdges).iterator();\n    Iterator<Node> sourcesItr = ListSequence.fromList(modificationSources).iterator();\n    while (sourcesItr.hasNext()) {\n      List<Edge> edges = modifiedEdgesItr.next();\n      Node source = sourcesItr.next();\n      splitEdges(graphLayout, edges, source);\n    }\n    return graphLayout;\n  }","id":106414,"modified_method":"private GraphLayout getLayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, Map<Node, Dimension> nodeSizes) {\n    if (SHOW_INFO > 0) {\n      System.out.println(\"initial graph: \" + embeddedGraph);\n    }\n    Graph graph = embeddedGraph.getGraph();\n    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(graph.getEdges()));\n    List<Node> oldNodes = ListSequence.fromList(new ArrayList<Node>());\n    ListSequence.fromList(oldNodes).addSequence(SetSequence.fromSet(MapSequence.fromMap(nodeSizes).keySet()));\n    Map<Dart, Integer> bends = MapSequence.fromMap(new HashMap<Dart, Integer>());\n    Map<Dart, Integer> angles = MapSequence.fromMap(new HashMap<Dart, Integer>());\n    QuasiOrthogonalRepresentation.getRepresentation(embeddedGraph, bends, angles);\n    QuasiRepresentationModifier quasiModifier = new QuasiRepresentationModifier(embeddedGraph, bends, angles);\n    quasiModifier.reduceToOrthogonalRepresentation();\n    if (SHOW_INFO > 0) {\n      System.out.println(\"modifications: \");\n      for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(quasiModifier.getModifications())) {\n        System.out.println(modification);\n      }\n    }\n    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);\n    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);\n    if (SHOW_INFO > 0) {\n      System.out.println(\"modified graph: \" + embeddedGraph);\n    }\n    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = this.getNodeDirectionSizes(oldNodes, nodeSizes);\n    Map<Edge, Integer> edgesShifts = getEdgesShifts(quasiModifier.getModifications(), directions, nodeSizes);\n    ConstraintsGraphProcessor processor = new ConstraintsGraphProcessor(embeddedGraph, directions);\n    processor.modifyEmbeddedGraph(oldNodes, nodeSizes);\n    processor.constructGraph();\n    Map<Node, Point> coordinates = processor.getCoordinatesInModifiedGraph(edgesShifts, nodeDirectionSizes);\n    GraphLayout graphLayout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(oldNodes)) {\n      Point center = MapSequence.fromMap(coordinates).get(node);\n      Map<Direction2D, Integer> sizes = MapSequence.fromMap(nodeDirectionSizes).get(node);\n      Dimension nodeSize = MapSequence.fromMap(nodeSizes).get(node);\n      Rectangle rect = new Rectangle(center.x - MapSequence.fromMap(sizes).get(Direction2D.LEFT), center.y - MapSequence.fromMap(sizes).get(Direction2D.DOWN), nodeSize.width, nodeSize.height);\n      graphLayout.setLayoutFor(node, rect);\n    }\n    for (Edge edge : ListSequence.fromList(oldEdges)) {\n      Node source = edge.getSource();\n      Node target = edge.getTarget();\n      List<Edge> history = embeddedGraph.findFullHistory(edge);\n      List<Point> edgeLayout = ListSequence.fromList(new LinkedList<Point>());\n      Node cur = source;\n      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(cur)));\n      for (Edge historyEdge : ListSequence.fromList(history)) {\n        Node next = historyEdge.getOpposite(cur);\n        ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(next)));\n        cur = next;\n      }\n      if (ListSequence.fromList(oldNodes).contains(source)) {\n        Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).first(), source));\n        int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(source)).get(dir);\n        Point first = ListSequence.fromList(edgeLayout).removeElementAt(0);\n        first.translate(size * dir.dx(), size * dir.dy());\n        ListSequence.fromList(edgeLayout).removeElementAt(0);\n        ListSequence.fromList(edgeLayout).insertElement(0, first);\n      }\n      if (ListSequence.fromList(oldNodes).contains(edge.getTarget())) {\n        Direction2D dir = MapSequence.fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.fromList(history).last(), target));\n        int size = MapSequence.fromMap(MapSequence.fromMap(nodeDirectionSizes).get(target)).get(dir);\n        Point last = ListSequence.fromList(edgeLayout).removeLastElement();\n        last.translate(size * dir.dx(), size * dir.dy());\n        ListSequence.fromList(edgeLayout).removeLastElement();\n        ListSequence.fromList(edgeLayout).addElement(last);\n      }\n      graphLayout.setLayoutFor(edge, edgeLayout);\n    }\n    for (QuasiRepresentationModifier.Modification modification : ListSequence.fromList(quasiModifier.getModifications())) {\n      splitEdges(graphLayout, modification);\n    }\n    return graphLayout;\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void layoutGraph() {\n    /*\n      myLayouter.setLayoutLevel(myLayoutChoice.getSelectedLayoutLavel());\n    */\n    Scanner scanner = new Scanner(myTextArea.getText());\n    Map<Node, Dimension> nodeDimensions = MapSequence.fromMap(new HashMap<Node, Dimension>());\n    Map<Edge, Dimension> edgeDimensions = MapSequence.fromMap(new HashMap<Edge, Dimension>());\n    Graph g = null;\n    try {\n      g = GraphIO.scanGraph(scanner);\n      int numNodeSizes = scanner.nextInt();\n      for (int i = 0; i < numNodeSizes; i++) {\n        Node node = g.getNode(scanner.nextInt());\n        MapSequence.fromMap(nodeDimensions).put(node, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n      int edgeLabelSizes = scanner.nextInt();\n      for (int i = 0; i < edgeLabelSizes; i++) {\n        Node source = g.getNode(scanner.nextInt());\n        final Node target = g.getNode(scanner.nextInt());\n        Edge edge = ListSequence.fromList(source.getOutEdges()).where(new IWhereFilter<Edge>() {\n          public boolean accept(Edge it) {\n            return it.getTarget() == target;\n          }\n        }).first();\n        MapSequence.fromMap(edgeDimensions).put(edge, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n    } catch (IllegalArgumentException e) {\n      JOptionPane.showMessageDialog(this, \"something is wrong in graph...\");\n    }\n    if (g != null) {\n      for (Node node : ListSequence.fromList(g.getNodes())) {\n        if (MapSequence.fromMap(nodeDimensions).get(node) == null) {\n          MapSequence.fromMap(nodeDimensions).put(node, new Dimension(DEFAULT_NODE_SIZE, DEFAULT_NODE_SIZE));\n        }\n      }\n      if (myLayoutChoice.isSetLabels()) {\n        for (Edge edge : ListSequence.fromList(g.getEdges())) {\n          if (MapSequence.fromMap(edgeDimensions).get(edge) == null) {\n            MapSequence.fromMap(edgeDimensions).put(edge, new Dimension(DEFAULT_EDGE_X_SIZE, DEFAULT_EDGE_Y_SIZE));\n          }\n        }\n      }\n      myCurrentLayout = myLayouter.doLayout(g, nodeDimensions);\n    }\n  }","id":106415,"modified_method":"private void layoutGraph() {\n    /*\n      myLayouter.setLayoutLevel(myLayoutChoice.getSelectedLayoutLavel());\n    */\n    Scanner scanner = new Scanner(myTextArea.getText());\n    Map<Node, Dimension> nodeDimensions = MapSequence.fromMap(new HashMap<Node, Dimension>());\n    Map<Edge, Dimension> edgeDimensions = MapSequence.fromMap(new HashMap<Edge, Dimension>());\n    Graph g = null;\n    try {\n      g = GraphIO.scanGraph(scanner);\n      int numNodeSizes = scanner.nextInt();\n      for (int i = 0; i < numNodeSizes; i++) {\n        Node node = g.getNode(scanner.nextInt());\n        MapSequence.fromMap(nodeDimensions).put(node, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n      int edgeLabelSizes = scanner.nextInt();\n      for (int i = 0; i < edgeLabelSizes; i++) {\n        Node source = g.getNode(scanner.nextInt());\n        final Node target = g.getNode(scanner.nextInt());\n        Edge edge = ListSequence.fromList(source.getOutEdges()).where(new IWhereFilter<Edge>() {\n          public boolean accept(Edge it) {\n            return it.getTarget() == target;\n          }\n        }).first();\n        MapSequence.fromMap(edgeDimensions).put(edge, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n    } catch (IllegalArgumentException e) {\n      JOptionPane.showMessageDialog(this, \"something is wrong in graph...\");\n    }\n    if (g != null) {\n      for (Node node : ListSequence.fromList(g.getNodes())) {\n        if (MapSequence.fromMap(nodeDimensions).get(node) == null) {\n          MapSequence.fromMap(nodeDimensions).put(node, new Dimension(DEFAULT_NODE_SIZE, DEFAULT_NODE_SIZE + 10));\n        }\n      }\n      if (myLayoutChoice.isSetLabels()) {\n        for (Edge edge : ListSequence.fromList(g.getEdges())) {\n          if (MapSequence.fromMap(edgeDimensions).get(edge) == null) {\n            MapSequence.fromMap(edgeDimensions).put(edge, new Dimension(DEFAULT_EDGE_X_SIZE, DEFAULT_EDGE_Y_SIZE));\n          }\n        }\n      }\n      myCurrentLayout = myLayouter.doLayout(g, nodeDimensions);\n    }\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public QuasiRepresentationModifier(EmbeddedGraph embeddedGraph, Map<Dart, Integer> bends, Map<Dart, Integer> angles) {\n    myGraph = embeddedGraph.getGraph();\n    myEmbeddedGraph = embeddedGraph;\n    myAngles = angles;\n    myBends = bends;\n    myModifiedEdges = ListSequence.fromList(new LinkedList<List<Edge>>());\n    myModificationSources = ListSequence.fromList(new LinkedList<Node>());\n  }","id":106416,"modified_method":"public QuasiRepresentationModifier(EmbeddedGraph embeddedGraph, Map<Dart, Integer> bends, Map<Dart, Integer> angles) {\n    myGraph = embeddedGraph.getGraph();\n    myEmbeddedGraph = embeddedGraph;\n    myAngles = angles;\n    myBends = bends;\n    myModifications = ListSequence.fromList(new LinkedList<QuasiRepresentationModifier.Modification>());\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void reduceToOrthogonalRepresentation() {\n    Map<Edge, Edge> edgeTransform = MapSequence.fromMap(new HashMap<Edge, Edge>());\n    List<Node> initialNodes = ListSequence.fromList(new ArrayList<Node>());\n    ListSequence.fromList(initialNodes).addSequence(ListSequence.fromList(myGraph.getNodes()));\n    for (final Node node : ListSequence.fromList(initialNodes)) {\n      List<Dart> darts = getOrderedDarts(node);\n      Iterator<Dart> dartItr = ListSequence.fromList(darts).iterator();\n      Set<Dart> removed = SetSequence.fromSet(new HashSet<Dart>());\n      while (dartItr.hasNext()) {\n        Dart curDart;\n        curDart = dartItr.next();\n        if (MapSequence.fromMap(myAngles).get(curDart) == 0) {\n          List<Dart> sameDirectionDarts = ListSequence.fromList(new LinkedList<Dart>());\n          while (MapSequence.fromMap(myAngles).get(curDart) == 0) {\n            ListSequence.fromList(sameDirectionDarts).addElement(curDart);\n            curDart = dartItr.next();\n          }\n\n          List<Edge> modifiedEdges = ListSequence.fromList(new LinkedList<Edge>());\n          for (Dart dart : ListSequence.fromList(sameDirectionDarts)) {\n            Edge edge = dart.getEdge();\n            if (MapSequence.fromMap(edgeTransform).containsKey(edge)) {\n              edge = MapSequence.fromMap(edgeTransform).get(edge);\n            }\n            ListSequence.fromList(modifiedEdges).addElement(edge);\n          }\n          Edge edge = curDart.getEdge();\n          if (MapSequence.fromMap(edgeTransform).containsKey(edge)) {\n            edge = MapSequence.fromMap(edgeTransform).get(edge);\n          }\n          ListSequence.fromList(modifiedEdges).addElement(edge);\n          ListSequence.fromList(myModifiedEdges).addElement(modifiedEdges);\n          ListSequence.fromList(myModificationSources).addElement(node);\n\n          final Wrappers._T<Edge> curEdge = new Wrappers._T<Edge>(curDart.getEdge());\n          for (Dart dart : ListSequence.fromList(sameDirectionDarts).reversedList()) {\n            SetSequence.fromSet(removed).addElement(curDart);\n            SetSequence.fromSet(removed).addElement(myEmbeddedGraph.getOpposite(curDart));\n            Dart backCurDart = myEmbeddedGraph.getOpposite(curDart);\n            List<Edge> edgesFromSplit = ListSequence.fromList(new ArrayList<Edge>());\n            Node newNode = myEmbeddedGraph.splitEdge(curEdge.value, edgesFromSplit);\n            Edge nextEdge = ListSequence.fromList(edgesFromSplit).findFirst(new IWhereFilter<Edge>() {\n              public boolean accept(Edge it) {\n                return ListSequence.fromList(it.getAdjacentNodes()).contains(node);\n              }\n            });\n            Dart tempDart;\n            tempDart = myEmbeddedGraph.getSourceDart(nextEdge, node);\n            MapSequence.fromMap(myAngles).put(tempDart, MapSequence.fromMap(myAngles).get(curDart));\n            MapSequence.fromMap(myBends).put(tempDart, 0);\n            tempDart = myEmbeddedGraph.getOpposite(tempDart);\n            MapSequence.fromMap(myAngles).put(tempDart, 1);\n            MapSequence.fromMap(myBends).put(tempDart, 0);\n\n            Edge anotherEdge = ListSequence.fromList(edgesFromSplit).findFirst(new IWhereFilter<Edge>() {\n              public boolean accept(Edge it) {\n                return ListSequence.fromList(it.getAdjacentNodes()).contains(curEdge.value.getOpposite(node));\n              }\n            });\n            if (dart == ListSequence.fromList(sameDirectionDarts).last()) {\n              MapSequence.fromMap(edgeTransform).put(anotherEdge, curEdge.value);\n            }\n            tempDart = myEmbeddedGraph.getSourceDart(anotherEdge, newNode);\n            MapSequence.fromMap(myAngles).put(tempDart, 2);\n            MapSequence.fromMap(myBends).put(tempDart, MapSequence.fromMap(myBends).get(curDart));\n            tempDart = myEmbeddedGraph.getOpposite(tempDart);\n            MapSequence.fromMap(myAngles).put(tempDart, MapSequence.fromMap(myAngles).get(backCurDart));\n            MapSequence.fromMap(myBends).put(tempDart, MapSequence.fromMap(myBends).get(backCurDart));\n\n            Face face = myEmbeddedGraph.getFace(dart);\n            Face anotherFace = myEmbeddedGraph.getFace(myEmbeddedGraph.getOpposite(dart));\n            Edge oldEdge = dart.getEdge();\n            Dart frontOldDart = myEmbeddedGraph.getSourceDart(oldEdge, node);\n            Dart backOldDart = myEmbeddedGraph.getOpposite(frontOldDart);\n            SetSequence.fromSet(removed).addElement(frontOldDart);\n            SetSequence.fromSet(removed).addElement(backOldDart);\n\n            face.makeEndsWith(node);\n            oldEdge.removeFromGraph();\n            Edge newEdge = newNode.addEdgeTo(oldEdge.getOpposite(node));\n            MapSequence.fromMap(edgeTransform).put(newEdge, oldEdge);\n            Dart lastFaceDart = ListSequence.fromList(face.getDarts()).last();\n            myEmbeddedGraph.removeDart(face, lastFaceDart);\n            Dart frontNewDart = new Dart(newEdge, newNode);\n            myEmbeddedGraph.setDart(face, 0, frontNewDart);\n            MapSequence.fromMap(myAngles).put(frontNewDart, 1);\n            MapSequence.fromMap(myBends).put(frontNewDart, MapSequence.fromMap(myBends).get(frontOldDart));\n\n            anotherFace.makeEndsWith(node);\n            Dart backNewDart = new Dart(newEdge, oldEdge.getOpposite(node));\n            myEmbeddedGraph.setDart(anotherFace, ListSequence.fromList(anotherFace.getDarts()).count() - 1, backNewDart);\n            myEmbeddedGraph.insertDart(anotherFace, ListSequence.fromList(anotherFace.getDarts()).count(), lastFaceDart);\n            MapSequence.fromMap(myAngles).put(backNewDart, MapSequence.fromMap(myAngles).get(backOldDart));\n            MapSequence.fromMap(myBends).put(backNewDart, MapSequence.fromMap(myBends).get(backOldDart) - 1);\n\n            List<Edge> historyEdges = ListSequence.fromListAndArray(new ArrayList<Edge>(), nextEdge, newEdge);\n            myEmbeddedGraph.setEdgesHistory(oldEdge, historyEdges);\n\n            curEdge.value = nextEdge;\n            curDart = myEmbeddedGraph.getSourceDart(curEdge.value, node);\n          }\n        }\n      }\n      for (Dart dart : SetSequence.fromSet(removed)) {\n        MapSequence.fromMap(myAngles).removeKey(dart);\n        MapSequence.fromMap(myBends).removeKey(dart);\n      }\n    }\n  }","id":106417,"modified_method":"public void reduceToOrthogonalRepresentation() {\n    Map<Edge, Edge> edgeTransform = MapSequence.fromMap(new HashMap<Edge, Edge>());\n    List<Node> initialNodes = ListSequence.fromList(new ArrayList<Node>());\n    ListSequence.fromList(initialNodes).addSequence(ListSequence.fromList(myGraph.getNodes()));\n    for (final Node node : ListSequence.fromList(initialNodes)) {\n      List<Dart> darts = getOrderedDarts(node);\n      Iterator<Dart> dartItr = ListSequence.fromList(darts).iterator();\n      Set<Dart> removed = SetSequence.fromSet(new HashSet<Dart>());\n      while (dartItr.hasNext()) {\n        Dart curDart;\n        curDart = dartItr.next();\n        if (MapSequence.fromMap(myAngles).get(curDart) == 0) {\n          List<Dart> sameDirectionDarts = ListSequence.fromList(new LinkedList<Dart>());\n          while (MapSequence.fromMap(myAngles).get(curDart) == 0) {\n            ListSequence.fromList(sameDirectionDarts).addElement(curDart);\n            curDart = dartItr.next();\n          }\n\n          List<Edge> modifiedEdges = ListSequence.fromList(new LinkedList<Edge>());\n          for (Dart dart : ListSequence.fromList(sameDirectionDarts)) {\n            Edge edge = dart.getEdge();\n            if (MapSequence.fromMap(edgeTransform).containsKey(edge)) {\n              edge = MapSequence.fromMap(edgeTransform).get(edge);\n            }\n            ListSequence.fromList(modifiedEdges).addElement(edge);\n          }\n          Edge edge = curDart.getEdge();\n          if (MapSequence.fromMap(edgeTransform).containsKey(edge)) {\n            edge = MapSequence.fromMap(edgeTransform).get(edge);\n          }\n          ListSequence.fromList(modifiedEdges).addElement(edge);\n          final Wrappers._T<Edge> curEdge = new Wrappers._T<Edge>(curDart.getEdge());\n          int curNum = 0;\n          List<Edge> newEdges = ListSequence.fromList(new LinkedList<Edge>());\n          for (Dart dart : ListSequence.fromList(sameDirectionDarts).reversedList()) {\n            SetSequence.fromSet(removed).addElement(curDart);\n            SetSequence.fromSet(removed).addElement(myEmbeddedGraph.getOpposite(curDart));\n            Dart backCurDart = myEmbeddedGraph.getOpposite(curDart);\n            List<Edge> edgesFromSplit = ListSequence.fromList(new ArrayList<Edge>());\n            Node newNode = myEmbeddedGraph.splitEdge(curEdge.value, edgesFromSplit);\n            Edge nextEdge = ListSequence.fromList(edgesFromSplit).findFirst(new IWhereFilter<Edge>() {\n              public boolean accept(Edge it) {\n                return ListSequence.fromList(it.getAdjacentNodes()).contains(node);\n              }\n            });\n            Dart tempDart;\n            tempDart = myEmbeddedGraph.getSourceDart(nextEdge, node);\n            MapSequence.fromMap(myAngles).put(tempDart, MapSequence.fromMap(myAngles).get(curDart));\n            MapSequence.fromMap(myBends).put(tempDart, 0);\n            tempDart = myEmbeddedGraph.getOpposite(tempDart);\n            MapSequence.fromMap(myAngles).put(tempDart, 1);\n            MapSequence.fromMap(myBends).put(tempDart, 0);\n\n            Edge anotherEdge = ListSequence.fromList(edgesFromSplit).findFirst(new IWhereFilter<Edge>() {\n              public boolean accept(Edge it) {\n                return ListSequence.fromList(it.getAdjacentNodes()).contains(curEdge.value.getOpposite(node));\n              }\n            });\n            if (dart == ListSequence.fromList(sameDirectionDarts).last()) {\n              MapSequence.fromMap(edgeTransform).put(anotherEdge, curEdge.value);\n              ListSequence.fromList(newEdges).addElement(anotherEdge);\n            }\n            tempDart = myEmbeddedGraph.getSourceDart(anotherEdge, newNode);\n            MapSequence.fromMap(myAngles).put(tempDart, 2);\n            MapSequence.fromMap(myBends).put(tempDart, MapSequence.fromMap(myBends).get(curDart));\n            tempDart = myEmbeddedGraph.getOpposite(tempDart);\n            MapSequence.fromMap(myAngles).put(tempDart, MapSequence.fromMap(myAngles).get(backCurDart));\n            MapSequence.fromMap(myBends).put(tempDart, MapSequence.fromMap(myBends).get(backCurDart));\n\n            Face face = myEmbeddedGraph.getFace(dart);\n            Face anotherFace = myEmbeddedGraph.getFace(myEmbeddedGraph.getOpposite(dart));\n            Edge oldEdge = dart.getEdge();\n            Dart frontOldDart = myEmbeddedGraph.getSourceDart(oldEdge, node);\n            Dart backOldDart = myEmbeddedGraph.getOpposite(frontOldDart);\n            SetSequence.fromSet(removed).addElement(frontOldDart);\n            SetSequence.fromSet(removed).addElement(backOldDart);\n\n            face.makeEndsWith(node);\n            oldEdge.removeFromGraph();\n            Edge newEdge = newNode.addEdgeTo(oldEdge.getOpposite(node));\n            ListSequence.fromList(newEdges).addElement(newEdge);\n            MapSequence.fromMap(edgeTransform).put(newEdge, oldEdge);\n            Dart lastFaceDart = ListSequence.fromList(face.getDarts()).last();\n            myEmbeddedGraph.removeDart(face, lastFaceDart);\n            Dart frontNewDart = new Dart(newEdge, newNode);\n            myEmbeddedGraph.setDart(face, 0, frontNewDart);\n            MapSequence.fromMap(myAngles).put(frontNewDart, 1);\n            MapSequence.fromMap(myBends).put(frontNewDart, MapSequence.fromMap(myBends).get(frontOldDart));\n\n            anotherFace.makeEndsWith(node);\n            Dart backNewDart = new Dart(newEdge, oldEdge.getOpposite(node));\n            myEmbeddedGraph.setDart(anotherFace, ListSequence.fromList(anotherFace.getDarts()).count() - 1, backNewDart);\n            myEmbeddedGraph.insertDart(anotherFace, ListSequence.fromList(anotherFace.getDarts()).count(), lastFaceDart);\n            MapSequence.fromMap(myAngles).put(backNewDart, MapSequence.fromMap(myAngles).get(backOldDart));\n            MapSequence.fromMap(myBends).put(backNewDart, MapSequence.fromMap(myBends).get(backOldDart) - 1);\n\n            List<Edge> historyEdges = ListSequence.fromListAndArray(new ArrayList<Edge>(), nextEdge, newEdge);\n            myEmbeddedGraph.setEdgesHistory(oldEdge, historyEdges);\n\n            curEdge.value = nextEdge;\n            curDart = myEmbeddedGraph.getSourceDart(curEdge.value, node);\n            curNum++;\n          }\n          ListSequence.fromList(myModifications).addElement(new QuasiRepresentationModifier.Modification(ListSequence.fromList(modifiedEdges).reversedList(), newEdges, node, curDart));\n        }\n      }\n      for (Dart dart : SetSequence.fromSet(removed)) {\n        MapSequence.fromMap(myAngles).removeKey(dart);\n        MapSequence.fromMap(myBends).removeKey(dart);\n      }\n    }\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Node> getModificationSources() {\n    return myModificationSources;\n  }","id":106418,"modified_method":"public List<QuasiRepresentationModifier.Modification> getModifications() {\n    return myModifications;\n  }","commit_id":"2f27eb666ab469f5279116d1b347d9bf30b107cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleNode(Module module)\n    throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\n    return createTreeNode(PackageViewModuleNode.class, module.getProject(), module, getSettings());\n  }","id":106419,"modified_method":"@Override\n  protected AbstractTreeNode createModuleNode(Module module)\n    throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {\n    return new PackageViewModuleNode(module.getProject(), module, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleGroup(final Module module) throws\n                                                                    InvocationTargetException,\n                                                                    NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return createTreeNode(PackageViewModuleNode.class, getProject(), module, getSettings());\n  }","id":106420,"modified_method":"@Override\n  protected AbstractTreeNode createModuleGroup(final Module module) throws\n                                                                    InvocationTargetException,\n                                                                    NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return new PackageViewModuleNode(getProject(), module, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleGroupNode(final ModuleGroup moduleGroup)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return createTreeNode(PackageViewModuleGroupNode.class, getProject(),  moduleGroup, getSettings());\n  }","id":106421,"modified_method":"@Override\n  protected AbstractTreeNode createModuleGroupNode(final ModuleGroup moduleGroup)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return new PackageViewModuleGroupNode(getProject(),  moduleGroup, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleNode(Module module)\n    throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n    final VirtualFile[] roots = ModuleRootManager.getInstance(module).getContentRoots();\n    if (roots.length == 1) {\n      final PsiDirectory psi = PsiManager.getInstance(myProject).findDirectory(roots[0]);\n      if (psi != null) {\n        return createTreeNode(PsiDirectoryNode.class, myProject, psi, getSettings());\n      }\n    }\n\n    return createTreeNode(ProjectViewModuleNode.class, getProject(), module, getSettings());\n  }","id":106422,"modified_method":"@Override\n  protected AbstractTreeNode createModuleNode(Module module)\n    throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n    final VirtualFile[] roots = ModuleRootManager.getInstance(module).getContentRoots();\n    if (roots.length == 1) {\n      final PsiDirectory psi = PsiManager.getInstance(myProject).findDirectory(roots[0]);\n      if (psi != null) {\n        return new PsiDirectoryNode(myProject, psi, getSettings());\n      }\n    }\n\n    return new ProjectViewModuleNode(getProject(), module, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleGroupNode(final ModuleGroup moduleGroup)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return createTreeNode(ProjectViewModuleGroupNode.class, getProject(), moduleGroup, getSettings());\n  }","id":106423,"modified_method":"@Override\n  protected AbstractTreeNode createModuleGroupNode(final ModuleGroup moduleGroup)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    return new ProjectViewModuleGroupNode(getProject(), moduleGroup, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected AbstractTreeNode createModuleGroup(final Module module)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    final VirtualFile[] roots = ModuleRootManager.getInstance(module).getContentRoots();\n    if (roots.length == 1) {\n      final PsiDirectory psi = PsiManager.getInstance(myProject).findDirectory(roots[0]);\n      if (psi != null) {\n        return createTreeNode(PsiDirectoryNode.class, myProject, psi, getSettings());\n      }\n    }\n\n    return createTreeNode(ProjectViewModuleNode.class, getProject(), module, getSettings());\n  }","id":106424,"modified_method":"@Override\n  protected AbstractTreeNode createModuleGroup(final Module module)\n    throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n    final VirtualFile[] roots = ModuleRootManager.getInstance(module).getContentRoots();\n    if (roots.length == 1) {\n      final PsiDirectory psi = PsiManager.getInstance(myProject).findDirectory(roots[0]);\n      if (psi != null) {\n        return new PsiDirectoryNode(myProject, psi, getSettings());\n      }\n    }\n\n    return new ProjectViewModuleNode(getProject(), module, getSettings());\n  }","commit_id":"c8055c9253100b0d77545c4f7bc970e215ab3e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static synchronized List<BaseMessage> lookup(final String resourceId, final Set<Class> msgTypes) {\n    if(! correlationIds.containsKey(resourceId))\n      return Lists.newArrayList();\n    \n    final List<BaseMessage> result = Lists.newArrayList();\n    for(final MessageCache corrId : correlationIds.get(resourceId)){\n      if(msgTypes.contains(corrId.getKey()))\n        result.add(corrId.getValue());\n    }\n    return result;\n  }","id":106425,"modified_method":"public static synchronized List<BaseMessage> lookup(final String resourceId, final Set<Class> msgTypes) {\n    List<MessageCache> messages = correlationIds.getIfPresent(resourceId);\n    if(messages == null)\n      return Lists.newArrayList();\n    \n    final List<BaseMessage> result = Lists.newArrayList();\n    for(final MessageCache corrId : messages){\n      if(msgTypes.contains(corrId.getKey()))\n        result.add(corrId.getValue());\n    }\n    return result;\n  }","commit_id":"0a9c22ffd8df18bf23cfe5f0302a365fb239061b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static synchronized void remember(final String resourceId, final Class<? extends BaseMessage> msgType, BaseMessage message) {\n    List<MessageCache> listIds = null;\n    if(! correlationIds.containsKey(resourceId)){\n      listIds = Lists.newArrayList();\n      correlationIds.put(resourceId, listIds);\n    }else\n      listIds = correlationIds.get(resourceId);\n    \n    int duplicate = -1;\n    for(int i=0; i<listIds.size(); i++){\n      final MessageCache corrId = listIds.get(i);\n      if(msgType.equals(corrId.getKey())){\n        duplicate = i;\n        break;\n      }\n    }\n    if(duplicate>=0)\n      listIds.remove(duplicate);\n    \n    try{\n      listIds.add(new MessageCache(msgType, message ));\n    }catch(final Exception ex){\n      throw Exceptions.toUndeclared(new EucalyptusCloudException(\"Correlation Id is in wrong format\"));\n    }\n  }","id":106426,"modified_method":"public static synchronized void remember(final String resourceId, final Class<? extends BaseMessage> msgType, BaseMessage message) {\n    List<MessageCache> listIds = null;\n    listIds = correlationIds.getIfPresent(resourceId);\n    if(listIds == null){\n      listIds = Lists.newArrayList();\n      correlationIds.put(resourceId, listIds);\n    }\n    int duplicate = -1;\n    for(int i=0; i<listIds.size(); i++){\n      final MessageCache corrId = listIds.get(i);\n      if(msgType.equals(corrId.getKey())){\n        duplicate = i;\n        break;\n      }\n    }\n    if(duplicate>=0)\n      listIds.remove(duplicate);\n    \n    try{\n      listIds.add(new MessageCache(msgType, message ));\n    }catch(final Exception ex){\n      throw Exceptions.toUndeclared(new EucalyptusCloudException(\"Correlation Id is in wrong format\"));\n    }\n  }","commit_id":"0a9c22ffd8df18bf23cfe5f0302a365fb239061b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static synchronized BaseMessage lookup(final String resourceId, final Class<? extends BaseMessage> msgType) {\n    if(! correlationIds.containsKey(resourceId))\n      return null;\n    \n    for(final MessageCache corrId : correlationIds.get(resourceId)){\n      if(msgType.equals(corrId.getKey()))\n        return corrId.getValue();\n    }\n    return null;\n  }","id":106427,"modified_method":"public static synchronized BaseMessage lookup(final String resourceId, final Class<? extends BaseMessage> msgType) {\n    List<MessageCache> messages = correlationIds.getIfPresent(resourceId);\n    if(messages == null)\n      return null;\n    for(final MessageCache corrId : messages){\n      if(msgType.equals(corrId.getKey()))\n        return corrId.getValue();\n    }\n    return null;\n  }","commit_id":"0a9c22ffd8df18bf23cfe5f0302a365fb239061b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static synchronized BaseMessage lookupLast(final String resourceId, Set<Class> msgTypes) {\n    if(! correlationIds.containsKey(resourceId))\n      return null;\n    \n    final List<MessageCache> result = Lists.newArrayList();\n    for(final MessageCache corrId : correlationIds.get(resourceId)){\n      if(msgTypes.contains(corrId.getKey()))\n        result.add(corrId);\n    }\n    if(result.size()<=0)\n      return null;\n    \n    BaseMessage lastMsg = result.get(0).getValue();\n    long lastTs = result.get(0).getCreationTime().getTime();\n    for(final MessageCache corrId : result){\n      if(corrId.getCreationTime().getTime() > lastTs){\n        lastMsg = corrId.getValue();\n        lastTs = corrId.getCreationTime().getTime();\n      }\n    }\n    return lastMsg;\n  }","id":106428,"modified_method":"public static synchronized BaseMessage lookupLast(final String resourceId, Set<Class> msgTypes) {   \n    List<MessageCache> messages = correlationIds.getIfPresent(resourceId);\n    if(messages == null)\n      return null;\n    \n    final List<MessageCache> result = Lists.newArrayList();\n    for(final MessageCache corrId : messages){\n      if(msgTypes.contains(corrId.getKey()))\n        result.add(corrId);\n    }\n    if(result.size()<=0)\n      return null;\n    \n    BaseMessage lastMsg = result.get(0).getValue();\n    long lastTs = result.get(0).getCreationTime().getTime();\n    for(final MessageCache corrId : result){\n      if(corrId.getCreationTime().getTime() > lastTs){\n        lastMsg = corrId.getValue();\n        lastTs = corrId.getCreationTime().getTime();\n      }\n    }\n    return lastMsg;\n  }","commit_id":"0a9c22ffd8df18bf23cfe5f0302a365fb239061b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static synchronized List<BaseMessage> lookup(final String resourceId){\n    if(! correlationIds.containsKey(resourceId))\n      return Lists.newArrayList();\n    \n    return Lists.transform(correlationIds.get(resourceId), new Function<MessageCache, BaseMessage>(){\n      @Override\n      public BaseMessage apply(MessageCache arg0) {\n        return arg0.getValue();\n      }\n    });\n  }","id":106429,"modified_method":"public static synchronized List<BaseMessage> lookup(final String resourceId){\n    List<MessageCache> messages = correlationIds.getIfPresent(resourceId);\n    if(messages == null)\n      return Lists.newArrayList();\n \n    return Lists.transform(messages, new Function<MessageCache, BaseMessage>(){\n      @Override\n      public BaseMessage apply(MessageCache arg0) {\n        return arg0.getValue();\n      }\n    });\n  }","commit_id":"0a9c22ffd8df18bf23cfe5f0302a365fb239061b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                Long deltaProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"DeltaProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object resetTimestampObj = mBeanServer.getAttribute(contextMBean, \"ResetTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (resetTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n\n        return null;\n    }","id":106430,"modified_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                Long deltaProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"DeltaProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object resetTimestampObj = mBeanServer.getAttribute(contextMBean, \"ResetTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (resetTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n\n        return null;\n    }","commit_id":"4a2af47205c496185d19918763101abe0c1af176","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer mBeanServer = agent.getMBeanServer();\n                Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n                Iterator<ObjectName> iterator = set.iterator();\n                if (iterator.hasNext()) {\n                    ObjectName routeMBean = iterator.next();\n\n                    // the route must be part of the camel context\n                    String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                    if (camelId != null && camelId.equals(camelContext.getName())) {\n                        Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                        Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                        Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                        Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                        Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MaxProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                        Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                        Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                        Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                        Long deltaProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"DeltaProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \"ms\"));\n                        String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                        String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                        String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                        // Test for null to see if a any exchanges have been processed first to avoid NPE\n                        Object resetTimestampObj = mBeanServer.getAttribute(routeMBean, \"ResetTimestamp\");\n                        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                        if (resetTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                        } else {\n                            Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                        }\n\n                        // Test for null to see if a any exchanges have been processed first to avoid NPE\n                        Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                        if (firstExchangeTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                        } else {\n                            Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                        }\n\n                        // Again, check for null to avoid NPE\n                        Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                        if (lastExchangeCompletedTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                        } else {\n                            Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                        }\n                    }\n                }\n            } else {\n                System.out.println(\"\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n                System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n            }\n\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n            RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n            System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        }\n        return null;\n    }","id":106431,"modified_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer mBeanServer = agent.getMBeanServer();\n                Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n                Iterator<ObjectName> iterator = set.iterator();\n                if (iterator.hasNext()) {\n                    ObjectName routeMBean = iterator.next();\n\n                    // the route must be part of the camel context\n                    String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                    if (camelId != null && camelId.equals(camelContext.getName())) {\n                        Integer inflightExchange = (Integer) mBeanServer.getAttribute(routeMBean, \"InflightExchanges\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tInflight Exchanges: \" + inflightExchange));\n                        Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                        Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                        Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                        Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \" ms\"));\n                        Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MaxProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \" ms\"));\n                        Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \" ms\"));\n                        Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \" ms\"));\n                        Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \" ms\"));\n                        Long deltaProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"DeltaProcessingTime\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \" ms\"));\n                        String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                        String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                        String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                        // Test for null to see if a any exchanges have been processed first to avoid NPE\n                        Object resetTimestampObj = mBeanServer.getAttribute(routeMBean, \"ResetTimestamp\");\n                        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                        if (resetTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                        } else {\n                            Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                        }\n\n                        // Test for null to see if a any exchanges have been processed first to avoid NPE\n                        Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                        if (firstExchangeTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                        } else {\n                            Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                        }\n\n                        // Again, check for null to avoid NPE\n                        Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                        if (lastExchangeCompletedTimestampObj == null) {\n                            // Print an empty value for scripting\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                        } else {\n                            Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                        }\n                    }\n                }\n            } else {\n                System.out.println(\"\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n                System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n            }\n\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n            RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n            System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        }\n        return null;\n    }","commit_id":"4a2af47205c496185d19918763101abe0c1af176","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void executeOnRoute(CamelContext camelContext, Route camelRoute) throws Exception {\n        JAXBContext context = JAXBContext.newInstance(RouteStatDump.class);\n        Unmarshaller unmarshaller = context.createUnmarshaller();\n\n        // write new header for new camel context\n        if (previousCamelContextName == null || !previousCamelContextName.equals(camelContext.getName())) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProfile\\u001B[0m\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n            System.out.println(String.format(HEADER_FORMAT, \"Id\", \"Count\", \"Last (ms)\", \"Delta (ms)\", \"Mean (ms)\", \"Min (ms)\", \"Max (ms)\", \"Total (ms)\", \"Self (ms)\"));\n        }\n//        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n//        System.out.println(StringEscapeUtils.unescapeJava(\"\\tEndpoint uri: \" + URISupport.sanitizeUri(camelRoute.getEndpoint().getEndpointUri())));\n\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + camelRoute.getId() + \"\\\",*\"), null);\n            for (ObjectName routeMBean : set) {\n                // the route must be part of the camel context\n                String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                if (camelId != null && camelId.equals(camelContext.getName())) {\n\n                    String xml = (String) mBeanServer.invoke(routeMBean, \"dumpRouteStatsAsXml\", new Object[]{Boolean.FALSE, Boolean.TRUE}, new String[]{\"boolean\", \"boolean\"});\n                    RouteStatDump route = (RouteStatDump) unmarshaller.unmarshal(new StringReader(xml));\n\n                    long count = route.getExchangesCompleted() + route.getExchangesFailed();\n                    System.out.println(String.format(OUTPUT_FORMAT, route.getId(), count, route.getLastProcessingTime(), route.getDeltaProcessingTime(),\n                            route.getMeanProcessingTime(), route.getMinProcessingTime(), route.getMaxProcessingTime(), route.getTotalProcessingTime(), route.getSelfProcessingTime()));\n\n                    for (ProcessorStatDump ps : route.getProcessorStats()) {\n                        // the self time is the total time of the processor itself\n                        long selfTime = ps.getTotalProcessingTime();\n                        count = ps.getExchangesCompleted() + ps.getExchangesFailed();\n                        // indent route id with 2 spaces\n                        System.out.println(String.format(OUTPUT_FORMAT, \"  \" + ps.getId(), count, ps.getLastProcessingTime(), ps.getDeltaProcessingTime(),\n                                ps.getMeanProcessingTime(), ps.getMinProcessingTime(), ps.getMaxProcessingTime(), ps.getAccumulatedProcessingTime(), selfTime));\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, profile are not available.\\u001B[0m\"));\n        }\n\n        // we want to group routes from the same context in the same table\n        previousCamelContextName = camelContext.getName();\n    }","id":106432,"modified_method":"@Override\n    public void executeOnRoute(CamelContext camelContext, Route camelRoute) throws Exception {\n        JAXBContext context = JAXBContext.newInstance(RouteStatDump.class);\n        Unmarshaller unmarshaller = context.createUnmarshaller();\n\n        // write new header for new camel context\n        if (previousCamelContextName == null || !previousCamelContextName.equals(camelContext.getName())) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProfile\\u001B[0m\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n            System.out.println(String.format(HEADER_FORMAT, \"Id\", \"Count\", \"Last (ms)\", \"Delta (ms)\", \"Mean (ms)\", \"Min (ms)\", \"Max (ms)\", \"Total (ms)\", \"Self (ms)\"));\n        }\n//        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n//        System.out.println(StringEscapeUtils.unescapeJava(\"\\tEndpoint uri: \" + URISupport.sanitizeUri(camelRoute.getEndpoint().getEndpointUri())));\n\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=routes,name=\\\"\" + camelRoute.getId() + \"\\\",*\"), null);\n            for (ObjectName routeMBean : set) {\n                // the route must be part of the camel context\n                String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                if (camelId != null && camelId.equals(camelContext.getName())) {\n\n                    String xml = (String) mBeanServer.invoke(routeMBean, \"dumpRouteStatsAsXml\", new Object[]{Boolean.FALSE, Boolean.TRUE}, new String[]{\"boolean\", \"boolean\"});\n                    RouteStatDump route = (RouteStatDump) unmarshaller.unmarshal(new StringReader(xml));\n\n                    long count = route.getExchangesCompleted() + route.getExchangesFailed();\n                    System.out.println(String.format(OUTPUT_FORMAT, route.getId(), count, route.getLastProcessingTime(), route.getDeltaProcessingTime(),\n                            route.getMeanProcessingTime(), route.getMinProcessingTime(), route.getMaxProcessingTime(), route.getTotalProcessingTime(), route.getSelfProcessingTime()));\n\n                    for (ProcessorStatDump ps : route.getProcessorStats()) {\n                        // the self time is the total time of the processor itself\n                        long selfTime = ps.getTotalProcessingTime();\n                        count = ps.getExchangesCompleted() + ps.getExchangesFailed();\n                        // indent route id with 2 spaces\n                        System.out.println(String.format(OUTPUT_FORMAT, \"  \" + ps.getId(), count, ps.getLastProcessingTime(), ps.getDeltaProcessingTime(),\n                                ps.getMeanProcessingTime(), ps.getMinProcessingTime(), ps.getMaxProcessingTime(), ps.getAccumulatedProcessingTime(), selfTime));\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, profile are not available.\\u001B[0m\"));\n        }\n\n        // we want to group routes from the same context in the same table\n        previousCamelContextName = camelContext.getName();\n    }","commit_id":"4a2af47205c496185d19918763101abe0c1af176","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void executeOnRoute(CamelContext camelContext, Route camelRoute) throws Exception {\n        String id = camelRoute.getId();\n\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            // reset route mbeans\n            ObjectName query = ObjectName.getInstance(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,*\");\n            Set<ObjectName> set = mBeanServer.queryNames(query, null);\n            Iterator<ObjectName> iterator = set.iterator();\n            while (iterator.hasNext()) {\n                ObjectName routeMBean = iterator.next();\n\n                String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                if (camelId != null && camelId.equals(camelContext.getName())) {\n                    mBeanServer.invoke(routeMBean, \"reset\", null, null);\n                }\n            }\n\n            // reset processor mbeans that belongs to the given route\n            query = ObjectName.getInstance(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=processors,*\");\n            set = mBeanServer.queryNames(query, null);\n            iterator = set.iterator();\n            while (iterator.hasNext()) {\n                ObjectName processorMBean = iterator.next();\n                // must belong to this camel context and match the route id\n                String camelId = (String) mBeanServer.getAttribute(processorMBean, \"CamelId\");\n                String routeId = (String) mBeanServer.getAttribute(processorMBean, \"RouteId\");\n                if (camelId != null && camelId.equals(camelContext.getName()) && routeId != null && routeId.equals(id)) {\n                    mBeanServer.invoke(processorMBean, \"reset\", null, null);\n                }\n            }\n        }\n    }","id":106433,"modified_method":"@Override\n    public void executeOnRoute(CamelContext camelContext, Route camelRoute) throws Exception {\n        String id = camelRoute.getId();\n\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            // reset route mbeans\n            ObjectName query = ObjectName.getInstance(agent.getMBeanObjectDomainName() + \":type=routes,*\");\n            Set<ObjectName> set = mBeanServer.queryNames(query, null);\n            Iterator<ObjectName> iterator = set.iterator();\n            while (iterator.hasNext()) {\n                ObjectName routeMBean = iterator.next();\n\n                String camelId = (String) mBeanServer.getAttribute(routeMBean, \"CamelId\");\n                if (camelId != null && camelId.equals(camelContext.getName())) {\n                    mBeanServer.invoke(routeMBean, \"reset\", null, null);\n                }\n            }\n\n            // reset processor mbeans that belongs to the given route\n            query = ObjectName.getInstance(agent.getMBeanObjectDomainName() + \":type=processors,*\");\n            set = mBeanServer.queryNames(query, null);\n            iterator = set.iterator();\n            while (iterator.hasNext()) {\n                ObjectName processorMBean = iterator.next();\n                // must belong to this camel context and match the route id\n                String camelId = (String) mBeanServer.getAttribute(processorMBean, \"CamelId\");\n                String routeId = (String) mBeanServer.getAttribute(processorMBean, \"RouteId\");\n                if (camelId != null && camelId.equals(camelContext.getName()) && routeId != null && routeId.equals(id)) {\n                    mBeanServer.invoke(processorMBean, \"reset\", null, null);\n                }\n            }\n        }\n    }","commit_id":"4a2af47205c496185d19918763101abe0c1af176","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean,  \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the camel Context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, the statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n        \n        return null;\n    }","id":106434,"modified_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean,  \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n        \n        return null;\n    }","commit_id":"02f857b9a0e187452b19d1815ac769a4c61a2b03","url":"https://github.com/apache/camel"},{"original_method":"private static Map<String, Integer> computeColumnWidths(final Iterable<CamelContext> camelContexts) throws Exception {\n        if (camelContexts == null) {\n            throw new IllegalArgumentException(\"unable to determine column widths from null Iterable<CamelContext>\");\n        } else {\n            int maxNameLen = 0;\n            int maxStatusLen = 0;\n            int maxUptimeLen = 0;\n\n            for (final CamelContext camelContext : camelContexts) {\n                final String name = camelContext.getName();\n                maxNameLen = java.lang.Math.max(maxNameLen, name == null ? 0 : name.length());\n             \n                final String status = camelContext.getStatus().toString();\n                maxStatusLen = java.lang.Math.max(maxStatusLen, status == null ? 0 : status.length());\n             \n                final String uptime = camelContext.getUptime();\n                maxUptimeLen = java.lang.Math.max(maxUptimeLen, uptime == null ? 0 : uptime.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(3);\n            retval.put(NAME_COLUMN_LABEL, maxNameLen);\n            retval.put(STATUS_COLUMN_LABEL, maxStatusLen);\n            retval.put(UPTIME_COLUMN_LABEL, maxUptimeLen);\n\n            return retval;\n        }\n    }","id":106435,"modified_method":"private static Map<String, Integer> computeColumnWidths(final Iterable<CamelContext> camelContexts) throws Exception {\n        if (camelContexts == null) {\n            throw new IllegalArgumentException(\"Unable to determine column widths from null Iterable<CamelContext>\");\n        } else {\n            int maxNameLen = 0;\n            int maxStatusLen = 0;\n            int maxUptimeLen = 0;\n\n            for (final CamelContext camelContext : camelContexts) {\n                final String name = camelContext.getName();\n                maxNameLen = java.lang.Math.max(maxNameLen, name == null ? 0 : name.length());\n             \n                final String status = camelContext.getStatus().toString();\n                maxStatusLen = java.lang.Math.max(maxStatusLen, status == null ? 0 : status.length());\n             \n                final String uptime = camelContext.getUptime();\n                maxUptimeLen = java.lang.Math.max(maxUptimeLen, uptime == null ? 0 : uptime.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(3);\n            retval.put(NAME_COLUMN_LABEL, maxNameLen);\n            retval.put(STATUS_COLUMN_LABEL, maxStatusLen);\n            retval.put(UPTIME_COLUMN_LABEL, maxUptimeLen);\n\n            return retval;\n        }\n    }","commit_id":"02f857b9a0e187452b19d1815ac769a4c61a2b03","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer mBeanServer = agent.getMBeanServer();\n                Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n                Iterator<ObjectName> iterator = set.iterator();\n                if (iterator.hasNext()) {\n                    ObjectName routeMBean = iterator.next();\n                    Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                    Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                    Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                    Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                    Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MaxProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                    Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                    Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                    Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                    String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                    String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                    String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                    // Test for null to see if a any exchanges have been processed first to avoid NPE\n                    Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                    SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                    if (firstExchangeTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                    } else {\n                        Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                    }\n\n                    // Again, check for null to avoid NPE\n                    Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                    if (lastExchangeCompletedTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                    } else {\n                        Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                    }\n                }\n            } else {\n                System.out.println(\"\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the camel Context\"));\n                System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, the statistics are not available.\\u001B[0m\"));\n            }\n\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n            RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n            System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        }\n        return null;\n    }","id":106436,"modified_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer mBeanServer = agent.getMBeanServer();\n                Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n                Iterator<ObjectName> iterator = set.iterator();\n                if (iterator.hasNext()) {\n                    ObjectName routeMBean = iterator.next();\n                    Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                    Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                    Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                    Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                    Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MaxProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                    Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                    Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                    Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                    String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                    String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                    String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                    // Test for null to see if a any exchanges have been processed first to avoid NPE\n                    Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                    SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                    if (firstExchangeTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                    } else {\n                        Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                    }\n\n                    // Again, check for null to avoid NPE\n                    Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                    if (lastExchangeCompletedTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                    } else {\n                        Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                    }\n                }\n            } else {\n                System.out.println(\"\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n                System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n            }\n\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n            RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n            System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        }\n        return null;\n    }","commit_id":"02f857b9a0e187452b19d1815ac769a4c61a2b03","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                Long deltaProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"DeltaProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object resetTimestampObj = mBeanServer.getAttribute(contextMBean, \"ResetTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (resetTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                // add type converter statistics if enabled\n                if (camelContext.getTypeConverterRegistry().getStatistics().isStatisticsEnabled()) {\n                    System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\tTypeConverterRegistry utilization: [attempts=%s, hits=%s, misses=%s, failures=%s]\",\n                            camelContext.getTypeConverterRegistry().getStatistics().getAttemptCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getHitCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getMissCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getFailedCounter())));\n                }\n\n                // add stream caching details if enabled\n                if (camelContext.getStreamCachingStrategy().isEnabled()) {\n                    System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\tStreamCachingStrategy: [spoolDirectory=%s, spoolChiper=%s, spoolThreshold=%s, spoolUsedHeapMemoryThreshold=%s, anySpoolRules=%s, bufferSize=%s, removeSpoolDirectoryWhenStopping=%s, statisticsEnabled=%s]\",\n                            camelContext.getStreamCachingStrategy().getSpoolDirectory(),\n                            camelContext.getStreamCachingStrategy().getSpoolChiper(),\n                            camelContext.getStreamCachingStrategy().getSpoolThreshold(),\n                            camelContext.getStreamCachingStrategy().getSpoolUsedHeapMemoryThreshold(),\n                            camelContext.getStreamCachingStrategy().isAnySpoolRules(),\n                            camelContext.getStreamCachingStrategy().getBufferSize(),\n                            camelContext.getStreamCachingStrategy().isRemoveSpoolDirectoryWhenStopping(),\n                            camelContext.getStreamCachingStrategy().getStatistics().isStatisticsEnabled())));\n\n                    if (camelContext.getStreamCachingStrategy().getStatistics().isStatisticsEnabled()) {\n                        System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\t                       [cacheMemoryCounter=%s, cacheMemorySize=%s, cacheMemoryAverageSize=%s, cacheSpoolCounter=%s, cacheSpoolSize=%s, cacheSpoolAverageSize=%s]\",\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemoryCounter(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemorySize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemoryAverageSize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolCounter(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolSize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolAverageSize())));\n                    }\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMessage History: \" + camelContext.isMessageHistory()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n\n        return null;\n    }","id":106437,"modified_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tManagementName: \" + camelContext.getManagementName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                Long deltaProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"DeltaProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tDelta Processing Time: \" + deltaProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object resetTimestampObj = mBeanServer.getAttribute(contextMBean, \"ResetTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (resetTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) resetTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tReset Statistics Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                // add type converter statistics if enabled\n                if (camelContext.getTypeConverterRegistry().getStatistics().isStatisticsEnabled()) {\n                    System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\tTypeConverterRegistry utilization: [attempts=%s, hits=%s, misses=%s, failures=%s]\",\n                            camelContext.getTypeConverterRegistry().getStatistics().getAttemptCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getHitCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getMissCounter(),\n                            camelContext.getTypeConverterRegistry().getStatistics().getFailedCounter())));\n                }\n\n                // add stream caching details if enabled\n                if (camelContext.getStreamCachingStrategy().isEnabled()) {\n                    System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\tStreamCachingStrategy: [spoolDirectory=%s, spoolChiper=%s, spoolThreshold=%s, spoolUsedHeapMemoryThreshold=%s, anySpoolRules=%s, bufferSize=%s, removeSpoolDirectoryWhenStopping=%s, statisticsEnabled=%s]\",\n                            camelContext.getStreamCachingStrategy().getSpoolDirectory(),\n                            camelContext.getStreamCachingStrategy().getSpoolChiper(),\n                            camelContext.getStreamCachingStrategy().getSpoolThreshold(),\n                            camelContext.getStreamCachingStrategy().getSpoolUsedHeapMemoryThreshold(),\n                            camelContext.getStreamCachingStrategy().isAnySpoolRules(),\n                            camelContext.getStreamCachingStrategy().getBufferSize(),\n                            camelContext.getStreamCachingStrategy().isRemoveSpoolDirectoryWhenStopping(),\n                            camelContext.getStreamCachingStrategy().getStatistics().isStatisticsEnabled())));\n\n                    if (camelContext.getStreamCachingStrategy().getStatistics().isStatisticsEnabled()) {\n                        System.out.println(StringEscapeUtils.unescapeJava(String.format(\"\\t                       [cacheMemoryCounter=%s, cacheMemorySize=%s, cacheMemoryAverageSize=%s, cacheSpoolCounter=%s, cacheSpoolSize=%s, cacheSpoolAverageSize=%s]\",\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemoryCounter(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemorySize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheMemoryAverageSize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolCounter(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolSize(),\n                                camelContext.getStreamCachingStrategy().getStatistics().getCacheSpoolAverageSize())));\n                    }\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the Camel context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, some statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mMiscellaneous\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tMessage History: \" + camelContext.isMessageHistory()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tClassResolver: \" + camelContext.getClassResolver()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tPackageScanClassResolver: \" + camelContext.getPackageScanClassResolver()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tApplicationContextClassLoader: \" + camelContext.getApplicationContextClassLoader()));\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDataformats\\u001B[0m\"));\n        for (String names : camelContext.getDataFormats().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + names));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mLanguages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        return null;\n    }","commit_id":"630aff69cbedcf0f48254506769414d6701d45c5","url":"https://github.com/apache/camel"},{"original_method":"public void run() {\r\n        MergeJob mergeJob;\r\n        DumpJob dumpJob;\r\n        try {\r\n            loop: while (true) {\r\n                controlQueue.acquire();\r\n                \r\n                // prefer dump actions to flush memory to disc\r\n                if (dumpQueue.size() > 0) {\r\n                    try {\r\n                        dumpJob = dumpQueue.take();\r\n                        dumpJob.dump();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (1)\", e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // otherwise do a merge operation\r\n                if (mergeQueue.size() > 0) {\r\n                    try {\r\n                        mergeJob = mergeQueue.take();\r\n                        mergeJob.merge();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (2)\", e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // check termination\r\n                if (this.terminate) {\r\n                    Log.logInfo(\"IODispatcher\", \"catched termination signal\");\r\n                    break;\r\n                }\r\n\r\n                Log.logSevere(\"IODispatcher\", \"main loop in bad state, dumpQueue.size() = \" + dumpQueue.size() + \", mergeQueue.size() = \" + mergeQueue.size() + \", controlQueue.availablePermits() = \" + controlQueue.availablePermits());\r\n                assert false : \"this process statt should not be reached\"; // this should never happen\r\n            }\r\n            Log.logInfo(\"IODispatcher\", \"loop terminated\");\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n            Log.logSevere(\"IODispatcher\", \"main run job was interrupted (3)\", e);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            Log.logSevere(\"IODispatcher\", \"main run job failed (4)\", e);\r\n        } finally {\r\n            Log.logInfo(\"IODispatcher\", \"terminating run job\");\r\n            controlQueue = null;\r\n            dumpQueue = null;\r\n            mergeQueue = null;\r\n            termination.release();\r\n        }\r\n    }","id":106438,"modified_method":"public void run() {\r\n        MergeJob mergeJob;\r\n        DumpJob dumpJob;\r\n        try {\r\n            loop: while (true) {\r\n                controlQueue.acquire();\r\n                \r\n                // prefer dump actions to flush memory to disc\r\n                if (dumpQueue.size() > 0) {\r\n                \tFile f = null;\r\n                    try {\r\n                        dumpJob = dumpQueue.take();\r\n                        f = dumpJob.file;\r\n                        dumpJob.dump();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (1)\", e);\r\n                        e.printStackTrace();\r\n                    } catch (Exception e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (1), dump to \" + f + \" failed.\", e);\r\n                    \te.printStackTrace();\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // otherwise do a merge operation\r\n                if (mergeQueue.size() > 0) {\r\n                \tFile f = null, f1 = null, f2 = null;\r\n                    try {\r\n                        mergeJob = mergeQueue.take();\r\n                        f = mergeJob.newFile;\r\n                        f1 = mergeJob.f1;\r\n                        f2 = mergeJob.f2;\r\n                        mergeJob.merge();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (2)\", e);\r\n                        e.printStackTrace();\r\n                    } catch (Exception e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (2), dump to \" + f + \" failed. Input files are \" + f1 + \" and \" + f2, e);\r\n                    \te.printStackTrace();\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // check termination\r\n                if (this.terminate) {\r\n                    Log.logInfo(\"IODispatcher\", \"catched termination signal\");\r\n                    break;\r\n                }\r\n\r\n                Log.logSevere(\"IODispatcher\", \"main loop in bad state, dumpQueue.size() = \" + dumpQueue.size() + \", mergeQueue.size() = \" + mergeQueue.size() + \", controlQueue.availablePermits() = \" + controlQueue.availablePermits());\r\n                assert false : \"this process statt should not be reached\"; // this should never happen\r\n            }\r\n            Log.logInfo(\"IODispatcher\", \"loop terminated\");\r\n        } catch (InterruptedException e) {\r\n            Log.logSevere(\"IODispatcher\", \"main run job was interrupted (3)\", e);\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            Log.logSevere(\"IODispatcher\", \"main run job failed (4)\", e);\r\n            e.printStackTrace();\r\n        } finally {\r\n            Log.logInfo(\"IODispatcher\", \"terminating run job\");\r\n            controlQueue = null;\r\n            dumpQueue = null;\r\n            mergeQueue = null;\r\n            termination.release();\r\n        }\r\n    }","commit_id":"083533e5ec8674d9569a39b70486c451f69e3790","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * merge this row collection with another row collection using an simultanous iteration of the input collections\r\n     * the current collection is not altered in any way, the returned collection is a new collection with copied content.\r\n     * @param c\r\n     * @return\r\n     */\r\n    protected static RowSet mergeEnum(RowCollection c0, RowCollection c1) {\r\n        assert c0.rowdef == c1.rowdef : c0.rowdef.toString() + \" != \" + c1.rowdef.toString();\r\n        RowSet r = new RowSet(c0.rowdef, c0.size() + c1.size());\r\n        c0.sort();\r\n        c1.sort();\r\n        int c0i = 0, c1i = 0;\r\n        int c0p, c1p;\r\n        int o;\r\n        final int objectsize = c0.rowdef.objectsize;\r\n        while (c0i < c0.size() && c1i < c1.size()) {\r\n            c0p = c0i * objectsize;\r\n            c1p = c1i * objectsize;\r\n            o = c0.rowdef.objectOrder.compare(\r\n                    c0.chunkcache, c0p, c0.rowdef.primaryKeyLength,\r\n                    c1.chunkcache, c1p, c0.rowdef.primaryKeyLength);\r\n            if (o == 0) {\r\n                r.addSorted(c0.chunkcache, c0p, objectsize);\r\n                c0i++;\r\n                c1i++;\r\n                continue;\r\n            }\r\n            if (o < 0) {\r\n                r.addSorted(c0.chunkcache, c0p, objectsize);\r\n                c0i++;\r\n                continue;\r\n            }\r\n            if (o > 0) {\r\n                r.addSorted(c1.chunkcache, c1p, objectsize);\r\n                c1i++;\r\n                continue;\r\n            }\r\n        }\r\n        while (c0i < c0.size()) {\r\n            r.addSorted(c0.chunkcache, c0i * objectsize, objectsize);\r\n            c0i++;\r\n        }\r\n        while (c1i < c1.size()) {\r\n            r.addSorted(c1.chunkcache, c1i * objectsize, objectsize);\r\n            c1i++;\r\n        }\r\n        return r;\r\n    }","id":106439,"modified_method":"/**\r\n     * merge this row collection with another row collection using an simultanous iteration of the input collections\r\n     * the current collection is not altered in any way, the returned collection is a new collection with copied content.\r\n     * @param c\r\n     * @return\r\n     */\r\n    protected static RowSet mergeEnum(RowCollection c0, RowCollection c1) {\r\n        assert c0.rowdef == c1.rowdef : c0.rowdef.toString() + \" != \" + c1.rowdef.toString();\r\n        RowSet r = new RowSet(c0.rowdef, c0.size() + c1.size());\r\n        try {\r\n        \tc0.sort();\r\n        } catch (Exception e) {\r\n        \tLog.logSevere(\"RowSet\", \"collection corrupted. cleaned. \" + e.getMessage());\r\n        \te.printStackTrace();\r\n        \tc0.clear();\r\n        }\r\n        try {\r\n        \tc1.sort();\r\n        } catch (Exception e) {\r\n        \tLog.logSevere(\"RowSet\", \"collection corrupted. cleaned. \" + e.getMessage());\r\n        \te.printStackTrace();\r\n        \tc1.clear();\r\n        }\r\n        int c0i = 0, c1i = 0;\r\n        int c0p, c1p;\r\n        int o;\r\n        final int objectsize = c0.rowdef.objectsize;\r\n        while (c0i < c0.size() && c1i < c1.size()) {\r\n            c0p = c0i * objectsize;\r\n            c1p = c1i * objectsize;\r\n            o = c0.rowdef.objectOrder.compare(\r\n                    c0.chunkcache, c0p, c0.rowdef.primaryKeyLength,\r\n                    c1.chunkcache, c1p, c0.rowdef.primaryKeyLength);\r\n            if (o == 0) {\r\n                r.addSorted(c0.chunkcache, c0p, objectsize);\r\n                c0i++;\r\n                c1i++;\r\n                continue;\r\n            }\r\n            if (o < 0) {\r\n                r.addSorted(c0.chunkcache, c0p, objectsize);\r\n                c0i++;\r\n                continue;\r\n            }\r\n            if (o > 0) {\r\n                r.addSorted(c1.chunkcache, c1p, objectsize);\r\n                c1i++;\r\n                continue;\r\n            }\r\n        }\r\n        while (c0i < c0.size()) {\r\n            r.addSorted(c0.chunkcache, c0i * objectsize, objectsize);\r\n            c0i++;\r\n        }\r\n        while (c1i < c1.size()) {\r\n            r.addSorted(c1.chunkcache, c1i * objectsize, objectsize);\r\n            c1i++;\r\n        }\r\n        return r;\r\n    }","commit_id":"083533e5ec8674d9569a39b70486c451f69e3790","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * this is called by the switchboard to put in a new page into the index\r\n     * use all the words in one condenser object to simultanous create index entries\r\n     * \r\n     * @param url\r\n     * @param urlModified\r\n     * @param document\r\n     * @param condenser\r\n     * @param language\r\n     * @param doctype\r\n     * @param outlinksSame\r\n     * @param outlinksOther\r\n     * @return\r\n     */\r\n    public int addPageIndex(final yacyURL url, final Date urlModified, final plasmaParserDocument document, final Condenser condenser, final String language, final char doctype, final int outlinksSame, final int outlinksOther) {\r\n        int wordCount = 0;\r\n        final int urlLength = url.toNormalform(true, true).length();\r\n        final int urlComps = htmlFilterContentScraper.urlComps(url.toString()).length;\r\n        \r\n        // check if merger is running\r\n        if (this.merger != null && !this.merger.isAlive()) {\r\n        \tlog.logSevere(\"re-starting IODispatcher\");\r\n        \tthis.merger.start();\r\n        }\r\n        \r\n        // iterate over all words of context text\r\n        final Iterator<Map.Entry<String, Word>> i = condenser.words().entrySet().iterator();\r\n        Map.Entry<String, Word> wentry;\r\n        String word;\r\n        int len = (document == null) ? urlLength : document.dc_title().length();\r\n        WordReferenceRow ientry = new WordReferenceRow(url.hash(),\r\n                                urlLength, urlComps, len,\r\n                                condenser.RESULT_NUMB_WORDS,\r\n                                condenser.RESULT_NUMB_SENTENCES,\r\n                                urlModified.getTime(),\r\n                                System.currentTimeMillis(),\r\n                                language,\r\n                                doctype,\r\n                                outlinksSame, outlinksOther);\r\n        Word wprop;\r\n        while (i.hasNext()) {\r\n            wentry = i.next();\r\n            word = wentry.getKey();\r\n            wprop = wentry.getValue();\r\n            assert (wprop.flags != null);\r\n            ientry.setWord(wprop);\r\n            try {\r\n                this.index.add(Word.word2hash(word), ientry);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            wordCount++;\r\n        }\r\n        \r\n        return wordCount;\r\n    }","id":106440,"modified_method":"/**\r\n     * this is called by the switchboard to put in a new page into the index\r\n     * use all the words in one condenser object to simultanous create index entries\r\n     * \r\n     * @param url\r\n     * @param urlModified\r\n     * @param document\r\n     * @param condenser\r\n     * @param language\r\n     * @param doctype\r\n     * @param outlinksSame\r\n     * @param outlinksOther\r\n     * @return\r\n     */\r\n    public int addPageIndex(final yacyURL url, final Date urlModified, final plasmaParserDocument document, final Condenser condenser, final String language, final char doctype, final int outlinksSame, final int outlinksOther) {\r\n        int wordCount = 0;\r\n        final int urlLength = url.toNormalform(true, true).length();\r\n        final int urlComps = htmlFilterContentScraper.urlComps(url.toString()).length;\r\n        \r\n        // iterate over all words of context text\r\n        final Iterator<Map.Entry<String, Word>> i = condenser.words().entrySet().iterator();\r\n        Map.Entry<String, Word> wentry;\r\n        String word;\r\n        int len = (document == null) ? urlLength : document.dc_title().length();\r\n        WordReferenceRow ientry = new WordReferenceRow(url.hash(),\r\n                                urlLength, urlComps, len,\r\n                                condenser.RESULT_NUMB_WORDS,\r\n                                condenser.RESULT_NUMB_SENTENCES,\r\n                                urlModified.getTime(),\r\n                                System.currentTimeMillis(),\r\n                                language,\r\n                                doctype,\r\n                                outlinksSame, outlinksOther);\r\n        Word wprop;\r\n        while (i.hasNext()) {\r\n            wentry = i.next();\r\n            word = wentry.getKey();\r\n            wprop = wentry.getValue();\r\n            assert (wprop.flags != null);\r\n            ientry.setWord(wprop);\r\n            try {\r\n                this.index.add(Word.word2hash(word), ientry);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            wordCount++;\r\n        }\r\n        \r\n        return wordCount;\r\n    }","commit_id":"083533e5ec8674d9569a39b70486c451f69e3790","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiManager manager = file.getManager();\n    PsiElementFactory factory = manager.getElementFactory();\n    PsiMethod method = findMethod(file, editor.getCaretModel().getOffset());\n    PsiAnnotation annotation = factory.createAnnotationFromText(\"@\" + ourFQName, method);\n    method.getModifierList().addAfter(annotation, null);\n  }","id":106441,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiMethod method = findMethod(file, editor.getCaretModel().getOffset());\n    new AddAnnotationAction(ourFQName, method).invoke(project, editor, file);\n  }","commit_id":"25e56e0105602d24181c3fe62a607228153642af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    PsiMethod method = findMethod(file, editor.getCaretModel().getOffset());\n    if (method == null) return false;\n    if (method.getModifierList().findAnnotation(ourFQName) != null) return false;\n    PsiMethod[] superMethods = method.findSuperMethods();\n    for (int i = 0; i < superMethods.length; i++) {\n      PsiMethod superMethod = superMethods[i];\n      if (!superMethod.hasModifierProperty(PsiModifier.ABSTRACT)) return true;\n    }\n\n    return false;\n  }","id":106442,"modified_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    PsiMethod method = findMethod(file, editor.getCaretModel().getOffset());\n    if (method == null) return false;\n    if (method.getModifierList().findAnnotation(ourFQName) != null) return false;\n    PsiMethod[] superMethods = method.findSuperMethods();\n    for (PsiMethod superMethod : superMethods) {\n      if (!superMethod.hasModifierProperty(PsiModifier.ABSTRACT)\n          && new AddAnnotationAction(ourFQName, method).isAvailable(project, editor, file)) {\n        return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"25e56e0105602d24181c3fe62a607228153642af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkNullableStuff(PsiMethod method, List<MethodSignatureBackedByPsiMethod> superMethodSignatures) {\n    boolean isDeclaredNotNull = AnnotationUtil.isAnnotated(method, AnnotationUtil.NOT_NULL, false);\n    boolean isDeclaredNullable = AnnotationUtil.isAnnotated(method, AnnotationUtil.NULLABLE, false);\n    if (isDeclaredNullable && isDeclaredNotNull) {\n      return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, method.getNameIdentifier(),\n                                               \"Cannot annotate with both @Nullable and @NotNull\");\n    }\n\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n\n    for (MethodSignatureBackedByPsiMethod superMethodSignature : superMethodSignatures) {\n      PsiMethod superMethod = superMethodSignature.getMethod();\n      if (isDeclaredNullable && AnnotationUtil.isNotNull(superMethod)) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, method.getNameIdentifier(),\n                                                 \"Method annotated with @Nullable must not override @NotNull method\");\n      }\n      if (!isDeclaredNullable && !isDeclaredNotNull && AnnotationUtil.isNotNull(superMethod)) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, method.getNameIdentifier(),\n                                                 \"Not annotated method overrides method annotated with @NotNull\");\n      }\n      PsiParameter[] superParameters = superMethod.getParameterList().getParameters();\n      if (superParameters.length != parameters.length) {\n        continue;\n      }\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        PsiParameter superParameter = superParameters[i];\n        if (AnnotationUtil.isAnnotated(parameter, AnnotationUtil.NOT_NULL, false) && AnnotationUtil.isAnnotated(superParameter, AnnotationUtil.NULLABLE, false)) {\n          return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, parameter.getNameIdentifier(),\n                                                   \"Parameter annotated @NonNull must not override @Nullable parameter\");\n        }\n      }\n    }\n\n    return null;\n  }","id":106443,"modified_method":"public static HighlightInfo checkNullableStuff(PsiMethod method, List<MethodSignatureBackedByPsiMethod> superMethodSignatures) {\n    boolean isDeclaredNotNull = AnnotationUtil.isAnnotated(method, AnnotationUtil.NOT_NULL, false);\n    boolean isDeclaredNullable = AnnotationUtil.isAnnotated(method, AnnotationUtil.NULLABLE, false);\n    if (isDeclaredNullable && isDeclaredNotNull) {\n      return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, method.getNameIdentifier(),\n                                               \"Cannot annotate with both @Nullable and @NotNull\");\n    }\n\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n\n    for (MethodSignatureBackedByPsiMethod superMethodSignature : superMethodSignatures) {\n      PsiMethod superMethod = superMethodSignature.getMethod();\n      if (isDeclaredNullable && AnnotationUtil.isNotNull(superMethod)) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, method.getNameIdentifier(),\n                                                 \"Method annotated with @Nullable must not override @NotNull method\");\n      }\n      if (!isDeclaredNullable && !isDeclaredNotNull && AnnotationUtil.isNotNull(superMethod)) {\n        HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, method.getNameIdentifier(),\n                                                                     \"Not annotated method overrides method annotated with @NotNull\");\n        QuickFixAction.registerQuickFixAction(info, new AddAnnotationAction(AnnotationUtil.NOT_NULL, method), null);\n        return info;\n      }\n      PsiParameter[] superParameters = superMethod.getParameterList().getParameters();\n      if (superParameters.length != parameters.length) {\n        continue;\n      }\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        PsiParameter superParameter = superParameters[i];\n        if (AnnotationUtil.isAnnotated(parameter, AnnotationUtil.NOT_NULL, false) && AnnotationUtil.isAnnotated(superParameter, AnnotationUtil.NULLABLE, false)) {\n          return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, parameter.getNameIdentifier(),\n                                                   \"Parameter annotated @NonNull must not override @Nullable parameter\");\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"25e56e0105602d24181c3fe62a607228153642af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void annotateMethod(final PsiMethod method) {\n      final PsiModifierList modList = method.getModifierList();\n      if (modList.findAnnotation(AnnotationUtil.NULLABLE) != null) return;\n\n      if (ReadonlyStatusHandler.getInstance(method.getProject()).ensureFilesWritable(\n        new VirtualFile[]{method.getContainingFile().getVirtualFile()}).hasReadonlyFiles()) {\n        return;\n      }\n\n      try {\n        PsiAnnotation annotation = method.getManager().getElementFactory().createAnnotationFromText(\"@\" + AnnotationUtil.NULLABLE, method);\n        modList.addBefore(annotation, modList.getFirstChild());\n\n        CodeStyleManager.getInstance(method.getProject()).shortenClassReferences(modList);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }","id":106444,"modified_method":"private static void annotateMethod(final PsiMethod method) {\n      try {\n        new AddAnnotationAction(AnnotationUtil.NULLABLE, method).invoke(method.getProject(), null, method.getContainingFile());\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }","commit_id":"25e56e0105602d24181c3fe62a607228153642af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static HighlightInfo checkImplementsAllowed(PsiReferenceList list) {\n    if (list.getParent() instanceof PsiClass) {\n      PsiClass aClass = (PsiClass)list.getParent();\n      if (aClass.isInterface()) {\n        boolean isImplements = list.equals(aClass.getImplementsList());\n        if (isImplements) {\n          return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, JavaErrorMessages.message(\"implements.after.interface\"));\n        }\n      }\n    }\n    return null;\n  }","id":106445,"modified_method":"static HighlightInfo checkImplementsAllowed(PsiReferenceList list) {\n    if (list.getParent() instanceof PsiClass) {\n      PsiClass aClass = (PsiClass)list.getParent();\n      if (aClass.isInterface()) {\n        boolean isImplements = list.equals(aClass.getImplementsList());\n        if (isImplements) {\n          final HighlightInfo highlightInfo =\n            HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, JavaErrorMessages.message(\"implements.after.interface\"));\n          final PsiClassType[] referencedTypes = list.getReferencedTypes();\n          if (referencedTypes.length > 0) {\n            QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeExtendsToImplementsFix(aClass, referencedTypes[0]));\n          }\n          return highlightInfo;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"da098b2a31b7a92bf07805353a65e08513def859","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkNameValuePair(PsiNameValuePair pair) {\n    PsiReference ref = pair.getReference();\n    if (ref == null) return null;\n    PsiMethod method = (PsiMethod)ref.resolve();\n    if (method == null) {\n      if (pair.getName() != null) {\n        String description = JavaErrorMessages.message(\"annotation.unknown.method\", ref.getCanonicalText());\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.WRONG_REF, ref.getElement(), description);\n      }\n      else {\n        String description = JavaErrorMessages.message(\"annotation.missing.method\", ref.getCanonicalText());\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, ref.getElement(), description);\n      }\n    }\n    else {\n      PsiType returnType = method.getReturnType();\n      PsiAnnotationMemberValue value = pair.getValue();\n      HighlightInfo info = checkMemberValueType(value, returnType);\n      if (info != null) return info;\n\n      return checkDuplicateAttribute(pair);\n    }\n  }","id":106446,"modified_method":"public static HighlightInfo checkNameValuePair(PsiNameValuePair pair) {\n    PsiReference ref = pair.getReference();\n    if (ref == null) return null;\n    PsiMethod method = (PsiMethod)ref.resolve();\n    if (method == null) {\n      if (pair.getName() != null) {\n        final String description = JavaErrorMessages.message(\"annotation.unknown.method\", ref.getCanonicalText());\n        final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.WRONG_REF, ref.getElement(), description);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateAnnotationMethodFromUsageFix(pair));\n        return highlightInfo;\n      }\n      else {\n        String description = JavaErrorMessages.message(\"annotation.missing.method\", ref.getCanonicalText());\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, ref.getElement(), description);\n      }\n    }\n    else {\n      PsiType returnType = method.getReturnType();\n      PsiAnnotationMemberValue value = pair.getValue();\n      HighlightInfo info = checkMemberValueType(value, returnType);\n      if (info != null) return info;\n\n      return checkDuplicateAttribute(pair);\n    }\n  }","commit_id":"ed24c9b3960bd61206e614a2f9d68323d14a8632","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected List<PsiClass> getTargetClasses(PsiElement element) {\n    PsiClass psiClass = null;\n    PsiExpression qualifier = null;\n\n    if (element instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)element;\n      PsiJavaCodeReferenceElement ref = newExpression.getClassOrAnonymousClassReference();\n      if (ref != null) {\n        PsiElement refElement = ref.resolve();\n        if (refElement instanceof PsiClass) psiClass = (PsiClass)refElement;\n      }\n    }\n    else if (element instanceof PsiReferenceExpression) {\n      qualifier = ((PsiReferenceExpression)element).getQualifierExpression();\n    }\n    else if (element instanceof PsiMethodCallExpression) {\n      final PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)element).getMethodExpression();\n      qualifier = methodExpression.getQualifierExpression();\n      @NonNls final String referenceName = methodExpression.getReferenceName();\n      if (referenceName == null) return Collections.emptyList();\n    }\n    boolean allowOuterClasses = false;\n    if (qualifier != null) {\n      PsiType type = qualifier.getType();\n      if (type instanceof PsiClassType) {\n        psiClass = ((PsiClassType)type).resolve();\n      }\n\n      if (qualifier instanceof PsiJavaCodeReferenceElement) {\n        final PsiElement resolved = ((PsiJavaCodeReferenceElement)qualifier).resolve();\n        if (resolved instanceof PsiClass) {\n          if (psiClass == null) psiClass = (PsiClass)resolved;\n        }\n      }\n    } else if (psiClass == null) {\n      psiClass = PsiTreeUtil.getParentOfType(element, PsiClass.class);\n      allowOuterClasses = true;\n    }\n\n    if (psiClass instanceof PsiTypeParameter) {\n      PsiClass[] supers = psiClass.getSupers();\n      List<PsiClass> filtered = new ArrayList<PsiClass>();\n      for (PsiClass aSuper : supers) {\n        if (!aSuper.getManager().isInProject(aSuper)) continue;\n        if (!(aSuper instanceof PsiTypeParameter)) filtered.add(aSuper);\n      }\n      return filtered;\n    }\n    else {\n      if (psiClass == null || !psiClass.getManager().isInProject(psiClass)) {\n        return Collections.emptyList();\n      }\n\n      if (!allowOuterClasses ||\n          !isAllowOuterTargetClass() ||\n          ApplicationManager.getApplication().isUnitTestMode())\n        return Collections.singletonList(psiClass);\n\n      List<PsiClass> result = new ArrayList<PsiClass>();\n\n      while (psiClass != null) {\n        result.add(psiClass);\n        if (psiClass.hasModifierProperty(PsiModifier.STATIC)) break;\n        psiClass = PsiTreeUtil.getParentOfType(psiClass, PsiClass.class);\n      }\n      return result;\n    }\n  }","id":106447,"modified_method":"@NotNull\n  protected List<PsiClass> getTargetClasses(PsiElement element) {\n    PsiClass psiClass = null;\n    PsiExpression qualifier = null;\n\n    if (element instanceof PsiNameValuePair) {\n      final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(element, PsiAnnotation.class);\n      if (annotation != null) {\n        PsiJavaCodeReferenceElement nameRef = annotation.getNameReferenceElement();\n        if (nameRef == null) {\n          return Collections.emptyList();\n        }\n        else {\n          final PsiElement resolve = nameRef.resolve();\n          if (resolve instanceof PsiClass) {\n            return Collections.singletonList((PsiClass)resolve);\n          }\n          else {\n            return Collections.emptyList();\n          }\n        }\n      }\n    }\n    if (element instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)element;\n      PsiJavaCodeReferenceElement ref = newExpression.getClassOrAnonymousClassReference();\n      if (ref != null) {\n        PsiElement refElement = ref.resolve();\n        if (refElement instanceof PsiClass) psiClass = (PsiClass)refElement;\n      }\n    }\n    else if (element instanceof PsiReferenceExpression) {\n      qualifier = ((PsiReferenceExpression)element).getQualifierExpression();\n    }\n    else if (element instanceof PsiMethodCallExpression) {\n      final PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)element).getMethodExpression();\n      qualifier = methodExpression.getQualifierExpression();\n      @NonNls final String referenceName = methodExpression.getReferenceName();\n      if (referenceName == null) return Collections.emptyList();\n    }\n    boolean allowOuterClasses = false;\n    if (qualifier != null) {\n      PsiType type = qualifier.getType();\n      if (type instanceof PsiClassType) {\n        psiClass = ((PsiClassType)type).resolve();\n      }\n\n      if (qualifier instanceof PsiJavaCodeReferenceElement) {\n        final PsiElement resolved = ((PsiJavaCodeReferenceElement)qualifier).resolve();\n        if (resolved instanceof PsiClass) {\n          if (psiClass == null) psiClass = (PsiClass)resolved;\n        }\n      }\n    } else if (psiClass == null) {\n      psiClass = PsiTreeUtil.getParentOfType(element, PsiClass.class);\n      allowOuterClasses = true;\n    }\n\n    if (psiClass instanceof PsiTypeParameter) {\n      PsiClass[] supers = psiClass.getSupers();\n      List<PsiClass> filtered = new ArrayList<PsiClass>();\n      for (PsiClass aSuper : supers) {\n        if (!aSuper.getManager().isInProject(aSuper)) continue;\n        if (!(aSuper instanceof PsiTypeParameter)) filtered.add(aSuper);\n      }\n      return filtered;\n    }\n    else {\n      if (psiClass == null || !psiClass.getManager().isInProject(psiClass)) {\n        return Collections.emptyList();\n      }\n\n      if (!allowOuterClasses ||\n          !isAllowOuterTargetClass() ||\n          ApplicationManager.getApplication().isUnitTestMode())\n        return Collections.singletonList(psiClass);\n\n      List<PsiClass> result = new ArrayList<PsiClass>();\n\n      while (psiClass != null) {\n        result.add(psiClass);\n        if (psiClass.hasModifierProperty(PsiModifier.STATIC)) break;\n        psiClass = PsiTreeUtil.getParentOfType(psiClass, PsiClass.class);\n      }\n      return result;\n    }\n  }","commit_id":"ed24c9b3960bd61206e614a2f9d68323d14a8632","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doCreate(PsiClass targetClass,\n                               PsiMethod method,\n                               boolean shouldBeAbstract,\n                               List<Pair<PsiExpression, PsiType>> arguments,\n                               PsiSubstitutor substitutor,\n                               ExpectedTypeInfo[] expectedTypes,\n                               @Nullable final PsiElement context) {\n\n    method = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(method);\n\n    if (method == null) {\n      return;\n    }\n    final Project project = targetClass.getProject();\n    final PsiFile targetFile = targetClass.getContainingFile();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(targetFile);\n    if (document == null) return;\n\n    TemplateBuilderImpl builder = new TemplateBuilderImpl(method);\n\n    CreateFromUsageUtils.setupMethodParameters(method, builder, context, substitutor, arguments);\n    new GuessTypeParameters(JavaPsiFacade.getInstance(project).getElementFactory())\n      .setupTypeElement(method.getReturnTypeElement(), expectedTypes, substitutor, builder, context, targetClass);\n    PsiCodeBlock body = method.getBody();\n    builder.setEndVariableAfter(shouldBeAbstract || body == null ? method : body.getLBrace());\n    method = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(method);\n    if (method == null) return;\n\n    RangeMarker rangeMarker = document.createRangeMarker(method.getTextRange());\n    final Editor newEditor = positionCursor(project, targetFile, method);\n    Template template = builder.buildTemplate();\n    newEditor.getCaretModel().moveToOffset(rangeMarker.getStartOffset());\n    newEditor.getDocument().deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n    rangeMarker.dispose();\n\n    if (!shouldBeAbstract) {\n      startTemplate(newEditor, template, project, new TemplateEditingAdapter() {\n        public void templateFinished(Template template, boolean brokenOff) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              PsiDocumentManager.getInstance(project).commitDocument(newEditor.getDocument());\n              final int offset = newEditor.getCaretModel().getOffset();\n              PsiMethod method = PsiTreeUtil.findElementOfClassAtOffset(targetFile, offset - 1, PsiMethod.class, false);\n              if (context instanceof PsiMethod) {\n                final PsiTypeParameter[] typeParameters = ((PsiMethod)context).getTypeParameters();\n                if (typeParameters.length > 0) {\n                  for (PsiTypeParameter typeParameter : typeParameters) {\n                    if (checkTypeParam( method, typeParameter)) {\n                      method.getTypeParameterList().add(typeParameter);\n                    }\n                  }\n                }\n              }\n              if (method != null) {\n                try {\n                  CreateFromUsageUtils.setupMethodBody(method);\n                }\n                catch (IncorrectOperationException e) {\n                  LOG.error(e);\n                }\n\n                CreateFromUsageUtils.setupEditor(method, newEditor);\n              }\n            }\n          });\n        }\n      });\n    }\n    else {\n      startTemplate(newEditor, template, project);\n    }\n  }","id":106448,"modified_method":"public static void doCreate(PsiClass targetClass,\n                               PsiMethod method,\n                               boolean shouldBeAbstract,\n                               List<Pair<PsiExpression, PsiType>> arguments,\n                               PsiSubstitutor substitutor,\n                               ExpectedTypeInfo[] expectedTypes,\n                               @Nullable final PsiElement context) {\n\n    method = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(method);\n\n    if (method == null) {\n      return;\n    }\n    final Project project = targetClass.getProject();\n    final PsiFile targetFile = targetClass.getContainingFile();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(targetFile);\n    if (document == null) return;\n\n    TemplateBuilderImpl builder = new TemplateBuilderImpl(method);\n\n    CreateFromUsageUtils.setupMethodParameters(method, builder, context, substitutor, arguments);\n    new GuessTypeParameters(JavaPsiFacade.getInstance(project).getElementFactory())\n      .setupTypeElement(method.getReturnTypeElement(), expectedTypes, substitutor, builder, context, targetClass);\n    PsiCodeBlock body = method.getBody();\n    builder.setEndVariableAfter(shouldBeAbstract || body == null ? method : body.getLBrace());\n    method = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(method);\n    if (method == null) return;\n\n    RangeMarker rangeMarker = document.createRangeMarker(method.getTextRange());\n    final Editor newEditor = positionCursor(project, targetFile, method);\n    Template template = builder.buildTemplate();\n    newEditor.getCaretModel().moveToOffset(rangeMarker.getStartOffset());\n    newEditor.getDocument().deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n    rangeMarker.dispose();\n\n    if (!shouldBeAbstract) {\n      startTemplate(newEditor, template, project, new TemplateEditingAdapter() {\n        public void templateFinished(Template template, boolean brokenOff) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              PsiDocumentManager.getInstance(project).commitDocument(newEditor.getDocument());\n              final int offset = newEditor.getCaretModel().getOffset();\n              PsiMethod method = PsiTreeUtil.findElementOfClassAtOffset(targetFile, offset - 1, PsiMethod.class, false);\n              if (context instanceof PsiMethod) {\n                final PsiTypeParameter[] typeParameters = ((PsiMethod)context).getTypeParameters();\n                if (typeParameters.length > 0) {\n                  for (PsiTypeParameter typeParameter : typeParameters) {\n                    if (checkTypeParam( method, typeParameter)) {\n                      method.getTypeParameterList().add(typeParameter);\n                    }\n                  }\n                }\n              }\n              if (method != null) {\n                try {\n                  CreateFromUsageUtils.setupMethodBody(method);\n                }\n                catch (IncorrectOperationException e) {\n                  LOG.error(e);\n                }\n\n                CreateFromUsageUtils.setupEditor(method, newEditor);\n              }\n            }\n          });\n        }\n      });\n    }\n    else {\n      startTemplate(newEditor, template, project);\n    }\n  }","commit_id":"ed24c9b3960bd61206e614a2f9d68323d14a8632","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkApplicability(PsiAnnotation annotation) {\n    PsiAnnotationOwner owner = annotation.getOwner();\n    if (!(owner instanceof PsiModifierList || owner instanceof PsiTypeElement || owner instanceof PsiMethodReceiver || owner instanceof PsiTypeParameter)) return null;\n    PsiElement member = ((PsiElement)owner).getParent();\n    String[] elementTypeFields = getApplicableElementTypeFields(owner instanceof PsiModifierList ? member : (PsiElement)owner);\n    if (isAnnotationApplicableTo(annotation, false, elementTypeFields)) return null;\n    PsiJavaCodeReferenceElement nameRef = annotation.getNameReferenceElement();\n    String description = JavaErrorMessages.message(\"annotation.not.applicable\",\n                                                   nameRef.getText(),\n                                                   JavaErrorMessages.message(\"annotation.target.\" + elementTypeFields[0]));\n    return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, nameRef, description);\n  }","id":106449,"modified_method":"public static HighlightInfo checkApplicability(final PsiAnnotation annotation) {\n    PsiAnnotationOwner owner = annotation.getOwner();\n    if (!(owner instanceof PsiModifierList || owner instanceof PsiTypeElement || owner instanceof PsiMethodReceiver || owner instanceof PsiTypeParameter)) return null;\n    PsiElement member = ((PsiElement)owner).getParent();\n    String[] elementTypeFields = getApplicableElementTypeFields(owner instanceof PsiModifierList ? member : (PsiElement)owner);\n    if (isAnnotationApplicableTo(annotation, false, elementTypeFields)) return null;\n    PsiJavaCodeReferenceElement nameRef = annotation.getNameReferenceElement();\n    String description = JavaErrorMessages.message(\"annotation.not.applicable\",\n                                                   nameRef.getText(),\n                                                   JavaErrorMessages.message(\"annotation.target.\" + elementTypeFields[0]));\n    final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, nameRef, description);\n    QuickFixAction.registerQuickFixAction(highlightInfo, new DeleteNotApplicableAnnotationAction(annotation));\n    return highlightInfo;\n  }","commit_id":"79e3df1fff15f972fbaf84d6656080f00dac2396","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkBaseClassDefaultConstructorProblem(PsiClass aClass,\n                                                                      RefCountHolder refCountHolder,\n                                                                      PsiResolveHelper resolveHelper,\n                                                                      TextRange textRange,\n                                                                      @NotNull PsiClassType[] handledExceptions) {\n    PsiClass baseClass = aClass.getSuperClass();\n    if (baseClass == null) return null;\n    PsiMethod[] constructors = baseClass.getConstructors();\n    if (constructors.length == 0) return null;\n\n    for (PsiMethod constructor : constructors) {\n      if (resolveHelper.isAccessible(constructor, aClass, null)) {\n        if (constructor.getParameterList().getParametersCount() == 0 ||\n            constructor.getParameterList().getParametersCount() == 1 && constructor.isVarArgs()\n          ) {\n          // it is an error if base ctr throws exceptions\n          String description = checkDefaultConstructorThrowsException(constructor, handledExceptions);\n          if (description != null) {\n            return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, description);\n          }\n          if (refCountHolder != null) {\n            refCountHolder.registerLocallyReferenced(constructor);\n          }\n          return null;\n        }\n      }\n    }\n\n    String description = JavaErrorMessages.message(\"no.default.constructor.available\", HighlightUtil.formatClass(baseClass));\n\n    HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, description);\n    QuickFixAction.registerQuickFixAction(info, new CreateConstructorMatchingSuperFix(aClass));\n\n    return info;\n  }","id":106450,"modified_method":"public static HighlightInfo checkBaseClassDefaultConstructorProblem(PsiClass aClass,\n                                                                      RefCountHolder refCountHolder,\n                                                                      PsiResolveHelper resolveHelper,\n                                                                      TextRange textRange,\n                                                                      @NotNull PsiClassType[] handledExceptions) {\n    PsiClass baseClass = aClass.getSuperClass();\n    if (baseClass == null) return null;\n    PsiMethod[] constructors = baseClass.getConstructors();\n    if (constructors.length == 0) return null;\n\n    for (PsiMethod constructor : constructors) {\n      if (resolveHelper.isAccessible(constructor, aClass, null)) {\n        if (constructor.getParameterList().getParametersCount() == 0 ||\n            constructor.getParameterList().getParametersCount() == 1 && constructor.isVarArgs()\n          ) {\n          // it is an error if base ctr throws exceptions\n          String description = checkDefaultConstructorThrowsException(constructor, handledExceptions);\n          if (description != null) {\n            final HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, description);\n            QuickFixAction.registerQuickFixAction(info, new CreateConstructorMatchingSuperFix(aClass));\n            return info;\n          }\n          if (refCountHolder != null) {\n            refCountHolder.registerLocallyReferenced(constructor);\n          }\n          return null;\n        }\n      }\n    }\n\n    String description = JavaErrorMessages.message(\"no.default.constructor.available\", HighlightUtil.formatClass(baseClass));\n\n    HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, description);\n    QuickFixAction.registerQuickFixAction(info, new CreateConstructorMatchingSuperFix(aClass));\n\n    return info;\n  }","commit_id":"8f2a390367f0a833d27bebeb4c8d0fca5c5acd05","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append(\"_\");\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106451,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append('_');\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    this(t, w, hf, false);\n  }","id":106452,"modified_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    CoordinationTransformer transformer = new CoordinationTransformer(hf);\n    this.wnConnect = w;\n    this.qTree = transformer.transformTree(t);\n    this.collocationCollector = Generics.newArrayList();\n    this.hf = hf;\n    this.getCollocationsList();\n    if (DEBUG) {\n      System.err.println(\"Collected collocations: \" + collocationCollector);\n    }\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n * Traverses the parse tree to find WordNet collocations.\n */\n  private void getCollocationsList(boolean threadSafe) {\n    getCollocationsList(qTree, threadSafe);\n  }","id":106453,"modified_method":"/**\n   * Traverses the parse tree to find WordNet collocations.\n   */\n  private void getCollocationsList() {\n    getCollocationsList(qTree);\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t, boolean threadSafe) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel= hf.determineHead(t).label();\n    StringBuffer testString = null;\n    Integer leftSistersBuffer=0;//measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      Integer currWindowLength=0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree, threadSafe); //recursive call to get colls in subtrees.\n      testString = new StringBuffer(160);\n      testString.append(treeAsStemmedCollocation(subtree, threadSafe));\n      testString.append(\"_\");\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuffer testStringNonStemmed = new StringBuffer(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append(\"_\");\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode, threadSafe));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append(\"_\");\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","id":106454,"modified_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel = hf.determineHead(t).label();\n    int leftSistersBuffer = 0; //measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      int currWindowLength = 0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree); //recursive call to get colls in subtrees.\n      StringBuilder testString = new StringBuilder(160);\n      testString.append(treeAsStemmedCollocation(subtree));\n      testString.append('_');\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuilder testStringNonStemmed = new StringBuilder(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append('_');\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append('_');\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsStemmedCollocation(Tree t, boolean threadSafe) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t, threadSafe);\n    // err.println(list.size());\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","id":106455,"modified_method":"private static String treeAsStemmedCollocation(Tree t) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t);\n    // err.println(list.size());\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append(\"_\");\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106456,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append('_');\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuffer mutatedString = new StringBuffer(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","id":106457,"modified_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuilder mutatedString = new StringBuilder(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   *   <br>       <code> came_up_with (7,9) <\/code>\n   */\n  public void PrintCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for(Collocation c: collocationCollector){\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","id":106458,"modified_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   * <br>         <code> came_up_with (7,9) <\/code>\n   */\n  public void printCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for (Collocation c: collocationCollector) {\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","id":106459,"modified_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append('_');\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t, boolean threadSafe) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = threadSafe ? Morphology.stemStaticSynchronized(w.word(), w.tag())\n              : Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","id":106460,"modified_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"Thread \" + j + \" produced annotation \" + i +\n                     \" differently than the baseline\",\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","id":106461,"modified_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"For annotation \" + i + \", thread \" + j + \" produced annotation \" +\n                        threads[j].annotations.get(i) + \" versus the baseline \" + baseline.get(i),\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","commit_id":"acfc2e10bdd589a64c7ff679a8b87ea7cae0b8b4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","id":106462,"modified_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append('_');\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t, boolean threadSafe) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel= hf.determineHead(t).label();\n    StringBuffer testString = null;\n    Integer leftSistersBuffer=0;//measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      Integer currWindowLength=0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree, threadSafe); //recursive call to get colls in subtrees.\n      testString = new StringBuffer(160);\n      testString.append(treeAsStemmedCollocation(subtree, threadSafe));\n      testString.append(\"_\");\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuffer testStringNonStemmed = new StringBuffer(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append(\"_\");\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode, threadSafe));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append(\"_\");\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","id":106463,"modified_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel = hf.determineHead(t).label();\n    int leftSistersBuffer = 0; //measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      int currWindowLength = 0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree); //recursive call to get colls in subtrees.\n      StringBuilder testString = new StringBuilder(160);\n      testString.append(treeAsStemmedCollocation(subtree));\n      testString.append('_');\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuilder testStringNonStemmed = new StringBuilder(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append('_');\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append('_');\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n * Traverses the parse tree to find WordNet collocations.\n */\n  private void getCollocationsList(boolean threadSafe) {\n    getCollocationsList(qTree, threadSafe);\n  }","id":106464,"modified_method":"/**\n   * Traverses the parse tree to find WordNet collocations.\n   */\n  private void getCollocationsList() {\n    getCollocationsList(qTree);\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append(\"_\");\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106465,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append('_');\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    this(t, w, hf, false);\n  }","id":106466,"modified_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    CoordinationTransformer transformer = new CoordinationTransformer(hf);\n    this.wnConnect = w;\n    this.qTree = transformer.transformTree(t);\n    this.collocationCollector = Generics.newArrayList();\n    this.hf = hf;\n    this.getCollocationsList();\n    if (DEBUG) {\n      System.err.println(\"Collected collocations: \" + collocationCollector);\n    }\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t, boolean threadSafe) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = threadSafe ? Morphology.stemStaticSynchronized(w.word(), w.tag())\n              : Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","id":106467,"modified_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append(\"_\");\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106468,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append('_');\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuffer mutatedString = new StringBuffer(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","id":106469,"modified_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuilder mutatedString = new StringBuilder(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsStemmedCollocation(Tree t, boolean threadSafe) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t, threadSafe);\n    // err.println(list.size());\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","id":106470,"modified_method":"private static String treeAsStemmedCollocation(Tree t) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t);\n    // err.println(list.size());\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   *   <br>       <code> came_up_with (7,9) <\/code>\n   */\n  public void PrintCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for(Collocation c: collocationCollector){\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","id":106471,"modified_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   * <br>         <code> came_up_with (7,9) <\/code>\n   */\n  public void printCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for (Collocation c: collocationCollector) {\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"Thread \" + j + \" produced annotation \" + i +\n                     \" differently than the baseline\",\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","id":106472,"modified_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"For annotation \" + i + \", thread \" + j + \" produced annotation \" +\n                        threads[j].annotations.get(i) + \" versus the baseline \" + baseline.get(i),\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","commit_id":"5d56c828753b0c44631049fddfcc62c3996ff4ae","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","id":106473,"modified_method":"private static String treeAsNonStemmedCollocation(Tree t) {\n    List<WordTag> list= getNonStemmedWordTagsFromTree(t);\n\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append('_');\n      s.append(wt.word());\n    }\n    return s.toString();\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append(\"_\");\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106474,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree t) {\n    StringBuilder sb = new StringBuilder(160);\n    ArrayList<TaggedWord> sent = t.taggedYield();\n    for (TaggedWord aSent : sent) {\n      sb.append(aSent.word()).append('_');\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    this(t, w, hf, false);\n  }","id":106475,"modified_method":"/**\n   * Construct a new {@code CollocationFinder} over the {@code Tree} t.\n   * @param t parse tree\n   * @param w wordnet connection\n   * @param hf {@link HeadFinder} to use\n   */\n  public CollocationFinder(Tree t, WordNetConnection w, HeadFinder hf) {\n    CoordinationTransformer transformer = new CoordinationTransformer(hf);\n    this.wnConnect = w;\n    this.qTree = transformer.transformTree(t);\n    this.collocationCollector = Generics.newArrayList();\n    this.hf = hf;\n    this.getCollocationsList();\n    if (DEBUG) {\n      System.err.println(\"Collected collocations: \" + collocationCollector);\n    }\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n * Traverses the parse tree to find WordNet collocations.\n */\n  private void getCollocationsList(boolean threadSafe) {\n    getCollocationsList(qTree, threadSafe);\n  }","id":106476,"modified_method":"/**\n   * Traverses the parse tree to find WordNet collocations.\n   */\n  private void getCollocationsList() {\n    getCollocationsList(qTree);\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuffer mutatedString = new StringBuffer(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","id":106477,"modified_method":"private Tree getMangledTree(Tree t) {\n    Collocation matchingColl = null;\n    for (Tree child : t.children()) {\n      child = getMangledTree(child);\n    }\n    //boolean additionalCollocationsExist = false;\n    for (Collocation c : collocationCollector) {\n      // if there are multiple collocations with the same parent node,\n      // this will take the longer one\n      if (t.equals(c.parentNode)) {\n        if (matchingColl == null ||\n            (c.span.first() <= matchingColl.span.first() &&\n                c.span.second() >= matchingColl.span.second())) {\n          matchingColl = c;\n          if (DEBUG) {\n            err.println(\"Found matching collocation for tree:\");\n            t.pennPrint();\n            err.print(\"  head label: \" + c.headLabel);\n            err.println(\"; collocation string: \" + c.collocationString);\n            err.println(\"  Constituents: \"+ c.indicesOfConstituentChildren);\n          }\n        }\n      }\n    }\n\n    if (matchingColl == null) {\n      return t;\n    } else {\n      if (DEBUG) {\n        err.println(\"Collapsing \" + matchingColl);\n      }\n      Tree[] allChildren = t.children();\n      // get the earliest child in the collocation and store it as first child.\n      // delete the rest.\n      StringBuilder mutatedString = new StringBuilder(160);\n      for (int i : matchingColl.indicesOfConstituentChildren) {\n        String strToAppend = mergeLeavesIntoCollocatedString(allChildren[i]);\n        mutatedString.append(strToAppend);\n        mutatedString.append(\"_\");\n      }\n      mutatedString = mutatedString.deleteCharAt(mutatedString.length() - 1);\n\n      // Starting with the latest constituent, delete all the \"pruned\" children\n      if (DEBUG) { err.println(\"allChildren is: \" + Arrays.toString(allChildren)); }\n      for (int index = matchingColl.indicesOfConstituentChildren.size() - 1; index > 0; index--) {\n        int thisConstituent = matchingColl.indicesOfConstituentChildren.get(index);\n        allChildren = (Tree[]) ArrayUtils.removeAt(allChildren, thisConstituent);\n        if (DEBUG) { err.println(\" deleted \" + thisConstituent + \"; allChildren is: \" + Arrays.toString(allChildren)); }\n      }\n      //name for the leaf string of our new collocation\n      String newNodeString = mutatedString.toString();\n\n      int firstChildIndex = matchingColl.indicesOfConstituentChildren.get(0);\n      //now we mutate the earliest constituent\n      Tree newCollocationChild = allChildren[firstChildIndex];\n      if (DEBUG) err.println(\"Manipulating: \" + newCollocationChild);\n      newCollocationChild.setValue(matchingColl.headLabel.value());\n      Tree newCollocationLeaf = newCollocationChild.treeFactory().newLeaf(newNodeString);\n      newCollocationChild.setChildren(Collections.singletonList(newCollocationLeaf));\n      if (DEBUG) err.println(\"  changed to: \" + newCollocationChild);\n\n      allChildren[firstChildIndex] = newCollocationChild;\n      t.setChildren(allChildren);\n\n      if (DEBUG) {\n        err.println(\"Restructured tree is:\");\n        t.pennPrint();\n        err.println();\n      }\n      return t;\n    }\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append(\"_\");\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","id":106478,"modified_method":"private static String mergeLeavesIntoCollocatedString(Tree[] trees) {\n    StringBuilder sb = new StringBuilder(160);\n    for (Tree t: trees) {\n      ArrayList<TaggedWord> sent = t.taggedYield();\n      for (TaggedWord aSent : sent) {\n        sb.append(aSent.word()).append('_');\n      }\n    }\n    return sb.substring(0,sb.length() -1);\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String treeAsStemmedCollocation(Tree t, boolean threadSafe) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t, threadSafe);\n    // err.println(list.size());\n    StringBuffer s = new StringBuffer(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","id":106479,"modified_method":"private static String treeAsStemmedCollocation(Tree t) {\n    List<WordTag> list= getStemmedWordTagsFromTree(t);\n    // err.println(list.size());\n    StringBuilder s = new StringBuilder(160);\n    WordTag firstWord = list.remove(0);\n    s.append(firstWord.word());\n    for(WordTag wt : list) {\n      s.append(\"_\");\n      s.append(wt.word());\n    }\n    //err.println(\"Expressing this as:\"+s.toString());\n    return s.toString();\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   *   <br>       <code> came_up_with (7,9) <\/code>\n   */\n  public void PrintCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for(Collocation c: collocationCollector){\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","id":106480,"modified_method":"/**\n   * Prints the collocations found in this <code>Tree<\/code> as strings.\n   * Each is followed by its boundary constituent indices in the original tree.\n   * <br>Example: <code> throw_up (2,3) <\/code>\n   * <br>         <code> came_up_with (7,9) <\/code>\n   */\n  public void printCollocationStrings(PrintWriter pw){\n    //ArrayList<String> strs = new ArrayList<String>();\n    for (Collocation c: collocationCollector) {\n      String cs = c.collocationString;\n      pw.println(cs+\" (\"+(c.span.first()+1)+\",\"+(c.span.second()+1)+\")\");\n    }\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t, boolean threadSafe) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = threadSafe ? Morphology.stemStaticSynchronized(w.word(), w.tag())\n              : Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","id":106481,"modified_method":"/**\n   *\n   * @param t a tree\n   * @return the WordTags corresponding to the leaves of the tree,\n   * stemmed according to their POS tags in the tree.\n   */\n  private static List<WordTag> getStemmedWordTagsFromTree(Tree t) {\n    List<WordTag> stemmedWordTags = Generics.newArrayList();\n    ArrayList<TaggedWord> s = t.taggedYield();\n    for (TaggedWord w : s) {\n      WordTag wt = Morphology.stemStatic(w.word(), w.tag());\n      stemmedWordTags.add(wt);\n    }\n    return stemmedWordTags;\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t, boolean threadSafe) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel= hf.determineHead(t).label();\n    StringBuffer testString = null;\n    Integer leftSistersBuffer=0;//measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      Integer currWindowLength=0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree, threadSafe); //recursive call to get colls in subtrees.\n      testString = new StringBuffer(160);\n      testString.append(treeAsStemmedCollocation(subtree, threadSafe));\n      testString.append(\"_\");\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuffer testStringNonStemmed = new StringBuffer(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append(\"_\");\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode, threadSafe));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append(\"_\");\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed.toString());\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","id":106482,"modified_method":"/**\n   * This method does the work of traversing the tree and writing collocations\n   * to the CollocationCollector (an internal data structure).\n   *\n   * @param t Tree to get collocations from.\n   */\n  private void getCollocationsList(Tree t) {\n    int leftMostLeaf = Trees.leftEdge(t,qTree);\n    if (t.isPreTerminal()) return;\n    List<Tree> children = t.getChildrenAsList();\n    if (children.isEmpty()) return;\n    //TODO: fix determineHead\n    // - in phrases like \"World Trade Organization 's\" the head of the parent NP is \"POS\".\n    // - this is problematic for the collocationFinder which assigns this head\n    // as the POS for the collocation \"World_Trade_Organization\"!\n    Label headLabel = hf.determineHead(t).label();\n    int leftSistersBuffer = 0; //measures the length of sisters in words when reading\n    for (int i = 0; i < children.size();i++){\n      ArrayList<Integer> childConstituents = new ArrayList<Integer>();\n      childConstituents.add(i);\n      Tree subtree = children.get(i);\n      int currWindowLength = 0; //measures the length in words of the current collocation.\n      getCollocationsList(subtree); //recursive call to get colls in subtrees.\n      StringBuilder testString = new StringBuilder(160);\n      testString.append(treeAsStemmedCollocation(subtree));\n      testString.append('_');\n      Integer thisSubtreeLength = subtree.yield().size();\n      currWindowLength+=thisSubtreeLength;\n      StringBuilder testStringNonStemmed = new StringBuilder(160);\n      testStringNonStemmed.append(treeAsNonStemmedCollocation(subtree));\n      testStringNonStemmed.append('_');\n\n      //for each subtree i, we iteratively append word yields of succeeding sister\n      //subtrees j and check their wordnet entries.  if they exist we write them to\n      //the global collocationCollector pair by the indices of the leftmost and\n      //rightmost words in the collocation.\n\n      for (int j = i+1; j < children.size(); j++) {\n        Tree sisterNode = children.get(j);\n        childConstituents.add(j);\n        testString.append(treeAsStemmedCollocation(sisterNode));\n        testStringNonStemmed.append(treeAsNonStemmedCollocation(sisterNode));\n        currWindowLength+=sisterNode.yield().size();\n        if (DEBUG) {\n       //   err.println(\"Testing string w/ reported indices:\" + testString.toString()\n         //             + \" (\" +(leftMostLeaf+leftSistersBuffer)+\",\"+(leftMostLeaf+leftSistersBuffer+currWindowLength-1)+\")\");\n        }\n        //ignore collocations beginning with \"the\" or \"a\"\n        if (StringUtils.lookingAt(testString.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testString);\n          }\n        } else if (wordNetContains(testString.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testString.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testString);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testString.append('_');\n        if (StringUtils.lookingAt(testStringNonStemmed.toString(), \"(?:[Tt]he|THE|[Aa][Nn]?)[ _]\")) {\n          if (false) {\n            err.println(\"CollocationFinder: Not collapsing the/a word: \" +\n                testStringNonStemmed);\n          }\n        } else if (wordNetContains(testStringNonStemmed.toString())) {\n          Pair <Integer, Integer> c = new Pair<Integer,Integer>(leftMostLeaf+leftSistersBuffer,leftMostLeaf+leftSistersBuffer+currWindowLength-1);\n\n          ArrayList<Integer> childConstituentsClone = new ArrayList<Integer>(childConstituents);\n          Collocation col = new Collocation(c,t,childConstituentsClone,testStringNonStemmed.toString(),headLabel);\n          collocationCollector.add(col);\n          if (DEBUG) {\n            err.println(\"Found collocation in wordnet: \"+ testStringNonStemmed);\n            err.println(\"  Span of collocation is: \" + c +\n                \"; childConstituents is: \" + c);\n          }\n        }\n        testStringNonStemmed.append(\"_\");\n      }\n      leftSistersBuffer+=thisSubtreeLength;\n    }\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"Thread \" + j + \" produced annotation \" + i +\n                     \" differently than the baseline\",\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","id":106483,"modified_method":"public void testTwoThreads() throws Exception {\n    StanfordCoreNLP pipeline = new StanfordCoreNLP(PropertiesUtils.asProperties(\"maxAdditionalKnownLCWords\", \"0\"));\n    List<File> files = StanfordCoreNLPSlowITest.getFileList();\n    files = files.subList(0, numDocs);\n\n    List<String> baseline = getAnnotations(files, pipeline);\n\n    CoreNLPThread[] threads = new CoreNLPThread[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i] = new CoreNLPThread(files, pipeline);\n      threads[i].start();\n    }\n    for (int i = 0; i < numThreads; ++i) {\n      threads[i].join();\n      assertEquals(\"Thread \" + i + \" did not produce \" +\n                   baseline.size() + \" results\",\n                   baseline.size(), threads[i].annotations.size());\n    }\n    for (int i = 0; i < baseline.size(); ++i) {\n      //System.out.println(\"Baseline \" + i + \":\");\n      //System.out.println(baseline.get(i));\n      for (int j = 0; j < numThreads; ++j) {\n        //System.out.println(\"Thread \" + j + \" annotation \" + i + \":\");\n        //System.out.println(threads[j].annotations.get(i));\n        assertEquals(\"For annotation \" + i + \", thread \" + j + \" produced annotation \" +\n                        threads[j].annotations.get(i) + \" versus the baseline \" + baseline.get(i),\n                     baseline.get(i), threads[j].annotations.get(i));\n      }\n    }\n  }","commit_id":"1d9e7b85d1edc1e554eeaf5815e5edf50e270618","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getEntriesCount(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tfilterQuery(entryQuery);\n\n\t\treturn assetEntryLocalService.getEntriesCount(entryQuery);\n\t}","id":106484,"modified_method":"public int getEntriesCount(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tpreFilterQuery(entryQuery);\n\n\t\tObject[] results = filterQuery(entryQuery);\n\n\t\treturn (Integer)results[1];\n\t}","commit_id":"c643bfa1d7f26d087449753c1f192bb6f30b7a64","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getEntriesRSS(\n\t\t\tAssetEntryQuery entryQuery, String name, String type,\n\t\t\tdouble version, String displayStyle, String feedURL, String tagURL)\n\t\tthrows PortalException, SystemException {\n\n\t\tfilterQuery(entryQuery);\n\n\t\tList<AssetEntry> entries = assetEntryLocalService.getEntries(\n\t\t\tentryQuery);\n\n\t\treturn exportToRSS(\n\t\t\tname, null, type, version, displayStyle, feedURL, tagURL, entries);\n\t}","id":106485,"modified_method":"public String getEntriesRSS(\n\t\t\tAssetEntryQuery entryQuery, String name, String type,\n\t\t\tdouble version, String displayStyle, String feedURL, String tagURL)\n\t\tthrows PortalException, SystemException {\n\n\t\tpreFilterQuery(entryQuery);\n\n\t\tObject[] results = filterQuery(entryQuery);\n\n\t\treturn exportToRSS(\n\t\t\tname, null, type, version, displayStyle, feedURL, tagURL,\n\t\t\t(List<AssetEntry>)results[0]);\n\t}","commit_id":"c643bfa1d7f26d087449753c1f192bb6f30b7a64","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void filterQuery(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tentryQuery.setAllCategoryIds(filterCategoryIds(\n\t\t\tentryQuery.getAllCategoryIds()));\n\t\tentryQuery.setAnyCategoryIds(filterCategoryIds(\n\t\t\tentryQuery.getAnyCategoryIds()));\n\n\t\tentryQuery.setAllTagIds(filterTagIds(entryQuery.getAllTagIds()));\n\t\tentryQuery.setAnyTagIds(filterTagIds(entryQuery.getAnyTagIds()));\n\t}","id":106486,"modified_method":"protected Object[] filterQuery(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tint start = entryQuery.getStart();\n\t\tint end = entryQuery.getEnd();\n\n\t\tentryQuery.setStart(0);\n\t\tentryQuery.setEnd(end + ASSET_FILTER_SEARCH_LIMIT);\n\n\t\tList<AssetEntry> entries = assetEntryLocalService.getEntries(\n\t\t\tentryQuery);\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<AssetEntry> filteredEntries = new ArrayList<AssetEntry>();\n\n\t\tfor (AssetEntry entry : entries) {\n\t\t\tString className = entry.getClassName();\n\t\t\tlong classPK = entry.getClassPK();\n\n\t\t\tAssetRendererFactory factory = AssetRendererFactoryRegistryUtil.\n\t\t\t\tgetAssetRendererFactoryByClassName(className);\n\n\t\t\ttry {\n\t\t\t\tif (factory.hasPermission(\n\t\t\t\t\t\tpermissionChecker, classPK, ActionKeys.VIEW)) {\n\n\t\t\t\t\tfilteredEntries.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\n\t\tint length = filteredEntries.size();\n\n\t\tif ((start != QueryUtil.ALL_POS) && (end != QueryUtil.ALL_POS)) {\n\t\t\tif (end > length) {\n\t\t\t\tend = length;\n\t\t\t}\n\n\t\t\tfilteredEntries = filteredEntries.subList(start, end);\n\t\t}\n\n\t\treturn new Object[] {filteredEntries, length};\n\t}","commit_id":"c643bfa1d7f26d087449753c1f192bb6f30b7a64","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<AssetEntry> getEntries(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tfilterQuery(entryQuery);\n\n\t\treturn assetEntryLocalService.getEntries(entryQuery);\n\t}","id":106487,"modified_method":"public List<AssetEntry> getEntries(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tpreFilterQuery(entryQuery);\n\n\t\tObject[] results = filterQuery(entryQuery);\n\n\t\treturn (List<AssetEntry>)results[0];\n\t}","commit_id":"c643bfa1d7f26d087449753c1f192bb6f30b7a64","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","id":106488,"modified_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","commit_id":"5746a56727110341656b7cb43f70a4e23395e80e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(InternalXtendLexer.class);\n\t}","id":106489,"modified_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.parser.antlr.Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(org.eclipse.xtend.core.parser.antlr.internal.InternalXtendLexer.class);\n\t}","commit_id":"5746a56727110341656b7cb43f70a4e23395e80e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.ide.editor.contentassist.antlr.internal.Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(org.eclipse.xtend.ide.common.contentassist.antlr.internal.InternalXtendLexer.class);\n\t}","id":106490,"modified_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(InternalXtendLexer.class);\n\t}","commit_id":"5746a56727110341656b7cb43f70a4e23395e80e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtend.ide.common.contentassist.antlr.internal.InternalXtendLexer.class)\n\t\t\t.toProvider(LexerProvider.create(org.eclipse.xtend.ide.common.contentassist.antlr.internal.InternalXtendLexer.class));\n\t}","id":106491,"modified_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(InternalXtendLexer.class).toProvider(LexerProvider.create(InternalXtendLexer.class));\n\t}","commit_id":"5746a56727110341656b7cb43f70a4e23395e80e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.ide.editor.contentassist.antlr.internal.Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXbaseLexer.class);\n\t}","id":106492,"modified_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(InternalXbaseLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXbaseLexer.class)\n\t\t\t.toProvider(LexerProvider.create(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXbaseLexer.class));\n\t}","id":106493,"modified_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(InternalXbaseLexer.class).toProvider(LexerProvider.create(InternalXbaseLexer.class));\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(InternalXbaseLexer.class);\n\t}","id":106494,"modified_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.parser.antlr.Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(org.eclipse.xtext.xbase.parser.antlr.internal.InternalXbaseLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","id":106495,"modified_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","id":106496,"modified_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(InternalXbaseWithAnnotationsLexer.class);\n\t}","id":106497,"modified_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.parser.antlr.Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(org.eclipse.xtext.xbase.annotations.parser.antlr.internal.InternalXbaseWithAnnotationsLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.ide.editor.contentassist.antlr.internal.Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(org.eclipse.xtext.xbase.annotations.ide.contentassist.antlr.internal.InternalXbaseWithAnnotationsLexer.class);\n\t}","id":106498,"modified_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(InternalXbaseWithAnnotationsLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.xbase.annotations.ide.contentassist.antlr.internal.InternalXbaseWithAnnotationsLexer.class)\n\t\t\t.toProvider(LexerProvider.create(org.eclipse.xtext.xbase.annotations.ide.contentassist.antlr.internal.InternalXbaseWithAnnotationsLexer.class));\n\t}","id":106499,"modified_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(InternalXbaseWithAnnotationsLexer.class).toProvider(LexerProvider.create(InternalXbaseWithAnnotationsLexer.class));\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(InternalXtypeLexer.class);\n\t}","id":106500,"modified_method":"public void configureHighlightingLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.parser.antlr.Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(org.eclipse.xtext.xbase.parser.antlr.internal.InternalXtypeLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXtypeLexer.class)\n\t\t\t.toProvider(LexerProvider.create(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXtypeLexer.class));\n\t}","id":106501,"modified_method":"public void configureContentAssistLexerProvider(Binder binder) {\n\t\tbinder.bind(InternalXtypeLexer.class).toProvider(LexerProvider.create(InternalXtypeLexer.class));\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(org.eclipse.xtext.ide.editor.contentassist.antlr.internal.Lexer.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(org.eclipse.xtext.xbase.ide.contentassist.antlr.internal.InternalXtypeLexer.class);\n\t}","id":106502,"modified_method":"public void configureContentAssistLexer(Binder binder) {\n\t\tbinder.bind(Lexer.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.CONTENT_ASSIST))\n\t\t\t.to(InternalXtypeLexer.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(org.eclipse.xtext.ide.LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","id":106503,"modified_method":"public void configureHighlightingTokenDefProvider(Binder binder) {\n\t\tbinder.bind(ITokenDefProvider.class)\n\t\t\t.annotatedWith(Names.named(LexerIdeBindings.HIGHLIGHTING))\n\t\t\t.to(AntlrTokenDefProvider.class);\n\t}","commit_id":"1aa7a4d1bedf44843a94f7bcb2ede4f59a0f8ba8","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void updateLdap(ActionRequest req, PortletPreferences prefs)\n\t\tthrows Exception {\n\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tboolean required = ParamUtil.getBoolean(req, \"required\");\n\t\tboolean ntlmEnabled = ParamUtil.getBoolean(req, \"ntlmEnabled\");\n\t\tString baseProviderURL = ParamUtil.getString(req, \"baseProviderURL\");\n\t\tString baseDN = ParamUtil.getString(req, \"baseDN\");\n\t\tString principal = ParamUtil.getString(req, \"principal\");\n\t\tString credentials = ParamUtil.getString(req, \"credentials\");\n\t\tString searchFilter = ParamUtil.getString(req, \"searchFilter\");\n\t\tString passwordEncryptionAlgorithm = ParamUtil.getString(\n\t\t\treq, \"passwordEncryptionAlgorithm\");\n\t\tString userMappings = ParamUtil.getString(req, \"userMappings\");\n\t\tboolean importOnStartup = ParamUtil.getBoolean(req, \"importOnStartup\");\n\t\tlong importInterval = ParamUtil.getLong(req, \"importInterval\");\n\t\tString importSearchFilter = ParamUtil.getString(\n\t\t\treq, \"importSearchFilter\");\n\t\tboolean exportEnabled = ParamUtil.getBoolean(req, \"exportEnabled\");\n\t\tString usersDn = ParamUtil.getString(req, \"usersDn\");\n\t\tString userDefaultObjectClasses = ParamUtil.getString(\n\t\t\treq, \"userDefaultObjectClasses\");\n\t\tboolean passwordPolicyEnabled = ParamUtil.getBoolean(\n\t\t\treq, \"passwordPolicyEnabled\");\n\n\t\ttry {\n\t\t\tif (enabled) {\n\t\t\t\tProperties env = new Properties();\n\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\t\t\tPrefsPropsUtil.getString(PropsUtil.LDAP_FACTORY_INITIAL));\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.PROVIDER_URL,\n\t\t\t\t\tLDAPUtil.getFullProviderURL(baseProviderURL, baseDN));\n\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, principal);\n\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, credentials);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\n\t\t\t\tnew InitialLdapContext(env, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSessionErrors.add(req, \"ldapAuthentication\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_ENABLED, String.valueOf(enabled));\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_REQUIRED, String.valueOf(required));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.NTLM_AUTH_ENABLED, String.valueOf(ntlmEnabled));\n\t\tprefs.setValue(PropsUtil.LDAP_BASE_PROVIDER_URL, baseProviderURL);\n\t\tprefs.setValue(PropsUtil.LDAP_BASE_DN, baseDN);\n\t\tprefs.setValue(PropsUtil.LDAP_SECURITY_PRINCIPAL, principal);\n\t\tprefs.setValue(PropsUtil.LDAP_SECURITY_CREDENTIALS, credentials);\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_SEARCH_FILTER, searchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_AUTH_PASSWORD_ENCRYPTION_ALGORITHM,\n\t\t\tpasswordEncryptionAlgorithm);\n\t\tprefs.setValue(PropsUtil.LDAP_USER_MAPPINGS, userMappings);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_ON_STARTUP, String.valueOf(importOnStartup));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_INTERVAL, String.valueOf(importInterval));\n\t\tprefs.setValue(PropsUtil.LDAP_IMPORT_SEARCH_FILTER, importSearchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_EXPORT_ENABLED, String.valueOf(exportEnabled));\n\t\tprefs.setValue(PropsUtil.LDAP_USERS_DN, usersDn);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_USER_DEFAULT_OBJECT_CLASSES,\n\t\t\tuserDefaultObjectClasses);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_PASSWORD_POLICY_ENABLED,\n\t\t\tString.valueOf(passwordPolicyEnabled));\n\n\t\tprefs.store();\n\t}","id":106504,"modified_method":"protected void updateLdap(ActionRequest req, PortletPreferences prefs)\n\t\tthrows Exception {\n\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tboolean required = ParamUtil.getBoolean(req, \"required\");\n\t\tboolean ntlmEnabled = ParamUtil.getBoolean(req, \"ntlmEnabled\");\n\t\tString baseProviderURL = ParamUtil.getString(req, \"baseProviderURL\");\n\t\tString baseDN = ParamUtil.getString(req, \"baseDN\");\n\t\tString principal = ParamUtil.getString(req, \"principal\");\n\t\tString credentials = ParamUtil.getString(req, \"credentials\");\n\t\tString searchFilter = ParamUtil.getString(req, \"searchFilter\");\n\t\tString passwordEncryptionAlgorithm = ParamUtil.getString(\n\t\t\treq, \"passwordEncryptionAlgorithm\");\n\t\tString userMappings = ParamUtil.getString(req, \"userMappings\");\n\t\tboolean importEnabled = ParamUtil.getBoolean(req, \"importEnabled\");\n\t\tboolean importOnStartup = ParamUtil.getBoolean(req, \"importOnStartup\");\n\t\tlong importInterval = ParamUtil.getLong(req, \"importInterval\");\n\t\tString importUserSearchFilter = ParamUtil.getString(\n\t\t\treq, \"importUserSearchFilter\");\n\t\tString importGroupSearchFilter = ParamUtil.getString(\n\t\t\treq, \"importGroupSearchFilter\");\n\t\tboolean exportEnabled = ParamUtil.getBoolean(req, \"exportEnabled\");\n\t\tString usersDn = ParamUtil.getString(req, \"usersDn\");\n\t\tString userDefaultObjectClasses = ParamUtil.getString(\n\t\t\treq, \"userDefaultObjectClasses\");\n\t\tboolean passwordPolicyEnabled = ParamUtil.getBoolean(\n\t\t\treq, \"passwordPolicyEnabled\");\n\n\t\ttry {\n\t\t\tif (enabled) {\n\t\t\t\tProperties env = new Properties();\n\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\t\t\tPrefsPropsUtil.getString(PropsUtil.LDAP_FACTORY_INITIAL));\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.PROVIDER_URL,\n\t\t\t\t\tLDAPUtil.getFullProviderURL(baseProviderURL, baseDN));\n\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, principal);\n\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, credentials);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\n\t\t\t\tnew InitialLdapContext(env, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSessionErrors.add(req, \"ldapAuthentication\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_ENABLED, String.valueOf(enabled));\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_REQUIRED, String.valueOf(required));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.NTLM_AUTH_ENABLED, String.valueOf(ntlmEnabled));\n\t\tprefs.setValue(PropsUtil.LDAP_BASE_PROVIDER_URL, baseProviderURL);\n\t\tprefs.setValue(PropsUtil.LDAP_BASE_DN, baseDN);\n\t\tprefs.setValue(PropsUtil.LDAP_SECURITY_PRINCIPAL, principal);\n\t\tprefs.setValue(PropsUtil.LDAP_SECURITY_CREDENTIALS, credentials);\n\t\tprefs.setValue(PropsUtil.LDAP_AUTH_SEARCH_FILTER, searchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_AUTH_PASSWORD_ENCRYPTION_ALGORITHM,\n\t\t\tpasswordEncryptionAlgorithm);\n\t\tprefs.setValue(PropsUtil.LDAP_USER_MAPPINGS, userMappings);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_ENABLED, String.valueOf(importEnabled));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_ON_STARTUP, String.valueOf(importOnStartup));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_INTERVAL, String.valueOf(importInterval));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_USER_SEARCH_FILTER, importUserSearchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_IMPORT_GROUP_SEARCH_FILTER, importGroupSearchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_EXPORT_ENABLED, String.valueOf(exportEnabled));\n\t\tprefs.setValue(PropsUtil.LDAP_USERS_DN, usersDn);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_USER_DEFAULT_OBJECT_CLASSES,\n\t\t\tuserDefaultObjectClasses);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.LDAP_PASSWORD_POLICY_ENABLED,\n\t\t\tString.valueOf(passwordPolicyEnabled));\n\n\t\tprefs.store();\n\t}","commit_id":"57babebb7d667987e70d21a707b2e08f440f6e0d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importFromLDAP(long companyId) throws Exception {\n\t\tif (!isImportEnabled(companyId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLdapContext ctx = getContext(companyId);\n\n\t\tif (ctx == null) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tProperties userMappings = getUserMappings(companyId);\n\t\t\tProperties groupMappings = getGroupMappings(companyId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_BASE_DN);\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SEARCH_FILTER);\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 0, 0, null, false, false);\n\n\t\t\tNamingEnumeration enu = ctx.search(baseDN, filter, cons);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\timportFromLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, baseDN,\n\t\t\t\t\tresult);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","id":106505,"modified_method":"public static void importFromLDAP(long companyId) throws Exception {\n\t\tif (!isImportEnabled(companyId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLdapContext ctx = getContext(companyId);\n\n\t\tif (ctx == null) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tProperties userMappings = getUserMappings(companyId);\n\t\t\tProperties groupMappings = getGroupMappings(companyId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_BASE_DN);\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_USER_SEARCH_FILTER);\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 0, 0, null, false, false);\n\n\t\t\tNamingEnumeration enu = ctx.search(baseDN, filter, cons);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\timportFromLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, baseDN,\n\t\t\t\t\tresult);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"57babebb7d667987e70d21a707b2e08f440f6e0d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void initializeDefaultPreferences() {\n        IPreferenceStore store = FindbugsPlugin.getDefault().getPreferenceStore();\n        store.setDefault(EXPORT_SORT_ORDER, ORDER_BY_NAME);\n        store.setDefault(DONT_REMIND_ABOUT_FULL_BUILD, false);\n\n        store.setDefault(KEY_CACHE_CLASS_DATA, false);\n        store.setDefault(KEY_RUN_ANALYSIS_AS_EXTRA_JOB, false);\n\n        store.setDefault(DISABLED_CATEGORIES, \"EXPERIMENTAL,I18N,MALICIOUS_CODE,SECURITY\");\n        store.setDefault(RUN_ANALYSIS_AUTOMATICALLY, false);\n        store.setDefault(RUN_ANALYSIS_ON_FULL_BUILD, false);\n        store.setDefault(ASK_ABOUT_PERSPECTIVE_SWITCH, true);\n        store.setDefault(SWITCH_PERSPECTIVE_AFTER_ANALYSIS, false);\n        store.setDefault(PRIO_LOW_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        store.setDefault(PRIO_NORMAL_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        store.setDefault(PRIO_HIGH_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        // disabled to be able to distinguish between default and current value\n        // store.setDefault(PROJECT_PROPS_DISABLED, true);\n    }","id":106506,"modified_method":"@Override\n    public void initializeDefaultPreferences() {\n        IPreferenceStore store = FindbugsPlugin.getDefault().getPreferenceStore();\n        store.setDefault(EXPORT_SORT_ORDER, ORDER_BY_NAME);\n        store.setDefault(DONT_REMIND_ABOUT_FULL_BUILD, false);\n\n        store.setDefault(KEY_CACHE_CLASS_DATA, false);\n        store.setDefault(KEY_RUN_ANALYSIS_AS_EXTRA_JOB, false);\n\n        store.setDefault(DISABLED_CATEGORIES, \"EXPERIMENTAL,I18N,MALICIOUS_CODE,SECURITY\");\n        store.setDefault(RUN_ANALYSIS_AUTOMATICALLY, false);\n        store.setDefault(RUN_ANALYSIS_ON_FULL_BUILD, false);\n        store.setDefault(ASK_ABOUT_PERSPECTIVE_SWITCH, true);\n        store.setDefault(SWITCH_PERSPECTIVE_AFTER_ANALYSIS, false);\n        store.setDefault(RANK_OFCONCERN_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        store.setDefault(RANK_TROUBLING_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        store.setDefault(RANK_SCARY_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        store.setDefault(RANK_SCARIEST_MARKER_SEVERITY, MarkerSeverity.Warning.name());\n        // disabled to be able to distinguish between default and current value\n        // store.setDefault(PROJECT_PROPS_DISABLED, true);\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static void restoreDefaults(IPreferenceStore store) {\n        store.setToDefault(EXPORT_SORT_ORDER);\n        store.setToDefault(DONT_REMIND_ABOUT_FULL_BUILD);\n        store.setToDefault(DISABLED_CATEGORIES);\n        store.setToDefault(RUN_ANALYSIS_AUTOMATICALLY);\n        store.setToDefault(RUN_ANALYSIS_ON_FULL_BUILD);\n        store.setToDefault(ASK_ABOUT_PERSPECTIVE_SWITCH);\n        store.setToDefault(SWITCH_PERSPECTIVE_AFTER_ANALYSIS);\n        store.setToDefault(PRIO_LOW_MARKER_SEVERITY);\n        store.setToDefault(PRIO_NORMAL_MARKER_SEVERITY);\n        store.setToDefault(PRIO_HIGH_MARKER_SEVERITY);\n\n        store.setToDefault(KEY_CACHE_CLASS_DATA);\n        store.setToDefault(KEY_RUN_ANALYSIS_AS_EXTRA_JOB);\n    }","id":106507,"modified_method":"public static void restoreDefaults(IPreferenceStore store) {\n        store.setToDefault(EXPORT_SORT_ORDER);\n        store.setToDefault(DONT_REMIND_ABOUT_FULL_BUILD);\n        store.setToDefault(DISABLED_CATEGORIES);\n        store.setToDefault(RUN_ANALYSIS_AUTOMATICALLY);\n        store.setToDefault(RUN_ANALYSIS_ON_FULL_BUILD);\n        store.setToDefault(ASK_ABOUT_PERSPECTIVE_SWITCH);\n        store.setToDefault(SWITCH_PERSPECTIVE_AFTER_ANALYSIS);\n        store.setToDefault(RANK_OFCONCERN_MARKER_SEVERITY);\n        store.setToDefault(RANK_TROUBLING_MARKER_SEVERITY);\n        store.setToDefault(RANK_SCARY_MARKER_SEVERITY);\n        store.setToDefault(RANK_SCARIEST_MARKER_SEVERITY);\n\n        store.setToDefault(KEY_CACHE_CLASS_DATA);\n        store.setToDefault(KEY_RUN_ANALYSIS_AS_EXTRA_JOB);\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * @return null if marker shouldn't be generated\n     */\n    private String getMarkerType() {\n        String type;\n        switch (bug.getPriority()) {\n        case Priorities.HIGH_PRIORITY:\n            type = FindBugsMarker.NAME_HIGH;\n            break;\n        case Priorities.NORMAL_PRIORITY:\n            type = FindBugsMarker.NAME_NORMAL;\n            break;\n        case Priorities.LOW_PRIORITY:\n            type = FindBugsMarker.NAME_LOW;\n            break;\n        case Priorities.EXP_PRIORITY:\n            if (!EXPERIMENTAL_BUGS) {\n                return null;\n            }\n            type = FindBugsMarker.NAME_EXPERIMENTAL;\n            break;\n        case Priorities.IGNORE_PRIORITY:\n            FindbugsPlugin.getDefault().logError(\"Bug with ignore priority \");\n            return null;\n        default:\n            FindbugsPlugin.getDefault().logError(\"Bug with unknown priority \" + bug.getPriority());\n            return null;\n        }\n        return type;\n    }","id":106508,"modified_method":"/**\n     * @return null if marker shouldn't be generated\n     */\n    private String getMarkerType() {\n        switch (bug.getBugRankCategory()) {\n        case SCARIEST:\n            return FindBugsMarker.NAME_SCARIEST;\n        case SCARY:\n            return FindBugsMarker.NAME_SCARY;\n        case TROUBLING:\n            return FindBugsMarker.NAME_TROUBLING;\n        case OF_CONCERN:\n            return FindBugsMarker.NAME_OF_CONCERN;\n        }\n        return FindBugsMarker.NAME_OF_CONCERN;\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean isMarkerSeveritiesChanged() {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        String highPrio = store.getString(FindBugsConstants.PRIO_HIGH_MARKER_SEVERITY);\n        String normalPrio = store.getString(FindBugsConstants.PRIO_NORMAL_MARKER_SEVERITY);\n        String lowPrio = store.getString(FindBugsConstants.PRIO_HIGH_MARKER_SEVERITY);\n        return !initialHighPrio.name().equals(highPrio) || !initialNormalPrio.name().equals(normalPrio)\n                || !initialLowPrio.name().equals(lowPrio);\n    }","id":106509,"modified_method":"public boolean isMarkerSeveritiesChanged() {\n        if (isMarkerSeveritiesChanged(FindBugsConstants.RANK_SCARIEST_MARKER_SEVERITY, initialScariestRank)) {\n            return true;\n        }\n        if (isMarkerSeveritiesChanged(FindBugsConstants.RANK_SCARY_MARKER_SEVERITY, initialScaryRank)) {\n            return true;\n        }\n        if (isMarkerSeveritiesChanged(FindBugsConstants.RANK_TROUBLING_MARKER_SEVERITY, initialTroublingRank)) {\n            return true;\n        }\n        if (isMarkerSeveritiesChanged(FindBugsConstants.RANK_OFCONCERN_MARKER_SEVERITY, initialOfConcernRank)) {\n            return true;\n        }\n        return false;\n\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void updateRankValueLabel() {\n        String label;\n        int rank = minRankSlider.getSelection();\n        if (rank < 5) {\n            label = \"Scariest\";\n        } else if (rank < 10) {\n            label = \"Scary\";\n        } else if (rank < 15) {\n            label = \"Troubling\";\n        } else {\n            label = \"Possible\";\n        }\n        rankValueLabel.setText(rank + \" (\" + label + \")\");\n    }","id":106510,"modified_method":"private void updateRankValueLabel() {\n        String label;\n        int rank = minRankSlider.getSelection();\n        if (rank < 5) {\n            label = \"Scariest\";\n        } else if (rank < 10) {\n            label = \"Scary\";\n        } else if (rank < 15) {\n            label = \"Troubling\";\n        } else {\n            label = \"Of Concern\";\n        }\n        rankValueLabel.setText(rank + \" (\" + label + \")\");\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void createBugSeverityGroup(Composite parent) {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        MarkerSeverity[] markerSeverities = MarkerSeverity.values();\n\n        Group prioGroup = new Group(parent, SWT.NONE);\n        prioGroup.setLayout(new GridLayout(2, false));\n        prioGroup.setText(\"Mark bugs with ... priority as:\");\n        prioGroup.setLayoutData(new GridData(SWT.BEGINNING, SWT.TOP, true, true));\n\n        Label bugSeverityLabel = new Label(prioGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"High Priority:\");\n\n        highPrioCombo = new Combo(prioGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            highPrioCombo.add(markerSeverity.name());\n        }\n        initialHighPrio = MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_HIGH_MARKER_SEVERITY));\n        highPrioCombo.setText(initialHighPrio.name());\n\n        bugSeverityLabel = new Label(prioGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Medium Priority:\");\n\n        normalPrioCombo = new Combo(prioGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            normalPrioCombo.add(markerSeverity.name());\n        }\n        initialNormalPrio = MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_NORMAL_MARKER_SEVERITY));\n        normalPrioCombo.setText(initialNormalPrio.name());\n\n        bugSeverityLabel = new Label(prioGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Low Priority:\");\n\n        lowPrioCombo = new Combo(prioGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            lowPrioCombo.add(markerSeverity.name());\n        }\n        initialLowPrio = MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_LOW_MARKER_SEVERITY));\n        lowPrioCombo.setText(initialLowPrio.name());\n\n    }","id":106511,"modified_method":"private void createBugSeverityGroup(Composite parent) {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        MarkerSeverity[] markerSeverities = MarkerSeverity.values();\n\n        Group rankGroup = new Group(parent, SWT.NONE);\n        rankGroup.setLayout(new GridLayout(2, false));\n        rankGroup.setText(\"Mark bugs with ... rank as:\");\n        rankGroup.setLayoutData(new GridData(SWT.BEGINNING, SWT.TOP, true, true));\n\n        Label bugSeverityLabel = new Label(rankGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Scariest:\");\n\n        scariestRankCombo = new Combo(rankGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            scariestRankCombo.add(markerSeverity.name());\n        }\n        initialScariestRank = MarkerSeverity.get(store.getString(FindBugsConstants.RANK_SCARIEST_MARKER_SEVERITY));\n        scariestRankCombo.setText(initialScariestRank.name());\n\n        bugSeverityLabel = new Label(rankGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Scary:\");\n\n        scaryRankCombo = new Combo(rankGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            scaryRankCombo.add(markerSeverity.name());\n        }\n        initialScaryRank = MarkerSeverity.get(store.getString(FindBugsConstants.RANK_SCARY_MARKER_SEVERITY));\n        scaryRankCombo.setText(initialScaryRank.name());\n\n        bugSeverityLabel = new Label(rankGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Troubling:\");\n\n        troublingRankCombo = new Combo(rankGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            troublingRankCombo.add(markerSeverity.name());\n        }\n        initialTroublingRank = MarkerSeverity.get(store.getString(FindBugsConstants.RANK_TROUBLING_MARKER_SEVERITY));\n        troublingRankCombo.setText(initialTroublingRank.name());\n\n        bugSeverityLabel = new Label(rankGroup, SWT.NONE);\n        bugSeverityLabel.setText(\"Of concern:\");\n\n        ofConcernRankCombo = new Combo(rankGroup, SWT.DROP_DOWN | SWT.READ_ONLY);\n        for (MarkerSeverity markerSeverity : markerSeverities) {\n            ofConcernRankCombo.add(markerSeverity.name());\n        }\n        initialOfConcernRank = MarkerSeverity.get(store.getString(FindBugsConstants.RANK_OFCONCERN_MARKER_SEVERITY));\n        ofConcernRankCombo.setText(initialOfConcernRank.name());\n\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void performOk() {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        String highPrio = highPrioCombo.getText();\n        store.setValue(FindBugsConstants.PRIO_HIGH_MARKER_SEVERITY, highPrio);\n\n        String normalPrio = normalPrioCombo.getText();\n        store.setValue(FindBugsConstants.PRIO_NORMAL_MARKER_SEVERITY, normalPrio);\n\n        String lowPrio = lowPrioCombo.getText();\n        store.setValue(FindBugsConstants.PRIO_LOW_MARKER_SEVERITY, lowPrio);\n\n    }","id":106512,"modified_method":"public void performOk() {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        String scariest = scariestRankCombo.getText();\n        store.setValue(FindBugsConstants.RANK_SCARIEST_MARKER_SEVERITY, scariest);\n\n        String scary = scaryRankCombo.getText();\n        store.setValue(FindBugsConstants.RANK_SCARY_MARKER_SEVERITY, scary);\n\n        String troubling = troublingRankCombo.getText();\n        store.setValue(FindBugsConstants.RANK_TROUBLING_MARKER_SEVERITY, troubling);\n\n        String ofConcern = ofConcernRankCombo.getText();\n        store.setValue(FindBugsConstants.RANK_OFCONCERN_MARKER_SEVERITY, ofConcern);\n\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"void refreshUI(UserPreferences prefs) {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        highPrioCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_HIGH_MARKER_SEVERITY)).name());\n        normalPrioCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_NORMAL_MARKER_SEVERITY)).name());\n        lowPrioCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.PRIO_LOW_MARKER_SEVERITY)).name());\n\n        ProjectFilterSettings filterSettings = prefs.getFilterSettings();\n        minRankSlider.setSelection(filterSettings.getMinRank());\n        updateRankValueLabel();\n        minPriorityCombo.setText(filterSettings.getMinPriority());\n        for (Button checkBox : chkEnableBugCategoryList) {\n            checkBox.setSelection(filterSettings.containsCategory((String) checkBox.getData()));\n        }\n        syncSelectedCategories();\n    }","id":106513,"modified_method":"void refreshUI(UserPreferences prefs) {\n        IPreferenceStore store = propertyPage.getPreferenceStore();\n        scariestRankCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.RANK_SCARIEST_MARKER_SEVERITY)).name());\n        scaryRankCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.RANK_SCARY_MARKER_SEVERITY)).name());\n        troublingRankCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.RANK_TROUBLING_MARKER_SEVERITY)).name());\n        ofConcernRankCombo.setText(MarkerSeverity.get(store.getString(FindBugsConstants.RANK_OFCONCERN_MARKER_SEVERITY)).name());\n\n        ProjectFilterSettings filterSettings = prefs.getFilterSettings();\n        minRankSlider.setSelection(filterSettings.getMinRank());\n        updateRankValueLabel();\n        minPriorityCombo.setText(filterSettings.getMinPriority());\n        for (Button checkBox : chkEnableBugCategoryList) {\n            checkBox.setSelection(filterSettings.containsCategory((String) checkBox.getData()));\n        }\n        syncSelectedCategories();\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void setEnabled(boolean enabled) {\n        minPriorityCombo.setEnabled(enabled);\n        lowPrioCombo.setEnabled(enabled);\n        normalPrioCombo.setEnabled(enabled);\n        highPrioCombo.setEnabled(enabled);\n        minRankSlider.setEnabled(enabled);\n        for (Button checkBox : chkEnableBugCategoryList) {\n            checkBox.setEnabled(enabled);\n        }\n        super.setEnabled(enabled);\n    }","id":106514,"modified_method":"@Override\n    public void setEnabled(boolean enabled) {\n        minPriorityCombo.setEnabled(enabled);\n        ofConcernRankCombo.setEnabled(enabled);\n        troublingRankCombo.setEnabled(enabled);\n        scaryRankCombo.setEnabled(enabled);\n        scariestRankCombo.setEnabled(enabled);\n        minRankSlider.setEnabled(enabled);\n        for (Button checkBox : chkEnableBugCategoryList) {\n            checkBox.setEnabled(enabled);\n        }\n        super.setEnabled(enabled);\n    }","commit_id":"05ec53fc82b3ee55ded98d1ca0bad1efb050dbf1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected void updateLdap(ActionRequest req, PortletPreferences prefs)\n\t\tthrows Exception {\n\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tboolean required = ParamUtil.getBoolean(req, \"required\");\n\t\tString url = ParamUtil.getString(req, \"url\");\n\t\tString principal = ParamUtil.getString(req, \"principal\");\n\t\tString credentials = ParamUtil.getString(req, \"credentials\");\n\t\tString searchFilter = ParamUtil.getString(req, \"searchFilter\");\n\t\tString passwordEncryptionAlgorithm = ParamUtil.getString(\n\t\t\treq, \"passwordEncryptionAlgorithm\");\n\t\tString userMappings = ParamUtil.getString(req, \"userMappings\");\n\n\t\ttry {\n\t\t\tif (enabled) {\n\t\t\t\tProperties env = new Properties();\n\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\t\tPropsUtil.AUTH_IMPL_LDAP_FACTORY_INITIAL));\n\t\t\t\tenv.put(Context.PROVIDER_URL, url);\n\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, principal);\n\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, credentials);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\n\t\t\t\tnew InitialLdapContext(env, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSessionErrors.add(req, \"ldapAuthentication\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_ENABLED, Boolean.toString(enabled));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_REQUIRED, Boolean.toString(required));\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_PROVIDER_URL, url);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_SECURITY_PRINCIPAL, principal);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_SECURITY_CREDENTIALS, credentials);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_SEARCH_FILTER, searchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_PASSWORD_ENCRYPTION_ALGORITHM,\n\t\t\tpasswordEncryptionAlgorithm);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_USER_MAPPINGS, userMappings);\n\n\t\tprefs.store();\n\n\t\tLDAPAuth ldapAuth = (LDAPAuth)InstancePool.get(\n\t\t\tLDAPAuth.class.getName());\n\t}","id":106515,"modified_method":"protected void updateLdap(ActionRequest req, PortletPreferences prefs)\n\t\tthrows Exception {\n\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tboolean required = ParamUtil.getBoolean(req, \"required\");\n\t\tString baseProviderURL = ParamUtil.getString(req, \"base_provider_url\");\n\t\tString baseDN = ParamUtil.getString(req, \"base_dn\");\n\t\tString principal = ParamUtil.getString(req, \"principal\");\n\t\tString credentials = ParamUtil.getString(req, \"credentials\");\n\t\tString searchFilter = ParamUtil.getString(req, \"searchFilter\");\n\t\tString passwordEncryptionAlgorithm = ParamUtil.getString(\n\t\t\treq, \"passwordEncryptionAlgorithm\");\n\t\tString userMappings = ParamUtil.getString(req, \"userMappings\");\n\n\t\ttry {\n\t\t\tif (enabled) {\n\t\t\t\tProperties env = new Properties();\n\n\t\t\t\tenv.put(\n\t\t\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\t\tPropsUtil.AUTH_IMPL_LDAP_FACTORY_INITIAL));\n\t\t\t\tenv.put(Context.PROVIDER_URL, LDAPUtil.getFullProviderURL(\n\t\t\t\t\tbaseProviderURL, baseDN));\n\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, principal);\n\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, credentials);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\n\t\t\t\tnew InitialLdapContext(env, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSessionErrors.add(req, \"ldapAuthentication\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_ENABLED, Boolean.toString(enabled));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_REQUIRED, Boolean.toString(required));\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_BASE_PROVIDER_URL, \n\t\t\tbaseProviderURL);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_BASE_DN, baseDN);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_SECURITY_PRINCIPAL, principal);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_SECURITY_CREDENTIALS, credentials);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_SEARCH_FILTER, searchFilter);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTH_IMPL_LDAP_PASSWORD_ENCRYPTION_ALGORITHM,\n\t\t\tpasswordEncryptionAlgorithm);\n\t\tprefs.setValue(PropsUtil.AUTH_IMPL_LDAP_USER_MAPPINGS, userMappings);\n\n\t\tprefs.store();\n\t}","commit_id":"28bd5baf774c7f5c6d272f34a1c8443b0ef9b29d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int authenticate(\n\t\t\tString companyId, String emailAddress, String userId,\n\t\t\tString password)\n\t\tthrows Exception {\n\n\t\tboolean enabled = PrefsPropsUtil.getBoolean(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_ENABLED);\n\n\t\tif (!enabled) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Authenticator is not enabled\");\n\t\t\t}\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Authenticator is enabled\");\n\t\t}\n\n\t\tProperties env = new Properties();\n\n\t\tString providerURL = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_PROVIDER_URL);\n\n\t\tString ldapContext = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_CONTEXT);\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL, providerURL + StringPool.SLASH + ldapContext);\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tString filter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SEARCH_FILTER);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t}\n\n\t\tfilter = StringUtil.replace(\n\t\t\tfilter,\n\t\t\tnew String[] {\n\t\t\t\t\"@company_id@\", \"@email_address@\", \"@user_id@\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcompanyId, emailAddress, userId\n\t\t\t});\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 1, 0, null, false, false);\n\t\n\t\t\tNamingEnumeration enu = ctx.search(StringPool.BLANK, filter, cons);\n\t\n\t\t\tif (enu.hasMore()) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter returned at least one result\");\n\t\t\t\t}\n\t\n\t\t\t\tBinding binding = (Binding)enu.next();\n\t\n\t\t\t\tAttributes attrs = ctx.getAttributes(binding.getName());\n\t\n\t\t\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_USER_MAPPINGS));\n\t\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\t\n\t\t\t\t\tuserMappings.list(new PrintWriter(sw));\n\t\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\t\n\t\t\t\tString creatorUserId = null;\n\t\t\t\tboolean autoUserId = false;\n\t\n\t\t\t\tif (Validator.isNull(userId)) {\n\t\t\t\t\tuserId = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"userId\"));\n\t\t\t\t}\n\t\n\t\t\t\tboolean autoPassword = false;\n\t\t\t\tString password1 = password;\n\t\t\t\tString password2 = password;\n\t\t\t\tboolean passwordReset = false;\n\t\n\t\t\t\tif (Validator.isNull(emailAddress)) {\n\t\t\t\t\temailAddress = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"emailAddress\"));\n\t\t\t\t}\n\t\n\t\t\t\tLocale locale = Locale.US;\n\t\t\t\tString firstName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"firstName\"));\n\t\t\t\tString middleName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"middleName\"));\n\t\t\t\tString lastName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"lastName\"));\n\t\n\t\t\t\tif (Validator.isNull(firstName) || Validator.isNull(lastName)) {\n\t\t\t\t\tString fullName = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"fullName\"));\n\t\n\t\t\t\t\tString[] names = LDAPUtil.splitFullName(fullName);\n\t\n\t\t\t\t\tfirstName = names[0];\n\t\t\t\t\tmiddleName = names[1];\n\t\t\t\t\tlastName = names[2];\n\t\t\t\t}\n\t\n\t\t\t\tString nickName = null;\n\t\t\t\tString prefixId = null;\n\t\t\t\tString suffixId = null;\n\t\t\t\tboolean male = true;\n\t\t\t\tint birthdayMonth = Calendar.JANUARY;\n\t\t\t\tint birthdayDay = 1;\n\t\t\t\tint birthdayYear = 1970;\n\t\t\t\tString jobTitle = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"jobTitle\"));\n\t\t\t\tString organizationId = null;\n\t\t\t\tString locationId = null;\n\t\t\t\tboolean sendEmail = false;\n\t\n\t\t\t\t// Check passwords by either doing a comparison between the\n\t\t\t\t// passwords or by binding to the LDAP server\n\t\n\t\t\t\tAttribute userPassword = attrs.get(\"userPassword\");\n\t\n\t\t\t\tif (userPassword != null) {\n\t\t\t\t\tString ldapPassword =\n\t\t\t\t\t\tnew String((byte[])userPassword.get());\n\t\n\t\t\t\t\tString encryptedPassword = password;\n\t\n\t\t\t\t\tString algorithm = PrefsPropsUtil.getString(\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tPropsUtil.AUTH_IMPL_LDAP_PASSWORD_ENCRYPTION_ALGORITHM);\n\t\n\t\t\t\t\tif (Validator.isNotNull(algorithm)) {\n\t\t\t\t\t\tencryptedPassword =\n\t\t\t\t\t\t\t\"{\" + algorithm + \"}\" +\n\t\t\t\t\t\t\t\tEncryptor.digest(algorithm, password);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!ldapPassword.equals(encryptedPassword)) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"LDAP password \" + ldapPassword +\n\t\t\t\t\t\t\t\t\" does not match with given password \" +\n\t\t\t\t\t\t\t\t\tencryptedPassword + \" for user id \" + userId);\n\t\n\t\t\t\t\t\treturn authenticateRequired(companyId, userId, \n\t\t\t\t\t\t\temailAddress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, userId);\n\t\t\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, password);\n\t\n\t\t\t\t\t\tctx = new InitialLdapContext(env, null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Failed to bind to the LDAP server with \" + userId +\n\t\t\t\t\t\t\t\t\" \" + password, e);\n\t\n\t\t\t\t\t\treturn authenticateRequired(companyId, userId, \n\t\t\t\t\t\t\temailAddress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure the user has a portal account\n\t\n\t\t\t\tLDAPImportUtil.addOrUpdateUser(\n\t\t\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId,\n\t\t\t\t\tmale, birthdayMonth, birthdayDay, birthdayYear, jobTitle,\n\t\t\t\t\torganizationId, locationId, sendEmail, true, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter did not return any results\");\n\t\t\t\t}\n\t\n\t\t\t\treturn authenticateRequired(companyId, userId, emailAddress);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.warn(\"Problem accessing LDAP server\");\n\n\t\t\treturn authenticateRequired(companyId, userId, emailAddress);\n\t\t}\n\t\t\n\t\treturn SUCCESS;\n\t}","id":106516,"modified_method":"protected int authenticate(\n\t\t\tString companyId, String emailAddress, String userId,\n\t\t\tString password)\n\t\tthrows Exception {\n\n\t\tboolean enabled = PrefsPropsUtil.getBoolean(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_ENABLED);\n\n\t\tif (!enabled) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Authenticator is not enabled\");\n\t\t\t}\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Authenticator is enabled\");\n\t\t}\n\n\t\tProperties env = new Properties();\n\n\t\tString baseProviderURL = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_BASE_PROVIDER_URL);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_BASE_DN);\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL, LDAPUtil.getFullProviderURL(baseProviderURL,\n\t\t\t\tbaseDN));\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tString filter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_SEARCH_FILTER);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t}\n\n\t\tfilter = StringUtil.replace(\n\t\t\tfilter,\n\t\t\tnew String[] {\n\t\t\t\t\"@company_id@\", \"@email_address@\", \"@user_id@\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcompanyId, emailAddress, userId\n\t\t\t});\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 1, 0, null, false, false);\n\t\n\t\t\tNamingEnumeration enu = ctx.search(StringPool.BLANK, filter, cons);\n\t\n\t\t\tif (enu.hasMore()) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter returned at least one result\");\n\t\t\t\t}\n\t\n\t\t\t\tBinding binding = (Binding)enu.next();\n\t\n\t\t\t\tAttributes attrs = ctx.getAttributes(binding.getName());\n\t\n\t\t\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\t\t\tPrefsPropsUtil.getString(\n\t\t\t\t\t\tcompanyId, PropsUtil.AUTH_IMPL_LDAP_USER_MAPPINGS));\n\t\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringWriter sw = new StringWriter();\n\t\n\t\t\t\t\tuserMappings.list(new PrintWriter(sw));\n\t\n\t\t\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t\t\t}\n\t\n\t\t\t\tString creatorUserId = null;\n\t\t\t\tboolean autoUserId = false;\n\t\n\t\t\t\tif (Validator.isNull(userId)) {\n\t\t\t\t\tuserId = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"userId\"));\n\t\t\t\t}\n\t\n\t\t\t\tboolean autoPassword = false;\n\t\t\t\tString password1 = password;\n\t\t\t\tString password2 = password;\n\t\t\t\tboolean passwordReset = false;\n\t\n\t\t\t\tif (Validator.isNull(emailAddress)) {\n\t\t\t\t\temailAddress = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"emailAddress\"));\n\t\t\t\t}\n\t\n\t\t\t\tLocale locale = Locale.US;\n\t\t\t\tString firstName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"firstName\"));\n\t\t\t\tString middleName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"middleName\"));\n\t\t\t\tString lastName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"lastName\"));\n\t\n\t\t\t\tif (Validator.isNull(firstName) || Validator.isNull(lastName)) {\n\t\t\t\t\tString fullName = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tattrs, userMappings.getProperty(\"fullName\"));\n\t\n\t\t\t\t\tString[] names = LDAPUtil.splitFullName(fullName);\n\t\n\t\t\t\t\tfirstName = names[0];\n\t\t\t\t\tmiddleName = names[1];\n\t\t\t\t\tlastName = names[2];\n\t\t\t\t}\n\t\n\t\t\t\tString nickName = null;\n\t\t\t\tString prefixId = null;\n\t\t\t\tString suffixId = null;\n\t\t\t\tboolean male = true;\n\t\t\t\tint birthdayMonth = Calendar.JANUARY;\n\t\t\t\tint birthdayDay = 1;\n\t\t\t\tint birthdayYear = 1970;\n\t\t\t\tString jobTitle = LDAPUtil.getAttributeValue(\n\t\t\t\t\tattrs, userMappings.getProperty(\"jobTitle\"));\n\t\t\t\tString organizationId = null;\n\t\t\t\tString locationId = null;\n\t\t\t\tboolean sendEmail = false;\n\t\n\t\t\t\t// Check passwords by either doing a comparison between the\n\t\t\t\t// passwords or by binding to the LDAP server\n\t\n\t\t\t\tAttribute userPassword = attrs.get(\"userPassword\");\n\t\n\t\t\t\tif (userPassword != null) {\n\t\t\t\t\tString ldapPassword =\n\t\t\t\t\t\tnew String((byte[])userPassword.get());\n\t\n\t\t\t\t\tString encryptedPassword = password;\n\t\n\t\t\t\t\tString algorithm = PrefsPropsUtil.getString(\n\t\t\t\t\t\tcompanyId,\n\t\t\t\t\t\tPropsUtil.AUTH_IMPL_LDAP_PASSWORD_ENCRYPTION_ALGORITHM);\n\t\n\t\t\t\t\tif (Validator.isNotNull(algorithm)) {\n\t\t\t\t\t\tencryptedPassword =\n\t\t\t\t\t\t\t\"{\" + algorithm + \"}\" +\n\t\t\t\t\t\t\t\tEncryptor.digest(algorithm, password);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!ldapPassword.equals(encryptedPassword)) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"LDAP password \" + ldapPassword +\n\t\t\t\t\t\t\t\t\" does not match with given password \" +\n\t\t\t\t\t\t\t\t\tencryptedPassword + \" for user id \" + userId);\n\t\n\t\t\t\t\t\treturn authenticateRequired(companyId, userId, \n\t\t\t\t\t\t\temailAddress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tenv.put(Context.SECURITY_PRINCIPAL, userId);\n\t\t\t\t\t\tenv.put(Context.SECURITY_CREDENTIALS, password);\n\t\n\t\t\t\t\t\tctx = new InitialLdapContext(env, null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Failed to bind to the LDAP server with \" + userId +\n\t\t\t\t\t\t\t\t\" \" + password, e);\n\t\n\t\t\t\t\t\treturn authenticateRequired(companyId, userId, \n\t\t\t\t\t\t\temailAddress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure the user has a portal account\n\t\n\t\t\t\tLDAPImportUtil.addOrUpdateUser(\n\t\t\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId,\n\t\t\t\t\tmale, birthdayMonth, birthdayDay, birthdayYear, jobTitle,\n\t\t\t\t\torganizationId, locationId, sendEmail, true, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter did not return any results\");\n\t\t\t\t}\n\t\n\t\t\t\treturn authenticateRequired(companyId, userId, emailAddress);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.warn(\"Problem accessing LDAP server\");\n\n\t\t\treturn authenticateRequired(companyId, userId, emailAddress);\n\t\t}\n\t\t\n\t\treturn SUCCESS;\n\t}","commit_id":"28bd5baf774c7f5c6d272f34a1c8443b0ef9b29d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importLDAP(String companyId) throws Exception {\n\t\tProperties env = new Properties();\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_PROVIDER_URL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_USER_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tuserMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tProperties groupMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_GROUP_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tgroupMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\t\ttry {\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SEARCH_FILTER);\n\n\t\t\tString context = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_CONTEXT);\n\n\t\t\tNamingEnumeration enu = ctx.search(context, filter, null);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\t_importLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, result);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","id":106517,"modified_method":"public static void importLDAP(String companyId) throws Exception {\n\t\tProperties env = new Properties();\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_PROVIDER_URL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_USER_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tuserMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tProperties groupMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_GROUP_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tgroupMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\t\ttry {\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SEARCH_FILTER);\n\n\t\t\tString context = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_DN);\n\n\t\t\tNamingEnumeration enu = ctx.search(context, filter, null);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\t_importLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, result);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"28bd5baf774c7f5c6d272f34a1c8443b0ef9b29d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void printEnvironment(Installation installation, PrintStream out) {\n        out.println(String.format(FORMAT, HEADERS));\n        for (String variable : installation.getEnvironment().keySet()) {\n            String value = installation.getEnvironment().get(variable);\n            out.println(String.format(FORMAT, variable, value));\n        }\n    }","id":106518,"modified_method":"protected void printEnvironment(Installation installation, PrintStream out) {\n        TablePrinter printer = new TablePrinter();\n        printer.columns(\"variable\", \"value\");\n\n        for (String variable : installation.getEnvironment().keySet()) {\n            String value = installation.getEnvironment().get(variable);\n            printer.row(variable, value);\n        }\n\n        printer.print(out);\n    }","commit_id":"a1e9950fef045f2671997678df85916cf7116e85","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        out.println(String.format(FORMAT, HEADERS));\n        for (Installation installation : installations) {\n            String id = installation.getId();\n            Long pid = null;\n            try {\n                pid = installation.getActivePid();\n            } catch (IOException e) {\n                System.err.println(\"Failed to find pid for id: \" + id + \". \" + e);\n            }\n            out.println(String.format(FORMAT, \"\" + id, (pid != null) ? pid.toString() : \"\", installation.getName()));\n        }\n    }","id":106519,"modified_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        TablePrinter printer = new TablePrinter();\n        printer.columns(\"id\", \"pid\", \"name\");\n\n        for (Installation installation : installations) {\n            String id = installation.getId();\n            String pid = \"\";\n            try {\n                pid = \"\" + installation.getActivePid();\n            } catch (IOException e) {\n                // ignore\n            }\n            printer.row(id, pid, installation.getName());\n        }\n\n        printer.print(out);\n    }","commit_id":"a1e9950fef045f2671997678df85916cf7116e85","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        TablePrinter printer = new TablePrinter();\n        printer.columns(\"id\", \"pid\", \"name\");\n\n        for (Installation installation : installations) {\n            String id = installation.getId();\n            String pid = \"\";\n            try {\n                pid = \"\" + installation.getActivePid();\n            } catch (IOException e) {\n                // ignore\n            }\n            printer.row(id, pid, installation.getName());\n        }\n\n        printer.print(out);\n    }","id":106520,"modified_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        TablePrinter printer = new TablePrinter();\n        if (verbose) {\n            printer.columns(\"id\", \"pid\", \"connected\", \"type\", \"directory\");\n        } else {\n            printer.columns(\"id\", \"pid\", \"connected\", \"type\");\n        }\n\n        for (Installation installation : installations) {\n\n            String id = installation.getId();\n            String pid = \"\";\n            String connected = \"no\";\n            String path = installation.getInstallDir() != null ? installation.getInstallDir().getPath() : \"\";\n\n            String type = installation.getName();\n            if (!verbose) {\n                if (type.startsWith(\"java \")) {\n                    // skip middle package name as that is too verbose\n                    int idx = type.lastIndexOf('.');\n                    if (idx > 0) {\n                        type = \"java \" + type.substring(idx + 1);\n                    }\n                }\n            }\n            try {\n                Long aid = installation.getActivePid();\n                if (aid != null) {\n                    pid = \"\" + aid;\n                    connected = \"yes\";\n                }\n            } catch (IOException e) {\n                // ignore\n            }\n            if (verbose) {\n                printer.row(id, pid, connected, type, path);\n            } else {\n                printer.row(id, pid, connected, type);\n            }\n        }\n\n        printer.print(out);\n    }","commit_id":"96c942ff617eaf9f75d562997529803ca59e9848","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        IOpenShiftConnection connection = getOrCreateConnection();\n        System.out.println(String.format(FORMAT, \"[domain]\", \"[application id]\"));\n\n        for (IDomain domain : connection.getDomains()) {\n            if (domainId == null || domainId.equals(domain.getId())) {\n                String displayDomain = domain.getId();\n                domain.refresh();\n                for (IApplication application : domain.getApplications()) {\n                    System.out.println(String.format(FORMAT, displayDomain, application.getName()));\n                    displayDomain = \"\";\n                }\n            }\n        }\n        return null;\n    }","id":106521,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        IOpenShiftConnection connection = getOrCreateConnection();\n\n        TablePrinter printer = new TablePrinter();\n        printer.columns(\"domain\", \"application id\");\n\n        for (IDomain domain : connection.getDomains()) {\n            if (domainId == null || domainId.equals(domain.getId())) {\n                String displayDomain = domain.getId();\n                domain.refresh();\n                for (IApplication application : domain.getApplications()) {\n                    printer.row(displayDomain, application.getName());\n                    displayDomain = \"\";\n                }\n            }\n        }\n        printer.print();\n\n        return null;\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected URL getControllerURL() throws MalformedURLException {\n        URL controllerUrl = null;\n        if (controllerJson != null) {\n            controllerUrl = new URL(controllerJson);\n        } else if (controllerKind != null) {\n            String name = controllerKind + \".json\";\n            controllerUrl = new URL(\"profile:\" + name);\n            if (controllerUrl == null) {\n                throw new IllegalStateException(\"Cannot find controller kind: \" + name + \" on the classpath\");\n            }\n        }\n        return controllerUrl;\n    }","id":106522,"modified_method":"protected URL getControllerURL() throws MalformedURLException {\n        URL controllerUrl = null;\n        if (controllerJson != null) {\n            controllerUrl = new URL(controllerJson);\n        } else if (controllerKind != null) {\n            String name = controllerKind + \".json\";\n            controllerUrl = new URL(\"profile:\" + name);\n        }\n        return controllerUrl;\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        IOpenShiftConnection connection = getOrCreateConnection();\n        System.out.println(\"[id]\");\n        for (IDomain domain :connection.getDomains()){\n            System.out.println(domain.getId());\n        }\n        return null;\n    }","id":106523,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        IOpenShiftConnection connection = getOrCreateConnection();\n\n        TablePrinter printer = new TablePrinter();\n        printer.column(\"id\");\n\n        for (IDomain domain :connection.getDomains()){\n            printer.row(domain.getId());\n        }\n        printer.print();\n\n        return null;\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        PrintStream out = System.out;\n        List<String> containers = clusterService.getEnsembleContainers();\n        if (containers != null) {\n            out.println(\"[id]\");\n            for (String container : containers) {\n                out.println(container);\n            }\n        }\n        return null;\n    }","id":106524,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        TablePrinter printer = new TablePrinter();\n        printer.column(\"id\");\n\n        List<String> containers = clusterService.getEnsembleContainers();\n        if (containers != null) {\n            for (String container : containers) {\n                printer.row(container);\n            }\n        }\n        printer.print();\n\n        return null;\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        out.println(String.format(FORMAT, HEADERS));\n        for (Installation installation : installations) {\n            String id = installation.getId();\n            Long pid = null;\n            try {\n                pid = installation.getActivePid();\n            } catch (IOException e) {\n                System.err.println(\"Failed to find pid for id: \" + id + \". \" + e);\n            }\n            out.println(String.format(FORMAT, \"\" + id, (pid != null) ? pid.toString() : \"\", installation.getName()));\n        }\n    }","id":106525,"modified_method":"protected void printInstallations(List<Installation> installations, PrintStream out) {\n        TablePrinter printer = new TablePrinter();\n        printer.columns(\"id\", \"pid\", \"name\");\n\n        for (Installation installation : installations) {\n            String id = installation.getId();\n            String pid = \"\";\n            try {\n                pid = \"\" + installation.getActivePid();\n            } catch (IOException e) {\n                pid = \"<unknown>\";\n            }\n            printer.row(id, pid, installation.getName());\n        }\n\n        printer.print(out);\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n\n        if (start && stop) {\n            System.err.println(\"Please use only one of --start and --stop options!\");\n            return null;\n        }\n\n        if (interval > 0) {\n            System.out.println(\"Setting watch interval to \" + interval + \" ms\");\n            watcher.setInterval(interval);\n        }\n        if (stop) {\n            System.out.println(\"Stopping watch\");\n            watcher.stop();\n        }\n        watcher.setUpload(!noUpload);\n        if (urls != null) {\n            if (remove) {\n                for (String url : urls) {\n                    watcher.remove(url);\n                }\n            } else {\n                for (String url : urls) {\n                    watcher.add(url);\n                }\n            }\n        }\n        if (start) {\n            System.out.println(\"Starting watch\");\n            watcher.start();\n        }\n\n        if (list) { //List the watched bundles.\n            String format = \"%-40s %-30s %-8s %-80s\";\n            System.out.println(String.format(format, \"URL\", \"Profile\", \"Version\", \"Bundle\"));\n            for (String url : watcher.getWatchURLs()) {\n\n                Map<ProfileVersionKey, Map<String, Parser>> profileArtifacts = watcher.getProfileArtifacts();\n                if (profileArtifacts.size() > 0) {\n                    Set<Map.Entry<ProfileVersionKey, Map<String, Parser>>> entries = profileArtifacts.entrySet();\n                    for (Map.Entry<ProfileVersionKey, Map<String, Parser>> entry : entries) {\n                        ProfileVersionKey key = entry.getKey();\n                        Map<String, Parser> artifactMap = entry.getValue();\n                        Set<Map.Entry<String, Parser>> artifactMapEntries = artifactMap.entrySet();\n                        for (Map.Entry<String, Parser> artifactMapEntry : artifactMapEntries) {\n                            String location = artifactMapEntry.getKey();\n                            Parser parser = artifactMapEntry.getValue();\n                            if (isSnapshot(parser) || watcher.wildCardMatch(location, url)) {\n                                System.out.println(String.format(format, url, key.getProfileId(), key.getVersion(), location));\n                            }\n                        }\n                    }\n                } else {\n                    System.out.println(String.format(format, url, \"\", \"\", \"\"));\n                }\n            }\n        } else {\n            List<String> urls = watcher.getWatchURLs();\n            if (urls != null && urls.size() > 0) {\n                System.out.println(\"Watched URLs: \");\n                for (String url : watcher.getWatchURLs()) {\n                    System.out.println(url);\n                }\n            } else {\n                System.out.println(\"No watched URLs\");\n            }\n        }\n\n        return null;\n    }","id":106526,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n\n        if (start && stop) {\n            System.err.println(\"Please use only one of --start and --stop options!\");\n            return null;\n        }\n\n        if (interval > 0) {\n            System.out.println(\"Setting watch interval to \" + interval + \" ms\");\n            watcher.setInterval(interval);\n        }\n        if (stop) {\n            System.out.println(\"Stopping watch\");\n            watcher.stop();\n        }\n        watcher.setUpload(!noUpload);\n        if (urls != null) {\n            if (remove) {\n                for (String url : urls) {\n                    watcher.remove(url);\n                }\n            } else {\n                for (String url : urls) {\n                    watcher.add(url);\n                }\n            }\n        }\n        if (start) {\n            System.out.println(\"Starting watch\");\n            watcher.start();\n        }\n\n        if (list) {\n            // list the watched bundles.\n            TablePrinter printer = new TablePrinter();\n            printer.columns(\"url\", \"profile\", \"version\", \"bundle\");\n            for (String url : watcher.getWatchURLs()) {\n                Map<ProfileVersionKey, Map<String, Parser>> profileArtifacts = watcher.getProfileArtifacts();\n                if (profileArtifacts.size() > 0) {\n                    Set<Map.Entry<ProfileVersionKey, Map<String, Parser>>> entries = profileArtifacts.entrySet();\n                    for (Map.Entry<ProfileVersionKey, Map<String, Parser>> entry : entries) {\n                        ProfileVersionKey key = entry.getKey();\n                        Map<String, Parser> artifactMap = entry.getValue();\n                        Set<Map.Entry<String, Parser>> artifactMapEntries = artifactMap.entrySet();\n                        for (Map.Entry<String, Parser> artifactMapEntry : artifactMapEntries) {\n                            String location = artifactMapEntry.getKey();\n                            Parser parser = artifactMapEntry.getValue();\n                            if (isSnapshot(parser) || watcher.wildCardMatch(location, url)) {\n                                printer.row(url, key.getProfileId(), key.getVersion(), location);\n                            }\n                        }\n                    }\n                } else {\n                    printer.row(url, \"\", \"\", \"\");\n                }\n            }\n            printer.print();\n        } else {\n            List<String> urls = watcher.getWatchURLs();\n            if (urls != null && urls.size() > 0) {\n                System.out.println(\"Watched URLs: \");\n                for (String url : watcher.getWatchURLs()) {\n                    System.out.println(url);\n                }\n            } else {\n                System.out.println(\"No watched URLs\");\n            }\n        }\n\n        return null;\n    }","commit_id":"58aea2893ffd13bbaa3757f7c137ba9a3677e3c6","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static <T extends StagedModel, U extends StagedModel> Element\n\t\t\texportReferenceStagedModel(\n\t\t\t\tPortletDataContext portletDataContext, T referrerStagedModel,\n\t\t\t\tU stagedModel, String referenceType)\n\t\tthrows PortletDataException {\n\n\t\tElement referrerStagedModelElement =\n\t\t\tportletDataContext.getExportDataElement(referrerStagedModel);\n\n\t\tElement referenceElement = null;\n\n\t\tif (stagedModel instanceof StagedGroupedModel) {\n\t\t\tStagedGroupedModel stagedGroupedModel =\n\t\t\t\t(StagedGroupedModel)stagedModel;\n\n\t\t\tif (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\tstagedGroupedModel)) {\n\n\t\t\t\treferenceElement = portletDataContext.addReferenceElement(\n\t\t\t\t\treferrerStagedModel, referrerStagedModelElement,\n\t\t\t\t\tstagedModel, PortletDataContext.REFERENCE_TYPE_DEPENDENCY,\n\t\t\t\t\ttrue);\n\n\t\t\t\treturn referenceElement;\n\t\t\t}\n\t\t}\n\n\t\texportStagedModel(portletDataContext, stagedModel);\n\n\t\treferenceElement = portletDataContext.addReferenceElement(\n\t\t\treferrerStagedModel, referrerStagedModelElement, stagedModel,\n\t\t\treferenceType, false);\n\n\t\treturn referenceElement;\n\t}","id":106527,"modified_method":"public static <T extends StagedModel, U extends StagedModel> Element\n\t\t\texportReferenceStagedModel(\n\t\t\t\tPortletDataContext portletDataContext, T referrerStagedModel,\n\t\t\t\tU stagedModel, String referenceType)\n\t\tthrows PortletDataException {\n\n\t\tElement referrerStagedModelElement =\n\t\t\tportletDataContext.getExportDataElement(referrerStagedModel);\n\n\t\tif (!ExportImportHelperUtil.isReferenceWithinExportScope(\n\t\t\t\tportletDataContext, stagedModel)) {\n\n\t\t\treturn portletDataContext.addReferenceElement(\n\t\t\t\treferrerStagedModel, referrerStagedModelElement, stagedModel,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\t\t}\n\n\t\texportStagedModel(portletDataContext, stagedModel);\n\n\t\treturn portletDataContext.addReferenceElement(\n\t\t\treferrerStagedModel, referrerStagedModelElement, stagedModel,\n\t\t\treferenceType, false);\n\t}","commit_id":"b79f1b7ff008d458b05270dddbd3c2be522449cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <T extends StagedModel> Element exportReferenceStagedModel(\n\t\t\tPortletDataContext portletDataContext, String referrerPortletId,\n\t\t\tT stagedModel)\n\t\tthrows PortletDataException {\n\n\t\tElement referenceElement = null;\n\n\t\tPortlet referrerPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\treferrerPortletId);\n\n\t\tif (stagedModel instanceof StagedGroupedModel) {\n\t\t\tStagedGroupedModel stagedGroupedModel =\n\t\t\t\t(StagedGroupedModel)stagedModel;\n\n\t\t\tif (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\tstagedGroupedModel)) {\n\n\t\t\t\treferenceElement = portletDataContext.addReferenceElement(\n\t\t\t\t\treferrerPortlet,\n\t\t\t\t\tportletDataContext.getExportDataRootElement(), stagedModel,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\n\t\t\t\treturn referenceElement;\n\t\t\t}\n\t\t}\n\n\t\texportStagedModel(portletDataContext, stagedModel);\n\n\t\treferenceElement = portletDataContext.addReferenceElement(\n\t\t\treferrerPortlet, portletDataContext.getExportDataRootElement(),\n\t\t\tstagedModel, PortletDataContext.REFERENCE_TYPE_DEPENDENCY, false);\n\n\t\treturn referenceElement;\n\t}","id":106528,"modified_method":"public static <T extends StagedModel> Element exportReferenceStagedModel(\n\t\t\tPortletDataContext portletDataContext, String referrerPortletId,\n\t\t\tT stagedModel)\n\t\tthrows PortletDataException {\n\n\t\tPortlet referrerPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\treferrerPortletId);\n\n\t\tif (!ExportImportHelperUtil.isReferenceWithinExportScope(\n\t\t\t\tportletDataContext, stagedModel)) {\n\n\t\t\treturn portletDataContext.addReferenceElement(\n\t\t\t\treferrerPortlet, portletDataContext.getExportDataRootElement(),\n\t\t\t\tstagedModel, PortletDataContext.REFERENCE_TYPE_DEPENDENCY,\n\t\t\t\ttrue);\n\t\t}\n\n\t\texportStagedModel(portletDataContext, stagedModel);\n\n\t\treturn portletDataContext.addReferenceElement(\n\t\t\treferrerPortlet, portletDataContext.getExportDataRootElement(),\n\t\t\tstagedModel, PortletDataContext.REFERENCE_TYPE_DEPENDENCY, false);\n\t}","commit_id":"b79f1b7ff008d458b05270dddbd3c2be522449cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void update(AnActionEvent e) {\n    Project project = e.getData(DataKeys.PROJECT);\n    Change[] changes = e.getData(DataKeys.CHANGES);\n    List<VirtualFile> unversionedFiles = e.getData(ChangesListView.UNVERSIONED_FILES_DATA_KEY);\n\n    if (project != null && changes == null && unversionedFiles == null) {\n      unversionedFiles = new ArrayList<VirtualFile>();\n      changes = getChangesForSelectedFiles(project, changes, unversionedFiles, null, e);\n    }\n\n    final boolean isEnabled = project != null &&\n                              (changes != null && changes.length > 0) || (unversionedFiles != null && unversionedFiles.size() > 0);\n    if (ActionPlaces.PROJECT_VIEW_POPUP.equals(e.getPlace()) || ActionPlaces.EDITOR_POPUP.equals(e.getPlace())) {\n      e.getPresentation().setVisible(isEnabled);\n    }\n    else {\n      e.getPresentation().setEnabled(isEnabled);\n    }\n  }","id":106529,"modified_method":"public void update(AnActionEvent e) {\n    Project project = e.getData(DataKeys.PROJECT);\n    Change[] changes = e.getData(DataKeys.CHANGES);\n    List<VirtualFile> unversionedFiles = e.getData(ChangesListView.UNVERSIONED_FILES_DATA_KEY);\n\n    if (project != null && changes == null && unversionedFiles == null) {\n      unversionedFiles = new ArrayList<VirtualFile>();\n      changes = getChangesForSelectedFiles(project, changes, unversionedFiles, null, e);\n    }\n\n    final boolean isEnabled = project != null &&\n                              (changes != null && changes.length > 0) || (unversionedFiles != null && unversionedFiles.size() > 0);\n    if (ActionPlaces.isPopupPlace(e.getPlace())) {\n      e.getPresentation().setVisible(isEnabled);\n    }\n    else {\n      e.getPresentation().setEnabled(isEnabled);\n    }\n  }","commit_id":"61e56530456aed9bcee38376711c090a91701112","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPresentableRelativePath(final ContentRevision fromRevision, final ContentRevision toRevision) {\n    // need to use parent path because the old file is already not there\n    final VirtualFile oldFile = fromRevision.getFile().getParentPath().getVirtualFile();\n    final VirtualFile newFile = toRevision.getFile().getParentPath().getVirtualFile();\n    if (oldFile != null && newFile != null) {\n      Module oldModule = ModuleUtil.findModuleForFile(oldFile, myProject);\n      Module newModule = ModuleUtil.findModuleForFile(newFile, myProject);\n      if (oldModule != newModule) {\n        return getPresentableRelativePathFor(oldFile);\n      }\n    }\n    final RelativePathCalculator calculator =\n      new RelativePathCalculator(toRevision.getFile().getIOFile().getAbsolutePath(), fromRevision.getFile().getIOFile().getAbsolutePath());\n    calculator.execute();\n    final String result = calculator.getResult();\n    return (result == null) ? null : result.replace(\"/\", File.separator);\n  }","id":106530,"modified_method":"public String getPresentableRelativePath(final ContentRevision fromRevision, final ContentRevision toRevision) {\n    // need to use parent path because the old file is already not there\n    FilePath fromPath = fromRevision.getFile();\n    FilePath toPath = toRevision.getFile();\n\n    if (fromPath == null || toPath == null || (fromPath.getParentPath() == null) || (toPath.getParentPath() == null)) {\n      return null;\n    }\n\n    final VirtualFile oldFile = fromPath.getParentPath().getVirtualFile();\n    final VirtualFile newFile = toPath.getParentPath().getVirtualFile();\n    if (oldFile != null && newFile != null) {\n      Module oldModule = ModuleUtil.findModuleForFile(oldFile, myProject);\n      Module newModule = ModuleUtil.findModuleForFile(newFile, myProject);\n      if (oldModule != newModule) {\n        return getPresentableRelativePathFor(oldFile);\n      }\n    }\n    if (toPath.getIOFile() == null || fromPath.getIOFile() == null) {\n      return null;\n    }\n    final RelativePathCalculator calculator =\n      new RelativePathCalculator(toPath.getIOFile().getAbsolutePath(), fromPath.getIOFile().getAbsolutePath());\n    calculator.execute();\n    final String result = calculator.getResult();\n    return (result == null) ? null : result.replace(\"/\", File.separator);\n  }","commit_id":"164131113eabad6def164c64eaf90f97478076af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Object getData(@NonNls String dataId) {\n    if (dataId.equals(DataKeys.PROJECT.getName())) {\n      return myProject;\n    }\n    if (dataId.equals(DataKeys.NAVIGATABLE_ARRAY.getName())) {\n      final List<Navigatable> navigatables = new ArrayList<Navigatable>();\n      for (PomTreeStructure.PomNode pomNode : getSelectedPomNodes()) {\n        final Navigatable navigatable = pomNode.getNavigatable();\n        if(navigatable!=null){\n          navigatables.add(navigatable);\n        }\n      }\n      return navigatables.isEmpty() ? null : navigatables.toArray(new Navigatable[navigatables.size()]);\n    }\n    if (dataId.equals(DataKeys.VIRTUAL_FILE.getName())) {\n      final PomTreeStructure.PomNode pomNode = getContextPomNode();\n      return pomNode != null ? pomNode.getFile() : null;\n    }\n    if (dataId.equals(DataKeys.VIRTUAL_FILE_ARRAY.getName())) {\n      final List<VirtualFile> files = new ArrayList<VirtualFile>();\n      for (PomTreeStructure.PomNode pomNode : getSelectedPomNodes()) {\n        files.add(pomNode.getFile());\n      }\n      return files.isEmpty() ? null : files.toArray(new VirtualFile[files.size()]);\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_GOALS_KEY.getName())) {\n      final PomTreeStructure.PomNode pomNode = getSelectedPomNode();\n      if (pomNode != null) {\n        final MavenProject mavenProject = myProjectsState.getMavenProject(pomNode.getFile());\n        if (mavenProject != null) {\n          final String goal = mavenProject.getBuild().getDefaultGoal();\n          if (!StringUtil.isEmptyOrSpaces(goal)) {\n            return Collections.singletonList(goal);\n          }\n        }\n      }\n      else {\n        final List<PomTreeStructure.GoalNode> nodes = getSelectedNodes(PomTreeStructure.GoalNode.class);\n        if(PomTreeStructure.getCommonParent(nodes)==null) {\n          return null;\n        }\n        final List<String> goals = new ArrayList<String>();\n        for (PomTreeStructure.GoalNode node : nodes) {\n          goals.add(node.getGoal());\n        }\n        Collections.sort(goals, myGoalOrderComparator);\n        return goals;\n      }\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_PROFILES_KEY.getName())) {\n      final List<PomTreeStructure.ProfileNode> nodes = getSelectedNodes(PomTreeStructure.ProfileNode.class);\n      if(PomTreeStructure.getCommonParent(nodes)==null) {\n        return null;\n      }\n      final List<String> profiles = new ArrayList<String>();\n      for (PomTreeStructure.ProfileNode node : nodes) {\n        profiles.add(node.getProfile());\n      }\n      return profiles;\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_IDS.getName())) {\n      final List<PomTreeStructure.PluginNode> nodes = getSelectedNodes(PomTreeStructure.PluginNode.class);\n      if(PomTreeStructure.getCommonParent(nodes)==null) {\n        return null;\n      }\n      final List<MavenId> ids = new ArrayList<MavenId>();\n      for (PomTreeStructure.PluginNode node : nodes) {\n        if(node.isDetachable()){\n          ids.add(node.getId());\n        } else {\n          return null;\n        }\n      }\n      return ids;\n    }\n    return null;\n  }","id":106531,"modified_method":"@Nullable\n  public Object getData(@NonNls String dataId) {\n    if (dataId.equals(DataKeys.PROJECT.getName())) {\n      return myProject;\n    }\n    if (dataId.equals(DataKeys.NAVIGATABLE_ARRAY.getName())) {\n      final List<Navigatable> navigatables = new ArrayList<Navigatable>();\n      for (PomTreeStructure.PomNode pomNode : getSelectedPomNodes()) {\n        final Navigatable navigatable = pomNode.getNavigatable();\n        if(navigatable!=null){\n          navigatables.add(navigatable);\n        }\n      }\n      return navigatables.isEmpty() ? null : navigatables.toArray(new Navigatable[navigatables.size()]);\n    }\n    if (dataId.equals(DataKeys.VIRTUAL_FILE.getName())) {\n      final PomTreeStructure.PomNode pomNode = getContextPomNode();\n      if (pomNode == null) return null;\n      VirtualFile file = pomNode.getFile();\n      if (file == null || !file.isValid()) return null;\n      return file;\n    }\n    if (dataId.equals(DataKeys.VIRTUAL_FILE_ARRAY.getName())) {\n      final List<VirtualFile> files = new ArrayList<VirtualFile>();\n      for (PomTreeStructure.PomNode pomNode : getSelectedPomNodes()) {\n        VirtualFile file = pomNode.getFile();\n        if (file.isValid()) {\n          files.add(file);\n        }\n      }\n      return files.isEmpty() ? null : files.toArray(new VirtualFile[files.size()]);\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_GOALS_KEY.getName())) {\n      final PomTreeStructure.PomNode pomNode = getSelectedPomNode();\n      if (pomNode != null) {\n        final MavenProject mavenProject = myProjectsState.getMavenProject(pomNode.getFile());\n        if (mavenProject != null) {\n          final String goal = mavenProject.getBuild().getDefaultGoal();\n          if (!StringUtil.isEmptyOrSpaces(goal)) {\n            return Collections.singletonList(goal);\n          }\n        }\n      }\n      else {\n        final List<PomTreeStructure.GoalNode> nodes = getSelectedNodes(PomTreeStructure.GoalNode.class);\n        if(PomTreeStructure.getCommonParent(nodes)==null) {\n          return null;\n        }\n        final List<String> goals = new ArrayList<String>();\n        for (PomTreeStructure.GoalNode node : nodes) {\n          goals.add(node.getGoal());\n        }\n        Collections.sort(goals, myGoalOrderComparator);\n        return goals;\n      }\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_PROFILES_KEY.getName())) {\n      final List<PomTreeStructure.ProfileNode> nodes = getSelectedNodes(PomTreeStructure.ProfileNode.class);\n      if(PomTreeStructure.getCommonParent(nodes)==null) {\n        return null;\n      }\n      final List<String> profiles = new ArrayList<String>();\n      for (PomTreeStructure.ProfileNode node : nodes) {\n        profiles.add(node.getProfile());\n      }\n      return profiles;\n    }\n    if (dataId.equals(MavenDataKeys.MAVEN_IDS.getName())) {\n      final List<PomTreeStructure.PluginNode> nodes = getSelectedNodes(PomTreeStructure.PluginNode.class);\n      if(PomTreeStructure.getCommonParent(nodes)==null) {\n        return null;\n      }\n      final List<MavenId> ids = new ArrayList<MavenId>();\n      for (PomTreeStructure.PluginNode node : nodes) {\n        if(node.isDetachable()){\n          ids.add(node.getId());\n        } else {\n          return null;\n        }\n      }\n      return ids;\n    }\n    return null;\n  }","commit_id":"7e19d8aaa36334f3bdd521f83765235c187453ba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ReadBuffer decode( byte in[], int offset, int length ) throws DecodingException {\r\n\t\tbyte[] out = new byte[length];\r\n\t\tint written = 0;\r\n\t\tint end = offset + length;\r\n\t\tif( end > in.length )\r\n\t\t\tthrow new DecodingException( \"Index out of bound.\" );\r\n\t\tboolean linebreak = false;\r\n\t\tboolean lastCharWasQuoted = false;\r\n\t\tint lastSkip = 0;\r\n\t\twhile( length-- > 0 ) {\r\n\t\t\tbyte c = in[offset++];\r\n\t\t\tif( c == '=' ) {\r\n\t\t\t\tif( length > 0 ) {\r\n\t\t\t\t\tif( in[offset] == '?' ) {\r\n\t\t\t\t\t\t// System.err.println( \"=? found at \" + ( offset -1 ) );\r\n\t\t\t\t\t\tint f2 = offset + 1;\r\n\t\t\t\t\t\t// FIXME save charset here ticket #508\r\n\t\t\t\t\t\tfor( ; f2 < end && in[f2] != '?'; f2++ );\r\n\t\t\t\t\t\tif( f2 < end ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * 2nd question mark found\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t// System.err.println( \"2nd ? found at \" + f2 );\r\n\t\t\t\t\t\t\tint f3 = f2 + 1;\r\n\t\t\t\t\t\t\tfor( ; f3 < end && in[f3] != '?'; f3++ );\r\n\t\t\t\t\t\t\tif( f3 < end ) {\r\n\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t * 3rd question mark found\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// System.err.println( \"3rd ? found at \" + f3 );\r\n\t\t\t\t\t\t\t\tint f4 = f3 + 1;\r\n\t\t\t\t\t\t\t\tfor( ; f4 < end && in[f4] != '?'; f4++ );\r\n\t\t\t\t\t\t\t\tif( f4 < end - 1 && in[f4+1] == '=' ) {\r\n\t\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t\t * 4th question mark found, we are complete, so lets start\r\n\t\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t\tString enc = ( in[f2+1] == 'Q' || in[f2+1] == 'q' ) ? \"quoted-printable\" : ( ( in[f2+1] == 'B' || in[f2+1] == 'b' ) ? \"base64\" : null );\r\n\t\t\t\t\t\t\t\t\t// System.err.println( \"4th ? found at \" + f4 + \", encoding=\" + enc );\r\n\t\t\t\t\t\t\t\t\tif( enc != null ) {\r\n\t\t\t\t\t\t\t\t\t\tEncoding e = EncodingFactory.getEncoding( enc );\r\n\t\t\t\t\t\t\t\t\t\tif( e != null ) {\r\n\t\t\t\t\t\t\t\t\t\t\t// System.err.println( \"encoder found\" );\r\n\t\t\t\t\t\t\t\t\t\t\tReadBuffer tmp = null;\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// System.err.println( \"decode(\" + (f3 + 1) + \",\" + ( f4 - f3 - 1 ) + \")\" );\r\n\t\t\t\t\t\t\t\t\t\t\t\ttmp = e.decode( in, f3 + 1, f4 - f3 - 1 );\r\n\t\t\t\t\t\t\t\t\t\t\t\t// FIXME use saved charset here ticket #508\r\n\t\t\t\t\t\t\t\t\t\t\t\tfor( int j = 0; j < tmp.length; j++ ) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbyte d = tmp.content[ tmp.offset + j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tout[written++] = ( d == '_' ? 32 : d );\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tint distance = f4 + 2 - offset;\r\n\t\t\t\t\t\t\t\t\t\t\t\toffset += distance;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlength -= distance;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlastCharWasQuoted = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcatch (Exception e1) {\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( c == '\\r' ) {\r\n\t\t\t\tif( length > 0 && in[offset] == '\\n' ) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * delay linebreak in case of long line\r\n\t\t\t\t\t */\r\n\t\t\t\t\tlinebreak = true;\r\n\t\t\t\t\tlength--;\r\n\t\t\t\t\toffset++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( linebreak ) {\r\n\t\t\t\tlinebreak = false;\r\n\t\t\t\tif( c != ' ' && c != '\\t' ) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * new line does not start with whitespace, so its not a new part of a\r\n\t\t\t\t\t * long line\r\n\t\t\t\t\t */\r\n\t\t\t\t\tout[written++] = '\\r';\r\n\t\t\t\t\tout[written++] = '\\n';\r\n\t\t\t\t\tlastSkip = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif( !lastCharWasQuoted )\r\n\t\t\t\t\t\tout[written++] = ' ';\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * skip whitespace\r\n\t\t\t\t\t */\r\n\t\t\t\t\tint skipped = 1;\r\n\t\t\t\t\twhile( length > 0 && ( in[offset] == ' ' || in[offset] == '\\t' ) ) {\r\n\t\t\t\t\t\tif( lastSkip > 0 && skipped >= lastSkip ) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toffset++;\r\n\t\t\t\t\t\tlength--;\r\n\t\t\t\t\t\tskipped++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( lastSkip == 0 && skipped > 0 ) {\r\n\t\t\t\t\t\tlastSkip = skipped;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * print out everything else literally\r\n\t\t\t */\r\n\t\t\tout[written++] = c;\r\n\t\t\tlastCharWasQuoted = false;\r\n\t\t}\r\n\t\tif( linebreak ) {\r\n\t\t\tout[written++] = '\\r';\r\n\t\t\tout[written++] = '\\n';\r\n\t\t\tlastSkip = 0;\r\n\t\t}\r\n\t\t\t\r\n\t\tReadBuffer readBuffer = new ReadBuffer();\r\n\t\treadBuffer.content = out;\r\n\t\treadBuffer.offset = 0;\r\n\t\treadBuffer.length = written;\r\n\r\n\t\treturn readBuffer;\r\n\t}","id":106532,"modified_method":"public ReadBuffer decode( byte in[], int offset, int length ) throws DecodingException {\r\n\t\tbyte[] out = new byte[length];\r\n\t\tint written = 0;\r\n\t\tint end = offset + length;\r\n\t\tif( end > in.length )\r\n\t\t\tthrow new DecodingException( \"Index out of bound.\" );\r\n\t\tboolean linebreak = false;\r\n\t\tboolean lastCharWasQuoted = false;\r\n\t\tint lastSkip = 0;\r\n\t\twhile( length-- > 0 ) {\r\n\t\t\tbyte c = in[offset++];\r\n\t\t\tif( c == '=' ) {\r\n\t\t\t\tif( length > 0 ) {\r\n\t\t\t\t\tif( in[offset] == '?' ) {\r\n\t\t\t\t\t\t// System.err.println( \"=? found at \" + ( offset -1 ) );\r\n\t\t\t\t\t\tint f1 = offset;\r\n\t\t\t\t\t\tint f2 = f1 + 1;\r\n\t\t\t\t\t\t// FIXME save charset here ticket #508\r\n\t\t\t\t\t\tfor( ; f2 < end && in[f2] != '?'; f2++ );\r\n\t\t\t\t\t\tif( f2 < end ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * 2nd question mark found\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t// System.err.println( \"2nd ? found at \" + f2 );\r\n\t\t\t\t\t\t\tint f3 = f2 + 1;\r\n\t\t\t\t\t\t\tfor( ; f3 < end && in[f3] != '?'; f3++ );\r\n\t\t\t\t\t\t\tif( f3 < end ) {\r\n\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t * 3rd question mark found\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// System.err.println( \"3rd ? found at \" + f3 );\r\n\t\t\t\t\t\t\t\tint f4 = f3 + 1;\r\n\t\t\t\t\t\t\t\tfor( ; f4 < end && in[f4] != '?'; f4++ );\r\n\t\t\t\t\t\t\t\tif( f4 < end - 1 && in[f4+1] == '=' ) {\r\n\t\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t\t * 4th question mark found, we are complete, so lets start\r\n\t\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t\tString enc = ( in[f2+1] == 'Q' || in[f2+1] == 'q' ) ? \"quoted-printable\" : ( ( in[f2+1] == 'B' || in[f2+1] == 'b' ) ? \"base64\" : null );\r\n\t\t\t\t\t\t\t\t\t// System.err.println( \"4th ? found at \" + f4 + \", encoding=\" + enc );\r\n\t\t\t\t\t\t\t\t\tif( enc != null ) {\r\n\t\t\t\t\t\t\t\t\t\tEncoding e = EncodingFactory.getEncoding( enc );\r\n\t\t\t\t\t\t\t\t\t\tif( e != null ) {\r\n\t\t\t\t\t\t\t\t\t\t\t// System.err.println( \"encoder found\" );\r\n\t\t\t\t\t\t\t\t\t\t\tReadBuffer tmp = null;\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// System.err.println( \"decode(\" + (f3 + 1) + \",\" + ( f4 - f3 - 1 ) + \")\" );\r\n\t\t\t\t\t\t\t\t\t\t\t\ttmp = e.decode( in, f3 + 1, f4 - f3 - 1 );\r\n\t\t\t\t\t\t\t\t\t\t\t\t// get charset\r\n\t\t\t\t\t\t\t\t\t\t\t\tString charset = new String(in, f1 + 1, f2 - f1 - 1, \"ISO-8859-1\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tString clc = charset.toLowerCase(Locale.US);\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (clc.equals(\"utf-8\") || clc.equals(\"utf8\")) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor( int j = 0; j < tmp.length; j++ ) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbyte d = tmp.content[ tmp.offset + j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout[written++] = ( d == '_' ? 32 : d );\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// decode string\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tString decoded = new String(tmp.content, tmp.offset, tmp.length, charset);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// encode string\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbyte[] utf8 = decoded.getBytes(\"UTF-8\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor( int j = 0; j < utf8.length; j++ ) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbyte d = utf8[j];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout[written++] = ( d == '_' ? 32 : d );\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tint distance = f4 + 2 - offset;\r\n\t\t\t\t\t\t\t\t\t\t\t\toffset += distance;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlength -= distance;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlastCharWasQuoted = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t\t} catch (Exception e1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tDebug.debug(Debug.ERROR, e1.toString());\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( c == '\\r' ) {\r\n\t\t\t\tif( length > 0 && in[offset] == '\\n' ) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * delay linebreak in case of long line\r\n\t\t\t\t\t */\r\n\t\t\t\t\tlinebreak = true;\r\n\t\t\t\t\tlength--;\r\n\t\t\t\t\toffset++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( linebreak ) {\r\n\t\t\t\tlinebreak = false;\r\n\t\t\t\tif( c != ' ' && c != '\\t' ) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * new line does not start with whitespace, so its not a new part of a\r\n\t\t\t\t\t * long line\r\n\t\t\t\t\t */\r\n\t\t\t\t\tout[written++] = '\\r';\r\n\t\t\t\t\tout[written++] = '\\n';\r\n\t\t\t\t\tlastSkip = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif( !lastCharWasQuoted )\r\n\t\t\t\t\t\tout[written++] = ' ';\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * skip whitespace\r\n\t\t\t\t\t */\r\n\t\t\t\t\tint skipped = 1;\r\n\t\t\t\t\twhile( length > 0 && ( in[offset] == ' ' || in[offset] == '\\t' ) ) {\r\n\t\t\t\t\t\tif( lastSkip > 0 && skipped >= lastSkip ) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toffset++;\r\n\t\t\t\t\t\tlength--;\r\n\t\t\t\t\t\tskipped++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif( lastSkip == 0 && skipped > 0 ) {\r\n\t\t\t\t\t\tlastSkip = skipped;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * print out everything else literally\r\n\t\t\t */\r\n\t\t\tout[written++] = c;\r\n\t\t\tlastCharWasQuoted = false;\r\n\t\t}\r\n\t\tif( linebreak ) {\r\n\t\t\tout[written++] = '\\r';\r\n\t\t\tout[written++] = '\\n';\r\n\t\t\tlastSkip = 0;\r\n\t\t}\r\n\t\t\t\r\n\t\tReadBuffer readBuffer = new ReadBuffer();\r\n\t\treadBuffer.content = out;\r\n\t\treadBuffer.offset = 0;\r\n\t\treadBuffer.length = written;\r\n\r\n\t\treturn readBuffer;\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void parseHeaders()\n\t{\n\t\tDateFormat dateFormatter = new SimpleDateFormat( Config.getProperty( DATEFORMAT, \"mm/dd/yyyy HH:mm:ss\" ) );\n\t\tDateFormat mailDateFormatter = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH );\n\t\t\n\t\terror = \"\";\n\t\tif( header != null ) {\n\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tEncoding html = EncodingFactory.getEncoding( \"HTML\" );\n\t\t\t\n\t\t\tif( html == null ) {\n\t\t\t\terror += \"HTML encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\t\n\t\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\n\n\t\t\tif( hl == null ) {\n\t\t\t\terror += \"Header line encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif( ok ) {\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tReadBuffer decoded = hl.decode( header );\n\t\t\t\t\tBufferedReader reader = new BufferedReader( new InputStreamReader( new ByteArrayInputStream( decoded.content, decoded.offset, decoded.length ), \"UTF-8\" ) );\n\t\t\t\t\tString line;\n\t\t\t\t\twhile( ( line = reader.readLine() ) != null ) {\n\t\t\t\t\t\tif( line.length() == 0 )\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif( line.startsWith( \"From:\" ) ) {\n\t\t\t\t\t\t\tsender = line.substring( 5 ).trim();\n\t\t\t\t\t\t\tformattedSender = getAddress( sender );\n\t\t\t\t\t\t\tshortSender = formattedSender.trim();\n\t\t\t\t\t\t\tif( shortSender.length() > 40 ) {\n\t\t\t\t\t\t\t\tshortSender = shortSender.substring( 0, 37 ).trim() + \"...\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshortSender = html.encode( shortSender );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Date:\" ) ) {\n\t\t\t\t\t\t\tdateString = line.substring( 5 ).trim();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdate = mailDateFormatter.parse( dateString );\n\t\t\t\t\t\t\t\tformattedDate = dateFormatter.format( date );\n\t\t\t\t\t\t\t\tquotedDate = html.encode( dateString );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (ParseException e) {\n\t\t\t\t\t\t\t\tdate = null;\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Subject:\" ) ) {\n\t\t\t\t\t\t\tsubject = line.substring( 8 ).trim();\n\t\t\t\t\t\t\tformattedSubject = subject;\n\t\t\t\t\t\t\tshortSubject = formattedSubject;\n\t\t\t\t\t\t\tif( formattedSubject.length() > 60 )\n\t\t\t\t\t\t\t\tshortSubject = formattedSubject.substring( 0, 57 ).trim() + \"...\";\n\t\t\t\t\t\t\tshortSubject = html.encode( shortSubject );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.toLowerCase(Locale.US).startsWith( \"reply-to:\" ) ) {\n\t\t\t\t\t\t\treply = Mail.getAddress( line.substring( 9 ).trim() );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"To:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tMail.getRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tto = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Cc:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tMail.getRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tcc = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch( Exception e ) {\n\t\t\t\t\terror += \"Error parsing mail header: \" + e.getClass().getName() + \"<br>\";\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}","id":106533,"modified_method":"public void parseHeaders()\n\t{\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-mm-dd HH:mm\");\n\t\tDateFormat localDateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\n\t\tDateFormat longLocalDateFormatter = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);\n\t\t// the router sets the JVM time zone to UTC but saves the original here so we can get it\n\t\tString systemTimeZone = I2PAppContext.getGlobalContext().getProperty(\"i2p.systemTimeZone\");\n\t\tif (systemTimeZone != null) {\n\t\t\tTimeZone tz = TimeZone.getTimeZone(systemTimeZone);\n\t\t\tlocalDateFormatter.setTimeZone(tz);\n\t\t\tlongLocalDateFormatter.setTimeZone(tz);\n\t\t}\n\t\tDateFormat mailDateFormatter = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH );\n\t\t\n\t\terror = \"\";\n\t\tif( header != null ) {\n\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tEncoding html = EncodingFactory.getEncoding( \"HTML\" );\n\t\t\t\n\t\t\tif( html == null ) {\n\t\t\t\terror += \"HTML encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\t\n\t\t\tEncoding hl = EncodingFactory.getEncoding( \"HEADERLINE\" );\n\n\t\t\tif( hl == null ) {\n\t\t\t\terror += \"Header line encoder not found.<br>\";\n\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif( ok ) {\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tReadBuffer decoded = hl.decode( header );\n\t\t\t\t\tBufferedReader reader = new BufferedReader( new InputStreamReader( new ByteArrayInputStream( decoded.content, decoded.offset, decoded.length ), \"UTF-8\" ) );\n\t\t\t\t\tString line;\n\t\t\t\t\twhile( ( line = reader.readLine() ) != null ) {\n\t\t\t\t\t\tif( line.length() == 0 )\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif( line.startsWith( \"From:\" ) ) {\n\t\t\t\t\t\t\tsender = line.substring( 5 ).trim();\n\t\t\t\t\t\t\tformattedSender = getAddress( sender );\n\t\t\t\t\t\t\tshortSender = formattedSender.trim();\n\t\t\t\t\t\t\tif( shortSender.length() > 40 ) {\n\t\t\t\t\t\t\t\tshortSender = shortSender.substring( 0, 37 ).trim() + \"...\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshortSender = html.encode( shortSender );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Date:\" ) ) {\n\t\t\t\t\t\t\tdateString = line.substring( 5 ).trim();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdate = mailDateFormatter.parse( dateString );\n\t\t\t\t\t\t\t\tformattedDate = dateFormatter.format( date );\n\t\t\t\t\t\t\t\tlocalFormattedDate = localDateFormatter.format( date );\n\t\t\t\t\t\t\t\t//quotedDate = html.encode( dateString );\n\t\t\t\t\t\t\t\tquotedDate = longLocalDateFormatter.format(date);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (ParseException e) {\n\t\t\t\t\t\t\t\tdate = null;\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Subject:\" ) ) {\n\t\t\t\t\t\t\tsubject = line.substring( 8 ).trim();\n\t\t\t\t\t\t\tformattedSubject = subject;\n\t\t\t\t\t\t\tshortSubject = formattedSubject;\n\t\t\t\t\t\t\tif( formattedSubject.length() > 60 )\n\t\t\t\t\t\t\t\tshortSubject = formattedSubject.substring( 0, 57 ).trim() + \"...\";\n\t\t\t\t\t\t\tshortSubject = html.encode( shortSubject );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.toLowerCase(Locale.US).startsWith( \"reply-to:\" ) ) {\n\t\t\t\t\t\t\treply = getAddress( line.substring( 9 ).trim() );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"To:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tto = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( line.startsWith( \"Cc:\" ) ) {\n\t\t\t\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\t\t\t\tgetRecipientsFromList( list, line.substring( 3 ).trim(), true );\n\t\t\t\t\t\t\tcc = list.toArray();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch( Exception e ) {\n\t\t\t\t\terror += \"Error parsing mail header: \" + e.getClass().getName() + \"<br>\";\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Mail() {\n\t\tformattedSender = unknown;\n\t\tformattedSubject = unknown;\n\t\tformattedDate = unknown;\n\t\tshortSender = unknown;\n\t\tshortSubject = unknown;\n\t\tquotedDate = unknown;\n\t\terror = \"\";\n\t}","id":106534,"modified_method":"public Mail() {\n\t\tformattedSender = unknown;\n\t\tformattedSubject = unknown;\n\t\tformattedDate = unknown;\n\t\tlocalFormattedDate = unknown;\n\t\tshortSender = unknown;\n\t\tshortSubject = unknown;\n\t\tquotedDate = unknown;\n\t\terror = \"\";\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public SMTPClient()\r\n\t{\r\n\t\tsocket = null;\r\n\t\tbuffer = new byte[10240];\r\n\t\terror = \"\";\r\n\t\tlastResponse = \"\";\r\n\t}","id":106535,"modified_method":"public SMTPClient()\r\n\t{\r\n\t\tbuffer = new byte[10240];\r\n\t\terror = \"\";\r\n\t\tlastResponse = \"\";\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param httpRequest\r\n\t * @param response\r\n\t * @throws IOException\r\n\t * @throws ServletException\r\n\t */\r\n\tprivate void processRequest( HttpServletRequest httpRequest, HttpServletResponse response )\r\n\tthrows IOException, ServletException\r\n\t{\r\n\t\tString theme = Config.getProperty(CONFIG_THEME, DEFAULT_THEME);\r\n\t\tI2PAppContext ctx = I2PAppContext.getGlobalContext();\r\n\t\tboolean universalTheming = ctx.getBooleanProperty(RC_PROP_UNIVERSAL_THEMING);\r\n\t\tif (universalTheming) {\r\n\t\t\t// Fetch routerconsole theme (or use our default if it doesn't exist)\r\n\t\t\ttheme = ctx.getProperty(RC_PROP_THEME, DEFAULT_THEME);\r\n\t\t\t// Ensure that theme exists\r\n\t\t\tString[] themes = getThemes();\r\n\t\t\tboolean themeExists = false;\r\n\t\t\tfor (int i = 0; i < themes.length; i++) {\r\n\t\t\t\tif (themes[i].equals(theme))\r\n\t\t\t\t\tthemeExists = true;\r\n\t\t\t}\r\n\t\t\tif (!themeExists) {\r\n\t\t\t\ttheme = DEFAULT_THEME;\r\n\t\t\t}\r\n\t\t}\r\n\t\tboolean forceMobileConsole = ctx.getBooleanProperty(RC_PROP_FORCE_MOBILE_CONSOLE);\r\n\t\tboolean isMobile = (forceMobileConsole || isMobile(httpRequest.getHeader(\"User-Agent\")));\r\n\r\n\t\thttpRequest.setCharacterEncoding(\"UTF-8\");\r\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\r\n                response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\r\n\t\tRequestWrapper request = new RequestWrapper( httpRequest );\r\n\t\t\r\n\t\tSessionObject sessionObject = null;\r\n\t\t\r\n\t\tString subtitle = \"\";\r\n\t\t\r\n\t\tHttpSession httpSession = request.getSession( true );\r\n\t\t\r\n\t\tsessionObject = getSessionObject( httpSession );\r\n\r\n\t\tsynchronized( sessionObject ) {\r\n\t\t\t\r\n\t\t\tsessionObject.error = \"\";\r\n\t\t\tsessionObject.info = \"\";\r\n\t\t\tsessionObject.pageChanged = false;\r\n\t\t\tsessionObject.showAttachment = null;\r\n\t\t\tsessionObject.themePath = \"/themes/susimail/\" + theme + '/';\r\n\t\t\tsessionObject.imgPath = sessionObject.themePath + \"images/\";\r\n\t\t\tsessionObject.isMobile = isMobile;\r\n\t\t\t\r\n\t\t\tprocessStateChangeButtons( sessionObject, request );\r\n\t\t\t\r\n\t\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\t\tprocessGenericButtons( sessionObject, request );\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\tprocessFolderButtons( sessionObject, request );\r\n\t\t\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\t\t\tString uidl = (String)it.next();\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\t\t\tif( mail != null && mail.error.length() > 0 ) {\r\n\t\t\t\t\t\tsessionObject.error += mail.error;\r\n\t\t\t\t\t\tmail.error = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\t\tprocessMessageButtons( sessionObject, request );\r\n\t\t\t\t// If the last message has just been deleted then\r\n\t\t\t\t// sessionObject.state = STATE_LIST and\r\n\t\t\t\t// sessionObject.showUIDL = null\r\n\t\t\t\tif ( sessionObject.showUIDL != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail != null && mail.error.length() > 0 ) {\r\n\t\t\t\t\t\tsessionObject.error += mail.error;\r\n\t\t\t\t\t\tmail.error = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_NEW )\r\n\t\t\t\tprocessComposeButtons( sessionObject, request );\r\n\t\t\r\n\t\t\t/*\r\n\t\t\t * update folder content\r\n\t\t\t */\r\n\t\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\r\n\t\t\tif( ! sendAttachment( sessionObject, response ) ) { \r\n\t\t\t\tPrintWriter out = response.getWriter();\r\n\t\t\t\t\r\n\t\t\t\t/*\r\n\t\t\t\t * build subtitle\r\n\t\t\t\t */\r\n\t\t\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\t\t\tsubtitle = _(\"Login\");\r\n\t\t\t\telse if( sessionObject.state == STATE_LIST )\r\n\t\t\t\t\tsubtitle = ngettext(\"1 Message\", \"{0} Messages\", sessionObject.mailbox.getNumMails());\r\n\t\t\t\telse if( sessionObject.state == STATE_SHOW )\r\n\t\t\t\t\tsubtitle = _(\"Show Message\");\r\n\r\n\t\t\t\tresponse.setContentType( \"text/html\" );\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * write header\r\n\t\t\t\t */\r\n\t\t\t\tout.println( \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n<html>\\n\" +\r\n\t\t\t\t\t\"<head>\\n\" +\r\n\t\t\t\t\t\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\" +\r\n\t\t\t\t\t\"<title>susimail - \" + subtitle + \"<\/title>\\n\" +\r\n\t\t\t\t\t\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + sessionObject.themePath + \"susimail.css\\\">\\n\" );\r\n\t\t\t\tif (sessionObject.isMobile ) {\r\n\t\t\t\t\tout.println( \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes\\\" />\\n\" +\r\n\t\t\t\t\t\t\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + sessionObject.themePath + \"mobile.css\\\" />\\n\" );\r\n\t\t\t\t}\r\n\t\t\t\tout.println( \"<\/head>\\n<body>\\n\" +\r\n\t\t\t\t\t\"<div class=\\\"page\\\"><p><img src=\\\"\" + sessionObject.imgPath + \"susimail.png\\\" alt=\\\"Susimail\\\"><br>&nbsp;<\/p>\\n\" +\r\n\t\t\t\t\t\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" action=\\\"\" + myself + \"\\\" accept-charset=\\\"UTF-8\\\">\" );\r\n\r\n\t\t\t\tif( sessionObject.error != null && sessionObject.error.length() > 0 ) {\r\n\t\t\t\t\tout.println( \"<p class=\\\"error\\\">\" + sessionObject.error + \"<\/p>\" );\r\n\t\t\t\t}\r\n\t\t\t\tif( sessionObject.info != null && sessionObject.info.length() > 0 ) {\r\n\t\t\t\t\tout.println( \"<p class=\\\"info\\\">\" + sessionObject.info + \"<\/p>\" );\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t * now write body\r\n\t\t\t\t */\r\n\t\t\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\t\t\tshowLogin( out );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_LIST )\r\n\t\t\t\t\tshowFolder( out, sessionObject, request );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_SHOW )\r\n\t\t\t\t\tshowMessage( out, sessionObject );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_NEW )\r\n\t\t\t\t\tshowCompose( out, sessionObject, request );\r\n\t\t\t\t\r\n\t\t\t\tout.println( \"<\/form><div id=\\\"footer\\\"><hr><p class=\\\"footer\\\">susimail v0.\" + version +\" \" + ( RELEASE ? \"release\" : \"development\" ) + \" &copy; 2004-2005 <a href=\\\"mailto:susi23@mail.i2p\\\">susi<\/a><\/div><\/div><\/body>\\n<\/html>\");\t\t\t\t\r\n\t\t\t\tout.flush();\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":106536,"modified_method":"/**\r\n\t * \r\n\t * @param httpRequest\r\n\t * @param response\r\n\t * @throws IOException\r\n\t * @throws ServletException\r\n\t */\r\n\tprivate void processRequest( HttpServletRequest httpRequest, HttpServletResponse response )\r\n\tthrows IOException, ServletException\r\n\t{\r\n\t\tString theme = Config.getProperty(CONFIG_THEME, DEFAULT_THEME);\r\n\t\tI2PAppContext ctx = I2PAppContext.getGlobalContext();\r\n\t\tboolean universalTheming = ctx.getBooleanProperty(RC_PROP_UNIVERSAL_THEMING);\r\n\t\tif (universalTheming) {\r\n\t\t\t// Fetch routerconsole theme (or use our default if it doesn't exist)\r\n\t\t\ttheme = ctx.getProperty(RC_PROP_THEME, DEFAULT_THEME);\r\n\t\t\t// Ensure that theme exists\r\n\t\t\tString[] themes = getThemes();\r\n\t\t\tboolean themeExists = false;\r\n\t\t\tfor (int i = 0; i < themes.length; i++) {\r\n\t\t\t\tif (themes[i].equals(theme))\r\n\t\t\t\t\tthemeExists = true;\r\n\t\t\t}\r\n\t\t\tif (!themeExists) {\r\n\t\t\t\ttheme = DEFAULT_THEME;\r\n\t\t\t}\r\n\t\t}\r\n\t\tboolean forceMobileConsole = ctx.getBooleanProperty(RC_PROP_FORCE_MOBILE_CONSOLE);\r\n\t\tboolean isMobile = (forceMobileConsole || isMobile(httpRequest.getHeader(\"User-Agent\")));\r\n\r\n\t\thttpRequest.setCharacterEncoding(\"UTF-8\");\r\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\r\n                response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\r\n\t\tRequestWrapper request = new RequestWrapper( httpRequest );\r\n\t\t\r\n\t\tSessionObject sessionObject = null;\r\n\t\t\r\n\t\tString subtitle = \"\";\r\n\t\t\r\n\t\tHttpSession httpSession = request.getSession( true );\r\n\t\t\r\n\t\tsessionObject = getSessionObject( httpSession );\r\n\r\n\t\tsynchronized( sessionObject ) {\r\n\t\t\t\r\n\t\t\tsessionObject.error = \"\";\r\n\t\t\tsessionObject.info = \"\";\r\n\t\t\tsessionObject.pageChanged = false;\r\n\t\t\tsessionObject.showAttachment = null;\r\n\t\t\tsessionObject.themePath = \"/themes/susimail/\" + theme + '/';\r\n\t\t\tsessionObject.imgPath = sessionObject.themePath + \"images/\";\r\n\t\t\tsessionObject.isMobile = isMobile;\r\n\t\t\t\r\n\t\t\tprocessStateChangeButtons( sessionObject, request );\r\n\t\t\t\r\n\t\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\t\tprocessGenericButtons( sessionObject, request );\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\tprocessFolderButtons( sessionObject, request );\r\n\t\t\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\t\t\tString uidl = it.next();\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\t\t\tif( mail != null && mail.error.length() > 0 ) {\r\n\t\t\t\t\t\tsessionObject.error += mail.error;\r\n\t\t\t\t\t\tmail.error = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\t\tprocessMessageButtons( sessionObject, request );\r\n\t\t\t\t// If the last message has just been deleted then\r\n\t\t\t\t// sessionObject.state = STATE_LIST and\r\n\t\t\t\t// sessionObject.showUIDL = null\r\n\t\t\t\tif ( sessionObject.showUIDL != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail != null && mail.error.length() > 0 ) {\r\n\t\t\t\t\t\tsessionObject.error += mail.error;\r\n\t\t\t\t\t\tmail.error = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( sessionObject.state == STATE_NEW )\r\n\t\t\t\tprocessComposeButtons( sessionObject, request );\r\n\t\t\r\n\t\t\t/*\r\n\t\t\t * update folder content\r\n\t\t\t */\r\n\t\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\t\tsessionObject.folder.setElements( sessionObject.mailbox.getUIDLs() );\r\n\r\n\t\t\tif( ! sendAttachment( sessionObject, response ) ) { \r\n\t\t\t\tPrintWriter out = response.getWriter();\r\n\t\t\t\t\r\n\t\t\t\t/*\r\n\t\t\t\t * build subtitle\r\n\t\t\t\t */\r\n\t\t\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\t\t\tsubtitle = _(\"Login\");\r\n\t\t\t\telse if( sessionObject.state == STATE_LIST )\r\n\t\t\t\t\tsubtitle = ngettext(\"1 Message\", \"{0} Messages\", sessionObject.mailbox.getNumMails());\r\n\t\t\t\telse if( sessionObject.state == STATE_SHOW )\r\n\t\t\t\t\tsubtitle = _(\"Show Message\");\r\n\r\n\t\t\t\tresponse.setContentType( \"text/html\" );\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * write header\r\n\t\t\t\t */\r\n\t\t\t\tout.println( \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n<html>\\n\" +\r\n\t\t\t\t\t\"<head>\\n\" +\r\n\t\t\t\t\t\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\" +\r\n\t\t\t\t\t\"<title>susimail - \" + subtitle + \"<\/title>\\n\" +\r\n\t\t\t\t\t\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + sessionObject.themePath + \"susimail.css\\\">\\n\" );\r\n\t\t\t\tif (sessionObject.isMobile ) {\r\n\t\t\t\t\tout.println( \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes\\\" />\\n\" +\r\n\t\t\t\t\t\t\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + sessionObject.themePath + \"mobile.css\\\" />\\n\" );\r\n\t\t\t\t}\r\n\t\t\t\tout.println( \"<\/head>\\n<body>\\n\" +\r\n\t\t\t\t\t\"<div class=\\\"page\\\"><p><img src=\\\"\" + sessionObject.imgPath + \"susimail.png\\\" alt=\\\"Susimail\\\"><br>&nbsp;<\/p>\\n\" +\r\n\t\t\t\t\t\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" action=\\\"\" + myself + \"\\\" accept-charset=\\\"UTF-8\\\">\" );\r\n\r\n\t\t\t\tif( sessionObject.error != null && sessionObject.error.length() > 0 ) {\r\n\t\t\t\t\tout.println( \"<p class=\\\"error\\\">\" + sessionObject.error + \"<\/p>\" );\r\n\t\t\t\t}\r\n\t\t\t\tif( sessionObject.info != null && sessionObject.info.length() > 0 ) {\r\n\t\t\t\t\tout.println( \"<p class=\\\"info\\\">\" + sessionObject.info + \"<\/p>\" );\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t * now write body\r\n\t\t\t\t */\r\n\t\t\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\t\t\tshowLogin( out );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_LIST )\r\n\t\t\t\t\tshowFolder( out, sessionObject, request );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_SHOW )\r\n\t\t\t\t\tshowMessage( out, sessionObject );\r\n\t\t\t\t\r\n\t\t\t\telse if( sessionObject.state == STATE_NEW )\r\n\t\t\t\t\tshowCompose( out, sessionObject, request );\r\n\t\t\t\t\r\n\t\t\t\tout.println( \"<\/form><div id=\\\"footer\\\"><hr><p class=\\\"footer\\\">susimail v0.\" + version +\" \" + ( RELEASE ? \"release\" : \"development\" ) + \" &copy; 2004-2005 <a href=\\\"mailto:susi23@mail.i2p\\\">susi<\/a><\/div><\/div><\/body>\\n<\/html>\");\t\t\t\t\r\n\t\t\t\tout.flush();\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showCompose( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tout.println( button( SEND, _(\"Send\") ) +\r\n\t\t\t\tbutton( CANCEL, _(\"Cancel\") ) + spacer +\r\n\t\t\t\t(sessionObject.attachments != null && (!sessionObject.attachments.isEmpty()) ? button( DELETE_ATTACHMENT, _(\"Delete Attachment\") ) : button2( DELETE_ATTACHMENT, _(\"Delete Attachment\") ) ) + spacer +\r\n\t\t\t\tbutton( RELOAD, _(\"Reload Config\") ) + spacer +\r\n\t\t\t\tbutton( LOGOUT, _(\"Logout\") ) );\r\n\r\n\t\tString from = request.getParameter( NEW_FROM );\r\n\t\tString fixed = Config.getProperty( CONFIG_SENDER_FIXED, \"true\" );\r\n\t\t\r\n\t\tif( from == null || fixed.compareToIgnoreCase( \"false\" ) != 0 ) {\r\n\t\t\t\tString domain = Config.getProperty( CONFIG_SENDER_DOMAIN, \"mail.i2p\" );\r\n\t\t\t\tfrom = \"<\" + sessionObject.user + \"@\" + domain + \">\";\r\n\t\t}\r\n\t\t\r\n\t\tString to = request.getParameter( NEW_TO, sessionObject.replyTo != null ? sessionObject.replyTo : \"\" );\r\n\t\tString cc = request.getParameter( NEW_CC, sessionObject.replyCC != null ? sessionObject.replyCC : \"\" );\r\n\t\tString bcc = request.getParameter( NEW_BCC, \"\" );\r\n\t\tString subject = request.getParameter( NEW_SUBJECT, sessionObject.subject != null ? sessionObject.subject : \"\" );\r\n\t\tString text = request.getParameter( NEW_TEXT, sessionObject.body != null ? sessionObject.body : \"\" );\r\n\t\tString bccToSelf = Config.getProperty( CONFIG_BCC_TO_SELF, \"true\" );\r\n\t\tsessionObject.replyTo = null;\r\n\t\tsessionObject.replyCC = null;\r\n\t\tsessionObject.subject = null;\r\n\t\tsessionObject.body = null;\r\n\t\t\r\n\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"From:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_FROM + \"\\\" value=\\\"\" + from + \"\\\" \" + ( fixed.compareToIgnoreCase( \"false\" ) != 0 ? \"disabled\" : \"\" ) +\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"To:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_TO + \"\\\" value=\\\"\" + to + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Cc:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_CC + \"\\\" value=\\\"\" + cc + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Bcc:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_BCC + \"\\\" value=\\\"\" + bcc + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Subject:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_SUBJECT + \"\\\" value=\\\"\" + subject + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td>&nbsp;<\/td><td align=\\\"left\\\"><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"\" + NEW_BCC_TO_SELF + \"\\\" value=\\\"1\\\"\" + ( bccToSelf.compareToIgnoreCase( \"false\" ) != 0 ? \"checked\" : \"\" )+ \">\" + _(\"Bcc to self\") + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><textarea cols=\\\"\" + Config.getProperty( CONFIG_COMPOSER_COLS, 80 )+ \"\\\" rows=\\\"\" + Config.getProperty( CONFIG_COMPOSER_ROWS, 10 )+ \"\\\" name=\\\"\" + NEW_TEXT + \"\\\">\" + text + \"<\/textarea>\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"New Attachment:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"file\\\" size=\\\"50%\\\" name=\\\"\" + NEW_FILENAME + \"\\\" value=\\\"\\\"><input type=\\\"submit\\\" name=\\\"\" + NEW_UPLOAD + \"\\\" value=\\\"\" + _(\"Upload File\") + \"\\\"><\/td><\/tr>\" );\r\n\t\t\r\n\t\tif( sessionObject.attachments != null && !sessionObject.attachments.isEmpty() ) {\r\n\t\t\tboolean wroteHeader = false;\r\n\t\t\tfor( Attachment attachment : sessionObject.attachments ) {\r\n\t\t\t\tif( !wroteHeader ) {\r\n\t\t\t\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\">\" + _(\"Attachments:\") + \"<\/td><\/tr>\" );\r\n\t\t\t\t\twroteHeader = true;\r\n\t\t\t\t}\r\n\t\t\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + attachment.hashCode() + \"\\\" value=\\\"1\\\">&nbsp;\" + attachment.getFileName() + \"<\/td><\/tr>\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tout.println( \"<\/table>\" );\r\n\t}","id":106537,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showCompose( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tout.println( button( SEND, _(\"Send\") ) +\r\n\t\t\t\tbutton( CANCEL, _(\"Cancel\") ) + spacer +\r\n\t\t\t\t(sessionObject.attachments != null && (!sessionObject.attachments.isEmpty()) ? button( DELETE_ATTACHMENT, _(\"Delete Attachment\") ) : button2( DELETE_ATTACHMENT, _(\"Delete Attachment\") ) ) + spacer);\r\n\t\tif (Config.hasConfigFile())\r\n\t\t\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\tout.println(button( LOGOUT, _(\"Logout\") ) );\r\n\r\n\t\tString from = request.getParameter( NEW_FROM );\r\n\t\tString fixed = Config.getProperty( CONFIG_SENDER_FIXED, \"true\" );\r\n\t\t\r\n\t\tif( from == null || fixed.compareToIgnoreCase( \"false\" ) != 0 ) {\r\n\t\t\t\tString domain = Config.getProperty( CONFIG_SENDER_DOMAIN, \"mail.i2p\" );\r\n\t\t\t\tfrom = \"<\" + sessionObject.user + \"@\" + domain + \">\";\r\n\t\t}\r\n\t\t\r\n\t\tString to = request.getParameter( NEW_TO, sessionObject.replyTo != null ? sessionObject.replyTo : \"\" );\r\n\t\tString cc = request.getParameter( NEW_CC, sessionObject.replyCC != null ? sessionObject.replyCC : \"\" );\r\n\t\tString bcc = request.getParameter( NEW_BCC, \"\" );\r\n\t\tString subject = request.getParameter( NEW_SUBJECT, sessionObject.subject != null ? sessionObject.subject : \"\" );\r\n\t\tString text = request.getParameter( NEW_TEXT, sessionObject.body != null ? sessionObject.body : \"\" );\r\n\t\tString bccToSelf = Config.getProperty( CONFIG_BCC_TO_SELF, \"true\" );\r\n\t\tsessionObject.replyTo = null;\r\n\t\tsessionObject.replyCC = null;\r\n\t\tsessionObject.subject = null;\r\n\t\tsessionObject.body = null;\r\n\t\t\r\n\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"From:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_FROM + \"\\\" value=\\\"\" + from + \"\\\" \" + ( fixed.compareToIgnoreCase( \"false\" ) != 0 ? \"disabled\" : \"\" ) +\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"To:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_TO + \"\\\" value=\\\"\" + to + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Cc:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_CC + \"\\\" value=\\\"\" + cc + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Bcc:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_BCC + \"\\\" value=\\\"\" + bcc + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"Subject:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"text\\\" size=\\\"80\\\" name=\\\"\" + NEW_SUBJECT + \"\\\" value=\\\"\" + subject + \"\\\"><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td>&nbsp;<\/td><td align=\\\"left\\\"><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"\" + NEW_BCC_TO_SELF + \"\\\" value=\\\"1\\\"\" + ( bccToSelf.compareToIgnoreCase( \"false\" ) != 0 ? \"checked\" : \"\" )+ \">\" + _(\"Bcc to self\") + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><textarea cols=\\\"\" + Config.getProperty( CONFIG_COMPOSER_COLS, 80 )+ \"\\\" rows=\\\"\" + Config.getProperty( CONFIG_COMPOSER_ROWS, 10 )+ \"\\\" name=\\\"\" + NEW_TEXT + \"\\\">\" + text + \"<\/textarea>\" +\r\n\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\"<tr><td align=\\\"right\\\">\" + _(\"New Attachment:\") + \"<\/td><td align=\\\"left\\\"><input type=\\\"file\\\" size=\\\"50%\\\" name=\\\"\" + NEW_FILENAME + \"\\\" value=\\\"\\\"><input type=\\\"submit\\\" name=\\\"\" + NEW_UPLOAD + \"\\\" value=\\\"\" + _(\"Upload File\") + \"\\\"><\/td><\/tr>\" );\r\n\t\t\r\n\t\tif( sessionObject.attachments != null && !sessionObject.attachments.isEmpty() ) {\r\n\t\t\tboolean wroteHeader = false;\r\n\t\t\tfor( Attachment attachment : sessionObject.attachments ) {\r\n\t\t\t\tif( !wroteHeader ) {\r\n\t\t\t\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\">\" + _(\"Attachments:\") + \"<\/td><\/tr>\" );\r\n\t\t\t\t\twroteHeader = true;\r\n\t\t\t\t}\r\n\t\t\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + attachment.hashCode() + \"\\\" value=\\\"1\\\">&nbsp;\" + attachment.getFileName() + \"<\/td><\/tr>\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tout.println( \"<\/table>\" );\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showFolder( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete the marked messages?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete them!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\tbutton( REFRESH, _(\"Check Mail\") ) + spacer +\r\n\t\t\tbutton( RELOAD, _(\"Reload Config\") ) + spacer +\r\n\t\t\tbutton( LOGOUT, _(\"Logout\") ) + \"<table id=\\\"mailbox\\\" cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<tr>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SENDER, _(\"Sender\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SUBJECT, _(\"Subject\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_DATE, _(\"Date\"), sessionObject.imgPath ) + sortHeader( SORT_ID, \"\", sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SIZE, _(\"Size\"), sessionObject.imgPath ) + \"<\/th><\/tr>\" );\r\n\t\tint bg = 0;\r\n\t\tint i = 0;\r\n\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\tString uidl = (String)it.next();\r\n\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\tString link = \"<a href=\\\"\" + myself + \"?\" + SHOW + \"=\" + i + \"\\\">\";\r\n\t\t\t\r\n\t\t\tboolean idChecked = false;\r\n\t\t\tString checkId = sessionObject.pageChanged ? null : (String)request.getParameter( \"check\" + i );\r\n\t\t\t\r\n\t\t\tif( checkId != null && checkId.compareTo( \"1\" ) == 0 )\r\n\t\t\t\tidChecked = true;\r\n\t\t\t\r\n\t\t\tif( sessionObject.markAll )\r\n\t\t\t\tidChecked = true;\r\n\t\t\tif( sessionObject.invert )\r\n\t\t\t\tidChecked = !idChecked;\r\n\t\t\tif( sessionObject.clear )\r\n\t\t\t\tidChecked = false;\r\n\r\n\t\t\tDebug.debug( Debug.DEBUG, \"check\" + i + \": checkId=\" + checkId + \", idChecked=\" + idChecked + \", pageChanged=\" + sessionObject.pageChanged +\r\n\t\t\t\t\t\", markAll=\" + sessionObject.markAll +\r\n\t\t\t\t\t\", invert=\" + sessionObject.invert +\r\n\t\t\t\t\t\", clear=\" + sessionObject.clear );\r\n\t\t\tout.println( \"<tr class=\\\"list\" + bg + \"\\\"><td><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + i + \"\\\" value=\\\"1\\\"\" + \r\n\t\t\t\t\t( idChecked ? \"checked\" : \"\" ) + \">\" + ( RELEASE ? \"\" : \"\" + i ) + \"<\/td><td>\" + link + mail.shortSender + \"<\/a><\/td><td>&nbsp;<\/td><td>\" + link + mail.shortSubject + \"<\/a><\/td><td>&nbsp;<\/td><td>\" + mail.formattedDate + \"<\/td><td>&nbsp;<\/td><td>\" + ngettext(\"1 Byte\", \"{0} Bytes\", mail.size) + \"<\/td><\/tr>\" );\r\n\t\t\tbg = 1 - bg;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<\/table>\" +\r\n\t\t\t\tbutton( MARKALL, _(\"Mark All\") ) +\r\n\t\t\t\tbutton( INVERT, _(\"Invert Selection\") ) +\r\n\t\t\t\tbutton( CLEAR, _(\"Clear\") ) +\r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t( sessionObject.folder.isFirstPage() ?\r\n\t\t\t\t\t\t\t\t\t\t button2( FIRSTPAGE, _(\"First\") ) + button2( PREVPAGE, _(\"Previous\") ) :\r\n \t\t\t\t\t\t\t\t\t\t button( FIRSTPAGE, _(\"First\") ) + button( PREVPAGE, _(\"Previous\") ) ) +\r\n\t\t\t\t\" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + _(\"Page {0} of {1}\", sessionObject.folder.getCurrentPage(), sessionObject.folder.getPages()) + \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" +\r\n\t\t\t\t( sessionObject.folder.isLastPage() ? \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button2( NEXTPAGE, _(\"Next\") ) + button2( LASTPAGE, _(\"Last\") ) :\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button( NEXTPAGE, _(\"Next\") ) + button( LASTPAGE, _(\"Last\") ) ) +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t_(\"Pagesize:\") + \"&nbsp;<input type=\\\"text\\\" name=\\\"\" + PAGESIZE + \"\\\" size=\\\"4\\\" value=\\\"\" +  sessionObject.folder.getPageSize() + \"\\\">\" +\r\n\t\t\t\tbutton( SETPAGESIZE, _(\"Set\") ) );\r\n\t}","id":106538,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void showFolder( PrintWriter out, SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete the marked messages?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete them!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\tbutton( REFRESH, _(\"Check Mail\") ) + spacer);\r\n\t\tif (Config.hasConfigFile())\r\n\t\t\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\tout.println(button( LOGOUT, _(\"Logout\") ) + \"<table id=\\\"mailbox\\\" cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<tr>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SENDER, _(\"Sender\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SUBJECT, _(\"Subject\"), sessionObject.imgPath ) + \"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_DATE, _(\"Date\"), sessionObject.imgPath ) +\r\n\t\t\t//sortHeader( SORT_ID, \"\", sessionObject.imgPath ) +\r\n\t\t\t\"<\/th>\" +\r\n\t\t\tthSpacer + \"<th>\" + sortHeader( SORT_SIZE, _(\"Size\"), sessionObject.imgPath ) + \"<\/th><\/tr>\" );\r\n\t\tint bg = 0;\r\n\t\tint i = 0;\r\n\t\tfor( Iterator<String> it = sessionObject.folder.currentPageIterator(); it != null && it.hasNext(); ) {\r\n\t\t\tString uidl = it.next();\r\n\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_HEADER );\r\n\t\t\tString link = \"<a href=\\\"\" + myself + \"?\" + SHOW + \"=\" + i + \"\\\">\";\r\n\t\t\t\r\n\t\t\tboolean idChecked = false;\r\n\t\t\tString checkId = sessionObject.pageChanged ? null : (String)request.getParameter( \"check\" + i );\r\n\t\t\t\r\n\t\t\tif( checkId != null && checkId.compareTo( \"1\" ) == 0 )\r\n\t\t\t\tidChecked = true;\r\n\t\t\t\r\n\t\t\tif( sessionObject.markAll )\r\n\t\t\t\tidChecked = true;\r\n\t\t\tif( sessionObject.invert )\r\n\t\t\t\tidChecked = !idChecked;\r\n\t\t\tif( sessionObject.clear )\r\n\t\t\t\tidChecked = false;\r\n\r\n\t\t\tDebug.debug( Debug.DEBUG, \"check\" + i + \": checkId=\" + checkId + \", idChecked=\" + idChecked + \", pageChanged=\" + sessionObject.pageChanged +\r\n\t\t\t\t\t\", markAll=\" + sessionObject.markAll +\r\n\t\t\t\t\t\", invert=\" + sessionObject.invert +\r\n\t\t\t\t\t\", clear=\" + sessionObject.clear );\r\n\t\t\tout.println( \"<tr class=\\\"list\" + bg + \"\\\"><td><input type=\\\"checkbox\\\" class=\\\"optbox\\\" name=\\\"check\" + i + \"\\\" value=\\\"1\\\"\" + \r\n\t\t\t\t\t( idChecked ? \"checked\" : \"\" ) + \">\" + ( RELEASE ? \"\" : \"\" + i ) + \"<\/td><td>\" +\r\n\t\t\t\t\tlink + mail.shortSender + \"<\/a><\/td><td>&nbsp;<\/td><td>\" + link + mail.shortSubject + \"<\/a><\/td><td>&nbsp;<\/td><td>\" +\r\n\t\t\t\t\t mail.localFormattedDate + \"<\/td><td>&nbsp;<\/td><td>\" + ngettext(\"1 Byte\", \"{0} Bytes\", mail.size) + \"<\/td><\/tr>\" );\r\n\t\t\tbg = 1 - bg;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"8\\\"><hr><\/td><\/tr>\\n<\/table>\" +\r\n\t\t\t\tbutton( MARKALL, _(\"Mark All\") ) +\r\n\t\t\t\tbutton( INVERT, _(\"Invert Selection\") ) +\r\n\t\t\t\tbutton( CLEAR, _(\"Clear\") ) +\r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t( sessionObject.folder.isFirstPage() ?\r\n\t\t\t\t\t\t\t\t\t\t button2( FIRSTPAGE, _(\"First\") ) + button2( PREVPAGE, _(\"Previous\") ) :\r\n \t\t\t\t\t\t\t\t\t\t button( FIRSTPAGE, _(\"First\") ) + button( PREVPAGE, _(\"Previous\") ) ) +\r\n\t\t\t\t\" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + _(\"Page {0} of {1}\", sessionObject.folder.getCurrentPage(), sessionObject.folder.getPages()) + \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" +\r\n\t\t\t\t( sessionObject.folder.isLastPage() ? \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button2( NEXTPAGE, _(\"Next\") ) + button2( LASTPAGE, _(\"Last\") ) :\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   button( NEXTPAGE, _(\"Next\") ) + button( LASTPAGE, _(\"Last\") ) ) +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n\t\t\t\t\"<br>\" +\r\n\t\t\t\t_(\"Pagesize:\") + \"&nbsp;<input type=\\\"text\\\" name=\\\"\" + PAGESIZE + \"\\\" size=\\\"4\\\" value=\\\"\" +  sessionObject.folder.getPageSize() + \"\\\">\" +\r\n\t\t\t\tbutton( SETPAGESIZE, _(\"Set\") ) );\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\tif( mail != null && mail.body != null && mail.part == null ) {\r\n\t\t\tmail.part = new MailPart();\r\n\t\t\tmail.part.parse( mail.body );\r\n\t\t}\r\n\t\tif( !RELEASE ) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tout.println( quoteHTML( new String( mail.body.content, mail.body.offset, mail.body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer +\r\n\t\t\tbutton( RELOAD, _(\"Reload Config\") ) + spacer +\r\n\t\t\tbutton( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\">\" + _(\"From:\") + \"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\">\" + _(\"Date:\") + \"<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\">\" + _(\"Subject:\") + \"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.body != null ) {\r\n\t\t\t\tshowPart( out, mail.part, 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","id":106539,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FETCH_ALL );\r\n\t\tif( mail != null && mail.body != null && mail.part == null ) {\r\n\t\t\tmail.part = new MailPart();\r\n\t\t\tmail.part.parse( mail.body );\r\n\t\t}\r\n\t\tif( !RELEASE ) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tout.println( quoteHTML( new String( mail.body.content, mail.body.offset, mail.body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer);\r\n\t\tif (Config.hasConfigFile())\r\n\t\t\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\tout.println(button( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"From:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.sender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Date:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Subject:\") +\r\n\t\t\t\t\t\"<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.body != null ) {\r\n\t\t\t\tshowPart( out, mail.part, 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * returns a html string of the label and two imaged links using the parameter name\r\n\t * (used for sorting buttons in folder view)\r\n\t * \r\n\t * @param name\r\n\t * @param label\r\n\t * @return the string\r\n\t */\r\n\tprivate static String sortHeader( String name, String label, String imgPath )\r\n\t{\r\n\t\treturn \"\" + label + \"&nbsp;<a href=\\\"\" + myself + \"?\" + name + \"=up\\\"><img src=\\\"\" + imgPath + \"3up.png\\\" border=\\\"0\\\" alt=\\\"^\\\"><\/a><a href=\\\"\" + myself + \"?\" + name + \"=down\\\"><img src=\\\"\" + imgPath + \"3down.png\\\" border=\\\"0\\\" alt=\\\"v\\\"><\/a>\";\r\n\t}","id":106540,"modified_method":"/**\r\n\t * returns a html string of the label and two imaged links using the parameter name\r\n\t * (used for sorting buttons in folder view)\r\n\t * \r\n\t * @param name\r\n\t * @param label\r\n\t * @return the string\r\n\t */\r\n\tprivate static String sortHeader( String name, String label, String imgPath )\r\n\t{\r\n\t\treturn label + \"&nbsp;<a href=\\\"\" + myself + \"?\" + name + \"=up\\\"><img src=\\\"\" +\r\n\t\t\timgPath + \"3up.png\\\" border=\\\"0\\\" alt=\\\"^\\\"><\/a><a href=\\\"\" + myself +\r\n\t\t\t\"?\" + name + \"=down\\\"><img src=\\\"\" + imgPath + \"3down.png\\\" border=\\\"0\\\" alt=\\\"v\\\"><\/a>\";\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * Process all buttons, which possibly change internal state.\r\n\t * \r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processStateChangeButtons(SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\t/*\r\n\t\t * LOGIN/LOGOUT\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\tprocessLogin( sessionObject, request );\r\n\r\n\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\tprocessLogout( sessionObject, request );\r\n\r\n\t\t/*\r\n\t\t *  compose dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_NEW ) {\r\n\t\t\tif( buttonPressed( request, CANCEL ) )\r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\r\n\t\t\telse if( buttonPressed( request, SEND ) )\r\n\t\t\t\tif( sendMail( sessionObject, request ) )\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t}\r\n\t\t/*\r\n\t\t * message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\tif( buttonPressed( request, LIST ) ) { \r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * buttons on both folder and message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW || sessionObject.state == STATE_LIST ) {\r\n\t\t\tif( buttonPressed( request, NEW ) ) {\r\n\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tboolean reply = false;\r\n\t\t\tboolean replyAll = false;\r\n\t\t\tboolean forward = false;\r\n\t\t\tsessionObject.replyTo = null;\r\n\t\t\tsessionObject.replyCC = null;\r\n\t\t\tsessionObject.body = null;\r\n\t\t\tsessionObject.subject = null;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLY ) )\r\n\t\t\t\treply = true;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLYALL ) ) {\r\n\t\t\t\treplyAll = true;\r\n\t\t\t}\r\n\t\t\tif( buttonPressed( request, FORWARD ) ) {\r\n\t\t\t\tforward = true;\r\n\t\t\t}\r\n\t\t\tif( reply || replyAll || forward ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * try to find message\r\n\t\t\t\t */\r\n\t\t\t\tString uidl = null;\r\n\t\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\t\tint pos = getCheckedMessage( request );\r\n\t\t\t\t\tuidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( pos );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tuidl = sessionObject.showUIDL;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail.part == null ) {\r\n\t\t\t\t\t\tmail.part = new MailPart();\r\n\t\t\t\t\t\tmail.part.parse( mail.body );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * extract original sender from Reply-To: or From:\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif( mail.part != null ) {\r\n\t\t\t\t\t\tif( reply || replyAll ) {\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\tsessionObject.subject = \"Re: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println( _(\"On {0} {1} wrote:\", mail.formattedDate, sessionObject.replyTo) );\r\n\t\t\t\t\t\t\tStringWriter text2 = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw2 = new PrintWriter( text2 );\r\n\t\t\t\t\t\t\tshowPart( pw2, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw2.flush();\r\n\t\t\t\t\t\t\tString[] lines = text2.toString().split( \"\\r\\n\" );\r\n\t\t\t\t\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\t\t\t\t\tpw.println( \"> \" + lines[i] );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( replyAll ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * extract additional recipients\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tStringBuilder buf = new StringBuilder();\r\n\t\t\t\t\t\t\tString pad = \"\";\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( buf.length() > 0 )\r\n\t\t\t\t\t\t\t\tsessionObject.replyCC = buf.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( forward ) {\r\n\t\t\t\t\t\t\tsessionObject.subject = \"FWD: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tString sender = null;\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println( \"---- \" + _(\"begin forwarded mail\") + \" ----\" );\r\n\t\t\t\t\t\t\tpw.println( \"From: \" + sender );\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"To: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"Cc: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.dateString != null )\r\n\t\t\t\t\t\t\t\tpw.print( \"Date: \" + mail.dateString );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tshowPart( pw, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw.println( \"----  \" + _(\"end forwarded mail\") + \"  ----\" );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsessionObject.error += _(\"Could not fetch mail body.\") + \"<br>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * folder view\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_LIST || sessionObject.state == STATE_SHOW) {\r\n\t\t\t/*\r\n\t\t\t * check if user wants to view a message\r\n\t\t\t */\r\n\t\t\tString show = request.getParameter( SHOW );\r\n\t\t\tif( show != null && show.length() > 0 ) {\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tint id = Integer.parseInt( show );\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( id >= 0 && id < sessionObject.folder.getPageSize() ) {\r\n\t\t\t\t\t\tString uidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( id );\r\n\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\tsessionObject.state = STATE_SHOW;\r\n\t\t\t\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch( NumberFormatException nfe )\r\n\t\t\t\t{\r\n\t\t\t\t\tsessionObject.error += _(\"Message id not valid.\") + \"<br>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":106541,"modified_method":"/**\r\n\t * Process all buttons, which possibly change internal state.\r\n\t * \r\n\t * @param sessionObject\r\n\t * @param request\r\n\t */\r\n\tprivate static void processStateChangeButtons(SessionObject sessionObject, RequestWrapper request )\r\n\t{\r\n\t\t/*\r\n\t\t * LOGIN/LOGOUT\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_AUTH )\r\n\t\t\tprocessLogin( sessionObject, request );\r\n\r\n\t\tif( sessionObject.state != STATE_AUTH )\r\n\t\t\tprocessLogout( sessionObject, request );\r\n\r\n\t\t/*\r\n\t\t *  compose dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_NEW ) {\r\n\t\t\tif( buttonPressed( request, CANCEL ) )\r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\r\n\t\t\telse if( buttonPressed( request, SEND ) )\r\n\t\t\t\tif( sendMail( sessionObject, request ) )\r\n\t\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t}\r\n\t\t/*\r\n\t\t * message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW ) {\r\n\t\t\tif( buttonPressed( request, LIST ) ) { \r\n\t\t\t\tsessionObject.state = STATE_LIST;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * buttons on both folder and message dialog\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_SHOW || sessionObject.state == STATE_LIST ) {\r\n\t\t\tif( buttonPressed( request, NEW ) ) {\r\n\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tboolean reply = false;\r\n\t\t\tboolean replyAll = false;\r\n\t\t\tboolean forward = false;\r\n\t\t\tsessionObject.replyTo = null;\r\n\t\t\tsessionObject.replyCC = null;\r\n\t\t\tsessionObject.body = null;\r\n\t\t\tsessionObject.subject = null;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLY ) )\r\n\t\t\t\treply = true;\r\n\t\t\t\r\n\t\t\tif( buttonPressed( request, REPLYALL ) ) {\r\n\t\t\t\treplyAll = true;\r\n\t\t\t}\r\n\t\t\tif( buttonPressed( request, FORWARD ) ) {\r\n\t\t\t\tforward = true;\r\n\t\t\t}\r\n\t\t\tif( reply || replyAll || forward ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * try to find message\r\n\t\t\t\t */\r\n\t\t\t\tString uidl = null;\r\n\t\t\t\tif( sessionObject.state == STATE_LIST ) {\r\n\t\t\t\t\tint pos = getCheckedMessage( request );\r\n\t\t\t\t\tuidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( pos );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tuidl = sessionObject.showUIDL;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\tMail mail = sessionObject.mailCache.getMail( uidl, MailCache.FETCH_ALL );\r\n\t\t\t\t\tif( mail.part == null ) {\r\n\t\t\t\t\t\tmail.part = new MailPart();\r\n\t\t\t\t\t\tmail.part.parse( mail.body );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * extract original sender from Reply-To: or From:\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif( mail.part != null ) {\r\n\t\t\t\t\t\tif( reply || replyAll ) {\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsessionObject.replyTo = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\tsessionObject.subject = \"Re: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println( _(\"On {0} {1} wrote:\", mail.formattedDate + \" UTC\", sessionObject.replyTo) );\r\n\t\t\t\t\t\t\tStringWriter text2 = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw2 = new PrintWriter( text2 );\r\n\t\t\t\t\t\t\tshowPart( pw2, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw2.flush();\r\n\t\t\t\t\t\t\tString[] lines = text2.toString().split( \"\\r\\n\" );\r\n\t\t\t\t\t\t\tfor( int i = 0; i < lines.length; i++ )\r\n\t\t\t\t\t\t\t\tpw.println( \"> \" + lines[i] );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( replyAll ) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * extract additional recipients\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tStringBuilder buf = new StringBuilder();\r\n\t\t\t\t\t\t\tString pad = \"\";\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tbuf.append( pad );\r\n\t\t\t\t\t\t\t\t\tbuf.append( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \", \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( buf.length() > 0 )\r\n\t\t\t\t\t\t\t\tsessionObject.replyCC = buf.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( forward ) {\r\n\t\t\t\t\t\t\tsessionObject.subject = \"FWD: \" + mail.formattedSubject;\r\n\t\t\t\t\t\t\tString sender = null;\r\n\t\t\t\t\t\t\tif( mail.reply != null && Mail.validateAddress( mail.reply ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.reply );\r\n\t\t\t\t\t\t\telse if( mail.sender != null && Mail.validateAddress( mail.sender ) )\r\n\t\t\t\t\t\t\t\tsender = Mail.getAddress( mail.sender );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tStringWriter text = new StringWriter();\r\n\t\t\t\t\t\t\tPrintWriter pw = new PrintWriter( text );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tpw.println( \"---- \" + _(\"begin forwarded mail\") + \" ----\" );\r\n\t\t\t\t\t\t\tpw.println( \"From: \" + sender );\r\n\t\t\t\t\t\t\tif( mail.to != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"To: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.to.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.to[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.cc != null ) {\r\n\t\t\t\t\t\t\t\tString pad = \"Cc: \";\r\n\t\t\t\t\t\t\t\tfor( int i = 0; i < mail.cc.length; i++ ) {\r\n\t\t\t\t\t\t\t\t\tpw.println( pad );\r\n\t\t\t\t\t\t\t\t\tpw.println( (String)mail.cc[i] );\r\n\t\t\t\t\t\t\t\t\tpad = \"    \";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( mail.dateString != null )\r\n\t\t\t\t\t\t\t\tpw.print( \"Date: \" + mail.dateString );\r\n\t\t\t\t\t\t\tpw.println();\r\n\t\t\t\t\t\t\tshowPart( pw, mail.part, 0, TEXT_ONLY );\r\n\t\t\t\t\t\t\tpw.println( \"----  \" + _(\"end forwarded mail\") + \"  ----\" );\r\n\t\t\t\t\t\t\tpw.flush();\r\n\t\t\t\t\t\t\tsessionObject.body = text.toString();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsessionObject.state = STATE_NEW;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tsessionObject.error += _(\"Could not fetch mail body.\") + \"<br>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t * folder view\r\n\t\t */\r\n\t\tif( sessionObject.state == STATE_LIST || sessionObject.state == STATE_SHOW) {\r\n\t\t\t/*\r\n\t\t\t * check if user wants to view a message\r\n\t\t\t */\r\n\t\t\tString show = request.getParameter( SHOW );\r\n\t\t\tif( show != null && show.length() > 0 ) {\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tint id = Integer.parseInt( show );\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( id >= 0 && id < sessionObject.folder.getPageSize() ) {\r\n\t\t\t\t\t\tString uidl = (String)sessionObject.folder.getElementAtPosXonCurrentPage( id );\r\n\t\t\t\t\t\tif( uidl != null ) {\r\n\t\t\t\t\t\t\tsessionObject.state = STATE_SHOW;\r\n\t\t\t\t\t\t\tsessionObject.showUIDL = uidl;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch( NumberFormatException nfe )\r\n\t\t\t\t{\r\n\t\t\t\t\tsessionObject.error += _(\"Message id not valid.\") + \"<br>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"028776de880b8196d32b0d9324d32e3ea64299c7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Mark mail for deletion locally.\n\t * Send delete requests to POP3 then quit and reconnect.\n\t * No success/failure indication is returned.\n\t * \n\t * @since 0.9.13\n\t */\n\tpublic void delete(Collection<String> uidls) {\n\t\tList<String> toDelete = new ArrayList<String>(uidls.size());\n\t\tfor (String uidl : uidls) {\n\t\t\tif (disk != null)\n\t\t\t\tdisk.deleteMail(uidl);\n\t\t\tMail mail = mails.get(uidl);\n\t\t\tif (mail == null)\n\t\t\t\tcontinue;\n\t\t\tmail.markForDeletion = true;\n\t\t\ttoDelete.add(uidl);\n\t\t}\n\t\tif (toDelete.isEmpty())\n\t\t\treturn;\n\t\tmailbox.queueForDeletion(toDelete);\n\t}","id":106542,"modified_method":"/**\n\t * Mark mail for deletion locally.\n\t * Send delete requests to POP3 then quit and reconnect.\n\t * No success/failure indication is returned.\n\t * \n\t * @since 0.9.13\n\t */\n\tpublic void delete(Collection<String> uidls) {\n\t\tList<String> toDelete = new ArrayList<String>(uidls.size());\n\t\tfor (String uidl : uidls) {\n\t\t\tif (disk != null)\n\t\t\t\tdisk.deleteMail(uidl);\n\t\t\tsynchronized(mails) {\n\t\t\t\tMail mail = mails.get(uidl);\n\t\t\t\tif (mail == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tmail.markForDeletion = true;\n\t\t\t\t// now replace it with an empty one to save memory\n\t\t\t\tmail = new Mail(uidl);\n\t\t\t\tmail.markForDeletion = true;\n\t\t\t\tmails.put(uidl, mail);\n\t\t\t}\n\t\t\ttoDelete.add(uidl);\n\t\t}\n\t\tif (toDelete.isEmpty())\n\t\t\treturn;\n\t\tmailbox.queueForDeletion(toDelete);\n\t}","commit_id":"738bae46d237259adc207e71a86430eb5e887ff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FetchMode.ALL );\r\n\t\tif(!RELEASE && mail != null && mail.hasBody()) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\tout.println( \"Debug: Mail header and body follow\");\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tReadBuffer body = mail.getBody();\r\n\t\t\tout.println( quoteHTML( new String(body.content, body.offset, body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println(\"<div class=\\\"topbuttons\\\">\");\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer +\r\n\t\t\tbutton( DELETE, _(\"Delete\") ) + spacer +\r\n\t\t\t\"<br>\" +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ));\r\n\t\tout.println(\"<\/div>\");\r\n\t\t//if (Config.hasConfigFile())\r\n\t\t//\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\t//out.println(button( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"From\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.sender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Subject\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Date\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.hasPart()) {\r\n\t\t\t\tmail.setNew(false);\r\n\t\t\t\tshowPart( out, mail.getPart(), 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","id":106543,"modified_method":"/**\r\n\t * \r\n\t * @param out\r\n\t * @param sessionObject\r\n\t */\r\n\tprivate static void showMessage( PrintWriter out, SessionObject sessionObject )\r\n\t{\r\n\t\tif( sessionObject.reallyDelete ) {\r\n\t\t\tout.println( \"<p class=\\\"error\\\">\" + _(\"Really delete this message?\") + \" \" + button( REALLYDELETE, _(\"Yes, really delete it!\") ) + \"<\/p>\" );\r\n\t\t}\r\n\t\tMail mail = sessionObject.mailCache.getMail( sessionObject.showUIDL, MailCache.FetchMode.ALL );\r\n\t\tif(!RELEASE && mail != null && mail.hasBody()) {\r\n\t\t\tout.println( \"<!--\" );\r\n\t\t\tout.println( \"Debug: Mail header and body follow\");\r\n\t\t\t// FIXME encoding, escaping --, etc... but disabled.\r\n\t\t\tReadBuffer body = mail.getBody();\r\n\t\t\tout.println( quoteHTML( new String(body.content, body.offset, body.length ) ) );\r\n\t\t\tout.println( \"-->\" );\r\n\t\t}\r\n\t\tout.println(\"<div class=\\\"topbuttons\\\">\");\r\n\t\tout.println( button( NEW, _(\"New\") ) + spacer +\r\n\t\t\tbutton( REPLY, _(\"Reply\") ) +\r\n\t\t\tbutton( REPLYALL, _(\"Reply All\") ) +\r\n\t\t\tbutton( FORWARD, _(\"Forward\") ) + spacer);\r\n\t\tif (sessionObject.reallyDelete)\r\n\t\t\tout.println(button2(DELETE, _(\"Delete\")));\r\n\t\telse\r\n\t\t\tout.println(button(DELETE, _(\"Delete\")));\r\n\t\tout.println(\"<br>\" +\r\n\t\t\t( sessionObject.folder.isFirstElement( sessionObject.showUIDL ) ? button2( PREV, _(\"Previous\") ) : button( PREV, _(\"Previous\") ) ) + spacer +\r\n\t\t\tbutton( LIST, _(\"Back to Folder\") ) + spacer +\r\n\t\t\t( sessionObject.folder.isLastElement( sessionObject.showUIDL ) ? button2( NEXT, _(\"Next\") ) : button( NEXT, _(\"Next\") ) ));\r\n\t\tout.println(\"<\/div>\");\r\n\t\t//if (Config.hasConfigFile())\r\n\t\t//\tout.println(button( RELOAD, _(\"Reload Config\") ) + spacer);\r\n\t\t//out.println(button( LOGOUT, _(\"Logout\") ) );\r\n\t\tif( mail != null ) {\r\n\t\t\tout.println( \"<table cellspacing=\\\"0\\\" cellpadding=\\\"5\\\">\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"From\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.sender ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Subject\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + quoteHTML( mail.formattedSubject ) + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr class=\\\"mailhead\\\"><td align=\\\"right\\\" valign=\\\"top\\\">\" + _(\"Date\") +\r\n\t\t\t\t\t\":<\/td><td align=\\\"left\\\">\" + mail.quotedDate + \"<\/td><\/tr>\\n\" +\r\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\" );\r\n\t\t\tif( mail.hasPart()) {\r\n\t\t\t\tmail.setNew(false);\r\n\t\t\t\tshowPart( out, mail.getPart(), 0, SHOW_HTML );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail body.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout.println( \"<tr class=\\\"mailbody\\\"><td colspan=\\\"2\\\" align=\\\"center\\\"><p class=\\\"error\\\">\" + _(\"Could not fetch mail.\") + \"<\/p><\/td><\/tr>\" );\r\n\t\t}\r\n\t\tout.println( \"<tr><td colspan=\\\"2\\\" align=\\\"center\\\"><hr><\/td><\/tr>\\n<\/table>\" );\r\n\t}","commit_id":"738bae46d237259adc207e71a86430eb5e887ff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void doInitialise() throws InitialisationException {\n\n        try {\n            Object component = create();\n            proxy = new DefaultMuleProxy(component, descriptor, null);\n            proxy.setStatistics(getStatistics());\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","id":106544,"modified_method":"protected void doInitialise() throws InitialisationException {\n\n        try {\n            Object component = createComponent();\n            proxy = new DefaultMuleProxy(component, descriptor, null);\n            proxy.setStatistics(getStatistics());\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doInitialise() throws InitialisationException {\n\n        super.doInitialise();\n        Object component = null;\n        try {\n            component = create();\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n        if (component instanceof Callable) {\n            callable = (Callable) component;\n        } else {\n            throw new InitialisationException(new Message(Messages.OBJECT_X_NOT_OF_CORRECT_TYPE_SHOULD_BE_X,\n                    component.getClass().getName(), Callable.class.getName()), this);\n        }\n\n        if (component instanceof Initialisable) {\n            ((Initialisable) component).initialise();\n        }\n\n\n    }","id":106545,"modified_method":"public void doInitialise() throws InitialisationException {\n\n        super.doInitialise();\n        Object component = null;\n        try {\n            component = createComponent();\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n        if (component instanceof Callable) {\n            callable = (Callable) component;\n        } else {\n            throw new InitialisationException(new Message(Messages.OBJECT_X_NOT_OF_CORRECT_TYPE_SHOULD_BE_X,\n                    component.getClass().getName(), Callable.class.getName()), this);\n        }\n\n        if (component instanceof Initialisable) {\n            ((Initialisable) component).initialise();\n        }\n\n\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage doSend(UMOEvent event) throws UMOException {\n\n        UMOMessage result = null;\n        MuleProxy proxy = null;\n        try {\n            proxy = (MuleProxy) proxyPool.borrowObject();\n            getStatistics().setComponentPoolSize(proxyPool.getSize());\n            proxy.setStatistics(getStatistics());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(this + \" : got proxy for \" + event.getId() + \" = \" + proxy);\n            }\n            result = (UMOMessage) proxy.onCall(event);\n        } catch (UMOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ComponentException(event.getMessage(), this, e);\n        } finally {\n            try {\n                if (proxy != null) {\n                    proxyPool.returnObject(proxy);\n                }\n            } catch (Exception e) {\n                throw new ComponentException(event.getMessage(), this, e);\n            }\n            getStatistics().setComponentPoolSize(proxyPool.getSize());\n        }\n        return result;\n    }","id":106546,"modified_method":"public UMOMessage doSend(UMOEvent event) throws UMOException {\n\n        UMOMessage result = null;\n        MuleProxy proxy = null;\n        try {\n            if(proxyPool!=null) {\n                proxy = (MuleProxy) proxyPool.borrowObject();\n                getStatistics().setComponentPoolSize(proxyPool.getSize());\n            } else if (componentPerRequest) {\n                proxy = createComponentProxy();\n            } else {\n                proxy = componentProxy;\n            }\n\n            proxy.setStatistics(getStatistics());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(this + \" : got proxy for \" + event.getId() + \" = \" + proxy);\n            }\n            result = (UMOMessage) proxy.onCall(event);\n        } catch (UMOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ComponentException(event.getMessage(), this, e);\n        } finally {\n            try {\n                if (proxy != null && proxyPool!=null) {\n                    proxyPool.returnObject(proxy);\n                } else if (componentPerRequest) {\n                    proxy.dispose();\n                }\n            } catch (Exception e) {\n                throw new ComponentException(event.getMessage(), this, e);\n            }\n            if(proxyPool!=null) {\n                getStatistics().setComponentPoolSize(proxyPool.getSize());\n            }\n        }\n        return result;\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispose() {\n\n        try {\n            // threadPool.awaitTerminationAfterShutdown();\n            if (workManager != null) {\n                workManager.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Component Thread Pool did not close properly: \" + e);\n        }\n        try {\n            if (proxyPool != null) {\n                proxyPool.clearPool();\n            }\n        } catch (Exception e) {\n            logger.error(\"Proxy Pool did not close properly: \" + e);\n        }\n    }","id":106547,"modified_method":"public void doDispose() {\n\n        try {\n            // threadPool.awaitTerminationAfterShutdown();\n            if (workManager != null) {\n                workManager.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Component Thread Pool did not close properly: \" + e);\n        }\n        try {\n            if (proxyPool != null) {\n                proxyPool.clearPool();\n            } else if (componentProxy!=null) {\n                componentProxy.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Proxy Pool did not close properly: \" + e);\n        }\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doStop() throws UMOException {\n        workManager.stop();\n    }","id":106548,"modified_method":"public void doStop() throws UMOException {\n        workManager.stop();\n        if(proxyPool!=null) {\n            try {\n                proxyPool.stop();\n                proxyPool.clearPool();\n            } catch (Exception e) {\n                logger.error(\"Failed to stop compoent pool: \" + e.getMessage(), e);\n            }\n            poolInitialised.set(false);\n        } else if(componentProxy!=null) {\n            componentProxy.stop();\n        }\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Default constructor\n     */\n    public SedaComponent(MuleDescriptor descriptor, SedaModel model) {\n        super(descriptor, model);\n        descriptorQueueName = descriptor.getName() + \".component\";\n        queueTimeout = model.getQueueTimeout();\n    }","id":106549,"modified_method":"/**\n     * Default constructor\n     */\n    public SedaComponent(MuleDescriptor descriptor, SedaModel model) {\n        super(descriptor, model);\n        descriptorQueueName = descriptor.getName() + \".component\";\n        queueTimeout = model.getQueueTimeout();\n        enablePooling = model.isEnablePooling();\n        componentPerRequest = model.isComponentPerRequest();\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doForceStop() throws UMOException {\n        workManager.stop();\n    }","id":106550,"modified_method":"public void doForceStop() throws UMOException {\n        doStop();\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * While the component isn't stopped this runs a continuous loop checking\n     * for new events in the queue\n     */\n    public void run() {\n        MuleEvent event = null;\n        MuleProxy proxy = null;\n        QueueSession queueSession = null;\n\n        while (!stopped.get()) {\n            try {\n                // Wait if the component is paused\n                paused.whenFalse(null);\n\n                //If we're doing a draining stop, read all events from the queue\n                //before stopping\n                if (stopping.get()) {\n                    if (queueSession.getQueue(descriptor.getName() + \".component\").size() == 0) {\n                        stopping.set(false);\n                        break;\n                    }\n                }\n                event = (MuleEvent) dequeue();\n                if(event!=null) {\n                    if (stats.isEnabled()) {\n                        stats.decQueuedEvent();\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Component: \" + descriptor.getName() + \" dequeued event on: \"\n                                + event.getEndpoint().getEndpointURI());\n                    }\n\n                    proxy = (MuleProxy) proxyPool.borrowObject();\n                    getStatistics().setComponentPoolSize(proxyPool.getSize());\n                    proxy.setStatistics(getStatistics());\n                    proxy.start();\n                    proxy.onEvent(queueSession, event);\n                    workManager.scheduleWork(proxy, WorkManager.INDEFINITE, null, null);\n                }\n            } catch (Exception e) {\n                if (proxy != null) {\n                    try {\n                        proxyPool.returnObject(proxy);\n                    } catch (Exception e2) {\n                        logger.info(\"Failed to return proxy to pool\", e2);\n                    }\n                }\n\n                if (e instanceof InterruptedException) {\n                    stopping.set(false);\n                    break;\n                } else if (e instanceof NoSuchElementException) {\n                    handleException(new ComponentException(new Message(Messages.PROXY_POOL_TIMED_OUT),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else if (e instanceof UMOException) {\n                    handleException(e);\n                } else if (e instanceof WorkException) {\n                    handleException(new ComponentException(new Message(Messages.EVENT_PROCESSING_FAILED_FOR_X,\n                            descriptor.getName()),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else {\n                    handleException(new ComponentException(new Message(Messages.FAILED_TO_GET_POOLED_OBJECT),\n                            event.getMessage(),\n                            this,\n                            e));\n                }\n            } finally {\n            \tstopping.set(false);\n            }\n        }\n    }","id":106551,"modified_method":"/**\n     * While the component isn't stopped this runs a continuous loop checking\n     * for new events in the queue\n     */\n    public void run() {\n        MuleEvent event = null;\n        MuleProxy proxy = null;\n        QueueSession queueSession = null;\n\n        while (!stopped.get()) {\n            try {\n                // Wait if the component is paused\n                paused.whenFalse(null);\n\n                //If we're doing a draining stop, read all events from the queue\n                //before stopping\n                if (stopping.get()) {\n                    if (queueSession.getQueue(descriptor.getName() + \".component\").size() == 0) {\n                        stopping.set(false);\n                        break;\n                    }\n                }\n                event = (MuleEvent) dequeue();\n                if(event!=null) {\n                    if (stats.isEnabled()) {\n                        stats.decQueuedEvent();\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Component: \" + descriptor.getName() + \" dequeued event on: \"\n                                + event.getEndpoint().getEndpointURI());\n                    }\n\n                    if(proxyPool!=null) {\n                        proxy = (MuleProxy) proxyPool.borrowObject();\n                        getStatistics().setComponentPoolSize(proxyPool.getSize());\n                    } else if(componentPerRequest) {\n                        proxy = createComponentProxy();\n                    } else {\n                        proxy = componentProxy;\n                    }\n\n                    proxy.setStatistics(getStatistics());\n                    proxy.start();\n                    proxy.onEvent(queueSession, event);\n                    workManager.scheduleWork(proxy, WorkManager.INDEFINITE, null, null);\n                }\n            } catch (Exception e) {\n                if (proxy != null && proxyPool!=null) {\n                    try {\n                        proxyPool.returnObject(proxy);\n                    } catch (Exception e2) {\n                        logger.info(\"Failed to return proxy to pool\", e2);\n                    }\n                }\n\n                if (e instanceof InterruptedException) {\n                    stopping.set(false);\n                    break;\n                } else if (e instanceof NoSuchElementException) {\n                    handleException(new ComponentException(new Message(Messages.PROXY_POOL_TIMED_OUT),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else if (e instanceof UMOException) {\n                    handleException(e);\n                } else if (e instanceof WorkException) {\n                    handleException(new ComponentException(new Message(Messages.EVENT_PROCESSING_FAILED_FOR_X,\n                            descriptor.getName()),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else {\n                    handleException(new ComponentException(new Message(Messages.FAILED_TO_GET_POOLED_OBJECT),\n                            event.getMessage(),\n                            this,\n                            e));\n                }\n            } finally {\n            \tstopping.set(false);\n                if(componentPerRequest) {\n                    proxy.dispose();\n                }\n            }\n        }\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doStart() throws UMOException {\n\n        try {\n            // Need to initialise the pool only after all listerner have\n            // been\n            // registed and initialised so we need to delay until now\n            if (!poolInitialised.get()) {\n                initialisePool();\n            }\n            proxyPool.start();\n            workManager.start();\n            workManager.scheduleWork(this, WorkManager.INDEFINITE, null, null);\n        } catch (Exception e) {\n            throw new LifecycleException(new Message(Messages.FAILED_TO_START_X, \"Component: \"\n                    + descriptor.getName()), e, this);\n        }\n    }","id":106552,"modified_method":"public void doStart() throws UMOException {\n\n        try {\n            // Need to initialise the pool only after all listerner have\n            // been\n            // registed and initialised so we need to delay until now\n            if (!poolInitialised.get() && enablePooling) {\n                initialisePool();\n                proxyPool.start();\n            } else if (!componentPerRequest) {\n                componentProxy = createComponentProxy();\n            }\n            workManager.start();\n            workManager.scheduleWork(this, WorkManager.INDEFINITE, null, null);\n        } catch (Exception e) {\n            throw new LifecycleException(new Message(Messages.FAILED_TO_START_X, \"Component: \"\n                    + descriptor.getName()), e, this);\n        }\n    }","commit_id":"b51dc39a25c6aeac1181155640c6edc22afdf9ce","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testPipelineSynchronous() throws Exception {\n\n        QuickConfigurationBuilder builder = new QuickConfigurationBuilder(true);\n        builder.createStartedManager(true, \"\", getModelType());\n        builder.registerComponent(EchoComponent.class.getName(), \"component1\", \"vm://component1\", \"vm://component2\", null);\n        builder.registerComponent(EchoComponent.class.getName(), \"component2\", \"vm://component2\", \"vm://component3\", null);\n        Map props = new HashMap();\n        props.put(\"data\", \"request received by component 3\");\n        builder.registerComponent(StaticComponent.class.getName(), \"component3\", \"vm://component3\", null, props);\n\n        MuleClient client = new MuleClient();\n        List results = new ArrayList();\n        for (int i = 0; i < getNumberOfMessages(); i++) {\n            UMOMessage result = client.send(\"vm://component1\", \"test\", null);\n            assertNotNull(result);\n            results.add(result);\n        }\n\n        assertEquals(results.size(), getNumberOfMessages());\n        for (Iterator iterator = results.iterator(); iterator.hasNext();) {\n            UMOMessage umoMessage = (UMOMessage) iterator.next();\n            assertEquals(\"request received by component 3\", umoMessage.getPayloadAsString());\n        }\n    }","id":106553,"modified_method":"public void testPipelineSynchronous() throws Exception {\n\n        QuickConfigurationBuilder builder = new QuickConfigurationBuilder(true);\n        builder.createStartedManager(true, \"\", getModelType());\n        configureModel(builder.getManager().getModel());\n        builder.registerComponent(EchoComponent.class.getName(), \"component1\", \"vm://component1\", \"vm://component2\", null);\n        builder.registerComponent(EchoComponent.class.getName(), \"component2\", \"vm://component2\", \"vm://component3\", null);\n        Map props = new HashMap();\n        props.put(\"data\", \"request received by component 3\");\n        builder.registerComponent(StaticComponent.class.getName(), \"component3\", \"vm://component3\", null, props);\n\n        MuleClient client = new MuleClient();\n        List results = new ArrayList();\n        for (int i = 0; i < getNumberOfMessages(); i++) {\n            UMOMessage result = client.send(\"vm://component1\", \"test\", null);\n            assertNotNull(result);\n            results.add(result);\n        }\n\n        assertEquals(results.size(), getNumberOfMessages());\n        for (Iterator iterator = results.iterator(); iterator.hasNext();) {\n            UMOMessage umoMessage = (UMOMessage) iterator.next();\n            assertEquals(\"request received by component 3\", umoMessage.getPayloadAsString());\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doInitialise() throws InitialisationException {\n\n        try {\n            Object component = create();\n            proxy = new DefaultMuleProxy(component, descriptor, null);\n            proxy.setStatistics(getStatistics());\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","id":106554,"modified_method":"protected void doInitialise() throws InitialisationException {\n\n        try {\n            Object component = createComponent();\n            proxy = new DefaultMuleProxy(component, descriptor, null);\n            proxy.setStatistics(getStatistics());\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doInitialise() throws InitialisationException {\n\n        super.doInitialise();\n        Object component = null;\n        try {\n            component = create();\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n        if (component instanceof Callable) {\n            callable = (Callable) component;\n        } else {\n            throw new InitialisationException(new Message(Messages.OBJECT_X_NOT_OF_CORRECT_TYPE_SHOULD_BE_X,\n                    component.getClass().getName(), Callable.class.getName()), this);\n        }\n\n        if (component instanceof Initialisable) {\n            ((Initialisable) component).initialise();\n        }\n\n\n    }","id":106555,"modified_method":"public void doInitialise() throws InitialisationException {\n\n        super.doInitialise();\n        Object component = null;\n        try {\n            component = createComponent();\n        } catch (UMOException e) {\n            throw new InitialisationException(e, this);\n        }\n        if (component instanceof Callable) {\n            callable = (Callable) component;\n        } else {\n            throw new InitialisationException(new Message(Messages.OBJECT_X_NOT_OF_CORRECT_TYPE_SHOULD_BE_X,\n                    component.getClass().getName(), Callable.class.getName()), this);\n        }\n\n        if (component instanceof Initialisable) {\n            ((Initialisable) component).initialise();\n        }\n\n\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * While the component isn't stopped this runs a continuous loop checking\n     * for new events in the queue\n     */\n    public void run() {\n        MuleEvent event = null;\n        MuleProxy proxy = null;\n        QueueSession queueSession = null;\n\n        while (!stopped.get()) {\n            try {\n                // Wait if the component is paused\n                paused.whenFalse(null);\n\n                //If we're doing a draining stop, read all events from the queue\n                //before stopping\n                if (stopping.get()) {\n                    if (queueSession.getQueue(descriptor.getName() + \".component\").size() == 0) {\n                        stopping.set(false);\n                        break;\n                    }\n                }\n                event = (MuleEvent) dequeue();\n                if(event!=null) {\n                    if (stats.isEnabled()) {\n                        stats.decQueuedEvent();\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Component: \" + descriptor.getName() + \" dequeued event on: \"\n                                + event.getEndpoint().getEndpointURI());\n                    }\n\n                    proxy = (MuleProxy) proxyPool.borrowObject();\n                    getStatistics().setComponentPoolSize(proxyPool.getSize());\n                    proxy.setStatistics(getStatistics());\n                    proxy.start();\n                    proxy.onEvent(queueSession, event);\n                    workManager.scheduleWork(proxy, WorkManager.INDEFINITE, null, null);\n                }\n            } catch (Exception e) {\n                if (proxy != null) {\n                    try {\n                        proxyPool.returnObject(proxy);\n                    } catch (Exception e2) {\n                        logger.info(\"Failed to return proxy to pool\", e2);\n                    }\n                }\n\n                if (e instanceof InterruptedException) {\n                    stopping.set(false);\n                    break;\n                } else if (e instanceof NoSuchElementException) {\n                    handleException(new ComponentException(new Message(Messages.PROXY_POOL_TIMED_OUT),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else if (e instanceof UMOException) {\n                    handleException(e);\n                } else if (e instanceof WorkException) {\n                    handleException(new ComponentException(new Message(Messages.EVENT_PROCESSING_FAILED_FOR_X,\n                            descriptor.getName()),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else {\n                    handleException(new ComponentException(new Message(Messages.FAILED_TO_GET_POOLED_OBJECT),\n                            event.getMessage(),\n                            this,\n                            e));\n                }\n            } finally {\n            \tstopping.set(false);\n            }\n        }\n    }","id":106556,"modified_method":"/**\n     * While the component isn't stopped this runs a continuous loop checking\n     * for new events in the queue\n     */\n    public void run() {\n        MuleEvent event = null;\n        MuleProxy proxy = null;\n        QueueSession queueSession = null;\n\n        while (!stopped.get()) {\n            try {\n                // Wait if the component is paused\n                paused.whenFalse(null);\n\n                //If we're doing a draining stop, read all events from the queue\n                //before stopping\n                if (stopping.get()) {\n                    if (queueSession.getQueue(descriptor.getName() + \".component\").size() == 0) {\n                        stopping.set(false);\n                        break;\n                    }\n                }\n                event = (MuleEvent) dequeue();\n                if(event!=null) {\n                    if (stats.isEnabled()) {\n                        stats.decQueuedEvent();\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Component: \" + descriptor.getName() + \" dequeued event on: \"\n                                + event.getEndpoint().getEndpointURI());\n                    }\n\n                    if(proxyPool!=null) {\n                        proxy = (MuleProxy) proxyPool.borrowObject();\n                        getStatistics().setComponentPoolSize(proxyPool.getSize());\n                    } else if(componentPerRequest) {\n                        proxy = createComponentProxy();\n                    } else {\n                        proxy = componentProxy;\n                    }\n\n                    proxy.setStatistics(getStatistics());\n                    proxy.start();\n                    proxy.onEvent(queueSession, event);\n                    workManager.scheduleWork(proxy, WorkManager.INDEFINITE, null, null);\n                }\n            } catch (Exception e) {\n                if (proxy != null && proxyPool!=null) {\n                    try {\n                        proxyPool.returnObject(proxy);\n                    } catch (Exception e2) {\n                        logger.info(\"Failed to return proxy to pool\", e2);\n                    }\n                }\n\n                if (e instanceof InterruptedException) {\n                    stopping.set(false);\n                    break;\n                } else if (e instanceof NoSuchElementException) {\n                    handleException(new ComponentException(new Message(Messages.PROXY_POOL_TIMED_OUT),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else if (e instanceof UMOException) {\n                    handleException(e);\n                } else if (e instanceof WorkException) {\n                    handleException(new ComponentException(new Message(Messages.EVENT_PROCESSING_FAILED_FOR_X,\n                            descriptor.getName()),\n                            event.getMessage(),\n                            this,\n                            e));\n                } else {\n                    handleException(new ComponentException(new Message(Messages.FAILED_TO_GET_POOLED_OBJECT),\n                            event.getMessage(),\n                            this,\n                            e));\n                }\n            } finally {\n            \tstopping.set(false);\n                if(componentPerRequest) {\n                    proxy.dispose();\n                }\n            }\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doStart() throws UMOException {\n\n        try {\n            // Need to initialise the pool only after all listerner have\n            // been\n            // registed and initialised so we need to delay until now\n            if (!poolInitialised.get()) {\n                initialisePool();\n            }\n            proxyPool.start();\n            workManager.start();\n            workManager.scheduleWork(this, WorkManager.INDEFINITE, null, null);\n        } catch (Exception e) {\n            throw new LifecycleException(new Message(Messages.FAILED_TO_START_X, \"Component: \"\n                    + descriptor.getName()), e, this);\n        }\n    }","id":106557,"modified_method":"public void doStart() throws UMOException {\n\n        try {\n            // Need to initialise the pool only after all listerner have\n            // been\n            // registed and initialised so we need to delay until now\n            if (!poolInitialised.get() && enablePooling) {\n                initialisePool();\n                proxyPool.start();\n            } else if (!componentPerRequest) {\n                componentProxy = createComponentProxy();\n            }\n            workManager.start();\n            workManager.scheduleWork(this, WorkManager.INDEFINITE, null, null);\n        } catch (Exception e) {\n            throw new LifecycleException(new Message(Messages.FAILED_TO_START_X, \"Component: \"\n                    + descriptor.getName()), e, this);\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage doSend(UMOEvent event) throws UMOException {\n\n        UMOMessage result = null;\n        MuleProxy proxy = null;\n        try {\n            proxy = (MuleProxy) proxyPool.borrowObject();\n            getStatistics().setComponentPoolSize(proxyPool.getSize());\n            proxy.setStatistics(getStatistics());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(this + \" : got proxy for \" + event.getId() + \" = \" + proxy);\n            }\n            result = (UMOMessage) proxy.onCall(event);\n        } catch (UMOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ComponentException(event.getMessage(), this, e);\n        } finally {\n            try {\n                if (proxy != null) {\n                    proxyPool.returnObject(proxy);\n                }\n            } catch (Exception e) {\n                throw new ComponentException(event.getMessage(), this, e);\n            }\n            getStatistics().setComponentPoolSize(proxyPool.getSize());\n        }\n        return result;\n    }","id":106558,"modified_method":"public UMOMessage doSend(UMOEvent event) throws UMOException {\n\n        UMOMessage result = null;\n        MuleProxy proxy = null;\n        try {\n            if(proxyPool!=null) {\n                proxy = (MuleProxy) proxyPool.borrowObject();\n                getStatistics().setComponentPoolSize(proxyPool.getSize());\n            } else if (componentPerRequest) {\n                proxy = createComponentProxy();\n            } else {\n                proxy = componentProxy;\n            }\n\n            proxy.setStatistics(getStatistics());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(this + \" : got proxy for \" + event.getId() + \" = \" + proxy);\n            }\n            result = (UMOMessage) proxy.onCall(event);\n        } catch (UMOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ComponentException(event.getMessage(), this, e);\n        } finally {\n            try {\n                if (proxy != null && proxyPool!=null) {\n                    proxyPool.returnObject(proxy);\n                } else if (componentPerRequest) {\n                    proxy.dispose();\n                }\n            } catch (Exception e) {\n                throw new ComponentException(event.getMessage(), this, e);\n            }\n            if(proxyPool!=null) {\n                getStatistics().setComponentPoolSize(proxyPool.getSize());\n            }\n        }\n        return result;\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doForceStop() throws UMOException {\n        workManager.stop();\n    }","id":106559,"modified_method":"public void doForceStop() throws UMOException {\n        doStop();\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Default constructor\n     */\n    public SedaComponent(MuleDescriptor descriptor, SedaModel model) {\n        super(descriptor, model);\n        descriptorQueueName = descriptor.getName() + \".component\";\n        queueTimeout = model.getQueueTimeout();\n    }","id":106560,"modified_method":"/**\n     * Default constructor\n     */\n    public SedaComponent(MuleDescriptor descriptor, SedaModel model) {\n        super(descriptor, model);\n        descriptorQueueName = descriptor.getName() + \".component\";\n        queueTimeout = model.getQueueTimeout();\n        enablePooling = model.isEnablePooling();\n        componentPerRequest = model.isComponentPerRequest();\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doStop() throws UMOException {\n        workManager.stop();\n    }","id":106561,"modified_method":"public void doStop() throws UMOException {\n        workManager.stop();\n        if(proxyPool!=null) {\n            try {\n                proxyPool.stop();\n                proxyPool.clearPool();\n            } catch (Exception e) {\n                logger.error(\"Failed to stop compoent pool: \" + e.getMessage(), e);\n            }\n            poolInitialised.set(false);\n        } else if(componentProxy!=null) {\n            componentProxy.stop();\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispose() {\n\n        try {\n            // threadPool.awaitTerminationAfterShutdown();\n            if (workManager != null) {\n                workManager.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Component Thread Pool did not close properly: \" + e);\n        }\n        try {\n            if (proxyPool != null) {\n                proxyPool.clearPool();\n            }\n        } catch (Exception e) {\n            logger.error(\"Proxy Pool did not close properly: \" + e);\n        }\n    }","id":106562,"modified_method":"public void doDispose() {\n\n        try {\n            // threadPool.awaitTerminationAfterShutdown();\n            if (workManager != null) {\n                workManager.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Component Thread Pool did not close properly: \" + e);\n        }\n        try {\n            if (proxyPool != null) {\n                proxyPool.clearPool();\n            } else if (componentProxy!=null) {\n                componentProxy.dispose();\n            }\n        } catch (Exception e) {\n            logger.error(\"Proxy Pool did not close properly: \" + e);\n        }\n    }","commit_id":"fa93e63776acf8f114706cf2ad14044964f77c0d","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void buildConstraints() {\n        Expression constraint = null;\n        Expression constraint1 = null;\n        Expression constraint2 = null;\n        Expression constraint3 = null;\n        Expression constraint4 = null;\n        Expression constraint5 = null;\n\n        // PlayRound table 0: 0 <= C4 < 100 (max round is 100)\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"C4\",\n                                                       0L);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHAN,\n                                                       \"C4\",\n                                                       100L);\n        constraint1 = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                               constraint1,\n                                               constraint2);\n        addConstraint(\"PlayRound\", 0, constraint1);\n\n        // PlayRound table 1: 0 <= R_POT < 900 (because the max round is 100, we\n        // only add at most 9 each time)\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"R_POT\",\n                                                       0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHAN,\n                                                       \"R_POT\",\n                                                       900);\n        constraint3 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"T_ID\",\n                                                       0);\n        constraint4 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"B_ID\",\n                                                       0);\n        constraint5 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"R_ID\",\n                                                       0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3,\n                                              constraint4,\n                                              constraint5);\n        addConstraint(\"PlayRound\", 1, constraint);\n\n        // For the tables\n        addConstraint(\"T\", 0, constraint3);\n\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint3,\n                                              constraint4);\n        addConstraint(\"B\", 0, constraint);\n\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3,\n                                              constraint5);\n        addConstraint(\"R\", 0, constraint);\n    }","id":106563,"modified_method":"protected void buildConstraints() {\n        Expression constraint = null;\n\n        // PlayRound table 0: 0 <= C4 < 100 (max round is 100)\n        constraint = Verification.inRange(\"C4\", 0L, 99L);\n        addConstraint(\"PlayRound\", 0, constraint);\n\n        // PlayRound table 1: 0 <= R_POT < 900 (because the max round is 100, we\n        // only add at most 9 each time)\n        Expression r_pot = Verification.inRange(\"R_POT\", 0, 899);\n        Expression t_id = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                           \"T_ID\", 0);\n        Expression b_id = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                           \"B_ID\", 0);\n        Expression r_id = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                           \"R_ID\", 0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              r_pot, t_id, b_id, r_id);\n        addConstraint(\"PlayRound\", 1, constraint);\n\n        // For the tables\n        addConstraint(\"T\", 0, t_id);\n\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              t_id, b_id);\n        addConstraint(\"B\", 0, constraint);\n\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              r_pot, t_id, r_id);\n        addConstraint(\"R\", 0, constraint);\n    }","commit_id":"3374428f28920163cd105f1acf47e3113c7c7543","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected void buildConstraints() {\n        Expression constraint = null;\n        Expression constraint1 = null;\n        Expression constraint2 = null;\n        Expression constraint3 = null;\n        Expression constraint4 = null;\n        Expression constraint5 = null;\n\n        // Delivery (no need to check 'd_id', it's systematically generated)\n        constraint = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                      \"o_id\",\n                                                      0);\n        addConstraint(Constants.DELIVERY, 0, constraint);\n\n        // New Order table 0\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"C_DISCOUNT\",\n                                                       0.0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHANOREQUALTO,\n                                                       \"C_DISCOUNT\",\n                                                       1.0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2);\n        addConstraint(Constants.NEWORDER, 0, constraint);\n        // New Order table 1\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"w_tax\",\n                                                       0.0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHANOREQUALTO,\n                                                       \"w_tax\",\n                                                       1.0);\n        constraint3 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"d_tax\",\n                                                       0.0);\n        constraint4 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHANOREQUALTO,\n                                                       \"d_tax\",\n                                                       1.0);\n        constraint5 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHAN,\n                                                       \"total\",\n                                                       0.0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3,\n                                              constraint4,\n                                              constraint5);\n        addConstraint(Constants.NEWORDER, 1, constraint);\n        // New Order table 2\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"s_quantity\",\n                                                       0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"i_price\",\n                                                       0.0);\n        constraint3 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHAN,\n                                                       \"ol_amount\",\n                                                       0.0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3);\n        addConstraint(Constants.NEWORDER, 2, constraint);\n\n        // Order Status table 0\n        constraint = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                      \"C_ID\",\n                                                      0);\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 0, constraint);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 0, constraint);\n        // Order Status table 1\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"O_ID\",\n                                                       0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"O_CARRIER_ID\",\n                                                       0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2);\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 1, constraint);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 1, constraint);\n        // Order Status table 2\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHAN,\n                                                       \"OL_SUPPLY_W_ID\",\n                                                       (short) 0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHANOREQUALTO,\n                                                       \"OL_SUPPLY_W_ID\",\n                                                       (short) m_scaleParams.warehouses);\n        constraint3 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"OL_I_ID\",\n                                                       0);\n        constraint4 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"OL_QUANTITY\",\n                                                       0);\n        constraint5 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"OL_AMOUNT\",\n                                                       0.0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3,\n                                              constraint4,\n                                              constraint5);\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 2, constraint);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 1, constraint);\n\n        // Payment\n        constraint1 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"c_id\",\n                                                       0);\n        constraint2 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"c_credit_lim\",\n                                                       0.0);\n        constraint3 = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                       \"c_discount\",\n                                                       0.0);\n        constraint4 = Verification.compareWithConstant(ExpressionType.COMPARE_LESSTHANOREQUALTO,\n                                                       \"c_discount\",\n                                                       1.0);\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              constraint1,\n                                              constraint2,\n                                              constraint3,\n                                              constraint4);\n        addConstraint(Constants.PAYMENT_BY_ID, 2, constraint);\n        addConstraint(Constants.PAYMENT_BY_ID_C, 0, constraint);\n        addConstraint(Constants.PAYMENT_BY_NAME, 2, constraint);\n        addConstraint(Constants.PAYMENT_BY_NAME_C, 0, constraint);\n\n        // slev\n        constraint = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                      \"C1\",\n                                                      0L);\n        addConstraint(Constants.STOCK_LEVEL, 0, constraint);\n    }","id":106564,"modified_method":"protected void buildConstraints() {\n        Expression constraint = null;\n\n        // WAREHOUSE table\n        Expression w_id = Verification.inRange(\"W_ID\", (short) 1,\n                                               (short) (m_scaleParams.warehouses * 2));\n        Expression w_tax = Verification.inRange(\"W_TAX\", Constants.MIN_TAX,\n                                                Constants.MAX_TAX);\n        Expression warehouse = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                        w_id, w_tax);\n\n        // DISTRICT table\n        Expression d_id = Verification.inRange(\"D_ID\", (byte) 1,\n                                               (byte) m_scaleParams.districtsPerWarehouse);\n        Expression d_w_id = Verification.inRange(\"D_W_ID\", (short) 1,\n                                                 (short) (m_scaleParams.warehouses * 2));\n        Expression d_next_o_id = Verification.inRange(\"D_NEXT_O_ID\", 1, 10000000);\n        Expression d_tax = Verification.inRange(\"D_TAX\", Constants.MIN_TAX,\n                                                Constants.MAX_TAX);\n        Expression district = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                       d_id, d_w_id, d_next_o_id, d_tax);\n\n        // CUSTOMER table\n        Expression c_id = Verification.inRange(\"C_ID\", 1,\n                                               m_scaleParams.customersPerDistrict);\n        Expression c_d_id = Verification.inRange(\"C_D_ID\", (byte) 1,\n                                                 (byte) m_scaleParams.districtsPerWarehouse);\n        Expression c_w_id = Verification.inRange(\"C_W_ID\", (short) 1,\n                                                 (short) (m_scaleParams.warehouses * 2));\n        Expression c_discount = Verification.inRange(\"C_DISCOUNT\", Constants.MIN_DISCOUNT,\n                                                     Constants.MAX_DISCOUNT);\n        Expression c_credit =\n            Verification.conjunction(ExpressionType.CONJUNCTION_OR,\n                                     Verification.compareWithConstant(ExpressionType.COMPARE_EQUAL,\n                                                                      \"C_CREDIT\",\n                                                                      Constants.GOOD_CREDIT),\n                                     Verification.compareWithConstant(ExpressionType.COMPARE_EQUAL,\n                                                                      \"C_CREDIT\",\n                                                                      Constants.BAD_CREDIT));\n        Expression customer = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                       c_id, c_d_id, c_w_id, c_discount, c_credit);\n\n        // CUSTOMER_NAME table\n        Expression customer_name = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                            c_id, c_d_id, c_w_id);\n\n        // HISTORY table\n        Expression h_c_id = Verification.inRange(\"H_C_ID\", 1,\n                                                 m_scaleParams.customersPerDistrict);\n        Expression h_c_d_id = Verification.inRange(\"H_C_D_ID\", (byte) 1,\n                                                   (byte) m_scaleParams.districtsPerWarehouse);\n        Expression h_c_w_id = Verification.inRange(\"H_C_W_ID\", (short) 1,\n                                                   (short) (m_scaleParams.warehouses * 2));\n        Expression h_d_id = Verification.inRange(\"H_D_ID\", (byte) 1,\n                                                 (byte) m_scaleParams.districtsPerWarehouse);\n        Expression h_w_id = Verification.inRange(\"H_W_ID\", (short) 1,\n                                                 (short) (m_scaleParams.warehouses * 2));\n        Expression history = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                      h_c_id, h_c_d_id, h_c_w_id, h_d_id, h_w_id);\n\n        // NEW_ORDER table\n        Expression no_o_id = Verification.inRange(\"NO_O_ID\", 1, 10000000);\n        Expression no_d_id = Verification.inRange(\"NO_D_ID\", (byte) 1,\n                                                  (byte) m_scaleParams.districtsPerWarehouse);\n        Expression no_w_id = Verification.inRange(\"NO_W_ID\", (short) 1,\n                                                  (short) (m_scaleParams.warehouses * 2));\n        Expression new_order = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                        no_o_id, no_d_id, no_w_id);\n\n        // ORDERS table\n        Expression o_id = Verification.inRange(\"O_ID\", 1, 10000000);\n        Expression o_c_id = Verification.inRange(\"O_C_ID\", 1,\n                                                 m_scaleParams.customersPerDistrict);\n        Expression o_d_id = Verification.inRange(\"O_D_ID\", (byte) 1,\n                                                 (byte) m_scaleParams.districtsPerWarehouse);\n        Expression o_w_id = Verification.inRange(\"O_W_ID\", (short) 1,\n                                                 (short) (m_scaleParams.warehouses * 2));\n        Expression o_carrier_id =\n            Verification.conjunction(ExpressionType.CONJUNCTION_OR,\n                                     Verification.inRange(\"O_CARRIER_ID\",\n                                                          Constants.MIN_CARRIER_ID,\n                                                          Constants.MAX_CARRIER_ID),\n                                     Verification.compareWithConstant(ExpressionType.COMPARE_EQUAL,\n                                                                      \"O_CARRIER_ID\",\n                                                                      (int) Constants.NULL_CARRIER_ID));\n        Expression orders = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                     o_id, o_c_id, o_d_id, o_w_id, o_carrier_id);\n\n        // ORDER_LINE table\n        Expression ol_o_id = Verification.inRange(\"OL_O_ID\", 1, 10000000);\n        Expression ol_d_id = Verification.inRange(\"OL_D_ID\", (byte) 1,\n                                                  (byte) m_scaleParams.districtsPerWarehouse);\n        Expression ol_w_id = Verification.inRange(\"OL_W_ID\", (short) 1,\n                                                  (short) (m_scaleParams.warehouses * 2));\n        Expression ol_number = Verification.inRange(\"OL_NUMBER\", 1,\n                                                    Constants.MAX_OL_CNT);\n        Expression ol_i_id = Verification.inRange(\"OL_I_ID\", 1, m_scaleParams.items);\n        Expression ol_supply_w_id = Verification.inRange(\"OL_SUPPLY_W_ID\", (short) 1,\n                                                         (short) (m_scaleParams.warehouses * 2));\n        Expression ol_quantity = Verification.inRange(\"OL_QUANTITY\", 0,\n                                                      Constants.MAX_OL_QUANTITY);\n        Expression ol_amount = Verification.inRange(\"OL_AMOUNT\",\n                                                    0,\n                                                    Constants.MAX_PRICE * Constants.MAX_OL_QUANTITY);\n        Expression order_line = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                         ol_o_id, ol_d_id, ol_w_id, ol_number,\n                                                         ol_i_id, ol_supply_w_id, ol_quantity,\n                                                         ol_amount);\n\n        // ITEM table\n        Expression i_id = Verification.inRange(\"I_ID\", 1, m_scaleParams.items);\n        Expression i_im_id = Verification.inRange(\"I_IM_ID\", Constants.MIN_IM,\n                                                  Constants.MAX_IM);\n        Expression i_price = Verification.inRange(\"I_PRICE\", Constants.MIN_PRICE,\n                                                  Constants.MAX_PRICE);\n        Expression item = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                   i_id, i_im_id, i_price);\n\n        // STOCK table\n        Expression s_i_id = Verification.inRange(\"S_I_ID\", 1, m_scaleParams.items);\n        Expression s_w_id = Verification.inRange(\"S_W_ID\", (short) 1,\n                                                 (short) (m_scaleParams.warehouses * 2));\n        Expression s_quantity = Verification.inRange(\"S_QUANTITY\", Constants.MIN_QUANTITY,\n                                                     Constants.MAX_QUANTITY);\n        Expression stock = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                                    s_i_id, s_w_id, s_quantity);\n\n        // Delivery (no need to check 'd_id', it's systematically generated)\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              d_id, o_id);\n        addConstraint(Constants.DELIVERY, 0, constraint);\n\n        // New Order table 0\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              c_discount, c_credit);\n        addConstraint(Constants.NEWORDER, 0, constraint);\n        // New Order table 1\n        constraint =\n            Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                     d_next_o_id,\n                                     w_tax, d_tax,\n                                     Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHAN,\n                                                                      \"total\", 0.0));\n        addConstraint(Constants.NEWORDER, 1, constraint);\n        // New Order table 2\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              s_quantity,\n                                              i_price,\n                                              ol_amount);\n        addConstraint(Constants.NEWORDER, 2, constraint);\n\n        // Order Status table 0\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 0, c_id);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 0, c_id);\n        // Order Status table 1\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              o_id, o_carrier_id);\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 1, constraint);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 1, constraint);\n        // Order Status table 2\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              ol_supply_w_id, ol_i_id,\n                                              ol_quantity, ol_amount);\n        addConstraint(Constants.ORDER_STATUS_BY_ID, 2, constraint);\n        addConstraint(Constants.ORDER_STATUS_BY_NAME, 2, constraint);\n\n        // Payment\n        constraint = Verification.conjunction(ExpressionType.CONJUNCTION_AND,\n                                              c_id, c_discount);\n        addConstraint(Constants.PAYMENT_BY_ID, 2, constraint);\n        addConstraint(Constants.PAYMENT_BY_ID_C, 0, constraint);\n        addConstraint(Constants.PAYMENT_BY_NAME, 2, constraint);\n        addConstraint(Constants.PAYMENT_BY_NAME_C, 0, constraint);\n\n        // slev\n        constraint = Verification.compareWithConstant(ExpressionType.COMPARE_GREATERTHANOREQUALTO,\n                                                      \"C1\",\n                                                      0L);\n        addConstraint(Constants.STOCK_LEVEL, 0, constraint);\n\n        // Full table checks\n        addConstraint(\"WAREHOUSE\", 0, warehouse);\n        addConstraint(\"DISTRICT\", 0, district);\n        addConstraint(\"CUSTOMER\", 0, customer);\n        addConstraint(\"CUSTOMER_NAME\", 0, customer_name);\n        addConstraint(\"HISTORY\", 0, history);\n        addConstraint(\"NEW_ORDER\", 0, new_order);\n        addConstraint(\"ORDERS\", 0, orders);\n        addConstraint(\"ORDER_LINE\", 0, order_line);\n        addConstraint(\"ITEM\", 0, item);\n        addConstraint(\"STOCK\", 0, stock);\n\n        // TODO Foreign key constraints\n    }","commit_id":"3374428f28920163cd105f1acf47e3113c7c7543","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkRequestAndPermissions(wsRequest);\n    SearchProjectPermissionsWsResponse searchProjectPermissionsWsResponse = doHandle(toSearchProjectPermissionsWsRequest(wsRequest));\n    writeProtobuf(searchProjectPermissionsWsResponse, wsRequest, wsResponse);\n  }","id":106565,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    SearchProjectPermissionsWsResponse searchProjectPermissionsWsResponse = doHandle(toSearchProjectPermissionsWsRequest(wsRequest));\n    writeProtobuf(searchProjectPermissionsWsResponse, wsRequest, wsResponse);\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkRequestAndPermissions(Request wsRequest) {\n    Optional<WsProjectRef> project = WsProjectRef.newOptionalWsProjectRef(wsRequest);\n    boolean hasProject = project.isPresent();\n    boolean hasProjectUuid = hasProject && project.get().uuid() != null;\n    boolean hasProjectKey = hasProject && project.get().key() != null;\n\n    if (hasProjectUuid) {\n      checkProjectAdminUserByComponentUuid(userSession, project.get().uuid());\n    } else if (hasProjectKey) {\n      checkProjectAdminUserByComponentKey(userSession, project.get().key());\n    } else {\n      checkGlobalAdminUser(userSession);\n    }\n  }","id":106566,"modified_method":"private void checkRequestAndPermissions(SearchProjectPermissionsWsRequest request) {\n    Optional<WsProjectRef> project = newOptionalWsProjectRef(request.getProjectId(), request.getProjectKey());\n    boolean hasProject = project.isPresent();\n    boolean hasProjectUuid = hasProject && project.get().uuid() != null;\n    boolean hasProjectKey = hasProject && project.get().key() != null;\n\n    if (hasProjectUuid) {\n      checkProjectAdminUserByComponentUuid(userSession, project.get().uuid());\n    } else if (hasProjectKey) {\n      checkProjectAdminUserByComponentKey(userSession, project.get().key());\n    } else {\n      checkGlobalAdminUser(userSession);\n    }\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private SearchProjectPermissionsWsResponse doHandle(SearchProjectPermissionsWsRequest request) {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      SearchProjectPermissionsData data = dataLoader.load(request);\n      return buildResponse(data);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106567,"modified_method":"private SearchProjectPermissionsWsResponse doHandle(SearchProjectPermissionsWsRequest request) {\n    checkRequestAndPermissions(request);\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      SearchProjectPermissionsData data = dataLoader.load(request);\n      return buildResponse(data);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private WsUsersResponse buildResponse(DbSession dbSession, PermissionQuery query, PermissionTemplateDto template) {\n    List<UserWithPermissionDto> usersWithPermission = dbClient.permissionTemplateDao().selectUsers(dbSession, query, template.getId(), query.pageOffset(), query.pageSize());\n    int total = dbClient.permissionTemplateDao().countUsers(dbSession, query, template.getId());\n\n    WsUsersResponse.Builder responseBuilder = WsUsersResponse.newBuilder();\n    for (UserWithPermissionDto userWithPermission : usersWithPermission) {\n      responseBuilder.addUsers(userDtoToUserResponse(userWithPermission));\n    }\n\n    responseBuilder.getPagingBuilder()\n      .setPageIndex(query.pageIndex())\n      .setPageSize(query.pageSize())\n      .setTotal(total)\n      .build();\n\n    return responseBuilder.build();\n  }","id":106568,"modified_method":"private WsPermissions.UsersWsResponse buildResponse(DbSession dbSession, PermissionQuery query, PermissionTemplateDto template) {\n    List<UserWithPermissionDto> usersWithPermission = dbClient.permissionTemplateDao().selectUsers(dbSession, query, template.getId(), query.pageOffset(), query.pageSize());\n    int total = dbClient.permissionTemplateDao().countUsers(dbSession, query, template.getId());\n\n    UsersWsResponse.Builder responseBuilder = UsersWsResponse.newBuilder();\n    for (UserWithPermissionDto userWithPermission : usersWithPermission) {\n      responseBuilder.addUsers(userDtoToUserResponse(userWithPermission));\n    }\n\n    responseBuilder.getPagingBuilder()\n      .setPageIndex(query.pageIndex())\n      .setPageSize(query.pageSize())\n      .setTotal(total)\n      .build();\n\n    return responseBuilder.build();\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkGlobalAdminUser(userSession);\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      WsTemplateRef templateRef = WsTemplateRef.fromRequest(wsRequest);\n      PermissionTemplateDto template = dependenciesFinder.getTemplate(dbSession, templateRef);\n\n      PermissionQuery query = buildQuery(wsRequest, template);\n      WsUsersResponse templateUsersResponse = buildResponse(dbSession, query, template);\n      writeProtobuf(templateUsersResponse, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106569,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkGlobalAdminUser(userSession);\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      WsTemplateRef templateRef = WsTemplateRef.fromRequest(wsRequest);\n      PermissionTemplateDto template = dependenciesFinder.getTemplate(dbSession, templateRef);\n\n      PermissionQuery query = buildQuery(wsRequest, template);\n      WsPermissions.UsersWsResponse templateUsersResponse = buildResponse(dbSession, query, template);\n      writeProtobuf(templateUsersResponse, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_for_users_by_template_name() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsUsersResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsExactly(\"login-1\", \"login-2\");\n  }","id":106570,"modified_method":"@Test\n  public void search_for_users_by_template_name() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    UsersWsResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsExactly(\"login-1\", \"login-2\");\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_with_pagination() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.SELECTED, \"all\")\n      .setParam(WebService.Param.PAGE, \"2\")\n      .setParam(WebService.Param.PAGE_SIZE, \"1\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsUsersResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsOnly(\"login-2\");\n  }","id":106571,"modified_method":"@Test\n  public void search_with_pagination() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.SELECTED, \"all\")\n      .setParam(WebService.Param.PAGE, \"2\")\n      .setParam(WebService.Param.PAGE_SIZE, \"1\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsPermissions.UsersWsResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsOnly(\"login-2\");\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_using_text_query() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.TEXT_QUERY, \"ame-1\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsUsersResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsOnly(\"login-1\");\n  }","id":106572,"modified_method":"@Test\n  public void search_using_text_query() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.TEXT_QUERY, \"ame-1\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    UsersWsResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsOnly(\"login-1\");\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_using_selected() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.SELECTED, \"all\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsUsersResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsExactly(\"login-1\", \"login-2\", \"login-3\");\n    assertThat(response.getUsers(2).getSelected()).isFalse();\n  }","id":106573,"modified_method":"@Test\n  public void search_using_selected() throws IOException {\n    InputStream responseStream = newRequest(UserRole.USER, null)\n      .setParam(org.sonarqube.ws.client.permission.PermissionsWsParameters.PARAM_TEMPLATE_NAME, template1.getName())\n      .setParam(WebService.Param.SELECTED, \"all\")\n      .setMediaType(PROTOBUF)\n      .execute().getInputStream();\n\n    WsPermissions.UsersWsResponse response = parseFrom(responseStream);\n\n    assertThat(response.getUsersList()).extracting(\"login\").containsExactly(\"login-1\", \"login-2\", \"login-3\");\n    assertThat(response.getUsers(2).getSelected()).isFalse();\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static WsUsersResponse buildResponse(List<UserWithPermissionDto> usersWithPermission, Paging paging) {\n    WsUsersResponse.Builder userResponse = WsUsersResponse.newBuilder();\n    WsPermissions.User.Builder user = WsPermissions.User.newBuilder();\n    for (UserWithPermissionDto userWithPermission : usersWithPermission) {\n      userResponse.addUsers(\n        user\n          .clear()\n          .setLogin(userWithPermission.getLogin())\n          .setName(nullToEmpty(userWithPermission.getName()))\n          .setEmail(nullToEmpty(userWithPermission.getEmail()))\n          .setSelected(userWithPermission.getPermission() != null));\n    }\n\n    userResponse.getPagingBuilder()\n      .clear()\n      .setPageIndex(paging.pageIndex())\n      .setPageSize(paging.pageSize())\n      .setTotal(paging.total())\n      .build();\n\n    return userResponse.build();\n  }","id":106574,"modified_method":"private static UsersWsResponse buildResponse(List<UserWithPermissionDto> usersWithPermission, Paging paging) {\n    UsersWsResponse.Builder userResponse = UsersWsResponse.newBuilder();\n    WsPermissions.User.Builder user = WsPermissions.User.newBuilder();\n    for (UserWithPermissionDto userWithPermission : usersWithPermission) {\n      userResponse.addUsers(\n        user\n          .clear()\n          .setLogin(userWithPermission.getLogin())\n          .setName(nullToEmpty(userWithPermission.getName()))\n          .setEmail(nullToEmpty(userWithPermission.getEmail()))\n          .setSelected(userWithPermission.getPermission() != null));\n    }\n\n    userResponse.getPagingBuilder()\n      .clear()\n      .setPageIndex(paging.pageIndex())\n      .setPageSize(paging.pageSize())\n      .setTotal(paging.total())\n      .build();\n\n    return userResponse.build();\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      PermissionRequest request = new Builder(wsRequest).withPagination().build();\n      Optional<ComponentDto> project = dependenciesFinder.searchProject(dbSession, request.project());\n      checkProjectAdminUserByComponentDto(userSession, project);\n      PermissionQuery permissionQuery = buildPermissionQuery(request, project);\n      Long projectIdIfPresent = project.isPresent() ? project.get().getId() : null;\n      int total = dbClient.permissionDao().countUsers(dbSession, permissionQuery, projectIdIfPresent);\n      List<UserWithPermissionDto> usersWithPermission = permissionFinder.findUsersWithPermission(dbSession, permissionQuery);\n      WsUsersResponse wsUsersResponse = buildResponse(usersWithPermission, forPageIndex(request.page()).withPageSize(request.pageSize()).andTotal(total));\n\n      writeProtobuf(wsUsersResponse, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106575,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    UsersWsResponse usersWsResponse = doHandle(toUsersWsRequest(wsRequest));\n    writeProtobuf(usersWsResponse, wsRequest, wsResponse);\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static PermissionQuery buildPermissionQuery(PermissionRequest request, Optional<ComponentDto> project) {\n    PermissionQuery.Builder permissionQuery = PermissionQuery.builder()\n      .permission(request.permission())\n      .pageIndex(request.page())\n      .pageSize(request.pageSize())\n      .membership(fromSelectionModeToMembership(firstNonNull(request.selected(), SelectionMode.SELECTED.value())))\n      .search(request.query());\n    if (project.isPresent()) {\n      permissionQuery.component(project.get().getKey());\n    }\n\n    return permissionQuery.build();\n  }","id":106576,"modified_method":"private static PermissionQuery buildPermissionQuery(UsersWsRequest request, Optional<ComponentDto> project) {\n    PermissionQuery.Builder permissionQuery = PermissionQuery.builder()\n      .permission(request.getPermission())\n      .pageIndex(request.getPage())\n      .pageSize(request.getPageSize())\n      .membership(fromSelectionModeToMembership(firstNonNull(request.getSelected(), SelectionMode.SELECTED.value())))\n      .search(request.getQuery());\n    if (project.isPresent()) {\n      permissionQuery.component(project.get().getKey());\n    }\n\n    return permissionQuery.build();\n  }","commit_id":"40cf347e9aa2ded35a8798b8aec0abbf2e993183","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void setDefaultTemplate(SetDefaultTemplateWsRequest request) {\n    wsClient.execute(\n      newPostRequest(\"set_default_template\")\n        .setParam(PARAM_QUALIFIER, request.getQualifier())\n        .setParam(PARAM_TEMPLATE_ID, request.getTemplateId())\n        .setParam(PARAM_TEMPLATE_NAME, request.getTemplateName()));\n  }","id":106577,"modified_method":"public void setDefaultTemplate(SetDefaultTemplateWsRequest request) {\n    wsClient.execute(\n      newPostRequest(action(\"set_default_template\"))\n        .setParam(PARAM_QUALIFIER, request.getQualifier())\n        .setParam(PARAM_TEMPLATE_ID, request.getTemplateId())\n        .setParam(PARAM_TEMPLATE_NAME, request.getTemplateName()));\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SearchTemplatesWsResponse searchTemplates(SearchTemplatesWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(\"search_templates\")\n        .setParam(\"q\", request.getQuery()),\n      SearchTemplatesWsResponse.parser());\n  }","id":106578,"modified_method":"public SearchTemplatesWsResponse searchTemplates(SearchTemplatesWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(action(\"search_templates\"))\n        .setParam(\"q\", request.getQuery()),\n      SearchTemplatesWsResponse.parser());\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public UpdateTemplateWsResponse updateTemplate(UpdateTemplateWsRequest request) {\n    return wsClient.execute(\n      newPostRequest(\"update_template\")\n        .setParam(PARAM_DESCRIPTION, request.getDescription())\n        .setParam(PARAM_ID, request.getId())\n        .setParam(PARAM_NAME, request.getName())\n        .setParam(PARAM_PROJECT_KEY_PATTERN, request.getProjectKeyPattern()),\n      UpdateTemplateWsResponse.parser());\n  }","id":106579,"modified_method":"public UpdateTemplateWsResponse updateTemplate(UpdateTemplateWsRequest request) {\n    return wsClient.execute(\n      newPostRequest(action(\"update_template\"))\n        .setParam(PARAM_DESCRIPTION, request.getDescription())\n        .setParam(PARAM_ID, request.getId())\n        .setParam(PARAM_NAME, request.getName())\n        .setParam(PARAM_PROJECT_KEY_PATTERN, request.getProjectKeyPattern()),\n      UpdateTemplateWsResponse.parser());\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SearchProjectPermissionsWsResponse searchProjectPermissions(SearchProjectPermissionsWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(\"search_project_permissions\")\n        .setParam(PARAM_PROJECT_ID, request.getProjectId())\n        .setParam(PARAM_PROJECT_KEY, request.getProjectKey())\n        .setParam(\"p\", request.getPage())\n        .setParam(\"ps\", request.getPageSize())\n        .setParam(\"q\", request.getQuery()),\n      SearchProjectPermissionsWsResponse.parser());\n  }","id":106580,"modified_method":"public SearchProjectPermissionsWsResponse searchProjectPermissions(SearchProjectPermissionsWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(action(\"search_project_permissions\"))\n        .setParam(PARAM_PROJECT_ID, request.getProjectId())\n        .setParam(PARAM_PROJECT_KEY, request.getProjectKey())\n        .setParam(\"p\", request.getPage())\n        .setParam(\"ps\", request.getPageSize())\n        .setParam(\"q\", request.getQuery()),\n      SearchProjectPermissionsWsResponse.parser());\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public UsersWsResponse users(UsersWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(\"users\")\n        .setParam(PARAM_PERMISSION, request.getPermission())\n        .setParam(PARAM_PROJECT_ID, request.getProjectId())\n        .setParam(PARAM_PROJECT_KEY, request.getProjectKey())\n        .setParam(\"selected\", request.getSelected())\n        .setParam(\"p\", request.getPage())\n        .setParam(\"ps\", request.getPageSize())\n        .setParam(\"q\", request.getQuery()),\n      UsersWsResponse.parser());\n  }","id":106581,"modified_method":"public UsersWsResponse users(UsersWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(action(\"users\"))\n        .setParam(PARAM_PERMISSION, request.getPermission())\n        .setParam(PARAM_PROJECT_ID, request.getProjectId())\n        .setParam(PARAM_PROJECT_KEY, request.getProjectKey())\n        .setParam(\"selected\", request.getSelected())\n        .setParam(\"p\", request.getPage())\n        .setParam(\"ps\", request.getPageSize())\n        .setParam(\"q\", request.getQuery()),\n      UsersWsResponse.parser());\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SearchWsResponse search(SearchWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(\"search\")\n        .setParam(\"defaults\", request.getDefaults())\n        .setParam(\"language\", request.getLanguage())\n        .setParam(\"profileName\", request.getProfileName())\n        .setParam(\"projectKey\", request.getProjectKey()),\n      SearchWsResponse.parser());\n  }","id":106582,"modified_method":"public SearchWsResponse search(SearchWsRequest request) {\n    return wsClient.execute(\n      newGetRequest(action(\"search\"))\n        .setParam(\"defaults\", request.getDefaults())\n        .setParam(\"language\", request.getLanguage())\n        .setParam(\"profileName\", request.getProfileName())\n        .setParam(\"projectKey\", request.getProjectKey()),\n      SearchWsResponse.parser());\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private WsSearchResponse buildResponse(List<ComponentDto> components, Paging paging) {\n    WsSearchResponse.Builder responseBuilder = WsSearchResponse.newBuilder();\n    responseBuilder.getPagingBuilder()\n      .setPageIndex(paging.pageIndex())\n      .setPageSize(paging.pageSize())\n      .setTotal(paging.total())\n      .build();\n\n    responseBuilder.addAllComponents(\n      from(components)\n        .transform(ComponentDToComponentResponseFunction.INSTANCE));\n\n    return responseBuilder.build();\n  }","id":106583,"modified_method":"private SearchWsResponse buildResponse(List<ComponentDto> components, Paging paging) {\n    WsComponents.SearchWsResponse.Builder responseBuilder = SearchWsResponse.newBuilder();\n    responseBuilder.getPagingBuilder()\n      .setPageIndex(paging.pageIndex())\n      .setPageSize(paging.pageSize())\n      .setTotal(paging.total())\n      .build();\n\n    responseBuilder.addAllComponents(\n      from(components)\n        .transform(ComponentDToComponentResponseFunction.INSTANCE));\n\n    return responseBuilder.build();\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private ComponentQuery buildQuery(Request wsRequest, List<String> qualifiers) {\n    return new ComponentQuery(\n      wsRequest.param(Param.TEXT_QUERY),\n      qualifiers.toArray(new String[qualifiers.size()]));\n  }","id":106584,"modified_method":"private ComponentQuery buildQuery(SearchWsRequest request, List<String> qualifiers) {\n    return new ComponentQuery(\n      request.getQuery(),\n      qualifiers.toArray(new String[qualifiers.size()]));\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Paging buildPaging(DbSession dbSession, Request wsRequest, ComponentQuery query) {\n    int total = dbClient.componentDao().countByQuery(dbSession, query);\n    return Paging.forPageIndex(wsRequest.mandatoryParamAsInt(Param.PAGE))\n      .withPageSize(wsRequest.mandatoryParamAsInt(Param.PAGE_SIZE))\n      .andTotal(total);\n  }","id":106585,"modified_method":"private Paging buildPaging(DbSession dbSession, SearchWsRequest request, ComponentQuery query) {\n    int total = dbClient.componentDao().countByQuery(dbSession, query);\n    return Paging.forPageIndex(request.getPage())\n      .withPageSize(request.getPageSize())\n      .andTotal(total);\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    List<String> qualifiers = wsRequest.mandatoryParamAsStrings(PARAM_QUALIFIERS);\n    validateQualifiers(qualifiers);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      ComponentQuery query = buildQuery(wsRequest, qualifiers);\n      Paging paging = buildPaging(dbSession, wsRequest, query);\n      List<ComponentDto> components = searchComponents(dbSession, query, paging);\n      WsSearchResponse response = buildResponse(components, paging);\n      writeProtobuf(response, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106586,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    SearchWsResponse searchWsResponse = doHandle(toSearchWsRequest(wsRequest));\n    writeProtobuf(searchWsResponse, wsRequest, wsResponse);\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_with_pagination() throws IOException {\n    for (int i = 1; i <= 9; i++) {\n      componentDb.insertComponent(\n        newProjectDto(\"project-uuid-\" + i)\n          .setName(\"Project Name \" + i));\n    }\n    db.commit();\n\n    InputStream responseStream = newRequest(Qualifiers.PROJECT)\n      .setParam(Param.PAGE, \"2\")\n      .setParam(Param.PAGE_SIZE, \"3\")\n      .execute()\n      .getInputStream();\n    WsSearchResponse response = WsSearchResponse.parseFrom(responseStream);\n\n    assertThat(response.getComponentsCount()).isEqualTo(3);\n    assertThat(response.getComponentsList()).extracting(\"id\").containsExactly(\"project-uuid-4\", \"project-uuid-5\", \"project-uuid-6\");\n  }","id":106587,"modified_method":"@Test\n  public void search_with_pagination() throws IOException {\n    for (int i = 1; i <= 9; i++) {\n      componentDb.insertComponent(\n        newProjectDto(\"project-uuid-\" + i)\n          .setName(\"Project Name \" + i));\n    }\n    db.commit();\n\n    InputStream responseStream = newRequest(Qualifiers.PROJECT)\n      .setParam(Param.PAGE, \"2\")\n      .setParam(Param.PAGE_SIZE, \"3\")\n      .execute()\n      .getInputStream();\n    SearchWsResponse response = SearchWsResponse.parseFrom(responseStream);\n\n    assertThat(response.getComponentsCount()).isEqualTo(3);\n    assertThat(response.getComponentsList()).extracting(\"id\").containsExactly(\"project-uuid-4\", \"project-uuid-5\", \"project-uuid-6\");\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_with_key_query() throws IOException {\n    componentDb.insertComponent(newProjectDto().setKey(\"project-_%-key\"));\n    componentDb.insertComponent(newProjectDto().setKey(\"project-key-without-escaped-characters\"));\n    db.commit();\n\n    InputStream responseStream = newRequest(Qualifiers.PROJECT)\n      .setParam(Param.TEXT_QUERY, \"project-_%\")\n      .execute().getInputStream();\n    WsSearchResponse response = WsSearchResponse.parseFrom(responseStream);\n\n    assertThat(response.getComponentsCount()).isEqualTo(1);\n    assertThat(response.getComponentsList()).extracting(\"key\").containsExactly(\"project-_%-key\");\n  }","id":106588,"modified_method":"@Test\n  public void search_with_key_query() throws IOException {\n    componentDb.insertComponent(newProjectDto().setKey(\"project-_%-key\"));\n    componentDb.insertComponent(newProjectDto().setKey(\"project-key-without-escaped-characters\"));\n    db.commit();\n\n    InputStream responseStream = newRequest(Qualifiers.PROJECT)\n      .setParam(Param.TEXT_QUERY, \"project-_%\")\n      .execute().getInputStream();\n    SearchWsResponse response = SearchWsResponse.parseFrom(responseStream);\n\n    assertThat(response.getComponentsCount()).isEqualTo(1);\n    assertThat(response.getComponentsList()).extracting(\"key\").containsExactly(\"project-_%-key\");\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_protobuf_response() throws Exception {\n    server.doReturnBody(\n      WsComponents.WsSearchResponse\n        .newBuilder()\n        .addComponents(WsComponents.WsSearchResponse.Component.getDefaultInstance())\n        .build()\n        .toByteArray());\n    server.doReturnStatus(HTTP_OK);\n    server.doReturnContentType(MediaTypes.PROTOBUF);\n\n    WsComponents.WsSearchResponse response = underTest.execute(\n      newGetRequest(\"api/components/search\")\n        .setMediaType(WsRequest.MediaType.PROTOBUF),\n      WsComponents.WsSearchResponse.parser());\n\n    assertThat(response.getComponentsCount()).isEqualTo(1);\n    assertThat(server.requestHeaders().get(HttpHeaders.ACCEPT))\n      .isEqualTo(MediaTypes.PROTOBUF);\n  }","id":106589,"modified_method":"@Test\n  public void return_protobuf_response() throws Exception {\n    server.doReturnBody(\n      WsComponents.SearchWsResponse\n        .newBuilder()\n        .addComponents(WsComponents.SearchWsResponse.Component.getDefaultInstance())\n        .build()\n        .toByteArray());\n    server.doReturnStatus(HTTP_OK);\n    server.doReturnContentType(MediaTypes.PROTOBUF);\n\n    WsComponents.SearchWsResponse response = underTest.execute(\n      newGetRequest(\"api/components/search\")\n        .setMediaType(WsRequest.MediaType.PROTOBUF),\n      WsComponents.SearchWsResponse.parser());\n\n    assertThat(response.getComponentsCount()).isEqualTo(1);\n    assertThat(server.requestHeaders().get(HttpHeaders.ACCEPT))\n      .isEqualTo(MediaTypes.PROTOBUF);\n  }","commit_id":"1de32aa4798f3246861214ec7f52bfc5f76fd0bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void buildTemplatesResponse(WsSearchTemplatesResponse.Builder response, SearchTemplatesData data) {\n    Permission.Builder permissionResponse = Permission.newBuilder();\n    PermissionTemplate.Builder templateBuilder = PermissionTemplate.newBuilder();\n\n    for (PermissionTemplateDto templateDto : data.templates()) {\n      templateBuilder\n        .clear()\n        .setId(templateDto.getUuid())\n        .setName(templateDto.getName())\n        .setCreatedAt(formatDateTime(templateDto.getCreatedAt()))\n        .setUpdatedAt(formatDateTime(templateDto.getUpdatedAt()));\n      if (templateDto.getKeyPattern() != null) {\n        templateBuilder.setProjectKeyPattern(templateDto.getKeyPattern());\n      }\n      if (templateDto.getDescription() != null) {\n        templateBuilder.setDescription(templateDto.getDescription());\n      }\n      for (String permission : data.permissions(templateDto.getId())) {\n        templateBuilder.addPermissions(\n          permissionResponse\n            .clear()\n            .setKey(permission)\n            .setUsersCount(data.userCount(templateDto.getId(), permission))\n            .setGroupsCount(data.groupCount(templateDto.getId(), permission)));\n      }\n      response.addPermissionTemplates(templateBuilder);\n    }\n  }","id":106590,"modified_method":"private static void buildTemplatesResponse(WsPermissions.SearchTemplatesWsResponse.Builder response, SearchTemplatesData data) {\n    Permission.Builder permissionResponse = Permission.newBuilder();\n    PermissionTemplate.Builder templateBuilder = PermissionTemplate.newBuilder();\n\n    for (PermissionTemplateDto templateDto : data.templates()) {\n      templateBuilder\n        .clear()\n        .setId(templateDto.getUuid())\n        .setName(templateDto.getName())\n        .setCreatedAt(formatDateTime(templateDto.getCreatedAt()))\n        .setUpdatedAt(formatDateTime(templateDto.getUpdatedAt()));\n      if (templateDto.getKeyPattern() != null) {\n        templateBuilder.setProjectKeyPattern(templateDto.getKeyPattern());\n      }\n      if (templateDto.getDescription() != null) {\n        templateBuilder.setDescription(templateDto.getDescription());\n      }\n      for (String permission : data.permissions(templateDto.getId())) {\n        templateBuilder.addPermissions(\n          permissionResponse\n            .clear()\n            .setKey(permission)\n            .setUsersCount(data.userCount(templateDto.getId(), permission))\n            .setGroupsCount(data.groupCount(templateDto.getId(), permission)));\n      }\n      response.addPermissionTemplates(templateBuilder);\n    }\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkGlobalAdminUser(userSession);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      SearchTemplatesData data = dataLoader.load(wsRequest);\n      WsSearchTemplatesResponse response = buildResponse(data);\n      writeProtobuf(response, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106591,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkGlobalAdminUser(userSession);\n\n    SearchTemplatesWsResponse searchTemplatesWsResponse = doHandle(toSearchTemplatesWsRequest(wsRequest));\n    writeProtobuf(searchTemplatesWsResponse, wsRequest, wsResponse);\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private WsSearchTemplatesResponse buildResponse(SearchTemplatesData data) {\n    WsSearchTemplatesResponse.Builder response = WsSearchTemplatesResponse.newBuilder();\n\n    buildTemplatesResponse(response, data);\n    buildDefaultTemplatesResponse(response, data);\n    buildPermissionsResponse(response);\n\n    return response.build();\n  }","id":106592,"modified_method":"private WsPermissions.SearchTemplatesWsResponse buildResponse(SearchTemplatesData data) {\n    SearchTemplatesWsResponse.Builder response = SearchTemplatesWsResponse.newBuilder();\n\n    buildTemplatesResponse(response, data);\n    buildDefaultTemplatesResponse(response, data);\n    buildPermissionsResponse(response);\n\n    return response.build();\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void buildDefaultTemplatesResponse(WsSearchTemplatesResponse.Builder response, SearchTemplatesData data) {\n    TemplateIdQualifier.Builder templateUuidQualifierBuilder = TemplateIdQualifier.newBuilder();\n    for (DefaultPermissionTemplateFinder.TemplateUuidQualifier templateUuidQualifier : data.defaultTempltes()) {\n      response.addDefaultTemplates(templateUuidQualifierBuilder\n        .clear()\n        .setQualifier(templateUuidQualifier.getQualifier())\n        .setTemplateId(templateUuidQualifier.getTemplateUuid()));\n    }\n  }","id":106593,"modified_method":"private static void buildDefaultTemplatesResponse(SearchTemplatesWsResponse.Builder response, SearchTemplatesData data) {\n    TemplateIdQualifier.Builder templateUuidQualifierBuilder = TemplateIdQualifier.newBuilder();\n    for (DefaultPermissionTemplateFinder.TemplateUuidQualifier templateUuidQualifier : data.defaultTempltes()) {\n      response.addDefaultTemplates(templateUuidQualifierBuilder\n        .clear()\n        .setQualifier(templateUuidQualifier.getQualifier())\n        .setTemplateId(templateUuidQualifier.getTemplateUuid()));\n    }\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void buildPermissionsResponse(WsSearchTemplatesResponse.Builder response) {\n    Permission.Builder permissionResponse = Permission.newBuilder();\n    for (String permissionKey : ProjectPermissions.ALL) {\n      response.addPermissions(\n        permissionResponse\n          .clear()\n          .setKey(permissionKey)\n          .setName(i18nName(permissionKey))\n          .setDescription(i18nDescriptionMessage(permissionKey))\n        );\n    }\n  }","id":106594,"modified_method":"private void buildPermissionsResponse(SearchTemplatesWsResponse.Builder response) {\n    Permission.Builder permissionResponse = Permission.newBuilder();\n    for (String permissionKey : ProjectPermissions.ALL) {\n      response.addPermissions(\n        permissionResponse\n          .clear()\n          .setKey(permissionKey)\n          .setName(i18nName(permissionKey))\n          .setDescription(i18nDescriptionMessage(permissionKey)));\n    }\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<PermissionTemplateDto> searchTemplates(DbSession dbSession, Request wsRequest) {\n    String nameMatch = wsRequest.param(TEXT_QUERY);\n\n    return nameMatch == null ?\n      dbClient.permissionTemplateDao().selectAll(dbSession)\n      : dbClient.permissionTemplateDao().selectAll(dbSession, nameMatch);\n  }","id":106595,"modified_method":"private List<PermissionTemplateDto> searchTemplates(DbSession dbSession, SearchTemplatesWsRequest request) {\n    String nameMatch = request.getQuery();\n\n    return nameMatch == null ? dbClient.permissionTemplateDao().selectAll(dbSession)\n      : dbClient.permissionTemplateDao().selectAll(dbSession, nameMatch);\n  }","commit_id":"563fbccfafb8d7225b7fe3f98f87f415c805217a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkRequestAndPermissions(wsRequest);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      SearchProjectPermissionsData data = dataLoader.load(wsRequest);\n      WsSearchProjectPermissionsResponse response = buildResponse(data);\n      writeProtobuf(response, wsRequest, wsResponse);\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":106596,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    checkRequestAndPermissions(wsRequest);\n    SearchProjectPermissionsWsResponse searchProjectPermissionsWsResponse = doHandle(toSearchProjectPermissionsWsRequest(wsRequest));\n    writeProtobuf(searchProjectPermissionsWsResponse, wsRequest, wsResponse);\n  }","commit_id":"665e52be0bcd458c8198829088f8eadf793029f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private WsSearchProjectPermissionsResponse buildResponse(SearchProjectPermissionsData data) {\n    WsSearchProjectPermissionsResponse.Builder response = WsSearchProjectPermissionsResponse.newBuilder();\n    Permission.Builder permissionResponse = Permission.newBuilder();\n\n    Project.Builder rootComponentBuilder = Project.newBuilder();\n    for (ComponentDto rootComponent : data.rootComponents()) {\n      rootComponentBuilder\n        .clear()\n        .setId(rootComponent.uuid())\n        .setKey(rootComponent.key())\n        .setQualifier(rootComponent.qualifier())\n        .setName(rootComponent.name());\n      for (String permission : data.permissions(rootComponent.getId())) {\n        rootComponentBuilder.addPermissions(\n          permissionResponse\n            .clear()\n            .setKey(permission)\n            .setUsersCount(data.userCount(rootComponent.getId(), permission))\n            .setGroupsCount(data.groupCount(rootComponent.getId(), permission)));\n      }\n      response.addProjects(rootComponentBuilder);\n    }\n\n    for (String permissionKey : ProjectPermissions.ALL) {\n      response.addPermissions(\n        permissionResponse\n          .clear()\n          .setKey(permissionKey)\n          .setName(i18nName(permissionKey))\n          .setDescription(i18nDescriptionMessage(permissionKey))\n        );\n    }\n\n    Paging paging = data.paging();\n    response.setPaging(\n      Common.Paging.newBuilder()\n        .setPageIndex(paging.pageIndex())\n        .setPageSize(paging.pageSize())\n        .setTotal(paging.total())\n      );\n\n    return response.build();\n  }","id":106597,"modified_method":"private SearchProjectPermissionsWsResponse buildResponse(SearchProjectPermissionsData data) {\n    SearchProjectPermissionsWsResponse.Builder response = SearchProjectPermissionsWsResponse.newBuilder();\n    Permission.Builder permissionResponse = Permission.newBuilder();\n\n    Project.Builder rootComponentBuilder = Project.newBuilder();\n    for (ComponentDto rootComponent : data.rootComponents()) {\n      rootComponentBuilder\n        .clear()\n        .setId(rootComponent.uuid())\n        .setKey(rootComponent.key())\n        .setQualifier(rootComponent.qualifier())\n        .setName(rootComponent.name());\n      for (String permission : data.permissions(rootComponent.getId())) {\n        rootComponentBuilder.addPermissions(\n          permissionResponse\n            .clear()\n            .setKey(permission)\n            .setUsersCount(data.userCount(rootComponent.getId(), permission))\n            .setGroupsCount(data.groupCount(rootComponent.getId(), permission)));\n      }\n      response.addProjects(rootComponentBuilder);\n    }\n\n    for (String permissionKey : ProjectPermissions.ALL) {\n      response.addPermissions(\n        permissionResponse\n          .clear()\n          .setKey(permissionKey)\n          .setName(i18nName(permissionKey))\n          .setDescription(i18nDescriptionMessage(permissionKey)));\n    }\n\n    Paging paging = data.paging();\n    response.setPaging(\n      Common.Paging.newBuilder()\n        .setPageIndex(paging.pageIndex())\n        .setPageSize(paging.pageSize())\n        .setTotal(paging.total()));\n\n    return response.build();\n  }","commit_id":"665e52be0bcd458c8198829088f8eadf793029f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<ComponentDto> searchRootComponents(DbSession dbSession, Request wsRequest, Paging paging) {\n    String query = wsRequest.param(TEXT_QUERY);\n    Optional<WsProjectRef> project = WsProjectRef.newOptionalWsProjectRef(wsRequest);\n\n    if (project.isPresent()) {\n      return singletonList(finder.getRootComponentOrModule(dbSession, project.get()));\n    }\n\n    return dbClient.componentDao().selectComponents(dbSession, rootQualifiers, paging.offset(), paging.pageSize(), query);\n  }","id":106598,"modified_method":"private List<ComponentDto> searchRootComponents(DbSession dbSession, SearchProjectPermissionsWsRequest request, Paging paging) {\n    String query = request.getQuery();\n    Optional<WsProjectRef> project = newOptionalWsProjectRef(request.getProjectId(), request.getProjectKey());\n\n    if (project.isPresent()) {\n      return singletonList(finder.getRootComponentOrModule(dbSession, project.get()));\n    }\n\n    return dbClient.componentDao().selectComponents(dbSession, rootQualifiers, paging.offset(), paging.pageSize(), query);\n  }","commit_id":"665e52be0bcd458c8198829088f8eadf793029f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private int countRootComponents(DbSession dbSession, Collection<String> qualifiers, Request wsRequest) {\n    return dbClient.componentDao().countRootComponents(dbSession, qualifiers, wsRequest.param(TEXT_QUERY));\n  }","id":106599,"modified_method":"private int countRootComponents(DbSession dbSession, Collection<String> qualifiers, SearchProjectPermissionsWsRequest request) {\n    return dbClient.componentDao().countRootComponents(dbSession, qualifiers, request.getQuery());\n  }","commit_id":"665e52be0bcd458c8198829088f8eadf793029f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@NotNull\n  @Override\n  protected CreateFileFromTemplateDialog.Builder buildDialog(Project project, final PsiDirectory directory) {\n    final CreateFileFromTemplateDialog.Builder builder = CreateFileFromTemplateDialog.\n      createDialog(project, IdeBundle.message(\"action.create.new.class\"));\n    builder.addKind(\"Class\", Icons.CLASS_ICON, JavaTemplateUtil.INTERNAL_CLASS_TEMPLATE_NAME);\n    builder.addKind(\"Interface\", Icons.INTERFACE_ICON, JavaTemplateUtil.INTERNAL_INTERFACE_TEMPLATE_NAME);\n    if (LanguageLevelProjectExtension.getInstance(project).getLanguageLevel().compareTo(LanguageLevel.JDK_1_5) >= 0) {\n      builder.addKind(\"Enum\", Icons.ENUM_ICON, JavaTemplateUtil.INTERNAL_ENUM_TEMPLATE_NAME);\n      builder.addKind(\"Annotation\", Icons.ANNOTATION_TYPE_ICON, JavaTemplateUtil.INTERNAL_ANNOTATION_TYPE_TEMPLATE_NAME);\n    }\n    return builder;\n  }","id":106600,"modified_method":"@Override\n  protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n    builder\n      .setTitle(IdeBundle.message(\"action.create.new.class\"))\n      .addKind(\"Class\", Icons.CLASS_ICON, JavaTemplateUtil.INTERNAL_CLASS_TEMPLATE_NAME)\n      .addKind(\"Interface\", Icons.INTERFACE_ICON, JavaTemplateUtil.INTERNAL_INTERFACE_TEMPLATE_NAME);\n    if (LanguageLevelProjectExtension.getInstance(project).getLanguageLevel().compareTo(LanguageLevel.JDK_1_5) >= 0) {\n      builder.addKind(\"Enum\", Icons.ENUM_ICON, JavaTemplateUtil.INTERNAL_ENUM_TEMPLATE_NAME);\n      builder.addKind(\"Annotation\", Icons.ANNOTATION_TYPE_ICON, JavaTemplateUtil.INTERNAL_ANNOTATION_TYPE_TEMPLATE_NAME);\n    }\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T extends PsiElement> Builder createDialog(@NotNull final Project project, @NotNull final String title) {\n    final CreateFileFromTemplateDialog dialog = new CreateFileFromTemplateDialog(project, title);\n\n    return new Builder() {\n\n      public Builder addKind(@NotNull String name, @Nullable Icon icon, @NotNull String templateName) {\n        dialog.myKindCombo.addItem(new Trinity<String, Icon, String>(name, icon, templateName));\n        return this;\n      }\n\n      public <T extends PsiElement> T show(@NotNull String errorTitle, @Nullable String selectedTemplateName,\n                                           @NotNull final FileCreator<T> creator) {\n        final Ref<T> created = Ref.create(null);\n        if (selectedTemplateName != null) {\n          Object item = null;\n          ComboBoxModel model = dialog.myKindCombo.getModel();\n          for (int i = 0, n = model.getSize(); i < n; i++) {\n            Trinity<String, Icon, String> trinity = (Trinity<String, Icon, String>)model.getElementAt(i);\n            if (selectedTemplateName.equals(trinity.third)) {\n              item = trinity;\n              break;\n            }\n          }\n          if (item != null) {\n            dialog.myKindCombo.setSelectedItem(item);\n          }\n        }\n        dialog.myCreator = new ElementCreator(project, errorTitle) {\n          @Override\n          protected void checkBeforeCreate(String newName) throws IncorrectOperationException {\n            creator.checkBeforeCreate(newName, dialog.getTemplateName());\n          }\n\n          @Override\n          protected PsiElement[] create(String newName) throws Exception {\n            final T element = creator.createFile(dialog.getEnteredName(), dialog.getTemplateName());\n            created.set(element);\n            if (element != null) {\n              return new PsiElement[]{element};\n            }\n            return PsiElement.EMPTY_ARRAY;\n          }\n\n          @Override\n          protected String getActionName(String newName) {\n            return creator.getActionName(newName, dialog.getTemplateName());\n          }\n        };\n        dialog.show();\n        if (dialog.getExitCode() == OK_EXIT_CODE) {\n          return created.get();\n        }\n        return null;\n      }\n    };\n  }","id":106601,"modified_method":"public static <T extends PsiElement> Builder createDialog(@NotNull final Project project) {\n    final CreateFileFromTemplateDialog dialog = new CreateFileFromTemplateDialog(project);\n\n    return new Builder() {\n\n      @Override\n      public Builder setTitle(String title) {\n        dialog.setTitle(title);\n        return this;\n      }\n\n      public Builder addKind(@NotNull String name, @Nullable Icon icon, @NotNull String templateName) {\n        dialog.myKindCombo.addItem(new Trinity<String, Icon, String>(name, icon, templateName));\n        return this;\n      }\n\n      public <T extends PsiElement> T show(@NotNull String errorTitle, @Nullable String selectedTemplateName,\n                                           @NotNull final FileCreator<T> creator) {\n        final Ref<T> created = Ref.create(null);\n        if (selectedTemplateName != null) {\n          Object item = null;\n          ComboBoxModel model = dialog.myKindCombo.getModel();\n          for (int i = 0, n = model.getSize(); i < n; i++) {\n            Trinity<String, Icon, String> trinity = (Trinity<String, Icon, String>)model.getElementAt(i);\n            if (selectedTemplateName.equals(trinity.third)) {\n              item = trinity;\n              break;\n            }\n          }\n          if (item != null) {\n            dialog.myKindCombo.setSelectedItem(item);\n          }\n        }\n        dialog.myCreator = new ElementCreator(project, errorTitle) {\n          @Override\n          protected void checkBeforeCreate(String newName) throws IncorrectOperationException {\n            creator.checkBeforeCreate(newName, dialog.getTemplateName());\n          }\n\n          @Override\n          protected PsiElement[] create(String newName) throws Exception {\n            final T element = creator.createFile(dialog.getEnteredName(), dialog.getTemplateName());\n            created.set(element);\n            if (element != null) {\n              return new PsiElement[]{element};\n            }\n            return PsiElement.EMPTY_ARRAY;\n          }\n\n          @Override\n          protected String getActionName(String newName) {\n            return creator.getActionName(newName, dialog.getTemplateName());\n          }\n        };\n        dialog.show();\n        if (dialog.getExitCode() == OK_EXIT_CODE) {\n          return created.get();\n        }\n        return null;\n      }\n    };\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CreateFileFromTemplateDialog(@NotNull Project project, @NotNull final String title) {\n    super(project, true);\n\n    myKindCombo.setRenderer(new DefaultListCellRenderer() {\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        @SuppressWarnings({\"unchecked\"}) Trinity<String, Icon, String> trinity = (Trinity<String, Icon, String>) value;\n        setText(trinity == null ? \"\" : trinity.first);\n        setIcon(trinity == null ? null : trinity.second);\n        return this;\n      }\n    });\n\n    setTitle(title);\n    //myNameLabel.setText(prompt);\n\n    new ComboboxSpeedSearch(myKindCombo) {\n      @Override\n      protected String getElementText(Object element) {\n        return ((Trinity<String, Icon, String>)element).first;\n      }\n    };\n\n    final AnAction arrow = new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        if (e.getInputEvent() instanceof KeyEvent) {\n          final int code = ((KeyEvent)e.getInputEvent()).getKeyCode();\n          final int delta = code == KeyEvent.VK_DOWN ? 1 : code == KeyEvent.VK_UP ? -1 : 0;\n\n          final int size = myKindCombo.getModel().getSize();\n          int next = myKindCombo.getSelectedIndex() + delta;\n          if (next < 0 || next >= size) {\n            if (!UISettings.getInstance().CYCLE_SCROLLING) {\n              return;\n            }\n            next = (next + size) % size;\n          }\n          myKindCombo.setSelectedIndex(next);\n        }\n      }\n    };\n    final KeyboardShortcut up = new KeyboardShortcut(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), null);\n    final KeyboardShortcut down = new KeyboardShortcut(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), null);\n    arrow.registerCustomShortcutSet(new CustomShortcutSet(up, down), myNameField);\n\n    myUpDownHint.setIcon(Icons.UP_DOWN_ARROWS);\n    init();\n  }","id":106602,"modified_method":"private CreateFileFromTemplateDialog(@NotNull Project project) {\n    super(project, true);\n\n    myKindCombo.setRenderer(new DefaultListCellRenderer() {\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        @SuppressWarnings({\"unchecked\"}) Trinity<String, Icon, String> trinity = (Trinity<String, Icon, String>) value;\n        setText(trinity == null ? \"\" : trinity.first);\n        setIcon(trinity == null ? null : trinity.second);\n        return this;\n      }\n    });\n\n      //myNameLabel.setText(prompt);\n\n    new ComboboxSpeedSearch(myKindCombo) {\n      @Override\n      protected String getElementText(Object element) {\n        return ((Trinity<String, Icon, String>)element).first;\n      }\n    };\n\n    final AnAction arrow = new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        if (e.getInputEvent() instanceof KeyEvent) {\n          final int code = ((KeyEvent)e.getInputEvent()).getKeyCode();\n          final int delta = code == KeyEvent.VK_DOWN ? 1 : code == KeyEvent.VK_UP ? -1 : 0;\n\n          final int size = myKindCombo.getModel().getSize();\n          int next = myKindCombo.getSelectedIndex() + delta;\n          if (next < 0 || next >= size) {\n            if (!UISettings.getInstance().CYCLE_SCROLLING) {\n              return;\n            }\n            next = (next + size) % size;\n          }\n          myKindCombo.setSelectedIndex(next);\n        }\n      }\n    };\n    final KeyboardShortcut up = new KeyboardShortcut(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), null);\n    final KeyboardShortcut down = new KeyboardShortcut(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), null);\n    arrow.registerCustomShortcutSet(new CustomShortcutSet(up, down), myNameField);\n\n    myUpDownHint.setIcon(Icons.UP_DOWN_ARROWS);\n    init();\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected abstract CreateFileFromTemplateDialog.Builder buildDialog(Project project, PsiDirectory directory);","id":106603,"modified_method":"protected abstract void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder);","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract String getErrorTitle();","id":106604,"modified_method":"protected String getErrorTitle() {\n    return CommonBundle.getErrorTitle();\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected String getDefaultTempalteName(@NotNull PsiDirectory dir) {\n    return null;\n  }","id":106605,"modified_method":"@Nullable\n  protected String getDefaultTemplateName(@NotNull PsiDirectory dir) {\n    return null;\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    final IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n    if (view == null) {\n      return;\n    }\n\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    final PsiDirectory dir = view.getOrChooseDirectory();\n    if (dir == null) return;\n\n    final T createdElement =\n      buildDialog(project, dir).show(getErrorTitle(), getDefaultTempalteName(dir), new CreateFileFromTemplateDialog.FileCreator<T>() {\n        public void checkBeforeCreate(@NotNull String name, @NotNull String templateName) {\n          CreateFromTemplateAction.this.checkBeforeCreate(name, templateName, dir);\n        }\n\n        public T createFile(@NotNull String name, @NotNull String templateName) {\n          return CreateFromTemplateAction.this.createFile(name, templateName, dir);\n        }\n\n        @NotNull\n        public String getActionName(@NotNull String name, @NotNull String templateName) {\n          return CreateFromTemplateAction.this.getActionName(dir, name, templateName);\n        }\n      });\n    if (createdElement != null) {\n      view.selectElement(createdElement);\n    }\n  }","id":106606,"modified_method":"public final void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n\n    final IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n    if (view == null) {\n      return;\n    }\n\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    final PsiDirectory dir = view.getOrChooseDirectory();\n    if (dir == null || project == null) return;\n\n    final CreateFileFromTemplateDialog.Builder builder = CreateFileFromTemplateDialog.createDialog(project);\n    buildDialog(project, dir, builder);\n\n    final T createdElement =\n      builder.show(getErrorTitle(), getDefaultTemplateName(dir), new CreateFileFromTemplateDialog.FileCreator<T>() {\n        public void checkBeforeCreate(@NotNull String name, @NotNull String templateName) {\n          CreateFromTemplateAction.this.checkBeforeCreate(name, templateName, dir);\n        }\n\n        public T createFile(@NotNull String name, @NotNull String templateName) {\n          return CreateFromTemplateAction.this.createFile(name, templateName, dir);\n        }\n\n        @NotNull\n        public String getActionName(@NotNull String name, @NotNull String templateName) {\n          return CreateFromTemplateAction.this.getActionName(dir, name, templateName);\n        }\n      });\n    if (createdElement != null) {\n      view.selectElement(createdElement);\n    }\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected CreateFileFromTemplateDialog.Builder buildDialog(Project project, PsiDirectory directory) {\n    final CreateFileFromTemplateDialog.Builder builder =\n      CreateFileFromTemplateDialog.createDialog(project, XmlBundle.message(\"new.html.file.action\"));\n    builder.addKind(\"HTML file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_HTML_TEMPLATE_NAME);\n    builder.addKind(\"HTML5 file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_HTML5_TEMPLATE_NAME);\n    builder.addKind(\"XHTML file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_XHTML_TEMPLATE_NAME);\n    return builder;\n  }","id":106607,"modified_method":"@Override\n  protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n    builder\n      .setTitle(XmlBundle.message(\"new.html.file.action\"))\n      .addKind(\"HTML file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_HTML_TEMPLATE_NAME)\n      .addKind(\"HTML5 file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_HTML5_TEMPLATE_NAME)\n      .addKind(\"XHTML file\", StdFileTypes.HTML.getIcon(), FileTemplateManager.INTERNAL_XHTML_TEMPLATE_NAME);\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected PsiFile createFile(String name, String templateName, PsiDirectory dir) {\n    PropertiesComponent.getInstance(dir.getProject()).setValue(DEFAULT_HTML_TEMPLATE_PROPERTY, templateName);\n\n    final FileTemplate template = FileTemplateManager.getInstance().getInternalTemplate(templateName);\n\n    PsiElement element;\n    try {\n      element = FileTemplateUtil\n        .createFromTemplate(template, name, FileTemplateManager.getInstance().getDefaultProperties(), dir);\n      final PsiFile psiFile = element.getContainingFile();\n\n      final VirtualFile virtualFile = psiFile.getVirtualFile();\n      if (virtualFile != null) {\n        FileEditorManager.getInstance(dir.getProject()).openFile(virtualFile, true);\n        return psiFile;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","id":106608,"modified_method":"@Override\n  protected PsiFile createFile(String name, String templateName, PsiDirectory dir) {\n    PropertiesComponent.getInstance(dir.getProject()).setValue(DEFAULT_HTML_TEMPLATE_PROPERTY, templateName);\n\n    return createFileFromTemplate(name, templateName, dir);\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getDefaultTempalteName(@NotNull PsiDirectory dir) {\n    return PropertiesComponent.getInstance(dir.getProject()).getValue(DEFAULT_HTML_TEMPLATE_PROPERTY);\n  }","id":106609,"modified_method":"@Override\n  protected String getDefaultTemplateName(@NotNull PsiDirectory dir) {\n    return PropertiesComponent.getInstance(dir.getProject()).getValue(DEFAULT_HTML_TEMPLATE_PROPERTY);\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected CreateFileFromTemplateDialog.Builder buildDialog(Project project, final PsiDirectory directory) {\n    final CreateFileFromTemplateDialog.Builder builder = CreateFileFromTemplateDialog.\n      createDialog(project, GroovyBundle.message(\"newclass.dlg.title\"));\n    builder.addKind(\"Class\", GroovyIcons.CLASS, \"GroovyClass.groovy\");\n    builder.addKind(\"Interface\", GroovyIcons.INTERFACE, \"GroovyInterface.groovy\");\n    builder.addKind(\"Enum\", GroovyIcons.ENUM, \"GroovyEnum.groovy\");\n    builder.addKind(\"Annotation\", GroovyIcons.ANNOTATION_TYPE, \"GroovyAnnotation.groovy\");\n    return builder;\n  }","id":106610,"modified_method":"@Override\n  protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n    builder\n      .setTitle(GroovyBundle.message(\"newclass.dlg.title\"))\n      .addKind(\"Class\", GroovyIcons.CLASS, \"GroovyClass.groovy\")\n      .addKind(\"Interface\", GroovyIcons.INTERFACE, \"GroovyInterface.groovy\")\n      .addKind(\"Enum\", GroovyIcons.ENUM, \"GroovyEnum.groovy\")\n      .addKind(\"Annotation\", GroovyIcons.ANNOTATION_TYPE, \"GroovyAnnotation.groovy\");\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected CreateFileFromTemplateDialog.Builder buildDialog(Project project, final PsiDirectory directory) {\n    final CreateFileFromTemplateDialog.Builder builder = CreateFileFromTemplateDialog.\n      createDialog(project, GroovyBundle.message(\"newscript.dlg.prompt\"));\n    builder.addKind(\"Groovy script\", GroovyIcons.GROOVY_ICON_16x16, \"GroovyScript.groovy\");\n    builder.addKind(\"GroovyDSL script\", GroovyIcons.GROOVY_ICON_16x16, GROOVY_DSL_SCRIPT_TMPL);\n    return builder;\n  }","id":106611,"modified_method":"@Override\n  protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n    builder\n      .setTitle(GroovyBundle.message(\"newscript.dlg.prompt\"))\n      .addKind(\"Groovy script\", GroovyIcons.GROOVY_ICON_16x16, \"GroovyScript.groovy\")\n      .addKind(\"GroovyDSL script\", GroovyIcons.GROOVY_ICON_16x16, GROOVY_DSL_SCRIPT_TMPL);\n  }","commit_id":"7203ccf4565779160d8cbb2828b5d5fb733fbf6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkStructuredDateDefinitions(ServletRequest request, MutablePropertyValues mpvs) {\n\n        PropertyValue[] pvs = mpvs.getPropertyValues();\n        for (int i = 0; i < pvs.length; i++) {\n            PropertyValue pv = pvs[i];\n\n            try {\n                String propertyName = pv.getName();\n                Class type = bean.getPropertyType(propertyName);\n                // if its a date check that it hasn't got structured parameters in the request\n                // this is used as an alternative to specifying the date format\n                if(type == Date.class || type == Calendar.class) {\n                    try {\n                           // The request will always include the year value\n                    \tString yearString = request.getParameter(propertyName + \"_year\");\n                    \tint year;\n                    \t\n                    \tif(StringUtils.isBlank(yearString)) {\n                            Calendar now = Calendar.getInstance(RequestContextUtils.getLocale((HttpServletRequest) request));\n                            year = now.get(Calendar.YEAR);\n                    \t}\n                    \telse {\n                    \t\tyear = Integer.parseInt(yearString);\n                    \t}\n\n                        // The request may not include the other date values, so be prepared to use the\n                        // default values.  Default values --> month = January; day = 1st day of the month;\n                        // hour = 00; minute = 00.\n                        int month = Integer.parseInt(getParameterValue(request, propertyName + \"_month\",\"1\"));\n                        int day = Integer.parseInt(getParameterValue(request, propertyName + \"_day\",\"1\"));\n                        int hour = Integer.parseInt(getParameterValue(request, propertyName + \"_hour\",\"0\"));\n                        int minute = Integer.parseInt(getParameterValue(request, propertyName + \"_minute\",\"0\"));\n\n                        Calendar c = new GregorianCalendar(year,month - 1,day,hour,minute);\n                        if(type == Date.class)\n                            mpvs.setPropertyValueAt(new PropertyValue(propertyName,c.getTime()),i);\n                        else\n                            mpvs.setPropertyValueAt(new PropertyValue(propertyName,c),i);\n                    }\n                    catch(NumberFormatException nfe) {\n                         LOG.warn(\"Unable to parse structured date from request for date [\"+propertyName+\"]\",nfe);\n                    }\n                }\n            }\n            catch(InvalidPropertyException ipe) {\n                // ignore\n            }\n        }\n    }","id":106612,"modified_method":"private void checkStructuredDateDefinitions(ServletRequest request, MutablePropertyValues propertyValues) {\n        PropertyValue[] pvs = propertyValues.getPropertyValues();\n        for (int i = 0; i < pvs.length; i++) {\n            PropertyValue propertyValue = pvs[i];\n\n            try {\n                String propertyName = propertyValue.getName();\n                Class type = bean.getPropertyType(propertyName);\n                // if its a date check that it hasn't got structured parameters in the request\n                // this is used as an alternative to specifying the date format\n                if(type == Date.class || type == Calendar.class) {\n                    try {\n                        PropertyValue yearProperty = propertyValues.getPropertyValue(propertyName + \"_year\");\n                        // The request will always include the year value\n                        String yearString = (String) yearProperty.getValue();\n                        int year;\n\n                        if(StringUtils.isBlank(yearString)) {\n                            Calendar now = Calendar.getInstance(RequestContextUtils.getLocale((HttpServletRequest) request));\n                            year = now.get(Calendar.YEAR);\n                        }\n                        else {\n                            year = Integer.parseInt(yearString);\n                        }\n\n                        int month = getIntegerPropertyValue(propertyValues, propertyName + \"_month\", 1);\n                        int day = getIntegerPropertyValue(propertyValues, propertyName + \"_day\", 1);\n                        int hour = getIntegerPropertyValue(propertyValues, propertyName + \"_hour\", 0);\n                        int minute = getIntegerPropertyValue(propertyValues, propertyName + \"_minute\", 0);\n\n                        Calendar c = new GregorianCalendar(year,month - 1,day,hour,minute);\n                        if(type == Date.class)\n                            propertyValues.setPropertyValueAt(new PropertyValue(propertyName,c.getTime()),i);\n                        else\n                            propertyValues.setPropertyValueAt(new PropertyValue(propertyName,c),i);\n                    }\n                    catch(NumberFormatException nfe) {\n                        LOG.warn(\"Unable to parse structured date from request for date [\"+propertyName+\"]\",nfe);\n                    }\n                }\n            }\n            catch(InvalidPropertyException ipe) {\n                // ignore\n            }\n        }\n    }","commit_id":"4e65a365ca44ff3be49f818bb7669eb5791aab12","url":"https://github.com/grails/grails-core"},{"original_method":"public void bind(MutablePropertyValues propertyValues) {\n        checkStructuredDateDefinitions(propertyValues);\n        super.bind(propertyValues);\n    }","id":106613,"modified_method":"public void bind(PropertyValues propertyValues) {\n        GrailsWebRequest webRequest = (GrailsWebRequest) RequestContextHolder.getRequestAttributes();\n        if(webRequest != null && propertyValues instanceof MutablePropertyValues) {\n            ServletRequest request = webRequest.getCurrentRequest();\n            checkStructuredDateDefinitions(request, (MutablePropertyValues) propertyValues);\n        }\n        super.bind(propertyValues);\n    }","commit_id":"4e65a365ca44ff3be49f818bb7669eb5791aab12","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Get a naming service instance. This method ensures that there\n     * will be only one naming service instance (singleton) as well as\n     * choose the implementation from the \"i2p.naming.impl\" system\n     * property.\n     *\n     * FIXME Actually, it doesn't ensure that. Only call this once!!!\n     */\n    public static final synchronized NamingService createInstance(I2PAppContext context) {\n        NamingService instance = null;\n        String impl = context.getProperty(PROP_IMPL, DEFAULT_IMPL);\n        try {\n            Class cls = Class.forName(impl);\n            Constructor con = cls.getConstructor(new Class[] { I2PAppContext.class });\n            instance = (NamingService)con.newInstance(new Object[] { context });\n        } catch (Exception ex) {\n            Log log = context.logManager().getLog(NamingService.class);\n            log.error(\"Cannot load naming service \" + impl + \", only .b32.i2p lookups will succeed\", ex);\n            instance = new DummyNamingService(context); // fallback\n        }\n        return instance;\n    }","id":106614,"modified_method":"/**\n     * Get a naming service instance. This method ensures that there\n     * will be only one naming service instance (singleton) as well as\n     * choose the implementation from the \"i2p.naming.impl\" system\n     * property.\n     *\n     * FIXME Actually, it doesn't ensure that. Only call this once!!!\n     */\n    public static final synchronized NamingService createInstance(I2PAppContext context) {\n        NamingService instance = null;\n        String impl = context.getProperty(PROP_IMPL, DEFAULT_IMPL);\n        try {\n            Class cls = Class.forName(impl);\n            Constructor con = cls.getConstructor(new Class[] { I2PAppContext.class });\n            instance = (NamingService)con.newInstance(new Object[] { context });\n        } catch (Exception ex) {\n            Log log = context.logManager().getLog(NamingService.class);\n            // Blockfile may throw RuntimeException but HostsTxt won't\n            if (!impl.equals(BACKUP_IMPL)) {\n                log.error(\"Cannot load naming service \" + impl + \", using HostsTxtNamingService\", ex);\n                instance = new HostsTxtNamingService(context);\n            } else {\n                log.error(\"Cannot load naming service \" + impl + \", only .b32.i2p lookups will succeed\", ex);\n                instance = new DummyNamingService(context);\n            }\n        }\n        return instance;\n    }","commit_id":"4f3c15eb042969c3945a48867eeded454893c0c6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public synchronized void remove(PersistentBlobTempBucket bucket, ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" from database\", new Exception(\"debug\"));\n\t\tlong index = bucket.index;\n\t\tPersistentBlobTempBucketTag tag = bucket.tag;\n\t\tif(tag == null) {\n\t\t\tif(!container.ext().isActive(bucket)) {\n\t\t\t\tLogger.error(this, \"BUCKET NOT ACTIVE IN REMOVE: \"+bucket, new Exception(\"error\"));\n\t\t\t\tcontainer.activate(bucket, 1);\n\t\t\t\ttag = bucket.tag;\n\t\t\t\tindex = bucket.index;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"NO TAG ON BUCKET REMOVING: \"+bucket, new Exception(\"error\"));\n\t\t\t}\n\t\t}\n\t\tcontainer.activate(tag, 1);\n\t\tif(!bucket.persisted()) {\n\t\t\tmaybeShrink(container);\n\t\t\treturn;\n\t\t}\n\t\tif(!bucket.freed()) {\n\t\t\tLogger.error(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" but not freed!\", new Exception(\"debug\"));\n\t\t\tnotCommittedBlobs.put(index, bucket);\n\t\t} else {\n\t\t\talmostFreeSlots.put(index, tag);\n\t\t}\n\t\ttag.bucket = null;\n\t\ttag.isFree = true;\n\t\tcontainer.store(tag);\n\t\tcontainer.delete(bucket);\n\t\tbucket.onRemove();\n\t\t\n\t\tmaybeShrink(container);\n\t}","id":106615,"modified_method":"public synchronized void remove(PersistentBlobTempBucket bucket, ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" from database\", new Exception(\"debug\"));\n\t\tlong index = bucket.index;\n\t\tPersistentBlobTempBucketTag tag = bucket.tag;\n\t\tif(tag == null) {\n\t\t\tif(!container.ext().isActive(bucket)) {\n\t\t\t\tLogger.error(this, \"BUCKET NOT ACTIVE IN REMOVE: \"+bucket, new Exception(\"error\"));\n\t\t\t\tcontainer.activate(bucket, 1);\n\t\t\t\ttag = bucket.tag;\n\t\t\t\tindex = bucket.index;\n\t\t\t} else {\n\t\t\t\t// THIS IS IMPOSSIBLE, yet saces has seen it in practice ... lets get some detail...\n\t\t\t\tLogger.error(this, \"NO TAG ON BUCKET REMOVING: \"+bucket+\" index \"+index, new Exception(\"error\"));\n\t\t\t\tQuery query = container.query();\n\t\t\t\tquery.constrain(PersistentBlobTempBucketTag.class);\n\t\t\t\tquery.descend(\"index\").constrain(index);\n\t\t\t\tObjectSet<PersistentBlobTempBucketTag> results = query.execute();\n\t\t\t\tif(!results.hasNext()) {\n\t\t\t\t\tLogger.error(this, \"TAG DOES NOT EXIST FOR INDEX \"+index);\n\t\t\t\t} else {\n\t\t\t\t\ttag = results.next();\n\t\t\t\t\tif(tag.index != index)\n\t\t\t\t\t\t// Crazy things are happening, may as well check the impossible!\n\t\t\t\t\t\tLogger.error(this, \"INVALID INDEX: should be \"+index+\" but is \"+tag.index);\n\t\t\t\t\tif(tag.isFree)\n\t\t\t\t\t\tLogger.error(this, \"FOUND TAG BUT IS FREE: \"+tag);\n\t\t\t\t\tif(tag.bucket == null) {\n\t\t\t\t\t\tLogger.error(this, \"FOUND TAG BUT NO BUCKET: \"+tag);\n\t\t\t\t\t} else if(tag.bucket == bucket) {\n\t\t\t\t\t\tLogger.error(this, \"TAG LINKS TO BUCKET BUT BUCKET DOESN'T LINK TO TAG\");\n\t\t\t\t\t} else { // tag.bucket != bucket\n\t\t\t\t\t\tLogger.error(this, \"SERIOUS ERROR: TAG BELONGS TO A DIFFERENT BUCKET!!!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcontainer.activate(tag, 1);\n\t\tif(!bucket.persisted()) {\n\t\t\tmaybeShrink(container);\n\t\t\treturn;\n\t\t}\n\t\tif(!bucket.freed()) {\n\t\t\tLogger.error(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" but not freed!\", new Exception(\"debug\"));\n\t\t\tnotCommittedBlobs.put(index, bucket);\n\t\t} else {\n\t\t\talmostFreeSlots.put(index, tag);\n\t\t}\n\t\ttag.bucket = null;\n\t\ttag.isFree = true;\n\t\tcontainer.store(tag);\n\t\tcontainer.delete(bucket);\n\t\tbucket.onRemove();\n\t\t\n\t\tmaybeShrink(container);\n\t}","commit_id":"5f2d82dae65b26351fc8975c89a1fbb01de329e3","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFrom(ObjectContainer container) {\n\t\tif(blocks != null) {\n\t\t\tfor(Block block : blocks) {\n\t\t\t\tcontainer.activate(block, 1);\n\t\t\t\tfor(RandomGrabArrayItem item : block.reqs) {\n\t\t\t\t\tif(item != null) {\n\t\t\t\t\t\tLogger.error(this, \"VALID ITEM WHILE DELETING BLOCK: \"+item+\" on \"+this, new Exception(\"error\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontainer.delete(block);\n\t\t\t}\n\t\t}\n\t\tcontainer.delete(this);\n\t}","id":106616,"modified_method":"public void removeFrom(ObjectContainer container) {\n\t\tif(blocks != null) {\n\t\t\tint count = 0;\n\t\t\tfor(Block block : blocks) {\n\t\t\t\tcontainer.activate(block, 1);\n\t\t\t\tfor(RandomGrabArrayItem item : block.reqs) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(item != null) {\n\t\t\t\t\t\tif(count > index)\n\t\t\t\t\t\t\tLogger.error(this, \"ITEM AT INDEX \"+count+\" EVEN THOUGH MAX INDEX IS \"+index);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLogger.error(this, \"VALID ITEM WHILE DELETING BLOCK: \"+item+\" on \"+this, new Exception(\"error\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontainer.delete(block);\n\t\t\t}\n\t\t}\n\t\tcontainer.delete(this);\n\t}","commit_id":"5a54bece293ad28b3ad948a58749fc6fe5a64b27","url":"https://github.com/freenet/fred"},{"original_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, boolean bothNoderefs)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000)\n\t\t\t\tLogger.minor(this, error);\n\t\t\telse\n\t\t\t\tLogger.error(this, error);\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // the signature\n\t\t\t\t\t\t\t\t\t(bothNoderefs ? pn.jfkMyRef.length : 0) + // my reference\n\t\t\t\t\t\t\t\t\t8 // bootID\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length - (bothNoderefs ? pn.jfkMyRef.length : 0) - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length + 8 /*bootID*/ + hisRef.length + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, hisRef.length + 8);\n\t\tbufferOffset += hisRef.length + 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tbyte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t\n\t\t// cleanup\n                // FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","id":106617,"modified_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, boolean bothNoderefs)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000)\n\t\t\t\tLogger.minor(this, error);\n\t\t\telse\n\t\t\t\tLogger.error(this, error);\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tNode.SIGNATURE_PARAMETER_LENGTH * 2 + // the signature\n\t\t\t\t\t\t\t\t\t(bothNoderefs ? pn.jfkMyRef.length : 0) + // my reference\n\t\t\t\t\t\t\t\t\t8 // bootID\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tif(!bothNoderefs)\n\t\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tif(data.length - (bothNoderefs ? pn.jfkMyRef.length : 0) - 8 < 0) {\n\t\t\tLogger.error(this, \"No space for hisRef: bothNoderefs=\"+bothNoderefs+\" data.length=\"+data.length+\" myRef.length=\"+(pn.jfkMyRef==null?0:pn.jfkMyRef.length)+\" orig data length \"+(payload.length-inputOffset));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] hisRef = new byte[data.length - (bothNoderefs ? pn.jfkMyRef.length : 0) - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length + 8 /*bootID*/ + hisRef.length + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, hisRef.length + 8);\n\t\tbufferOffset += hisRef.length + 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tbyte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t\n\t\t// cleanup\n                // FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","commit_id":"716e0a88a6e3380b7779affc4d6abcfac681ca31","url":"https://github.com/freenet/fred"},{"original_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t}\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t\t// But they should be active.\n\t\t\t\t\tif(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive!\");\n\t\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\t\telse\n\t\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(dataBlockStatus[i], 1);\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(persistent).makeBucket(maxBlockLength * dataBuckets.length);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from \"+dataBuckets.length+\" data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from block \"+i);\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(status == null) throw new NullPointerException();\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(data == null) throw new NullPointerException();\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tBucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(codec == null || !isCollectingBinaryBlob(parent))\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.store(this);\n\t\t\t// Leave active before queueing\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.store(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\treturn;\n\t\t}\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\n\t\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t}","id":106618,"modified_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t}\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t\t// But they should be active.\n\t\t\t\t\tif(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive!\");\n\t\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\t\telse if(dataBuckets[i].data == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" has null data!\");\n\t\t\t\t\telse\n\t\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(dataBlockStatus[i], 1);\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(persistent).makeBucket(maxBlockLength * dataBuckets.length);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from \"+dataBuckets.length+\" data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from block \"+i);\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(status == null) throw new NullPointerException();\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(data == null) throw new NullPointerException();\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tBucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(codec == null || !isCollectingBinaryBlob(parent))\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.store(this);\n\t\t\t// Leave active before queueing\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.store(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\treturn;\n\t\t}\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\n\t\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t}","commit_id":"044caf0a6043f518ae7db873b4fb5602bc3c4aa8","url":"https://github.com/freenet/fred"},{"original_method":"@Nullable\n    public String getContent() throws VcsException {\n      if (myContent == null) {\n        try {\n          myContent = getLastUpToDateContentFor(myFile.getIOFile(), myFile.getCharset().name());\n        }\n        catch(Exception ex) {\n          throw new VcsException(ex);\n        }\n      }\n      return myContent;\n    }","id":106619,"modified_method":"@Nullable\n    public String getContent() throws VcsException {\n      if (myContent == null) {\n        try {\n          myContent = new String(getUpToDateBinaryContent(), myFile.getCharset().name());\n        }\n        catch(Exception ex) {\n          throw new VcsException(ex);\n        }\n      }\n      return myContent;\n    }","commit_id":"2fe0423180832c4093baa0f8febd1ac012e7872a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SvnUpToDateRevision(@NotNull final FilePath file, final SVNRevision revision) {\n      myFile = file;\n      myRevNumber = new SvnRevisionNumber(revision);\n    }","id":106620,"modified_method":"protected SvnUpToDateRevision(@NotNull final FilePath file, final SVNRevision revision) {\n      myFile = file;\n      myRevNumber = new SvnRevisionNumber(revision);\n    }","commit_id":"2fe0423180832c4093baa0f8febd1ac012e7872a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) throws SVNException {\n    loadEntriesFile(filePath);\n    if (status != null) {\n      FileStatus fStatus = convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath);\n      }\n      else if (statusType == SVNStatusType.STATUS_IGNORED) {\n        builder.processIgnoredFile(filePath.getVirtualFile());\n      }\n      else if (fStatus == FileStatus.NOT_CHANGED && statusType != SVNStatusType.STATUS_NONE) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n          builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), FileStatus.MODIFIED));\n        }\n      }\n    }\n  }","id":106621,"modified_method":"private static void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) throws SVNException {\n    loadEntriesFile(filePath);\n    if (status != null) {\n      FileStatus fStatus = convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(SvnUpToDateRevision.create(filePath, status.getRevision()),\n                                         CurrentContentRevision.create(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, CurrentContentRevision.create(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(SvnUpToDateRevision.create(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath);\n      }\n      else if (statusType == SVNStatusType.STATUS_IGNORED) {\n        builder.processIgnoredFile(filePath.getVirtualFile());\n      }\n      else if (fStatus == FileStatus.NOT_CHANGED && statusType != SVNStatusType.STATUS_NONE) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n          builder.processChange(new Change(SvnUpToDateRevision.create(filePath, status.getRevision()),\n                                           CurrentContentRevision.create(filePath), FileStatus.MODIFIED));\n        }\n      }\n    }\n  }","commit_id":"2fe0423180832c4093baa0f8febd1ac012e7872a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void getChanges(final VcsDirtyScope dirtyScope, final ChangelistBuilder builder, ProgressIndicator progress) throws VcsException {\n    try {\n      final SVNStatusClient client = myVcs.createStatusClient();\n      final List<SvnChangedFile> copiedFiles = new ArrayList<SvnChangedFile>();\n      final List<SvnChangedFile> deletedFiles = new ArrayList<SvnChangedFile>();\n      for (FilePath path : dirtyScope.getRecursivelyDirtyDirectories()) {\n        processFile(path, client, builder, copiedFiles, deletedFiles, true);\n      }\n\n      for (FilePath path : dirtyScope.getDirtyFiles()) {\n        processFile(path, client, builder, copiedFiles, deletedFiles, false);\n      }\n\n      for(SvnChangedFile copiedFile: copiedFiles) {\n        boolean foundRename = false;\n        final SVNStatus copiedStatus = copiedFile.getStatus();\n        for (Iterator<SvnChangedFile> iterator = deletedFiles.iterator(); iterator.hasNext();) {\n          SvnChangedFile deletedFile = iterator.next();\n          final SVNStatus deletedStatus = deletedFile.getStatus();\n          if (copiedStatus.getCopyFromURL().equals(deletedStatus.getURL().toString())) {\n            builder.processChange(new Change(new SvnUpToDateRevision(deletedFile.getFilePath(), deletedStatus.getRevision()),\n                                             CurrentContentRevision.create(copiedFile.getFilePath())));\n            iterator.remove();\n            foundRename = true;\n            break;\n          }\n        }\n\n        // handle the case when the deleted file wasn't included in the dirty scope - try searching for the local copy\n        // by building a relative url\n        if (!foundRename) {\n          File wcPath = guessWorkingCopyPath(copiedStatus.getFile(), copiedStatus.getURL(), copiedStatus.getCopyFromURL());\n          SVNStatus status;\n          try {\n            status = client.doStatus(wcPath, false);\n          }\n          catch(SVNException ex) {\n            status = null;\n          }\n          if (status != null && status.getContentsStatus() == SVNStatusType.STATUS_DELETED) {\n            final FilePath filePath = myFactory.createFilePathOnDeleted(wcPath, false);\n            final SvnUpToDateRevision beforeRevision = new SvnUpToDateRevision(filePath, status.getRevision());\n            final ContentRevision afterRevision = CurrentContentRevision.create(copiedFile.getFilePath());\n            builder.processChange(new Change(beforeRevision, afterRevision));\n            foundRename = true;\n          }\n        }\n\n        if (!foundRename) {\n          processStatus(copiedFile.getFilePath(), copiedStatus, builder);\n        }\n      }\n      for(SvnChangedFile deletedFile: deletedFiles) {\n        processStatus(deletedFile.getFilePath(), deletedFile.getStatus(), builder);\n      }\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","id":106622,"modified_method":"public void getChanges(final VcsDirtyScope dirtyScope, final ChangelistBuilder builder, ProgressIndicator progress) throws VcsException {\n    try {\n      final SVNStatusClient client = myVcs.createStatusClient();\n      final List<SvnChangedFile> copiedFiles = new ArrayList<SvnChangedFile>();\n      final List<SvnChangedFile> deletedFiles = new ArrayList<SvnChangedFile>();\n      for (FilePath path : dirtyScope.getRecursivelyDirtyDirectories()) {\n        processFile(path, client, builder, copiedFiles, deletedFiles, true);\n      }\n\n      for (FilePath path : dirtyScope.getDirtyFiles()) {\n        processFile(path, client, builder, copiedFiles, deletedFiles, false);\n      }\n\n      for(SvnChangedFile copiedFile: copiedFiles) {\n        boolean foundRename = false;\n        final SVNStatus copiedStatus = copiedFile.getStatus();\n        for (Iterator<SvnChangedFile> iterator = deletedFiles.iterator(); iterator.hasNext();) {\n          SvnChangedFile deletedFile = iterator.next();\n          final SVNStatus deletedStatus = deletedFile.getStatus();\n          if (copiedStatus.getCopyFromURL().equals(deletedStatus.getURL().toString())) {\n            builder.processChange(new Change(SvnUpToDateRevision.create(deletedFile.getFilePath(), deletedStatus.getRevision()),\n                                             CurrentContentRevision.create(copiedFile.getFilePath())));\n            iterator.remove();\n            foundRename = true;\n            break;\n          }\n        }\n\n        // handle the case when the deleted file wasn't included in the dirty scope - try searching for the local copy\n        // by building a relative url\n        if (!foundRename) {\n          File wcPath = guessWorkingCopyPath(copiedStatus.getFile(), copiedStatus.getURL(), copiedStatus.getCopyFromURL());\n          SVNStatus status;\n          try {\n            status = client.doStatus(wcPath, false);\n          }\n          catch(SVNException ex) {\n            status = null;\n          }\n          if (status != null && status.getContentsStatus() == SVNStatusType.STATUS_DELETED) {\n            final FilePath filePath = myFactory.createFilePathOnDeleted(wcPath, false);\n            final SvnUpToDateRevision beforeRevision = SvnUpToDateRevision.create(filePath, status.getRevision());\n            final ContentRevision afterRevision = CurrentContentRevision.create(copiedFile.getFilePath());\n            builder.processChange(new Change(beforeRevision, afterRevision));\n            foundRename = true;\n          }\n        }\n\n        if (!foundRename) {\n          processStatus(copiedFile.getFilePath(), copiedStatus, builder);\n        }\n      }\n      for(SvnChangedFile deletedFile: deletedFiles) {\n        processStatus(deletedFile.getFilePath(), deletedFile.getStatus(), builder);\n      }\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","commit_id":"2fe0423180832c4093baa0f8febd1ac012e7872a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void switchToTree() {\n    PsiElement element = restoreElement();\n    Document document = getDocumentToSynchronize();\n    if (element != null && document != null) {\n      // switch to tree\n      PsiElement anchor = AnchorElementInfoFactory.getAnchor(element);\n      if (anchor == null) anchor = element;\n      myType = AnchorTypeInfo.obtainInfo(anchor, myType.getFileLanguage());\n      setRange(anchor.getTextRange());\n      myMarkerCache.rangeChanged();\n      myStubElementTypeAndId = pack(-1, null);\n    }\n  }","id":106623,"modified_method":"private void switchToTree() {\n    PsiElement element = restoreElement();\n    if (element != null) {\n      PsiElement anchor = AnchorElementInfoFactory.getAnchor(element);\n      if (anchor == null) anchor = element;\n      myType = AnchorTypeInfo.obtainInfo(anchor, myType.getFileLanguage());\n      setRange(anchor.getTextRange());\n      myMarkerCache.rangeChanged();\n      myStubElementTypeAndId = pack(-1, null);\n    }\n  }","commit_id":"5ce2ec9cb2ec82e603b3d2361d105613431fc184","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean pointsToTheSameElementAs(@NotNull final SmartPointerElementInfo other) {\n    if (other instanceof AnchorElementInfo) {\n      AnchorElementInfo otherAnchor = (AnchorElementInfo)other;\n      if ((getStubId() == -1) != (otherAnchor.getStubId() == -1)) {\n        return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            return Comparing.equal(restoreElement(), other.restoreElement());\n          }\n        });\n      }\n      if (myStubElementTypeAndId != otherAnchor.myStubElementTypeAndId) return false;\n    }\n    return super.pointsToTheSameElementAs(other);\n  }","id":106624,"modified_method":"@Override\n  public boolean pointsToTheSameElementAs(@NotNull final SmartPointerElementInfo other) {\n    if (other instanceof AnchorElementInfo) {\n      if (!getVirtualFile().equals(other.getVirtualFile())) return false;\n\n      long packed1 = myStubElementTypeAndId;\n      long packed2 = ((AnchorElementInfo)other).myStubElementTypeAndId;\n\n      if (packed1 != -1 && packed2 != -1) {\n        return packed1 == packed2;\n      }\n      if (packed1 != -1 || packed2 != -1) {\n        return areRestoredElementsEqual(other);\n      }\n    }\n    return super.pointsToTheSameElementAs(other);\n  }","commit_id":"5ce2ec9cb2ec82e603b3d2361d105613431fc184","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean pointsToTheSameElementAs(@NotNull final SmartPointerElementInfo other) {\n    if (other instanceof SelfElementInfo) {\n      SelfElementInfo otherInfo = (SelfElementInfo)other;\n      Segment range1 = getPsiRange();\n      Segment range2 = otherInfo.getPsiRange();\n      return Comparing.equal(getVirtualFile(), otherInfo.getVirtualFile())\n             && myType == otherInfo.myType\n             && range1 != null\n             && range2 != null\n             && range1.getStartOffset() == range2.getStartOffset()\n             && range1.getEndOffset() == range2.getEndOffset()\n        ;\n    }\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return Comparing.equal(restoreElement(), other.restoreElement());\n      }\n    });\n  }","id":106625,"modified_method":"@Override\n  public boolean pointsToTheSameElementAs(@NotNull final SmartPointerElementInfo other) {\n    if (other instanceof SelfElementInfo) {\n      SelfElementInfo otherInfo = (SelfElementInfo)other;\n      if (!getVirtualFile().equals(other.getVirtualFile()) || myType != otherInfo.myType) return false;\n\n      Segment range1 = getPsiRange();\n      Segment range2 = otherInfo.getPsiRange();\n      return range1 != null && range2 != null\n             && range1.getStartOffset() == range2.getStartOffset()\n             && range1.getEndOffset() == range2.getEndOffset()\n        ;\n    }\n    return areRestoredElementsEqual(other);\n  }","commit_id":"5ce2ec9cb2ec82e603b3d2361d105613431fc184","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    ScheduleSpecification that = (ScheduleSpecification) o;\n\n    return Objects.equal(this.schedule, that.schedule) &&\n      Objects.equal(this.program, that.program) &&\n      Objects.equal(this.properties, that.properties);\n  }","id":106626,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    ScheduleSpecification that = (ScheduleSpecification) o;\n\n    if (!program.equals(that.program) || !properties.equals(that.properties) || !schedule.equals(that.schedule)) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"1d2416505b225c2b902a8f80cd75e13e7bfed377","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"schedule\", schedule)\n      .add(\"program\", program)\n      .add(\"properties\", properties)\n      .toString();\n  }","id":106627,"modified_method":"@Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"ScheduleSpecification{\");\n    sb.append(\"schedule=\").append(schedule);\n    sb.append(\", program=\").append(program);\n    sb.append(\", properties=\").append(properties);\n    sb.append('}');\n    return sb.toString();\n  }","commit_id":"1d2416505b225c2b902a8f80cd75e13e7bfed377","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(schedule, program, properties);\n  }","id":106628,"modified_method":"@Override\n  public int hashCode() {\n    int result = schedule.hashCode();\n    result = 31 * result + program.hashCode();\n    result = 31 * result + properties.hashCode();\n    return result;\n  }","commit_id":"1d2416505b225c2b902a8f80cd75e13e7bfed377","url":"https://github.com/caskdata/cdap"},{"original_method":"protected void reindexCalendarBookings(long companyId)\n\t\tthrows PortalException {\n\n\t\tfinal Collection<Document> documents = new ArrayList<>();\n\n\t\tActionableDynamicQuery actionableDynamicQuery =\n\t\t\t_calendarBookingLocalService.getActionableDynamicQuery();\n\n\t\tactionableDynamicQuery.setAddCriteriaMethod(\n\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tProperty statusProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"status\");\n\n\t\t\t\t\tint[] statuses = {\n\t\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_APPROVED,\n\t\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_MAYBE\n\t\t\t\t\t};\n\n\t\t\t\t\tdynamicQuery.add(statusProperty.in(statuses));\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tactionableDynamicQuery.setPerformActionMethod(\n\t\t\tnew ActionableDynamicQuery.PerformActionMethod<CalendarBooking>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void performAction(CalendarBooking calendarBooking) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument document = getDocument(calendarBooking);\n\n\t\t\t\t\t\tdocuments.add(document);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PortalException pe) {\n\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\"Unable to index calendar booking \" +\n\t\t\t\t\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\t\t\t\tpe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tactionableDynamicQuery.setCompanyId(companyId);\n\n\t\tactionableDynamicQuery.performActions();\n\n\t\tSearchEngineUtil.updateDocuments(\n\t\t\tgetSearchEngineId(), companyId, documents, isCommitImmediately());\n\t}","id":106629,"modified_method":"protected void reindexCalendarBookings(long companyId)\n\t\tthrows PortalException {\n\n\t\tfinal ActionableDynamicQuery actionableDynamicQuery =\n\t\t\t_calendarBookingLocalService.getActionableDynamicQuery();\n\n\t\tactionableDynamicQuery.setCompanyId(companyId);\n\t\tactionableDynamicQuery.setAddCriteriaMethod(\n\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tProperty statusProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"status\");\n\n\t\t\t\t\tint[] statuses = {\n\t\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_APPROVED,\n\t\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_MAYBE\n\t\t\t\t\t};\n\n\t\t\t\t\tdynamicQuery.add(statusProperty.in(statuses));\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tactionableDynamicQuery.setPerformActionMethod(\n\t\t\tnew ActionableDynamicQuery.PerformActionMethod<CalendarBooking>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void performAction(CalendarBooking calendarBooking) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument document = getDocument(calendarBooking);\n\n\t\t\t\t\t\tactionableDynamicQuery.addDocument(document);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PortalException pe) {\n\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\"Unable to index calendar booking \" +\n\t\t\t\t\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\t\t\t\tpe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tactionableDynamicQuery.setSearchEngineId(getSearchEngineId());\n\t\tactionableDynamicQuery.setCommitImmediately(isCommitImmediately());\n\n\t\tactionableDynamicQuery.performActions();\n\t}","commit_id":"1da79023ece608bf3333e4ec224f6f297b6bf22e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doReindex(String[] ids) throws Exception {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\n\t\treindexRecords(\n\t\t\tcompanyId, DDLRecordSetConstants.SCOPE_DYNAMIC_DATA_LISTS);\n\t\treindexRecords(companyId, DDLRecordSetConstants.SCOPE_FORMS);\n\t}","id":106630,"modified_method":"@Override\n\tprotected void doReindex(String[] ids) throws Exception {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\n\t\treindexRecords(companyId);\n\t}","commit_id":"1da79023ece608bf3333e4ec224f6f297b6bf22e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void reindexRecords(long companyId, int scope) throws Exception {\n\t\tLong[] minAndMaxRecordIds =\n\t\t\t_ddlRecordLocalService.getMinAndMaxCompanyRecordIds(\n\t\t\t\tcompanyId, WorkflowConstants.STATUS_APPROVED, scope);\n\n\t\tif ((minAndMaxRecordIds[0] == null) ||\n\t\t\t(minAndMaxRecordIds[1] == null)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong minRecordId = minAndMaxRecordIds[0];\n\t\tlong maxRecordId = minAndMaxRecordIds[1];\n\n\t\tlong startRecordId = minRecordId;\n\t\tlong endRecordId = startRecordId + DEFAULT_INTERVAL;\n\n\t\twhile (startRecordId <= maxRecordId) {\n\t\t\treindexRecords(companyId, startRecordId, endRecordId, scope);\n\n\t\t\tstartRecordId = endRecordId;\n\t\t\tendRecordId += DEFAULT_INTERVAL;\n\t\t}\n\t}","id":106631,"modified_method":"protected void reindexRecords(long companyId) throws Exception {\n\t\tfinal ActionableDynamicQuery actionableDynamicQuery =\n\t\t\t_ddlRecordLocalService.getActionableDynamicQuery();\n\n\t\tactionableDynamicQuery.setCompanyId(companyId);\n\t\tactionableDynamicQuery.setAddCriteriaMethod(\n\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\t\t\t\t@Override\n\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tProperty recordIdProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"recordId\");\n\n\t\t\t\t\tDynamicQuery recordVersionDynamicQuery =\n\t\t\t\t\t\t_ddlRecordVersionLocalService.dynamicQuery();\n\n\t\t\t\t\trecordVersionDynamicQuery.setProjection(\n\t\t\t\t\t\tProjectionFactoryUtil.property(\"recordId\"));\n\n\t\t\t\t\tProperty statusProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"status\");\n\n\t\t\t\t\trecordVersionDynamicQuery.add(\n\t\t\t\t\t\tstatusProperty.eq(WorkflowConstants.STATUS_APPROVED));\n\n\t\t\t\t\tdynamicQuery.add(\n\t\t\t\t\t\trecordIdProperty.in(recordVersionDynamicQuery));\n\n\t\t\t\t\tProperty recordSetProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"recordSetId\");\n\n\t\t\t\t\tDynamicQuery recordSetDynamicQuery =\n\t\t\t\t\t\t_ddlRecordSetLocalService.dynamicQuery();\n\n\t\t\t\t\trecordSetDynamicQuery.setProjection(\n\t\t\t\t\t\tProjectionFactoryUtil.property(\"recordSetId\"));\n\n\t\t\t\t\tProperty scopeProperty = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\"scope\");\n\n\t\t\t\t\trecordSetDynamicQuery.add(\n\t\t\t\t\t\tscopeProperty.in(_REINDEX_SCOPES));\n\n\t\t\t\t\tdynamicQuery.add(\n\t\t\t\t\t\trecordSetProperty.in(recordSetDynamicQuery));\n\t\t\t\t}\n\t\t});\n\t\tactionableDynamicQuery.setPerformActionMethod(\n\t\t\tnew ActionableDynamicQuery.PerformActionMethod() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void performAction(Object object)\n\t\t\t\t\tthrows PortalException {\n\n\t\t\t\t\tDDLRecord record = (DDLRecord)object;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument document = getDocument(record);\n\n\t\t\t\t\t\tif (document != null) {\n\t\t\t\t\t\t\tactionableDynamicQuery.addDocument(document);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PortalException pe) {\n\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\"Unable to index dynamic data lists record \" +\n\t\t\t\t\t\t\t\t\trecord.getRecordId(),\n\t\t\t\t\t\t\t\tpe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t});\n\n\t\tactionableDynamicQuery.setSearchEngineId(getSearchEngineId());\n\t\tactionableDynamicQuery.setCommitImmediately(isCommitImmediately());\n\n\t\tactionableDynamicQuery.performActions();\n\t}","commit_id":"1da79023ece608bf3333e4ec224f6f297b6bf22e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void validateTableOfLongs(VoltTable vt, long[][] expected) {\n        assertNotNull(expected);\n        assertEquals(\"Wrong number of rows in table.  \",\n                        expected.length, vt.getRowCount());\n        int len = expected.length;\n        for (int i=0; i < len; i++) {\n            validateRowOfLongs(vt, expected[i]);\n        }\n    }","id":106632,"modified_method":"public void validateTableOfLongs(VoltTable vt, long[][] expected) {\n        assertNotNull(expected);\n        assertEquals(expected.length, vt.getRowCount());\n        int len = expected.length;\n        for (int i=0; i < len; i++) {\n            validateRowOfLongs(vt, expected[i]);\n        }\n    }","commit_id":"8b7911e0ecdfd873b71b9fe8f23c34b4739925d4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static public void verifyStmtFails(Client client, String stmt, String expectedPattern) throws IOException {\n        verifyProcFails(client, expectedPattern, \"@AdHoc\", stmt);\n    }","id":106633,"modified_method":"static public void verifyStmtFails(Client client, String stmt, String expectedMsg) throws IOException {\n        verifyProcFails(client, expectedMsg, \"@AdHoc\", stmt);\n    }","commit_id":"8b7911e0ecdfd873b71b9fe8f23c34b4739925d4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static public void verifyProcFails(Client client, String expectedPattern, String storedProc, Object... args) throws IOException {\n\n        String what;\n        if (storedProc.compareTo(\"@AdHoc\") == 0) {\n            what = \"the statement \\\"\" + args[0] + \"\\\"\";\n        }\n        else {\n            what = \"the stored procedure \\\"\" + storedProc + \"\\\"\";\n        }\n\n        try {\n            client.callProcedure(storedProc, args);\n        }\n        catch (ProcCallException pce) {\n            String msg = pce.getMessage();\n            String diagnostic = \"Expected \" + what + \" to throw an exception matching the pattern \\\"\" +\n                    expectedPattern + \"\\\", but instead it threw an exception containing \\\"\" + msg + \"\\\".\";\n            Pattern pattern = Pattern.compile(expectedPattern, Pattern.MULTILINE);\n            assertTrue(diagnostic, pattern.matcher(msg).find());\n            return;\n        }\n\n        String diagnostic = \"Expected \" + what + \" to throw an exception matching the pattern \\\"\" +\n                expectedPattern + \"\\\", but instead it threw nothing.\";\n        fail(diagnostic);\n    }","id":106634,"modified_method":"static public void verifyProcFails(Client client, String expectedMsg, String storedProc, Object... args) throws IOException {\n\n        String what;\n        if (storedProc.compareTo(\"@AdHoc\") == 0) {\n            what = \"the statement \\\"\" + args[0] + \"\\\"\";\n        }\n        else {\n            what = \"the stored procedure \\\"\" + storedProc + \"\\\"\";\n        }\n\n        try {\n            client.callProcedure(storedProc, args);\n        }\n        catch (ProcCallException pce) {\n            String msg = pce.getMessage();\n            String diagnostic = \"Expected \" + what + \" to throw an exception containing the message \\\"\" +\n                    expectedMsg + \"\\\", but instead it threw an exception containing \\\"\" + msg + \"\\\".\";\n            assertTrue(diagnostic, msg.contains(expectedMsg));\n            return;\n        }\n\n        String diagnostic = \"Expected \" + what + \" to throw an exception containing the message \\\"\" +\n                expectedMsg + \"\\\", but instead it threw nothing.\";\n        fail(diagnostic);\n    }","commit_id":"8b7911e0ecdfd873b71b9fe8f23c34b4739925d4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testTableLimitAndPercentage() throws Exception {\n        System.out.println(\"STARTING TABLE LIMIT AND PERCENTAGE FULL TEST......\");\n        Client client = getClient();\n        VoltTable vt = null;\n        if(isHSQL()) {\n            return;\n        }\n\n        // When table limit feature is fully supported, there needs to be more test cases.\n        // generalize this test within a loop, maybe.\n        // Test max row 0\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED0\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {0});\n\n        verifyProcFails(client, \"CONSTRAINT VIOLATION\\\\s*Table CAPPED0 exceeds table maximum row count 0\",\n                \"CAPPED0.insert\", 0, 0, 0);\n\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED0\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {0});\n\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED0\", 0, 0);\n\n        // Test max row 2\n        vt = client.callProcedure(\"CAPPED2.insert\", 0, 0, 0).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 50);\n        vt = client.callProcedure(\"CAPPED2.insert\", 1, 1, 1).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 100);\n\n        verifyProcFails(client, \"CONSTRAINT VIOLATION\\\\s*Table CAPPED2 exceeds table maximum row count 2\",\n                \"CAPPED2.insert\", 2, 2, 2);\n\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED2\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {2});\n\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 100);\n\n        // Test @Statistics TABLE for normal table\n        vt = client.callProcedure(\"NOCAPPED.insert\", 0, 0, 0).getResults()[0];\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"NOCAPPED\", VoltType.NULL_INTEGER, 0);\n\n\n        // Test percentage with round up\n        vt = client.callProcedure(\"CAPPED3.insert\", 0, 0, 0).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 34);\n        vt = client.callProcedure(\"CAPPED3.insert\", 1, 1, 1).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 67);\n        vt = client.callProcedure(\"CAPPED3.insert\", 2, 2, 2).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 100);\n\n        verifyProcFails(client, \"CONSTRAINT VIOLATION\\\\s*Table CAPPED3 exceeds table maximum row count 3\",\n                \"CAPPED3.insert\", 3, 3, 3);\n\n        // This should also fail if attempting to insert a row via INSERT INTO ... SELECT.\n        verifyStmtFails(client, \"insert into capped3 select * from capped2\",\n                \"CONSTRAINT VIOLATION\\\\s*Table CAPPED3 exceeds table maximum row count 3\");\n\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED3\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {3});\n\n    }","id":106635,"modified_method":"public void testTableLimitAndPercentage() throws Exception {\n        System.out.println(\"STARTING TABLE LIMIT AND PERCENTAGE FULL TEST......\");\n        Client client = getClient();\n        VoltTable vt = null;\n        Exception e = null;\n        if(isHSQL()) {\n            return;\n        }\n\n        // When table limit feature is fully supported, there needs to be more test cases.\n        // generalize this test within a loop, maybe.\n        // Test max row 0\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED0\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {0});\n\n        e = null;\n        try {\n            vt = client.callProcedure(\"CAPPED0.insert\", 0, 0, 0).getResults()[0];\n        } catch (ProcCallException ex) {\n            e = ex;\n            assertTrue(ex.getMessage().contains(\"CONSTRAINT VIOLATION\"));\n            assertTrue(ex.getMessage().contains(\"Table CAPPED0 exceeds table maximum row count 0\"));\n        } finally {\n            assertNotNull(e);\n        }\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED0\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {0});\n\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED0\", 0, 0);\n\n        // Test max row 2\n        vt = client.callProcedure(\"CAPPED2.insert\", 0, 0, 0).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 50);\n        vt = client.callProcedure(\"CAPPED2.insert\", 1, 1, 1).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 100);\n\n        e = null;\n        try {\n            vt = client.callProcedure(\"CAPPED2.insert\", 2, 2, 2).getResults()[0];\n        } catch (ProcCallException ex) {\n            e = ex;\n            assertTrue(ex.getMessage().contains(\"CONSTRAINT VIOLATION\"));\n            assertTrue(ex.getMessage().contains(\"Table CAPPED2 exceeds table maximum row count 2\"));\n        } finally {\n            assertNotNull(e);\n        }\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED2\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {2});\n\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED2\", 2, 100);\n\n        // Test @Statistics TABLE for normal table\n        vt = client.callProcedure(\"NOCAPPED.insert\", 0, 0, 0).getResults()[0];\n        // Test @Statistics TABLE\n        validStatisticsForTableLimitAndPercentage(client, \"NOCAPPED\", VoltType.NULL_INTEGER, 0);\n\n\n        // Test percentage with round up\n        vt = client.callProcedure(\"CAPPED3.insert\", 0, 0, 0).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 34);\n        vt = client.callProcedure(\"CAPPED3.insert\", 1, 1, 1).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 67);\n        vt = client.callProcedure(\"CAPPED3.insert\", 2, 2, 2).getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {1});\n        validStatisticsForTableLimitAndPercentage(client, \"CAPPED3\", 3, 100);\n\n        e = null;\n        try {\n            vt = client.callProcedure(\"CAPPED3.insert\", 3, 3, 3).getResults()[0];\n        } catch (ProcCallException ex) {\n            e = ex;\n            assertTrue(ex.getMessage().contains(\"CONSTRAINT VIOLATION\"));\n            assertTrue(ex.getMessage().contains(\"Table CAPPED3 exceeds table maximum row count 3\"));\n        } finally {\n            assertNotNull(e);\n        }\n        vt = client.callProcedure(\"@AdHoc\", \"select count(*) from CAPPED3\").getResults()[0];\n        validateTableOfScalarLongs(vt, new long[] {3});\n\n    }","commit_id":"8b7911e0ecdfd873b71b9fe8f23c34b4739925d4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  public final Schema generate(Type type, boolean acceptRecursiveTypes) throws UnsupportedTypeException {\n    Set<String> knownRecords = ImmutableSet.of();\n    return doGenerate(TypeToken.of(type), knownRecords, acceptRecursiveTypes);\n  }","id":106636,"modified_method":"@Override\n  public final Schema generate(Type type, boolean acceptRecursiveTypes) throws UnsupportedTypeException {\n    Set<String> knownRecords = Collections.emptySet();\n    return doGenerate(TypeToken.of(type), knownRecords, acceptRecursiveTypes);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected Schema generateRecord(TypeToken<?> typeToken, Set<String> knowRecords, boolean acceptRecursion)\n    throws UnsupportedTypeException {\n    String recordName = typeToken.getRawType().getName();\n    Map<String, TypeToken<?>> recordFieldTypes =\n      typeToken.getRawType().isInterface() ?\n        collectByMethods(typeToken, Maps.<String, TypeToken<?>>newTreeMap()) :\n        collectByFields(typeToken, Maps.<String, TypeToken<?>>newTreeMap());\n\n    // Recursively generate field type schema.\n    ImmutableList.Builder<Schema.Field> builder = ImmutableList.builder();\n    for (Map.Entry<String, TypeToken<?>> fieldType : recordFieldTypes.entrySet()) {\n      Schema fieldSchema = doGenerate(fieldType.getValue(),\n                                      ImmutableSet.<String>builder().addAll(knowRecords).add(recordName).build(),\n                                      acceptRecursion);\n\n      if (!fieldType.getValue().getRawType().isPrimitive()) {\n        // For non-primitive, allows \"null\" value, unless the class is annotated with Nonnull\n        if (!typeToken.getRawType().isAnnotationPresent(Nonnull.class)) {\n          fieldSchema = Schema.unionOf(fieldSchema, Schema.of(Schema.Type.NULL));\n        }\n      }\n      builder.add(Schema.Field.of(fieldType.getKey(), fieldSchema));\n    }\n\n    return Schema.recordOf(recordName, builder.build());\n  }","id":106637,"modified_method":"@Override\n  protected Schema generateRecord(TypeToken<?> typeToken, Set<String> knowRecords, boolean acceptRecursion)\n    throws UnsupportedTypeException {\n    String recordName = typeToken.getRawType().getName();\n    Map<String, TypeToken<?>> recordFieldTypes =\n      typeToken.getRawType().isInterface() ?\n        collectByMethods(typeToken, new TreeMap<String, TypeToken<?>>()) :\n        collectByFields(typeToken, new TreeMap<String, TypeToken<?>>());\n\n    // Recursively generate field type schema.\n    List<Schema.Field> fields = new ArrayList<>();\n    for (Map.Entry<String, TypeToken<?>> fieldType : recordFieldTypes.entrySet()) {\n      Set<String> records = new HashSet<>(knowRecords);\n      records.add(recordName);\n      Schema fieldSchema = doGenerate(fieldType.getValue(), records, acceptRecursion);\n\n      if (!fieldType.getValue().getRawType().isPrimitive()) {\n        // For non-primitive, allows \"null\" value, unless the class is annotated with Nonnull\n        if (!typeToken.getRawType().isAnnotationPresent(Nonnull.class)) {\n          fieldSchema = Schema.unionOf(fieldSchema, Schema.of(Schema.Type.NULL));\n        }\n      }\n      fields.add(Schema.Field.of(fieldType.getKey(), fieldSchema));\n    }\n\n    return Schema.recordOf(recordName, Collections.unmodifiableList(fields));\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"public Schema parse() throws IOException {\n    try {\n      List<Schema.Field> fields = Lists.newArrayList();\n\n      while (pos < end) {\n        String name = nextToken();\n        expectWhitespace(\"Expecting whitespace between column name and type\");\n        skipWhitespace();\n        errorIf(pos >= end, \"Unexpected EOF\");\n        fields.add(Schema.Field.of(name, parseType()));\n        // stop if we're at the last field\n        if (pos >= end) {\n          break;\n        }\n        advancePastComma(\"Expected a comma separating schema columns\");\n      }\n\n      return Schema.recordOf(\"rec\", fields);\n    } catch (Exception e) {\n      Throwables.propagateIfInstanceOf(e, IOException.class);\n      // can happen if, for example, there are multiple fields in a record with the same name\n      throw new IOException(e);\n    }\n  }","id":106638,"modified_method":"public Schema parse() throws IOException {\n    try {\n      List<Schema.Field> fields = new ArrayList<>();\n\n      while (pos < end) {\n        String name = nextToken();\n        expectWhitespace(\"Expecting whitespace between column name and type\");\n        skipWhitespace();\n        errorIf(pos >= end, \"Unexpected EOF\");\n        fields.add(Schema.Field.of(name, parseType()));\n        // stop if we're at the last field\n        if (pos >= end) {\n          break;\n        }\n        advancePastComma(\"Expected a comma separating schema columns\");\n      }\n\n      return Schema.recordOf(\"rec\", fields);\n    } catch (Exception e) {\n      if (e instanceof IOException) {\n        throw e;\n      }\n      // can happen if, for example, there are multiple fields in a record with the same name\n      throw new IOException(e);\n    }\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"private Schema parseRecord() throws IOException {\n    expectChar('<', \"record must be followed with a '<'\");\n    skipWhitespace();\n    String recordName = \"rec\" + recordNum;\n    recordNum++;\n    List<Schema.Field> fields = Lists.newArrayList();\n\n    // keep going until we get to the enclosing '>'\n    while (true) {\n      // colName:type\n      String colName = nextToken();\n      errorIf(schema.charAt(pos) != ':', \"Expecting a ':' between field name and type\");\n      pos++;\n      errorIf(pos >= end, \"Unexpected EOF\");\n      fields.add(Schema.Field.of(colName, parseType()));\n      // must be at the end or at a comma\n      if (tryAdvancePastEndBracket()) {\n        break;\n      }\n      advancePastComma(\"Expected a comma separating record fields\");\n    }\n\n    return Schema.recordOf(recordName, fields);\n  }","id":106639,"modified_method":"private Schema parseRecord() throws IOException {\n    expectChar('<', \"record must be followed with a '<'\");\n    skipWhitespace();\n    String recordName = \"rec\" + recordNum;\n    recordNum++;\n    List<Schema.Field> fields = new ArrayList<>();\n\n    // keep going until we get to the enclosing '>'\n    while (true) {\n      // colName:type\n      String colName = nextToken();\n      errorIf(schema.charAt(pos) != ':', \"Expecting a ':' between field name and type\");\n      pos++;\n      errorIf(pos >= end, \"Unexpected EOF\");\n      fields.add(Schema.Field.of(colName, parseType()));\n      // must be at the end or at a comma\n      if (tryAdvancePastEndBracket()) {\n        break;\n      }\n      advancePastComma(\"Expected a comma separating record fields\");\n    }\n\n    return Schema.recordOf(recordName, fields);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"private Schema parseUnion() throws IOException {\n    expectChar('<', \"union must be followed by a '<'\");\n    skipWhitespace();\n    List<Schema> unionTypes = Lists.newArrayList();\n\n    // keep going until we see the closing '>'\n    while (true) {\n      unionTypes.add(parseType());\n      if (tryAdvancePastEndBracket()) {\n        break;\n      }\n      advancePastComma(\"Expected a comma separating union types\");\n    }\n\n    return Schema.unionOf(unionTypes);\n  }","id":106640,"modified_method":"private Schema parseUnion() throws IOException {\n    expectChar('<', \"union must be followed by a '<'\");\n    skipWhitespace();\n    List<Schema> unionTypes = new ArrayList<>();\n\n    // keep going until we see the closing '>'\n    while (true) {\n      unionTypes.add(parseType());\n      if (tryAdvancePastEndBracket()) {\n        break;\n      }\n      advancePastComma(\"Expected a comma separating union types\");\n    }\n\n    return Schema.unionOf(unionTypes);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Constructs {@link Schema.Type#RECORD RECORD} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @param knownRecords Set of record name already encountered during the reading.\n   * @return A {@link Schema} of type {@link Schema.Type#RECORD RECORD}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readRecord(JsonReader reader, Set<String> knownRecords) throws IOException {\n    if (!\"name\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"name\\\" missing for record.\");\n    }\n\n    String recordName = reader.nextString();\n\n    // Read in fields schemas\n    if (!\"fields\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"fields\\\" missing for record.\");\n    }\n\n    knownRecords.add(recordName);\n\n    ImmutableList.Builder<Schema.Field> fieldBuilder = ImmutableList.builder();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      reader.beginObject();\n      if (!\"name\".equals(reader.nextName())) {\n        throw new IOException(\"Property \\\"name\\\" missing for record field.\");\n      }\n      String fieldName = reader.nextString();\n      fieldBuilder.add(Schema.Field.of(fieldName, readInnerSchema(reader, \"type\", knownRecords)));\n      reader.endObject();\n    }\n    reader.endArray();\n    return Schema.recordOf(recordName, fieldBuilder.build());\n  }","id":106641,"modified_method":"/**\n   * Constructs {@link Schema.Type#RECORD RECORD} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @param knownRecords Set of record name already encountered during the reading.\n   * @return A {@link Schema} of type {@link Schema.Type#RECORD RECORD}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readRecord(JsonReader reader, Set<String> knownRecords) throws IOException {\n    if (!\"name\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"name\\\" missing for record.\");\n    }\n\n    String recordName = reader.nextString();\n\n    // Read in fields schemas\n    if (!\"fields\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"fields\\\" missing for record.\");\n    }\n\n    knownRecords.add(recordName);\n\n    List<Schema.Field> fieldBuilder = new ArrayList<>();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      reader.beginObject();\n      if (!\"name\".equals(reader.nextName())) {\n        throw new IOException(\"Property \\\"name\\\" missing for record field.\");\n      }\n      String fieldName = reader.nextString();\n      fieldBuilder.add(Schema.Field.of(fieldName, readInnerSchema(reader, \"type\", knownRecords)));\n      reader.endObject();\n    }\n    reader.endArray();\n    return Schema.recordOf(recordName, fieldBuilder);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void write(JsonWriter writer, Schema schema) throws IOException {\n    if (schema == null) {\n      writer.nullValue();\n      return;\n    }\n    Set<String> knownRecords = Sets.newHashSet();\n    write(writer, schema, knownRecords);\n  }","id":106642,"modified_method":"@Override\n  public void write(JsonWriter writer, Schema schema) throws IOException {\n    if (schema == null) {\n      writer.nullValue();\n      return;\n    }\n    Set<String> knownRecords = new HashSet<>();\n    write(writer, schema, knownRecords);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Constructs {@link Schema.Type#ENUM ENUM} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @return A {@link Schema} of type {@link Schema.Type#ENUM ENUM}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readEnum(JsonReader reader) throws IOException {\n    if (!\"symbols\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"symbols\\\" missing for enum.\");\n    }\n    ImmutableList.Builder<String> enumValues = ImmutableList.builder();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      enumValues.add(reader.nextString());\n    }\n    reader.endArray();\n    return Schema.enumWith(enumValues.build());\n  }","id":106643,"modified_method":"/**\n   * Constructs {@link Schema.Type#ENUM ENUM} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @return A {@link Schema} of type {@link Schema.Type#ENUM ENUM}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readEnum(JsonReader reader) throws IOException {\n    if (!\"symbols\".equals(reader.nextName())) {\n      throw new IOException(\"Property \\\"symbols\\\" missing for enum.\");\n    }\n    List<String> enumValues = new ArrayList<>();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      enumValues.add(reader.nextString());\n    }\n    reader.endArray();\n    return Schema.enumWith(enumValues);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Schema read(JsonReader reader) throws IOException {\n    return read(reader, Sets.<String>newHashSet());\n  }","id":106644,"modified_method":"@Override\n  public Schema read(JsonReader reader) throws IOException {\n    return read(reader, new HashSet<String>());\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Constructs {@link Schema.Type#UNION UNION} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @param knownRecords Set of record name already encountered during the reading.\n   * @return A {@link Schema} of type {@link Schema.Type#UNION UNION}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readUnion(JsonReader reader, Set<String> knownRecords) throws IOException {\n    ImmutableList.Builder<Schema> unionSchemas = ImmutableList.builder();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      unionSchemas.add(read(reader, knownRecords));\n    }\n    reader.endArray();\n    return Schema.unionOf(unionSchemas.build());\n  }","id":106645,"modified_method":"/**\n   * Constructs {@link Schema.Type#UNION UNION} type schema from the json input.\n   *\n   * @param reader The {@link JsonReader} for streaming json input tokens.\n   * @param knownRecords Set of record name already encountered during the reading.\n   * @return A {@link Schema} of type {@link Schema.Type#UNION UNION}.\n   * @throws IOException When fails to construct a valid schema from the input.\n   */\n  private Schema readUnion(JsonReader reader, Set<String> knownRecords) throws IOException {\n    List<Schema> unionSchemas = new ArrayList<>();\n    reader.beginArray();\n    while (reader.peek() != JsonToken.END_ARRAY) {\n      unionSchemas.add(read(reader, knownRecords));\n    }\n    reader.endArray();\n    return Schema.unionOf(unionSchemas);\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Type getRawType() {\n    try {\n      ClassLoader cl = Objects.firstNonNull(classLoader,\n                                            Objects.firstNonNull(Thread.currentThread().getContextClassLoader(),\n                                                                 getClass().getClassLoader()));\n      return cl.loadClass(this.rawType);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"cannot convert \" + this.rawType + \" to a type. \", e);\n    }\n  }","id":106646,"modified_method":"@Override\n  public Type getRawType() {\n    try {\n      ClassLoader cl = classLoader;\n      if (cl == null) {\n        cl = Thread.currentThread().getContextClassLoader();\n        if (cl == null) {\n          cl = getClass().getClassLoader();\n        }\n      }\n      return cl.loadClass(this.rawType);\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(\"cannot convert \" + this.rawType + \" to a type. \", e);\n    }\n  }","commit_id":"833fe9fe41cbb60d52bbce01c7f74c72b1fdb010","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Encapsulates the logic related to locating the resource bundle with the given \n     * relative name for a class.\n     *\n     * @param cls the Class requiring the bundle\n     * @param name the name of the resource\n     * @return an appropriate ResourceBundle\n     */\n    public static ResourceBundle getBundle(Class<?> cls, String name) {\n        try {\n            return ResourceBundle.getBundle(getBundleName(cls, name),\n                                            Locale.getDefault(),\n                                            cls.getClassLoader());\n        } catch (MissingResourceException ex) {\n            return ResourceBundle.getBundle(getBundleName(cls, name),\n                                            Locale.getDefault(),\n                                            Thread.currentThread().getContextClassLoader());\n            \n        }\n    }","id":106647,"modified_method":"/**\n     * Encapsulates the logic related to locating the resource bundle with the given \n     * relative name for a class.\n     *\n     * @param cls the Class requiring the bundle\n     * @param name the name of the resource\n     * @return an appropriate ResourceBundle\n     */\n    public static ResourceBundle getBundle(Class<?> cls, String name) {\n        try {\n            ClassLoader loader = cls.getClassLoader();\n            if (loader == null) {\n                return ResourceBundle.getBundle(getBundleName(cls, name), Locale.getDefault());\n            }\n            return ResourceBundle.getBundle(getBundleName(cls, name),\n                                            Locale.getDefault(),\n                                            loader);\n        } catch (MissingResourceException ex) {\n            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n            if (loader == null) {\n                return ResourceBundle.getBundle(getBundleName(cls, name), Locale.getDefault());\n            }\n            return ResourceBundle.getBundle(getBundleName(cls, name),\n                                            Locale.getDefault(),\n                                            loader);\n            \n        }\n    }","commit_id":"949df02a48ca3558786b7fc96de04121e906406a","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Encapsulates the logic related to locating the default resource bundle\n     * for a class. \n     *\n     * @param cls the Class requiring the bundle\n     * @return an appropriate ResourceBundle\n     */\n    public static ResourceBundle getBundle(Class<?> cls) {\n        \n        try {\n            return ResourceBundle.getBundle(getBundleName(cls),\n                                        Locale.getDefault(),\n                                        cls.getClassLoader());\n        } catch (MissingResourceException ex) {\n            return ResourceBundle.getBundle(getBundleName(cls),\n                                            Locale.getDefault(),\n                                            Thread.currentThread().getContextClassLoader());\n            \n        }\n    }","id":106648,"modified_method":"/**\n     * Encapsulates the logic related to locating the default resource bundle\n     * for a class. \n     *\n     * @param cls the Class requiring the bundle\n     * @return an appropriate ResourceBundle\n     */\n    public static ResourceBundle getBundle(Class<?> cls) {\n        \n        try {\n            ClassLoader loader = cls.getClassLoader();\n            if (loader == null) {\n                return ResourceBundle.getBundle(getBundleName(cls), Locale.getDefault());\n            }\n            return ResourceBundle.getBundle(getBundleName(cls),\n                                        Locale.getDefault(),\n                                        loader);\n        } catch (MissingResourceException ex) {\n            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n            if (loader == null) {\n                return ResourceBundle.getBundle(getBundleName(cls), Locale.getDefault());\n            }\n            return ResourceBundle.getBundle(getBundleName(cls),\n                                            Locale.getDefault(),\n                                            loader);\n            \n        }\n    }","commit_id":"949df02a48ca3558786b7fc96de04121e906406a","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n  public void testShortCircuitRenewCancelDifferentHostSamePort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr =\n        new InetSocketAddress(InetAddress.getLocalHost(), 123);    \n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(\"1.1.1.1\", rmAddr.getPort()),\n        false);\n  }","id":106649,"modified_method":"@Test\n  public void testShortCircuitRenewCancelDifferentHostSamePort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr = NetUtils.createSocketAddr(\n        InetAddress.getLocalHost().getHostName(), 123, null);\n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(\"1.1.1.1\", rmAddr.getPort()),\n        false);\n  }","commit_id":"a9775b4e49581bc9ffeed2f7e2417fa401b02f30","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testShortCircuitRenewCancelDifferentHostDifferentPort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr =\n        new InetSocketAddress(InetAddress.getLocalHost(), 123);    \n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(\"1.1.1.1\", rmAddr.getPort()+1),\n        false);\n  }","id":106650,"modified_method":"@Test\n  public void testShortCircuitRenewCancelDifferentHostDifferentPort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr = NetUtils.createSocketAddr(\n        InetAddress.getLocalHost().getHostName(), 123, null);\n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(\"1.1.1.1\", rmAddr.getPort()+1),\n        false);\n  }","commit_id":"a9775b4e49581bc9ffeed2f7e2417fa401b02f30","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testShortCircuitRenewCancelSameHostDifferentPort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr =\n        new InetSocketAddress(InetAddress.getLocalHost(), 123);    \n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(rmAddr.getAddress(), rmAddr.getPort()+1),\n        false);\n  }","id":106651,"modified_method":"@Test\n  public void testShortCircuitRenewCancelSameHostDifferentPort()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr = NetUtils.createSocketAddr(\n        InetAddress.getLocalHost().getHostName(), 123, null);\n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(rmAddr.getAddress(), rmAddr.getPort()+1),\n        false);\n  }","commit_id":"a9775b4e49581bc9ffeed2f7e2417fa401b02f30","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testShortCircuitRenewCancel()\n      throws IOException, InterruptedException {\n    InetSocketAddress addr =\n        new InetSocketAddress(InetAddress.getLocalHost(), 123);\n    checkShortCircuitRenewCancel(addr, addr, true);\n  }","id":106652,"modified_method":"@Test\n  public void testShortCircuitRenewCancel()\n      throws IOException, InterruptedException {\n    InetSocketAddress addr = NetUtils.createSocketAddr(\n        InetAddress.getLocalHost().getHostName(), 123, null);\n    checkShortCircuitRenewCancel(addr, addr, true);\n  }","commit_id":"a9775b4e49581bc9ffeed2f7e2417fa401b02f30","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testShortCircuitRenewCancelWildcardAddress()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr = new InetSocketAddress(123);\n    checkShortCircuitRenewCancel(\n        rmAddr,\n        new InetSocketAddress(InetAddress.getLocalHost(), rmAddr.getPort()),\n        true);\n  }","id":106653,"modified_method":"@Test\n  public void testShortCircuitRenewCancelWildcardAddress()\n      throws IOException, InterruptedException {\n    InetSocketAddress rmAddr = new InetSocketAddress(123);\n    InetSocketAddress serviceAddr = NetUtils.createSocketAddr(\n        InetAddress.getLocalHost().getHostName(), rmAddr.getPort(), null);\n    checkShortCircuitRenewCancel(\n        rmAddr,\n        serviceAddr,\n        true);\n  }","commit_id":"a9775b4e49581bc9ffeed2f7e2417fa401b02f30","url":"https://github.com/apache/hadoop"},{"original_method":"public InputStream getResourceAsStream(String uri) {\n\t\t\treturn Locators.getDefault().getResourceAsStream(PATH_PREFIX + uri);\n\t\t}","id":106654,"modified_method":"public InputStream getResourceAsStream(String uri) {\n\t\t\treturn ClassWebResource.getResourceAsStream(PATH_PREFIX + uri);\n\t\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the locator for this {@link ClassWebContext}. */\n\t\tpublic Locator getLocator() {\n\t\t\treturn new Locator() {\n\t\t\t\tpublic String getDirectory() {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpublic URL getResource(String name) {\n\t\t\t\t\treturn ClassWebContext.this.getResource(name);\n\t\t\t\t}\n\t\t\t\tpublic InputStream getResourceAsStream(String name) {\n\t\t\t\t\treturn ClassWebContext.this.getResourceAsStream(name);\n\t\t\t\t}\n\t\t\t};\n\t\t}","id":106655,"modified_method":"/** Returns the locator for this {@link ClassWebContext}. */\n\t\tpublic Locator getLocator() {\n\t\t\treturn new Locator() {\n\t\t\t\tpublic String getDirectory() {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpublic URL getResource(String name) {\n\t\t\t\t\treturn ClassWebResource.getResource(name);\n\t\t\t\t}\n\t\t\t\tpublic InputStream getResourceAsStream(String name) {\n\t\t\t\t\treturn ClassWebResource.getResourceAsStream(name);\n\t\t\t\t}\n\t\t\t};\n\t\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"/** Works with {@link ClassWebContext} to\n\t * load resources from class path (thru this servlet).\n\t */\n\tprivate void web(HttpServletRequest request,\n\tHttpServletResponse response, String pi)\n\tthrows ServletException, IOException {\n\t\t//A trick used to enforce browser to load new version JavaScript\n\t\t//How it work: client engine prefix URI with /_zver123, where\n\t\t//123 is the build version that changes once reload is required\n\t\t//Then, the server eliminate such prefix before locating resource\n\t\tfinal String ZVER = \"/_zver\";\n\t\tif (pi.startsWith(ZVER)) {\n\t\t\tfinal int j = pi.indexOf('/', ZVER.length());\n\t\t\tif (j >= 0) pi = pi.substring(j);\n\t\t\telse log.warning(\"Unknown path info: \"+pi);\n\t\t}\n\n\t\t//Notify the browser by calling back the code specified with /_zcb\n\t\tString jsextra = null;\n\t\tfinal String ZCB = \"/_zcb\"; //denote callback is required\n\t\tif (pi.startsWith(ZCB)) {\n\t\t\tfinal int j = pi.indexOf('/', ZCB.length());\n\t\t\tif (j >= 0) {\n\t\t\t\tjsextra = pi.substring(ZCB.length(), j);\n\t\t\t\tpi = pi.substring(j);\n\t\t\t} else {\n\t\t\t\tjsextra = pi.substring(ZCB.length());\n\t\t\t\tlog.warning(\"Unknown path info: \"+pi);\n\t\t\t}\n\n\t\t\tfinal int len = jsextra.length();\n\t\t\tif (len == 0) jsextra = null;\n\t\t\telse {\n\t\t\t\tfinal char cc = jsextra.charAt(len - 1);\n\t\t\t\tif (cc != ';') {\n\t\t\t\t\tif (cc != ')') jsextra += \"()\";\n\t\t\t\t\tjsextra += ';';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String ext = getExtension(pi);\n\t\tif (ext != null) {\n\t\t\tif (\"dsp\".equals(ext)) {\n\t\t\t\tfinal Interpretation cnt =\n\t\t\t\t\t(Interpretation)_dspCache.get(pi);\n\t\t\t\tif (cnt == null) {\n\t\t\t\t\tif (Servlets.isIncluded(request)) log.error(\"Resource not found: \"+pi);\n\t\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\t\tresponse.sendError(response.SC_NOT_FOUND, pi+\" not found.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcnt.interpret(new ServletDSPContext(\n\t\t\t\t\t_ctx, request, response, _cwc.getLocator()));\n\t\t\t\tif (jsextra != null) response.getWriter().write(jsextra);\n\t\t\t\treturn; //done\n\t\t\t}\n\n\t\t\tif (!Servlets.isIncluded(request)) {\t\t\t\t\n\t\t\t\tfinal String ctype = ContentTypes.getContentType(ext);\n\t\t\t\tif (ctype != null)\n\t\t\t\t\tresponse.setContentType(ctype);\n\t\t\t\tif (D.ON && log.debugable()) log.debug(\"Content type: \"+ctype+\" for \"+pi);\n\t\t\t}\n\t\t}\n\n\t\tpi = Servlets.locate(_ctx, request, pi, _cwc.getLocator());\n\t\tfinal InputStream is = _cwc.getResourceAsStream(pi);\n\t\tfinal byte[] data;\n\t\tif (is == null) {\n\t\t\tif (\"js\".equals(ext) || \"css\".equals(ext)) {\n\t\t\t\t//1. Don't sendError for them. Otherwise FF won't invoke onload\n\t\t\t\t//2. always log because browser usually don't show error message for them\n\t\t\t\tlog.warning(\"Resource not found: \"+pi);\n\t\t\t\tdata = new byte[0];\n\t\t\t} else {\n\t\t\t\tif (Servlets.isIncluded(request)) log.error(\"Resource not found: \"+pi);\n\t\t\t\tresponse.sendError(response.SC_NOT_FOUND, pi+\" not found.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = Files.readAll(is);\n\t\t\t//since what is embedded in the jar is not big, so load at once\n\t\t}\n\n\t\tint len = data.length;\n\t\tfinal byte[] extra = jsextra != null ? jsextra.getBytes(\"UTF-8\"): null;\n\t\tif (extra != null) len += extra.length;\n\t\tresponse.setContentLength(len);\n\n\t\tfinal ServletOutputStream out = response.getOutputStream();\n\t\tout.write(data);\n\t\tif (extra != null) out.write(extra);\n\t\tout.flush();\n\t}","id":106656,"modified_method":"/** Works with {@link ClassWebContext} to\n\t * load resources from class path (thru this servlet).\n\t */\n\tprivate void web(HttpServletRequest request,\n\tHttpServletResponse response, String pi)\n\tthrows ServletException, IOException {\n\t\t//A trick used to enforce browser to load new version JavaScript\n\t\t//How it work: client engine prefix URI with /_zver123, where\n\t\t//123 is the build version that changes once reload is required\n\t\t//Then, the server eliminate such prefix before locating resource\n\t\tfinal String ZVER = \"/_zver\";\n\t\tif (pi.startsWith(ZVER)) {\n\t\t\tfinal int j = pi.indexOf('/', ZVER.length());\n\t\t\tif (j >= 0) pi = pi.substring(j);\n\t\t\telse log.warning(\"Unknown path info: \"+pi);\n\t\t}\n\n\t\t//Notify the browser by calling back the code specified with /_zcb\n\t\tString jsextra = null;\n\t\tfinal String ZCB = \"/_zcb\"; //denote callback is required\n\t\tif (pi.startsWith(ZCB)) {\n\t\t\tfinal int j = pi.indexOf('/', ZCB.length());\n\t\t\tif (j >= 0) {\n\t\t\t\tjsextra = pi.substring(ZCB.length(), j);\n\t\t\t\tpi = pi.substring(j);\n\t\t\t} else {\n\t\t\t\tjsextra = pi.substring(ZCB.length());\n\t\t\t\tlog.warning(\"Unknown path info: \"+pi);\n\t\t\t}\n\n\t\t\tfinal int len = jsextra.length();\n\t\t\tif (len == 0) jsextra = null;\n\t\t\telse {\n\t\t\t\tfinal char cc = jsextra.charAt(len - 1);\n\t\t\t\tif (cc != ';') {\n\t\t\t\t\tif (cc != ')') jsextra += \"()\";\n\t\t\t\t\tjsextra += ';';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String ext = getExtension(pi);\n\t\tif (ext != null) {\n\t\t\tif (\"dsp\".equals(ext)) {\n\t\t\t\tfinal Interpretation cnt =\n\t\t\t\t\t(Interpretation)_dspCache.get(pi);\n\t\t\t\tif (cnt == null) {\n\t\t\t\t\tif (Servlets.isIncluded(request)) log.error(\"Resource not found: \"+pi);\n\t\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\t\tresponse.sendError(response.SC_NOT_FOUND, pi+\" not found.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcnt.interpret(new ServletDSPContext(\n\t\t\t\t\t_ctx, request, response, _cwc.getLocator()));\n\t\t\t\tif (jsextra != null) response.getWriter().write(jsextra);\n\t\t\t\treturn; //done\n\t\t\t}\n\n\t\t\tif (!Servlets.isIncluded(request)) {\t\t\t\t\n\t\t\t\tfinal String ctype = ContentTypes.getContentType(ext);\n\t\t\t\tif (ctype != null)\n\t\t\t\t\tresponse.setContentType(ctype);\n\t\t\t\tif (D.ON && log.debugable()) log.debug(\"Content type: \"+ctype+\" for \"+pi);\n\t\t\t}\n\t\t}\n\n\t\tpi = Servlets.locate(_ctx, request, pi, _cwc.getLocator());\n\t\tfinal InputStream is = getResourceAsStream(pi);\n\t\tfinal byte[] data;\n\t\tif (is == null) {\n\t\t\tif (\"js\".equals(ext) || \"css\".equals(ext)) {\n\t\t\t\t//1. Don't sendError for them. Otherwise FF won't invoke onload\n\t\t\t\t//2. always log because browser usually don't show error message for them\n\t\t\t\tlog.warning(\"Resource not found: \"+pi);\n\t\t\t\tdata = new byte[0];\n\t\t\t} else {\n\t\t\t\tif (Servlets.isIncluded(request)) log.error(\"Resource not found: \"+pi);\n\t\t\t\tresponse.sendError(response.SC_NOT_FOUND, pi+\" not found.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = Files.readAll(is);\n\t\t\t//since what is embedded in the jar is not big, so load at once\n\t\t}\n\n\t\tint len = data.length;\n\t\tfinal byte[] extra = jsextra != null ? jsextra.getBytes(\"UTF-8\"): null;\n\t\tif (extra != null) len += extra.length;\n\t\tresponse.setContentLength(len);\n\n\t\tfinal ServletOutputStream out = response.getOutputStream();\n\t\tout.write(data);\n\t\tif (extra != null) out.write(extra);\n\t\tout.flush();\n\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"public Object load(Object src) throws Exception {\n\t\t\tif (D.ON && log.debugable()) log.debug(\"Parse \"+src);\n\t\t\tfinal String path = (String)src;\n\t\t\tfinal InputStream is = _cwc.getResourceAsStream(path);\n\t\t\tif (is == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\treturn parse0(is, Interpreter.getContentType(path));\n\t\t\t} catch (Exception ex) {\n\t\t\t\tif (log.debugable())\n\t\t\t\t\tlog.realCauseBriefly(\"Failed to parse \"+path, ex);\n\t\t\t\telse\n\t\t\t\t\tlog.error(\"Failed to parse \"+path\n\t\t\t\t\t+\"\\nCause: \"+ex.getClass().getName()+\" \"+Exceptions.getMessage(ex)\n\t\t\t\t\t+\"\\n\"+Exceptions.getBriefStackTrace(ex));\n\t\t\t\treturn null; //as non-existent\n\t\t\t}\n\t\t}","id":106657,"modified_method":"public Object load(Object src) throws Exception {\n\t\t\tif (D.ON && log.debugable()) log.debug(\"Parse \"+src);\n\t\t\tfinal String path = (String)src;\n\t\t\tfinal InputStream is = getResourceAsStream(path);\n\t\t\tif (is == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\treturn parse0(is, Interpreter.getContentType(path));\n\t\t\t} catch (Exception ex) {\n\t\t\t\tif (log.debugable())\n\t\t\t\t\tlog.realCauseBriefly(\"Failed to parse \"+path, ex);\n\t\t\t\telse\n\t\t\t\t\tlog.error(\"Failed to parse \"+path\n\t\t\t\t\t+\"\\nCause: \"+ex.getClass().getName()+\" \"+Exceptions.getMessage(ex)\n\t\t\t\t\t+\"\\n\"+Exceptions.getBriefStackTrace(ex));\n\t\t\t\treturn null; //as non-existent\n\t\t\t}\n\t\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"public URL getResource(String uri) {\n\t\t\treturn Locators.getDefault().getResource(PATH_PREFIX + uri);\n\t\t}","id":106658,"modified_method":"public URL getResource(String uri) {\n\t\t\treturn ClassWebResource.getResource(PATH_PREFIX + uri);\n\t\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"public void init(ServletConfig config) throws ServletException {\n\t\t//super.init(config);\n\t\t\t//Note callback super to avoid saving config\n\n\t\t_ctx = config.getServletContext();\n\n\t\tfinal String cs = config.getInitParameter(\"charset\");\n\t\tif (cs != null)\n\t\t\t_charset = cs.length() > 0 ? cs: null;\n\t}","id":106659,"modified_method":"public void init(ServletConfig config) throws ServletException {\n\t\t//super.init(config);\n\t\t\t//Note callback super to avoid saving config\n\n\t\t_ctx = config.getServletContext();\n\n\t\tString s = config.getInitParameter(\"class-resource\");\n\t\tfinal boolean bClsRes = \"true\".equals(s);\n\t\t_locator = new Locator() {\n\t\t\tpublic String getDirectory() {\n\t\t\t\treturn null; //FUTURE: support relative path\n\t\t\t}\n\t\t\tpublic URL getResource(String name) {\n\t\t\t\ttry {\n\t\t\t\t\tURL url = _ctx.getResource(name);\n\t\t\t\t\treturn !bClsRes || url != null ? url:\n\t\t\t\t\t\tClassWebResource.getResource(name);\n\t\t\t\t} catch (java.net.MalformedURLException ex) {\n\t\t\t\t\tthrow new SystemException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic InputStream getResourceAsStream(String name) {\n\t\t\t\tInputStream is = _ctx.getResourceAsStream(name);\n\t\t\t\treturn !bClsRes || is != null ? is:\n\t\t\t\t\tClassWebResource.getResourceAsStream(name);\n\t\t\t}\n\t\t};\n\n\t\ts = config.getInitParameter(\"charset\");\n\t\tif (s != null) _charset = s.length() > 0 ? s: null;\n\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String path = Https.getThisServletPath(request);\n\t\tif (D.ON && log.debugable()) log.debug(\"Get \"+path);\n\n\t\tfinal Object old = Charsets.setup(request, response, _charset);\n\t\ttry {\n\t\t\tfinal Interpretation cnt = (Interpretation)\n\t\t\t\tResourceCaches.get(getCache(_ctx), _ctx, path, null);\n\t\t\tif (cnt == null) {\n\t\t\t\tif (Https.isIncluded(request)) log.error(\"Not found: \"+path);\n\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcnt.interpret(\n\t\t\t\tnew ServletDSPContext(_ctx, request, response, null));\n\t\t} finally {\n\t\t\tCharsets.cleanup(request, old);\n\t\t}\n\t}","id":106660,"modified_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String path = Https.getThisServletPath(request);\n\t\tif (D.ON && log.debugable()) log.debug(\"Get \"+path);\n\n\t\tfinal Object old = Charsets.setup(request, response, _charset);\n\t\ttry {\n\t\t\tfinal Interpretation cnt = (Interpretation)\n\t\t\t\tResourceCaches.get(getCache(), _ctx, path, null);\n\t\t\tif (cnt == null) {\n\t\t\t\tif (Https.isIncluded(request)) log.error(\"Not found: \"+path);\n\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcnt.interpret(\n\t\t\t\tnew ServletDSPContext(_ctx, request, response, null));\n\t\t} finally {\n\t\t\tCharsets.cleanup(request, old);\n\t\t}\n\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"public URL getResource(String name) {\n\t\ttry {\n\t\t\treturn _ctx.getResource(fixName(name));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new SystemException(ex);\n\t\t}\n\t}","id":106661,"modified_method":"public URL getResource(String name) {\n\t\ttry {\n\t\t\treturn _ctx.getResource(fixName(name));\n\t\t} catch (java.net.MalformedURLException ex) {\n\t\t\tthrow new SystemException(ex);\n\t\t}\n\t}","commit_id":"cd47797f180b2bd2bc6dbd754fa05c5affbe8e36","url":"https://github.com/zkoss/zk"},{"original_method":"public void init(FilterConfig filterConfig) throws ServletException {\n        ac = (ApplicationContext)filterConfig.getServletContext()\n        \t.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n        authnBeanName = filterConfig.getInitParameter(\"authnBean\");\n\t\tauthzBeanName = filterConfig.getInitParameter(\"authzBean\");\n\t\tcontextBeanName = filterConfig.getInitParameter(\"contextBean\");\n\t\troleParam = filterConfig.getInitParameter(\"role\").split(\",\");\n\t}","id":106662,"modified_method":"public void init(FilterConfig filterConfig) throws ServletException {\n        if(logger.isInfoEnabled()) logger.info(\"Initializing sections role filter\");\n\n        ac = (ApplicationContext)filterConfig.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\n        authnBeanName = filterConfig.getInitParameter(\"authnServiceBean\");\n\t\tauthzBeanName = filterConfig.getInitParameter(\"authzServiceBean\");\n\t\tcontextBeanName = filterConfig.getInitParameter(\"contextManagementServiceBean\");\n\t\tauthorizationFilterConfigurationBeanName = filterConfig.getInitParameter(\"authorizationFilterConfigurationBean\");\n\t\tselectSiteRedirect = filterConfig.getInitParameter(\"selectSiteRedirect\");\n    }","commit_id":"90628c236c4d3d359dba00a0f23d26a3ac0f8afa","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\tAuthn authn = (Authn)ac.getBean(authnBeanName);\n\t\tAuthz authz = (Authz)ac.getBean(authzBeanName);\n\t\tContext context = (Context)ac.getBean(contextBeanName);\n\t\tString userUid = authn.getUserUid(request);\n\n        if(log.isDebugEnabled()) log.debug(\"Filtering request for user \" + userUid);\n\n        String siteContext = context.getContext(request);\n        Role siteRole = authz.getSiteRole(userUid, siteContext);\n\n        boolean roleAllowed = false;\n        for(int i=0; i<roleParam.length; i++) {\n\t\t\tString roleName = roleParam[i];\n\t        if (siteRole.getName().equals(roleName)) {\n\t        \troleAllowed = true;\n\t        \tbreak;\n\t        }\n\t\t}\n\n        if(roleAllowed) {\n\t\t\tchain.doFilter(request, response);\n        } else {\n    \t\tif(log.isInfoEnabled()) log.info(\"PAGE VIEW AUTHZ FAILURE: User \"\n    \t\t\t\t+ userUid + \" in role \"\n    \t\t\t\t+ siteRole + \" for site \" + siteContext + \" on page \"\n    \t\t\t\t+ ((HttpServletRequest)request).getServletPath());\n    \t\t((HttpServletResponse)response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n\t}","id":106663,"modified_method":"public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest request = (HttpServletRequest)servletRequest;\n\t\tString servletPath = request.getServletPath();\n\t\tif (logger.isDebugEnabled()) logger.debug(\"Filtering request for servletPath=\" + servletPath);\n\t\tservletPath = servletPath.replaceFirst(\"^/\", \"\");\n\t\tif (servletPath.indexOf(\"/\") >= 0) {\n\t\t\t// Only protect the top-level folder, to allow for login through\n\t\t\t// a subdirectory, shared resource files, and so on.\n\t\t\tchain.doFilter(request, response);\n\t\t\treturn;\n\t\t}\n\n\t\tAuthn authn = (Authn)ac.getBean(authnBeanName);\n\t\tAuthz authz = (Authz)ac.getBean(authzBeanName);\n\t\tContext context = (Context)ac.getBean(contextBeanName);\n\t\tAuthorizationFilterConfigurationBean authzFilterConfigBean = (AuthorizationFilterConfigurationBean)ac.getBean(authorizationFilterConfigurationBeanName);\n\t\tString userUid = authn.getUserUid(request);\n\n        if (logger.isDebugEnabled()) logger.debug(\"Filtering request for user \" + userUid + \", pathInfo=\" + request.getPathInfo());\n\n\t\t// Try to get the currently selected site context, if any\n\t\tString siteContext = context.getContext(request);\n\t\t\n        if(logger.isDebugEnabled()) logger.debug(\"context=\" + siteContext);\n\n\t\tif (siteContext != null) {\n\t\t\t// Get the name of the page from the servlet path.\n\t\t\tString[] splitPath = servletPath.split(\"[./]\");\n\t\t\tString pageName = splitPath[0];\n\n\t\t\tboolean isAuthorized = false;\n\t\t\tRole role = authz.getSiteRole(userUid, siteContext);\n\t\t\tif (role.isInstructor() &&\n\t\t\t\tauthzFilterConfigBean.getManageAllSections().contains(pageName)) {\n\t\t\t\tisAuthorized = true;\n\t\t\t} else if ( (role.isInstructor() || role.isTeachingAssistant())\n\t\t\t\t\t&& authzFilterConfigBean.getManageEnrollments().contains(pageName)) {\n\t\t\t\tisAuthorized = true;\n\t\t\t} else if (role.isStudent()\n\t\t\t\t\t&& authzFilterConfigBean.getManageOwnSections().contains(pageName)) {\n\t\t\t\tisAuthorized = true;\n\t\t\t}\n\n\t\t\tif (isAuthorized) {\n\t\t\t\tchain.doFilter(request, response);\n\t\t\t} else {\n\t\t\t\tlogger.error(\"AUTHORIZATION FAILURE: User \" + userUid + \" in site \" +\n\t\t\t\t\tsiteContext + \" attempted to reach URL \" + request.getRequestURL());\n\t\t\t\t((HttpServletResponse)response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n\t\t\t}\n\t\t} else {\n\t\t\tif (selectSiteRedirect != null) {\n\t\t\t\t((HttpServletResponse)response).sendRedirect(selectSiteRedirect);\n\t\t\t} else {\n\t\t\t\t((HttpServletResponse)response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n\t\t\t}\n\t\t}\n\t}","commit_id":"90628c236c4d3d359dba00a0f23d26a3ac0f8afa","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void service(HttpServletRequest request,\n\tHttpServletResponse response, String path, String extra)\n\tthrows ServletException, IOException {\n\t\tfinal Interpretation cnt = (Interpretation)_cache.get(path);\n\t\tif (cnt == null) {\n\t\t\tif (Servlets.isIncluded(request)) log.error(\"Failed to load the resource: \"+path);\n\t\t\t\t//It might be eaten, so log the error\n\t\t\tresponse.sendError(response.SC_NOT_FOUND, path);\n\t\t\treturn;\n\t\t}\n\n\t\tStringWriter sw =\n\t\t\t_webctx.shallCompress(request, get2ndExtension(path)) ?\n\t\t\t\tnew StringWriter(4096): null;\n\t\tcnt.interpret(new ServletDspContext(\n\t\t\t_webctx.getServletContext(), request, response,\n\t\t\tsw, _webctx.getLocator()));\n\t\tif (extra != null)\n\t\t\t(sw != null ? (Writer)sw: response.getWriter()).write(extra);\n\t\tif (sw != null) {\n\t\t\tbyte[] data = sw.toString().getBytes(\"UTF-8\");\n\t\t\tsw = null; //free\n\t\t\tif (data.length > 200) {\n\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t\treturn; //done\n\t}","id":106664,"modified_method":"public void service(HttpServletRequest request,\n\tHttpServletResponse response, String path, String extra)\n\tthrows ServletException, IOException {\n\t\tfinal Interpretation cnt = (Interpretation)_cache.get(path);\n\t\tif (cnt == null) {\n\t\t\tif (Servlets.isIncluded(request)) log.error(\"Failed to load the resource: \"+path);\n\t\t\t\t//It might be eaten, so log the error\n\t\t\tresponse.sendError(response.SC_NOT_FOUND, path);\n\t\t\treturn;\n\t\t}\n\n\t\tStringWriter sw =\n\t\t\t_webctx.shallCompress(request, get2ndExtension(path)) ?\n\t\t\t\tnew StringWriter(4096): null;\n\t\tcnt.interpret(new ServletDspContext(\n\t\t\t_webctx.getServletContext(), request, response,\n\t\t\tsw, _webctx.getLocator()));\n\t\tif (extra != null)\n\t\t\t(sw != null ? (Writer)sw: response.getWriter()).write(extra);\n\n\t\tif (sw != null) {\n\t\t\tfinal String result = sw.toString();\n\t\t\tsw = null; //free\n\n\t\t\ttry {\n\t\t\t\tfinal OutputStream os = response.getOutputStream();\n\t\t\t\t\t//Call it first to ensure getWrite() is not called yet\n\n\t\t\t\tbyte[] data = result.getBytes(\"UTF-8\");\n\t\t\t\tif (data.length > 200) {\n\t\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t\t}\n\n\t\t\t\tresponse.setContentLength(data.length);\n\t\t\t\tos.write(data);\n\t\t\t} catch (IllegalStateException ex) { //getWriter is called\n\t\t\t\tresponse.getWriter().write(result);\n\t\t\t}\n\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t\treturn; //done\n\t}","commit_id":"50312ef1cbe30f909911582ed2bbb31c67a14411","url":"https://github.com/zkoss/zk"},{"original_method":"public void init(ServletConfig config) throws ServletException {\n\t\t//super.init(config);\n\t\t\t//Note callback super to avoid saving config\n\n\t\t_ctx = config.getServletContext();\n\n\t\tString s = config.getInitParameter(\"class-resource\");\n\t\tfinal boolean bClsRes = \"true\".equals(s);\n\t\t_locator = new Locator() {\n\t\t\tpublic String getDirectory() {\n\t\t\t\treturn null; //FUTURE: support relative path\n\t\t\t}\n\t\t\tpublic URL getResource(String name) {\n\t\t\t\tURL url = null;\n\t\t\t\tif (name.indexOf(\"://\") < 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turl = _ctx.getResource(name);\n\t\t\t\t\t\tif (bClsRes && url == null)\n\t\t\t\t\t\t\turl = ClassWebResource.getResource(name);\n\t\t\t\t\t} catch (java.net.MalformedURLException ex) { //eat it\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn url != null ? url: Taglibs.getDefaultURL(name);\n\t\t\t}\n\t\t\tpublic InputStream getResourceAsStream(String name) {\n\t\t\t\tInputStream is = _ctx.getResourceAsStream(name);\n\t\t\t\treturn !bClsRes || is != null ? is:\n\t\t\t\t\tClassWebResource.getResourceAsStream(name);\n\t\t\t}\n\t\t};\n\n\t\ts = config.getInitParameter(\"charset\");\n\t\tif (s != null) _charset = s.length() > 0 ? s: null;\n\t}","id":106665,"modified_method":"public void init(ServletConfig config) throws ServletException {\n\t\t//super.init(config);\n\t\t\t//Note callback super to avoid saving config\n\n\t\t_ctx = config.getServletContext();\n\n\t\tString param = config.getInitParameter(\"compress\");\n\t\tif (param != null)\n\t\t\t_compress = \"true\".equals(param);\n\n\t\tparam = config.getInitParameter(\"class-resource\");\n\t\tfinal boolean bClsRes = \"true\".equals(param);\n\t\t_locator = new Locator() {\n\t\t\tpublic String getDirectory() {\n\t\t\t\treturn null; //FUTURE: support relative path\n\t\t\t}\n\t\t\tpublic URL getResource(String name) {\n\t\t\t\tURL url = null;\n\t\t\t\tif (name.indexOf(\"://\") < 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turl = _ctx.getResource(name);\n\t\t\t\t\t\tif (bClsRes && url == null)\n\t\t\t\t\t\t\turl = ClassWebResource.getResource(name);\n\t\t\t\t\t} catch (java.net.MalformedURLException ex) { //eat it\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn url != null ? url: Taglibs.getDefaultURL(name);\n\t\t\t}\n\t\t\tpublic InputStream getResourceAsStream(String name) {\n\t\t\t\tInputStream is = _ctx.getResourceAsStream(name);\n\t\t\t\treturn !bClsRes || is != null ? is:\n\t\t\t\t\tClassWebResource.getResourceAsStream(name);\n\t\t\t}\n\t\t};\n\n\t\tparam = config.getInitParameter(\"charset\");\n\t\tif (param != null) _charset = param.length() > 0 ? param: null;\n\t}","commit_id":"50312ef1cbe30f909911582ed2bbb31c67a14411","url":"https://github.com/zkoss/zk"},{"original_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String path = Https.getThisServletPath(request);\n\t\tif (D.ON && log.debugable()) log.debug(\"Get \"+path);\n\n\t\tfinal Object old = Charsets.setup(request, response, _charset);\n\t\ttry {\n\t\t\tfinal Interpretation cnt = (Interpretation)\n\t\t\t\tResourceCaches.get(getCache(), _ctx, path, null);\n\t\t\tif (cnt == null) {\n\t\t\t\tif (Https.isIncluded(request)) log.error(\"Not found: \"+path);\n\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcnt.interpret(\n\t\t\t\tnew ServletDspContext(_ctx, request, response, null));\n\t\t} finally {\n\t\t\tCharsets.cleanup(request, old);\n\t\t}\n\t}","id":106666,"modified_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String path = Https.getThisServletPath(request);\n\t\tif (D.ON && log.debugable()) log.debug(\"Get \"+path);\n\n\t\tfinal Object old = Charsets.setup(request, response, _charset);\n\t\ttry {\n\t\t\tfinal Interpretation cnt = (Interpretation)\n\t\t\t\tResourceCaches.get(getCache(), _ctx, path, null);\n\t\t\tif (cnt == null) {\n\t\t\t\tif (Https.isIncluded(request)) log.error(\"Not found: \"+path);\n\t\t\t\t\t//It might be eaten, so log the error\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, path);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfinal boolean compress = _compress && !Servlets.isIncluded(request);\n\t\t\tfinal StringWriter out = compress ? new StringWriter(): null;\n\t\t\tcnt.interpret(\n\t\t\t\tnew ServletDspContext(_ctx, request, response, out, null));\n\n\t\t\tif (compress) {\n\t\t\t\tfinal String result = out.toString();\n\n\t\t\t\ttry {\n\t\t\t\t\tfinal OutputStream os = response.getOutputStream();\n\t\t\t\t\t\t//Call it first to ensure getWrite() is not called yet\n\t\n\t\t\t\t\tbyte[] data = result.getBytes(\"UTF-8\");\n\t\t\t\t\tif (data.length > 200) {\n\t\t\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresponse.setContentLength(data.length);\n\t\t\t\t\tos.write(data);\n\t\t\t\t\tresponse.flushBuffer();\n\t\t\t\t} catch (IllegalStateException ex) { //getWriter is called\n\t\t\t\t\tresponse.getWriter().write(result);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tCharsets.cleanup(request, old);\n\t\t}\n\t}","commit_id":"50312ef1cbe30f909911582ed2bbb31c67a14411","url":"https://github.com/zkoss/zk"},{"original_method":"public List<RouteSegmentResult> searchRoute(final RoutingContext ctx, RouteSegment start, RouteSegment end, boolean leftSideNavigation) throws IOException, InterruptedException {\n\t\tList<RouteSegmentResult> result = searchRouteInternalPrepare(ctx, start, end, leftSideNavigation);\n\t\tif(result != null) {\n\t\t\tprintResults(ctx, start, end, result);\n\t\t}\n\t\tif (RoutingContext.SHOW_GC_SIZE) {\n\t\t\tint sz = ctx.global.size;\n\t\t\tSystem.out.println(\"Subregion size \" + ctx.subregionTiles.size() + \" \" + \" tiles \" + ctx.tiles.size());\n\t\t\tctx.runGCUsedMemory();\n\t\t\tlong h1 = ctx.runGCUsedMemory();\n\t\t\tctx.unloadAllData();\n\t\t\tctx.runGCUsedMemory();\n\t\t\tlong h2 = ctx.runGCUsedMemory();\n\t\t\tfloat mb = (1 << 20);\n\t\t\tlog.warn(\"Unload context :  estimated \" + sz / mb + \" ?= \" + (h1 - h2) / mb + \" actual\");\n\t\t}\n\t\treturn result;\n\t}","id":106667,"modified_method":"public List<RouteSegmentResult> searchRoute(final RoutingContext ctx, RouteSegment start, RouteSegment end, boolean leftSideNavigation) throws IOException, InterruptedException {\n\t\tList<RouteSegmentResult> result = searchRouteInternalPrepare(ctx, start, end, leftSideNavigation);\n\t\tif(result != null) {\n\t\t\tprintResults(ctx, start, end, result);\n\t\t}\n\t\tif (RoutingContext.SHOW_GC_SIZE) {\n\t\t\tint sz = ctx.global.size;\n\t\t\tlog.warn(\"Subregion size \" + ctx.subregionTiles.size() + \" \" + \" tiles \" + ctx.indexedSubregions.size());\n\t\t\tctx.runGCUsedMemory();\n\t\t\tlong h1 = ctx.runGCUsedMemory();\n\t\t\tctx.unloadAllData();\n\t\t\tctx.runGCUsedMemory();\n\t\t\tlong h2 = ctx.runGCUsedMemory();\n\t\t\tfloat mb = (1 << 20);\n\t\t\tlog.warn(\"Unload context :  estimated \" + sz / mb + \" ?= \" + (h1 - h2) / mb + \" actual\");\n\t\t}\n\t\treturn result;\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void loadTileHeaders(RoutingTile tile) {\n\t\tfinal int zoomToLoad = 31 - tile.getZoom();\n\t\tfinal int tileX = tile.getTileX();\n\t\tfinal int tileY = tile.getTileY();\n\t\t\n\t\tSearchRequest<RouteDataObject> request = BinaryMapIndexReader.buildSearchRouteRequest(tileX << zoomToLoad,\n\t\t\t\t(tileX + 1) << zoomToLoad, tileY << zoomToLoad, (tileY + 1) << zoomToLoad, null);\n\t\tfor (Entry<BinaryMapIndexReader, List<RouteSubregion>> r : map.entrySet()) {\n\t\t\tif(nativeLib == null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (r.getValue().size() > 0) {\n\t\t\t\t\t\tlong now = System.nanoTime();\n//\t\t\t\t\t\tint rg = r.getValue().get(0).routeReg.regionsRead;\n\t\t\t\t\t\tList<RouteSubregion> subregs = r.getKey().searchRouteIndexTree(request, r.getValue());\n\t\t\t\t\t\tfor (RouteSubregion sr : subregs) {\n\t\t\t\t\t\t\tint ind = searchSubregionTile(sr);\n\t\t\t\t\t\t\tRoutingSubregionTile found;\n\t\t\t\t\t\t\tif (ind < 0) {\n\t\t\t\t\t\t\t\tfound = new RoutingSubregionTile(sr);\n\t\t\t\t\t\t\t\tsubregionTiles.add(-(ind + 1), found);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfound = subregionTiles.get(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttile.searchSubregionAndAdd(sr, found);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeToLoadHeaders += (System.nanoTime() - now);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(\"Loading data exception\", e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\t\ttile.setHeadersLoaded();\n\t\t\n\t}","id":106668,"modified_method":"private List<RoutingSubregionTile> loadTileHeaders(final int x31, final int y31) {\n\t\tfinal int zoomToLoad = 31 - config.ZOOM_TO_LOAD_TILES;\n\t\tint tileX = x31 >> zoomToLoad;\n\t\tint tileY = y31 >> zoomToLoad;\n\t\t\n\t\tSearchRequest<RouteDataObject> request = BinaryMapIndexReader.buildSearchRouteRequest(tileX << zoomToLoad,\n\t\t\t\t(tileX + 1) << zoomToLoad, tileY << zoomToLoad, (tileY + 1) << zoomToLoad, null);\n\t\tList<RoutingSubregionTile> collection = null;\n\t\tfor (Entry<BinaryMapIndexReader, List<RouteSubregion>> r : map.entrySet()) {\n\t\t\tif(nativeLib == null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (r.getValue().size() > 0) {\n\t\t\t\t\t\tlong now = System.nanoTime();\n//\t\t\t\t\t\tint rg = r.getValue().get(0).routeReg.regionsRead;\n\t\t\t\t\t\tList<RouteSubregion> subregs = r.getKey().searchRouteIndexTree(request, r.getValue());\n\t\t\t\t\t\tfor (RouteSubregion sr : subregs) {\n\t\t\t\t\t\t\tint ind = searchSubregionTile(sr);\n\t\t\t\t\t\t\tRoutingSubregionTile found;\n\t\t\t\t\t\t\tif (ind < 0) {\n\t\t\t\t\t\t\t\tfound = new RoutingSubregionTile(sr);\n\t\t\t\t\t\t\t\tsubregionTiles.add(-(ind + 1), found);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfound = subregionTiles.get(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(collection == null) {\n\t\t\t\t\t\t\t\tcollection = new ArrayList<RoutingContext.RoutingSubregionTile>(4);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcollection.add(found);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeToLoadHeaders += (System.nanoTime() - now);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(\"Loading data exception\", e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\t\treturn collection;\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void registerRouteDataObject(int x31, int y31, RouteDataObject o ) {\n\t\tif(!getRouter().acceptLine(o)){\n\t\t\treturn;\n\t\t}\n\t\tgetRoutingTile(x31, y31, false).registerRouteDataObject(o);\n\t}","id":106669,"modified_method":"public void registerRouteDataObject(int x31, int y31, RouteDataObject o ) {\n\t\tif(!getRouter().acceptLine(o)){\n\t\t\treturn;\n\t\t}\n\t\tlong tileId = getRoutingTile(x31, y31, false);\n\t\tList<RouteDataObject> routes = tileRoutes.get(tileId);\n\t\tif(routes == null){\n\t\t\troutes = new ArrayList<RouteDataObject>();\n\t\t\ttileRoutes.put(tileId, routes);\n\t\t}\n\t\troutes.add(o);\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void unloadAllData(RoutingContext except) {\n\t\tfor (RoutingSubregionTile tl : subregionTiles) {\n\t\t\tif (tl.isLoaded()) {\n\t\t\t\tif(except == null || except.searchSubregionTile(tl.subregion) < 0){\n\t\t\t\t\ttl.unload();\n\t\t\t\t\tunloadedTiles ++;\n\t\t\t\t\tglobal.size -= tl.tileStatistics.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubregionTiles.clear();\n\t\ttiles.clear();\t\t\n\t}","id":106670,"modified_method":"public void unloadAllData(RoutingContext except) {\n\t\tfor (RoutingSubregionTile tl : subregionTiles) {\n\t\t\tif (tl.isLoaded()) {\n\t\t\t\tif(except == null || except.searchSubregionTile(tl.subregion) < 0){\n\t\t\t\t\ttl.unload();\n\t\t\t\t\tunloadedTiles ++;\n\t\t\t\t\tglobal.size -= tl.tileStatistics.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubregionTiles.clear();\n\t\ttileRoutes.clear();\t\t\n\t\tindexedSubregions.clear();\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private int searchSubregionTile(RouteSubregion subregion){\n\t\tRoutingSubregionTile key = new RoutingSubregionTile(subregion);\n\t\tint ind = Collections.binarySearch(subregionTiles, key, new Comparator<RoutingSubregionTile>() {\n\t\t\t@Override\n\t\t\tpublic int compare(RoutingSubregionTile o1, RoutingSubregionTile o2) {\n\t\t\t\tif(o1.subregion.left == o2.subregion.left) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn o1.subregion.left < o2.subregion.left ? 1 : -1;\n\t\t\t}\n\t\t});\n\t\tif (ind >= 0) {\n\t\t\tfor (int i = ind; i <= subregionTiles.size(); i++) {\n\t\t\t\tif (i == subregionTiles.size() || subregionTiles.get(i).subregion.left > subregion.left) {\n\t\t\t\t\tind = -i - 1;\n\t\t\t\t\treturn ind;\n\t\t\t\t}\n\t\t\t\tif (subregionTiles.get(i).subregion == subregion) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ind;\n\t}","id":106671,"modified_method":"private int searchSubregionTile(RouteSubregion subregion){\n\t\tRoutingSubregionTile key = new RoutingSubregionTile(subregion);\n\t\tlong now = System.nanoTime();\n\t\tint ind = Collections.binarySearch(subregionTiles, key, new Comparator<RoutingSubregionTile>() {\n\t\t\t@Override\n\t\t\tpublic int compare(RoutingSubregionTile o1, RoutingSubregionTile o2) {\n\t\t\t\tif(o1.subregion.left == o2.subregion.left) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn o1.subregion.left < o2.subregion.left ? 1 : -1;\n\t\t\t}\n\t\t});\n\t\tif (ind >= 0) {\n\t\t\tfor (int i = ind; i <= subregionTiles.size(); i++) {\n\t\t\t\tif (i == subregionTiles.size() || subregionTiles.get(i).subregion.left > subregion.left) {\n\t\t\t\t\tind = -i - 1;\n\t\t\t\t\treturn ind;\n\t\t\t\t}\n\t\t\t\tif (subregionTiles.get(i).subregion == subregion) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttimeToLoadHeaders += (System.nanoTime() - now);\n\t\treturn ind;\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public RouteSegment loadRouteSegment(int x31, int y31) {\n\t\tfinal RoutingTile tile = getRoutingTile(x31, y31, true);\n\t\treturn tile.getSegment(x31, y31, this);\n\t}","id":106672,"modified_method":"public RouteSegment loadRouteSegment(int x31, int y31) {\n\t\tlong tileId = getRoutingTile(x31, y31, true);\n\t\tTLongObjectHashMap<RouteDataObject> excludeDuplications = new TLongObjectHashMap<RouteDataObject>();\n\t\tRouteSegment original = null;\n\t\tif (tileRoutes.containsKey(tileId)) {\n\t\t\tList<RouteDataObject> routes = tileRoutes.get(tileId);\n\t\t\tif (routes != null) {\n\t\t\t\tfor (RouteDataObject ro : routes) {\n\t\t\t\t\tfor (int i = 0; i < ro.pointsX.length; i++) {\n\t\t\t\t\t\tif (ro.getPoint31XTile(i) == x31 && ro.getPoint31YTile(i) == y31) {\n\t\t\t\t\t\t\texcludeDuplications.put(ro.id, ro);\n\t\t\t\t\t\t\tRouteSegment segment = new RouteSegment(ro, i);\n\t\t\t\t\t\t\tsegment.next = original;\n\t\t\t\t\t\t\toriginal = segment;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<RoutingSubregionTile> subregions = indexedSubregions.get(tileId);\n\t\tif (subregions != null) {\n\t\t\tfor (RoutingSubregionTile rs : subregions) {\n\t\t\t\toriginal = rs.loadRouteSegment(x31, y31, this, excludeDuplications, original);\n\t\t\t}\n\t\t}\n\t\treturn original;\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private RoutingTile getRoutingTile(int x31, int y31, boolean load){\n//\t\tlong now = System.nanoTime();\n\t\tint xloc = x31 >> (31 - config.ZOOM_TO_LOAD_TILES);\n\t\tint yloc = y31 >> (31 - config.ZOOM_TO_LOAD_TILES);\n\t\tint l = (xloc << config.ZOOM_TO_LOAD_TILES) + yloc;\n\t\tRoutingTile tile = tiles.get(l);\n\t\tif(tile == null) {\n\t\t\ttile = new RoutingTile(xloc, yloc, config.ZOOM_TO_LOAD_TILES);\n\t\t\ttiles.put(l, tile);\n\t\t}\n\t\tif (load) {\n\t\t\tif (getCurrentEstimatedSize() > 0.95 * config.memoryLimitation) {\n\t\t\t\tint sz1 = getCurrentEstimatedSize();\n\t\t\t\tlong h1 = 0;\n\t\t\t\tif (SHOW_GC_SIZE && sz1 > 0.7 * config.memoryLimitation) {\n\t\t\t\t\trunGCUsedMemory();\n\t\t\t\t\th1 = runGCUsedMemory();\n\t\t\t\t}\n\t\t\t\tint clt = getCurrentlyLoadedTiles();\n\t\t\t\tunloadUnusedTiles();\n\t\t\t\tif (h1 != 0 && getCurrentlyLoadedTiles() != clt) {\n\t\t\t\t\tint sz2 = getCurrentEstimatedSize();\n\t\t\t\t\trunGCUsedMemory();\n\t\t\t\t\tlong h2 = runGCUsedMemory();\n\t\t\t\t\tfloat mb = (1 << 20);\n\t\t\t\t\tlog.warn(\"Unload tiles :  estimated \" + (sz1 - sz2) / mb + \" ?= \" + (h1 - h2) / mb + \" actual\");\n\t\t\t\t\tlog.warn(\"Used after \" + h2 / mb + \" of \" + Runtime.getRuntime().totalMemory() / mb + \" max \"\n\t\t\t\t\t\t\t+ Runtime.getRuntime().maxMemory() / mb);\n\t\t\t\t} else {\n//\t\t\t\t\tfloat mb = (1 << 20);\n//\t\t\t\t\tint sz2 = getCurrentEstimatedSize();\n//\t\t\t\t\tlog.warn(\"Unload tiles :  occupied before \" + sz1 / mb + \" Mb - now  \" + sz2 / mb + \"MB \");\n//\t\t\t\t\tlog.warn(\"Memory free \" + Runtime.getRuntime().freeMemory() / mb + \" of \" + Runtime.getRuntime().totalMemory() / mb\n//\t\t\t\t\t\t\t+ \" max \" + Runtime.getRuntime().maxMemory() / mb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tile.isHeadersLoaded()) {\n\t\t\t\tloadTileHeaders(tile);\n\t\t\t}\n\t\t\tfor (RoutingSubregionTile ts : tile.subregions) {\n\t\t\t\tif (!ts.isLoaded()) {\n\t\t\t\t\tloadSubregionTile(ts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttimeToLoad += (System.nanoTime() - now);\n\t\treturn tile;\n\t}","id":106673,"modified_method":"private long getRoutingTile(int x31, int y31, boolean load){\n//\t\tlong now = System.nanoTime();\n\t\tlong xloc = x31 >> (31 - config.ZOOM_TO_LOAD_TILES);\n\t\tlong yloc = y31 >> (31 - config.ZOOM_TO_LOAD_TILES);\n\t\tlong tileId = (xloc << config.ZOOM_TO_LOAD_TILES) + yloc;\n\t\tif (load) {\n\t\t\tif (getCurrentEstimatedSize() > 0.95 * config.memoryLimitation) {\n\t\t\t\tint sz1 = getCurrentEstimatedSize();\n\t\t\t\tlong h1 = 0;\n\t\t\t\tif (SHOW_GC_SIZE && sz1 > 0.7 * config.memoryLimitation) {\n\t\t\t\t\trunGCUsedMemory();\n\t\t\t\t\th1 = runGCUsedMemory();\n\t\t\t\t}\n\t\t\t\tint clt = getCurrentlyLoadedTiles();\n\t\t\t\tunloadUnusedTiles();\n\t\t\t\tif (h1 != 0 && getCurrentlyLoadedTiles() != clt) {\n\t\t\t\t\tint sz2 = getCurrentEstimatedSize();\n\t\t\t\t\trunGCUsedMemory();\n\t\t\t\t\tlong h2 = runGCUsedMemory();\n\t\t\t\t\tfloat mb = (1 << 20);\n\t\t\t\t\tlog.warn(\"Unload tiles :  estimated \" + (sz1 - sz2) / mb + \" ?= \" + (h1 - h2) / mb + \" actual\");\n\t\t\t\t\tlog.warn(\"Used after \" + h2 / mb + \" of \" + Runtime.getRuntime().totalMemory() / mb + \" max \"\n\t\t\t\t\t\t\t+ Runtime.getRuntime().maxMemory() / mb);\n\t\t\t\t} else {\n\t\t\t\t\t// float mb = (1 << 20);\n\t\t\t\t\t// int sz2 = getCurrentEstimatedSize();\n\t\t\t\t\t// log.warn(\"Unload tiles :  occupied before \" + sz1 / mb + \" Mb - now  \" + sz2 / mb + \"MB \");\n\t\t\t\t\t// log.warn(\"Memory free \" + Runtime.getRuntime().freeMemory() / mb + \" of \" + Runtime.getRuntime().totalMemory() / mb\n\t\t\t\t\t// + \" max \" + Runtime.getRuntime().maxMemory() / mb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!indexedSubregions.containsKey(tileId)) {\n\t\t\t\tList<RoutingSubregionTile> collection = loadTileHeaders(x31, y31);\n\t\t\t\tindexedSubregions.put(tileId, collection);\n\t\t\t}\n\t\t\tList<RoutingSubregionTile> subregions = indexedSubregions.get(tileId);\n\t\t\tif (subregions != null) {\n\t\t\t\tfor (RoutingSubregionTile ts : subregions) {\n\t\t\t\t\tif (!ts.isLoaded()) {\n\t\t\t\t\t\tloadSubregionTile(ts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// timeToLoad += (System.nanoTime() - now);\n\t\treturn tileId;\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void loadTileData(int x31, int y31, int zoomAround, final List<RouteDataObject> toFillIn) {\n\t\tint coordinatesShift = (1 << (31 - zoomAround));\n\t\t// put in map to avoid duplicate map loading\n\t\tTIntObjectHashMap<RoutingTile> ts = new TIntObjectHashMap<RoutingContext.RoutingTile>();\n\t\tlong now = System.nanoTime();\n\t\tRoutingTile rt = getRoutingTile(x31 - coordinatesShift, y31 - coordinatesShift, true);\n\t\tts.put(rt.getId(), rt);\n\t\trt = getRoutingTile(x31 + coordinatesShift, y31 - coordinatesShift, true);\n\t\tts.put(rt.getId(), rt);\n\t\trt = getRoutingTile(x31 - coordinatesShift, y31 + coordinatesShift, true);\n\t\tts.put(rt.getId(), rt);\n\t\trt = getRoutingTile(x31 + coordinatesShift, y31 + coordinatesShift, true);\n\t\tts.put(rt.getId(), rt);\n\n\t\tIterator<RoutingTile> it = ts.valueCollection().iterator();\n\t\t\n\t\twhile (it.hasNext()) {\n\t\t\tRoutingTile tl = it.next();\n\t\t\ttl.getAllObjects(toFillIn, this);\n\t\t}\n\t\ttimeToFindInitialSegments += (System.nanoTime() - now);\n\t}","id":106674,"modified_method":"public void loadTileData(int x31, int y31, int zoomAround, final List<RouteDataObject> toFillIn) {\n\t\tint coordinatesShift = (1 << (31 - zoomAround));\n\t\t// put in map to avoid duplicate map loading\n//\t\tTIntObjectHashMap<RoutingTile> ts = new TIntObjectHashMap<RoutingContext.RoutingTile>();\n\t\tTLongHashSet ts = new TLongHashSet(); \n\t\tlong now = System.nanoTime();\n\t\tts.add(getRoutingTile(x31 - coordinatesShift, y31 - coordinatesShift, true));\n\t\tts.add(getRoutingTile(x31 + coordinatesShift, y31 - coordinatesShift, true));\n\t\tts.add(getRoutingTile(x31 - coordinatesShift, y31 + coordinatesShift, true));\n\t\tts.add(getRoutingTile(x31 + coordinatesShift, y31 + coordinatesShift, true));\n\t\tTLongIterator it = ts.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tgetAllObjects(it.next(), toFillIn);\n\t\t}\n\t\ttimeToFindInitialSegments += (System.nanoTime() - now);\n\t}","commit_id":"ccb1bcdfdb5c716c565627f0da78e3793ce85984","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Wraps an entity spec so its configuration can be overridden without modifying the \n     * original entity spec.\n     */\n    public static <T extends Entity> WrappingEntitySpec<T> wrapSpec(EntitySpec<? extends T> spec) {\n        return WrappingEntitySpec.newInstance(spec);\n    }","id":106675,"modified_method":"/**\n     * Wraps an entity spec so its configuration can be overridden without modifying the \n     * original entity spec.\n     * \n     * @deprecated since 0.6.0; use {@link EntitySpec#create(EntitySpec)} - though note that\n     * semantics are slightly different there, the new method copies the spec so if the wrapped \n     * entity changes the new method will not pick up those changes; \n     * no plans at present to continue to support the delegation pattern (is there any need?)\n     */\n    public static <T extends Entity> WrappingEntitySpec<T> wrapSpec(EntitySpec<? extends T> spec) {\n        return WrappingEntitySpec.newInstance(spec);\n    }","commit_id":"c2aa922fe55cc10b3c72720027512fabb1c0d58c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n        public OsDetails getOsDetails() {\n            return new BasicOsDetails.Factory().newLocalhostInstance();\n        }","id":106676,"modified_method":"@Override\n        public OsDetails getOsDetails() {\n            return BasicOsDetails.Factory.newLocalhostInstance();\n        }","commit_id":"c2aa922fe55cc10b3c72720027512fabb1c0d58c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public boolean obtainSpecificPort(int portNumber) {\n            return LocalhostMachineProvisioningLocation.obtainSpecificPort(getAddress(), portNumber);\n        }","id":106677,"modified_method":"public boolean obtainSpecificPort(int portNumber) {\n            if (!isSudoAllowed() && portNumber <= 1024)\n                return false;\n            return LocalhostMachineProvisioningLocation.obtainSpecificPort(getAddress(), portNumber);\n        }","commit_id":"c2aa922fe55cc10b3c72720027512fabb1c0d58c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Integer convertConfigToSensor(PortRange value, Entity entity) {\n        if (value==null) return null;\n        Collection<Location> locations = entity.getLocations();\n        if (!locations.isEmpty()) {\n            if (locations.size()==1) {\n                Location l = locations.iterator().next();\n                if (l instanceof PortSupplier) {\n                    int p = ((PortSupplier)l).obtainPort(value);\n                    if (p!=-1) {\n                        LOG.debug(\"\"+entity+\" choosing port \"+p+\" for \"+getName());\n                        return p;\n                    }\n                    LOG.warn(\"\"+entity+\" no port available for \"+getName()+\" in range \"+value);\n                    // definitively, no ports available\n                    return null;\n                }\n                // ports may be available, we just can't tell from the location\n                Integer v = (value.isEmpty() ? null : value.iterator().next());\n                LOG.debug(\"\"+entity+\" choosing port \"+v+\" (unconfirmed) for \"+getName());\n                return v;\n            } else {\n                LOG.warn(\"\"+entity+\" ports not applicable, or not yet applicable, because has multiple locations \"+locations+\"; ignoring \"+getName());       \n            }\n        } else {\n            LOG.warn(\"\"+entity+\" ports not applicable, or not yet applicable, bacause has no locations, ignoring \"+getName());\n        }\n        return null;\n    }","id":106678,"modified_method":"protected Integer convertConfigToSensor(PortRange value, Entity entity) {\n        if (value==null) return null;\n        Collection<Location> locations = entity.getLocations();\n        if (!locations.isEmpty()) {\n            if (locations.size()==1) {\n                Location l = locations.iterator().next();\n                if (l instanceof PortSupplier) {\n                    int p = ((PortSupplier)l).obtainPort(value);\n                    if (p!=-1) {\n                        LOG.debug(\"\"+entity+\" choosing port \"+p+\" for \"+getName());\n                        return p;\n                    }\n                    int rangeSize = Iterables.size(value);\n                    if (rangeSize==0)\n                        LOG.warn(\"\"+entity+\" no port available for \"+getName()+\" (empty range \"+value+\")\");\n                    else if (rangeSize==1) {\n                        Integer pp = value.iterator().next();\n                        if (pp>1024)\n                            LOG.warn(\"\"+entity+\" port \"+pp+\" not available for \"+getName());\n                        else \n                            LOG.warn(\"\"+entity+\" port \"+pp+\" not available for \"+getName()+\" (root may be required?)\");\n                    } else {\n                        LOG.warn(\"\"+entity+\" no port available for \"+getName()+\" (tried range \"+value+\")\");\n                    }\n                    // definitively, no ports available\n                    return null;\n                }\n                // ports may be available, we just can't tell from the location\n                Integer v = (value.isEmpty() ? null : value.iterator().next());\n                LOG.debug(\"\"+entity+\" choosing port \"+v+\" (unconfirmed) for \"+getName());\n                return v;\n            } else {\n                LOG.warn(\"\"+entity+\" ports not applicable, or not yet applicable, because has multiple locations \"+locations+\"; ignoring \"+getName());       \n            }\n        } else {\n            LOG.warn(\"\"+entity+\" ports not applicable, or not yet applicable, bacause has no locations, ignoring \"+getName());\n        }\n        return null;\n    }","commit_id":"c2aa922fe55cc10b3c72720027512fabb1c0d58c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** creates a task which returns modifies sudoers to ensure non-tty access is permitted;\n     * also gives nice warnings if sudo is not permitted */\n    public static ProcessTaskFactory<Boolean> dontRequireTtyForSudo(SshMachineLocation machine, final boolean requireSuccess) {\n        return newSshExecTaskFactory(machine, \n                BashCommands.dontRequireTtyForSudo())\n            .summary(\"setting up sudo\")\n            .configure(SshTool.PROP_ALLOCATE_PTY, true)\n            .allowingNonZeroExitCode()\n            .returning(new Function<ProcessTaskWrapper<?>,Boolean>() { public Boolean apply(ProcessTaskWrapper<?> task) {\n                if (task.getExitCode()==0) return true;\n                log.warn(\"Error setting up sudo for \"+task.getMachine().getUser()+\"@\"+task.getMachine().getAddress().getHostName()+\" \"+\n                        \" (exit code \"+task.getExitCode()+\")\");\n                Streams.logStreamTail(log, \"STDERR of sudo setup problem\", Streams.byteArrayOfString(task.getStderr()), 1024);\n                if (requireSuccess) {\n                    throw new IllegalStateException(\"Passwordless sudo is required for \"+task.getMachine().getUser()+\"@\"+task.getMachine().getAddress().getHostName());\n                }\n                return true; \n            } });\n    }","id":106679,"modified_method":"/** creates a task which returns modifies sudoers to ensure non-tty access is permitted;\n     * also gives nice warnings if sudo is not permitted */\n    public static ProcessTaskFactory<Boolean> dontRequireTtyForSudo(SshMachineLocation machine, final boolean requireSuccess) {\n        return newSshExecTaskFactory(machine, \n                BashCommands.dontRequireTtyForSudo())\n            .summary(\"setting up sudo\")\n            .configure(SshTool.PROP_ALLOCATE_PTY, true)\n            .allowingNonZeroExitCode()\n            .returning(new Function<ProcessTaskWrapper<?>,Boolean>() { public Boolean apply(ProcessTaskWrapper<?> task) {\n                if (task.getExitCode()==0) return true;\n                log.warn(\"Error setting up sudo for \"+task.getMachine().getUser()+\"@\"+task.getMachine().getAddress().getHostName()+\" \"+\n                        \" (exit code \"+task.getExitCode()+\")\");\n                Streams.logStreamTail(log, \"STDERR of sudo setup problem\", Streams.byteArrayOfString(task.getStderr()), 1024);\n                if (requireSuccess) {\n                    Entity entity = BrooklynTasks.getTargetOrContextEntity(Tasks.current());\n                    throw new IllegalStateException(\"Passwordless sudo is required for \"+task.getMachine().getUser()+\"@\"+task.getMachine().getAddress().getHostName()+\n                            (entity!=null ? \" (\"+entity+\")\" : \"\"));\n                }\n                return true; \n            } });\n    }","commit_id":"c2aa922fe55cc10b3c72720027512fabb1c0d58c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */\n        int count = -1;\n        if (dataLengthBuffer.remaining() > 0) {\n          count = channelRead(channel, dataLengthBuffer);\n          if (count < 0 || dataLengthBuffer.remaining() > 0)\n            return count;\n        }\n\n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer == null) {\n            rpcHeaderBuffer = ByteBuffer.allocate(2);\n          }\n          count = channelRead(channel, rpcHeaderBuffer);\n          if (count < 0 || rpcHeaderBuffer.remaining() > 0) {\n            return count;\n          }\n          int version = rpcHeaderBuffer.get(0);\n          byte[] method = new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod = AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            LOG.warn(\"Incorrect header or version mismatch from \" +\n                     hostAddress + \":\" + remotePort +\n                     \" got version \" + version +\n                     \" expected version \" + CURRENT_VERSION);\n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod == null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {\n            AccessControlException ae = new AccessControlException(\n                \"Authentication is required\");\n            SecureCall failedCall = new SecureCall(AUTHORIZATION_FAILED_CALLID, null, this,\n                null, 0);\n            failedCall.setResponse(null, Status.FATAL, ae.getClass().getName(),\n                ae.getMessage());\n            responder.doRespond(failedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                HBaseSaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod = AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake = true;\n          }\n          if (authMethod != AuthMethod.SIMPLE) {\n            useSasl = true;\n          }\n\n          rpcHeaderBuffer = null;\n          rpcHeaderRead = true;\n          continue;\n        }\n\n        if (data == null) {\n          dataLengthBuffer.flip();\n          dataLength = dataLengthBuffer.getInt();\n\n          if (dataLength == HBaseClient.PING_CALL_ID) {\n            if(!useWrap) { //covers the !useSasl too\n              dataLengthBuffer.clear();\n              return 0;  //ping message\n            }\n          }\n          if (dataLength < 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" +\n                getHostAddress());\n          }\n          data = ByteBuffer.allocate(dataLength);\n          incRpcCount();  // Increment the rpc count\n        }\n\n        count = channelRead(channel, data);\n\n        if (data.remaining() == 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data = null;\n            skipInitialSaslHandshake = false;\n            continue;\n          }\n          boolean isHeaderRead = headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data = null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        }\n        return count;\n      }\n    }","id":106680,"modified_method":"public int readAndProcess() throws IOException, InterruptedException {\n      while (true) {\n        /* Read at most one RPC. If the header is not read completely yet\n         * then iterate until we read first RPC or until there is no data left.\n         */\n        int count = -1;\n        if (dataLengthBuffer.remaining() > 0) {\n          count = channelRead(channel, dataLengthBuffer);\n          if (count < 0 || dataLengthBuffer.remaining() > 0)\n            return count;\n        }\n\n        if (!rpcHeaderRead) {\n          //Every connection is expected to send the header.\n          if (rpcHeaderBuffer == null) {\n            rpcHeaderBuffer = ByteBuffer.allocate(2);\n          }\n          count = channelRead(channel, rpcHeaderBuffer);\n          if (count < 0 || rpcHeaderBuffer.remaining() > 0) {\n            return count;\n          }\n          int version = rpcHeaderBuffer.get(0);\n          byte[] method = new byte[] {rpcHeaderBuffer.get(1)};\n          authMethod = AuthMethod.read(new DataInputStream(\n              new ByteArrayInputStream(method)));\n          dataLengthBuffer.flip();\n          if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {\n            //Warning is ok since this is not supposed to happen.\n            if (INSECURE_VERSIONS.contains(version)) {\n              LOG.warn(\"An insecure client (version '\" + version + \"') is attempting to connect \" +\n                  \" to this version '\" + CURRENT_VERSION + \"' secure server from \" +\n                  hostAddress + \":\" + remotePort);\n            } else {\n              LOG.warn(\"Incorrect header or version mismatch from \" +\n                  hostAddress + \":\" + remotePort +\n                  \" got version \" + version +\n                  \" expected version \" + CURRENT_VERSION);              \n            }\n            \n            return -1;\n          }\n          dataLengthBuffer.clear();\n          if (authMethod == null) {\n            throw new IOException(\"Unable to read authentication method\");\n          }\n          if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {\n            AccessControlException ae = new AccessControlException(\n                \"Authentication is required\");\n            SecureCall failedCall = new SecureCall(AUTHORIZATION_FAILED_CALLID, null, this,\n                null, 0);\n            failedCall.setResponse(null, Status.FATAL, ae.getClass().getName(),\n                ae.getMessage());\n            responder.doRespond(failedCall);\n            throw ae;\n          }\n          if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {\n            doSaslReply(SaslStatus.SUCCESS, new IntWritable(\n                HBaseSaslRpcServer.SWITCH_TO_SIMPLE_AUTH), null, null);\n            authMethod = AuthMethod.SIMPLE;\n            // client has already sent the initial Sasl message and we\n            // should ignore it. Both client and server should fall back\n            // to simple auth from now on.\n            skipInitialSaslHandshake = true;\n          }\n          if (authMethod != AuthMethod.SIMPLE) {\n            useSasl = true;\n          }\n\n          rpcHeaderBuffer = null;\n          rpcHeaderRead = true;\n          continue;\n        }\n\n        if (data == null) {\n          dataLengthBuffer.flip();\n          dataLength = dataLengthBuffer.getInt();\n\n          if (dataLength == HBaseClient.PING_CALL_ID) {\n            if(!useWrap) { //covers the !useSasl too\n              dataLengthBuffer.clear();\n              return 0;  //ping message\n            }\n          }\n          if (dataLength < 0) {\n            LOG.warn(\"Unexpected data length \" + dataLength + \"!! from \" +\n                getHostAddress());\n          }\n          data = ByteBuffer.allocate(dataLength);\n          incRpcCount();  // Increment the rpc count\n        }\n\n        count = channelRead(channel, data);\n\n        if (data.remaining() == 0) {\n          dataLengthBuffer.clear();\n          data.flip();\n          if (skipInitialSaslHandshake) {\n            data = null;\n            skipInitialSaslHandshake = false;\n            continue;\n          }\n          boolean isHeaderRead = headerRead;\n          if (useSasl) {\n            saslReadAndProcess(data.array());\n          } else {\n            processOneRpc(data.array());\n          }\n          data = null;\n          if (!isHeaderRead) {\n            continue;\n          }\n        }\n        return count;\n      }\n    }","commit_id":"00781a6eb181ec379881a624a8b97d7aeabd3651","url":"https://github.com/apache/hbase"},{"original_method":"public void update( Cluster cluster, List<ClusterAddressInfo> ccList ) {\n    if ( !cluster.getState( ).isAddressingInitialized( ) ) {\n      Helper.loadStoredAddresses( cluster );\n      cluster.getState( ).setAddressingInitialized( true );\n    }\n    for( ClusterAddressInfo addrInfo : ccList ) {\n      try {\n        Address address = Helper.lookupOrCreate( cluster, addrInfo );\n        if( address.isAllocated( ) && Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) ) {\n          address.allocate( Component.eucalyptus.name( ) );\n          address.clearPending( );\n          cluster.getState( ).clearOrphan( addrInfo );\n        } else if ( address.isAssigned( ) ) {\n          try {\n            VmInstance vm = VmInstances.getInstance( ).lookupByInstanceIp( addrInfo.getInstanceIp( ) );\n            cluster.getState( ).clearOrphan( addrInfo );\n          } catch ( NoSuchElementException e ) {\n            InetAddress addr = null;\n            try {\n              addr = Inet4Address.getByName( addrInfo.getInstanceIp( ) );\n            } catch ( UnknownHostException e1 ) {\n              LOG.debug( e1, e1 );\n            }\n            if ( addr == null || !addr.isLoopbackAddress( )  ) {\n              cluster.getState().handleOrphan( addrInfo );\n            }\n          }\n        }\n      } catch ( Throwable e ) {\n        LOG.debug( e, e );\n      }\n    }\n  }","id":106681,"modified_method":"public void update( Cluster cluster, List<ClusterAddressInfo> ccList ) {\n    if ( !cluster.getState( ).isAddressingInitialized( ) ) {\n      Helper.loadStoredAddresses( cluster );\n      cluster.getState( ).setAddressingInitialized( true );\n    }\n    for( ClusterAddressInfo addrInfo : ccList ) {\n      try {\n        Address address = Helper.lookupOrCreate( cluster, addrInfo );\n        if ( address.isAssigned( ) ) {\n          if( Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) ) {\n            this.markAsAllocated( cluster, addrInfo, address );\n          }\n          try {\n            VmInstance vm = VmInstances.getInstance( ).lookupByInstanceIp( addrInfo.getInstanceIp( ) );\n            cluster.getState( ).clearOrphan( addrInfo );\n          } catch ( NoSuchElementException e ) {\n            InetAddress addr = null;\n            try {\n              addr = Inet4Address.getByName( addrInfo.getInstanceIp( ) );\n            } catch ( UnknownHostException e1 ) {\n              LOG.debug( e1, e1 );\n            }\n            if ( addr == null || !addr.isLoopbackAddress( )  ) {\n              cluster.getState().handleOrphan( addrInfo );\n            }\n          }\n        } else if( address.isAllocated( ) && Address.UNALLOCATED_USERID.equals( address.getUserId( ) ) ) {\n          this.markAsAllocated( cluster, addrInfo, address );\n        } \n      } catch ( Throwable e ) {\n        LOG.debug( e, e );\n      }\n    }\n  }","commit_id":"56aff2ed27a5eaf4d9aabfd9414636ffa14b697d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void handleOrphan( ClusterAddressInfo address ) {\n    Integer orphanCount = 1;\n    orphanCount = orphans.putIfAbsent( address.getAddress( ), orphanCount );\n    orphanCount = ( orphanCount == null ) ? 1 : orphanCount;\n    orphans.put( address.getAddress( ), orphanCount + 1 );\n    LOG.warn( \"Found orphaned public ip address: \" + address + \" count=\" + orphanCount );\n    if ( orphanCount > 10 ) {\n      new UnassignAddressCallback( address ).dispatch( this.clusterName );\n      orphans.remove( address.getAddress( ) );\n    }\n  }","id":106682,"modified_method":"public void handleOrphan( ClusterAddressInfo address ) {\n    Integer orphanCount = 1;\n    orphanCount = orphans.putIfAbsent( address, orphanCount );\n    LOG.warn( \"Found orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount );\n    orphanCount = ( orphanCount == null ) ? 1 : orphanCount;\n    orphans.put( address, orphanCount + 1 );\n    LOG.warn( \"Updated orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount );\n    if ( orphanCount > 10 ) {\n      LOG.warn( \"Unassigning orphaned public ip address: \" + LogUtil.dumpObject( address ) + \" count=\" + orphanCount );\n      new UnassignAddressCallback( address ).dispatch( this.clusterName );\n      orphans.remove( address.getAddress( ) );\n    }\n  }","commit_id":"56aff2ed27a5eaf4d9aabfd9414636ffa14b697d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * @throws InterruptedException If interrupted.\n     */\n    @SuppressWarnings(\"BusyWait\")\n    protected void awaitPartitionMapExchange() throws InterruptedException {\n        for (Ignite g : G.allGrids()) {\n            IgniteKernal g0 = (IgniteKernal)g;\n\n            for (IgniteCacheProxy<?, ?> c : g0.context().cache().jcaches()) {\n                CacheConfiguration cfg = c.context().config();\n\n                if (cfg.getCacheMode() == PARTITIONED &&\n                    cfg.getRebalanceMode() != NONE &&\n                    g.cluster().nodes().size() > 1) {\n                    AffinityFunction aff = cfg.getAffinity();\n\n                    GridDhtCacheAdapter<?, ?> dht = dht(c);\n\n                    GridDhtPartitionTopology top = dht.topology();\n\n                    for (int p = 0; p < aff.partitions(); p++) {\n                        long start = 0;\n\n                        for (int i = 0; ; i++) {\n                            // Must map on updated version of topology.\n                            Collection<ClusterNode> affNodes =\n                                g0.affinity(cfg.getName()).mapPartitionToPrimaryAndBackups(p);\n\n                            int exp = affNodes.size();\n\n                            GridDhtTopologyFuture topFut = top.topologyVersionFuture();\n\n                            Collection<ClusterNode> owners = (topFut != null && topFut.isDone()) ?\n                                top.nodes(p, AffinityTopologyVersion.NONE) : Collections.<ClusterNode>emptyList();\n\n                            int actual = owners.size();\n\n                            if (affNodes.size() != owners.size() || !affNodes.containsAll(owners)) {\n                                LT.warn(log(), null, \"Waiting for topology map update [\" +\n                                    \"grid=\" + g.name() +\n                                    \", cache=\" + cfg.getName() +\n                                    \", cacheId=\" + dht.context().cacheId() +\n                                    \", topVer=\" + top.topologyVersion() +\n                                    \", topFut=\" + topFut +\n                                    \", p=\" + p +\n                                    \", affNodesCnt=\" + exp +\n                                    \", ownersCnt=\" + actual +\n                                    \", affNodes=\" + affNodes +\n                                    \", owners=\" + owners +\n                                    \", locNode=\" + g.cluster().localNode() + ']');\n\n                                if (i == 0)\n                                    start = System.currentTimeMillis();\n\n                                if (System.currentTimeMillis() - start > 30_000)\n                                    throw new IgniteException(\"Timeout of waiting for topology map update [\" +\n                                        \"grid=\" + g.name() +\n                                        \", cache=\" + cfg.getName() +\n                                        \", cacheId=\" + dht.context().cacheId() +\n                                        \", topVer=\" + top.topologyVersion() +\n                                        \", topFut=\" + topFut +\n                                        \", p=\" + p +\n                                        \", affNodesCnt=\" + exp +\n                                        \", ownersCnt=\" + actual +\n                                        \", affNodes=\" + affNodes +\n                                        \", owners=\" + owners +\n                                        \", locNode=\" + g.cluster().localNode() + ']');\n\n                                Thread.sleep(200); // Busy wait.\n\n                                continue;\n                            }\n\n                            if (i > 0)\n                                log().warning(\"Finished waiting for topology map update [grid=\" + g.name() +\n                                    \", p=\" + p + \", duration=\" + (System.currentTimeMillis() - start) + \"ms]\");\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","id":106683,"modified_method":"/**\n     * @throws InterruptedException If interrupted.\n     */\n    @SuppressWarnings(\"BusyWait\")\n    protected void awaitPartitionMapExchange() throws InterruptedException {\n        for (Ignite g : G.allGrids()) {\n            IgniteKernal g0 = (IgniteKernal)g;\n\n            for (IgniteCacheProxy<?, ?> c : g0.context().cache().jcaches()) {\n                CacheConfiguration cfg = c.context().config();\n\n                if (cfg.getCacheMode() == PARTITIONED &&\n                    cfg.getRebalanceMode() != NONE &&\n                    g.cluster().nodes().size() > 1) {\n                    AffinityFunction aff = cfg.getAffinity();\n\n                    GridDhtCacheAdapter<?, ?> dht = dht(c);\n\n                    GridDhtPartitionTopology top = dht.topology();\n\n                    for (int p = 0; p < aff.partitions(); p++) {\n                        long start = 0;\n\n                        for (int i = 0; ; i++) {\n                            boolean match = false;\n\n                            AffinityTopologyVersion readyVer = dht.context().shared().exchange().readyAffinityVersion();\n\n                            if (readyVer.topologyVersion() > 0 && dht.context().started()) {\n                                // Must map on updated version of topology.\n                                Collection<ClusterNode> affNodes =\n                                    g0.affinity(cfg.getName()).mapPartitionToPrimaryAndBackups(p);\n\n                                int exp = affNodes.size();\n\n                                GridDhtTopologyFuture topFut = top.topologyVersionFuture();\n\n                                Collection<ClusterNode> owners = (topFut != null && topFut.isDone()) ?\n                                    top.nodes(p, AffinityTopologyVersion.NONE) : Collections.<ClusterNode>emptyList();\n\n                                int actual = owners.size();\n\n                                if (affNodes.size() != owners.size() || !affNodes.containsAll(owners)) {\n                                    LT.warn(log(), null, \"Waiting for topology map update [\" +\n                                        \"grid=\" + g.name() +\n                                        \", cache=\" + cfg.getName() +\n                                        \", cacheId=\" + dht.context().cacheId() +\n                                        \", topVer=\" + top.topologyVersion() +\n                                        \", topFut=\" + topFut +\n                                        \", p=\" + p +\n                                        \", affNodesCnt=\" + exp +\n                                        \", ownersCnt=\" + actual +\n                                        \", affNodes=\" + affNodes +\n                                        \", owners=\" + owners +\n                                        \", locNode=\" + g.cluster().localNode() + ']');\n                                }\n                                else\n                                    match = true;\n                            }\n                            else {\n                                LT.warn(log(), null, \"Waiting for topology map update [\" +\n                                    \"grid=\" + g.name() +\n                                    \", cache=\" + cfg.getName() +\n                                    \", cacheId=\" + dht.context().cacheId() +\n                                    \", topVer=\" + top.topologyVersion() +\n                                    \", started=\" + dht.context().started() +\n                                    \", p=\" + p +\n                                    \", readVer=\" + readyVer +\n                                    \", locNode=\" + g.cluster().localNode() + ']');\n                            }\n\n                            if (!match) {\n                                if (i == 0)\n                                    start = System.currentTimeMillis();\n\n                                if (System.currentTimeMillis() - start > 30_000)\n                                    throw new IgniteException(\"Timeout of waiting for topology map update [\" +\n                                        \"grid=\" + g.name() +\n                                        \", cache=\" + cfg.getName() +\n                                        \", cacheId=\" + dht.context().cacheId() +\n                                        \", topVer=\" + top.topologyVersion() +\n                                        \", p=\" + p +\n                                        \", readVer=\" + readyVer +\n                                        \", locNode=\" + g.cluster().localNode() + ']');\n\n                                Thread.sleep(200); // Busy wait.\n\n                                continue;\n                            }\n\n                            if (i > 0)\n                                log().warning(\"Finished waiting for topology map update [grid=\" + g.name() +\n                                    \", p=\" + p + \", duration=\" + (System.currentTimeMillis() - start) + \"ms]\");\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"b295bc5bc1a0e98bf4a9fb6c28d7db32ff75aa6f","url":"https://github.com/apache/ignite"},{"original_method":"private void copyBlock(DFSClient dfs, LocatedBlock lblock,\n                         OutputStream fos) throws Exception {\n    int failures = 0;\n    InetSocketAddress targetAddr = null;\n    TreeSet<DatanodeInfo> deadNodes = new TreeSet<DatanodeInfo>();\n    Socket s = null;\n    BlockReader blockReader = null; \n    ExtendedBlock block = lblock.getBlock(); \n\n    while (s == null) {\n      DatanodeInfo chosenNode;\n      \n      try {\n        chosenNode = bestNode(dfs, lblock.getLocations(), deadNodes);\n        targetAddr = NetUtils.createSocketAddr(chosenNode.getXferAddr());\n      }  catch (IOException ie) {\n        if (failures >= DFSConfigKeys.DFS_CLIENT_MAX_BLOCK_ACQUIRE_FAILURES_DEFAULT) {\n          throw new IOException(\"Could not obtain block \" + lblock);\n        }\n        LOG.info(\"Could not obtain block from any node:  \" + ie);\n        try {\n          Thread.sleep(10000);\n        }  catch (InterruptedException iex) {\n        }\n        deadNodes.clear();\n        failures++;\n        continue;\n      }\n      try {\n        s = new Socket();\n        s.connect(targetAddr, HdfsServerConstants.READ_TIMEOUT);\n        s.setSoTimeout(HdfsServerConstants.READ_TIMEOUT);\n        \n        String file = BlockReaderFactory.getFileName(targetAddr, block.getBlockPoolId(),\n            block.getBlockId());\n        blockReader = BlockReaderFactory.newBlockReader(\n            conf, s, file, block, lblock\n            .getBlockToken(), 0, -1);\n        \n      }  catch (IOException ex) {\n        // Put chosen node into dead list, continue\n        LOG.info(\"Failed to connect to \" + targetAddr + \":\" + ex);\n        deadNodes.add(chosenNode);\n        if (s != null) {\n          try {\n            s.close();\n          } catch (IOException iex) {\n          }\n        }\n        s = null;\n      }\n    }\n    if (blockReader == null) {\n      throw new Exception(\"Could not open data stream for \" + lblock.getBlock());\n    }\n    byte[] buf = new byte[1024];\n    int cnt = 0;\n    boolean success = true;\n    long bytesRead = 0;\n    try {\n      while ((cnt = blockReader.read(buf, 0, buf.length)) > 0) {\n        fos.write(buf, 0, cnt);\n        bytesRead += cnt;\n      }\n      if ( bytesRead != block.getNumBytes() ) {\n        throw new IOException(\"Recorded block size is \" + block.getNumBytes() + \n                              \", but datanode returned \" +bytesRead+\" bytes\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      success = false;\n    } finally {\n      try {s.close(); } catch (Exception e1) {}\n    }\n    if (!success)\n      throw new Exception(\"Could not copy block data for \" + lblock.getBlock());\n  }","id":106684,"modified_method":"private void copyBlock(DFSClient dfs, LocatedBlock lblock,\n                         OutputStream fos) throws Exception {\n    int failures = 0;\n    InetSocketAddress targetAddr = null;\n    TreeSet<DatanodeInfo> deadNodes = new TreeSet<DatanodeInfo>();\n    Socket s = null;\n    BlockReader blockReader = null; \n    ExtendedBlock block = lblock.getBlock(); \n\n    while (s == null) {\n      DatanodeInfo chosenNode;\n      \n      try {\n        chosenNode = bestNode(dfs, lblock.getLocations(), deadNodes);\n        targetAddr = NetUtils.createSocketAddr(chosenNode.getXferAddr());\n      }  catch (IOException ie) {\n        if (failures >= DFSConfigKeys.DFS_CLIENT_MAX_BLOCK_ACQUIRE_FAILURES_DEFAULT) {\n          throw new IOException(\"Could not obtain block \" + lblock, ie);\n        }\n        LOG.info(\"Could not obtain block from any node:  \" + ie);\n        try {\n          Thread.sleep(10000);\n        }  catch (InterruptedException iex) {\n        }\n        deadNodes.clear();\n        failures++;\n        continue;\n      }\n      try {\n        s = NetUtils.getDefaultSocketFactory(conf).createSocket();\n        s.connect(targetAddr, HdfsServerConstants.READ_TIMEOUT);\n        s.setSoTimeout(HdfsServerConstants.READ_TIMEOUT);\n        \n        String file = BlockReaderFactory.getFileName(targetAddr, block.getBlockPoolId(),\n            block.getBlockId());\n        blockReader = BlockReaderFactory.newBlockReader(\n            conf, s, file, block, lblock\n            .getBlockToken(), 0, -1);\n        \n      }  catch (IOException ex) {\n        // Put chosen node into dead list, continue\n        LOG.info(\"Failed to connect to \" + targetAddr + \":\" + ex);\n        deadNodes.add(chosenNode);\n        if (s != null) {\n          try {\n            s.close();\n          } catch (IOException iex) {\n          }\n        }\n        s = null;\n      }\n    }\n    if (blockReader == null) {\n      throw new Exception(\"Could not open data stream for \" + lblock.getBlock());\n    }\n    byte[] buf = new byte[1024];\n    int cnt = 0;\n    boolean success = true;\n    long bytesRead = 0;\n    try {\n      while ((cnt = blockReader.read(buf, 0, buf.length)) > 0) {\n        fos.write(buf, 0, cnt);\n        bytesRead += cnt;\n      }\n      if ( bytesRead != block.getNumBytes() ) {\n        throw new IOException(\"Recorded block size is \" + block.getNumBytes() + \n                              \", but datanode returned \" +bytesRead+\" bytes\");\n      }\n    } catch (Exception e) {\n      LOG.error(\"Error reading block\", e);\n      success = false;\n    } finally {\n      try {s.close(); } catch (Exception e1) {}\n    }\n    if (!success)\n      throw new Exception(\"Could not copy block data for \" + lblock.getBlock());\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"private void lostFoundInit(DFSClient dfs) {\n    lfInited = true;\n    try {\n      String lfName = \"/lost+found\";\n      \n      final HdfsFileStatus lfStatus = dfs.getFileInfo(lfName);\n      if (lfStatus == null) { // not exists\n        lfInitedOk = dfs.mkdirs(lfName, null, true);\n        lostFound = lfName;\n      } else if (!lfStatus.isDir()) { // exists but not a directory\n        LOG.warn(\"Cannot use /lost+found : a regular file with this name exists.\");\n        lfInitedOk = false;\n      }  else { // exists and is a directory\n        lostFound = lfName;\n        lfInitedOk = true;\n      }\n    }  catch (Exception e) {\n      e.printStackTrace();\n      lfInitedOk = false;\n    }\n    if (lostFound == null) {\n      LOG.warn(\"Cannot initialize /lost+found .\");\n      lfInitedOk = false;\n    }\n  }","id":106685,"modified_method":"private void lostFoundInit(DFSClient dfs) {\n    lfInited = true;\n    try {\n      String lfName = \"/lost+found\";\n      \n      final HdfsFileStatus lfStatus = dfs.getFileInfo(lfName);\n      if (lfStatus == null) { // not exists\n        lfInitedOk = dfs.mkdirs(lfName, null, true);\n        lostFound = lfName;\n      } else if (!lfStatus.isDir()) { // exists but not a directory\n        LOG.warn(\"Cannot use /lost+found : a regular file with this name exists.\");\n        lfInitedOk = false;\n      }  else { // exists and is a directory\n        lostFound = lfName;\n        lfInitedOk = true;\n      }\n    }  catch (Exception e) {\n      e.printStackTrace();\n      lfInitedOk = false;\n    }\n    if (lostFound == null) {\n      LOG.warn(\"Cannot initialize /lost+found .\");\n      lfInitedOk = false;\n      internalError = true;\n    }\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"private void copyBlocksToLostFound(String parent, HdfsFileStatus file,\n        LocatedBlocks blocks) throws IOException {\n    final DFSClient dfs = new DFSClient(NameNode.getAddress(conf), conf);\n    try {\n    if (!lfInited) {\n      lostFoundInit(dfs);\n    }\n    if (!lfInitedOk) {\n      return;\n    }\n    String fullName = file.getFullName(parent);\n    String target = lostFound + fullName;\n    String errmsg = \"Failed to move \" + fullName + \" to /lost+found\";\n    try {\n      if (!namenode.getRpcServer().mkdirs(\n          target, file.getPermission(), true)) {\n        LOG.warn(errmsg);\n        return;\n      }\n      // create chains\n      int chain = 0;\n      OutputStream fos = null;\n      for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n        LocatedBlock lblock = lBlk;\n        DatanodeInfo[] locs = lblock.getLocations();\n        if (locs == null || locs.length == 0) {\n          if (fos != null) {\n            fos.flush();\n            fos.close();\n            fos = null;\n          }\n          continue;\n        }\n        if (fos == null) {\n          fos = dfs.create(target + \"/\" + chain, true);\n          if (fos != null)\n            chain++;\n          else {\n            throw new IOException(errmsg + \": could not store chain \" + chain);\n          }\n        }\n        \n        // copy the block. It's a pity it's not abstracted from DFSInputStream ...\n        try {\n          copyBlock(dfs, lblock, fos);\n        } catch (Exception e) {\n          e.printStackTrace();\n          // something went wrong copying this block...\n          LOG.warn(\" - could not copy block \" + lblock.getBlock() + \" to \" + target);\n          fos.flush();\n          fos.close();\n          fos = null;\n        }\n      }\n      if (fos != null) fos.close();\n      LOG.warn(\"\\n - copied corrupted file \" + fullName + \" to /lost+found\");\n    }  catch (Exception e) {\n      e.printStackTrace();\n      LOG.warn(errmsg + \": \" + e.getMessage());\n    }\n    } finally {\n      dfs.close();\n    }\n  }","id":106686,"modified_method":"private void copyBlocksToLostFound(String parent, HdfsFileStatus file,\n        LocatedBlocks blocks) throws IOException {\n    final DFSClient dfs = new DFSClient(NameNode.getAddress(conf), conf);\n    final String fullName = file.getFullName(parent);\n    OutputStream fos = null;\n    try {\n      if (!lfInited) {\n        lostFoundInit(dfs);\n      }\n      if (!lfInitedOk) {\n        throw new IOException(\"failed to initialize lost+found\");\n      }\n      String target = lostFound + fullName;\n      if (hdfsPathExists(target)) {\n        LOG.warn(\"Fsck: can't copy the remains of \" + fullName + \" to \" +\n          \"lost+found, because \" + target + \" already exists.\");\n        return;\n      }\n      if (!namenode.getRpcServer().mkdirs(\n          target, file.getPermission(), true)) {\n        throw new IOException(\"failed to create directory \" + target);\n      }\n      // create chains\n      int chain = 0;\n      boolean copyError = false;\n      for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n        LocatedBlock lblock = lBlk;\n        DatanodeInfo[] locs = lblock.getLocations();\n        if (locs == null || locs.length == 0) {\n          if (fos != null) {\n            fos.flush();\n            fos.close();\n            fos = null;\n          }\n          continue;\n        }\n        if (fos == null) {\n          fos = dfs.create(target + \"/\" + chain, true);\n          if (fos == null) {\n            throw new IOException(\"Failed to copy \" + fullName +\n                \" to /lost+found: could not store chain \" + chain);\n          }\n          chain++;\n        }\n        \n        // copy the block. It's a pity it's not abstracted from DFSInputStream ...\n        try {\n          copyBlock(dfs, lblock, fos);\n        } catch (Exception e) {\n          LOG.error(\"Fsck: could not copy block \" + lblock.getBlock() +\n              \" to \" + target, e);\n          fos.flush();\n          fos.close();\n          fos = null;\n          internalError = true;\n          copyError = true;\n        }\n      }\n      if (copyError) {\n        LOG.warn(\"Fsck: there were errors copying the remains of the \" +\n          \"corrupted file \" + fullName + \" to /lost+found\");\n      } else {\n        LOG.info(\"Fsck: copied the remains of the corrupted file \" + \n          fullName + \" to /lost+found\");\n      }\n    } catch (Exception e) {\n      LOG.error(\"copyBlocksToLostFound: error processing \" + fullName, e);\n      internalError = true;\n    } finally {\n      if (fos != null) fos.close();\n      dfs.close();\n    }\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  void check(String parent, HdfsFileStatus file, Result res) throws IOException {\n    String path = file.getFullName(parent);\n    boolean isOpen = false;\n\n    if (file.isDir()) {\n      byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;\n      DirectoryListing thisListing;\n      if (showFiles) {\n        out.println(path + \" <dir>\");\n      }\n      res.totalDirs++;\n      do {\n        assert lastReturnedName != null;\n        thisListing = namenode.getRpcServer().getListing(\n            path, lastReturnedName, false);\n        if (thisListing == null) {\n          return;\n        }\n        HdfsFileStatus[] files = thisListing.getPartialListing();\n        for (int i = 0; i < files.length; i++) {\n          check(path, files[i], res);\n        }\n        lastReturnedName = thisListing.getLastName();\n      } while (thisListing.hasMore());\n      return;\n    }\n    long fileLen = file.getLen();\n    // Get block locations without updating the file access time \n    // and without block access tokens\n    LocatedBlocks blocks = namenode.getNamesystem().getBlockLocations(path, 0,\n        fileLen, false, false, false);\n    if (blocks == null) { // the file is deleted\n      return;\n    }\n    isOpen = blocks.isUnderConstruction();\n    if (isOpen && !showOpenFiles) {\n      // We collect these stats about open files to report with default options\n      res.totalOpenFilesSize += fileLen;\n      res.totalOpenFilesBlocks += blocks.locatedBlockCount();\n      res.totalOpenFiles++;\n      return;\n    }\n    res.totalFiles++;\n    res.totalSize += fileLen;\n    res.totalBlocks += blocks.locatedBlockCount();\n    if (showOpenFiles && isOpen) {\n      out.print(path + \" \" + fileLen + \" bytes, \" +\n        blocks.locatedBlockCount() + \" block(s), OPENFORWRITE: \");\n    } else if (showFiles) {\n      out.print(path + \" \" + fileLen + \" bytes, \" +\n        blocks.locatedBlockCount() + \" block(s): \");\n    } else {\n      out.print('.');\n    }\n    if (res.totalFiles % 100 == 0) { out.println(); out.flush(); }\n    int missing = 0;\n    int corrupt = 0;\n    long missize = 0;\n    int underReplicatedPerFile = 0;\n    int misReplicatedPerFile = 0;\n    StringBuilder report = new StringBuilder();\n    int i = 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block = lBlk.getBlock();\n      boolean isCorrupt = lBlk.isCorrupt();\n      String blkName = block.toString();\n      DatanodeInfo[] locs = lBlk.getLocations();\n      res.totalReplicas += locs.length;\n      short targetFileReplication = file.getReplication();\n      res.numExpectedReplicas += targetFileReplication;\n      if (locs.length > targetFileReplication) {\n        res.excessiveReplicas += (locs.length - targetFileReplication);\n        res.numOverReplicatedBlocks += 1;\n      }\n      // Check if block is Corrupt\n      if (isCorrupt) {\n        corrupt++;\n        res.corruptBlocks++;\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" + block.getBlockPoolId() + \n            \" block \" + block.getBlockName()+\"\\n\");\n      }\n      if (locs.length >= minReplication)\n        res.numMinReplicatedBlocks++;\n      if (locs.length < targetFileReplication && locs.length > 0) {\n        res.missingReplicas += (targetFileReplication - locs.length);\n        res.numUnderReplicatedBlocks += 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    locs.length + \" replica(s).\");\n      }\n      // verify block placement policy\n      int missingRacks = BlockPlacementPolicy.getInstance(conf, null, networktopology).\n                           verifyBlockPlacement(path, lBlk, Math.min(2,targetFileReplication));\n      if (missingRacks > 0) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile == 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block +\n                    \". Block should be additionally replicated on \" + \n                    missingRacks + \" more rack(s).\");\n      }\n      report.append(i + \". \" + blkName + \" len=\" + block.getNumBytes());\n      if (locs.length == 0) {\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize += block.getNumBytes();\n      } else {\n        report.append(\" repl=\" + locs.length);\n        if (showLocations || showRacks) {\n          StringBuilder sb = new StringBuilder(\"[\");\n          for (int j = 0; j < locs.length; j++) {\n            if (j > 0) { sb.append(\", \"); }\n            if (showRacks)\n              sb.append(NodeBase.getPath(locs[j]));\n            else\n              sb.append(locs[j]);\n          }\n          sb.append(']');\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append('\\n');\n      i++;\n    }\n    if ((missing > 0) || (corrupt > 0)) {\n      if (!showFiles && (missing > 0)) {\n        out.print(\"\\n\" + path + \": MISSING \" + missing\n            + \" blocks of total size \" + missize + \" B.\");\n      }\n      res.corruptFiles++;\n      try {\n        if (doMove) {\n          if (!isOpen) {\n            copyBlocksToLostFound(parent, file, blocks);\n          }\n        }\n        if (doDelete) {\n          if (!isOpen) {\n            LOG.warn(\"\\n - deleting corrupted file \" + path);\n            namenode.getRpcServer().delete(path, true);\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"error processing \" + path + \": \" + e.toString());\n      }\n    }\n    if (showFiles) {\n      if (missing > 0) {\n        out.print(\" MISSING \" + missing + \" blocks of total size \" + missize + \" B\\n\");\n      }  else if (underReplicatedPerFile == 0 && misReplicatedPerFile == 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }","id":106687,"modified_method":"@VisibleForTesting\n  void check(String parent, HdfsFileStatus file, Result res) throws IOException {\n    String path = file.getFullName(parent);\n    boolean isOpen = false;\n\n    if (file.isDir()) {\n      byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;\n      DirectoryListing thisListing;\n      if (showFiles) {\n        out.println(path + \" <dir>\");\n      }\n      res.totalDirs++;\n      do {\n        assert lastReturnedName != null;\n        thisListing = namenode.getRpcServer().getListing(\n            path, lastReturnedName, false);\n        if (thisListing == null) {\n          return;\n        }\n        HdfsFileStatus[] files = thisListing.getPartialListing();\n        for (int i = 0; i < files.length; i++) {\n          check(path, files[i], res);\n        }\n        lastReturnedName = thisListing.getLastName();\n      } while (thisListing.hasMore());\n      return;\n    }\n    long fileLen = file.getLen();\n    // Get block locations without updating the file access time \n    // and without block access tokens\n    LocatedBlocks blocks = namenode.getNamesystem().getBlockLocations(path, 0,\n        fileLen, false, false, false);\n    if (blocks == null) { // the file is deleted\n      return;\n    }\n    isOpen = blocks.isUnderConstruction();\n    if (isOpen && !showOpenFiles) {\n      // We collect these stats about open files to report with default options\n      res.totalOpenFilesSize += fileLen;\n      res.totalOpenFilesBlocks += blocks.locatedBlockCount();\n      res.totalOpenFiles++;\n      return;\n    }\n    res.totalFiles++;\n    res.totalSize += fileLen;\n    res.totalBlocks += blocks.locatedBlockCount();\n    if (showOpenFiles && isOpen) {\n      out.print(path + \" \" + fileLen + \" bytes, \" +\n        blocks.locatedBlockCount() + \" block(s), OPENFORWRITE: \");\n    } else if (showFiles) {\n      out.print(path + \" \" + fileLen + \" bytes, \" +\n        blocks.locatedBlockCount() + \" block(s): \");\n    } else {\n      out.print('.');\n    }\n    if (res.totalFiles % 100 == 0) { out.println(); out.flush(); }\n    int missing = 0;\n    int corrupt = 0;\n    long missize = 0;\n    int underReplicatedPerFile = 0;\n    int misReplicatedPerFile = 0;\n    StringBuilder report = new StringBuilder();\n    int i = 0;\n    for (LocatedBlock lBlk : blocks.getLocatedBlocks()) {\n      ExtendedBlock block = lBlk.getBlock();\n      boolean isCorrupt = lBlk.isCorrupt();\n      String blkName = block.toString();\n      DatanodeInfo[] locs = lBlk.getLocations();\n      res.totalReplicas += locs.length;\n      short targetFileReplication = file.getReplication();\n      res.numExpectedReplicas += targetFileReplication;\n      if (locs.length > targetFileReplication) {\n        res.excessiveReplicas += (locs.length - targetFileReplication);\n        res.numOverReplicatedBlocks += 1;\n      }\n      // Check if block is Corrupt\n      if (isCorrupt) {\n        corrupt++;\n        res.corruptBlocks++;\n        out.print(\"\\n\" + path + \": CORRUPT blockpool \" + block.getBlockPoolId() + \n            \" block \" + block.getBlockName()+\"\\n\");\n      }\n      if (locs.length >= minReplication)\n        res.numMinReplicatedBlocks++;\n      if (locs.length < targetFileReplication && locs.length > 0) {\n        res.missingReplicas += (targetFileReplication - locs.length);\n        res.numUnderReplicatedBlocks += 1;\n        underReplicatedPerFile++;\n        if (!showFiles) {\n          out.print(\"\\n\" + path + \": \");\n        }\n        out.println(\" Under replicated \" + block +\n                    \". Target Replicas is \" +\n                    targetFileReplication + \" but found \" +\n                    locs.length + \" replica(s).\");\n      }\n      // verify block placement policy\n      int missingRacks = BlockPlacementPolicy.getInstance(conf, null, networktopology).\n                           verifyBlockPlacement(path, lBlk, Math.min(2,targetFileReplication));\n      if (missingRacks > 0) {\n        res.numMisReplicatedBlocks++;\n        misReplicatedPerFile++;\n        if (!showFiles) {\n          if(underReplicatedPerFile == 0)\n            out.println();\n          out.print(path + \": \");\n        }\n        out.println(\" Replica placement policy is violated for \" + \n                    block +\n                    \". Block should be additionally replicated on \" + \n                    missingRacks + \" more rack(s).\");\n      }\n      report.append(i + \". \" + blkName + \" len=\" + block.getNumBytes());\n      if (locs.length == 0) {\n        report.append(\" MISSING!\");\n        res.addMissing(block.toString(), block.getNumBytes());\n        missing++;\n        missize += block.getNumBytes();\n      } else {\n        report.append(\" repl=\" + locs.length);\n        if (showLocations || showRacks) {\n          StringBuilder sb = new StringBuilder(\"[\");\n          for (int j = 0; j < locs.length; j++) {\n            if (j > 0) { sb.append(\", \"); }\n            if (showRacks)\n              sb.append(NodeBase.getPath(locs[j]));\n            else\n              sb.append(locs[j]);\n          }\n          sb.append(']');\n          report.append(\" \" + sb.toString());\n        }\n      }\n      report.append('\\n');\n      i++;\n    }\n    if ((missing > 0) || (corrupt > 0)) {\n      if (!showFiles && (missing > 0)) {\n        out.print(\"\\n\" + path + \": MISSING \" + missing\n            + \" blocks of total size \" + missize + \" B.\");\n      }\n      res.corruptFiles++;\n      if (isOpen) {\n        LOG.info(\"Fsck: ignoring open file \" + path);\n      } else {\n        if (doMove) copyBlocksToLostFound(parent, file, blocks);\n        if (doDelete) deleteCorruptedFile(path);\n      }\n    }\n    if (showFiles) {\n      if (missing > 0) {\n        out.print(\" MISSING \" + missing + \" blocks of total size \" + missize + \" B\\n\");\n      }  else if (underReplicatedPerFile == 0 && misReplicatedPerFile == 0) {\n        out.print(\" OK\\n\");\n      }\n      if (showBlocks) {\n        out.print(report.toString() + \"\\n\");\n      }\n    }\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Check files on DFS, starting from the indicated path.\n   */\n  public void fsck() {\n    final long startTime = System.currentTimeMillis();\n    try {\n      String msg = \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file = namenode.getRpcServer().getFileInfo(path);\n      if (file != null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res = new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path '\" + path + \"' \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path '\" + path + \"' \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath '\" + path + \"' \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg = \"Fsck on path '\" + path + \"' \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }","id":106688,"modified_method":"/**\n   * Check files on DFS, starting from the indicated path.\n   */\n  public void fsck() {\n    final long startTime = System.currentTimeMillis();\n    try {\n      String msg = \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file = namenode.getRpcServer().getFileInfo(path);\n      if (file != null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res = new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path '\" + path + \"' \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path '\" + path + \"' \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath '\" + path + \"' \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg = \"Fsck on path '\" + path + \"' \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"static String runFsck(Configuration conf, int expectedErrCode, \n                        boolean checkErrorCode,String... path) \n                        throws Exception {\n    ByteArrayOutputStream bStream = new ByteArrayOutputStream();\n    PrintStream out = new PrintStream(bStream, true);\n    ((Log4JLogger)FSPermissionChecker.LOG).getLogger().setLevel(Level.ALL);\n    int errCode = ToolRunner.run(new DFSck(conf, out), path);\n    if (checkErrorCode) {\n      assertEquals(expectedErrCode, errCode);\n    }\n    ((Log4JLogger)FSPermissionChecker.LOG).getLogger().setLevel(Level.INFO);\n    return bStream.toString();\n  }","id":106689,"modified_method":"static String runFsck(Configuration conf, int expectedErrCode, \n                        boolean checkErrorCode,String... path) \n                        throws Exception {\n    ByteArrayOutputStream bStream = new ByteArrayOutputStream();\n    PrintStream out = new PrintStream(bStream, true);\n    ((Log4JLogger)FSPermissionChecker.LOG).getLogger().setLevel(Level.ALL);\n    int errCode = ToolRunner.run(new DFSck(conf, out), path);\n    if (checkErrorCode) {\n      assertEquals(expectedErrCode, errCode);\n    }\n    ((Log4JLogger)FSPermissionChecker.LOG).getLogger().setLevel(Level.INFO);\n    FSImage.LOG.error(\"OUTPUT = \" + bStream.toString());\n    return bStream.toString();\n  }","commit_id":"21fdf16b0d866dfd9eef22515be5da5f1cd9ac59","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t// System.out.println(\"BIT: \" + state + \": \" + OPCODE_NAMES[seen]);\n\n\t\tswitch (seen) {\n\t\tcase ICONST_M1:\n\t\t\tnoteVal(-1);\n\t\t\treturn;\n\t\tcase ICONST_0:\n\t\t\tnoteVal(0);\n\t\t\treturn;\n\t\tcase ICONST_1:\n\t\t\tnoteVal(1);\n\t\t\treturn;\n\t\tcase ICONST_2:\n\t\t\tnoteVal(2);\n\t\t\treturn;\n\t\tcase ICONST_3:\n\t\t\tnoteVal(3);\n\t\t\treturn;\n\t\tcase ICONST_4:\n\t\t\tnoteVal(4);\n\t\t\treturn;\n\t\tcase ICONST_5:\n\t\t\tnoteVal(5);\n\t\t\treturn;\n\t\tcase LCONST_0:\n\t\t\tnoteVal(0);\n\t\t\treturn;\n\t\tcase LCONST_1:\n\t\t\tnoteVal(1);\n\t\t\treturn;\n\n\t\tcase BIPUSH:\n\t\t\treturn;  /* will pick up value via sawInt */\n\t\tcase LDC2_W:\n\t\t\treturn;  /* will pick up value via sawLong */\n\n\t\tcase SIPUSH:\n\t\t\treturn;  /* will pick up value via sawInt */\n\t\tcase LDC:\n\t\t\treturn;  /* will pick up value via sawInt */\n\n\t\tcase IAND:\n\t\tcase LAND:\n\t\t\tbitop = IAND;\n\t\t\tisLong = seen == LAND;\n\t\t\tcheckState(1);\n\t\t\treturn;\n\t\tcase IOR:\n\t\tcase LOR:\n\t\t\tbitop = IOR;\n\t\t\tisLong = seen == LOR;\n\t\t\tcheckState(1);\n\t\t\treturn;\n\n\t\tcase LCMP:\n\t\t    isLong = true;\n\t\t\treturn; /* Ignore. An 'if' opcode will follow */\n\n\t\t\t\n\t\tcase IFLE:\n\t\tcase IFLT:\n\t\tcase IFGT:\n\t\tcase IFGE: \n\t\tif (state == 3){\n\t\t\tboolean highbit = !isLong && (arg0 & 0x80000000) != 0;\n\t\t\tBugInstance bug;\n\t\t\tif (highbit)\n\t\t\t\tbug = new BugInstance(this, \"BIT_SIGNED_CHECK_HIGH_BIT\", (seen == IFLE || seen == IFGT) ? HIGH_PRIORITY : NORMAL_PRIORITY);\n\t\t\telse\n\t\t\t\tbug = new BugInstance(this, \"BIT_SIGNED_CHECK\", NORMAL_PRIORITY);\n\t\t\tbugReporter.reportBug(bug.addClassAndMethod(this).addSourceLine(this));\n\t\t}\n\t\tstate = 0;\n\t\treturn;\n\t\t\n\t\t\n\t\tcase IFEQ:\n\t\tcase IFNE:\n\t\t\t/* special case: if arg1 is 0 it will not be pushed */\n\t\t\tif (state == 2) {\n\t\t\t\targ1 = 0;\n\t\t\t\tstate = 3;\n\t\t\t}\n\n\t\t\t/* fallthrough */\n\n\t\tcase IF_ICMPEQ:\n\t\tcase IF_ICMPNE:\n\t\t\tcheckState(3);\n\t\t\tif (state != 4)\n\t\t\t\treturn;\n\t\t\tbreak; /* the only break in this switch!  gross */\n\n\t\tcase GOTO:\n\t\t\tstate = -1;\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tstate = 0;\n\t\t\treturn;\n\t\t}\n\n\n\t\t/* We have matched the instruction pattern, so check the args */\n\t\tlong dif;\n\t\tString t;\n\n\t\tif (bitop == IOR) {\n\t\t\tdif = arg0 & ~arg1;\n\t\t\tt = \"BIT_IOR\";\n\t\t} else if (arg0 != 0 || arg1 != 0) {\n\t\t\tdif = arg1 & ~arg0;\n\t\t\tt = \"BIT_AND\";\n\t\t} else {\n\t\t\tdif = 1;\n\t\t\tt = \"BIT_AND_ZZ\";\n\t\t}\n\n\t\tif (dif != 0) {\n\t\t\t// System.out.println(\"Match at offset \" + getPC());\n\t\t\tbugReporter.reportBug(new BugInstance(this, t, NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\tstate = 0;\n\t}","id":106690,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t// System.out.println(\"BIT: \" + state + \": \" + OPCODE_NAMES[seen]);\n\n\t\tswitch (seen) {\n\t\tcase ICONST_M1:\n\t\t\tnoteVal(-1);\n\t\t\treturn;\n\t\tcase ICONST_0:\n\t\t\tnoteVal(0);\n\t\t\treturn;\n\t\tcase ICONST_1:\n\t\t\tnoteVal(1);\n\t\t\treturn;\n\t\tcase ICONST_2:\n\t\t\tnoteVal(2);\n\t\t\treturn;\n\t\tcase ICONST_3:\n\t\t\tnoteVal(3);\n\t\t\treturn;\n\t\tcase ICONST_4:\n\t\t\tnoteVal(4);\n\t\t\treturn;\n\t\tcase ICONST_5:\n\t\t\tnoteVal(5);\n\t\t\treturn;\n\t\tcase LCONST_0:\n\t\t\tnoteVal(0);\n\t\t\treturn;\n\t\tcase LCONST_1:\n\t\t\tnoteVal(1);\n\t\t\treturn;\n\n\t\tcase BIPUSH:\n\t\t\treturn;  /* will pick up value via sawInt */\n\t\tcase LDC2_W:\n\t\t\treturn;  /* will pick up value via sawLong */\n\n\t\tcase SIPUSH:\n\t\t\treturn;  /* will pick up value via sawInt */\n\t\tcase LDC:\n\t\t\treturn;  /* will pick up value via sawInt */\n\n\t\tcase IAND:\n\t\tcase LAND:\n\t\t\tbitop = IAND;\n\t\t\tisLong = seen == LAND;\n\t\t\tcheckState(1);\n\t\t\treturn;\n\t\tcase IOR:\n\t\tcase LOR:\n\t\t\tbitop = IOR;\n\t\t\tisLong = seen == LOR;\n\t\t\tcheckState(1);\n\t\t\treturn;\n\n\t\tcase LCMP:\n\t\t    isLong = true;\n\t\t\treturn; /* Ignore. An 'if' opcode will follow */\n\n\t\t\t\n\t\tcase IFLE:\n\t\tcase IFLT:\n\t\tcase IFGT:\n\t\tcase IFGE: \n\t\tif (state == 3){\n\t\t\tboolean highbit = !isLong && (arg0 & 0x80000000) != 0;\n\t\t\tBugInstance bug;\n\t\t\tif (highbit)\n\t\t\t\tbug = new BugInstance(this, \"BIT_SIGNED_CHECK_HIGH_BIT\", (seen == IFLE || seen == IFGT) ? HIGH_PRIORITY : NORMAL_PRIORITY);\n\t\t\telse\n\t\t\t\tbug = new BugInstance(this, \"BIT_SIGNED_CHECK\", NORMAL_PRIORITY);\n\t\t\tbugReporter.reportBug(bug.addClassAndMethod(this).addSourceLine(this));\n\t\t}\n\t\tstate = 0;\n\t\treturn;\n\t\t\n\t\t\n\t\tcase IFEQ:\n\t\tcase IFNE:\n\t\t\t/* special case: if arg1 is 0 it will not be pushed */\n\t\t\tif (state == 2) {\n\t\t\t\targ1 = 0;\n\t\t\t\tstate = 3;\n\t\t\t}\n\n\t\t\t/* fallthrough */\n\n\t\tcase IF_ICMPEQ:\n\t\tcase IF_ICMPNE:\n\t\t\tcheckState(3);\n\t\t\tif (state != 4)\n\t\t\t\treturn;\n\t\t\tbreak; /* the only break in this switch!  gross */\n\n\t\tcase GOTO:\n\t\t\tstate = -1;\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tstate = 0;\n\t\t\treturn;\n\t\t}\n\n\n\t\t/* We have matched the instruction pattern, so check the args */\n\t\tlong dif;\n\t\tString t;\n\n\t\tif (bitop == IOR) {\n\t\t\tdif = arg0 & ~arg1;\n\t\t\tt = \"BIT_IOR\";\n\t\t} else if (arg0 != 0 || arg1 != 0) {\n\t\t\tdif = arg1 & ~arg0;\n\t\t\tt = \"BIT_AND\";\n\t\t} else {\n\t\t\tdif = 1;\n\t\t\tt = \"BIT_AND_ZZ\";\n\t\t}\n\n\t\tif (dif != 0) {\n\t\t\t// System.out.println(\"Match at offset \" + getPC());\n\t\t\tBugInstance bug = new BugInstance(this, t, NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this);\n\t\t\tif (arg0 == (int) arg0 && arg1 == (int) arg1) \n\t\t\t\tbug.addInt((int)arg0).addInt((int)arg1);\n\t\t\t\n\t\t\tbug.addSourceLine(this);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t\tstate = 0;\n\t}","commit_id":"445aceb16487d4d3463888768f9ce10fd13614a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Code obj) { \n\n\tCodeException [] exp = obj.getExceptionTable();\n\tif (exp == null) return;\n\tbyte [] code = obj.getCode();\n\n\tfor(int i = 0; i < exp.length; i++)  {\n\t  int handled = exp[i].getHandlerPC();\n\t  int start = exp[i].getStartPC();\n\t  int end = exp[i].getEndPC();\n\t  int cause = exp[i].getCatchType();\n\t  boolean exitInTryBlock = false;\n\n\t  for(int j = start; j <= end;)   {\n\t    int opcode = asUnsignedByte(code[j]);\n\t    if (opcode >= IRETURN && opcode <= RETURN\n\t\t|| opcode >=IFEQ && opcode <= GOTO\n\t\t\t\t&& (opcode != GOTO || j < end)\n\t\t\t) {\n\t\t\texitInTryBlock =  true;\n\t\t\tbreak;\n\t\t\t/*\n\t\t\tSystem.out.println(\"\texit: \" + opcode \n\t\t\t\t+ \" in \" + betterMethodName);\n\t\t\t*/\n\t\t\t}\n\t\tif (NO_OF_OPERANDS[opcode] < 0)  {\n\t\t\texitInTryBlock = true;\n\t\t\tbreak;\n\t\t\t}\n\t\tj += 1+NO_OF_OPERANDS[opcode];\n\t\t}\n\n\t  if (exitInTryBlock) continue;\n\t  String c ;\n\t  if (cause == 0)\n\t\tc = \"Throwable\";\n\t  else\n\t\t{\n\t\tc = Utility.compactClassName(\n\t\t  constant_pool.getConstantString(cause, \n\t\t\t\t\tCONSTANT_Class), false);\n\t\tif (!isChecked(c)) continue;\n\t\t}\n\tif (handled < 5) continue;\n\t/*\n\tif ( (0xff&code[handled]) == POP) {\n\t\tSystem.out.println( \"DE:\t\" \n\t\t\t+ betterMethodName\n\t\t\t+ \" might ignore \" + c\n\t\t\t+ \" (\" + (0xff&code[handled] )\n\t\t\t+ \",\" + (0xff&code[handled+1] )\n\t\t\t+\")\"\n\t\t\t);\n\t\t}\n\telse \n\t*/\n\tint opcode = asUnsignedByte(code[handled]);\n\t // System.out.println( \"DE:\topcode is \"  + opcode + \", \" + asUnsignedByte(code[handled+1]));\n\tboolean drops = false;\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled+1]) == RETURN) {\n\t\tif (DEBUG) System.out.println(\"Drop 1\");\n\t\tdrops = true;\n\t\t}\n\tif (handled+2 < code.length\n\t\t&&opcode == ASTORE\n\t\t && asUnsignedByte(code[handled+2]) == RETURN) {\n\t\tdrops = true;\n\t\tif (DEBUG) System.out.println(\"Drop 2\");\n\t\t}\n\tif (handled+3 < code.length\n\t   && !exitInTryBlock) {\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tif (offsetBefore == 4) {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 3\");\n\t\t\t}\n\t\t}\n\tif ( opcode == ASTORE\n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tif (offsetBefore == 5) {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 4\");\n\t\t\t}\n\t\t}\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled+1]) == GOTO \n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tint offsetAfter = \n\t\t\tasUnsignedByte(code[handled+2]) << 8\n\t\t\t| asUnsignedByte(code[handled+3]);\n\t\n\t\tif (offsetAfter > 0 && offsetAfter+4 == offsetBefore)\t  {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 5\");\n\t\t\t}\n\t\t}\n\n\tif ( opcode == ASTORE\n\t\t && asUnsignedByte(code[handled+2]) == GOTO \n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tint offsetAfter = \n\t\t\tasUnsignedByte(code[handled+3]) << 8\n\t\t\t| asUnsignedByte(code[handled+4]);\n\t\n\t\tif (offsetAfter > 0 && offsetAfter+5 == offsetBefore)\t  {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 6\");\n\t\t\t}\n\t\t}\n\n\n\n\n\t}\n\tif (end-start >= 5 && drops && !c.equals(\"java.lang.InterruptedException\")\n\t\t\t&& !c.equals(\"java.lang.CloneNotSupportedException\")) {\n\tString key = (exitInTryBlock ? \"mightDrop,\" : \"mightIgnore,\") + betterMethodName + \",\" + c;\n\tif (reported.add(key)) {\n\t\tbugReporter.reportBug(\n\t\t\tnew BugInstance(exitInTryBlock ? \"DE_MIGHT_DROP\" : \"DE_MIGHT_IGNORE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this, handled)\n\t\t\t\t.addClass(c).describe(\"CLASS_EXCEPTION\"));\n\t}\n\n\t}\n\t\t}\n}","id":106691,"modified_method":"public void visit(Code obj) { \n\n\tCodeException [] exp = obj.getExceptionTable();\n\tif (exp == null) return;\n\tbyte [] code = obj.getCode();\n\n\tfor(int i = 0; i < exp.length; i++)  {\n\t  int handled = exp[i].getHandlerPC();\n\t  int start = exp[i].getStartPC();\n\t  int end = exp[i].getEndPC();\n\t  int cause = exp[i].getCatchType();\n\t  boolean exitInTryBlock = false;\n\n\t  for(int j = start; j <= end;)   {\n\t    int opcode = asUnsignedByte(code[j]);\n\t    if (opcode >= IRETURN && opcode <= RETURN\n\t\t|| opcode >=IFEQ && opcode <= GOTO\n\t\t\t\t&& (opcode != GOTO || j < end)\n\t\t\t) {\n\t\t\texitInTryBlock =  true;\n\t\t\tbreak;\n\t\t\t/*\n\t\t\tSystem.out.println(\"\texit: \" + opcode \n\t\t\t\t+ \" in \" + betterMethodName);\n\t\t\t*/\n\t\t\t}\n\t\tif (NO_OF_OPERANDS[opcode] < 0)  {\n\t\t\texitInTryBlock = true;\n\t\t\tbreak;\n\t\t\t}\n\t\tj += 1+NO_OF_OPERANDS[opcode];\n\t\t}\n\n\t  if (exitInTryBlock) continue;\n\t  String c ;\n\t  if (cause == 0)\n\t\tc = \"Throwable\";\n\t  else\n\t\t{\n\t\tc = Utility.compactClassName(\n\t\t  constant_pool.getConstantString(cause, \n\t\t\t\t\tCONSTANT_Class), false);\n\t\tif (!isChecked(c)) continue;\n\t\t}\n\tif (handled < 5) continue;\n\t/*\n\tif ( (0xff&code[handled]) == POP) {\n\t\tSystem.out.println( \"DE:\t\" \n\t\t\t+ betterMethodName\n\t\t\t+ \" might ignore \" + c\n\t\t\t+ \" (\" + (0xff&code[handled] )\n\t\t\t+ \",\" + (0xff&code[handled+1] )\n\t\t\t+\")\"\n\t\t\t);\n\t\t}\n\telse \n\t*/\n\tint opcode = asUnsignedByte(code[handled]);\n\t // System.out.println( \"DE:\topcode is \"  + opcode + \", \" + asUnsignedByte(code[handled+1]));\n\tboolean drops = false;\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled+1]) == RETURN) {\n\t\tif (DEBUG) System.out.println(\"Drop 1\");\n\t\tdrops = true;\n\t\t}\n\tif (handled+2 < code.length\n\t\t&&opcode == ASTORE\n\t\t && asUnsignedByte(code[handled+2]) == RETURN) {\n\t\tdrops = true;\n\t\tif (DEBUG) System.out.println(\"Drop 2\");\n\t\t}\n\tif (handled+3 < code.length\n\t   && !exitInTryBlock) {\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tif (offsetBefore == 4) {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 3\");\n\t\t\t}\n\t\t}\n\tif ( opcode == ASTORE\n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tif (offsetBefore == 5) {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 4\");\n\t\t\t}\n\t\t}\n\tif ( opcode >= ASTORE_0\n\t\t&& opcode <= ASTORE_3\n\t\t && asUnsignedByte(code[handled+1]) == GOTO \n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tint offsetAfter = \n\t\t\tasUnsignedByte(code[handled+2]) << 8\n\t\t\t| asUnsignedByte(code[handled+3]);\n\t\n\t\tif (offsetAfter > 0 && offsetAfter+4 == offsetBefore)\t  {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 5\");\n\t\t\t}\n\t\t}\n\n\tif ( opcode == ASTORE\n\t\t && asUnsignedByte(code[handled+2]) == GOTO \n\t\t && asUnsignedByte(code[handled-3]) == GOTO) {\n\t\tint offsetBefore = \n\t\t\tasUnsignedByte(code[handled-2]) << 8\n\t\t\t| asUnsignedByte(code[handled-1]);\n\t\tint offsetAfter = \n\t\t\tasUnsignedByte(code[handled+3]) << 8\n\t\t\t| asUnsignedByte(code[handled+4]);\n\t\n\t\tif (offsetAfter > 0 && offsetAfter+5 == offsetBefore)\t  {\n\t\t\tdrops = true;\n\t\t\tif (DEBUG) System.out.println(\"Drop 6\");\n\t\t\t}\n\t\t}\n\n\n\n\n\t}\n\tif (end-start >= 5 && drops && !c.equals(\"java.lang.InterruptedException\")\n\t\t\t&& !c.equals(\"java.lang.CloneNotSupportedException\")) {\n\tString key = (exitInTryBlock ? \"mightDrop,\" : \"mightIgnore,\") + betterMethodName + \",\" + c;\n\tif (reported.add(key)) {\n\t\tBugInstance bugInstance = new BugInstance(exitInTryBlock ? \"DE_MIGHT_DROP\" : \"DE_MIGHT_IGNORE\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this);\n\n\t\tSourceLineAnnotation srcLine = bugInstance.addSourceLine(this, handled).getPrimarySourceLineAnnotation();\n\t\tif (srcLine == null || !catchBlockHasComment(srcLine)) {\n\t\t\tbugInstance.addClass(c).describe(\"CLASS_EXCEPTION\");\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t}\n\t}\n\n\t}\n\t\t}\n}","commit_id":"c579a24825f336c8b490ff9c9873c98b2ed6cb86","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == PUTFIELD || seen == PUTSTATIC) {\n\t\t\tXField fieldOperand = getXFieldOperand();\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item oldSummary = summary.get(fieldOperand);\n\t\t\tif (oldSummary != null) {\n\t\t\t\tsummary.put(fieldOperand, OpcodeStack.Item.merge(top, oldSummary));\n\t\t\t} else\n\t\t\t\tsummary.put(fieldOperand, top);\n\t\t}\n\t\t\n\t}","id":106692,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == PUTFIELD || seen == PUTSTATIC) {\n\t\t\tXField fieldOperand = getXFieldOperand();\n\t\t\tif (seen == PUTFIELD && !getMethodName().equals(\"<init>\")\n\t\t\t\t\t|| seen == PUTSTATIC && !getMethodName().equals(\"<clinit>\"))\n\t\t\t\twrittenOutsideOfConstructor.add(fieldOperand);\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item oldSummary = summary.get(fieldOperand);\n\t\t\tif (oldSummary != null) {\n\t\t\t\tsummary.put(fieldOperand, OpcodeStack.Item.merge(top, oldSummary));\n\t\t\t} else\n\t\t\t\tsummary.put(fieldOperand, top);\n\t\t}\n\t\t\n\t}","commit_id":"582ffa58baa86120ae9bc70fc77a1b412d2a303f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == MONITORENTER) {\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tString signature = top.getSignature();\n\t\t\tObject constant = top.getConstant();\n\t\t\tif (signature.equals(\"Ljava/lang/String;\") && constant instanceof String) \n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_SHARED_CONSTANT\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this).addString((String)constant).addSourceLine(this));\n\t\t\telse if (badSignatures.contains(signature)) {\n\t\t\t\tboolean isBoolean = signature.equals(\"Ljava/lang/Boolean;\");\n\t\t\t\tXField field = top.getXField();\n\t\t\t\tFieldItemSummary fieldItemSummary = AnalysisContext.currentAnalysisContext().getFieldItemSummary();\n\t\t\t\tOpcodeStack.Item summary = fieldItemSummary.getSummary(field);\n\t\t\t\tif (field != null && field.isFinal()) return;\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (isBoolean) priority--;\n\t\t\t\tif (newlyConstructedObject(summary))\n\t\t\t\t\tpriority = LOW_PRIORITY;\n\t\t\t\tif (isBoolean) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_BOOLEAN\", priority)\n\t\t\t\t\t.addClassAndMethod(this).addOptionalField(field).addOptionalLocalVariable(this, top).addSourceLine(this));\n\t\t\t\telse bugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE\", priority)\n\t\t\t\t.addClassAndMethod(this).addType(signature).addOptionalField(field).addOptionalLocalVariable(this, top).addSourceLine(this));\n\t\t\t}\n\t\t}\n\t}","id":106693,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == MONITORENTER) {\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tString signature = top.getSignature();\n\t\t\tObject constant = top.getConstant();\n\t\t\tif (signature.equals(\"Ljava/lang/String;\") && constant instanceof String) {\n\t\t\t\tBugInstance bug = new BugInstance(this, \"DL_SYNCHRONIZATION_ON_SHARED_CONSTANT\", NORMAL_PRIORITY).addClassAndMethod(this);\n\n\t\t\t\tString value = (String) constant;\n\t\t\t\tif (identified.matcher(value).matches())\n\t\t\t\t\tbug.addString(value).describe(StringAnnotation.STRING_CONSTANT_ROLE);\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(bug.addSourceLine(this));\n\t\t\t} else if (badSignatures.contains(signature)) {\n\t\t\t\tboolean isBoolean = signature.equals(\"Ljava/lang/Boolean;\");\n\t\t\t\tXField field = top.getXField();\n\t\t\t\tFieldItemSummary fieldItemSummary = AnalysisContext.currentAnalysisContext().getFieldItemSummary();\n\t\t\t\tOpcodeStack.Item summary = fieldItemSummary.getSummary(field);\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (isBoolean) priority--;\n\t\t\t\tif (newlyConstructedObject(summary))\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE\", priority)\n\t\t\t\t\t.addClassAndMethod(this).addType(signature).addOptionalField(field).addOptionalLocalVariable(this, top).addSourceLine(this));\n\t\t\t\telse if (isBoolean) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_BOOLEAN\", priority)\n\t\t\t\t\t.addClassAndMethod(this).addOptionalField(field).addOptionalLocalVariable(this, top).addSourceLine(this));\n\t\t\t\telse bugReporter.reportBug(new BugInstance(this, \"DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE\", priority)\n\t\t\t\t.addClassAndMethod(this).addType(signature).addOptionalField(field).addOptionalLocalVariable(this, top).addSourceLine(this));\n\t\t\t}\n\t\t}\n\t}","commit_id":"582ffa58baa86120ae9bc70fc77a1b412d2a303f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Wrappers._T<String> mpsCorePath = new Wrappers._T<String>(PathManager.getLibPath());\n    File mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n    if (mpsCore.exists()) {\n      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(libJars).select(new ISelector<String, String>() {\n        public String select(String it) {\n          return mpsCorePath.value + File.separator + it;\n        }\n      }));\n      SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"plugins\" + File.separator + \"vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n    } else {\n      mpsCorePath.value = PathManager.getPluginsPath() + File.separator + \"mps-core\" + File.separator + \"lib\";\n      mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n      if (mpsCore.exists()) {\n        SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(libJars).select(new ISelector<String, String>() {\n          public String select(String it) {\n            return mpsCorePath.value + File.separator + it;\n          }\n        }));\n        SetSequence.fromSet(classpathItems).addElement(PathManager.getPluginsPath() + File.separator + \"mps-vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n      } else {\n        SetSequence.fromSet(classpathItems).addSequence(SetSequence.fromSet(getClasspathInternal()));\n      }\n    }\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(ideaLibJars).select(new ISelector<String, String>() {\n      public String select(String it) {\n        return PathManager.getLibPath() + File.separator + it;\n      }\n    }));\n\n\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    SetSequence.fromSet(classpathItems).addElement(getTextMergerJar());\n    return classpathItems;\n  }","id":106694,"modified_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Wrappers._T<String> mpsCorePath = new Wrappers._T<String>(PathManager.getLibPath());\n    File mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n    if (mpsCore.exists()) {\n      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsLibJars).select(new ISelector<String, String>() {\n        public String select(String it) {\n          return mpsCorePath.value + File.separator + it;\n        }\n      }));\n      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsAddJars).select(new ISelector<String, String>() {\n        public String select(String it) {\n          return mpsCorePath.value + File.separator + it;\n        }\n      }));\n      SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"plugins\" + File.separator + \"vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n    } else {\n      mpsCorePath.value = PathManager.getPluginsPath() + File.separator + \"mps-core\" + File.separator + \"lib\";\n      mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n      if (mpsCore.exists()) {\n        SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsLibJars).select(new ISelector<String, String>() {\n          public String select(String it) {\n            return mpsCorePath.value + File.separator + it;\n          }\n        }));\n        SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsAddJars).select(new ISelector<String, String>() {\n          public String select(String it) {\n            return mpsCorePath.value + File.separator + it;\n          }\n        }));\n        SetSequence.fromSet(classpathItems).addElement(PathManager.getPluginsPath() + File.separator + \"mps-vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n      } else {\n        SetSequence.fromSet(classpathItems).addSequence(SetSequence.fromSet(getClasspathInternal()));\n      }\n    }\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(ideaLibJars).select(new ISelector<String, String>() {\n      public String select(String it) {\n        return PathManager.getLibPath() + File.separator + it;\n      }\n    }));\n\n\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    SetSequence.fromSet(classpathItems).addElement(getTextMergerJar());\n    return classpathItems;\n  }","commit_id":"e4b9286ceae8ffb06e622d3b262cdcba76bc06dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Set<String> getClasspathInternal() {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Iterable<String> OTHER_CLASSES = Arrays.asList(\"jetbrains.mps.internal.collections.runtime.ListSequence\", \"jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes\", \"jetbrains.mps.typesystem.inference.TypeChecker\", \"jetbrains.mps.editor.runtime.impl.LanguagesKeymapManager\", \"jetbrains.mps.intentions.IntentionsManager\", \"jetbrains.mps.ide.findusages.FindersManager\", \"jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner\", \"jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple\");\n    Iterable<Class> classes = Arrays.<Class>asList(MergeDriverMain.class, FileUtil.class, MergeSession.class, SModel.class, IdeMain.class);\n    classes = Sequence.fromIterable(OTHER_CLASSES).select(new ISelector<String, Class>() {\n      public Class select(String cn) {\n        try {\n          return (Class) Class.forName(cn);\n        } catch (ClassNotFoundException e) {\n          if (log.isErrorEnabled()) {\n            log.error(\"\", e);\n          }\n          return null;\n        }\n      }\n    }).concat(Sequence.fromIterable(classes));\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(classes).select(new ISelector<Class, String>() {\n      public String select(Class c) {\n        return PathUtil.getJarPathForClass(c);\n      }\n    }));\n    return classpathItems;\n\n  }","id":106695,"modified_method":"public static Set<String> getClasspathInternal() {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Iterable<String> OTHER_CLASSES = Arrays.asList(\"jetbrains.mps.internal.collections.runtime.ListSequence\", \"jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes\", \"jetbrains.mps.typesystem.inference.TypeChecker\", \"jetbrains.mps.editor.runtime.impl.LanguagesKeymapManager\", \"jetbrains.mps.intentions.IntentionsManager\", \"jetbrains.mps.ide.findusages.FindersManager\", \"jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner\", \"jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple\");\n    Iterable<Class> classes = Arrays.<Class>asList(MergeDriverMain.class, FileUtil.class, MergeSession.class, SModel.class, IdeMain.class);\n    classes = Sequence.fromIterable(OTHER_CLASSES).select(new ISelector<String, Class>() {\n      public Class select(String cn) {\n        try {\n          return (Class) Class.forName(cn);\n        } catch (ClassNotFoundException e) {\n          if (log.isErrorEnabled()) {\n            log.error(\"\", e);\n          }\n          return null;\n        }\n      }\n    }).concat(Sequence.fromIterable(classes));\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(classes).select(new ISelector<Class, String>() {\n      public String select(Class c) {\n        return PathUtil.getJarPathForClass(c);\n      }\n    }));\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsAddJars).select(new ISelector<String, String>() {\n      public String select(String it) {\n        return PathManager.getLibPath() + File.separator + it;\n      }\n    }));\n    return classpathItems;\n\n  }","commit_id":"e4b9286ceae8ffb06e622d3b262cdcba76bc06dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testFacetInitialized() {\n    FacetManager facetManager = FacetManager.getInstance(myModule);\n    Collection<MPSFacet> mpsFacets = facetManager.getFacetsByType(MPSFacetType.ID);\n    assertEquals(1, mpsFacets.size());\n    assertEquals(myFacet, mpsFacets.iterator().next());\n    assertEquals(myFacet, facetManager.getFacetByType(MPSFacetType.ID));\n\n    assertTrue(myFacet.wasInitialized());\n\n    runModelRead(new Runnable() {\n      @Override\n      public void run() {\n        // Default Solution settings\n        Solution solution = myFacet.getSolution();\n        assertFalse(solution.getModelRoots().iterator().hasNext());\n        // JDK solution should be always returned as module dependencies for now\n        // Commented out: jdk is connected like a real module sdk, which is probably absent in this test environment\n//    assertEquals(1, solution.getDependencies().size());\n        assertEmpty(solution.getUsedLanguagesReferences());\n\n        assertEquals(getModuleHome() + \"/src_gen\", solution.getGeneratorOutputPath());\n\n        Solution repositorySolution = ModuleRepositoryFacade.getInstance().getModule(solution.getModuleReference(), Solution.class);\n        assertEquals(solution, repositorySolution);\n        assertEquals(myModule.getName(), solution.getModuleDescriptor().getNamespace());\n      }\n    });\n  }","id":106696,"modified_method":"public void testFacetInitialized() {\n    FacetManager facetManager = FacetManager.getInstance(myModule);\n    Collection<MPSFacet> mpsFacets = facetManager.getFacetsByType(MPSFacetType.ID);\n    assertEquals(1, mpsFacets.size());\n    assertEquals(myFacet, mpsFacets.iterator().next());\n    assertEquals(myFacet, facetManager.getFacetByType(MPSFacetType.ID));\n\n    assertTrue(myFacet.wasInitialized());\n\n    runModelRead(new Runnable() {\n      @Override\n      public void run() {\n        // Default Solution settings\n        Solution solution = myFacet.getSolution();\n        assertFalse(solution.getModelRoots().iterator().hasNext());\n        // JDK solution should be always returned as module dependencies for now\n        // Commented out: jdk is connected like a real module sdk, which is probably absent in this test environment\n//    assertEquals(1, solution.getDependencies().size());\n        assertEmpty(solution.getUsedLanguagesReferences());\n\n        assertEquals(getModuleHome() + \"/src_gen\", solution.getOutputPath().getPath());\n\n        Solution repositorySolution = ModuleRepositoryFacade.getInstance().getModule(solution.getModuleReference(), Solution.class);\n        assertEquals(solution, repositorySolution);\n        assertEquals(myModule.getName(), solution.getModuleDescriptor().getNamespace());\n      }\n    });\n  }","commit_id":"459c16c43e003bd608bbbd1314e17ed3985f78eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testSetGeneratorOutputPath() throws InterruptedException {\n    @NonNls String generatorOutputPath = getModuleHome() + \"/generatorOut\";\n    MPSConfigurationBean configurationBean = myFacet.getConfiguration().getBean();\n    configurationBean.setGeneratorOutputPath(generatorOutputPath);\n    myFacet.setConfiguration(configurationBean);\n    flushEDT();\n\n    assertEquals(generatorOutputPath, myFacet.getSolution().getGeneratorOutputPath());\n  }","id":106697,"modified_method":"public void testSetGeneratorOutputPath() throws InterruptedException {\n    @NonNls String generatorOutputPath = getModuleHome() + \"/generatorOut\";\n    MPSConfigurationBean configurationBean = myFacet.getConfiguration().getBean();\n    configurationBean.setGeneratorOutputPath(generatorOutputPath);\n    myFacet.setConfiguration(configurationBean);\n    flushEDT();\n\n    assertEquals(generatorOutputPath, myFacet.getSolution().getOutputPath().getPath());\n  }","commit_id":"459c16c43e003bd608bbbd1314e17ed3985f78eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleOutputPaths(Iterable<SModule> _modules) {\n    Iterable<AbstractModule> modules = Sequence.fromIterable(_modules).where(new IWhereFilter<SModule>() {\n      public boolean accept(SModule it) {\n        return it instanceof AbstractModule;\n      }\n    }).select(new ISelector<SModule, AbstractModule>() {\n      public AbstractModule select(SModule it) {\n        return ((AbstractModule) it);\n      }\n    });\n    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        return ((AbstractModule) mod).getGeneratorOutputPath();\n      }\n    }));\n    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        return FileGenerationUtil.getCachesPath(mod.getGeneratorOutputPath());\n      }\n    }));\n    // todo: use union of output paths for models? \n    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        // todo: tmp hack \n        String path = mod.getTestsGeneratorOutputPath();\n        return (path != null ? path : mod.getGeneratorOutputPath());\n      }\n    }));\n    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {\n      public String select(AbstractModule mod) {\n        // todo: tmp hack \n        String path = mod.getTestsGeneratorOutputPath();\n        if (path == null) {\n          path = mod.getGeneratorOutputPath();\n        }\n        return FileGenerationUtil.getCachesPath(path);\n      }\n    }));\n\n    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FolderModelRootBase;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FolderModelRootBase) smr).getPath();\n      }\n    });\n    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FileBasedModelRoot;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FileBasedModelRoot) smr).getContentRoot();\n      }\n    }));\n\n    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {\n      public IFile select(String path) {\n        return FileSystem.getInstance().getFileByPath(path);\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile f) {\n        return f.isDirectory() && !(f instanceof JarEntryFile);\n      }\n    }).select(new ISelector<IFile, String>() {\n      public String select(IFile dir) {\n        return dir.getPath();\n      }\n    }));\n  }","id":106698,"modified_method":"public ModuleOutputPaths(Iterable<SModule> _modules) {\n    // FIXME consider re-use of SModuleOperations#getOutputRoots, avoid code duplication \n    Iterable<AbstractModule> modules = Sequence.fromIterable(_modules).ofType(AbstractModule.class);\n    Iterable<IFile> outputRoots = Sequence.fromIterable(modules).select(new ISelector<AbstractModule, IFile>() {\n      public IFile select(AbstractModule it) {\n        return it.getOutputPath();\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile it) {\n        return it != null;\n      }\n    });\n    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(outputRoots).select(new ISelector<IFile, String>() {\n      public String select(IFile it) {\n        return it.getPath();\n      }\n    }));\n    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(outputRoots).select(new ISelector<IFile, String>() {\n      public String select(IFile it) {\n        return FileGenerationUtil.getCachesPath(it.getPath());\n      }\n    }));\n    // todo: use union of output paths for models? \n    Iterable<IFile> testOutputRoots = Sequence.fromIterable(modules).select(new ISelector<AbstractModule, IFile>() {\n      public IFile select(AbstractModule mod) {\n        if (mod.getFacet(TestsFacet.class) != null) {\n          return mod.getFacet(TestsFacet.class).getTestsOutputPath();\n        }\n        return null;\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile it) {\n        return it != null;\n      }\n    });\n    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputRoots).select(new ISelector<IFile, String>() {\n      public String select(IFile it) {\n        return it.getPath();\n      }\n    }));\n    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputRoots).select(new ISelector<IFile, String>() {\n      public String select(IFile it) {\n        return FileGenerationUtil.getCachesPath(it.getPath());\n      }\n    }));\n\n    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FolderModelRootBase;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FolderModelRootBase) smr).getPath();\n      }\n    });\n    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {\n      public Iterable<ModelRoot> translate(SModule mod) {\n        return mod.getModelRoots();\n      }\n    }).where(new IWhereFilter<ModelRoot>() {\n      public boolean accept(ModelRoot it) {\n        return it instanceof FileBasedModelRoot;\n      }\n    }).select(new ISelector<ModelRoot, String>() {\n      public String select(ModelRoot smr) {\n        return ((FileBasedModelRoot) smr).getContentRoot();\n      }\n    }));\n\n    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {\n      public IFile select(String path) {\n        return FileSystem.getInstance().getFileByPath(path);\n      }\n    }).where(new IWhereFilter<IFile>() {\n      public boolean accept(IFile f) {\n        return f.isDirectory() && !(f instanceof JarEntryFile);\n      }\n    }).select(new ISelector<IFile, String>() {\n      public String select(IFile dir) {\n        return dir.getPath();\n      }\n    }));\n  }","commit_id":"459c16c43e003bd608bbbd1314e17ed3985f78eb","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Get the contents of a URI as a String but send it through tidy first\n   * @param uri the URI\n   * @return the data pointed to by a URI\n   */\n  public static String getTidyString (String uri) throws IOException, MalformedURLException, PortalException\n  {\n    URL url = new URL (UtilitiesBean.fixURI(uri));\n    Tidy tidy = new Tidy ();\n    tidy.setXHTML (true);\n    tidy.setDocType (\"omit\");\n    tidy.setQuiet(true);\n    tidy.setShowWarnings(false);\n    tidy.setNumEntities(true);\n    tidy.setWord2000(true);\n    if ( System.getProperty(\"os.name\").indexOf(\"Windows\") != -1 )\n       tidy.setErrout( new PrintWriter ( new FileOutputStream (new File (\"nul\") ) ) );\n    else\n       tidy.setErrout( new PrintWriter ( new FileOutputStream (new File (\"/dev/null\") ) ) );\n    ByteArrayOutputStream stream = new ByteArrayOutputStream (1024);\n\n    tidy.parse (url.openStream(), new BufferedOutputStream (stream));\n    if ( tidy.getParseErrors() > 0 )\n      throw new GeneralRenderingException(\"Unable to convert input document to XHTML\");\n    return stream.toString ();\n\n  }","id":106699,"modified_method":"/**\n   * Get the contents of a URI as a String but send it through tidy first.\n   * Also includes support for cookies.  \n   * @param uri the URI\n   * @return the data pointed to by a URI\n   */\n  private String getXmlString (String uri) \n  throws IOException, MalformedURLException, PortalException, ParseException\n  {\n    URL url = new URL (UtilitiesBean.fixURI(uri));\n    URLConnection urlConnect = url.openConnection();\n\n    sendAndStoreCookies(urlConnect);\n\n    String xml;\n    if ( (tidy != null) && (tidy.equalsIgnoreCase(\"on\")) )\n    {\n      Tidy tidy = new Tidy ();\n      tidy.setXHTML (true);\n      tidy.setDocType (\"omit\");\n      tidy.setQuiet(true);\n      tidy.setShowWarnings(false);\n      tidy.setNumEntities(true);\n      tidy.setWord2000(true);\n      if ( System.getProperty(\"os.name\").indexOf(\"Windows\") != -1 )\n         tidy.setErrout( new PrintWriter ( new FileOutputStream (new File (\"nul\") ) ) );\n      else\n         tidy.setErrout( new PrintWriter ( new FileOutputStream (new File (\"/dev/null\") ) ) );\n      ByteArrayOutputStream stream = new ByteArrayOutputStream (1024);\n\n      tidy.parse (urlConnect.getInputStream(), new BufferedOutputStream (stream));\n      if ( tidy.getParseErrors() > 0 )\n        throw new GeneralRenderingException(\"Unable to convert input document to XHTML\");\n      xml = stream.toString();\n    }\n    else\n    {\n      String line = null;\n      BufferedReader in = new BufferedReader(new InputStreamReader(urlConnect.getInputStream()));\n      StringBuffer sbText = new StringBuffer (1024);\n\n      while ((line = in.readLine()) != null)\n        sbText.append (line).append (\"\\n\");\n\n      xml = sbText.toString ();\n    }\n    \n    return xml;\n\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void receiveEvent (PortalEvent ev)\n  {\n    // No events to process here\n  }","id":106700,"modified_method":"/**\n   * Process portal events.  Currently supported events are\n   * EDIT_BUTTON_EVENT, HELP_BUTTON_EVENT, and ABOUT_BUTTON_EVENT.\n   * These three work by changing the xmlUri.  The new Uri should\n   * contain a link that will refer back to the old one at the end\n   * of its task.\n   * @param ev the event\n   */\n  public void receiveEvent (PortalEvent ev)\n  {\n    int evnum;\n\n    evnum = ev.getEventNumber();\n    if (evnum == ev.EDIT_BUTTON_EVENT && this.editUri != null)\n          this.buttonxmlUri = this.editUri;\n    else if (evnum == ev.HELP_BUTTON_EVENT && this.helpUri != null)\n\t  this.buttonxmlUri = this.helpUri;\n    else if (evnum == ev.ABOUT_BUTTON_EVENT && this.infoUri != null)\n          this.buttonxmlUri = this.infoUri;\n\n      // case ev.UNSUBSCRIBE:\n      //   // remove db entry for channel\n      //   break;\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setStaticData (ChannelStaticData sd)\n  {\n    try\n    {\n      this.xmlUri = sd.getParameter (\"xml\");\n      this.sslUri = sd.getParameter (\"ssl\");\n      this.fullxmlUri = sd.getParameter (\"xml\");\n      this.passThrough = sd.getParameter (\"passThrough\");\n      this.tidy = sd.getParameter (\"tidy\");\n    }\n    catch (Exception e)\n    {\n      Logger.log (Logger.ERROR, e);\n    }\n  }","id":106701,"modified_method":"public void setStaticData (ChannelStaticData sd)\n  {\n    try\n    {\n      // to add: if not already set, make a copy of sd for the \"reset\" command\n      this.xmlUri = sd.getParameter (\"cw_xml\");\n      this.sslUri = sd.getParameter (\"cw_ssl\");\n      this.fullxmlUri = sd.getParameter (\"cw_xml\");\n      this.passThrough = sd.getParameter (\"cw_passThrough\");\n      this.tidy = sd.getParameter (\"cw_tidy\");\n      this.infoUri = sd.getParameter (\"cw_info\");\n      this.helpUri = sd.getParameter (\"cw_help\");\n      this.editUri = sd.getParameter (\"cw_edit\");\n    }\n    catch (Exception e)\n    {\n      Logger.log (Logger.ERROR, e);\n    }\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setRuntimeData (ChannelRuntimeData rd)\n  {\n    runtimeData = rd;\n\n    String xmlUri = runtimeData.getParameter(\"xmlUri\");\n\n    if (xmlUri != null)\n       this.xmlUri = xmlUri;\n\n    String sslUri = runtimeData.getParameter(\"sslUri\");\n\n    if (sslUri != null)\n       this.sslUri = sslUri;\n\n    String xslTitle = runtimeData.getParameter(\"xslTitle\");\n\n    if (xslTitle != null)\n       this.xslTitle = xslTitle;\n\n    String xslUri = runtimeData.getParameter(\"xslUri\");\n\n    if (xslUri != null)\n       this.xslUri = xslUri;\n\n    String passThrough = runtimeData.getParameter(\"passThrough\");\n\n    if (passThrough != null)\n       this.passThrough = passThrough;\n\n    String tidy = runtimeData.getParameter(\"tidy\");\n\n    if (tidy != null)\n       this.tidy = tidy;\n\n    media = runtimeData.getMedia();\n\n    if (this.passThrough != null )\n      Logger.log (Logger.DEBUG, \"CWebProxy: passThrough: \" + this.passThrough);\n\n    if ( this.passThrough != null &&\n       !this.passThrough.equalsIgnoreCase(\"none\") &&\n         ( this.passThrough.equalsIgnoreCase(\"all\") ||\n           runtimeData.getParameter(\"inChannelLink\") != null ) )\n    {\n      Logger.log (Logger.DEBUG, \"CWebProxy: xmlUri is \" + this.xmlUri);\n\n      StringBuffer newXML = new StringBuffer().append(this.xmlUri);\n      String appendchar = \"?\";\n\n      Enumeration e=runtimeData.getParameterNames ();\n      if (e!=null)\n        {\n          while (e.hasMoreElements ())\n            {\n              String pName = (String) e.nextElement ();\n              if ( !pName.equals(\"inChannelLink\") )\n              {\n                newXML.append(appendchar);\n                appendchar = \"&\";\n                newXML.append(pName);\n                newXML.append(\"=\");\n                newXML.append(URLEncoder.encode(runtimeData.getParameter(pName)));\n              }\n            }\n        }\n      fullxmlUri = newXML.toString();\n      Logger.log (Logger.DEBUG, \"CWebProxy: fullxmlUri now: \" + fullxmlUri);\n    }\n  }","id":106702,"modified_method":"public void setRuntimeData (ChannelRuntimeData rd)\n  {\n    runtimeData = rd;\n\n    String xmlUri = runtimeData.getParameter(\"cw_xml\");\n    if (xmlUri != null) {\n       this.xmlUri = xmlUri;\n       // don't need an explicit reset if a new URI is provided.\n       buttonxmlUri = null;\n    }\n\n    String sslUri = runtimeData.getParameter(\"cw_ssl\");\n    if (sslUri != null)\n       this.sslUri = sslUri;\n\n    String xslTitle = runtimeData.getParameter(\"cw_xslTitle\");\n    if (xslTitle != null)\n       this.xslTitle = xslTitle;\n\n    String xslUri = runtimeData.getParameter(\"cw_xsl\");\n    if (xslUri != null)\n       this.xslUri = xslUri;\n\n    String passThrough = runtimeData.getParameter(\"cw_passThrough\");\n    if (passThrough != null)\n       this.passThrough = passThrough;\n\n    String tidy = runtimeData.getParameter(\"cw_tidy\");\n    if (tidy != null)\n       this.tidy = tidy;\n\n    String infoUri = runtimeData.getParameter(\"cw_info\");\n    if (infoUri != null)\n       this.infoUri = infoUri;\n\n    String editUri = runtimeData.getParameter(\"cw_edit\");\n    if (editUri != null)\n       this.editUri = editUri;\n\n    String helpUri = runtimeData.getParameter(\"cw_help\");\n    if (helpUri != null)\n       this.helpUri = helpUri;\n\n    // reset is a one-time thing.\n    String reset = runtimeData.getParameter(\"cw_reset\");\n    if (reset != null) {\n       if (reset.equalsIgnoreCase(\"return\")) {\n          buttonxmlUri = null;\n       }\n       // else if (reset.equalsIgnoreCase(\"reset\")) {\n       //  call setStaticData with our cached copy.\n       // }\n    }\n\n    media = runtimeData.getMedia();\n\n    if ( buttonxmlUri != null )\n\tfullxmlUri = buttonxmlUri;\n    else {\n    //if (this.passThrough != null )\n    //  Logger.log (Logger.DEBUG, \"CWebProxy: passThrough: \"+this.passThrough);\n\n    // Is this a case where we need to pass request parameters to the xmlURI?\n    if ( this.passThrough != null &&\n       !this.passThrough.equalsIgnoreCase(\"none\") &&\n         ( this.passThrough.equalsIgnoreCase(\"all\") ||\n           runtimeData.getParameter(\"cw_inChannelLink\") != null ) )\n    {\n      Logger.log (Logger.DEBUG, \"CWebProxy: xmlUri is \" + this.xmlUri);\n\n      StringBuffer newXML = new StringBuffer().append(this.xmlUri);\n      String appendchar = \"?\";\n\n      // want all runtime parameters not specific to WebProxy\n      Enumeration e=runtimeData.getParameterNames ();\n      if (e!=null)\n        {\n          while (e.hasMoreElements ())\n            {\n              String pName = (String) e.nextElement ();\n              if ( !pName.startsWith(\"cw_\") )\n              {\n                newXML.append(appendchar);\n                appendchar = \"&\";\n                newXML.append(pName);\n                newXML.append(\"=\");\n                newXML.append(URLEncoder.encode(runtimeData.getParameter(pName)));\n              }\n            }\n        }\n      fullxmlUri = newXML.toString();\n      Logger.log (Logger.DEBUG, \"CWebProxy: fullxmlUri now: \" + fullxmlUri);\n    }\n    }\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public CWebProxy ()\n  {\n  }","id":106703,"modified_method":"public CWebProxy ()\n  {\n    this.cookies = new Vector();\n    this.timer = new Timer();\n    this.supportSetCookie2 = false;\n    this.buttonxmlUri = null;\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void renderXML (DocumentHandler out) throws PortalException\n  {\n    String xml;\n\n    if (tidy != null && tidy.equalsIgnoreCase(\"on\"))\n    {\n      try\n      {\n        xml = getTidyString (fullxmlUri);\n      }\n      catch (Exception e)\n      {\n        throw new ResourceMissingException (fullxmlUri, \"\", e.getMessage());\n      }\n    }\n    else\n    {\n      try\n      {\n        xml = UtilitiesBean.getContentsAsString(fullxmlUri);\n      }\n      catch (Exception e)\n      {\n        throw new ResourceMissingException (fullxmlUri, \"\", e.getMessage());\n      }\n    }\n\n    runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n\n    // possibly this should be a copy\n    if (xmlUri != null)\n      runtimeData.put(\"xmlUri\", xmlUri);\n    if (sslUri != null)\n      runtimeData.put(\"sslUri\", sslUri);\n    if (xslTitle != null)\n      runtimeData.put(\"xslTitle\", xslTitle);\n    if (xslUri != null)\n      runtimeData.put(\"xslUri\", xslUri);\n    if (passThrough != null)\n      runtimeData.put(\"passThrough\", passThrough);\n    if (tidy != null)\n      runtimeData.put(\"tidy\", tidy);\n\n    try\n    {\n      if (xslUri != null)\n        XSLT.transform(xml, new URL(xslUri), out, runtimeData);\n      else\n      {\n        if (xslTitle != null)\n          XSLT.transform(xml, new URL(sslUri), out, runtimeData, xslTitle, media);\n        else\n          XSLT.transform(xml, new URL(sslUri), out, runtimeData, media);\n      }\n    }\n    catch (org.xml.sax.SAXException e)\n    {\n      throw new GeneralRenderingException(\"problem performing the transformation\");\n    } catch (IOException i) {\n      StringWriter sw = new StringWriter();\n      i.printStackTrace(new PrintWriter(sw));\n      sw.flush();\n      throw new GeneralRenderingException(sw.toString());\n    }\n  }","id":106704,"modified_method":"public void renderXML (DocumentHandler out) throws PortalException\n  {\n    String xml;\n\n    try\n    {\n      xml = getXmlString (fullxmlUri);\n    }\n    catch (Exception e)\n    {\n      throw new ResourceMissingException (fullxmlUri, \"\", e.getMessage());\n    }\n\n    runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n\n    // Runtime data parameters gets handed to the stylesheet.\n    // Add any static data parameters so it gets a full set of variables.\n    // Possibly this should be a copy.\n    if (xmlUri != null)\n      runtimeData.put(\"cw_xml\", xmlUri);\n    if (sslUri != null)\n      runtimeData.put(\"cs_ssl\", sslUri);\n    if (xslTitle != null)\n      runtimeData.put(\"cw_xslTitle\", xslTitle);\n    if (xslUri != null)\n      runtimeData.put(\"cw_xsl\", xslUri);\n    if (passThrough != null)\n      runtimeData.put(\"cw_passThrough\", passThrough);\n    if (tidy != null)\n      runtimeData.put(\"cw_tidy\", tidy);\n    if (infoUri != null)\n      runtimeData.put(\"cw_info\", infoUri);\n    if (helpUri != null)\n      runtimeData.put(\"cw_help\", helpUri);\n    if (editUri != null)\n      runtimeData.put(\"cw_edit\", editUri);\n\n    try\n    {\n      if (xslUri != null)\n        XSLT.transform(xml, new URL(xslUri), out, runtimeData);\n      else\n      {\n        if (xslTitle != null)\n          XSLT.transform(xml, new URL(sslUri), out, runtimeData, xslTitle, media);\n        else\n          XSLT.transform(xml, new URL(sslUri), out, runtimeData, media);\n      }\n    }\n    catch (org.xml.sax.SAXException e)\n    {\n      throw new GeneralRenderingException(\"problem performing the transformation\");\n    } catch (IOException i) {\n      StringWriter sw = new StringWriter();\n      i.printStackTrace(new PrintWriter(sw));\n      sw.flush();\n      throw new GeneralRenderingException(sw.toString());\n    }\n  }","commit_id":"b242f46d335e0f7114f8d1e37e2831a8e7196900","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean action(XWikiContext context) throws XWikiException {\n\t\tXWikiRequest request = context.getRequest();\n\t\tString formaction = request.getParameter(\"formaction\");\n\t\tif (formaction == null || formaction.equals(\"\") || formaction.equals(\"_preview_\")) {\n\t\t\treturn true;\n\t\t} else if (formaction.equals(\"_save_\")) {\n\t\t\tSaveAction sa = new SaveAction();\n\t\t\tif (sa.action(context)) {\n\t\t\t\tsa.render(context);\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (formaction.equals(\"_cancel_\")) {\n\t\t\tCancelAction ca = new CancelAction();\n\t\t\tif (ca.action(context)) {\n\t\t\t\tca.render(context);\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (formaction.equals(\"_saveandcontinue_\")) {\n\t\t\tSaveAndContinueAction saca = new SaveAndContinueAction();\n\t\t\tif (saca.action(context)) {\n\t\t\t\tsaca.render(context);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":106705,"modified_method":"public boolean action(XWikiContext context) throws XWikiException {\n\t\tXWikiRequest request = context.getRequest();\n\t\t// String formaction = request.getParameter(\"formaction\");\n\t\tString formactionsave = request.getParameter(\"formactionsave\");\n\t\tString formactioncancel = request.getParameter(\"formactioncancel\");\n\t\tString formactionsac = request.getParameter(\"formactionsac\");\n        if (isActionSelected(formactionsave)) {\n\t\t\tSaveAction sa = new SaveAction();\n\t\t\tif (sa.action(context)) {\n\t\t\t\tsa.render(context);\n\t\t\t}\n\t\t\treturn false;\n        }\n        if (isActionSelected(formactioncancel)) {\n\t\t\tCancelAction ca = new CancelAction();\n\t\t\tif (ca.action(context)) {\n\t\t\t\tca.render(context);\n\t\t\t}\n\t\t\treturn false;\n        }\n        if (isActionSelected(formactionsac)) {\n\t\t\tSaveAndContinueAction saca = new SaveAndContinueAction();\n\t\t\tif (saca.action(context)) {\n\t\t\t\tsaca.render(context);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"2ab4268b5664b8b24453ff28b36b3079f3e63ea2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String render(XWikiContext context) throws XWikiException {\n\t\tXWikiRequest request = context.getRequest();\n        XWiki xwiki = context.getWiki();\n\t\tString formaction = request.getParameter(\"formaction\");\n\t\tif (formaction == null || formaction.equals(\"\") || formaction.equals(\"_preview_\")) {\n\t\t\tXWikiDocument doc = context.getDoc();\n\t\t\tXWikiForm form = context.getForm();\n\t\t\tVelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n\n            if (xwiki.hasCaptcha(context)) {\n                CaptchaPluginApi captchaPluginApi = (CaptchaPluginApi) xwiki.getPluginApi(\"jcaptcha\", context);\n                if (captchaPluginApi != null)\n                    vcontext.put(\"captchaPlugin\", captchaPluginApi);\n                vcontext.put(\"isResponseCorrect\", captchaPluginApi.verifyCaptcha(\"edit\").toString());\n            }\n\n\t\t\tString language = ((EditForm) form).getLanguage();\n\t\t\tXWikiDocument tdoc;\n\n\t\t\t// Make sure it is not considered as new\n\t\t\tXWikiDocument doc2 = (XWikiDocument) doc.clone();\n\t\t\tcontext.put(\"doc\", doc2);\n\n           int sectionNumber = 0;\n           if (request.getParameter(\"section\") != null && context.getWiki().hasSectionEdit(context)) {\n               sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n            }\n            vcontext.put(\"sectionNumber\",new Integer(sectionNumber));\n\n\t\t\tif ((language == null) || (language.equals(\"\")) || (language.equals(\"default\")) || (language.equals(doc.getDefaultLanguage()))) {\n\t\t\t\ttdoc = doc2;\n\t\t\t\tcontext.put(\"tdoc\", doc2);\n\t\t\t\tvcontext.put(\"doc\", doc2.newDocument(context));\n\t\t\t\tvcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n\t\t\t\tvcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n\t\t\t\tdoc2.readFromTemplate(((EditForm) form).getTemplate(), context);\n\t\t\t\tdoc2.readFromForm((EditForm) form, context);\n                doc2.setAuthor(context.getUser());\n                if(doc2.isNew()){\n                    doc2.setCreator(context.getUser());\n                }\n\t\t\t} else {\n\t\t\t\t// Need to save parent and defaultLanguage if they have changed\n\t\t\t\ttdoc = doc.getTranslatedDocument(language, context);\n\t\t\t\ttdoc.setLanguage(language);\n\t\t\t\ttdoc.setTranslation(1);\n\t\t\t\tXWikiDocument tdoc2 = (XWikiDocument) tdoc.clone();\n\t\t\t\tcontext.put(\"tdoc\", tdoc2);\n\t\t\t\tvcontext.put(\"tdoc\", tdoc2.newDocument(context));\n\t\t\t\tvcontext.put(\"cdoc\", vcontext.get(\"tdoc\"));\n\t\t\t\ttdoc2.readFromTemplate(((EditForm) form).getTemplate(), context);\n\t\t\t\ttdoc2.readFromForm((EditForm) form, context);\n                tdoc2.setAuthor(context.getUser());\n                if(tdoc2.isNew()){\n                    tdoc2.setCreator(context.getUser());\n                }\n\t\t\t}\n            // reconfirm edit (captcha) when jcaptcha is not correct\n            if ((context.get(\"recheckcaptcha\") != null) && ((Boolean)context.get(\"recheckcaptcha\")).booleanValue())\n                return \"captcha\";\n            else return \"preview\";\n\t\t}\n\t\treturn \"disambiguation\";\n\t}","id":106706,"modified_method":"public String render(XWikiContext context) throws XWikiException {\n\t\tXWikiRequest request = context.getRequest();\n        XWiki xwiki = context.getWiki();\n\t\t\tXWikiDocument doc = context.getDoc();\n\t\t\tXWikiForm form = context.getForm();\n\t\t\tVelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n\n            if (xwiki.hasCaptcha(context)) {\n                CaptchaPluginApi captchaPluginApi = (CaptchaPluginApi) xwiki.getPluginApi(\"jcaptcha\", context);\n                if (captchaPluginApi != null)\n                    vcontext.put(\"captchaPlugin\", captchaPluginApi);\n                vcontext.put(\"isResponseCorrect\", captchaPluginApi.verifyCaptcha(\"edit\").toString());\n            }\n\n\t\t\tString language = ((EditForm) form).getLanguage();\n\t\t\tXWikiDocument tdoc;\n\n\t\t\t// Make sure it is not considered as new\n\t\t\tXWikiDocument doc2 = (XWikiDocument) doc.clone();\n\t\t\tcontext.put(\"doc\", doc2);\n\n           int sectionNumber = 0;\n           if (request.getParameter(\"section\") != null && context.getWiki().hasSectionEdit(context)) {\n               sectionNumber = Integer.parseInt(request.getParameter(\"section\"));\n            }\n            vcontext.put(\"sectionNumber\",new Integer(sectionNumber));\n\n\t\t\tif ((language == null) || (language.equals(\"\")) || (language.equals(\"default\")) || (language.equals(doc.getDefaultLanguage()))) {\n\t\t\t\ttdoc = doc2;\n\t\t\t\tcontext.put(\"tdoc\", doc2);\n\t\t\t\tvcontext.put(\"doc\", doc2.newDocument(context));\n\t\t\t\tvcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n\t\t\t\tvcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n\t\t\t\tdoc2.readFromTemplate(((EditForm) form).getTemplate(), context);\n\t\t\t\tdoc2.readFromForm((EditForm) form, context);\n                doc2.setAuthor(context.getUser());\n                if(doc2.isNew()){\n                    doc2.setCreator(context.getUser());\n                }\n\t\t\t} else {\n\t\t\t\t// Need to save parent and defaultLanguage if they have changed\n\t\t\t\ttdoc = doc.getTranslatedDocument(language, context);\n\t\t\t\ttdoc.setLanguage(language);\n\t\t\t\ttdoc.setTranslation(1);\n\t\t\t\tXWikiDocument tdoc2 = (XWikiDocument) tdoc.clone();\n\t\t\t\tcontext.put(\"tdoc\", tdoc2);\n\t\t\t\tvcontext.put(\"tdoc\", tdoc2.newDocument(context));\n\t\t\t\tvcontext.put(\"cdoc\", vcontext.get(\"tdoc\"));\n\t\t\t\ttdoc2.readFromTemplate(((EditForm) form).getTemplate(), context);\n\t\t\t\ttdoc2.readFromForm((EditForm) form, context);\n                tdoc2.setAuthor(context.getUser());\n                if(tdoc2.isNew()){\n                    tdoc2.setCreator(context.getUser());\n                }\n\t\t\t}\n            // reconfirm edit (captcha) when jcaptcha is not correct\n            if ((context.get(\"recheckcaptcha\") != null) && ((Boolean)context.get(\"recheckcaptcha\")).booleanValue())\n                return \"captcha\";\n            else return \"preview\";\n\t}","commit_id":"2ab4268b5664b8b24453ff28b36b3079f3e63ea2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void renderXML(DocumentHandler out) throws PortalException\n  {\n    String xml;\n    Document xmlDoc;\n    sslUri = UtilitiesBean.fixURI(sslUri);\n\n    String key = getKey(); // Generate a key to lookup cache\n    SAXBufferImpl cache = (SAXBufferImpl)bufferCache.get(key);\n\n    // If there is cached content then write it out\n    if (cache == null)\n    {\n      cache = new SAXBufferImpl();\n\n      try\n      {\n        org.apache.xerces.parsers.DOMParser domParser = new org.apache.xerces.parsers.DOMParser();\n        org.jasig.portal.utils.DTDResolver dtdResolver = new org.jasig.portal.utils.DTDResolver();\n        domParser.setEntityResolver(dtdResolver);\n        domParser.parse(UtilitiesBean.fixURI(xmlUri));\n        xmlDoc = domParser.getDocument();\n      }\n      catch (IOException e)\n      {\n        throw new ResourceMissingException (xmlUri, \"\", e.getMessage());\n      }\n      catch (SAXException se)\n      {\n        throw new GeneralRenderingException(\"Problem parsing \" + xmlUri + \": \" + se);\n      }\n\n      runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n      cache.startBuffering();\n\n      try\n      {\n        if (xslUri != null)\n          XSLT.transform(xmlDoc, new URL(xslUri), cache, runtimeData);\n        else\n        {\n          if (xslTitle != null)\n            XSLT.transform(xmlDoc, new URL(sslUri), cache, runtimeData, xslTitle, media);\n          else\n            XSLT.transform(xmlDoc, new URL(sslUri), cache, runtimeData, media);\n        }\n\n        if (!developmentMode)\n        {\n          Logger.log(Logger.INFO, \"Caching output of CGenericXSLT for: \" + key);\n          bufferCache.put(key, cache);\n        }\n      }\n      catch (SAXException se)\n      {\n        throw new GeneralRenderingException(\"Problem performing the transformation:\" + se.toString());\n      }\n      catch (IOException ioe)\n      {\n        StringWriter sw = new StringWriter();\n        ioe.printStackTrace(new PrintWriter(sw));\n        sw.flush();\n        throw new GeneralRenderingException(sw.toString());\n      }\n    }\n    try\n    {\n      cache.outputBuffer(out);\n    }\n    catch (SAXException se)\n    {\n      throw new GeneralRenderingException(\"Problem retreiving output from cache:\" + se.toString());\n    }\n  }","id":106707,"modified_method":"public void renderXML(DocumentHandler out) throws PortalException\n  {\n    String xml;\n    Document xmlDoc;\n    sslUri = UtilitiesBean.fixURI(sslUri);\n\n    String key = getKey(); // Generate a key to lookup cache\n    SAXBufferImpl cache = (SAXBufferImpl)bufferCache.get(key);\n\n    // If there is cached content then write it out\n    if (cache == null)\n    {\n      cache = new SAXBufferImpl();\n\n      try\n      {\n        org.apache.xerces.parsers.DOMParser domParser = new org.apache.xerces.parsers.DOMParser();\n        org.jasig.portal.utils.DTDResolver dtdResolver = new org.jasig.portal.utils.DTDResolver();\n        domParser.setEntityResolver(dtdResolver);\n        domParser.parse(UtilitiesBean.fixURI(xmlUri));\n        xmlDoc = domParser.getDocument();\n      }\n      catch (IOException e)\n      {\n        throw new ResourceMissingException (xmlUri, \"\", e.getMessage());\n      }\n      catch (SAXException se)\n      {\n        throw new GeneralRenderingException(\"Problem parsing \" + xmlUri + \": \" + se);\n      }\n\n      runtimeData.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n      cache.startBuffering();\n\n      try\n      {\n        if (xslUri != null)\n          XSLT.transform(xmlDoc, new URL(xslUri), cache, runtimeData);\n        else\n        {\n          if (xslTitle != null)\n            XSLT.transform(xmlDoc, new URL(sslUri), cache, runtimeData, xslTitle, media);\n          else\n            XSLT.transform(xmlDoc, new URL(sslUri), cache, runtimeData, media);\n        }\n\n        if (cacheEnabled)\n        {\n          Logger.log(Logger.INFO, \"Caching output of CGenericXSLT for: \" + key);\n          bufferCache.put(key, cache);\n        }\n      }\n      catch (SAXException se)\n      {\n        throw new GeneralRenderingException(\"Problem performing the transformation:\" + se.toString());\n      }\n      catch (IOException ioe)\n      {\n        StringWriter sw = new StringWriter();\n        ioe.printStackTrace(new PrintWriter(sw));\n        sw.flush();\n        throw new GeneralRenderingException(sw.toString());\n      }\n    }\n    try\n    {\n      cache.outputBuffer(out);\n    }\n    catch (SAXException se)\n    {\n      throw new GeneralRenderingException(\"Problem retreiving output from cache:\" + se.toString());\n    }\n  }","commit_id":"ecd4c8d0d26be5703b6c4920ea6fcb65be4dbddf","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setStaticData (ChannelStaticData sd)\n  {\n    this.xmlUri = sd.getParameter(\"xml\");\n    this.sslUri = sd.getParameter(\"ssl\");\n  }","id":106708,"modified_method":"public void setStaticData (ChannelStaticData sd)\n  {\n    this.xmlUri = sd.getParameter(\"xmlUri\");\n    this.sslUri = sd.getParameter(\"sslUri\");\n    this.xslTitle = sd.getParameter(\"xslTitle\");\n    this.xslUri = sd.getParameter(\"xslUri\");\n  }","commit_id":"ecd4c8d0d26be5703b6c4920ea6fcb65be4dbddf","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        KubernetesClient kubernetes = getKubernetes();\n\n        String name = repoName;\n        if (Strings.isNotBlank(username)) {\n            name = username + \"-\" + name;\n        }\n        Map<String,String> labels = new HashMap<>();\n        labels.put(\"user\", username);\n        labels.put(\"repo\", repoName);\n\n        Map<String,String> annotations = new HashMap<>();\n        try {\n            String jenkinsUrl = kubernetes.getServiceURL(ServiceNames.JENKINS, kubernetes.getNamespace(), \"http\", true);\n\n            if (Strings.isNotBlank(jenkinsUrl)) {\n                if (Strings.isNotBlank(jenkinsMonitorView)) {\n                    annotations.put(\"fabric8.link.jenkins.monitor/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsMonitorView));\n                    annotations.put(\"fabric8.link.jenkins.monitor/label\", \"Monitor\");\n                }\n                if (Strings.isNotBlank(jenkinsPipelineView)) {\n                    annotations.put(\"fabric8.link.jenkins.pipeline/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsPipelineView));\n                    annotations.put(\"fabric8.link.jenkins.pipeline/label\", \"Pipeline\");\n                }\n                if (Strings.isNotBlank(jenkinsJob)) {\n                    annotations.put(\"fabric8.link.jenkins.job/url\", URLUtils.pathJoin(jenkinsUrl, \"/job\", jenkinsJob));\n                    annotations.put(\"fabric8.link.jenkins.job/label\", \"Job\");\n                }\n            }\n        } catch (Exception e) {\n            getLog().warn(\"Could not find the Jenkins URL!: \" + e, e);\n        }\n\n        String taigaLink = getTaigaProjectUrl();\n        if (Strings.isNotBlank(taigaLink)) {\n            annotations.put(\"fabric8.link.taiga/url\", taigaLink);\n            annotations.put(\"fabric8.link.taiga/label\", \"Issues\");\n        }\n\n        BuildConfig buildConfig = new BuildConfigBuilder().\n                withNewMetadata().withName(name).withLabels(labels).withAnnotations(annotations).endMetadata().\n                withNewSpec().\n                withNewSource().\n                withType(\"Git\").withNewGit().withUri(gitUrl).endGit().\n                endSource().\n                withNewStrategy().\n                withType(\"Docker\").withNewDockerStrategy().withNewFrom().withName(buildImageStream + \":\" + buildImageTag).endFrom().endDockerStrategy().\n                endStrategy().\n                addNewTrigger().\n                withType(\"github\").withNewGithub().withSecret(secret).endGithub().\n                endTrigger().\n                addNewTrigger().\n                withType(\"generic\").withNewGeneric().withSecret(secret).endGeneric().\n                endTrigger().\n                endSpec().\n                build();\n\n        Controller controller = createController();\n        controller.applyBuildConfig(buildConfig, \"maven\");\n        getLog().info(\"Created build configuration for \" + name + \" in namespace: \" + controller.getNamespace() + \" at \" + kubernetes.getAddress());\n\n        createJenkinsWebhook();\n        createTaigaWebhook();\n    }","id":106709,"modified_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        KubernetesClient kubernetes = getKubernetes();\n\n        String name = repoName;\n        if (Strings.isNotBlank(username)) {\n            name = username + \"-\" + name;\n        }\n        Map<String,String> labels = new HashMap<>();\n        labels.put(\"user\", username);\n        labels.put(\"repo\", repoName);\n\n        Map<String,String> annotations = new HashMap<>();\n        String jenkinsJobUrl = null;\n        try {\n            String jenkinsUrl = kubernetes.getServiceURL(ServiceNames.JENKINS, kubernetes.getNamespace(), \"http\", true);\n\n            if (Strings.isNotBlank(jenkinsUrl)) {\n                if (Strings.isNotBlank(jenkinsMonitorView)) {\n                    annotations.put(\"fabric8.link.jenkins.monitor/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsMonitorView));\n                    annotations.put(\"fabric8.link.jenkins.monitor/label\", \"Monitor\");\n                }\n                if (Strings.isNotBlank(jenkinsPipelineView)) {\n                    annotations.put(\"fabric8.link.jenkins.pipeline/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsPipelineView));\n                    annotations.put(\"fabric8.link.jenkins.pipeline/label\", \"Pipeline\");\n                }\n                if (Strings.isNotBlank(jenkinsJob)) {\n                    jenkinsJobUrl = URLUtils.pathJoin(jenkinsUrl, \"/job\", jenkinsJob);\n                    annotations.put(\"fabric8.link.jenkins.job/url\", jenkinsJobUrl);\n                    annotations.put(\"fabric8.link.jenkins.job/label\", \"Job\");\n                }\n            }\n        } catch (Exception e) {\n            getLog().warn(\"Could not find the Jenkins URL!: \" + e, e);\n        }\n\n        String taigaLink = getTaigaProjectUrl();\n        if (Strings.isNotBlank(taigaLink)) {\n            annotations.put(\"fabric8.link.taiga/url\", taigaLink);\n            annotations.put(\"fabric8.link.taiga/label\", \"Issues\");\n        }\n\n        BuildConfig buildConfig = new BuildConfigBuilder().\n                withNewMetadata().withName(name).withLabels(labels).withAnnotations(annotations).endMetadata().\n                withNewSpec().\n                withNewSource().\n                withType(\"Git\").withNewGit().withUri(gitUrl).endGit().\n                endSource().\n                withNewStrategy().\n                withType(\"Docker\").withNewDockerStrategy().withNewFrom().withName(buildImageStream + \":\" + buildImageTag).endFrom().endDockerStrategy().\n                endStrategy().\n                addNewTrigger().\n                withType(\"github\").withNewGithub().withSecret(secret).endGithub().\n                endTrigger().\n                addNewTrigger().\n                withType(\"generic\").withNewGeneric().withSecret(secret).endGeneric().\n                endTrigger().\n                endSpec().\n                build();\n\n        Controller controller = createController();\n        controller.applyBuildConfig(buildConfig, \"maven\");\n        getLog().info(\"Created build configuration for \" + name + \" in namespace: \" + controller.getNamespace() + \" at \" + kubernetes.getAddress());\n\n        createJenkinsWebhook(jenkinsJobUrl);\n        createTaigaWebhook();\n    }","commit_id":"25178995462a9e62b802c263de66dae99cbfbf71","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void createJenkinsWebhook() {\n        String jenkinsWebHook = jenkinsJob;\n        if (Strings.isNotBlank(jenkinsWebHook)) {\n            jenkinsWebHook = URLUtils.pathJoin(jenkinsJob, \"/build\");\n            createWebHook(jenkinsWebHook);\n        }\n    }","id":106710,"modified_method":"protected void createJenkinsWebhook(String jenkinsJobUrl) {\n        if (Strings.isNotBlank(jenkinsJobUrl)) {\n            String jenkinsWebHook = URLUtils.pathJoin(jenkinsJobUrl, \"/build\");\n            createWebHook(jenkinsWebHook);\n        }\n    }","commit_id":"25178995462a9e62b802c263de66dae99cbfbf71","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * For a given project this operation will try to update the associated DevOps resources\n     * @throws Exception\n     */\n    public void execute() throws Exception {\n        loadConfigFile();\n        KubernetesClient kubernetes = getKubernetes();\n\n        String name = repoName;\n        if (Strings.isNotBlank(username)) {\n            name = username + \"-\" + name;\n        }\n        Map<String, String> labels = new HashMap<>();\n        labels.put(\"user\", username);\n        labels.put(\"repo\", repoName);\n\n        TaigaClient taiga = null;\n        ProjectDTO taigaProject = null;\n        try {\n            taiga = createTaiga();\n            taigaProject = createTaigaProject(taiga);\n        } catch (Exception e) {\n            getLog().error(\"Failed to load or lazily create the Taiga project: \" + e, e);\n        }\n\n        LetsChatClient letschat = null;\n        try {\n            letschat = createLetsChat();\n        } catch (Exception e) {\n            getLog().error(\"Failed to load or lazily create the LetsChat client: \" + e, e);\n        }\n\n        Map<String, String> annotations = new HashMap<>();\n        String jenkinsJobUrl = null;\n        try {\n            String jenkinsUrl = kubernetes.getServiceURL(ServiceNames.JENKINS, kubernetes.getNamespace(), \"http\", true);\n\n            if (Strings.isNotBlank(jenkinsUrl)) {\n                if (Strings.isNotBlank(jenkinsMonitorView)) {\n                    annotations.put(\"fabric8.link.jenkins.monitor/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsMonitorView));\n                    annotations.put(\"fabric8.link.jenkins.monitor/label\", \"Monitor\");\n                }\n                if (Strings.isNotBlank(jenkinsPipelineView)) {\n                    annotations.put(\"fabric8.link.jenkins.pipeline/url\", URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsPipelineView));\n                    annotations.put(\"fabric8.link.jenkins.pipeline/label\", \"Pipeline\");\n                }\n                if (Strings.isNotBlank(jenkinsJob)) {\n                    jenkinsJobUrl = URLUtils.pathJoin(jenkinsUrl, \"/job\", jenkinsJob);\n                    annotations.put(\"fabric8.link.jenkins.job/url\", jenkinsJobUrl);\n                    annotations.put(\"fabric8.link.jenkins.job/label\", \"Job\");\n                }\n            }\n        } catch (Exception e) {\n            getLog().warn(\"Could not find the Jenkins URL!: \" + e, e);\n        }\n\n        String taigaLink = getProjectPageLink(taiga, taigaProject, this.taigaProjectLinkPage);\n        if (Strings.isNotBlank(taigaLink)) {\n            annotations.put(\"fabric8.link.taiga/url\", taigaLink);\n            annotations.put(\"fabric8.link.taiga/label\", taigaProjectLinkLabel);\n        }\n        String taigaTeamLink = getProjectPageLink(taiga, taigaProject, this.taigaTeamLinkPage);\n        if (Strings.isNotBlank(taigaTeamLink)) {\n            annotations.put(\"fabric8.link.taiga.team/url\", taigaTeamLink);\n            annotations.put(\"fabric8.link.taiga.team/label\", taigaTeamLinkLabel);\n        }\n\n        String chatRoomLink = getChatRoomLink(letschat);\n        if (Strings.isNotBlank(chatRoomLink)) {\n            annotations.put(\"fabric8.link.letschat.room/url\", chatRoomLink);\n            annotations.put(\"fabric8.link.letschat.room/label\", letschatRoomLinkLabel);\n        }\n\n        BuildConfigFluent<BuildConfigBuilder>.SpecNested<BuildConfigBuilder> specBuilder = new BuildConfigBuilder().\n                withNewMetadata().withName(name).withLabels(labels).withAnnotations(annotations).endMetadata().\n                withNewSpec();\n\n        if (Strings.isNotBlank(gitUrl)) {\n            specBuilder = specBuilder.withNewSource().\n                    withType(\"Git\").withNewGit().withUri(gitUrl).endGit().\n                    endSource();\n        }\n        if (Strings.isNotBlank(buildImageStream) && Strings.isNotBlank(buildImageTag)) {\n            specBuilder = specBuilder.\n                    withNewStrategy().\n                    withType(\"Docker\").withNewDockerStrategy().withNewFrom().withName(buildImageStream + \":\" + buildImageTag).endFrom().endDockerStrategy().\n                    endStrategy();\n        }\n        BuildConfig buildConfig = specBuilder.\n                addNewTrigger().\n                withType(\"github\").withNewGithub().withSecret(secret).endGithub().\n                endTrigger().\n                addNewTrigger().\n                withType(\"generic\").withNewGeneric().withSecret(secret).endGeneric().\n                endTrigger().\n                endSpec().\n                build();\n\n        Controller controller = createController();\n        try {\n            controller.applyBuildConfig(buildConfig, \"maven\");\n            getLog().info(\"Created build configuration for \" + name + \" in namespace: \" + controller.getNamespace() + \" at \" + kubernetes.getAddress());\n        } catch (Exception e) {\n            getLog().error(\"Failed to create BuildConfig for \" + KubernetesHelper.toJson(buildConfig) + \". \" + e, e);\n        }\n        createJenkinsWebhook(jenkinsJobUrl);\n        createTaigaWebhook(taiga, taigaProject);\n    }","id":106711,"modified_method":"/**\n     * For a given project this operation will try to update the associated DevOps resources\n     * @throws Exception\n     */\n    public void execute() throws Exception {\n        loadConfigFile();\n        KubernetesClient kubernetes = getKubernetes();\n\n        String name = repoName;\n        if (Strings.isNotBlank(username)) {\n            name = username + \"-\" + name;\n        }\n        Map<String, String> labels = new HashMap<>();\n        labels.put(\"user\", username);\n        labels.put(\"repo\", repoName);\n\n        TaigaClient taiga = null;\n        ProjectDTO taigaProject = null;\n        try {\n            taiga = createTaiga();\n            taigaProject = createTaigaProject(taiga);\n        } catch (Exception e) {\n            getLog().error(\"Failed to load or lazily create the Taiga project: \" + e, e);\n        }\n\n        LetsChatClient letschat = null;\n        try {\n            letschat = createLetsChat();\n        } catch (Exception e) {\n            getLog().error(\"Failed to load or lazily create the LetsChat client: \" + e, e);\n        }\n\n        Map<String, String> annotations = new HashMap<>();\n        String jenkinsJobUrl = null;\n        try {\n            String jenkinsUrl = kubernetes.getServiceURL(ServiceNames.JENKINS, kubernetes.getNamespace(), \"http\", true);\n\n            if (Strings.isNotBlank(jenkinsUrl)) {\n                if (Strings.isNotBlank(jenkinsMonitorView)) {\n                    String url = URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsMonitorView);\n                    annotations.put(\"fabric8.link.jenkins.monitor/url\", url);\n                    String label = \"Monitor\";\n                    annotations.put(\"fabric8.link.jenkins.monitor/label\", label);\n                    addLink(label, url);\n                }\n                if (Strings.isNotBlank(jenkinsPipelineView)) {\n                    String url = URLUtils.pathJoin(jenkinsUrl, \"/view\", jenkinsPipelineView);\n                    annotations.put(\"fabric8.link.jenkins.pipeline/url\", url);\n                    String label = \"Pipeline\";\n                    annotations.put(\"fabric8.link.jenkins.pipeline/label\", label);\n                    addLink(label, url);\n                }\n                if (Strings.isNotBlank(jenkinsJob)) {\n                    jenkinsJobUrl = URLUtils.pathJoin(jenkinsUrl, \"/job\", jenkinsJob);\n                    annotations.put(\"fabric8.link.jenkins.job/url\", jenkinsJobUrl);\n                    String label = \"Job\";\n                    annotations.put(\"fabric8.link.jenkins.job/label\", label);\n                    addLink(label, jenkinsJobUrl);\n                }\n            }\n        } catch (Exception e) {\n            getLog().warn(\"Could not find the Jenkins URL!: \" + e, e);\n        }\n\n        String taigaLink = getProjectPageLink(taiga, taigaProject, this.taigaProjectLinkPage);\n        if (Strings.isNotBlank(taigaLink)) {\n            annotations.put(\"fabric8.link.taiga/url\", taigaLink);\n            annotations.put(\"fabric8.link.taiga/label\", taigaProjectLinkLabel);\n            addLink(taigaProjectLinkLabel, taigaLink);\n        }\n        String taigaTeamLink = getProjectPageLink(taiga, taigaProject, this.taigaTeamLinkPage);\n        if (Strings.isNotBlank(taigaTeamLink)) {\n            annotations.put(\"fabric8.link.taiga.team/url\", taigaTeamLink);\n            annotations.put(\"fabric8.link.taiga.team/label\", taigaTeamLinkLabel);\n            addLink(taigaTeamLinkLabel, taigaTeamLink);\n        }\n\n        String chatRoomLink = getChatRoomLink(letschat);\n        if (Strings.isNotBlank(chatRoomLink)) {\n            annotations.put(\"fabric8.link.letschat.room/url\", chatRoomLink);\n            annotations.put(\"fabric8.link.letschat.room/label\", letschatRoomLinkLabel);\n            addLink(letschatRoomLinkLabel, chatRoomLink);\n        }\n\n        BuildConfigFluent<BuildConfigBuilder>.SpecNested<BuildConfigBuilder> specBuilder = new BuildConfigBuilder().\n                withNewMetadata().withName(name).withLabels(labels).withAnnotations(annotations).endMetadata().\n                withNewSpec();\n\n        if (Strings.isNotBlank(gitUrl)) {\n            specBuilder = specBuilder.withNewSource().\n                    withType(\"Git\").withNewGit().withUri(gitUrl).endGit().\n                    endSource();\n        }\n        if (Strings.isNotBlank(buildImageStream) && Strings.isNotBlank(buildImageTag)) {\n            specBuilder = specBuilder.\n                    withNewStrategy().\n                    withType(\"Docker\").withNewDockerStrategy().withNewFrom().withName(buildImageStream + \":\" + buildImageTag).endFrom().endDockerStrategy().\n                    endStrategy();\n        }\n        BuildConfig buildConfig = specBuilder.\n                addNewTrigger().\n                withType(\"github\").withNewGithub().withSecret(secret).endGithub().\n                endTrigger().\n                addNewTrigger().\n                withType(\"generic\").withNewGeneric().withSecret(secret).endGeneric().\n                endTrigger().\n                endSpec().\n                build();\n\n        Controller controller = createController();\n        try {\n            controller.applyBuildConfig(buildConfig, \"maven\");\n            getLog().info(\"Created build configuration for \" + name + \" in namespace: \" + controller.getNamespace() + \" at \" + kubernetes.getAddress());\n        } catch (Exception e) {\n            getLog().error(\"Failed to create BuildConfig for \" + KubernetesHelper.toJson(buildConfig) + \". \" + e, e);\n        }\n        createJenkinsWebhook(jenkinsJobUrl);\n        createTaigaWebhook(taiga, taigaProject);\n        if (modifiedConfig) {\n            if (basedir == null) {\n                getLog().error(\"Could not save updated \" + ProjectConfigs.FILE_NAME + \" due to missing basedir\");\n            } else {\n                try {\n                    ProjectConfigs.saveToFolder(basedir, projectConfig, true);\n                    getLog().info(\"Updated \" + ProjectConfigs.FILE_NAME);\n                } catch (IOException e) {\n                    getLog().error(\"Could not save updated \" + ProjectConfigs.FILE_NAME + \": \" + e, e);\n                }\n            }\n        }\n    }","commit_id":"408e1dc36523c9cdddeff95b6de0085499e7999f","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testGenerateYaml() throws Exception {\n        ProjectConfig config = new ProjectConfig();\n        config.addFlow(\"io.fabric8.flow.maven.Deploy.groovy\");\n        config.setChatRoom(\"myroom\");\n        config.setCodeReview(true);\n        config.setIssueProjectName(\"THING\");\n\n        String yaml = ProjectConfigs.toYaml(config);\n        System.out.println(\"Config: \" + config + \" is yaml: \" + yaml);\n    }","id":106712,"modified_method":"@Test\n    public void testGenerateYaml() throws Exception {\n        ProjectConfig config = new ProjectConfig();\n        config.addFlow(\"io.fabric8.flow.maven.Deploy.groovy\");\n        config.setChatRoom(\"myroom\");\n        config.setCodeReview(true);\n        config.setIssueProjectName(\"THING\");\n        config.addLink(\"Room\", \"http://letschat.vagrant.f8/rooms/foo\");\n        config.addLink(\"Jenkins\", \"http://jenkins.vagrant.f8/builds/foo\");\n\n        String yaml = ProjectConfigs.toYaml(config);\n        System.out.println(\"Config: \" + config + \" is yaml: \" + yaml);\n    }","commit_id":"408e1dc36523c9cdddeff95b6de0085499e7999f","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@BeforeClass\n    public static void setUpClass() throws IOException {\n        MOCK.expectAndReturnAsJson(\"/api/v1/namespaces/arquillian\", 200, new NamespaceBuilder()\n                .withNewMetadata()\n                .withName(\"arquillian\")\n                .and().build());\n\n        MOCK.expectAndReturnAsJson(\"/api/v1/namespaces/arquillian/replicationcontrollers\", 200, new ReplicationControllerListBuilder()\n                .addNewItem()\n                .withNewMetadata()\n                .withName(\"repl1\")\n                .endMetadata()\n                .endItem()\n                .build());\n\n\n        MOCK.expectAndReturnAsJson(\"/api/v1/namespaces/arquillian/pods\", 200, new PodListBuilder().addNewItem()\n                .withNewMetadata()\n                .withName(\"pod1\")\n                .endMetadata()\n                .endItem()\n                .build());\n\n        MOCK.expectAndReturnAsJson(\"/api/v1/namespaces/arquillian/services\", 200, new ServiceListBuilder()\n                .addNewItem()\n                .withNewMetadata()\n                .withName(\"service1\")\n                .endMetadata()\n                .endItem()\n                .build());\n\n\n        MOCK.init();\n\n        String masterUrl = \"http://localhost:\" + MOCK.getServer().getPort();\n        System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY, masterUrl);\n        System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY, \"arquillian\");\n        System.setProperty(Constants.NAMESPACE_TO_USE, \"arquillian\");\n        System.setProperty(Constants.NAMESPACE_LAZY_CREATE_ENABLED, \"arquillian\");\n    }","id":106713,"modified_method":"@BeforeClass\n    public static void setUpClass() throws IOException {\n        MOCK.expect().withPath(\"/api/v1/namespaces/arquillian\").andReturn(200, new NamespaceBuilder()\n                .withNewMetadata()\n                .withName(\"arquillian\")\n                .and().build()).always();\n\n        MOCK.expect().withPath(\"/api/v1/namespaces/arquillian/replicationcontrollers\").andReturn(200, new ReplicationControllerListBuilder()\n                .addNewItem()\n                .withNewMetadata()\n                .withName(\"repl1\")\n                .endMetadata()\n                .endItem()\n                .build()).always();\n\n\n        MOCK.expect().withPath(\"/api/v1/namespaces/arquillian/pods\").andReturn(200, new PodListBuilder().addNewItem()\n                .withNewMetadata()\n                .withName(\"pod1\")\n                .endMetadata()\n                .endItem()\n                .build()).always();\n\n        MOCK.expect().withPath(\"/api/v1/namespaces/arquillian/services\").andReturn(200, new ServiceListBuilder()\n                .addNewItem()\n                .withNewMetadata()\n                .withName(\"service1\")\n                .endMetadata()\n                .endItem()\n                .build()).always();\n\n\n        MOCK.init();\n\n        String masterUrl = \"http://localhost:\" + MOCK.getServer().getPort();\n        System.setProperty(Config.KUBERNETES_MASTER_SYSTEM_PROPERTY, masterUrl);\n        System.setProperty(Config.KUBERNETES_NAMESPACE_SYSTEM_PROPERTY, \"arquillian\");\n        System.setProperty(Constants.NAMESPACE_TO_USE, \"arquillian\");\n        System.setProperty(Constants.NAMESPACE_LAZY_CREATE_ENABLED, \"arquillian\");\n    }","commit_id":"ff29ee98d22d36d024c29a653cc58e11aac696d8","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = StringUtil.replace(\n\t\t\t\tctx.getServletContextName(), StringPool.SPACE,\n\t\t\t\tStringPool.UNDERLINE);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-layout-templates.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Registering layout templates for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList layoutTemplateIds = LayoutTemplateLocalUtil.init(\n\t\t\t\tservletContextName, ctx, xmls);\n\n\t\t\t_vars.put(servletContextName, layoutTemplateIds);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Layout templates for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering layout templates for \" + servletContextName,\n\t\t\t\te);\n\t\t}\n\t}","id":106714,"modified_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = PortalUtil.getJsSafePortletName(\n\t\t\t\tctx.getServletContextName());\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-layout-templates.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Registering layout templates for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList layoutTemplateIds = LayoutTemplateLocalUtil.init(\n\t\t\t\tservletContextName, ctx, xmls);\n\n\t\t\t_vars.put(servletContextName, layoutTemplateIds);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Layout templates for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering layout templates for \" + servletContextName,\n\t\t\t\te);\n\t\t}\n\t}","commit_id":"28fe851332ee2770e1776a0f0827188b13e3061a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\n\t\t\t// Servlet context\n\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = StringUtil.replace(\n\t\t\t\tctx.getServletContextName(), StringPool.SPACE,\n\t\t\t\tStringPool.UNDERLINE);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\t// Company ids\n\n\t\t\tString[] companyIds = StringUtil.split(\n\t\t\t\tctx.getInitParameter(\"company_id\"));\n\n\t\t\tif ((companyIds.length == 1) && (companyIds[0].equals(\"*\"))) {\n\t\t\t\tcompanyIds = PortalInstances.getCompanyIds();\n\t\t\t}\n\n\t\t\t// Initialize portlets\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\"/WEB-INF/portlet.xml\")),\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-portlet.xml\")),\n\t\t\t\tHttp.URLtoString(ctx.getResource(\"/WEB-INF/web.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering portlets for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList portlets = PortletLocalServiceUtil.initWAR(\n\t\t\t\tservletContextName, xmls);\n\n\t\t\t// Class loader\n\n\t\t\tClassLoader portletClassLoader = event.getContextClassLoader();\n\n\t\t\tctx.setAttribute(\n\t\t\t\tPortletServlet.PORTLET_CLASS_LOADER, portletClassLoader);\n\n\t\t\t// Portlet context wrapper\n\n\t\t\tboolean strutsBridges = false;\n\n\t\t\tIterator itr1 = portlets.iterator();\n\n\t\t\twhile (itr1.hasNext()) {\n\t\t\t\tPortlet portlet = (Portlet)itr1.next();\n\n\t\t\t\tClass portletClass = portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getPortletClass());\n\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\t(javax.portlet.Portlet)portletClass.newInstance();\n\n\t\t\t\tif (ClassUtil.isSubclass(portletClass,\n\t\t\t\t\tStrutsPortlet.class.getName())) {\n\n\t\t\t\t\tstrutsBridges = true;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexerInstance = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getIndexerClass())) {\n\t\t\t\t\tindexerInstance = (Indexer)portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getIndexerClass()).newInstance();\n\t\t\t\t}\n\n\t\t\t\tScheduler schedulerInstance = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getSchedulerClass())) {\n\t\t\t\t\tschedulerInstance = (Scheduler)portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getSchedulerClass()).newInstance();\n\t\t\t\t}\n\n\t\t\t\tPreferencesValidator prefsValidator = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getPreferencesValidator())) {\n\t\t\t\t\tprefsValidator =\n\t\t\t\t\t\t(PreferencesValidator)portletClassLoader.loadClass(\n\t\t\t\t\t\t\tportlet.getPreferencesValidator()).newInstance();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (GetterUtil.getBoolean(PropsUtil.get(\n\t\t\t\t\t\t\t\tPropsUtil.PREFERENCE_VALIDATE_ON_STARTUP))) {\n\n\t\t\t\t\t\t\tprefsValidator.validate(\n\t\t\t\t\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\t\t\t\t\tportlet.getDefaultPreferences()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e1) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Portlet with the name \" + portlet.getPortletId() +\n\t\t\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMap resourceBundles = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getResourceBundle())) {\n\t\t\t\t\tresourceBundles = CollectionFactory.getHashMap();\n\n\t\t\t\t\tIterator itr2 = portlet.getSupportedLocales().iterator();\n\n\t\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\t\tString supportedLocale = (String)itr2.next();\n\n\t\t\t\t\t\tLocale locale = new Locale(supportedLocale);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tResourceBundle resourceBundle =\n\t\t\t\t\t\t\t\tResourceBundle.getBundle(\n\t\t\t\t\t\t\t\t\tportlet.getResourceBundle(), locale,\n\t\t\t\t\t\t\t\t\tportletClassLoader);\n\n\t\t\t\t\t\t\tresourceBundles.put(\n\t\t\t\t\t\t\t\tlocale.getLanguage(), resourceBundle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (MissingResourceException mre) {\n\t\t\t\t\t\t\t_log.warn(mre.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMap customUserAttributes = CollectionFactory.getHashMap();\n\n\t\t\t\tIterator itr2 =\n\t\t\t\t\tportlet.getCustomUserAttributes().entrySet().iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry)itr2.next();\n\n\t\t\t\t\tString attrCustomClass = (String)entry.getValue();\n\n\t\t\t\t\tcustomUserAttributes.put(\n\t\t\t\t\t\tattrCustomClass,\n\t\t\t\t\t\tportletClassLoader.loadClass(\n\t\t\t\t\t\t\tattrCustomClass).newInstance());\n\t\t\t\t}\n\n\t\t\t\tPortletContextWrapper pcw = new PortletContextWrapper(\n\t\t\t\t\tportlet.getPortletId(), ctx, portletInstance,\n\t\t\t\t\tindexerInstance, schedulerInstance, prefsValidator,\n\t\t\t\t\tresourceBundles, customUserAttributes);\n\n\t\t\t\tPortletContextPool.put(portlet.getPortletId(), pcw);\n\t\t\t}\n\n\t\t\t// Struts bridges\n\n\t\t\tif (strutsBridges) {\n\t\t\t\tctx.setAttribute(\n\t\t\t\t\tServletContextProvider.STRUTS_BRIDGES_CONTEXT_PROVIDER,\n\t\t\t\t\tnew LiferayServletContextProvider());\n\t\t\t}\n\n\t\t\t// Portlet display\n\n\t\t\tString xml = Http.URLtoString(ctx.getResource(\n\t\t\t\t\"/WEB-INF/liferay-display.xml\"));\n\n\t\t\tPortletCategory newPortletCategory =\n\t\t\t\tPortletLocalServiceUtil.getWARDisplay(servletContextName, xml);\n\n\t\t\tfor (int i = 0; i < companyIds.length; i++) {\n\t\t\t\tString companyId = companyIds[i];\n\n\t\t\t\tPortletCategory portletCategory =\n\t\t\t\t\t(PortletCategory)WebAppPool.get(\n\t\t\t\t\t\tcompanyId, WebKeys.PORTLET_CATEGORY);\n\n\t\t\t\tif (portletCategory != null) {\n\t\t\t\t\tportletCategory.merge(newPortletCategory);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Unable to register portlet for company \" + companyId +\n\t\t\t\t\t\t\t\" because it does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Variables\n\n\t\t\t_vars.put(\n\t\t\t\tservletContextName, new ObjectValuePair(companyIds, portlets));\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Portlets for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering portlets for \" + servletContextName, e2);\n\t\t}\n\t}","id":106715,"modified_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\n\t\t\t// Servlet context\n\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = PortalUtil.getJsSafePortletName(\n\t\t\t\tctx.getServletContextName());\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\t// Company ids\n\n\t\t\tString[] companyIds = StringUtil.split(\n\t\t\t\tctx.getInitParameter(\"company_id\"));\n\n\t\t\tif ((companyIds.length == 1) && (companyIds[0].equals(\"*\"))) {\n\t\t\t\tcompanyIds = PortalInstances.getCompanyIds();\n\t\t\t}\n\n\t\t\t// Initialize portlets\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\"/WEB-INF/portlet.xml\")),\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-portlet.xml\")),\n\t\t\t\tHttp.URLtoString(ctx.getResource(\"/WEB-INF/web.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering portlets for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList portlets = PortletLocalServiceUtil.initWAR(\n\t\t\t\tservletContextName, xmls);\n\n\t\t\t// Class loader\n\n\t\t\tClassLoader portletClassLoader = event.getContextClassLoader();\n\n\t\t\tctx.setAttribute(\n\t\t\t\tPortletServlet.PORTLET_CLASS_LOADER, portletClassLoader);\n\n\t\t\t// Portlet context wrapper\n\n\t\t\tboolean strutsBridges = false;\n\n\t\t\tIterator itr1 = portlets.iterator();\n\n\t\t\twhile (itr1.hasNext()) {\n\t\t\t\tPortlet portlet = (Portlet)itr1.next();\n\n\t\t\t\tClass portletClass = portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getPortletClass());\n\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\t(javax.portlet.Portlet)portletClass.newInstance();\n\n\t\t\t\tif (ClassUtil.isSubclass(portletClass,\n\t\t\t\t\tStrutsPortlet.class.getName())) {\n\n\t\t\t\t\tstrutsBridges = true;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexerInstance = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getIndexerClass())) {\n\t\t\t\t\tindexerInstance = (Indexer)portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getIndexerClass()).newInstance();\n\t\t\t\t}\n\n\t\t\t\tScheduler schedulerInstance = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getSchedulerClass())) {\n\t\t\t\t\tschedulerInstance = (Scheduler)portletClassLoader.loadClass(\n\t\t\t\t\t\tportlet.getSchedulerClass()).newInstance();\n\t\t\t\t}\n\n\t\t\t\tPreferencesValidator prefsValidator = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getPreferencesValidator())) {\n\t\t\t\t\tprefsValidator =\n\t\t\t\t\t\t(PreferencesValidator)portletClassLoader.loadClass(\n\t\t\t\t\t\t\tportlet.getPreferencesValidator()).newInstance();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (GetterUtil.getBoolean(PropsUtil.get(\n\t\t\t\t\t\t\t\tPropsUtil.PREFERENCE_VALIDATE_ON_STARTUP))) {\n\n\t\t\t\t\t\t\tprefsValidator.validate(\n\t\t\t\t\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\t\t\t\t\tportlet.getDefaultPreferences()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e1) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Portlet with the name \" + portlet.getPortletId() +\n\t\t\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMap resourceBundles = null;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getResourceBundle())) {\n\t\t\t\t\tresourceBundles = CollectionFactory.getHashMap();\n\n\t\t\t\t\tIterator itr2 = portlet.getSupportedLocales().iterator();\n\n\t\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\t\tString supportedLocale = (String)itr2.next();\n\n\t\t\t\t\t\tLocale locale = new Locale(supportedLocale);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tResourceBundle resourceBundle =\n\t\t\t\t\t\t\t\tResourceBundle.getBundle(\n\t\t\t\t\t\t\t\t\tportlet.getResourceBundle(), locale,\n\t\t\t\t\t\t\t\t\tportletClassLoader);\n\n\t\t\t\t\t\t\tresourceBundles.put(\n\t\t\t\t\t\t\t\tlocale.getLanguage(), resourceBundle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (MissingResourceException mre) {\n\t\t\t\t\t\t\t_log.warn(mre.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMap customUserAttributes = CollectionFactory.getHashMap();\n\n\t\t\t\tIterator itr2 =\n\t\t\t\t\tportlet.getCustomUserAttributes().entrySet().iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry)itr2.next();\n\n\t\t\t\t\tString attrCustomClass = (String)entry.getValue();\n\n\t\t\t\t\tcustomUserAttributes.put(\n\t\t\t\t\t\tattrCustomClass,\n\t\t\t\t\t\tportletClassLoader.loadClass(\n\t\t\t\t\t\t\tattrCustomClass).newInstance());\n\t\t\t\t}\n\n\t\t\t\tPortletContextWrapper pcw = new PortletContextWrapper(\n\t\t\t\t\tportlet.getPortletId(), ctx, portletInstance,\n\t\t\t\t\tindexerInstance, schedulerInstance, prefsValidator,\n\t\t\t\t\tresourceBundles, customUserAttributes);\n\n\t\t\t\tPortletContextPool.put(portlet.getPortletId(), pcw);\n\t\t\t}\n\n\t\t\t// Struts bridges\n\n\t\t\tif (strutsBridges) {\n\t\t\t\tctx.setAttribute(\n\t\t\t\t\tServletContextProvider.STRUTS_BRIDGES_CONTEXT_PROVIDER,\n\t\t\t\t\tnew LiferayServletContextProvider());\n\t\t\t}\n\n\t\t\t// Portlet display\n\n\t\t\tString xml = Http.URLtoString(ctx.getResource(\n\t\t\t\t\"/WEB-INF/liferay-display.xml\"));\n\n\t\t\tPortletCategory newPortletCategory =\n\t\t\t\tPortletLocalServiceUtil.getWARDisplay(servletContextName, xml);\n\n\t\t\tfor (int i = 0; i < companyIds.length; i++) {\n\t\t\t\tString companyId = companyIds[i];\n\n\t\t\t\tPortletCategory portletCategory =\n\t\t\t\t\t(PortletCategory)WebAppPool.get(\n\t\t\t\t\t\tcompanyId, WebKeys.PORTLET_CATEGORY);\n\n\t\t\t\tif (portletCategory != null) {\n\t\t\t\t\tportletCategory.merge(newPortletCategory);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Unable to register portlet for company \" + companyId +\n\t\t\t\t\t\t\t\" because it does not exist\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Variables\n\n\t\t\t_vars.put(\n\t\t\t\tservletContextName, new ObjectValuePair(companyIds, portlets));\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Portlets for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering portlets for \" + servletContextName, e2);\n\t\t}\n\t}","commit_id":"28fe851332ee2770e1776a0f0827188b13e3061a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = StringUtil.replace(\n\t\t\t\tctx.getServletContextName(), StringPool.SPACE,\n\t\t\t\tStringPool.UNDERLINE);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-look-and-feel.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering themes for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList themeIds = ThemeLocalUtil.init(servletContextName, ctx, xmls);\n\n\t\t\tVelocityContextPool.put(servletContextName, ctx);\n\n\t\t\t_vars.put(servletContextName, themeIds);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Themes for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering themes for \" + servletContextName, e);\n\t\t}\n\t}","id":106716,"modified_method":"public void invokeDeploy(HotDeployEvent event) throws HotDeployException {\n\t\tString servletContextName = null;\n\n\t\ttry {\n\t\t\tServletContext ctx = event.getServletContext();\n\n\t\t\tservletContextName = PortalUtil.getJsSafePortletName(\n\t\t\t\tctx.getServletContextName());\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t\t}\n\n\t\t\tString[] xmls = new String[] {\n\t\t\t\tHttp.URLtoString(ctx.getResource(\n\t\t\t\t\t\"/WEB-INF/liferay-look-and-feel.xml\"))\n\t\t\t};\n\n\t\t\tif (xmls[0] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering themes for \" + servletContextName);\n\t\t\t}\n\n\t\t\tList themeIds = ThemeLocalUtil.init(servletContextName, ctx, xmls);\n\n\t\t\tVelocityContextPool.put(servletContextName, ctx);\n\n\t\t\t_vars.put(servletContextName, themeIds);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Themes for \" + servletContextName +\n\t\t\t\t\t\t\" registered successfully\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new HotDeployException(\n\t\t\t\t\"Error registering themes for \" + servletContextName, e);\n\t\t}\n\t}","commit_id":"28fe851332ee2770e1776a0f0827188b13e3061a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getJsSafePortletName(String portletName) {\n\t\tString jsSafePortletName =\n\t\t\tStringUtil.replace(portletName, StringPool.SPACE, StringPool.BLANK);\n\n\t\treturn jsSafePortletName;\n\t}","id":106717,"modified_method":"public static String getJsSafePortletName(String portletName) {\n\t\tString jsSafePortletName =\n\t\t\tStringUtil.replace(\n\t\t\t\tportletName,\n\t\t\t\tnew String[] {\n\t\t\t\t\tStringPool.SPACE, StringPool.DASH\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tStringPool.BLANK, StringPool.BLANK\n\t\t\t\t});\n\n\t\treturn jsSafePortletName;\n\t}","commit_id":"28fe851332ee2770e1776a0f0827188b13e3061a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tif (!GetterUtil.getBoolean(PropsUtil.get(PropsUtil.TCK_URL))) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\n\t\t\tString[] portletNames = req.getParameterValues(\"portletName\");\n\n\t\t\tfor (int i = 0; i < portletNames.length; i++) {\n\t\t\t\tString[] nameAndWar = StringUtil.split(portletNames[i], \"/\");\n\n\t\t\t\tportletNames[i] =\n\t\t\t\t\tnameAndWar[1] + Portlet.WAR_SEPARATOR + nameAndWar[0];\n\t\t\t}\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.addLayout(\n\t\t\t\t\"1\", \"liferay.com.1\", false, Layout.DEFAULT_PARENT_LAYOUT_ID,\n\t\t\t\t\"TCKAction\", Layout.TYPE_PORTLET, false, StringPool.BLANK);\n\n\t\t\tLayoutTypePortlet layoutType =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tfor (int i = 0; i < portletNames.length; i++) {\n\t\t\t\tlayoutType.addPortletId(\"liferay.com.1\", portletNames[i]);\n\t\t\t}\n\n\t\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\t\tlayout.getLayoutId(), layout.getOwnerId(),\n\t\t\t\tlayout.getTypeSettings());\n\n\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.FORWARD_URL,\n\t\t\t\tmainPath + \"/portal/layout?p_l_id=\" + layout.getPlid());\n\n\t\t\treturn mapping.findForward(Constants.COMMON_FORWARD_JSP);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\treturn mapping.findForward(Constants.COMMON_ERROR);\n\t\t}\n\t}","id":106718,"modified_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tif (!GetterUtil.getBoolean(PropsUtil.get(PropsUtil.TCK_URL))) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\n\t\t\tString[] portletNames = req.getParameterValues(\"portletName\");\n\n\t\t\tfor (int i = 0; i < portletNames.length; i++) {\n\t\t\t\tString[] nameAndWar = StringUtil.split(portletNames[i], \"/\");\n\n\t\t\t\tportletNames[i] = PortalUtil.getJsSafePortletName(\n\t\t\t\t\tnameAndWar[1] + Portlet.WAR_SEPARATOR + nameAndWar[0]);\n\t\t\t}\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.addLayout(\n\t\t\t\t\"1\", \"liferay.com.1\", false, Layout.DEFAULT_PARENT_LAYOUT_ID,\n\t\t\t\t\"TCKAction\", Layout.TYPE_PORTLET, false, StringPool.BLANK);\n\n\t\t\tLayoutTypePortlet layoutType =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tfor (int i = 0; i < portletNames.length; i++) {\n\t\t\t\tlayoutType.addPortletId(\"liferay.com.1\", portletNames[i]);\n\t\t\t}\n\n\t\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\t\tlayout.getLayoutId(), layout.getOwnerId(),\n\t\t\t\tlayout.getTypeSettings());\n\n\t\t\tString mainPath = (String)req.getAttribute(WebKeys.MAIN_PATH);\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.FORWARD_URL,\n\t\t\t\tmainPath + \"/portal/layout?p_l_id=\" + layout.getPlid());\n\n\t\t\treturn mapping.findForward(Constants.COMMON_FORWARD_JSP);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\treturn mapping.findForward(Constants.COMMON_ERROR);\n\t\t}\n\t}","commit_id":"28fe851332ee2770e1776a0f0827188b13e3061a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  private static TextAttributesKey getAttributeByType(final @Nullable DartComponentType type, boolean isStatic, boolean isTopLevel) {\n    if (type == null) {\n      return null;\n    }\n    switch (type) {\n      case CLASS:\n      case TYPEDEF:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_CLASS);\n      case PARAMETER:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_PARAMETER);\n      case FUNCTION:\n        if (isTopLevel) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_TOP_LEVEL_FUNCTION_DECLARATION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_FUNCTION);\n      case VARIABLE:\n        if (isTopLevel) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_TOP_LEVEL_VARIABLE_DECLARATION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_LOCAL_VARIABLE);\n      case LABEL:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_LABEL);\n      case FIELD:\n        if (isStatic) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_STATIC_MEMBER_VARIABLE);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_VARIABLE);\n      case METHOD:\n        if (isStatic) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_STATIC_MEMBER_FUNCTION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_FUNCTION);\n      default:\n        return null;\n    }\n  }","id":106719,"modified_method":"@Nullable\n  private static TextAttributesKey getDeclarationAttributeByType(final @Nullable DartComponentType type,\n                                                                 boolean isStatic,\n                                                                 boolean isTopLevel) {\n    if (type == null) {\n      return null;\n    }\n    switch (type) {\n      case CLASS:\n      case TYPEDEF:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_CLASS);\n      case PARAMETER:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_PARAMETER);\n      case FUNCTION:\n        if (isTopLevel) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_TOP_LEVEL_FUNCTION_DECLARATION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_FUNCTION);\n      case VARIABLE:\n        if (isTopLevel) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_TOP_LEVEL_VARIABLE_DECLARATION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_LOCAL_VARIABLE);\n      case LABEL:\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_LABEL);\n      case FIELD:\n        if (isStatic) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_STATIC_MEMBER_VARIABLE);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_VARIABLE);\n      case METHOD:\n        if (isStatic) return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_STATIC_MEMBER_FUNCTION);\n        return TextAttributesKey.find(DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_FUNCTION);\n      default:\n        return null;\n    }\n  }","commit_id":"60bf581f68c0a32de8ca9062c6ca41633ce0118b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void annotate(final @NotNull PsiElement element, final @NotNull AnnotationHolder holder) {\n    if (holder.isBatchMode()) return;\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n\n    if (DartTokenTypesSets.BUILT_IN_IDENTIFIERS.contains(element.getNode().getElementType())) {\n      if (element.getNode().getTreeParent().getElementType() != DartTokenTypes.ID) {\n        final String message = ApplicationManager.getApplication().isUnitTestMode() ? \"highlighted as keyword\" : null;\n        holder.createInfoAnnotation(element, message).setTextAttributes(TextAttributesKey.find(DartSyntaxHighlighterColors.DART_KEYWORD));\n        return;\n      }\n    }\n\n    if (element.getNode().getElementType() == DartTokenTypes.REGULAR_STRING_PART) {\n      highlightEscapeSequences(element, holder);\n      return;\n    }\n\n    if (element instanceof DartMetadata) {\n      final DartArguments arguments = ((DartMetadata)element).getArguments();\n      final int endOffset = arguments == null ? element.getTextRange().getEndOffset() : arguments.getTextRange().getStartOffset();\n      final TextRange range = TextRange.create(element.getTextRange().getStartOffset(), endOffset);\n\n      final String message = ApplicationManager.getApplication().isUnitTestMode() ? \"metadata\" : null;\n      holder.createInfoAnnotation(range, message).setTextAttributes(TextAttributesKey.find(DartSyntaxHighlighterColors.DART_METADATA));\n      return;\n    }\n\n    if (element instanceof DartReference && element.getParent() instanceof DartType && \"dynamic\".equals(element.getText())) {\n      createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_BUILTIN);\n      return;\n    }\n\n    highlightIfDeclarationOrReference(element, holder, sdk);\n  }","id":106720,"modified_method":"@Override\n  public void annotate(final @NotNull PsiElement element, final @NotNull AnnotationHolder holder) {\n    if (holder.isBatchMode()) return;\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n\n    if (DartTokenTypesSets.BUILT_IN_IDENTIFIERS.contains(element.getNode().getElementType())) {\n      if (element.getNode().getTreeParent().getElementType() != DartTokenTypes.ID) {\n        createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_KEYWORD);\n        return;\n      }\n    }\n\n    if (element.getNode().getElementType() == DartTokenTypes.REGULAR_STRING_PART) {\n      highlightEscapeSequences(element, holder);\n      return;\n    }\n\n    if (element instanceof DartMetadata) {\n      final DartArguments arguments = ((DartMetadata)element).getArguments();\n      final int endOffset = arguments == null ? element.getTextRange().getEndOffset() : arguments.getTextRange().getStartOffset();\n      final TextRange range = TextRange.create(element.getTextRange().getStartOffset(), endOffset);\n      createInfoAnnotation(holder, range, DartSyntaxHighlighterColors.DART_METADATA);\n      return;\n    }\n\n    if (element instanceof DartReference && element.getParent() instanceof DartType && \"dynamic\".equals(element.getText())) {\n      createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_BUILTIN);\n      return;\n    }\n\n    highlightIfDeclarationOrReference(element, holder, sdk);\n  }","commit_id":"60bf581f68c0a32de8ca9062c6ca41633ce0118b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void highlightDeclarationsAndInvocations(final @NotNull PsiElement element, final @NotNull AnnotationHolder holder) {\n    if (element instanceof DartNewExpression) {\n      final DartNewExpression newExpression = (DartNewExpression)element;\n      final DartType type = newExpression.getType();\n      createInfoAnnotation(holder, type, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_CALL);\n    }\n    else if (element instanceof DartConstConstructorExpression) {\n      final DartConstConstructorExpression constConstructorExpression = (DartConstConstructorExpression)element;\n      final DartType type = constConstructorExpression.getType();\n      createInfoAnnotation(holder, type, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_CALL);\n    }\n    else if (element instanceof DartNamedConstructorDeclaration) {\n      final DartNamedConstructorDeclaration decl = (DartNamedConstructorDeclaration)element;\n      final PsiElement child = decl.getFirstChild();\n      final DartComponentName name = decl.getComponentName();\n      final TextRange textRange = new TextRange(child.getTextOffset(), name.getTextRange().getEndOffset());\n      holder.createInfoAnnotation(textRange, null).setTextAttributes(\n        TextAttributesKey.find(DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION));\n    }\n    else if (element instanceof DartFactoryConstructorDeclaration) {\n      final DartFactoryConstructorDeclaration decl = (DartFactoryConstructorDeclaration)element;\n      final DartReference dartReference = PsiTreeUtil.findChildOfType(decl, DartReference.class);\n      createInfoAnnotation(holder, dartReference, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION);\n    }\n    // Constructors are just method declarations whose name matches the parent class\n    else if (element instanceof DartMethodDeclaration) {\n      final DartMethodDeclaration decl = (DartMethodDeclaration)element;\n      final String methodName = decl.getName();\n      final DartClassDefinition classDef = PsiTreeUtil.getParentOfType(decl, DartClassDefinition.class);\n      if (classDef != null && methodName != null) {\n        final String className = classDef.getName();\n        if (className != null) {\n          final String elementKind;\n          if (className.equals(methodName)) {\n            elementKind = DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION;\n          } else {\n            elementKind = isStatic(element) ? DartSyntaxHighlighterColors.DART_STATIC_MEMBER_FUNCTION\n                                            : DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_FUNCTION;\n          }\n          createInfoAnnotation(holder, decl.getComponentName(), elementKind);\n        }\n      }\n    }\n    else if (element instanceof DartFunctionDeclarationWithBodyOrNative) {\n      final DartFunctionDeclarationWithBodyOrNative decl = (DartFunctionDeclarationWithBodyOrNative)element;\n      createInfoAnnotation(holder, decl.getComponentName(), DartSyntaxHighlighterColors.DART_TOP_LEVEL_FUNCTION_DECLARATION);\n    }\n  }","id":106721,"modified_method":"private static void highlightDeclarationsAndInvocations(final @NotNull PsiElement element, final @NotNull AnnotationHolder holder) {\n    if (element instanceof DartNewExpression) {\n      final DartNewExpression newExpression = (DartNewExpression)element;\n      final DartType type = newExpression.getType();\n      createInfoAnnotation(holder, type, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_CALL);\n    }\n    else if (element instanceof DartConstConstructorExpression) {\n      final DartConstConstructorExpression constConstructorExpression = (DartConstConstructorExpression)element;\n      final DartType type = constConstructorExpression.getType();\n      createInfoAnnotation(holder, type, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_CALL);\n    }\n    else if (element instanceof DartNamedConstructorDeclaration) {\n      final DartNamedConstructorDeclaration decl = (DartNamedConstructorDeclaration)element;\n      final PsiElement child = decl.getFirstChild();\n      final DartComponentName name = decl.getComponentName();\n      final TextRange textRange = new TextRange(child.getTextOffset(), name.getTextRange().getEndOffset());\n      createInfoAnnotation(holder, textRange, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION);\n    }\n    else if (element instanceof DartFactoryConstructorDeclaration) {\n      final DartFactoryConstructorDeclaration decl = (DartFactoryConstructorDeclaration)element;\n      final DartReference dartReference = PsiTreeUtil.findChildOfType(decl, DartReference.class);\n      createInfoAnnotation(holder, dartReference, DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION);\n    }\n    // Constructors are just method declarations whose name matches the parent class\n    else if (element instanceof DartMethodDeclaration) {\n      final DartMethodDeclaration decl = (DartMethodDeclaration)element;\n      final String methodName = decl.getName();\n      final DartClassDefinition classDef = PsiTreeUtil.getParentOfType(decl, DartClassDefinition.class);\n      if (classDef != null && methodName != null) {\n        final String className = classDef.getName();\n        if (className != null) {\n          final String elementKind;\n          if (className.equals(methodName)) {\n            elementKind = DartSyntaxHighlighterColors.DART_CONSTRUCTOR_DECLARATION;\n          }\n          else {\n            elementKind = isStatic(element) ? DartSyntaxHighlighterColors.DART_STATIC_MEMBER_FUNCTION\n                                            : DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_FUNCTION;\n          }\n          createInfoAnnotation(holder, decl.getComponentName(), elementKind);\n        }\n      }\n    }\n    else if (element instanceof DartFunctionDeclarationWithBodyOrNative) {\n      final DartFunctionDeclarationWithBodyOrNative decl = (DartFunctionDeclarationWithBodyOrNative)element;\n      createInfoAnnotation(holder, decl.getComponentName(), DartSyntaxHighlighterColors.DART_TOP_LEVEL_FUNCTION_DECLARATION);\n    }\n  }","commit_id":"60bf581f68c0a32de8ca9062c6ca41633ce0118b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void createInfoAnnotation(final @NotNull AnnotationHolder holder,\n                                           final @Nullable PsiElement element,\n                                           final @NotNull String attributeKey) {\n    if (element != null) {\n      holder.createInfoAnnotation(element, null).setTextAttributes(TextAttributesKey.find(attributeKey));\n    }\n  }","id":106722,"modified_method":"private static void createInfoAnnotation(final @NotNull AnnotationHolder holder,\n                                           final @Nullable PsiElement element,\n                                           final @NotNull String attributeKey) {\n    if (element != null) {\n      createInfoAnnotation(holder, element, TextAttributesKey.find(attributeKey));\n    }\n  }","commit_id":"60bf581f68c0a32de8ca9062c6ca41633ce0118b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void highlightIfDeclarationOrReference(final PsiElement element,\n                                                        final AnnotationHolder holder,\n                                                        final @Nullable DartSdk sdk) {\n    DartComponentName componentName = null;\n\n    //System.out.println(element.getText());\n\n    if (element instanceof DartComponentName) {\n      componentName = (DartComponentName)element;\n    }\n    else if (element instanceof DartReference) {\n      final DartReference[] references = PsiTreeUtil.getChildrenOfType(element, DartReference.class);\n      boolean chain = references != null && references.length > 1;\n      if (!chain) {\n        final PsiElement resolved = ((DartReference)element).resolve(); // todo this takes too much time\n        final PsiElement elementParent = element.getParent();\n        if (resolved != null && elementParent instanceof DartCallExpression) {\n          final PsiElement parent = resolved.getParent();\n          if (parent instanceof DartFunctionDeclarationWithBodyOrNative) {\n            createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_TOP_LEVEL_FUNCTION_CALL);\n          } else if (parent instanceof DartMethodDeclaration) {\n            final String callType =\n              ((DartMethodDeclaration)parent).isStatic() ? DartSyntaxHighlighterColors.DART_STATIC_MEMBER_FUNCTION_CALL\n                                                         : DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_FUNCTION_CALL;\n            createInfoAnnotation(holder, element, callType);\n          }\n        } else if (resolved != null) {\n\n          final PsiElement parent = resolved.getParent();\n          if (parent instanceof DartVarAccessDeclaration) {\n            final DartComponentType type = DartComponentType.typeOf(parent);\n            if (type == DartComponentType.VARIABLE) {\n              final PsiElement varParent = parent.getParent().getParent();\n              if (varParent instanceof DartFile) {\n                createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_TOP_LEVEL_VARIABLE_ACCESS);\n              } else {\n                createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_LOCAL_VARIABLE_ACCESS);\n              }\n            } else {\n              if (((DartVarAccessDeclaration)parent).isStatic()) {\n                createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_STATIC_MEMBER_VARIABLE_ACCESS);\n              } else {\n                createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_INSTANCE_MEMBER_VARIABLE_ACCESS);\n              }\n            }\n\n          }\n          else if (resolved instanceof DartComponentName) componentName = (DartComponentName)resolved;\n        }\n      }\n    }\n\n    if (componentName != null) {\n      if (BUILT_IN_TYPES_HIGHLIGHTED_AS_KEYWORDS.contains(componentName.getName()) &&\n          sdk != null && isInSdkCore(sdk, componentName.getContainingFile())) {\n        createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_BUILTIN);\n\n        return;\n      }\n\n      final boolean isStatic = isStatic(componentName.getParent());\n      final boolean isTopLevel = !isStatic && isTopLevel(componentName.getParent());\n      final TextAttributesKey attribute = getAttributeByType(DartComponentType.typeOf(componentName.getParent()), isStatic, isTopLevel);\n      if (attribute != null) {\n        holder.createInfoAnnotation(element, null).setTextAttributes(attribute);\n      }\n    } else {\n      highlightDeclarationsAndInvocations(element, holder);\n    }\n\n  }","id":106723,"modified_method":"private static void highlightIfDeclarationOrReference(final PsiElement element,\n                                                        final AnnotationHolder holder,\n                                                        final @Nullable DartSdk sdk) {\n    DartComponentName componentName = null;\n\n    if (element instanceof DartComponentName) {\n      componentName = (DartComponentName)element;\n    }\n    else if (element instanceof DartReference) {\n      componentName = highlightReference(element, holder);\n    }\n\n    if (componentName != null) {\n      if (BUILT_IN_TYPES_HIGHLIGHTED_AS_KEYWORDS.contains(componentName.getName()) &&\n          sdk != null && isInSdkCore(sdk, componentName.getContainingFile())) {\n        createInfoAnnotation(holder, element, DartSyntaxHighlighterColors.DART_BUILTIN);\n      }\n      else {\n        final boolean isStatic = isStatic(componentName.getParent());\n        final boolean isTopLevel = !isStatic && isTopLevel(componentName.getParent());\n        final TextAttributesKey attribute = getDeclarationAttributeByType(DartComponentType.typeOf(componentName.getParent()), isStatic,\n                                                                          isTopLevel);\n        createInfoAnnotation(holder, element, attribute);\n      }\n    }\n    else {\n      highlightDeclarationsAndInvocations(element, holder);\n    }\n  }","commit_id":"60bf581f68c0a32de8ca9062c6ca41633ce0118b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void visitTypeCastExpression(PsiTypeCastExpression expression) {\n    PsiExpression operand = expression.getOperand();\n    if (operand == null){\n      myIsConstant = false;\n      return;\n    }\n    operand.accept(this);\n    if (!myIsConstant) return;\n    PsiType type = expression.getCastType().getType();\n    if (type instanceof PsiPrimitiveType) return;\n    if (type.equalsToText(\"java.lang.String\")) return;\n    myIsConstant = false;\n  }","id":106724,"modified_method":"public void visitTypeCastExpression(PsiTypeCastExpression expression) {\n    PsiExpression operand = expression.getOperand();\n    if (operand == null){\n      myIsConstant = false;\n      return;\n    }\n    operand.accept(this);\n    if (!myIsConstant) return;\n    PsiTypeElement element = expression.getCastType();\n    if (element == null){\n      myIsConstant = false;\n      return;\n    }\n    PsiType type = element.getType();\n    if (type instanceof PsiPrimitiveType) return;\n    if (type.equalsToText(\"java.lang.String\")) return;\n    myIsConstant = false;\n  }","commit_id":"aee1a7b3bec7b48e8c131fc9cfe986a2fac22884","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n    expression.getLOperand().accept(this);\n    if (!myIsConstant) return;\n    PsiExpression rOperand = expression.getROperand();\n    if (rOperand != null){\n      rOperand.accept(this);\n    }\n  }","id":106725,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n    // check right operand first since it tends to be shorter\n    PsiExpression rOperand = expression.getROperand();\n    if (rOperand != null){\n      rOperand.accept(this);\n      if (!myIsConstant) return;\n      expression.getLOperand().accept(this);\n    }\n  }","commit_id":"aee1a7b3bec7b48e8c131fc9cfe986a2fac22884","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(PsiReferenceExpression expression) {\n    PsiElement refElement = expression.resolve();\n    if (!(refElement instanceof PsiVariable)) {\n      myIsConstant = false;\n      return;\n    }\n    PsiVariable variable = (PsiVariable)refElement;\n    Boolean isConst = varIsConst.get(variable);\n    if (isConst != null) {\n      myIsConstant &= isConst.booleanValue();\n      return;\n    }\n    if (variable instanceof PsiEnumConstant) {\n      myIsConstant = true;\n      varIsConst.put(variable, Boolean.TRUE);\n      return;\n    }\n    varIsConst.put(variable, Boolean.FALSE);\n    if (!variable.hasModifierProperty(PsiModifier.FINAL)){\n      myIsConstant = false;\n      return;\n    }\n    if (!variable.hasInitializer()){\n      myIsConstant = false;\n      return;\n    }\n    PsiExpression initializer = variable.getInitializer();\n    initializer.accept(this);\n    varIsConst.put(variable, Boolean.valueOf(myIsConstant));\n  }","id":106726,"modified_method":"public void visitReferenceExpression(PsiReferenceExpression expression) {\n    PsiElement refElement = expression.resolve();\n    if (!(refElement instanceof PsiVariable)) {\n      myIsConstant = false;\n      return;\n    }\n    PsiVariable variable = (PsiVariable)refElement;\n    Boolean isConst = varIsConst.get(variable);\n    if (isConst != null) {\n      myIsConstant &= isConst.booleanValue();\n      return;\n    }\n    if (variable instanceof PsiEnumConstant) {\n      myIsConstant = true;\n      varIsConst.put(variable, Boolean.TRUE);\n      return;\n    }\n    varIsConst.put(variable, Boolean.FALSE);\n    if (!variable.hasModifierProperty(PsiModifier.FINAL)){\n      myIsConstant = false;\n      return;\n    }\n    PsiExpression initializer = variable.getInitializer();\n    if (initializer == null){\n      myIsConstant = false;\n      return;\n    }\n    initializer.accept(this);\n    varIsConst.put(variable, Boolean.valueOf(myIsConstant));\n  }","commit_id":"aee1a7b3bec7b48e8c131fc9cfe986a2fac22884","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canBeSimplified(@NotNull PsiExpression expression) {\n    final ExpressionVisitor expressionVisitor = new ExpressionVisitor(expression.getManager(), false);\n    final Ref<Boolean> canBeSimplified = new Ref<Boolean>(Boolean.FALSE);\n    expression.accept(new PsiRecursiveElementVisitor() {\n      public void visitElement(PsiElement element) {\n        if (!canBeSimplified.get().booleanValue()) {\n          super.visitElement(element);\n        }\n      }\n\n      public void visitExpression(PsiExpression expression) {\n        super.visitExpression(expression);\n        expressionVisitor.clear();\n        expression.accept(expressionVisitor);\n        if (expressionVisitor.canBeSimplifiedFlag) {\n          canBeSimplified.set(Boolean.TRUE);\n        }\n      }\n    });\n    return canBeSimplified.get().booleanValue();\n  }","id":106727,"modified_method":"public static boolean canBeSimplified(@NotNull PsiExpression expression) {\n    PsiType type = expression.getType();\n    if (type != PsiType.BOOLEAN) return false;\n    final ExpressionVisitor expressionVisitor = new ExpressionVisitor(expression.getManager(), false);\n    final Ref<Boolean> canBeSimplified = new Ref<Boolean>(Boolean.FALSE);\n    expression.accept(new PsiRecursiveElementVisitor() {\n      public void visitElement(PsiElement element) {\n        if (!canBeSimplified.get().booleanValue()) {\n          super.visitElement(element);\n        }\n      }\n\n      public void visitExpression(PsiExpression expression) {\n        super.visitExpression(expression);\n        expressionVisitor.clear();\n        expression.accept(expressionVisitor);\n        if (expressionVisitor.canBeSimplifiedFlag) {\n          canBeSimplified.set(Boolean.TRUE);\n        }\n      }\n    });\n    return canBeSimplified.get().booleanValue();\n  }","commit_id":"aee1a7b3bec7b48e8c131fc9cfe986a2fac22884","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isCastRedundantInRefExpression (final PsiReferenceExpression refExpression, final PsiExpression castOperand) {\n    final PsiElement resolved = refExpression.resolve();\n    final Ref<Boolean> result = new Ref<Boolean>(Boolean.FALSE);\n    refExpression.getManager().performActionWithFormatterDisabled(new Runnable() {\n      public void run() {\n        try {\n          final PsiElementFactory elementFactory = refExpression.getManager().getElementFactory();\n          final PsiExpression copyExpression = elementFactory.createExpressionFromText(refExpression.getText(), refExpression);\n          if (copyExpression instanceof PsiReferenceExpression) {\n            final PsiReferenceExpression copy = (PsiReferenceExpression)copyExpression;\n            final PsiExpression qualifier = copy.getQualifierExpression();\n            if (qualifier != null) {\n              qualifier.replace(castOperand);\n              result.set(copy.resolve() == resolved);\n            }\n          }\n        }\n        catch (IncorrectOperationException e) {\n        }\n      }\n    });\n    return result.get().booleanValue();\n  }","id":106728,"modified_method":"private static boolean isCastRedundantInRefExpression (final PsiReferenceExpression refExpression, final PsiExpression castOperand) {\n    final PsiElement resolved = refExpression.resolve();\n    final Ref<Boolean> result = new Ref<Boolean>(Boolean.FALSE);\n    refExpression.getManager().performActionWithFormatterDisabled(new Runnable() {\n      public void run() {\n        try {\n          final PsiElementFactory elementFactory = refExpression.getManager().getElementFactory();\n          final PsiExpression copyExpression = elementFactory.createExpressionFromText(refExpression.getText(), refExpression);\n          if (copyExpression instanceof PsiReferenceExpression) {\n            final PsiReferenceExpression copy = (PsiReferenceExpression)copyExpression;\n            final PsiExpression qualifier = copy.getQualifierExpression();\n            if (qualifier != null) {\n              qualifier.replace(castOperand);\n              result.set(Boolean.valueOf(copy.resolve() == resolved));\n            }\n          }\n        }\n        catch (IncorrectOperationException e) {\n        }\n      }\n    });\n    return result.get().booleanValue();\n  }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n      PsiExpression rExpr = deParenthesize(expression.getLOperand());\n      PsiExpression lExpr = deParenthesize(expression.getROperand());\n\n      if (rExpr != null && lExpr != null) {\n        final IElementType binaryToken = expression.getOperationSign().getTokenType();\n        processBinaryExpressionOperand(lExpr, rExpr, binaryToken);\n        processBinaryExpressionOperand(rExpr, lExpr, binaryToken);\n      }\n    }","id":106729,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n      PsiExpression rExpr = PsiUtil.deparenthesizeExpression(expression.getLOperand());\n      PsiExpression lExpr = PsiUtil.deparenthesizeExpression(expression.getROperand());\n\n      if (rExpr != null && lExpr != null) {\n        final IElementType binaryToken = expression.getOperationSign().getTokenType();\n        processBinaryExpressionOperand(lExpr, rExpr, binaryToken);\n        processBinaryExpressionOperand(rExpr, lExpr, binaryToken);\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkForVirtual(PsiMethodCallExpression methodCall) {\n      PsiReferenceExpression methodExpr = methodCall.getMethodExpression();\n      PsiExpression qualifier = methodExpr.getQualifierExpression();\n      try {\n        if (!(qualifier instanceof PsiParenthesizedExpression)) return;\n        PsiExpression operand = ((PsiParenthesizedExpression)qualifier).getExpression();\n        if (!(operand instanceof PsiTypeCastExpression)) return;\n        PsiTypeCastExpression typeCast = (PsiTypeCastExpression)operand;\n        PsiExpression castOperand = typeCast.getOperand();\n        if (castOperand == null) return;\n\n        PsiType type = castOperand.getType();\n        if (type == null) return;\n        if (type instanceof PsiPrimitiveType) return;\n\n        final JavaResolveResult resolveResult = methodExpr.advancedResolve(false);\n        PsiMethod targetMethod = (PsiMethod)resolveResult.getElement();\n        if (targetMethod == null) return;\n        if (targetMethod.hasModifierProperty(PsiModifier.STATIC)) return;\n\n        try {\n          PsiManager manager = methodExpr.getManager();\n          PsiElementFactory factory = manager.getElementFactory();\n\n          PsiMethodCallExpression newCall = (PsiMethodCallExpression)factory.createExpressionFromText(methodCall.getText(), methodCall);\n          PsiExpression newQualifier = newCall.getMethodExpression().getQualifierExpression();\n          PsiExpression newOperand = ((PsiTypeCastExpression)((PsiParenthesizedExpression)newQualifier).getExpression()).getOperand();\n          newQualifier.replace(newOperand);\n\n          final JavaResolveResult newResult = newCall.getMethodExpression().advancedResolve(false);\n          if (!newResult.isValidResult()) return;\n          final PsiMethod newTargetMethod = (PsiMethod)newResult.getElement();\n          final PsiType newReturnType = newResult.getSubstitutor().substitute(newTargetMethod.getReturnType());\n          final PsiType oldReturnType = resolveResult.getSubstitutor().substitute(targetMethod.getReturnType());\n          if (newReturnType.equals(oldReturnType)) {\n            if (newTargetMethod.equals(targetMethod)) {\n                addToResults(typeCast);\n            } else if (newTargetMethod.getSignature(newResult.getSubstitutor()).equals(targetMethod.getSignature(resolveResult.getSubstitutor())) &&\n                       !(newTargetMethod.isDeprecated() && !targetMethod.isDeprecated())) { // see SCR11555, SCR14559\n              addToResults(typeCast);\n            }\n          }\n          qualifier = ((PsiTypeCastExpression) ((PsiParenthesizedExpression) qualifier).getExpression()).getOperand();\n        }\n        catch (IncorrectOperationException e) {\n          return;\n        }\n      } finally {\n        if (qualifier != null) {\n          qualifier.accept(this);\n        }\n      }\n    }","id":106730,"modified_method":"private void checkForVirtual(PsiMethodCallExpression methodCall) {\n      PsiReferenceExpression methodExpr = methodCall.getMethodExpression();\n      PsiExpression qualifier = methodExpr.getQualifierExpression();\n      try {\n        if (!(qualifier instanceof PsiParenthesizedExpression)) return;\n        PsiExpression operand = ((PsiParenthesizedExpression)qualifier).getExpression();\n        if (!(operand instanceof PsiTypeCastExpression)) return;\n        PsiTypeCastExpression typeCast = (PsiTypeCastExpression)operand;\n        PsiExpression castOperand = typeCast.getOperand();\n        if (castOperand == null) return;\n\n        PsiType type = castOperand.getType();\n        if (type == null) return;\n        if (type instanceof PsiPrimitiveType) return;\n\n        final JavaResolveResult resolveResult = methodExpr.advancedResolve(false);\n        PsiMethod targetMethod = (PsiMethod)resolveResult.getElement();\n        if (targetMethod == null) return;\n        if (targetMethod.hasModifierProperty(PsiModifier.STATIC)) return;\n\n        try {\n          PsiManager manager = methodExpr.getManager();\n          PsiElementFactory factory = manager.getElementFactory();\n\n          PsiMethodCallExpression newCall = (PsiMethodCallExpression)factory.createExpressionFromText(methodCall.getText(), methodCall);\n          PsiExpression newQualifier = newCall.getMethodExpression().getQualifierExpression();\n          PsiExpression newOperand = ((PsiTypeCastExpression)((PsiParenthesizedExpression)newQualifier).getExpression()).getOperand();\n          newQualifier.replace(newOperand);\n\n          final JavaResolveResult newResult = newCall.getMethodExpression().advancedResolve(false);\n          if (!newResult.isValidResult()) return;\n          final PsiMethod newTargetMethod = (PsiMethod)newResult.getElement();\n          final PsiType newReturnType = newResult.getSubstitutor().substitute(newTargetMethod.getReturnType());\n          final PsiType oldReturnType = resolveResult.getSubstitutor().substitute(targetMethod.getReturnType());\n          if (newReturnType.equals(oldReturnType)) {\n            if (newTargetMethod.equals(targetMethod)) {\n                addToResults(typeCast);\n            } else if (newTargetMethod.getSignature(newResult.getSubstitutor()).equals(targetMethod.getSignature(resolveResult.getSubstitutor())) &&\n                       !(newTargetMethod.isDeprecated() && !targetMethod.isDeprecated())) { // see SCR11555, SCR14559\n              addToResults(typeCast);\n            }\n          }\n          qualifier = ((PsiTypeCastExpression) ((PsiParenthesizedExpression) qualifier).getExpression()).getOperand();\n        }\n        catch (IncorrectOperationException e) {\n        }\n      }\n      finally {\n        if (qualifier != null) {\n          qualifier.accept(this);\n        }\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitTypeCastExpression(PsiTypeCastExpression typeCast) {\n      PsiExpression operand = typeCast.getOperand();\n      if (operand == null) return;\n\n      PsiElement expr = deParenthesize(operand);\n\n      if (expr instanceof PsiTypeCastExpression) {\n        PsiType castType = ((PsiTypeCastExpression)expr).getCastType().getType();\n        if (!(castType instanceof PsiPrimitiveType)) {\n          addToResults((PsiTypeCastExpression)expr);\n        }\n      }\n      else {\n        if (typeCast.getParent() instanceof PsiConditionalExpression) {\n          if (typeCast.getManager().getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) < 0) {\n            //branches need to be of the same type\n            if (!operand.getType().equals(((PsiConditionalExpression)typeCast.getParent()).getType())) return;\n          }\n        }\n\n        processAlreadyHasTypeCast(typeCast);\n      }\n    }","id":106731,"modified_method":"public void visitTypeCastExpression(PsiTypeCastExpression typeCast) {\n      PsiExpression operand = typeCast.getOperand();\n      if (operand == null) return;\n\n      PsiElement expr = PsiUtil.deparenthesizeExpression(operand);\n\n      if (expr instanceof PsiTypeCastExpression) {\n        PsiTypeElement typeElement = ((PsiTypeCastExpression)expr).getCastType();\n        if (typeElement == null) return;\n        PsiType castType = typeElement.getType();\n        if (!(castType instanceof PsiPrimitiveType)) {\n          addToResults((PsiTypeCastExpression)expr);\n        }\n      }\n      else {\n        PsiElement parent = typeCast.getParent();\n        if (parent instanceof PsiConditionalExpression) {\n          if (typeCast.getManager().getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) < 0) {\n            //branches need to be of the same type\n            if (!Comparing.equal(operand.getType(),((PsiConditionalExpression)parent).getType())) return;\n          }\n        }\n        processAlreadyHasTypeCast(typeCast);\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processAlreadyHasTypeCast(PsiTypeCastExpression typeCast){\n      PsiElement parent = typeCast.getParent();\n      while(parent instanceof PsiParenthesizedExpression) parent = parent.getParent();\n      if (parent instanceof PsiExpressionList) return; // do not replace in arg lists - should be handled by parent\n\n      if (isTypeCastSemantical(typeCast)) return;\n\n      PsiType toType = typeCast.getCastType().getType();\n      PsiType fromType = typeCast.getOperand().getType();\n      if (fromType == null) return;\n      if (parent instanceof PsiReferenceExpression) {\n        if (toType instanceof PsiClassType && fromType instanceof PsiPrimitiveType) return; //explicit boxing\n        //Check accessibility\n        if (fromType instanceof PsiClassType) {\n          final PsiReferenceExpression refExpression = ((PsiReferenceExpression)parent);\n          PsiElement element = refExpression.resolve();\n          if (!(element instanceof PsiMember)) return;\n          PsiClass accessClass = ((PsiClassType)fromType).resolve();\n          if (accessClass == null) return;\n          if (!parent.getManager().getResolveHelper().isAccessible((PsiMember)element, typeCast, accessClass)) return;\n          if (!isCastRedundantInRefExpression(refExpression, typeCast.getOperand())) return;\n        }\n      }\n\n      if (TypeConversionUtil.isAssignable(toType, fromType, false)) {\n        addToResults(typeCast);\n      }\n    }","id":106732,"modified_method":"private void processAlreadyHasTypeCast(PsiTypeCastExpression typeCast){\n      PsiElement parent = typeCast.getParent();\n      while(parent instanceof PsiParenthesizedExpression) parent = parent.getParent();\n      if (parent instanceof PsiExpressionList) return; // do not replace in arg lists - should be handled by parent\n\n      if (isTypeCastSemantical(typeCast)) return;\n\n      PsiTypeElement typeElement = typeCast.getCastType();\n      if (typeElement == null) return;\n      PsiType toType = typeElement.getType();\n      PsiType fromType = typeCast.getOperand().getType();\n      if (fromType == null) return;\n      if (parent instanceof PsiReferenceExpression) {\n        if (toType instanceof PsiClassType && fromType instanceof PsiPrimitiveType) return; //explicit boxing\n        //Check accessibility\n        if (fromType instanceof PsiClassType) {\n          final PsiReferenceExpression refExpression = (PsiReferenceExpression)parent;\n          PsiElement element = refExpression.resolve();\n          if (!(element instanceof PsiMember)) return;\n          PsiClass accessClass = ((PsiClassType)fromType).resolve();\n          if (accessClass == null) return;\n          if (!parent.getManager().getResolveHelper().isAccessible((PsiMember)element, typeCast, accessClass)) return;\n          if (!isCastRedundantInRefExpression(refExpression, typeCast.getOperand())) return;\n        }\n      }\n\n      if (TypeConversionUtil.isAssignable(toType, fromType, false)) {\n        addToResults(typeCast);\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processCall(PsiCallExpression expression){\n      PsiMethod oldMethod = null;\n      PsiParameter[] methodParms = null;\n      boolean[] typeCastCandidates = null;\n      boolean hasCandidate = false;\n\n\n\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      for (int i = 0; i < args.length; i++) {\n        PsiExpression arg = deParenthesize(args[i]);\n        if (arg instanceof PsiTypeCastExpression) {\n          if (oldMethod == null){\n            oldMethod = expression.resolveMethod();\n            if (oldMethod == null) return;\n            methodParms = oldMethod.getParameterList().getParameters();\n            if (methodParms.length == 0 || methodParms.length > args.length) return;\n            typeCastCandidates = new boolean[args.length];\n          }\n\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          if (castOperand == null) return;\n          PsiType operandType = castOperand.getType();\n          if (operandType == null) return;\n          PsiParameter methodParm = methodParms[Math.min(i, methodParms.length - 1)];\n          if (!methodParm.getType().isAssignableFrom(operandType)) continue;\n\n          //Check explicit cast for varargs parameter, see SCR 37199\n          if (args.length == methodParms.length) {\n            if (PsiType.NULL.equals(operandType) && methodParm.isVarArgs()) continue;\n          }\n\n          typeCastCandidates[i] = true;\n          hasCandidate = true;\n        }\n      }\n\n      if (hasCandidate) {\n        PsiManager manager = expression.getManager();\n        PsiElementFactory factory = manager.getElementFactory();\n\n\n        try {\n          for (int i = 0; i < args.length; i++) {\n            final PsiExpression arg = deParenthesize(args[i]);\n            if (typeCastCandidates[i]) {\n              PsiCallExpression newCall = (PsiCallExpression)expression.copy();\n              final PsiExpressionList argList = newCall.getArgumentList();\n              LOG.assertTrue(argList != null);\n              PsiExpression[] newArgs = argList.getExpressions();\n              PsiTypeCastExpression castExpression = (PsiTypeCastExpression)deParenthesize(newArgs[i]);\n              PsiExpression castOperand = castExpression.getOperand();\n              if (castOperand == null) return;\n              castExpression.replace(castOperand);\n              final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n              if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() && Comparing.equal(newCall.getType(), expression.getType())) {\n                addToResults((PsiTypeCastExpression)arg);\n              }\n            }\n          }\n        }\n        catch (IncorrectOperationException e) {\n          return;\n        }\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          castOperand.accept(this);\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","id":106733,"modified_method":"private void processCall(PsiCallExpression expression){\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      PsiMethod oldMethod = null;\n      PsiParameter[] methodParms = null;\n      boolean[] typeCastCandidates = null;\n      boolean hasCandidate = false;\n      for (int i = 0; i < args.length; i++) {\n        PsiExpression arg = PsiUtil.deparenthesizeExpression(args[i]);\n        if (arg instanceof PsiTypeCastExpression) {\n          if (oldMethod == null){\n            oldMethod = expression.resolveMethod();\n            if (oldMethod == null) return;\n            methodParms = oldMethod.getParameterList().getParameters();\n            if (methodParms.length == 0 || methodParms.length > args.length) return;\n            typeCastCandidates = new boolean[args.length];\n          }\n\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          if (castOperand == null) return;\n          PsiType operandType = castOperand.getType();\n          if (operandType == null) return;\n          PsiParameter methodParm = methodParms[Math.min(i, methodParms.length - 1)];\n          if (!methodParm.getType().isAssignableFrom(operandType)) continue;\n\n          //Check explicit cast for varargs parameter, see SCR 37199\n          if (args.length == methodParms.length) {\n            if (PsiType.NULL.equals(operandType) && methodParm.isVarArgs()) continue;\n          }\n\n          typeCastCandidates[i] = true;\n          hasCandidate = true;\n        }\n      }\n\n      if (hasCandidate) {\n        try {\n          for (int i = 0; i < args.length; i++) {\n            final PsiExpression arg = PsiUtil.deparenthesizeExpression(args[i]);\n            if (typeCastCandidates[i]) {\n              PsiCallExpression newCall = (PsiCallExpression)expression.copy();\n              final PsiExpressionList argList = newCall.getArgumentList();\n              LOG.assertTrue(argList != null);\n              PsiExpression[] newArgs = argList.getExpressions();\n              PsiTypeCastExpression castExpression = (PsiTypeCastExpression)PsiUtil.deparenthesizeExpression(newArgs[i]);\n              PsiExpression castOperand = castExpression.getOperand();\n              if (castOperand == null) return;\n              castExpression.replace(castOperand);\n              final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n              if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() && Comparing.equal(newCall.getType(), expression.getType())) {\n                addToResults((PsiTypeCastExpression)arg);\n              }\n            }\n          }\n        }\n        catch (IncorrectOperationException e) {\n          return;\n        }\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          castOperand.accept(this);\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isCastRedundant (PsiTypeCastExpression typeCast) {\n    MyIsRedundantVisitor visitor = new MyIsRedundantVisitor();\n    PsiElement parent = typeCast.getParent();\n    while(parent instanceof PsiParenthesizedExpression) parent = parent.getParent();\n    if (parent instanceof PsiExpressionList) parent = parent.getParent();\n    if (parent instanceof PsiReferenceExpression) parent = parent.getParent();\n    parent.accept(visitor);\n    return visitor.isRedundant();\n  }","id":106734,"modified_method":"public static boolean isCastRedundant (PsiTypeCastExpression typeCast) {\n    PsiElement parent = typeCast.getParent();\n    while(parent instanceof PsiParenthesizedExpression) parent = parent.getParent();\n    if (parent instanceof PsiExpressionList) parent = parent.getParent();\n    if (parent instanceof PsiReferenceExpression) parent = parent.getParent();\n    MyIsRedundantVisitor visitor = new MyIsRedundantVisitor();\n    parent.accept(visitor);\n    return visitor.isRedundant();\n  }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTypeCastSemantical(PsiTypeCastExpression typeCast) {\n    PsiExpression operand = typeCast.getOperand();\n    if (operand != null) {\n      PsiType opType = operand.getType();\n      PsiType castType = typeCast.getCastType().getType();\n      if (castType instanceof PsiPrimitiveType) {\n        if (opType instanceof PsiPrimitiveType) {\n          return !opType.equals(castType); // let's suppose all not equal primitive casts are necessary\n        }\n      }\n      else if (castType instanceof PsiClassType && ((PsiClassType)castType).hasParameters()) {\n        if (opType instanceof PsiClassType && ((PsiClassType)opType).isRaw()) return true;\n      }\n    }\n\n    return false;\n  }","id":106735,"modified_method":"public static boolean isTypeCastSemantical(PsiTypeCastExpression typeCast) {\n    PsiExpression operand = typeCast.getOperand();\n    if (operand != null) {\n      PsiType opType = operand.getType();\n      PsiTypeElement typeElement = typeCast.getCastType();\n      if (typeElement == null) return false;\n      PsiType castType = typeElement.getType();\n      if (castType instanceof PsiPrimitiveType) {\n        if (opType instanceof PsiPrimitiveType) {\n          return !opType.equals(castType); // let's suppose all not equal primitive casts are necessary\n        }\n      }\n      else if (castType instanceof PsiClassType && ((PsiClassType)castType).hasParameters()) {\n        if (opType instanceof PsiClassType && ((PsiClassType)opType).isRaw()) return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processPossibleTypeCast(PsiExpression rExpr, PsiType lType) {\n      rExpr = deParenthesize(rExpr);\n      if (rExpr instanceof PsiTypeCastExpression) {\n        PsiExpression castOperand = ((PsiTypeCastExpression)rExpr).getOperand();\n        if (castOperand != null) {\n          PsiType operandType = castOperand.getType();\n          if (operandType != null) {\n            if (lType != null && TypeConversionUtil.isAssignable(lType, operandType, false)) {\n              addToResults((PsiTypeCastExpression)rExpr);\n            }\n          }\n        }\n      }\n    }","id":106736,"modified_method":"private void processPossibleTypeCast(PsiExpression rExpr, PsiType lType) {\n      rExpr = PsiUtil.deparenthesizeExpression(rExpr);\n      if (rExpr instanceof PsiTypeCastExpression) {\n        PsiExpression castOperand = ((PsiTypeCastExpression)rExpr).getOperand();\n        if (castOperand != null) {\n          PsiType operandType = castOperand.getType();\n          if (operandType != null) {\n            if (lType != null && TypeConversionUtil.isAssignable(lType, operandType, false)) {\n              addToResults((PsiTypeCastExpression)rExpr);\n            }\n          }\n        }\n      }\n    }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addUsage(final ReductionSystem system, final PsiElement element) {\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (PsiExpression init : inits) {\n            system.addSubtypeConstraint(evaluateType(init, system).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (PsiExpression init1 : inits) {\n              system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        final PsiElement declarationScope = ((PsiParameter)element).getDeclarationScope();\n        if (declarationScope instanceof PsiMethod) {\n          final PsiMethod method = ((PsiMethod)declarationScope);\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          SearchScope scope = getScope(helper, method);\n\n          final PsiReference[] refs = helper.findReferences(method, scope, true);\n\n          for (PsiReference ref : refs) {\n            final PsiElement elt = ref.getElement();\n\n            if (elt != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(elt, PsiCallExpression.class);\n\n              if (call != null) {\n                final PsiExpression arg = call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex(\n                  (PsiParameter)element)];\n\n                system.addSubtypeConstraint(evaluateType(arg, system), myTypes.get(element));\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(evaluateType(retExpr, system), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiElement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class, PsiField.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getRExpression(), system), evaluateType(expression.getLExpression(),\n                                                                                                                        system));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getThenExpression(), system),\n                                                    evaluateType(expression.getElseExpression(), system));\n                        system.addSubtypeConstraint(evaluateType(expression.getElseExpression(), system),\n                                                    evaluateType(expression.getThenExpression(), system));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        evaluateType(expression, system);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(evaluateType(statement.getReturnValue(), system), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        final PsiType operandType = evaluateType(expression.getOperand(), system);\n                        final PsiType castType = evaluateType(expression, system);\n                        if (operandType == null || castType == null) return;\n\n                        if (Util.bindsTypeVariables(operandType)) {\n                          system.addCast(expression, operandType);\n                        }\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(evaluateType(init, system), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (PsiExpression init1 : inits) {\n                            system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","id":106737,"modified_method":"private void addUsage(final ReductionSystem system, final PsiElement element) {\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = PsiUtil.deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (PsiExpression init : inits) {\n            system.addSubtypeConstraint(evaluateType(init, system).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (PsiExpression init1 : inits) {\n              system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        final PsiElement declarationScope = ((PsiParameter)element).getDeclarationScope();\n        if (declarationScope instanceof PsiMethod) {\n          final PsiMethod method = ((PsiMethod)declarationScope);\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          SearchScope scope = getScope(helper, method);\n\n          final PsiReference[] refs = helper.findReferences(method, scope, true);\n\n          for (PsiReference ref : refs) {\n            final PsiElement elt = ref.getElement();\n\n            if (elt != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(elt, PsiCallExpression.class);\n\n              if (call != null) {\n                final PsiExpression arg = call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex(\n                  (PsiParameter)element)];\n\n                system.addSubtypeConstraint(evaluateType(arg, system), myTypes.get(element));\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(evaluateType(retExpr, system), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiElement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class, PsiField.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getRExpression(), system), evaluateType(expression.getLExpression(),\n                                                                                                                        system));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getThenExpression(), system),\n                                                    evaluateType(expression.getElseExpression(), system));\n                        system.addSubtypeConstraint(evaluateType(expression.getElseExpression(), system),\n                                                    evaluateType(expression.getThenExpression(), system));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        evaluateType(expression, system);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(evaluateType(statement.getReturnValue(), system), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        final PsiType operandType = evaluateType(expression.getOperand(), system);\n                        final PsiType castType = evaluateType(expression, system);\n                        if (operandType == null || castType == null) return;\n\n                        if (Util.bindsTypeVariables(operandType)) {\n                          system.addCast(expression, operandType);\n                        }\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(evaluateType(init, system), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (PsiExpression init1 : inits) {\n                            system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","commit_id":"0b2594c5430bb265e8865b418255f4efc1edbaf2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processMethodReturnType(final PsiMethod method) {\n    final PsiTypeElement returnType = method.getReturnTypeElement();\n    final PsiReference[] calls = mySearchHelper.findReferences(method, GlobalSearchScope.projectScope(myProject), false);\n    for (PsiReference call : calls) {\n      final PsiElement ref = call.getElement();\n      if (PsiTreeUtil.getParentOfType(ref, PsiDocComment.class) != null) continue;\n      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)ref.getParent();\n      addLink(methodCall, returnType);\n    }\n\n    final PsiReturnStatement[] returnStatements = RefactoringUtil.findReturnStatements(method);\n    for (final PsiReturnStatement returnStatement : returnStatements) {\n      final PsiExpression returnValue = returnStatement.getReturnValue();\n      if (returnValue != null) {\n        addLink(returnType, returnValue);\n      }\n    }\n\n    final PsiMethod[] superMethods = method.findSuperMethods();\n    final class Inner {\n      public void linkInheritors(final PsiMethod[] methods) {\n        for (final PsiMethod superMethod : methods) {\n          final PsiTypeElement superType = superMethod.getReturnTypeElement();\n          addLink(superType, returnType);\n          addLink(returnType, superType);\n        }\n      }\n    }\n  ;\n    new Inner().linkInheritors(superMethods);\n    // ??? In the theory this is non-efficient way: too many inheritors can be processed (and multiple times).\n    // ??? But in real use it seems reasonably fast. If poor performance problems emerged,\n    // ??? should be optimized\n    final PsiClass[] subClasses =\n      mySearchHelper.findInheritors(method.getContainingClass(), GlobalSearchScope.projectScope(myProject), false);\n    for (int i1 = 0; i1 != subClasses.length; ++i1) {\n      final PsiMethod[] mBSs = subClasses[i1].findMethodsBySignature(method, true);\n      new Inner().linkInheritors(mBSs);\n    }\n  }","id":106738,"modified_method":"private void processMethodReturnType(final PsiMethod method) {\n    final PsiTypeElement returnType = method.getReturnTypeElement();\n    for (PsiReference call : ReferencesSearch.search(method).findAll()) {\n      final PsiElement ref = call.getElement();\n      if (PsiTreeUtil.getParentOfType(ref, PsiDocComment.class) != null) continue;\n      final PsiMethodCallExpression methodCall = (PsiMethodCallExpression)ref.getParent();\n      addLink(methodCall, returnType);\n    }\n\n    final PsiReturnStatement[] returnStatements = RefactoringUtil.findReturnStatements(method);\n    for (final PsiReturnStatement returnStatement : returnStatements) {\n      final PsiExpression returnValue = returnStatement.getReturnValue();\n      if (returnValue != null) {\n        addLink(returnType, returnValue);\n      }\n    }\n\n    final PsiMethod[] superMethods = method.findSuperMethods();\n    final class Inner {\n      public void linkInheritors(final PsiMethod[] methods) {\n        for (final PsiMethod superMethod : methods) {\n          final PsiTypeElement superType = superMethod.getReturnTypeElement();\n          addLink(superType, returnType);\n          addLink(returnType, superType);\n        }\n      }\n    }\n\n    new Inner().linkInheritors(superMethods);\n    // ??? In the theory this is non-efficient way: too many inheritors can be processed (and multiple times).\n    // ??? But in real use it seems reasonably fast. If poor performance problems emerged,\n    // ??? should be optimized\n    final PsiClass[] subClasses =\n      mySearchHelper.findInheritors(method.getContainingClass(), GlobalSearchScope.projectScope(myProject), false);\n    for (int i1 = 0; i1 != subClasses.length; ++i1) {\n      final PsiMethod[] mBSs = subClasses[i1].findMethodsBySignature(method, true);\n      new Inner().linkInheritors(mBSs);\n    }\n  }","commit_id":"96a7e03295d499d8ab5e4186428a1a7144356c6f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fixPossiblyRedundantCast(PsiTypeCastExpression cast) throws IncorrectOperationException {\n    PsiClass castClass = PsiUtil.resolveClassInType(cast.getCastType().getType());\n    if (castClass == null) return;\n\n    PsiExpression operand = cast.getOperand();\n    if (operand == null) return;\n    PsiClass operandClass = PsiUtil.resolveClassInType(RefactoringUtil.getTypeByExpression(operand));\n    if (operandClass == null) return;\n\n    if (!castClass.getManager().areElementsEquivalent(castClass, operandClass) &&\n        !operandClass.isInheritor(castClass, true)) {\n      return;\n    }\n    // OK, cast is redundant\n    PsiExpression exprToReplace = cast;\n    while (exprToReplace.getParent() instanceof PsiParenthesizedExpression) {\n      exprToReplace = (PsiExpression)exprToReplace.getParent();\n    }\n    exprToReplace.replace(operand);\n  }","id":106739,"modified_method":"private static void fixPossiblyRedundantCast(PsiTypeCastExpression cast) throws IncorrectOperationException {\n    PsiTypeElement castTypeElement = cast.getCastType();\n    if (castTypeElement == null) return;\n    PsiClass castClass = PsiUtil.resolveClassInType(castTypeElement.getType());\n    if (castClass == null) return;\n\n    PsiExpression operand = cast.getOperand();\n    if (operand == null) return;\n    PsiClass operandClass = PsiUtil.resolveClassInType(RefactoringUtil.getTypeByExpression(operand));\n    if (operandClass == null) return;\n\n    if (!castClass.getManager().areElementsEquivalent(castClass, operandClass) &&\n        !operandClass.isInheritor(castClass, true)) {\n      return;\n    }\n    // OK, cast is redundant\n    PsiExpression exprToReplace = cast;\n    while (exprToReplace.getParent() instanceof PsiParenthesizedExpression) {\n      exprToReplace = (PsiExpression)exprToReplace.getParent();\n    }\n    exprToReplace.replace(operand);\n  }","commit_id":"96a7e03295d499d8ab5e4186428a1a7144356c6f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkToArray(PsiElement ref, PsiNewExpression newExpression) {\n    PsiElement tmp;\n\n    final PsiClass javaUtilCollectionClass = myManager.findClass(\"java.util.Collection\", ref.getResolveScope());\n    if (javaUtilCollectionClass == null) return;\n    tmp = newExpression.getParent();\n    if (!(tmp instanceof PsiExpressionList)) return;\n    tmp = tmp.getParent();\n    if (!(tmp instanceof PsiMethodCallExpression)) return;\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)tmp;\n    tmp = tmp.getParent();\n    if (!(tmp instanceof PsiTypeCastExpression)) return;\n    PsiTypeCastExpression typeCast = (PsiTypeCastExpression)tmp;\n\n    PsiReferenceExpression methodRef = methodCall.getMethodExpression();\n    if (methodRef == null) return;\n    tmp = methodRef.resolve();\n    if (!(tmp instanceof PsiMethod)) return;\n    PsiMethod method = (PsiMethod)tmp;\n    @NonNls final String name = method.getName();\n    if (!name.equals(\"toArray\")) return;\n\n    PsiClass methodClass = method.getContainingClass();\n    if (!methodClass.isInheritor(javaUtilCollectionClass, true)) return;\n\n    // ok, this is an implementation of java.util.Collection.toArray\n    addLink(typeCast, ref);\n\n  }","id":106740,"modified_method":"private void checkToArray(PsiElement ref, PsiNewExpression newExpression) {\n    PsiElement tmp;\n\n    final PsiClass javaUtilCollectionClass = myManager.findClass(\"java.util.Collection\", ref.getResolveScope());\n    if (javaUtilCollectionClass == null) return;\n    tmp = newExpression.getParent();\n    if (!(tmp instanceof PsiExpressionList)) return;\n    tmp = tmp.getParent();\n    if (!(tmp instanceof PsiMethodCallExpression)) return;\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)tmp;\n    tmp = tmp.getParent();\n    if (!(tmp instanceof PsiTypeCastExpression)) return;\n    PsiTypeCastExpression typeCast = (PsiTypeCastExpression)tmp;\n\n    PsiReferenceExpression methodRef = methodCall.getMethodExpression();\n    tmp = methodRef.resolve();\n    if (!(tmp instanceof PsiMethod)) return;\n    PsiMethod method = (PsiMethod)tmp;\n    @NonNls final String name = method.getName();\n    if (!name.equals(\"toArray\")) return;\n\n    PsiClass methodClass = method.getContainingClass();\n    if (!methodClass.isInheritor(javaUtilCollectionClass, true)) return;\n\n    // ok, this is an implementation of java.util.Collection.toArray\n    addLink(typeCast, ref);\n\n  }","commit_id":"96a7e03295d499d8ab5e4186428a1a7144356c6f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processVariableType(PsiVariable variable) {\n    final PsiTypeElement type = variable.getTypeElement();\n    final PsiExpression initializer = variable.getInitializer();\n    if (initializer != null) {\n      addLink(type, initializer);\n    }\n\n    final PsiReference[] refs = mySearchHelper.findReferences(variable, GlobalSearchScope.projectScope(myProject), false);\n    for (PsiReference ref : refs) {\n      final PsiElement element = ref.getElement();\n      addLink(element, type);\n      addLink(type, element);\n      analyzeVarUsage(element);\n    }\n\n    if (variable instanceof PsiParameter) {\n      final PsiElement declScope = ((PsiParameter)variable).getDeclarationScope();\n      if (declScope instanceof PsiCatchSection) {\n        markNode(type);\n      }\n      else if (declScope instanceof PsiForeachStatement) {\n        final PsiExpression iteratedValue = ((PsiForeachStatement)declScope).getIteratedValue();\n        addLink(type, iteratedValue);\n        addLink(iteratedValue, type);\n      }\n      else if (declScope instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)declScope;\n        final int index = method.getParameterList().getParameterIndex((PsiParameter)variable);\n\n        {\n          PsiReference[] calls = mySearchHelper.findReferences(method, GlobalSearchScope.projectScope(myProject), false);\n          for (PsiReference call : calls) {\n            PsiElement ref = call.getElement();\n            PsiExpressionList argumentList;\n            if (ref.getParent() instanceof PsiCall) {\n              argumentList = ((PsiCall)ref.getParent()).getArgumentList();\n            }\n            else if (ref.getParent() instanceof PsiAnonymousClass) {\n              argumentList = ((PsiConstructorCall)ref.getParent().getParent()).getArgumentList();\n            }\n            else {\n              continue;\n            }\n            if (argumentList == null) continue;\n            PsiExpression[] args = argumentList.getExpressions();\n            if (index >= args.length) continue;\n            addLink(type, args[index]);\n          }\n        }\n\n        final class Inner {\n          void linkInheritors(final PsiMethod[] methods) {\n            for (final PsiMethod superMethod : methods) {\n              final PsiParameter[] parameters = superMethod.getParameterList().getParameters();\n              if (index >= parameters.length) continue;\n              final PsiTypeElement superType = parameters[index].getTypeElement();\n              addLink(superType, type);\n              addLink(type, superType);\n            }\n          }\n        }\n\n        final PsiMethod[] superMethods = method.findSuperMethods();\n        new Inner().linkInheritors(superMethods);\n        final PsiClass[] subClasses =\n          mySearchHelper.findInheritors(method.getContainingClass(), GlobalSearchScope.projectScope(myProject), false);\n        // ??? In the theory this is non-efficient way: too many inheritors can be processed.\n        // ??? But in real use it seems reasonably fast. If poor performance problems emerged,\n        // ??? should be optimized\n        for (int i1 = 0; i1 != subClasses.length; ++i1) {\n          final PsiMethod[] mBSs = subClasses[i1].findMethodsBySignature(method, true);\n          new Inner().linkInheritors(mBSs);\n        }\n      }\n      else {\n        LOG.assertTrue(false);\n      }\n    }\n  }","id":106741,"modified_method":"private void processVariableType(PsiVariable variable) {\n    final PsiTypeElement type = variable.getTypeElement();\n    final PsiExpression initializer = variable.getInitializer();\n    if (initializer != null) {\n      addLink(type, initializer);\n    }\n\n    for (PsiReference ref : ReferencesSearch.search(variable).findAll()) {\n      final PsiElement element = ref.getElement();\n      addLink(element, type);\n      addLink(type, element);\n      analyzeVarUsage(element);\n    }\n\n    if (variable instanceof PsiParameter) {\n      final PsiElement declScope = ((PsiParameter)variable).getDeclarationScope();\n      if (declScope instanceof PsiCatchSection) {\n        markNode(type);\n      }\n      else if (declScope instanceof PsiForeachStatement) {\n        final PsiExpression iteratedValue = ((PsiForeachStatement)declScope).getIteratedValue();\n        addLink(type, iteratedValue);\n        addLink(iteratedValue, type);\n      }\n      else if (declScope instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)declScope;\n        final int index = method.getParameterList().getParameterIndex((PsiParameter)variable);\n\n        {\n          for (PsiReference call : ReferencesSearch.search(method).findAll()) {\n            PsiElement ref = call.getElement();\n            PsiExpressionList argumentList;\n            if (ref.getParent() instanceof PsiCall) {\n              argumentList = ((PsiCall)ref.getParent()).getArgumentList();\n            }\n            else if (ref.getParent() instanceof PsiAnonymousClass) {\n              argumentList = ((PsiConstructorCall)ref.getParent().getParent()).getArgumentList();\n            }\n            else {\n              continue;\n            }\n            if (argumentList == null) continue;\n            PsiExpression[] args = argumentList.getExpressions();\n            if (index >= args.length) continue;\n            addLink(type, args[index]);\n          }\n        }\n\n        final class Inner {\n          void linkInheritors(final PsiMethod[] methods) {\n            for (final PsiMethod superMethod : methods) {\n              final PsiParameter[] parameters = superMethod.getParameterList().getParameters();\n              if (index >= parameters.length) continue;\n              final PsiTypeElement superType = parameters[index].getTypeElement();\n              addLink(superType, type);\n              addLink(type, superType);\n            }\n          }\n        }\n\n        final PsiMethod[] superMethods = method.findSuperMethods();\n        new Inner().linkInheritors(superMethods);\n        final PsiClass[] subClasses =\n          mySearchHelper.findInheritors(method.getContainingClass(), GlobalSearchScope.projectScope(myProject), false);\n        // ??? In the theory this is non-efficient way: too many inheritors can be processed.\n        // ??? But in real use it seems reasonably fast. If poor performance problems emerged,\n        // ??? should be optimized\n        for (int i1 = 0; i1 != subClasses.length; ++i1) {\n          final PsiMethod[] mBSs = subClasses[i1].findMethodsBySignature(method, true);\n          new Inner().linkInheritors(mBSs);\n        }\n      }\n      else {\n        LOG.assertTrue(false);\n      }\n    }\n  }","commit_id":"96a7e03295d499d8ab5e4186428a1a7144356c6f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void populateReportItems( DecorationModel decorationModel, Locale locale,\n                                        Map<String, MavenReport> reportsByOutputName )\n    {\n        for ( Iterator<Menu> i = decorationModel.getMenus().iterator(); i.hasNext(); )\n        {\n            Menu menu = i.next();\n\n            populateItemRefs( menu.getItems(), locale, reportsByOutputName );\n        }\n    }","id":106742,"modified_method":"protected void populateReportItems( DecorationModel decorationModel, Locale locale,\n                                        Map<String, MavenReport> reportsByOutputName )\n    {\n        for ( Menu menu : decorationModel.getMenus() )\n        {\n            populateItemRefs( menu.getItems(), locale, reportsByOutputName );\n        }\n    }","commit_id":"c58dce043fb166bb63afd95926724f9a510f569c","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected SiteRenderingContext createSiteRenderingContext( Locale locale )\n        throws MojoExecutionException, IOException, MojoFailureException\n    {\n        if ( attributes == null )\n        {\n            attributes = new HashMap<Object, Object>();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"inputEncoding\" ) == null )\n        {\n            attributes.put( \"inputEncoding\", getInputEncoding() );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", getOutputEncoding() );\n        }\n\n        // Put any of the properties in directly into the Velocity context\n        attributes.putAll( project.getProperties() );\n\n        DecorationModel decorationModel;\n        try\n        {\n            decorationModel = siteTool.getDecorationModel( project, reactorProjects, localRepository, repositories,\n                                                           siteTool.getRelativePath( siteDirectory.getAbsolutePath(),\n                                                           project.getBasedir().getAbsolutePath() ),\n                                                           locale, getInputEncoding(), getOutputEncoding() );\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( relativizeDecorationLinks )\n        {\n            final String url = project.getUrl();\n\n            if ( url == null )\n            {\n                getLog().warn( \"No project URL defined - decoration links will not be relativized!\" );\n            }\n            else\n            {\n                getLog().info( \"Relativizing decoration links with respect to project URL: \" + url );\n                assembler.resolvePaths( decorationModel, url );\n            }\n        }\n\n        if ( template != null )\n        {\n            if ( templateFile != null )\n            {\n                getLog().warn( \"'template' configuration is ignored when 'templateFile' is set\" );\n            }\n            else\n            {\n                templateFile = new File( templateDirectory, template );\n            }\n        }\n\n        File skinFile;\n        try\n        {\n            Artifact skinArtifact =\n                siteTool.getSkinArtifactFromRepository( localRepository, repositories, decorationModel );\n            getLog().info( \"Rendering site with \" + skinArtifact.getId() + \" skin.\" );\n\n            skinFile = skinArtifact.getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n        SiteRenderingContext context;\n        if ( templateFile != null )\n        {\n            if ( !templateFile.exists() )\n            {\n                throw new MojoFailureException( \"Template file '\" + templateFile + \"' does not exist\" );\n            }\n            context = siteRenderer.createContextForTemplate( templateFile, skinFile, attributes, decorationModel,\n                                                             project.getName(), locale );\n        }\n        else\n        {\n            context = siteRenderer.createContextForSkin( skinFile, attributes, decorationModel, project.getName(),\n                                                         locale );\n        }\n\n        // Generate static site\n        if ( !locale.getLanguage().equals( Locale.getDefault().getLanguage() ) )\n        {\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"xdoc\" );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"fml\" );\n        }\n        else\n        {\n            context.addSiteDirectory( siteDirectory );\n            context.addModuleDirectory( xdocDirectory, \"xdoc\" );\n            context.addModuleDirectory( xdocDirectory, \"fml\" );\n        }\n\n        if ( moduleExcludes != null )\n        {\n            context.setModuleExcludes( moduleExcludes );\n        }\n\n        return context;\n    }","id":106743,"modified_method":"protected SiteRenderingContext createSiteRenderingContext( Locale locale )\n        throws MojoExecutionException, IOException, MojoFailureException\n    {\n        if ( attributes == null )\n        {\n            attributes = new HashMap<String, Object>();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"inputEncoding\" ) == null )\n        {\n            attributes.put( \"inputEncoding\", getInputEncoding() );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", getOutputEncoding() );\n        }\n\n        // Put any of the properties in directly into the Velocity context\n        for ( Map.Entry<Object, Object> entry : project.getProperties().entrySet() )\n        {\n            attributes.put( (String) entry.getKey(), entry.getValue() );\n        }\n\n        DecorationModel decorationModel;\n        try\n        {\n            decorationModel = siteTool.getDecorationModel( project, reactorProjects, localRepository, repositories,\n                                                           siteTool.getRelativePath( siteDirectory.getAbsolutePath(),\n                                                           project.getBasedir().getAbsolutePath() ),\n                                                           locale, getInputEncoding(), getOutputEncoding() );\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( relativizeDecorationLinks )\n        {\n            final String url = project.getUrl();\n\n            if ( url == null )\n            {\n                getLog().warn( \"No project URL defined - decoration links will not be relativized!\" );\n            }\n            else\n            {\n                getLog().info( \"Relativizing decoration links with respect to project URL: \" + url );\n                assembler.resolvePaths( decorationModel, url );\n            }\n        }\n\n        if ( template != null )\n        {\n            if ( templateFile != null )\n            {\n                getLog().warn( \"'template' configuration is ignored when 'templateFile' is set\" );\n            }\n            else\n            {\n                templateFile = new File( templateDirectory, template );\n            }\n        }\n\n        File skinFile;\n        try\n        {\n            Artifact skinArtifact =\n                siteTool.getSkinArtifactFromRepository( localRepository, repositories, decorationModel );\n            getLog().info( \"Rendering site with \" + skinArtifact.getId() + \" skin.\" );\n\n            skinFile = skinArtifact.getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n        SiteRenderingContext context;\n        if ( templateFile != null )\n        {\n            if ( !templateFile.exists() )\n            {\n                throw new MojoFailureException( \"Template file '\" + templateFile + \"' does not exist\" );\n            }\n            context = siteRenderer.createContextForTemplate( templateFile, skinFile, attributes, decorationModel,\n                                                             project.getName(), locale );\n        }\n        else\n        {\n            context = siteRenderer.createContextForSkin( skinFile, attributes, decorationModel, project.getName(),\n                                                         locale );\n        }\n\n        // Generate static site\n        if ( !locale.getLanguage().equals( Locale.getDefault().getLanguage() ) )\n        {\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"xdoc\" );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"fml\" );\n        }\n        else\n        {\n            context.addSiteDirectory( siteDirectory );\n            context.addModuleDirectory( xdocDirectory, \"xdoc\" );\n            context.addModuleDirectory( xdocDirectory, \"fml\" );\n        }\n\n        if ( moduleExcludes != null )\n        {\n            context.setModuleExcludes( moduleExcludes );\n        }\n\n        return context;\n    }","commit_id":"f8d7c6ebb7124878cb6cd69ada3bc383c5354f15","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void extract( DecorationModel decoration, Sink sink, Locale locale )\n    {\n        sink.head();\n        sink.title();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.title\" ) );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.section.title\" ) );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.description\" ) );\n        sink.paragraph_();\n\n        for ( Iterator<Menu> it = decoration.getMenus().iterator(); it.hasNext(); )\n        {\n            Menu menu = it.next();\n\n            sink.section3();\n            sink.sectionTitle3();\n            sink.text( menu.getName() );\n            sink.sectionTitle3_();\n            sink.horizontalRule();\n\n            extractItems( menu.getItems(), sink );\n\n            sink.section3_();\n        }\n\n        sink.section1_();\n        sink.body_();\n    }","id":106744,"modified_method":"private void extract( DecorationModel decoration, Sink sink, Locale locale )\n    {\n        sink.head();\n        sink.title();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.title\" ) );\n        sink.title_();\n        sink.head_();\n        sink.body();\n\n        sink.section1();\n        sink.sectionTitle1();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.section.title\" ) );\n        sink.sectionTitle1_();\n\n        sink.paragraph();\n        sink.text( i18n.getString( \"site-plugin\", locale, \"site.sitemap.description\" ) );\n        sink.paragraph_();\n\n        for ( Menu menu : decoration.getMenus() )\n        {\n            sink.section3();\n            sink.sectionTitle3();\n            sink.text( menu.getName() );\n            sink.sectionTitle3_();\n            sink.horizontalRule();\n\n            extractItems( menu.getItems(), sink );\n\n            sink.section3_();\n        }\n\n        sink.section1_();\n        sink.body_();\n    }","commit_id":"f8d7c6ebb7124878cb6cd69ada3bc383c5354f15","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Generate the project site\n     * <p/>\n     * throws MojoExecutionException if any\n     *\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        checkMavenVersion();\n\n        List<MavenReport> filteredReports;\n        if ( generateReports )\n        {\n            filteredReports = filterReports( reports );\n        }\n        else\n        {\n            filteredReports = Collections.EMPTY_LIST;\n        }\n\n        try\n        {\n            List<Locale> localesList = siteTool.getAvailableLocales( locales );\n\n            // Default is first in the list\n            Locale defaultLocale = localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Locale locale : localesList )\n            {\n                renderLocale( locale, filteredReports );\n            }\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","id":106745,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Generate the project site\n     * <p/>\n     * throws MojoExecutionException if any\n     *\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        checkMavenVersion();\n\n        List<MavenReport> filteredReports;\n        if ( generateReports )\n        {\n            filteredReports = filterReports( reports );\n        }\n        else\n        {\n            filteredReports = Collections.emptyList();\n        }\n\n        try\n        {\n            List<Locale> localesList = siteTool.getAvailableLocales( locales );\n\n            // Default is first in the list\n            Locale defaultLocale = localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Locale locale : localesList )\n            {\n                renderLocale( locale, filteredReports );\n            }\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","commit_id":"f8d7c6ebb7124878cb6cd69ada3bc383c5354f15","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test method for 'org.apache.maven.plugins.site.AbstractSiteMojo.getInterpolatedSiteDescriptorContent(Map, MavenProject, String)'\n     *\n     * @throws Exception\n     */\n    public void testGetInterpolatedSiteDescriptorContent()\n        throws Exception\n    {\n        File pluginXmlFile = getTestFile( \"src/test/resources/unit/interpolated-site/pom.xml\" );\n        assertNotNull( pluginXmlFile );\n        assertTrue( pluginXmlFile.exists() );\n\n        SiteMojo siteMojo = (SiteMojo) lookupMojo( \"site\", pluginXmlFile );\n        assertNotNull( siteMojo );\n\n        File descriptorFile = getTestFile( \"src/test/resources/unit/interpolated-site/src/site/site.xml\" );\n        assertNotNull( descriptorFile );\n        assertTrue( descriptorFile.exists() );\n\n        String siteDescriptorContent = FileUtils.fileRead( descriptorFile );\n        assertNotNull( siteDescriptorContent );\n        assertTrue( siteDescriptorContent.indexOf( \"${project.name}\" ) != -1 );\n\n        SiteTool siteTool = (SiteTool) lookup( SiteTool.ROLE );\n        siteDescriptorContent = siteTool.getInterpolatedSiteDescriptorContent( new HashMap(), siteMojo.project,\n                                                                               siteDescriptorContent, \"UTF-8\", \"UTF-8\" );\n        assertNotNull( siteDescriptorContent );\n        assertTrue( siteDescriptorContent.indexOf( \"${project.name}\" ) == -1 );\n    }","id":106746,"modified_method":"/**\n     * Test method for 'org.apache.maven.plugins.site.AbstractSiteMojo.getInterpolatedSiteDescriptorContent(Map, MavenProject, String)'\n     *\n     * @throws Exception\n     */\n    public void testGetInterpolatedSiteDescriptorContent()\n        throws Exception\n    {\n        File pluginXmlFile = getTestFile( \"src/test/resources/unit/interpolated-site/pom.xml\" );\n        assertNotNull( pluginXmlFile );\n        assertTrue( pluginXmlFile.exists() );\n\n        SiteMojo siteMojo = (SiteMojo) lookupMojo( \"site\", pluginXmlFile );\n        assertNotNull( siteMojo );\n\n        File descriptorFile = getTestFile( \"src/test/resources/unit/interpolated-site/src/site/site.xml\" );\n        assertNotNull( descriptorFile );\n        assertTrue( descriptorFile.exists() );\n\n        String siteDescriptorContent = FileUtils.fileRead( descriptorFile );\n        assertNotNull( siteDescriptorContent );\n        assertTrue( siteDescriptorContent.indexOf( \"${project.name}\" ) != -1 );\n\n        SiteTool siteTool = (SiteTool) lookup( SiteTool.ROLE );\n        siteDescriptorContent =\n            siteTool.getInterpolatedSiteDescriptorContent( new HashMap<String, String>(), siteMojo.project,\n                                                           siteDescriptorContent, \"UTF-8\", \"UTF-8\" );\n        assertNotNull( siteDescriptorContent );\n        assertTrue( siteDescriptorContent.indexOf( \"${project.name}\" ) == -1 );\n    }","commit_id":"f8d7c6ebb7124878cb6cd69ada3bc383c5354f15","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Extract a DocumentTOC from a DecorationModel.\n     *\n     * @param decorationModel a DecorationModel. May be null.\n     * @return a DocumentTOC, always non-null.\n     */\n    private static DocumentTOC getDocumentTOC( DecorationModel decorationModel )\n    {\n        final DocumentTOC toc = new DocumentTOC();\n\n        if ( decorationModel != null && decorationModel.getMenus() != null )\n        {\n            for ( final Iterator it = decorationModel.getMenus().iterator(); it.hasNext(); )\n            {\n                final Menu menu = (Menu) it.next();\n\n                for ( final Iterator it2 = menu.getItems().iterator(); it2.hasNext(); )\n                {\n                    final MenuItem item = (MenuItem) it2.next();\n\n                    final DocumentTOCItem documentTOCItem = new DocumentTOCItem();\n                    documentTOCItem.setName( item.getName() );\n                    documentTOCItem.setRef( item.getHref() );\n                    toc.addItem( documentTOCItem );\n                }\n            }\n        }\n\n        return toc;\n    }","id":106747,"modified_method":"/**\n     * Extract a DocumentTOC from a DecorationModel.\n     *\n     * @param decorationModel a DecorationModel. May be null.\n     * @return a DocumentTOC, always non-null.\n     */\n    private static DocumentTOC getDocumentTOC( DecorationModel decorationModel )\n    {\n        final DocumentTOC toc = new DocumentTOC();\n\n        if ( decorationModel != null && decorationModel.getMenus() != null )\n        {\n            for ( final Menu menu  : decorationModel.getMenus() )\n            {\n                for ( final MenuItem item : menu.getItems() )\n                {\n                    final DocumentTOCItem documentTOCItem = new DocumentTOCItem();\n                    documentTOCItem.setName( item.getName() );\n                    documentTOCItem.setRef( item.getHref() );\n                    toc.addItem( documentTOCItem );\n                }\n            }\n        }\n\n        return toc;\n    }","commit_id":"94399678dc49ca21bb0e5aca1b0748156e3ae7b9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Wrap the list of project {@link Developer} to a list of {@link DocumentAuthor}.\n     *\n     * @param project the MavenProject to extract the authors from.\n     * @return a list of DocumentAuthors from the project developers.\n     * Returns null if project is null or contains no developers.\n     */\n    private static List getAuthors( MavenProject project )\n    {\n        if ( project == null || project.getDevelopers() == null )\n        {\n            return null;\n        }\n\n        final List ret = new ArrayList( 4 );\n\n        for ( final Iterator it = project.getDevelopers().iterator(); it.hasNext(); )\n        {\n            final Developer developer = (Developer) it.next();\n\n            final DocumentAuthor author = new DocumentAuthor();\n            author.setName( developer.getName() );\n            author.setEmail( developer.getEmail() );\n            author.setCompanyName( developer.getOrganization() );\n            StringBuilder roles = null;\n\n            for ( final Iterator it2 = developer.getRoles().iterator(); it2.hasNext(); )\n            {\n                final String role = (String) it2.next();\n\n                if ( roles == null )\n                {\n                    roles = new StringBuilder( 32 );\n                }\n\n                roles.append( role );\n\n                if ( it2.hasNext() )\n                {\n                    roles.append( ',' ).append( ' ' );\n                }\n            }\n            if ( roles != null )\n            {\n                author.setPosition( roles.toString() );\n            }\n\n            ret.add( author );\n        }\n\n        return ret;\n    }","id":106748,"modified_method":"/**\n     * Wrap the list of project {@link Developer} to a list of {@link DocumentAuthor}.\n     *\n     * @param project the MavenProject to extract the authors from.\n     * @return a list of DocumentAuthors from the project developers.\n     * Returns null if project is null or contains no developers.\n     */\n    private static List<DocumentAuthor> getAuthors( MavenProject project )\n    {\n        if ( project == null || project.getDevelopers() == null )\n        {\n            return null;\n        }\n\n        final List<DocumentAuthor> ret = new ArrayList<DocumentAuthor>( 4 );\n\n        for ( final Iterator it = project.getDevelopers().iterator(); it.hasNext(); )\n        {\n            final Developer developer = (Developer) it.next();\n\n            final DocumentAuthor author = new DocumentAuthor();\n            author.setName( developer.getName() );\n            author.setEmail( developer.getEmail() );\n            author.setCompanyName( developer.getOrganization() );\n            StringBuilder roles = null;\n\n            for ( final Iterator it2 = developer.getRoles().iterator(); it2.hasNext(); )\n            {\n                final String role = (String) it2.next();\n\n                if ( roles == null )\n                {\n                    roles = new StringBuilder( 32 );\n                }\n\n                roles.append( role );\n\n                if ( it2.hasNext() )\n                {\n                    roles.append( ',' ).append( ' ' );\n                }\n            }\n            if ( roles != null )\n            {\n                author.setPosition( roles.toString() );\n            }\n\n            ret.add( author );\n        }\n\n        return ret;\n    }","commit_id":"94399678dc49ca21bb0e5aca1b0748156e3ae7b9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n\t * @param property\n\t * @param manyToOne\n\t */\n\tprivate static void bindManyToOneValues(GrailsDomainClassProperty property, ManyToOne manyToOne) {\n\t\t// TODO configure fetching\n\t\tmanyToOne.setFetchMode(FetchMode.DEFAULT);\n\t\t// TODO configure lazy loading\n\t\tmanyToOne.setLazy(true);\n\t\t\n\n\t\t// set referenced entity\n\t\tmanyToOne.setReferencedEntityName( property.getReferencedPropertyType().getName() );\n\t\tmanyToOne.setIgnoreNotFound(true);\n\t}","id":106749,"modified_method":"/**\n\t * @param property\n\t * @param manyToOne\n\t */\n\tprivate static void bindManyToOneValues(GrailsDomainClassProperty property, ManyToOne manyToOne) {\n\t\t// TODO configure fetching\n\t\tmanyToOne.setFetchMode(FetchMode.DEFAULT);\n\t\t// TODO configure lazy loading\n        ColumnConfig cc = getColumnConfig(property);\n\n        if(cc != null) {\n           manyToOne.setLazy(cc.getLazy());\n        }\n        else {\n            manyToOne.setLazy(true);\n        }\n\n\n\t\t// set referenced entity\n\t\tmanyToOne.setReferencedEntityName( property.getReferencedPropertyType().getName() );\n\t\tmanyToOne.setIgnoreNotFound(true);\n\t}","commit_id":"0654a70fbeff55f9610b92ab3d612e1f62b4deeb","url":"https://github.com/grails/grails-core"},{"original_method":"private static void bindCollectionSecondPass(GrailsDomainClassProperty property, Mappings mappings, Map persistentClasses, Collection collection, Map inheritedMetas) {\n\n\t\tPersistentClass associatedClass = null;\n\t\t\n\t\tif(LOG.isDebugEnabled())\n\t\t\tLOG.debug( \"Mapping collection: \"\n\t\t\t\t\t+ collection.getRole()\n\t\t\t\t\t+ \" -> \"\n\t\t\t\t\t+ collection.getCollectionTable().getName() );\n\t\t\n\t\t// Configure one-to-many\n\t\tif(collection.isOneToMany() ) {\n\t\t\tOneToMany oneToMany = (OneToMany)collection.getElement();\n\t\t\tString associatedClassName = oneToMany.getReferencedEntityName();\n\t\t\t\n\t\t\tassociatedClass = (PersistentClass)persistentClasses.get(associatedClassName);\n\t\t\t// if there is no persistent class for the association throw\n\t\t\t// exception\n\t\t\tif(associatedClass == null) {\n\t\t\t\tthrow new MappingException( \"Association references unmapped class: \" + oneToMany.getReferencedEntityName() );\n\t\t\t}\n\t\t\t\n\t\t\toneToMany.setAssociatedClass( associatedClass );\n\t\t\tif(!property.isManyToMany())\n\t\t\t\tcollection.setCollectionTable( associatedClass.getTable() );\n\t\t\t\n\t\t\tcollection.setLazy(true);\n\t\t\t\n\t\t\tif(isSorted(property)) {\n\t\t\t\tcollection.setSorted(true);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// setup the primary key references\n\t\tDependantValue key = createPrimaryKeyValue(property, collection,persistentClasses);\n\t\t\n\t\t// link a bidirectional relationship\t\t\n\t\tif(property.isBidirectional()) {\n\t\t\tGrailsDomainClassProperty otherSide = property.getOtherSide();\n\t\t\tif(otherSide.isManyToOne()) {\n\t\t\t\tlinkBidirectionalOneToMany(collection, associatedClass, key, otherSide);\n\t\t\t}\n\t\t\telse if(property.isManyToMany() /*&& property.isOwningSide()*/) {\n\t\t\t\tbindDependentKeyValue(property,key,mappings);\n\t\t\t}\n\t\t}\t\n\t\telse {\n\t\t\tbindDependentKeyValue(property,key,mappings);\n\t\t}\t\t\t\t\n\t\tcollection.setKey( key );\n\n\t\t\n\t\t// if we have a many-to-many\n\t\tif(property.isManyToMany() ) {\n\t\t\tGrailsDomainClassProperty otherSide = property.getOtherSide();\n\t\t\t\n\t\t\tif(property.isBidirectional()) {\n\t\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\t\tLOG.debug(\"[GrailsDomainBinder] Mapping other side \"+otherSide.getDomainClass().getName()+\".\"+otherSide.getName()+\" -> \"+collection.getCollectionTable().getName()+\" as ManyToOne\");\n\t\t\t\tManyToOne element = new ManyToOne( collection.getCollectionTable() );\n\t\t\t\tbindManyToMany(otherSide, element, mappings);\n\t\t\t\tcollection.setElement(element);\t\n\t\t\t\tcollection.setLazy(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// TODO support unidirectional many-to-many\n\t\t\t}\n\t\t\t\n\t\t} else if ( isUnidirectionalOneToMany(property) ) {\n\t\t\t// for non-inverse one-to-many, with a not-null fk, add a backref!\n\t\t\tbindUnidirectionalOneToMany(property, mappings, collection);\n\t\t}\t\t\n\t}","id":106750,"modified_method":"private static void bindCollectionSecondPass(GrailsDomainClassProperty property, Mappings mappings, Map persistentClasses, Collection collection, Map inheritedMetas) {\n\n\t\tPersistentClass associatedClass = null;\n\t\t\n\t\tif(LOG.isDebugEnabled())\n\t\t\tLOG.debug( \"Mapping collection: \"\n\t\t\t\t\t+ collection.getRole()\n\t\t\t\t\t+ \" -> \"\n\t\t\t\t\t+ collection.getCollectionTable().getName() );\n\n        ColumnConfig cc = getColumnConfig(property);\n        // Configure one-to-many\n        if(collection.isOneToMany() ) {\n            OneToMany oneToMany = (OneToMany)collection.getElement();\n            String associatedClassName = oneToMany.getReferencedEntityName();\n\n            associatedClass = (PersistentClass)persistentClasses.get(associatedClassName);\n            // if there is no persistent class for the association throw\n            // exception\n            if(associatedClass == null) {\n                throw new MappingException( \"Association references unmapped class: \" + oneToMany.getReferencedEntityName() );\n            }\n\n            oneToMany.setAssociatedClass( associatedClass );\n            if(!property.isManyToMany()) {\n                collection.setCollectionTable( associatedClass.getTable() );\n            }\n\n            if(cc!=null) {\n                collection.setLazy(cc.getLazy());\n            }\n            else {\n                collection.setLazy(true);\n            }\n\n\n\t\t\tif(isSorted(property)) {\n\t\t\t\tcollection.setSorted(true);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// setup the primary key references\n\t\tDependantValue key = createPrimaryKeyValue(property, collection,persistentClasses);\n\t\t\n\t\t// link a bidirectional relationship\t\t\n\t\tif(property.isBidirectional()) {\n\t\t\tGrailsDomainClassProperty otherSide = property.getOtherSide();\n\t\t\tif(otherSide.isManyToOne()) {\n\t\t\t\tlinkBidirectionalOneToMany(collection, associatedClass, key, otherSide);\n\t\t\t}\n\t\t\telse if(property.isManyToMany() /*&& property.isOwningSide()*/) {\n\t\t\t\tbindDependentKeyValue(property,key,mappings);\n\t\t\t}\n\t\t}\t\n\t\telse {\n\t\t\tbindDependentKeyValue(property,key,mappings);\n\t\t}\t\t\t\t\n\t\tcollection.setKey( key );\n\n\t\t\n\t\t// if we have a many-to-many\n\t\tif(property.isManyToMany() ) {\n\t\t\tGrailsDomainClassProperty otherSide = property.getOtherSide();\n\t\t\t\n\t\t\tif(property.isBidirectional()) {\n\t\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\t\tLOG.debug(\"[GrailsDomainBinder] Mapping other side \"+otherSide.getDomainClass().getName()+\".\"+otherSide.getName()+\" -> \"+collection.getCollectionTable().getName()+\" as ManyToOne\");\n\t\t\t\tManyToOne element = new ManyToOne( collection.getCollectionTable() );\n\t\t\t\tbindManyToMany(otherSide, element, mappings);\n\t\t\t\tcollection.setElement(element);\n                if(cc!=null) {\n                    collection.setLazy(cc.getLazy());\n                }\n                else {\n                    collection.setLazy(true);\n                }\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// TODO support unidirectional many-to-many\n\t\t\t}\n\t\t\t\n\t\t} else if ( isUnidirectionalOneToMany(property) ) {\n\t\t\t// for non-inverse one-to-many, with a not-null fk, add a backref!\n\t\t\tbindUnidirectionalOneToMany(property, mappings, collection);\n\t\t}\t\t\n\t}","commit_id":"0654a70fbeff55f9610b92ab3d612e1f62b4deeb","url":"https://github.com/grails/grails-core"},{"original_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    if (element instanceof AntStructuredElement) {\n      AntStructuredElement se = (AntStructuredElement)element;\n      final XmlAttribute attr = se.getSourceElement().getAttribute(\"refid\", null);\n      if (attr != null) {\n        final int offsetInPosition = attr.getValueElement().getTextRange().getStartOffset() - se.getTextRange().getStartOffset() + 1;\n        final String attrValue = attr.getValue();\n        return new PsiReference[]{\n          new AntRefIdReference(this, se, attrValue, new TextRange(offsetInPosition, offsetInPosition + attrValue.length()), attr)};\n      }\n    }\n    return PsiReference.EMPTY_ARRAY;\n  }","id":106751,"modified_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    if (!(element instanceof AntStructuredElement)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    AntStructuredElement se = (AntStructuredElement) element;\n    final XmlAttribute attr = se.getSourceElement().getAttribute(\"refid\", null);\n    if (attr == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final XmlAttributeValue valueElement = attr.getValueElement();\n    if (valueElement == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final int offsetInPosition = valueElement.getTextRange().getStartOffset() - se.getTextRange().getStartOffset() + 1;\n    final String attrValue = attr.getValue();\n    return new PsiReference[]{\n        new AntRefIdReference(this, se, attrValue, new TextRange(offsetInPosition, offsetInPosition + attrValue.length()), attr)};\n  }","commit_id":"840c37a1e3d4e80723814d5a7c89471e2effc456","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    String attributeName = ourTypesToAttributeNames.get(element.getClass());\n    if( attributeName == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    AntElement antElement = (AntElement)element;\n    final XmlAttribute attr = ((XmlTag)antElement.getSourceElement()).getAttribute(attributeName, null);\n    if (attr == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final int offsetInPosition = attr.getValueElement().getTextRange().getStartOffset() - antElement.getTextRange().getStartOffset() + 1;\n    final String attrValue = attr.getValue();\n    return new PsiReference[]{\n      new AntTargetReference(this, antElement, attrValue, new TextRange(offsetInPosition, offsetInPosition + attrValue.length()), attr)};\n  }","id":106752,"modified_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    String attributeName = ourTypesToAttributeNames.get(element.getClass());\n    if( attributeName == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    AntElement antElement = (AntElement)element;\n    final XmlAttribute attr = ((XmlTag)antElement.getSourceElement()).getAttribute(attributeName, null);\n    if (attr == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final XmlAttributeValue valueElement = attr.getValueElement();\n    if( valueElement == null ) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final int offsetInPosition = valueElement.getTextRange().getStartOffset() - antElement.getTextRange().getStartOffset() + 1;\n    final String attrValue = valueElement.getValue();\n    return new PsiReference[]{\n      new AntTargetReference(this, antElement, attrValue, new TextRange(offsetInPosition, offsetInPosition + attrValue.length()), attr)};\n  }","commit_id":"840c37a1e3d4e80723814d5a7c89471e2effc456","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAffectedByChange(final XmlChange xmlChange) {\n    return true;\n  }","id":106753,"modified_method":"public boolean isAffectedByChange(final XmlChange xmlChange) {\n    xmlChange.accept(AntSupport.getChangeVisitor());\n    return false;\n  }","commit_id":"a418c4452dabd43285a8fc2afbb30f47d5026e3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntPropertyImpl(final AntElement parent, final XmlElement sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n    AntElement propHolder = parent;\n    if (propHolder instanceof AntCall) {\n      propHolder = propHolder.getAntProject();\n    }\n    if (getName() != null) {\n      propHolder.setProperty(getName(), this);\n    } else if (getFileName() != null) {\n      final PropertiesFile file = getPropertiesFile();\n      if (file != null) {\n        for (Property prop : file.getProperties()) {\n          propHolder.setProperty(prop.getKey(), prop);\n        }\n      }\n    }\n  }","id":106754,"modified_method":"public AntPropertyImpl(final AntElement parent, final XmlElement sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n    propHolder = parent;\n    if (propHolder instanceof AntCall) {\n      propHolder = propHolder.getAntProject();\n    }\n    if (getName() != null) {\n      propHolder.setProperty(getName(), this);\n    }\n    else if (getFileName() != null) {\n      final PropertiesFile file = getPropertiesFile();\n      if (file != null) {\n        for (Property prop : file.getProperties()) {\n          propHolder.setProperty(prop.getKey(), prop);\n        }\n      }\n    }\n  }","commit_id":"a418c4452dabd43285a8fc2afbb30f47d5026e3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static AntLanguage getLanguage() {\n    if (ourAntLanguage == null) {\n      if (ourAntFileType == null) {\n        ourAntFileType = new AntFileType();\n      }\n      ourAntLanguage = (AntLanguage) ourAntFileType.getLanguage();\n    }\n    return ourAntLanguage;\n  }","id":106755,"modified_method":"public static AntLanguage getLanguage() {\n    if (ourLanguage == null) {\n      if (ourFileType == null) {\n        ourFileType = new AntFileType();\n      }\n      ourLanguage = (AntLanguage)ourFileType.getLanguage();\n    }\n    return ourLanguage;\n  }","commit_id":"a418c4452dabd43285a8fc2afbb30f47d5026e3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    final AntTarget target = (AntTarget)element;\n    final XmlAttribute attr = target.getSourceElement().getAttribute(\"depends\", null);\n    if (attr == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    int offsetInPosition = attr.getValueElement().getTextRange().getStartOffset() - target.getTextRange().getStartOffset() + 1;\n    final String str = attr.getValue();\n    final String[] targets = str.split(\",\");\n    final int length = targets.length;\n    if (length == 0) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    PsiReference[] result = new PsiReference[length];\n    for (int i = 0; i < result.length; i++) {\n      final String t = targets[i].trim();\n      result[i] = new AntTargetReference(this, target, t, new TextRange(offsetInPosition, offsetInPosition + t.length()), attr);\n      offsetInPosition += t.length() + 1;\n    }\n    return result;\n  }","id":106756,"modified_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement element) {\n    final AntTarget target = (AntTarget)element;\n    final XmlAttribute attr = target.getSourceElement().getAttribute(\"depends\", null);\n    if (attr == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    final XmlAttributeValue xmlAttributeValue = attr.getValueElement();\n    if (xmlAttributeValue == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    int offsetInPosition = xmlAttributeValue.getTextRange().getStartOffset() - target.getTextRange().getStartOffset() + 1;\n    final String str = attr.getValue();\n    final String[] targets = str.split(\",\");\n    final int length = targets.length;\n    if (length == 0) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    PsiReference[] result = new PsiReference[length];\n    for (int i = 0; i < result.length; i++) {\n      final String t = targets[i].trim();\n      result[i] = new AntTargetReference(this, target, t, new TextRange(offsetInPosition, offsetInPosition + t.length()), attr);\n      offsetInPosition += t.length() + 1;\n    }\n    return result;\n  }","commit_id":"a418c4452dabd43285a8fc2afbb30f47d5026e3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getWidth() {\n      int w = 0;\n\n      for (final Iterator<PsiType> t = myBindings.values().iterator(); t.hasNext();) {\n        final PsiType type = substitute(t.next());\n\n        if (type != null) {\n          w++;\n        }\n      }\n\n      return w;\n    }","id":106757,"modified_method":"public int getWidth() {\n      int w = 0;\n\n      for (PsiType type1 : myBindings.values()) {\n        final PsiType type = substitute(type1);\n\n        if (type != null) {\n          w++;\n        }\n      }\n\n      return w;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"BindingImpl(final int index, final PsiType type) {\n      myBindings = new HashMap<Integer, PsiType>();\n      myCyclic = type instanceof PsiTypeVariable;\n\n      myBindings.put(new Integer(index), type);\n\n      if (type instanceof Bottom) {\n        final HashSet<PsiTypeVariable> cluster = myFactory.getClusterOf(index);\n\n        if (cluster != null) {\n          for (final Iterator<PsiTypeVariable> v = cluster.iterator(); v.hasNext();) {\n            myBindings.put(new Integer(v.next().getIndex()), type);\n          }\n        }\n      }\n    }","id":106758,"modified_method":"BindingImpl(final int index, final PsiType type) {\n      myBindings = new HashMap<Integer, PsiType>();\n      myCyclic = type instanceof PsiTypeVariable;\n\n      myBindings.put(new Integer(index), type);\n\n      if (type instanceof Bottom) {\n        final HashSet<PsiTypeVariable> cluster = myFactory.getClusterOf(index);\n\n        if (cluster != null) {\n          for (PsiTypeVariable var : cluster) {\n            myBindings.put(new Integer(var.getIndex()), type);\n          }\n        }\n      }\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType apply(final PsiType type) {\n      if (type instanceof PsiTypeVariable) {\n        final PsiType t = myBindings.get(new Integer(((PsiTypeVariable)type).getIndex()));\n        return t == null ? type : t;\n      }\n      else if (type instanceof PsiArrayType) {\n        return apply(((PsiArrayType)type).getComponentType()).createArrayType();\n      }\n      else if (type instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult result = Util.resolveType(type);\n        final PsiClass theClass = result.getElement();\n        final PsiSubstitutor aSubst = result.getSubstitutor();\n\n        PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n        if (theClass != null) {\n          for (Iterator<PsiTypeParameter> p = aSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n            final PsiTypeParameter aParm = p.next();\n            final PsiType aType = aSubst.substitute(aParm);\n\n            theSubst = theSubst.put(aParm, apply(aType));\n          }\n\n          return theClass.getManager().getElementFactory().createType(theClass, theSubst);\n        }\n        else {\n          return type;\n        }\n      }\n      else if (type instanceof PsiWildcardType) {\n        final PsiWildcardType wcType = (PsiWildcardType)type;\n        final PsiType bound = wcType.getBound();\n\n        if (bound != null) {\n          final PsiType abound = apply(bound);\n\n          if (abound instanceof PsiWildcardType) {\n            return null;\n          }\n\n          return\n            wcType.isExtends()\n            ? PsiWildcardType.createExtends(PsiManager.getInstance(myProject), abound)\n            : PsiWildcardType.createSuper(PsiManager.getInstance(myProject), abound);\n        }\n\n        return type;\n      }\n      else {\n        return type;\n      }\n    }","id":106759,"modified_method":"public PsiType apply(final PsiType type) {\n      if (type instanceof PsiTypeVariable) {\n        final PsiType t = myBindings.get(new Integer(((PsiTypeVariable)type).getIndex()));\n        return t == null ? type : t;\n      }\n      else if (type instanceof PsiArrayType) {\n        return apply(((PsiArrayType)type).getComponentType()).createArrayType();\n      }\n      else if (type instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult result = Util.resolveType(type);\n        final PsiClass theClass = result.getElement();\n        final PsiSubstitutor aSubst = result.getSubstitutor();\n\n        PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n        if (theClass != null) {\n          for (final PsiTypeParameter aParm : aSubst.getSubstitutionMap().keySet()) {\n            final PsiType aType = aSubst.substitute(aParm);\n\n            theSubst = theSubst.put(aParm, apply(aType));\n          }\n\n          return theClass.getManager().getElementFactory().createType(theClass, theSubst);\n        }\n        else {\n          return type;\n        }\n      }\n      else if (type instanceof PsiWildcardType) {\n        final PsiWildcardType wcType = (PsiWildcardType)type;\n        final PsiType bound = wcType.getBound();\n\n        if (bound != null) {\n          final PsiType abound = apply(bound);\n\n          if (abound instanceof PsiWildcardType) {\n            return null;\n          }\n\n          return\n            wcType.isExtends()\n            ? PsiWildcardType.createExtends(PsiManager.getInstance(myProject), abound)\n            : PsiWildcardType.createSuper(PsiManager.getInstance(myProject), abound);\n        }\n\n        return type;\n      }\n      else {\n        return type;\n      }\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(final Binding binding) {\n      final BindingImpl b2 = (BindingImpl)binding;\n      final BindingImpl b1 = this;\n\n      int directoin = Binding.NONCOMPARABLE;\n      boolean first = true;\n\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final Integer index = new Integer(v.next().getIndex());\n\n        final PsiType x = normalize(b1.myBindings.get(index));\n        final PsiType y = normalize(b2.myBindings.get(index));\n\n        final int comp = new Object() {\n          int compare(final PsiType x, final PsiType y) {\n            final int[] kinds = new Object() {\n              private int classify(final PsiType x) {\n                if (x == null) {\n                  return 0;\n                }\n\n                if (x instanceof PsiPrimitiveType) {\n                  return 1;\n                }\n\n                if (x instanceof PsiArrayType) {\n                  return 2;\n                }\n\n                if (x instanceof PsiClassType) {\n                  return 3;\n                }\n\n                return 4; // Bottom\n              }\n\n              int[] classify2(final PsiType x, final PsiType y) {\n                return new int[]{classify(x), classify(y)};\n              }\n            }.classify2(x, y);\n\n            final int kindX = kinds[0];\n            final int kindY = kinds[1];\n\n            // Break your brain here...\n            if (kindX + kindY == 0) {\n              return Binding.SAME;\n            }\n\n            if (kindX * kindY == 0) {\n              if (kindX == 0) {\n                return Binding.WORSE;\n              }\n\n              return Binding.BETTER;\n            }\n\n            if (kindX * kindY == 1) {\n              if (x.equals(y)) {\n                return Binding.SAME;\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (kindX != kindY) {\n              if (kindX == 4) {\n                return Binding.WORSE;\n              }\n\n              if (kindY == 4) {\n                return Binding.BETTER;\n              }\n\n              if (kindX + kindY == 5) {\n                try {\n                  final PsiElementFactory f = PsiManager.getInstance(myProject).getElementFactory();\n                  final PsiType cloneable = f.createTypeFromText(\"java.lang.Cloneable\", null);\n                  final PsiType object = f.createTypeFromText(\"java.lang.Object\", null);\n                  final PsiType serializable = f.createTypeFromText(\"java.io.Serializable\", null);\n\n                  PsiType type;\n                  int flag;\n\n                  if (kindX == 3) {\n                    type = x;\n                    flag = Binding.WORSE;\n                  }\n                  else {\n                    type = y;\n                    flag = Binding.BETTER;\n                  }\n\n                  if (type.equals(object) || type.equals(cloneable) || type.equals(serializable)) {\n                    return flag;\n                  }\n                }\n                catch (IncorrectOperationException e) {\n                  LOG.error(e);\n                }\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (kindX == 2) {\n              return compare(((PsiArrayType)x).getComponentType(), ((PsiArrayType)y).getComponentType());\n            }\n\n            if (x.equals(y)) {\n              return Binding.SAME;\n            }\n            // End of breaking...\n\n            final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n            final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n            final PsiClass xClass = resultX.getElement();\n            final PsiClass yClass = resultY.getElement();\n\n            final PsiSubstitutor xSubst = resultX.getSubstitutor();\n            final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n            if (xClass == null || yClass == null) {\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (xClass.equals(yClass)) {\n              boolean first = true;\n              int direction = Binding.SAME;\n\n              for (Iterator<PsiTypeParameter> i = xSubst.getSubstitutionMap().keySet().iterator(); i.hasNext();) {\n                final PsiTypeParameter p = i.next();\n\n                final PsiType xParm = xSubst.substitute(p);\n                final PsiType yParm = ySubst.substitute(p);\n\n                final int comp = compare(xParm, yParm);\n\n                if (comp == Binding.NONCOMPARABLE) {\n                  return Binding.NONCOMPARABLE;\n                }\n\n                if (first) {\n                  first = false;\n                  direction = comp;\n                }\n\n                if (direction != comp) {\n                  return Binding.NONCOMPARABLE;\n                }\n              }\n\n              return direction;\n            }\n            else {\n              if (InheritanceUtil.isCorrectDescendant(xClass, yClass, true)) {\n                return Binding.BETTER;\n              }\n              else if (InheritanceUtil.isCorrectDescendant(yClass, xClass, true)) {\n                return Binding.WORSE;\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n          }\n        }.compare(x, y);\n\n        if (comp == Binding.NONCOMPARABLE) {\n          return Binding.NONCOMPARABLE;\n        }\n\n        if (first) {\n          first = false;\n          directoin = comp;\n        }\n\n        if (directoin != SAME) {\n          if (comp != Binding.SAME && directoin != comp) {\n            return Binding.NONCOMPARABLE;\n          }\n        }\n        else if (comp != SAME) {\n          directoin = comp;\n        }\n      }\n\n      return directoin;\n    }","id":106760,"modified_method":"public int compare(final Binding binding) {\n      final BindingImpl b2 = (BindingImpl)binding;\n      final BindingImpl b1 = this;\n\n      int directoin = Binding.NONCOMPARABLE;\n      boolean first = true;\n\n      for (PsiTypeVariable boundVariable : myBoundVariables) {\n        final Integer index = new Integer(boundVariable.getIndex());\n\n        final PsiType x = normalize(b1.myBindings.get(index));\n        final PsiType y = normalize(b2.myBindings.get(index));\n\n        final int comp = new Object() {\n          int compare(final PsiType x, final PsiType y) {\n            final int[] kinds = new Object() {\n              private int classify(final PsiType x) {\n                if (x == null) {\n                  return 0;\n                }\n\n                if (x instanceof PsiPrimitiveType) {\n                  return 1;\n                }\n\n                if (x instanceof PsiArrayType) {\n                  return 2;\n                }\n\n                if (x instanceof PsiClassType) {\n                  return 3;\n                }\n\n                return 4; // Bottom\n              }\n\n              int[] classify2(final PsiType x, final PsiType y) {\n                return new int[]{classify(x), classify(y)};\n              }\n            }.classify2(x, y);\n\n            final int kindX = kinds[0];\n            final int kindY = kinds[1];\n\n            // Break your brain here...\n            if (kindX + kindY == 0) {\n              return Binding.SAME;\n            }\n\n            if (kindX * kindY == 0) {\n              if (kindX == 0) {\n                return Binding.WORSE;\n              }\n\n              return Binding.BETTER;\n            }\n\n            if (kindX * kindY == 1) {\n              if (x.equals(y)) {\n                return Binding.SAME;\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (kindX != kindY) {\n              if (kindX == 4) {\n                return Binding.WORSE;\n              }\n\n              if (kindY == 4) {\n                return Binding.BETTER;\n              }\n\n              if (kindX + kindY == 5) {\n                try {\n                  final PsiElementFactory f = PsiManager.getInstance(myProject).getElementFactory();\n                  final PsiType cloneable = f.createTypeFromText(\"java.lang.Cloneable\", null);\n                  final PsiType object = f.createTypeFromText(\"java.lang.Object\", null);\n                  final PsiType serializable = f.createTypeFromText(\"java.io.Serializable\", null);\n\n                  PsiType type;\n                  int flag;\n\n                  if (kindX == 3) {\n                    type = x;\n                    flag = Binding.WORSE;\n                  }\n                  else {\n                    type = y;\n                    flag = Binding.BETTER;\n                  }\n\n                  if (type.equals(object) || type.equals(cloneable) || type.equals(serializable)) {\n                    return flag;\n                  }\n                }\n                catch (IncorrectOperationException e) {\n                  LOG.error(e);\n                }\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (kindX == 2) {\n              return compare(((PsiArrayType)x).getComponentType(), ((PsiArrayType)y).getComponentType());\n            }\n\n            if (x.equals(y)) {\n              return Binding.SAME;\n            }\n            // End of breaking...\n\n            final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n            final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n            final PsiClass xClass = resultX.getElement();\n            final PsiClass yClass = resultY.getElement();\n\n            final PsiSubstitutor xSubst = resultX.getSubstitutor();\n            final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n            if (xClass == null || yClass == null) {\n              return Binding.NONCOMPARABLE;\n            }\n\n            if (xClass.equals(yClass)) {\n              boolean first = true;\n              int direction = Binding.SAME;\n\n              for (Iterator<PsiTypeParameter> i = xSubst.getSubstitutionMap().keySet().iterator(); i.hasNext();) {\n                final PsiTypeParameter p = i.next();\n\n                final PsiType xParm = xSubst.substitute(p);\n                final PsiType yParm = ySubst.substitute(p);\n\n                final int comp = compare(xParm, yParm);\n\n                if (comp == Binding.NONCOMPARABLE) {\n                  return Binding.NONCOMPARABLE;\n                }\n\n                if (first) {\n                  first = false;\n                  direction = comp;\n                }\n\n                if (direction != comp) {\n                  return Binding.NONCOMPARABLE;\n                }\n              }\n\n              return direction;\n            }\n            else {\n              if (InheritanceUtil.isCorrectDescendant(xClass, yClass, true)) {\n                return Binding.BETTER;\n              }\n              else if (InheritanceUtil.isCorrectDescendant(yClass, xClass, true)) {\n                return Binding.WORSE;\n              }\n\n              return Binding.NONCOMPARABLE;\n            }\n          }\n        }.compare(x, y);\n\n        if (comp == Binding.NONCOMPARABLE) {\n          return Binding.NONCOMPARABLE;\n        }\n\n        if (first) {\n          first = false;\n          directoin = comp;\n        }\n\n        if (directoin != SAME) {\n          if (comp != Binding.SAME && directoin != comp) {\n            return Binding.NONCOMPARABLE;\n          }\n        }\n        else if (comp != SAME) {\n          directoin = comp;\n        }\n      }\n\n      return directoin;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiClass[] getGreatestLowerClasses(final PsiClass aClass, final PsiClass bClass) {\n    if (InheritanceUtil.isInheritorOrSelf(aClass, bClass, true)) {\n      return new PsiClass[]{aClass};\n    }\n\n    if (InheritanceUtil.isInheritorOrSelf(bClass, aClass, true)) {\n      return new PsiClass[]{bClass};\n    }\n\n    final Set<PsiClass> descendants = new LinkedHashSet<PsiClass>();\n\n    new Object() {\n      public void getGreatestLowerClasses(final PsiClass aClass, final PsiClass bClass, final Set<PsiClass> descendants) {\n        if (aClass.isInheritor(bClass, true)) {\n          descendants.add(aClass);\n        }\n        else {\n          final PsiSearchHelper helper = aClass.getManager().getSearchHelper();\n          final PsiClass[] bSubs = helper.findInheritors(bClass, GlobalSearchScope.allScope(myProject), false);\n          for (int i = 0; i < bSubs.length; i++) {\n            getGreatestLowerClasses(bSubs[i], aClass, descendants);\n          }\n        }\n      }\n    }.getGreatestLowerClasses(aClass, bClass, descendants);\n\n    return descendants.toArray(new PsiClass[descendants.size()]);\n  }","id":106761,"modified_method":"private PsiClass[] getGreatestLowerClasses(final PsiClass aClass, final PsiClass bClass) {\n    if (InheritanceUtil.isInheritorOrSelf(aClass, bClass, true)) {\n      return new PsiClass[]{aClass};\n    }\n\n    if (InheritanceUtil.isInheritorOrSelf(bClass, aClass, true)) {\n      return new PsiClass[]{bClass};\n    }\n\n    final Set<PsiClass> descendants = new LinkedHashSet<PsiClass>();\n\n    new Object() {\n      public void getGreatestLowerClasses(final PsiClass aClass, final PsiClass bClass, final Set<PsiClass> descendants) {\n        if (bClass.hasModifierProperty(PsiModifier.FINAL)) return;\n        if (aClass.isInheritor(bClass, true)) {\n          descendants.add(aClass);\n        }\n        else {\n          final PsiSearchHelper helper = aClass.getManager().getSearchHelper();\n          final PsiClass[] bSubs = helper.findInheritors(bClass, GlobalSearchScope.allScope(myProject), false);\n          for (int i = 0; i < bSubs.length; i++) {\n            getGreatestLowerClasses(bSubs[i], aClass, descendants);\n          }\n        }\n      }\n    }.getGreatestLowerClasses(aClass, bClass, descendants);\n\n    return descendants.toArray(new PsiClass[descendants.size()]);\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void merge(final Binding b, final boolean removeObject) {\n      for (final Iterator<PsiTypeVariable> v = b.getBoundVariables().iterator(); v.hasNext();) {\n        final PsiTypeVariable var = v.next();\n        final Integer index = new Integer(var.getIndex());\n\n        if (myBindings.get(index) != null) {\n          LOG.error(\"Oops... Binding conflict...\");\n        }\n        else {\n          final PsiType type = b.apply(var);\n          final PsiClassType javaLangObject =\n          PsiType.getJavaLangObject(PsiManager.getInstance(myProject), GlobalSearchScope.allScope(myProject));\n\n          if (removeObject &&\n              javaLangObject.equals(type)) {\n            final HashSet<PsiTypeVariable> cluster = myFactory.getClusterOf(var.getIndex());\n\n            if (cluster != null) {\n              for (final Iterator<PsiTypeVariable> w = cluster.iterator(); w.hasNext();) {\n                final PsiTypeVariable war = w.next();\n                final PsiType wtype = b.apply(war);\n\n                if (!javaLangObject.equals(wtype)) {\n                  myBindings.put(index, type);\n                break;\n                }\n              }\n            }\n          }\n          else {\n            myBindings.put(index, type);\n          }\n        }\n      }\n    }","id":106762,"modified_method":"public void merge(final Binding b, final boolean removeObject) {\n      for (final PsiTypeVariable var : b.getBoundVariables()) {\n        final Integer index = new Integer(var.getIndex());\n\n        if (myBindings.get(index) != null) {\n          LOG.error(\"Oops... Binding conflict...\");\n        }\n        else {\n          final PsiType type = b.apply(var);\n          final PsiClassType javaLangObject =\n            PsiType.getJavaLangObject(PsiManager.getInstance(myProject), GlobalSearchScope.allScope(myProject));\n\n          if (removeObject &&\n              javaLangObject.equals(type)) {\n            final HashSet<PsiTypeVariable> cluster = myFactory.getClusterOf(var.getIndex());\n\n            if (cluster != null) {\n              for (final PsiTypeVariable war : cluster) {\n                final PsiType wtype = b.apply(war);\n\n                if (!javaLangObject.equals(wtype)) {\n                  myBindings.put(index, type);\n                  break;\n                }\n              }\n            }\n          }\n          else {\n            myBindings.put(index, type);\n          }\n        }\n      }\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Binding reduceRecursive() {\n      final BindingImpl binding = (BindingImpl)create();\n\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final PsiTypeVariable var = v.next();\n        final Integer index = new Integer(var.getIndex());\n        final PsiType type = myBindings.get(index);\n\n        if (type != null) {\n          class Verifier extends PsiExtendedTypeVisitor {\n            boolean myFlag = false;\n\n            public Object visitTypeVariable(final PsiTypeVariable var) {\n              if (var.getIndex() == index.intValue()) {\n                myFlag = true;\n              }\n\n              return null;\n            }\n          }\n\n          final Verifier verifier = new Verifier();\n\n          type.accept(verifier);\n\n          if (verifier.myFlag) {\n            myBindings.put(index, Bottom.BOTTOM);\n            binding.myBindings.put(index, Bottom.BOTTOM);\n          }\n          else {\n            binding.myBindings.put(index, type);\n          }\n        }\n        else {\n          binding.myBindings.put(index, type);\n        }\n      }\n\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final PsiTypeVariable var = v.next();\n        final Integer index = new Integer(var.getIndex());\n        final PsiType type = myBindings.get(index);\n\n        if (type != null) {\n          myBindings.put(index, binding.apply(type));\n        }\n      }\n\n      return this;\n    }","id":106763,"modified_method":"public Binding reduceRecursive() {\n      final BindingImpl binding = (BindingImpl)create();\n\n      for (final PsiTypeVariable var : myBoundVariables) {\n        final Integer index = new Integer(var.getIndex());\n        final PsiType type = myBindings.get(index);\n\n        if (type != null) {\n          class Verifier extends PsiExtendedTypeVisitor {\n            boolean myFlag = false;\n\n            public Object visitTypeVariable(final PsiTypeVariable var) {\n              if (var.getIndex() == index.intValue()) {\n                myFlag = true;\n              }\n\n              return null;\n            }\n          }\n\n          final Verifier verifier = new Verifier();\n\n          type.accept(verifier);\n\n          if (verifier.myFlag) {\n            myBindings.put(index, Bottom.BOTTOM);\n            binding.myBindings.put(index, Bottom.BOTTOM);\n          }\n          else {\n            binding.myBindings.put(index, type);\n          }\n        }\n        else {\n          binding.myBindings.put(index, type);\n        }\n      }\n\n      for (final PsiTypeVariable var : myBoundVariables) {\n        final Integer index = new Integer(var.getIndex());\n        final PsiType type = myBindings.get(index);\n\n        if (type != null) {\n          myBindings.put(index, binding.apply(type));\n        }\n      }\n\n      return this;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Binding unify(final PsiType x, final PsiType y, final Unifier unifier) {\n    final int indicator = (x instanceof PsiTypeVariable ? 1 : 0) + (y instanceof PsiTypeVariable ? 2 : 0);\n\n    switch (indicator) {\n    case 0:\n           if (x instanceof PsiWildcardType || y instanceof PsiWildcardType) {\n             return unifier.unify(x, y);\n           }\n           else if (x instanceof PsiArrayType || y instanceof PsiArrayType) {\n             final PsiType xType = x instanceof PsiArrayType ? ((PsiArrayType)x).getComponentType() : x;\n             final PsiType yType = y instanceof PsiArrayType ? ((PsiArrayType)y).getComponentType() : y;\n\n             return unify(xType, yType, unifier);\n           }\n           else if (x instanceof PsiClassType && y instanceof PsiClassType) {\n             final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n             final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n             final PsiClass xClass = resultX.getElement();\n             final PsiClass yClass = resultY.getElement();\n\n             if (xClass != null && yClass != null) {\n               final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n               final PsiSubstitutor xSubst = resultX.getSubstitutor();\n\n               if (!xClass.equals(yClass)) {\n                 return null;\n               }\n\n               Binding b = create();\n\n               for (Iterator<PsiTypeParameter> p = xSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n                 final PsiTypeParameter aParm = p.next();\n                 final PsiType xType = xSubst.substitute(aParm);\n                 final PsiType yType = ySubst.substitute(aParm);\n\n                 final Binding b1 = unify(xType, yType, unifier);\n\n                 if (b1 == null) {\n                   return null;\n                 }\n\n                 b = b.compose(b1);\n               }\n\n               return b;\n             }\n           }\n           else if (y instanceof Bottom) {\n             return create();\n           }\n           else {\n             return null;\n           }\n\n    default:\n           return unifier.unify(x, y);\n    }\n  }","id":106764,"modified_method":"private Binding unify(final PsiType x, final PsiType y, final Unifier unifier) {\n    final int indicator = (x instanceof PsiTypeVariable ? 1 : 0) + (y instanceof PsiTypeVariable ? 2 : 0);\n\n    switch (indicator) {\n    case 0:\n           if (x instanceof PsiWildcardType || y instanceof PsiWildcardType) {\n             return unifier.unify(x, y);\n           }\n           else if (x instanceof PsiArrayType || y instanceof PsiArrayType) {\n             final PsiType xType = x instanceof PsiArrayType ? ((PsiArrayType)x).getComponentType() : x;\n             final PsiType yType = y instanceof PsiArrayType ? ((PsiArrayType)y).getComponentType() : y;\n\n             return unify(xType, yType, unifier);\n           }\n           else if (x instanceof PsiClassType && y instanceof PsiClassType) {\n             final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n             final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n             final PsiClass xClass = resultX.getElement();\n             final PsiClass yClass = resultY.getElement();\n\n             if (xClass != null && yClass != null) {\n               final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n               final PsiSubstitutor xSubst = resultX.getSubstitutor();\n\n               if (!xClass.equals(yClass)) {\n                 return null;\n               }\n\n               Binding b = create();\n\n               for (final PsiTypeParameter aParm : xSubst.getSubstitutionMap().keySet()) {\n                 final PsiType xType = xSubst.substitute(aParm);\n                 final PsiType yType = ySubst.substitute(aParm);\n\n                 final Binding b1 = unify(xType, yType, unifier);\n\n                 if (b1 == null) {\n                   return null;\n                 }\n\n                 b = b.compose(b1);\n               }\n\n               return b;\n             }\n           }\n           else if (y instanceof Bottom) {\n             return create();\n           }\n           else {\n             return null;\n           }\n\n    default:\n           return unifier.unify(x, y);\n    }\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Binding balance(final PsiType x, final PsiType y, final Balancer balancer, final HashSet<Constraint> constraints) {\n    final int indicator = (x instanceof PsiTypeVariable ? 1 : 0) + (y instanceof PsiTypeVariable ? 2 : 0);\n\n    switch (indicator) {\n    case 0:\n         if (x instanceof PsiWildcardType || y instanceof PsiWildcardType) {\n           final PsiType xType = x instanceof PsiWildcardType ? ((PsiWildcardType)x).getBound() : x;\n           final PsiType yType = y instanceof PsiWildcardType ? ((PsiWildcardType)y).getBound() : y;\n\n           switch ((x instanceof PsiWildcardType ? 1 : 0) + (y instanceof PsiWildcardType ? 2 : 0)) {\n           case 1:\n                if (((PsiWildcardType)x).isExtends()) {\n                  /* ? extends T1, T2 */\n                  return null;\n                }\n                else {\n                  /* ? super T1, T2 */\n                  if (!xType.getCanonicalText().equals(\"java.lang.Object\")) {\n                    return null;\n                  }\n                  return create();\n                }\n\n           case 2:\n                if (((PsiWildcardType)y).isExtends()) {\n                  /* T1, ? extends T2 */\n                 if (yType instanceof PsiTypeVariable) {\n                    return create((PsiTypeVariable)yType, PsiWildcardType.createSuper(PsiManager.getInstance(myProject), xType));\n                  }\n                  else {\n                    if (constraints != null) {\n                      constraints.add(new Subtype(xType, yType));\n                    }\n\n                    return balance(xType, yType, balancer, constraints);\n                  }\n                }\n                else {/* T1, ? super T2 */\n                  if (yType instanceof PsiTypeVariable) {\n                    return create(((PsiTypeVariable)yType), PsiWildcardType.createExtends(PsiManager.getInstance(myProject), xType));\n                  }\n                  else {\n                    if (constraints != null) {\n                      constraints.add(new Subtype(yType, xType));\n                    }\n\n                    return balance(xType, yType, balancer, constraints);\n                  }\n                }\n\n           case 3:\n                switch ((((PsiWildcardType)x).isExtends() ? 0 : 1) + (((PsiWildcardType)y).isExtends() ? 0 : 2)) {\n                case 0: /* ? super T1, ? super T2 */\n                     if (constraints != null) {\n                       constraints.add(new Subtype(yType, xType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n\n                case 1: /* ? extends T1, ? super T2 */\n                     if (constraints != null) {\n                       constraints.add(new Subtype(xType, yType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n\n                case 2: /* ? super T1, ? extends T2*/\n                     return null;\n\n                case 3: /* ? extends T1, ? extends T2*/\n                     if (constraints != null) {\n                       constraints.add(new Subtype(xType, yType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n                }\n           }\n\n           return create();\n         }\n         else if (x instanceof PsiArrayType || y instanceof PsiArrayType) {\n           final PsiType xType = x instanceof PsiArrayType ? ((PsiArrayType)x).getComponentType() : x;\n           final PsiType yType = y instanceof PsiArrayType ? ((PsiArrayType)y).getComponentType() : y;\n\n           return balance(xType, yType, balancer, constraints);\n         }\n         else if (x instanceof PsiClassType && y instanceof PsiClassType) {\n           final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n           final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n           final PsiClass xClass = resultX.getElement();\n           final PsiClass yClass = resultY.getElement();\n\n           if (xClass != null && yClass != null) {\n             final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n             PsiSubstitutor xSubst = TypeConversionUtil.getClassSubstitutor(yClass, xClass, resultX.getSubstitutor());\n             if (xSubst == null) return null;\n\n             Binding b = create();\n\n             for (Iterator<PsiTypeParameter> p = xSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n               final PsiTypeParameter aParm = p.next();\n               final PsiType xType = xSubst.substitute(aParm);\n               final PsiType yType = ySubst.substitute(aParm);\n\n               final Binding b1 = unify(xType, yType, new Unifier() {\n                                          public Binding unify(final PsiType x, final PsiType y) {\n                                            return balance(x, y, balancer, constraints);\n                                          }\n                                        });\n\n               if (b1 == null) {\n                 return null;\n               }\n\n               b = b.compose(b1);\n             }\n\n             return b;\n           }\n         }\n         else if (y instanceof Bottom) {\n           return create();\n         }\n         else {\n           return null;\n         }\n    break;\n\n    case 1:\n         return balancer.varType((PsiTypeVariable)x, y);\n\n    case 2:\n         return balancer.typeVar(x, (PsiTypeVariable)y);\n\n    case 3:\n         return balancer.varVar((PsiTypeVariable)x, (PsiTypeVariable)y);\n    }\n\n    return null;\n  }","id":106765,"modified_method":"public Binding balance(final PsiType x, final PsiType y, final Balancer balancer, final HashSet<Constraint> constraints) {\n    final int indicator = (x instanceof PsiTypeVariable ? 1 : 0) + (y instanceof PsiTypeVariable ? 2 : 0);\n\n    switch (indicator) {\n    case 0:\n         if (x instanceof PsiWildcardType || y instanceof PsiWildcardType) {\n           final PsiType xType = x instanceof PsiWildcardType ? ((PsiWildcardType)x).getBound() : x;\n           final PsiType yType = y instanceof PsiWildcardType ? ((PsiWildcardType)y).getBound() : y;\n\n           switch ((x instanceof PsiWildcardType ? 1 : 0) + (y instanceof PsiWildcardType ? 2 : 0)) {\n           case 1:\n                if (((PsiWildcardType)x).isExtends()) {\n                  /* ? extends T1, T2 */\n                  return null;\n                }\n                else {\n                  /* ? super T1, T2 */\n                  if (!xType.getCanonicalText().equals(\"java.lang.Object\")) {\n                    return null;\n                  }\n                  return create();\n                }\n\n           case 2:\n                if (((PsiWildcardType)y).isExtends()) {\n                  /* T1, ? extends T2 */\n                 if (yType instanceof PsiTypeVariable) {\n                    return create((PsiTypeVariable)yType, PsiWildcardType.createSuper(PsiManager.getInstance(myProject), xType));\n                  }\n                  else {\n                    if (constraints != null) {\n                      constraints.add(new Subtype(xType, yType));\n                    }\n\n                    return balance(xType, yType, balancer, constraints);\n                  }\n                }\n                else {/* T1, ? super T2 */\n                  if (yType instanceof PsiTypeVariable) {\n                    return create(((PsiTypeVariable)yType), PsiWildcardType.createExtends(PsiManager.getInstance(myProject), xType));\n                  }\n                  else {\n                    if (constraints != null) {\n                      constraints.add(new Subtype(yType, xType));\n                    }\n\n                    return balance(xType, yType, balancer, constraints);\n                  }\n                }\n\n           case 3:\n                switch ((((PsiWildcardType)x).isExtends() ? 0 : 1) + (((PsiWildcardType)y).isExtends() ? 0 : 2)) {\n                case 0: /* ? super T1, ? super T2 */\n                     if (constraints != null) {\n                       constraints.add(new Subtype(yType, xType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n\n                case 1: /* ? extends T1, ? super T2 */\n                     if (constraints != null) {\n                       constraints.add(new Subtype(xType, yType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n\n                case 2: /* ? super T1, ? extends T2*/\n                     return null;\n\n                case 3: /* ? extends T1, ? extends T2*/\n                     if (constraints != null) {\n                       constraints.add(new Subtype(xType, yType));\n                     }\n                     return balance(xType, yType, balancer, constraints);\n                }\n           }\n\n           return create();\n         }\n         else if (x instanceof PsiArrayType || y instanceof PsiArrayType) {\n           final PsiType xType = x instanceof PsiArrayType ? ((PsiArrayType)x).getComponentType() : x;\n           final PsiType yType = y instanceof PsiArrayType ? ((PsiArrayType)y).getComponentType() : y;\n\n           return balance(xType, yType, balancer, constraints);\n         }\n         else if (x instanceof PsiClassType && y instanceof PsiClassType) {\n           final PsiClassType.ClassResolveResult resultX = Util.resolveType(x);\n           final PsiClassType.ClassResolveResult resultY = Util.resolveType(y);\n\n           final PsiClass xClass = resultX.getElement();\n           final PsiClass yClass = resultY.getElement();\n\n           if (xClass != null && yClass != null) {\n             final PsiSubstitutor ySubst = resultY.getSubstitutor();\n\n             PsiSubstitutor xSubst = TypeConversionUtil.getClassSubstitutor(yClass, xClass, resultX.getSubstitutor());\n             if (xSubst == null) return null;\n\n             Binding b = create();\n\n             for (final PsiTypeParameter aParm : xSubst.getSubstitutionMap().keySet()) {\n               final PsiType xType = xSubst.substitute(aParm);\n               final PsiType yType = ySubst.substitute(aParm);\n\n               final Binding b1 = unify(xType, yType, new Unifier() {\n                 public Binding unify(final PsiType x, final PsiType y) {\n                   return balance(x, y, balancer, constraints);\n                 }\n               });\n\n               if (b1 == null) {\n                 return null;\n               }\n\n               b = b.compose(b1);\n             }\n\n             return b;\n           }\n         }\n         else if (y instanceof Bottom) {\n           return create();\n         }\n         else {\n           return null;\n         }\n    break;\n\n    case 1:\n         return balancer.varType((PsiTypeVariable)x, y);\n\n    case 2:\n         return balancer.typeVar(x, (PsiTypeVariable)y);\n\n    case 3:\n         return balancer.varVar((PsiTypeVariable)x, (PsiTypeVariable)y);\n    }\n\n    return null;\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType substitute(final PsiType t) {\n      if (t instanceof PsiWildcardType) {\n        final PsiWildcardType wcType = (PsiWildcardType)t;\n        final PsiType bound = wcType.getBound();\n\n        if (bound == null) {\n          return t;\n        }\n\n        final PsiManager manager = PsiManager.getInstance(myProject);\n        final PsiType subst = substitute(bound);\n        if (subst == null) return null;\n        return subst instanceof PsiWildcardType ? subst : wcType.isExtends()\n                                                          ? PsiWildcardType.createExtends(manager, subst)\n                                                          : PsiWildcardType.createSuper(manager, subst);\n      }\n      else if (t instanceof PsiTypeVariable) {\n        final PsiType b = apply(t);\n\n        if (b instanceof Bottom || b instanceof PsiTypeVariable) {\n          return null;\n        }\n\n        return substitute(b);\n      }\n      else if (t instanceof Bottom) {\n        return null;\n      }\n      else if (t instanceof PsiArrayType) {\n        return substitute(((PsiArrayType)t).getComponentType()).createArrayType();\n      }\n      else if (t instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult result = ((PsiClassType)t).resolveGenerics();\n\n        final PsiClass aClass = result.getElement();\n        final PsiSubstitutor aSubst = result.getSubstitutor();\n\n        if (aClass != null) {\n          PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n          for (final Iterator<PsiTypeParameter> p = aSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n            final PsiTypeParameter parm = p.next();\n            final PsiType type = aSubst.substitute(parm);\n\n            theSubst = theSubst.put(parm, substitute(type));\n          }\n\n          return aClass.getManager().getElementFactory().createType(aClass, theSubst);\n        }\n      }\n      return t;\n    }","id":106766,"modified_method":"public PsiType substitute(final PsiType t) {\n      if (t instanceof PsiWildcardType) {\n        final PsiWildcardType wcType = (PsiWildcardType)t;\n        final PsiType bound = wcType.getBound();\n\n        if (bound == null) {\n          return t;\n        }\n\n        final PsiManager manager = PsiManager.getInstance(myProject);\n        final PsiType subst = substitute(bound);\n        if (subst == null) return null;\n        return subst instanceof PsiWildcardType ? subst : wcType.isExtends()\n                                                          ? PsiWildcardType.createExtends(manager, subst)\n                                                          : PsiWildcardType.createSuper(manager, subst);\n      }\n      else if (t instanceof PsiTypeVariable) {\n        final PsiType b = apply(t);\n\n        if (b instanceof Bottom || b instanceof PsiTypeVariable) {\n          return null;\n        }\n\n        return substitute(b);\n      }\n      else if (t instanceof Bottom) {\n        return null;\n      }\n      else if (t instanceof PsiArrayType) {\n        return substitute(((PsiArrayType)t).getComponentType()).createArrayType();\n      }\n      else if (t instanceof PsiClassType) {\n        final PsiClassType.ClassResolveResult result = ((PsiClassType)t).resolveGenerics();\n\n        final PsiClass aClass = result.getElement();\n        final PsiSubstitutor aSubst = result.getSubstitutor();\n\n        if (aClass != null) {\n          PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n          for (final PsiTypeParameter parm : aSubst.getSubstitutionMap().keySet()) {\n            final PsiType type = aSubst.substitute(parm);\n\n            theSubst = theSubst.put(parm, substitute(type));\n          }\n\n          return aClass.getManager().getElementFactory().createType(aClass, theSubst);\n        }\n      }\n      return t;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Binding compose(final Binding b) {\n      LOG.assertTrue(b instanceof BindingImpl);\n\n      final BindingImpl b1 = this;\n      final BindingImpl b2 = (BindingImpl)b;\n\n      final BindingImpl b3 = new BindingImpl();\n\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final Integer i = new Integer(v.next().getIndex());\n\n        final PsiType b1i = b1.myBindings.get(i);\n        final PsiType b2i = b2.myBindings.get(i);\n\n        final int flag = (b1i == null ? 0 : 1) + (b2i == null ? 0 : 2);\n\n        switch (flag) {\n        case 0:\n        break;\n\n        case 1: /* b1(i)\\b2(i) */\n             {\n               final PsiType type = b2.apply(b1i);\n\n               if (type == null) {\n                 return null;\n               }\n\n               b3.myBindings.put(i, type);\n               b3.myCyclic = type instanceof PsiTypeVariable;\n             }\n        break;\n\n        case 2: /* b2(i)\\b1(i) */\n             {\n               final PsiType type = b1.apply(b2i);\n\n               if (type == null) {\n                 return null;\n               }\n\n               b3.myBindings.put(i, type);\n               b3.myCyclic = type instanceof PsiTypeVariable;\n             }\n        break;\n\n        case 3:  /* b2(i) \\cap b1(i) */\n             {\n               final Binding common = rise(b1i, b2i, null);\n\n               if (common == null) {\n                 return null;\n               }\n\n               final PsiType type = common.apply(b1i);\n               if (type == null) {\n                 return null;\n               }\n\n               final PsiType type1 = type;//b2.apply(type);\n\n               if (type1 == null) {\n                 return null;\n               }\n\n               b3.myBindings.put(i, type1);\n               b3.myCyclic = type instanceof PsiTypeVariable;\n             }\n        }\n      }\n\n      return b3;\n    }","id":106767,"modified_method":"public Binding compose(final Binding b) {\n      LOG.assertTrue(b instanceof BindingImpl);\n\n      final BindingImpl b1 = this;\n      final BindingImpl b2 = (BindingImpl)b;\n\n      final BindingImpl b3 = new BindingImpl();\n\n      for (PsiTypeVariable boundVariable : myBoundVariables) {\n        final Integer i = new Integer(boundVariable.getIndex());\n\n        final PsiType b1i = b1.myBindings.get(i);\n        final PsiType b2i = b2.myBindings.get(i);\n\n        final int flag = (b1i == null ? 0 : 1) + (b2i == null ? 0 : 2);\n\n        switch (flag) {\n          case 0:\n            break;\n\n          case 1: /* b1(i)\\b2(i) */\n            {\n              final PsiType type = b2.apply(b1i);\n\n              if (type == null) {\n                return null;\n              }\n\n              b3.myBindings.put(i, type);\n              b3.myCyclic = type instanceof PsiTypeVariable;\n            }\n            break;\n\n          case 2: /* b2(i)\\b1(i) */\n            {\n              final PsiType type = b1.apply(b2i);\n\n              if (type == null) {\n                return null;\n              }\n\n              b3.myBindings.put(i, type);\n              b3.myCyclic = type instanceof PsiTypeVariable;\n            }\n            break;\n\n          case 3:  /* b2(i) \\cap b1(i) */\n          {\n            final Binding common = rise(b1i, b2i, null);\n\n            if (common == null) {\n              return null;\n            }\n\n            final PsiType type = common.apply(b1i);\n            if (type == null) {\n              return null;\n            }\n\n            final PsiType type1 = type;//b2.apply(type);\n\n            if (type1 == null) {\n              return null;\n            }\n\n            b3.myBindings.put(i, type1);\n            b3.myCyclic = type instanceof PsiTypeVariable;\n          }\n        }\n      }\n\n      return b3;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n      final StringBuffer buffer = new StringBuffer();\n\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final Integer i = new Integer(v.next().getIndex());\n        final PsiType binding = myBindings.get(i);\n\n        if (binding != null) {\n          buffer.append(\"#\" + i + \" -> \" + binding.getPresentableText() + \"; \");\n        }\n      }\n\n      return buffer.toString();\n    }","id":106768,"modified_method":"public String toString() {\n      final StringBuffer buffer = new StringBuffer();\n\n      for (PsiTypeVariable boundVariable : myBoundVariables) {\n        final Integer i = new Integer(boundVariable.getIndex());\n        final PsiType binding = myBindings.get(i);\n\n        if (binding != null) {\n          buffer.append(\"#\" + i + \" -> \" + binding.getPresentableText() + \"; \");\n        }\n      }\n\n      return buffer.toString();\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isValid() {\n      for (final Iterator<PsiTypeVariable> v = myBoundVariables.iterator(); v.hasNext();) {\n        final PsiTypeVariable var = v.next();\n        final PsiType type = substitute(var);\n\n        if (!var.isValidInContext(type)) {\n          return false;\n        }\n      }\n\n      return true;\n    }","id":106769,"modified_method":"public boolean isValid() {\n      for (final PsiTypeVariable var : myBoundVariables) {\n        final PsiType type = substitute(var);\n\n        if (!var.isValidInContext(type)) {\n          return false;\n        }\n      }\n\n      return true;\n    }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getReport() {\n    return \"Items cooked : \" + getRatio(myCookedNumber, myVictims.size()) + \"\\n\" +\n           \"Casts removed: \" + getRatio(myCastsRemoved, myCastsNumber) + \"\\n\";\n  }","id":106770,"modified_method":"public String getReport() {\n    return \"Items generified: \" + getRatio(myCookedNumber, myVictims.size()) +\n           \", casts removed: \" + getRatio(myCastsRemoved, myCastsNumber);\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addUsage(final System system, final PsiElement element) {\n\n    class TypeEvaluator {\n      PsiType evaluateType(final PsiExpression expr) {\n        if (expr instanceof PsiArrayAccessExpression && !mySettings.preserveRawArrays()) {\n          final PsiType at = evaluateType(((PsiArrayAccessExpression)expr).getArrayExpression());\n\n          if (at instanceof PsiArrayType) {\n            return ((PsiArrayType)at).getComponentType();\n          }\n        }\n        else if (expr instanceof PsiAssignmentExpression) {\n          return evaluateType(((PsiAssignmentExpression)expr).getLExpression());\n        }\n        else if (expr instanceof PsiCallExpression) {\n          final PsiCallExpression call = ((PsiCallExpression)expr);\n          final PsiMethod method = call.resolveMethod();\n\n          if (method != null) {\n            final PsiClass aClass = method.getContainingClass();\n            final PsiTypeParameter[] aTypeParms = method.getTypeParameterList().getTypeParameters();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            final PsiExpression[] arguments = call.getArgumentList().getExpressions();\n            final PsiExpression aQualifier = expr instanceof PsiMethodCallExpression\n              ? ((PsiMethodCallExpression)expr).getMethodExpression().getQualifierExpression()\n              : null;\n            final HashSet<PsiTypeParameter> typeParameters = new HashSet<PsiTypeParameter>();\n\n            for (int i = 0; i < aTypeParms.length; i++) {\n              typeParameters.add(aTypeParms[i]);\n            }\n\n            PsiSubstitutor qualifierSubstitutor = PsiSubstitutor.EMPTY;\n            PsiSubstitutor supertypeSubstitutor = PsiSubstitutor.EMPTY;\n\n            PsiType aType;\n\n            if (method.isConstructor()) {\n              if (isCooked(expr)) {\n                aType = getType(expr);\n\n                qualifierSubstitutor = Util.resolveType(aType).getSubstitutor();\n              }\n              else {\n                final PsiClass cClass = method.getContainingClass();\n                final PsiTypeParameter[] classParms = Util.getTypeParametersList(cClass);\n\n                for (int i = 0; i < classParms.length; i++) {\n                  final PsiTypeParameter classParm = classParms[i];\n                  final PsiTypeVariable var = myTypeVariableFactory.create();\n\n                  qualifierSubstitutor = qualifierSubstitutor.put(classParm, var);\n                }\n\n                aType = myManager.getElementFactory().createType(method.getContainingClass(), qualifierSubstitutor);\n              }\n            }\n            else {\n              aType = getType(method);\n            }\n\n            if (aQualifier != null) {\n              final PsiType qualifierType = evaluateType(aQualifier);\n              final PsiClassType.ClassResolveResult result = Util.resolveType(qualifierType);\n\n              if (result.getElement() != null) {\n                final PsiClass qualifierClass = result.getElement();\n\n                qualifierSubstitutor = TypeConversionUtil.getClassSubstitutor(aClass, qualifierClass, result.getSubstitutor());\n\n                if (qualifierSubstitutor != null) {\n                  aType = qualifierSubstitutor.substitute(aType);\n                }\n              }\n            }\n\n            // Bind method type parameters here. Remember: intersection types are needed :((\n            // Example:\n            //     <T extends Foo> T foo (List<T> a, List<T> b) {...}\n            //     class List<X extends Foo> {...}\n            //\n            //     List x; -- List<'a> x\n            //     List y; -- List<'b> y\n            //\n            //     foo (x, y) -- type is 'a ^ 'b. Woof, woof....\n\n            final HashMap<PsiTypeParameter, PsiType> mapping = new HashMap<PsiTypeParameter, PsiType>();\n\n            for (int i = 0; i < Math.min(parameters.length, arguments.length); i++) {\n              final PsiType argumenType = evaluateType(arguments[i]);\n\n              PsiType parmType;\n\n              if (isCooked(parameters[i])) {\n                parmType = getType(parameters[i]);\n                system.addSubtypeConstraint(argumenType, parmType);\n              }\n              else {\n                parmType = qualifierSubstitutor.substitute(supertypeSubstitutor.substitute(parameters[i].getType()));\n\n                if (!Util.bindsTypeVariables(parmType) && !Util.bindsTypeParameters(parmType, typeParameters)) {\n                  parmType = Util.banalize(parmType);\n                }\n\n                final PsiType theType =\n                new Object() {\n                  PsiType introduceAdditionalTypeVariables(final PsiType type,\n                                                           final PsiSubstitutor qualifier,\n                                                           final PsiSubstitutor supertype) {\n                    final int level = type.getArrayDimensions();\n                    final PsiClassType.ClassResolveResult result = Util.resolveType(type);\n                    final PsiClass aClass = result.getElement();\n\n                    if (aClass != null) {\n                      if (aClass instanceof PsiTypeParameter) {\n                        final PsiTypeParameter tp = ((PsiTypeParameter)aClass);\n                        final PsiClassType[] extypes = tp.getExtendsListTypes();\n\n                        PsiType pv = mapping.get(tp);\n\n                        if (pv == null) {\n                          pv = myTypeVariableFactory.create();\n                          mapping.put(tp, pv);\n                        }\n\n                        for (int j = 0; j < extypes.length; j++) {\n                          final PsiClassType ext = extypes[j];\n                          final PsiType extype = qualifier.substitute(new Object() {\n                                                                         public PsiType substitute(final PsiType ext) {\n                                                                           final PsiClassType.ClassResolveResult result =\n                                                                             Util.resolveType(ext);\n                                                                           final PsiClass aClass = result.getElement();\n\n                                                                           if (aClass != null) {\n                                                                             if (aClass instanceof PsiTypeParameter) {\n                                                                               final PsiType type = mapping.get(aClass);\n\n                                                                               if (type != null) {\n                                                                                 return type;\n                                                                               }\n\n                                                                               return ext;\n                                                                             }\n\n                                                                             final PsiSubstitutor aSubst = result.getSubstitutor();\n                                                                             PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n                                                                             for (final Iterator<PsiTypeParameter> p =\n                                                                                    aSubst.getSubstitutionMap().keySet().iterator();\n                                                                                          p.hasNext();) {\n                                                                               final PsiTypeParameter parm = p.next();\n\n                                                                               PsiType type = aSubst.substitute(parm);\n\n                                                                               if (type != null) {\n                                                                                 type = substitute(type);\n                                                                               }\n\n                                                                               theSubst = theSubst.put(parm, type);\n                                                                             }\n\n                                                                             return aClass.getManager().getElementFactory()\n                                                                               .createType(aClass, theSubst);\n                                                                           }\n\n                                                                           return ext;\n                                                                         }\n                                                                       }.substitute(ext));\n                          system.addSubtypeConstraint(pv, extype);\n                        }\n\n                        return Util.createArrayType(pv, level);\n                      }\n\n                      final Map<PsiTypeParameter, PsiType> substitutionMap = result.getSubstitutor().getSubstitutionMap();\n\n                      PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n                      for (Iterator<PsiTypeParameter> t = substitutionMap.keySet().iterator(); t.hasNext();) {\n                        final PsiTypeParameter p = t.next();\n                        final PsiType pType = substitutionMap.get(p);\n\n                        if (pType instanceof PsiWildcardType) {\n                          final PsiWildcardType wildcard = ((PsiWildcardType)pType);\n                          final PsiType theBound = wildcard.getBound();\n\n                          if (theBound != null) {\n                            final PsiType bound = qualifier.substitute(supertype.substitute(theBound));\n\n                            if (Util.bindsTypeVariables(bound)) {\n                              final PsiType var = myTypeVariableFactory.create();\n\n                              if (wildcard.isExtends()) {\n                                system.addSubtypeConstraint(var, bound);\n                              }\n                              else {\n                                system.addSubtypeConstraint(bound, var);\n                              }\n\n                              theSubst = theSubst.put(p, var);\n                            }\n                            else if (Util.bindsTypeParameters(bound, typeParameters)) {\n                              final PsiType var = myTypeVariableFactory.create();\n                              PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n\n                              for (int i = 0; i < aTypeParms.length; i++) {\n                                final PsiTypeParameter aTypeParm = aTypeParms[i];\n\n                                PsiType parmVar = mapping.get(aTypeParm);\n\n                                if (parmVar == null) {\n                                  parmVar = myTypeVariableFactory.create();\n                                  mapping.put(aTypeParm, parmVar);\n                                }\n\n                                subst = subst.put(aTypeParm, parmVar);\n                              }\n\n                              final PsiType bnd = subst.substitute(bound);\n\n                              if (wildcard.isExtends()) {\n                                system.addSubtypeConstraint(bnd, var);\n                              }\n                              else {\n                                system.addSubtypeConstraint(var, bnd);\n                              }\n\n                              theSubst = theSubst.put(p, var);\n                            }\n                            else {\n                              theSubst = theSubst.put(p, pType);\n                            }\n                          }\n                        }\n                        else {\n                          theSubst = theSubst.put(p, introduceAdditionalTypeVariables(pType, qualifier, supertype));\n                        }\n                      }\n\n                      return Util.createArrayType(aClass.getManager().getElementFactory().createType(aClass, theSubst), level);\n                    }\n\n                    return Util.createArrayType(type, level);\n                  }\n                }.introduceAdditionalTypeVariables(parmType, qualifierSubstitutor, supertypeSubstitutor);\n\n                system.addSubtypeConstraint(argumenType, theType);\n              }\n            }\n\n            final PsiType rawType = expr.getType();\n\n            if (rawType != null) {\n              new Object() {\n                void traversePair(final PsiType aType, final PsiType rawType) {\n                  final PsiClassType.ClassResolveResult aResult = Util.resolveType(aType);\n                  final PsiClassType.ClassResolveResult rawResult = Util.resolveType(rawType);\n\n                  final PsiClass aClass = aResult.getElement();\n                  final PsiClass rawClass = rawResult.getElement();\n\n                  if (rawClass != null && aClass != null) {\n                    if (typeParameters.contains(aClass)) {\n                      final PsiTypeParameter parm = (PsiTypeParameter)aClass;\n\n                      if (mapping.get(parm) == null) {\n                        mapping.put(parm, rawType);\n                      }\n                      return;\n                    }\n\n                    final PsiSubstitutor rawSubst = rawResult.getSubstitutor();\n                    final PsiSubstitutor aSubat = aResult.getSubstitutor();\n\n                    for (final Iterator<PsiTypeParameter> p = rawSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n                      final PsiTypeParameter parm = p.next();\n\n                      final PsiType a = aSubat.substitute(parm);\n                      final PsiType raw = rawSubst.substitute(parm);\n\n                      if (a != null && raw != null) {\n                        traversePair(a, raw);\n                      }\n                    }\n                  }\n                }\n              }.traversePair(aType, rawType);\n            }\n\n            PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n            for (Iterator<PsiTypeParameter> i = mapping.keySet().iterator(); i.hasNext();) {\n              final PsiTypeParameter parm = i.next();\n              final PsiType type = mapping.get(parm);\n\n              theSubst = theSubst.put(parm, type);\n            }\n\n            return theSubst.substitute(aType);\n          }\n        }\n        else if (expr instanceof PsiParenthesizedExpression) {\n          return evaluateType(((PsiParenthesizedExpression)expr).getExpression());\n        }\n        else if (expr instanceof PsiConditionalExpression) {\n          return evaluateType(((PsiConditionalExpression)expr).getThenExpression());\n        }\n        else if (expr instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression ref = ((PsiReferenceExpression)expr);\n          final PsiExpression qualifier = ref.getQualifierExpression();\n\n          if (qualifier == null) {\n            return getType(ref.resolve());\n          }\n          else {\n            final PsiType qualifierType = evaluateType(qualifier);\n            final PsiElement element = ref.resolve();\n\n            final PsiClassType.ClassResolveResult result = Util.resolveType(qualifierType);\n\n            if (result.getElement() != null) {\n              final PsiClass aClass = result.getElement();\n              final PsiSubstitutor aSubst = result.getSubstitutor();\n\n              if (element instanceof PsiField) {\n                final PsiField field = (PsiField)element;\n                final PsiType fieldType = getType(field);\n                final PsiClass superClass = field.getContainingClass();\n\n                PsiType aType = fieldType;\n\n                if (!aClass.equals(superClass) && field.isPhysical()) {\n                  aType =\n                    TypeConversionUtil.getSuperClassSubstitutor(superClass, aClass, PsiSubstitutor.EMPTY).substitute(aType);\n                }\n\n                return aSubst.substitute(aType);\n              }\n            }\n            else if (element != null) {\n              return getType(element);\n            }\n          }\n        }\n\n        return getType(expr);\n      }\n    }\n\n    final TypeEvaluator e = new TypeEvaluator();\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (int i = 0; i < inits.length; i++) {\n            system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (int i = 0; i < inits.length; i++) {\n              system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(e.evaluateType(core), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(e.evaluateType(core), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n\n        if (method != null) {\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          final PsiReference[] refs = helper.findReferences(method, helper.getUseScope(method), true);\n\n          for (int i = 0; i < refs.length; i++) {\n            final PsiElement ref = refs[i].getElement();\n\n            if (ref != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(ref, PsiCallExpression.class);\n\n              if (call != null) {\n                final PsiExpression arg = call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex(\n                  (PsiParameter)element)];\n\n                system.addSubtypeConstraint(e.evaluateType(arg), myTypes.get(element));\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(e.evaluateType(retExpr), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiStatement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(e.evaluateType(expression.getRExpression()), e.evaluateType(expression.getLExpression()));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(e.evaluateType(expression.getThenExpression()),\n                                                    e.evaluateType(expression.getElseExpression()));\n                        system.addSubtypeConstraint(e.evaluateType(expression.getElseExpression()),\n                                                    e.evaluateType(expression.getThenExpression()));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        e.evaluateType(expression);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(e.evaluateType(statement.getReturnValue()), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        system.addCast(expression);\n                        final PsiType operandType = e.evaluateType(expression.getOperand());\n                        final PsiType castType = e.evaluateType(expression);\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(e.evaluateType(init), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (int i = 0; i < inits.length; i++) {\n                            system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","id":106771,"modified_method":"private void addUsage(final System system, final PsiElement element) {\n\n    class TypeEvaluator {\n      PsiType evaluateType(final PsiExpression expr) {\n        if (expr instanceof PsiArrayAccessExpression && !mySettings.preserveRawArrays()) {\n          final PsiType at = evaluateType(((PsiArrayAccessExpression)expr).getArrayExpression());\n\n          if (at instanceof PsiArrayType) {\n            return ((PsiArrayType)at).getComponentType();\n          }\n        }\n        else if (expr instanceof PsiAssignmentExpression) {\n          return evaluateType(((PsiAssignmentExpression)expr).getLExpression());\n        }\n        else if (expr instanceof PsiCallExpression) {\n          final PsiCallExpression call = ((PsiCallExpression)expr);\n          final PsiMethod method = call.resolveMethod();\n\n          if (method != null) {\n            final PsiClass aClass = method.getContainingClass();\n            final PsiTypeParameter[] aTypeParms = method.getTypeParameterList().getTypeParameters();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            final PsiExpression[] arguments = call.getArgumentList().getExpressions();\n            final PsiExpression aQualifier = expr instanceof PsiMethodCallExpression\n              ? ((PsiMethodCallExpression)expr).getMethodExpression().getQualifierExpression()\n              : null;\n            final HashSet<PsiTypeParameter> typeParameters = new HashSet<PsiTypeParameter>();\n\n            for (int i = 0; i < aTypeParms.length; i++) {\n              typeParameters.add(aTypeParms[i]);\n            }\n\n            PsiSubstitutor qualifierSubstitutor = PsiSubstitutor.EMPTY;\n            PsiSubstitutor supertypeSubstitutor = PsiSubstitutor.EMPTY;\n\n            PsiType aType;\n\n            if (method.isConstructor()) {\n              if (isCooked(expr)) {\n                aType = getType(expr);\n\n                qualifierSubstitutor = Util.resolveType(aType).getSubstitutor();\n              }\n              else {\n                final PsiClass cClass = method.getContainingClass();\n                final PsiTypeParameter[] classParms = Util.getTypeParametersList(cClass);\n\n                for (int i = 0; i < classParms.length; i++) {\n                  final PsiTypeParameter classParm = classParms[i];\n                  final PsiTypeVariable var = myTypeVariableFactory.create();\n\n                  qualifierSubstitutor = qualifierSubstitutor.put(classParm, var);\n                }\n\n                aType = myManager.getElementFactory().createType(method.getContainingClass(), qualifierSubstitutor);\n              }\n            }\n            else {\n              aType = getType(method);\n            }\n\n            if (aQualifier != null) {\n              final PsiType qualifierType = evaluateType(aQualifier);\n              final PsiClassType.ClassResolveResult result = Util.resolveType(qualifierType);\n\n              if (result.getElement() != null) {\n                final PsiClass qualifierClass = result.getElement();\n\n                qualifierSubstitutor = TypeConversionUtil.getClassSubstitutor(aClass, qualifierClass, result.getSubstitutor());\n\n                if (qualifierSubstitutor != null) {\n                  aType = qualifierSubstitutor.substitute(aType);\n                }\n              }\n            }\n\n            // Bind method type parameters here. Remember: intersection types are needed :((\n            // Example:\n            //     <T extends Foo> T foo (List<T> a, List<T> b) {...}\n            //     class List<X extends Foo> {...}\n            //\n            //     List x; -- List<'a> x\n            //     List y; -- List<'b> y\n            //\n            //     foo (x, y) -- type is 'a ^ 'b. Woof, woof....\n\n            final HashMap<PsiTypeParameter, PsiType> mapping = new HashMap<PsiTypeParameter, PsiType>();\n\n            for (int i = 0; i < Math.min(parameters.length, arguments.length); i++) {\n              final PsiType argumenType = evaluateType(arguments[i]);\n\n              PsiType parmType;\n\n              if (isCooked(parameters[i])) {\n                parmType = getType(parameters[i]);\n                system.addSubtypeConstraint(argumenType, parmType);\n              }\n              else {\n                parmType = qualifierSubstitutor.substitute(supertypeSubstitutor.substitute(parameters[i].getType()));\n\n                if (!Util.bindsTypeVariables(parmType) && !Util.bindsTypeParameters(parmType, typeParameters)) {\n                  parmType = Util.banalize(parmType);\n                }\n\n                final PsiType theType =\n                new Object() {\n                  PsiType introduceAdditionalTypeVariables(final PsiType type,\n                                                           final PsiSubstitutor qualifier,\n                                                           final PsiSubstitutor supertype) {\n                    final int level = type.getArrayDimensions();\n                    final PsiClassType.ClassResolveResult result = Util.resolveType(type);\n                    final PsiClass aClass = result.getElement();\n\n                    if (aClass != null) {\n                      if (aClass instanceof PsiTypeParameter) {\n                        final PsiTypeParameter tp = ((PsiTypeParameter)aClass);\n                        final PsiClassType[] extypes = tp.getExtendsListTypes();\n\n                        PsiType pv = mapping.get(tp);\n\n                        if (pv == null) {\n                          pv = myTypeVariableFactory.create();\n                          mapping.put(tp, pv);\n                        }\n\n                        for (int j = 0; j < extypes.length; j++) {\n                          final PsiClassType ext = extypes[j];\n                          final PsiType extype = qualifier.substitute(new Object() {\n                                                                         public PsiType substitute(final PsiType ext) {\n                                                                           final PsiClassType.ClassResolveResult result =\n                                                                             Util.resolveType(ext);\n                                                                           final PsiClass aClass = result.getElement();\n\n                                                                           if (aClass != null) {\n                                                                             if (aClass instanceof PsiTypeParameter) {\n                                                                               final PsiType type = mapping.get(aClass);\n\n                                                                               if (type != null) {\n                                                                                 return type;\n                                                                               }\n\n                                                                               return ext;\n                                                                             }\n\n                                                                             final PsiSubstitutor aSubst = result.getSubstitutor();\n                                                                             PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n                                                                             for (final Iterator<PsiTypeParameter> p =\n                                                                                    aSubst.getSubstitutionMap().keySet().iterator();\n                                                                                          p.hasNext();) {\n                                                                               final PsiTypeParameter parm = p.next();\n\n                                                                               PsiType type = aSubst.substitute(parm);\n\n                                                                               if (type != null) {\n                                                                                 type = substitute(type);\n                                                                               }\n\n                                                                               theSubst = theSubst.put(parm, type);\n                                                                             }\n\n                                                                             return aClass.getManager().getElementFactory()\n                                                                               .createType(aClass, theSubst);\n                                                                           }\n\n                                                                           return ext;\n                                                                         }\n                                                                       }.substitute(ext));\n                          system.addSubtypeConstraint(pv, extype);\n                        }\n\n                        return Util.createArrayType(pv, level);\n                      }\n\n                      final Map<PsiTypeParameter, PsiType> substitutionMap = result.getSubstitutor().getSubstitutionMap();\n\n                      PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n                      for (Iterator<PsiTypeParameter> t = substitutionMap.keySet().iterator(); t.hasNext();) {\n                        final PsiTypeParameter p = t.next();\n                        final PsiType pType = substitutionMap.get(p);\n\n                        if (pType instanceof PsiWildcardType) {\n                          final PsiWildcardType wildcard = ((PsiWildcardType)pType);\n                          final PsiType theBound = wildcard.getBound();\n\n                          if (theBound != null) {\n                            final PsiType bound = qualifier.substitute(supertype.substitute(theBound));\n\n                            if (Util.bindsTypeVariables(bound)) {\n                              final PsiType var = myTypeVariableFactory.create();\n\n                              if (wildcard.isExtends()) {\n                                system.addSubtypeConstraint(var, bound);\n                              }\n                              else {\n                                system.addSubtypeConstraint(bound, var);\n                              }\n\n                              theSubst = theSubst.put(p, var);\n                            }\n                            else if (Util.bindsTypeParameters(bound, typeParameters)) {\n                              final PsiType var = myTypeVariableFactory.create();\n                              PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n\n                              for (int i = 0; i < aTypeParms.length; i++) {\n                                final PsiTypeParameter aTypeParm = aTypeParms[i];\n\n                                PsiType parmVar = mapping.get(aTypeParm);\n\n                                if (parmVar == null) {\n                                  parmVar = myTypeVariableFactory.create();\n                                  mapping.put(aTypeParm, parmVar);\n                                }\n\n                                subst = subst.put(aTypeParm, parmVar);\n                              }\n\n                              final PsiType bnd = subst.substitute(bound);\n\n                              if (wildcard.isExtends()) {\n                                system.addSubtypeConstraint(bnd, var);\n                              }\n                              else {\n                                system.addSubtypeConstraint(var, bnd);\n                              }\n\n                              theSubst = theSubst.put(p, var);\n                            }\n                            else {\n                              theSubst = theSubst.put(p, pType);\n                            }\n                          }\n                        }\n                        else {\n                          theSubst = theSubst.put(p, introduceAdditionalTypeVariables(pType, qualifier, supertype));\n                        }\n                      }\n\n                      return Util.createArrayType(aClass.getManager().getElementFactory().createType(aClass, theSubst), level);\n                    }\n\n                    return Util.createArrayType(type, level);\n                  }\n                }.introduceAdditionalTypeVariables(parmType, qualifierSubstitutor, supertypeSubstitutor);\n\n                system.addSubtypeConstraint(argumenType, theType);\n              }\n            }\n\n            final PsiType rawType = expr.getType();\n\n            if (rawType != null) {\n              new Object() {\n                void traversePair(final PsiType aType, final PsiType rawType) {\n                  final PsiClassType.ClassResolveResult aResult = Util.resolveType(aType);\n                  final PsiClassType.ClassResolveResult rawResult = Util.resolveType(rawType);\n\n                  final PsiClass aClass = aResult.getElement();\n                  final PsiClass rawClass = rawResult.getElement();\n\n                  if (rawClass != null && aClass != null) {\n                    if (typeParameters.contains(aClass)) {\n                      final PsiTypeParameter parm = (PsiTypeParameter)aClass;\n\n                      if (mapping.get(parm) == null) {\n                        mapping.put(parm, rawType);\n                      }\n                      return;\n                    }\n\n                    final PsiSubstitutor rawSubst = rawResult.getSubstitutor();\n                    final PsiSubstitutor aSubat = aResult.getSubstitutor();\n\n                    for (final Iterator<PsiTypeParameter> p = rawSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n                      final PsiTypeParameter parm = p.next();\n\n                      final PsiType a = aSubat.substitute(parm);\n                      final PsiType raw = rawSubst.substitute(parm);\n\n                      if (a != null && raw != null) {\n                        traversePair(a, raw);\n                      }\n                    }\n                  }\n                }\n              }.traversePair(aType, rawType);\n            }\n\n            PsiSubstitutor theSubst = PsiSubstitutor.EMPTY;\n\n            for (Iterator<PsiTypeParameter> i = mapping.keySet().iterator(); i.hasNext();) {\n              final PsiTypeParameter parm = i.next();\n              final PsiType type = mapping.get(parm);\n\n              theSubst = theSubst.put(parm, type);\n            }\n\n            return theSubst.substitute(aType);\n          }\n        }\n        else if (expr instanceof PsiParenthesizedExpression) {\n          return evaluateType(((PsiParenthesizedExpression)expr).getExpression());\n        }\n        else if (expr instanceof PsiConditionalExpression) {\n          return evaluateType(((PsiConditionalExpression)expr).getThenExpression());\n        }\n        else if (expr instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression ref = ((PsiReferenceExpression)expr);\n          final PsiExpression qualifier = ref.getQualifierExpression();\n\n          if (qualifier == null) {\n            return getType(ref.resolve());\n          }\n          else {\n            final PsiType qualifierType = evaluateType(qualifier);\n            final PsiElement element = ref.resolve();\n\n            final PsiClassType.ClassResolveResult result = Util.resolveType(qualifierType);\n\n            if (result.getElement() != null) {\n              final PsiClass aClass = result.getElement();\n              final PsiSubstitutor aSubst = result.getSubstitutor();\n\n              if (element instanceof PsiField) {\n                final PsiField field = (PsiField)element;\n                final PsiType fieldType = getType(field);\n                final PsiClass superClass = field.getContainingClass();\n\n                PsiType aType = fieldType;\n\n                if (!aClass.equals(superClass) && field.isPhysical()) {\n                  aType =\n                    TypeConversionUtil.getSuperClassSubstitutor(superClass, aClass, PsiSubstitutor.EMPTY).substitute(aType);\n                }\n\n                return aSubst.substitute(aType);\n              }\n            }\n            else if (element != null) {\n              return getType(element);\n            }\n          }\n        }\n\n        return getType(expr);\n      }\n    }\n\n    final TypeEvaluator e = new TypeEvaluator();\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (int i = 0; i < inits.length; i++) {\n            system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (int i = 0; i < inits.length; i++) {\n              system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(e.evaluateType(core), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(e.evaluateType(core), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n\n        if (method != null) {\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          final PsiReference[] refs = helper.findReferences(method, helper.getUseScope(method), true);\n\n          for (int i = 0; i < refs.length; i++) {\n            final PsiElement ref = refs[i].getElement();\n\n            if (ref != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(ref, PsiCallExpression.class);\n\n              if (call != null) {\n                final PsiExpression arg = call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex(\n                  (PsiParameter)element)];\n\n                system.addSubtypeConstraint(e.evaluateType(arg), myTypes.get(element));\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(e.evaluateType(retExpr), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiStatement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(e.evaluateType(expression.getRExpression()), e.evaluateType(expression.getLExpression()));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(e.evaluateType(expression.getThenExpression()),\n                                                    e.evaluateType(expression.getElseExpression()));\n                        system.addSubtypeConstraint(e.evaluateType(expression.getElseExpression()),\n                                                    e.evaluateType(expression.getThenExpression()));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        e.evaluateType(expression);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(e.evaluateType(statement.getReturnValue()), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        final PsiType operandType = e.evaluateType(expression.getOperand());\n                        final PsiType castType = e.evaluateType(expression);\n\n                        if (Util.bindsTypeVariables(operandType)) {\n                          system.addCast(expression);\n                        }\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(e.evaluateType(init), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (int i = 0; i < inits.length; i++) {\n                            system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected UsageInfo[] findUsages() {\n    mySystemBuilder = new SystemBuilder(myProject, mySettings);\n\n    final System commonSystem = mySystemBuilder.build(myElements);\n    myResult = new Result(commonSystem);\n\n    final System[] systems = commonSystem.isolate();\n\n    for (int i = 0; i < systems.length; i++) {\n      final System system = systems[i];\n\n      if (system != null) {\n        final ResolverTree tree = new ResolverTree(system);\n\n        tree.resolve();\n\n        final Binding solution = tree.getBestSolution();\n\n        if (solution!= null) {\n          myResult.incorporateSolution(solution);\n        }\n      }\n    }\n\n    final HashSet<PsiElement> cookedItems = myResult.getCookedElements();\n    final UsageInfo[] usages = new UsageInfo[cookedItems.size()];\n\n    int i = 0;\n    for (final Iterator<PsiElement> e=cookedItems.iterator(); e.hasNext();) {\n      final PsiElement element = e.next();\n\n      usages[i++] = new UsageInfo(element){\n        public String getTooltipText(){\n          return myResult.getCookedType(element).getCanonicalText();\n        }\n      };\n    }\n\n    return usages;\n  }","id":106772,"modified_method":"protected UsageInfo[] findUsages() {\n    mySystemBuilder = new SystemBuilder(myProject, mySettings);\n\n    final System commonSystem = mySystemBuilder.build(myElements);\n    myResult = new Result(commonSystem);\n\n    final System[] systems = commonSystem.isolate();\n\n    for (final System system : systems) {\n      if (system != null) {\n        final ResolverTree tree = new ResolverTree(system);\n\n        tree.resolve();\n\n        final Binding solution = tree.getBestSolution();\n\n        if (solution != null) {\n          myResult.incorporateSolution(solution);\n        }\n      }\n    }\n\n    final HashSet<PsiElement> cookedItems = myResult.getCookedElements();\n    final UsageInfo[] usages = new UsageInfo[cookedItems.size()];\n\n    int i = 0;\n    for (final PsiElement element : cookedItems) {\n      usages[i++] = new UsageInfo(element) {\n        public String getTooltipText() {\n          return myResult.getCookedType(element).getCanonicalText();\n        }\n      };\n    }\n\n    return usages;\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(UsageInfo[] usages) {\n    final HashSet<PsiElement> victims = new HashSet<PsiElement>();\n\n    for (int i = 0; i < usages.length; i++) {\n      victims.add(usages[i].getElement());\n    }\n\n    myResult.apply (victims);\n\n    java.lang.System.out.println(myResult.getReport());\n\n    UndoManager.getInstance(myProject).undoableActionPerformed(new DummyComplexUndoableAction()); // force confirmation dialog for undo\n  }","id":106773,"modified_method":"protected void performRefactoring(UsageInfo[] usages) {\n    final HashSet<PsiElement> victims = new HashSet<PsiElement>();\n\n    for (UsageInfo usage : usages) {\n      victims.add(usage.getElement());\n    }\n\n    myResult.apply (victims);\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (myProject.isOpen()) {\n          WindowManager.getInstance().getStatusBar(myProject).setInfo(myResult.getReport());\n        }\n      }\n    });\n\n    UndoManager.getInstance(myProject).undoableActionPerformed(new DummyComplexUndoableAction()); // force confirmation dialog for undo\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiType banalize(final PsiType t) {\n    if (t instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult result = resolveType(t);\n      final PsiClass theClass = result.getElement();\n\n      if (theClass == null) {\n        return t;\n      }\n\n      final PsiSubstitutor theSubst = result.getSubstitutor();\n      final PsiManager theManager = theClass.getManager();\n\n      PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n\n      for (final Iterator<PsiTypeParameter> p = theSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n        final PsiTypeParameter theParm = p.next();\n        final PsiType actualType = theSubst.substitute(theParm);\n\n        if (actualType == null || actualType instanceof PsiWildcardType) {\n          subst = subst.put(theParm, Bottom.BOTTOM);\n        }\n        else {\n          final PsiType banType = banalize(actualType);\n\n          if (banType == null) {\n            return t;\n          }\n\n          subst = subst.put(theParm, banType);\n        }\n      }\n\n      return theManager.getElementFactory().createType(theClass, subst);\n    }\n    else if (t instanceof PsiArrayType) {\n      return banalize(((PsiArrayType)t).getComponentType()).createArrayType();\n    }\n\n    return t;\n  }","id":106774,"modified_method":"/**\n   * convert external raw types to types explicitly parameterized by Bottom\n   */\n  public static PsiType banalize(final PsiType t) {\n    if (t instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult result = resolveType(t);\n      final PsiClass theClass = result.getElement();\n\n      if (theClass == null) {\n        return t;\n      }\n\n      final PsiSubstitutor theSubst = result.getSubstitutor();\n      final PsiManager theManager = theClass.getManager();\n\n      PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n\n      for (final Iterator<PsiTypeParameter> p = theSubst.getSubstitutionMap().keySet().iterator(); p.hasNext();) {\n        final PsiTypeParameter theParm = p.next();\n        final PsiType actualType = theSubst.substitute(theParm);\n\n        if (actualType == null || actualType instanceof PsiWildcardType) {\n          subst = subst.put(theParm, Bottom.BOTTOM);\n        }\n        else {\n          final PsiType banType = banalize(actualType);\n\n          if (banType == null) {\n            return t;\n          }\n\n          subst = subst.put(theParm, banType);\n        }\n      }\n\n      return theManager.getElementFactory().createType(theClass, subst);\n    }\n    else if (t instanceof PsiArrayType) {\n      return banalize(((PsiArrayType)t).getComponentType()).createArrayType();\n    }\n\n    return t;\n  }","commit_id":"916b506e367df7277efa720a68e61bd36408c903","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HashSet<Constraint> apply(final Binding b) {\n    final HashSet<Constraint> result = new HashSet<Constraint>();\n\n    for (Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n      result.add(constr.apply(b));\n    }\n\n    return result;\n  }","id":106775,"modified_method":"private HashSet<Constraint> apply(final Binding b) {\n    final HashSet<Constraint> result = new HashSet<Constraint>();\n\n    for (final Constraint constr : myConstraints) {\n      result.add(constr.apply(b));\n    }\n\n    return result;\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void logSolution() {\n    LOG.debug(\"Reduced system:\");\n\n    for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n\n      LOG.debug(constr.toString());\n    }\n\n    LOG.debug(\"End of Reduced system.\");\n    LOG.debug(\"Reduced binding:\");\n    LOG.debug(myCurrentBinding.toString());\n    LOG.debug(\"End of Reduced binding.\");\n  }","id":106776,"modified_method":"private void logSolution() {\n    LOG.debug(\"Reduced system:\");\n\n    for (final Constraint constr : myConstraints) {\n      LOG.debug(constr.toString());\n    }\n\n    LOG.debug(\"End of Reduced system.\");\n    LOG.debug(\"Reduced binding:\");\n    LOG.debug(myCurrentBinding.toString());\n    LOG.debug(\"End of Reduced binding.\");\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean canBePruned(final Binding b) {\n    if (mySettings.exhaustive()) return false;\n    for (final Iterator<PsiTypeVariable> v = b.getBoundVariables().iterator(); v.hasNext();) {\n      final PsiTypeVariable var = v.next();\n      final PsiType type = b.apply(var);\n\n      if (!(type instanceof PsiTypeVariable) && isBoundElseWhere(var)) {\n        return false;\n      }\n    }\n\n    return true;\n  }","id":106777,"modified_method":"private boolean canBePruned(final Binding b) {\n    if (mySettings.exhaustive()) return false;\n    for (final PsiTypeVariable var : b.getBoundVariables()) {\n      final PsiType type = b.apply(var);\n\n      if (!(type instanceof PsiTypeVariable) && isBoundElseWhere(var)) {\n        return false;\n      }\n    }\n\n    return true;\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TObjectIntHashMap<PsiTypeVariable> calculateDegree() {\n    final TObjectIntHashMap<PsiTypeVariable> result = new TObjectIntHashMap<PsiTypeVariable>();\n\n    for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n\n      final PsiTypeVarCollector collector = new PsiTypeVarCollector();\n\n      setDegree(collector.getSet(constr.getRight()), result);\n    }\n\n    return result;\n  }","id":106778,"modified_method":"private TObjectIntHashMap<PsiTypeVariable> calculateDegree() {\n    final TObjectIntHashMap<PsiTypeVariable> result = new TObjectIntHashMap<PsiTypeVariable>();\n\n    for (final Constraint constr : myConstraints) {\n      final PsiTypeVarCollector collector = new PsiTypeVarCollector();\n\n      setDegree(collector.getSet(constr.getRight()), result);\n    }\n\n    return result;\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reduceSideVar(final Constraint x, final Constraint y, final Reducer reducer) {\n    final PsiTypeVariable var = reducer.getVar(x);\n\n    final PsiType xType = reducer.getType(x);\n    final PsiType yType = reducer.getType(y);\n\n    final LinkedList<Pair<PsiType, Binding>> union = reducer.unify(xType, yType);\n\n    if (union.size() == 0) {\n      return;\n    }\n\n    myConstraints.remove(x);\n    myConstraints.remove(y);\n\n    mySons = new ResolverTree[union.size()];\n    int i = 0;\n\n    Constraint prev = null;\n\n    for (Iterator<Pair<PsiType, Binding>> p = union.iterator(); p.hasNext();) {\n      final Pair<PsiType, Binding> pair = p.next();\n\n      if (prev != null) {\n        myConstraints.remove(prev);\n      }\n\n      prev = reducer.create(var, pair.getFirst());\n      myConstraints.add(prev);\n\n      mySons[i++] = applyRule(pair.getSecond());\n    }\n  }","id":106779,"modified_method":"private void reduceSideVar(final Constraint x, final Constraint y, final Reducer reducer) {\n    final PsiTypeVariable var = reducer.getVar(x);\n\n    final PsiType xType = reducer.getType(x);\n    final PsiType yType = reducer.getType(y);\n\n    final LinkedList<Pair<PsiType, Binding>> union = reducer.unify(xType, yType);\n\n    if (union.size() == 0) {\n      return;\n    }\n\n    myConstraints.remove(x);\n    myConstraints.remove(y);\n\n    mySons = new ResolverTree[union.size()];\n    int i = 0;\n\n    Constraint prev = null;\n\n    for (final Pair<PsiType, Binding> pair : union) {\n      if (prev != null) {\n        myConstraints.remove(prev);\n      }\n\n      prev = reducer.create(var, pair.getFirst());\n      myConstraints.add(prev);\n\n      mySons[i++] = applyRule(pair.getSecond());\n    }\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HashSet<Constraint> apply(final Binding b, final HashSet<Constraint> additional) {\n    final HashSet<Constraint> result = new HashSet<Constraint>();\n\n    for (Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n      result.add(constr.apply(b));\n    }\n\n    for (Iterator<Constraint> c = additional.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n      result.add(constr.apply(b));\n    }\n\n    return result;\n  }","id":106780,"modified_method":"private HashSet<Constraint> apply(final Binding b, final HashSet<Constraint> additional) {\n    final HashSet<Constraint> result = new HashSet<Constraint>();\n\n    for (final Constraint constr : myConstraints) {\n      result.add(constr.apply(b));\n    }\n\n    for (final Constraint constr : additional) {\n      result.add(constr.apply(b));\n    }\n\n    return result;\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reduce() {\n    if (myConstraints.size() == 0) {\n      return;\n    }\n\n    if (myCurrentBinding.isCyclic()) {\n      reduceCyclicVariables();\n    }\n\n    final HashMap<PsiTypeVariable, Constraint> myTypeVarConstraints = new HashMap<PsiTypeVariable, Constraint>();\n    final HashMap<PsiTypeVariable, Constraint> myVarTypeConstraints = new HashMap<PsiTypeVariable, Constraint>();\n\n    for (Iterator<Constraint> i = myConstraints.iterator(); i.hasNext();) {\n      final Constraint constr = i.next();\n\n      final PsiType left = constr.getLeft();\n      final PsiType right = constr.getRight();\n\n      switch ((left instanceof PsiTypeVariable ? 0 : 1) + (right instanceof PsiTypeVariable ? 0 : 2)) {\n      case 0:\n      continue;\n\n      case 1:\n           {\n             final Constraint c = myTypeVarConstraints.get(right);\n\n             if (c == null) {\n               final Constraint d = myVarTypeConstraints.get(right);\n\n               if (d != null) {\n                 reduceInterval(constr, d);\n                 return;\n               }\n\n               myTypeVarConstraints.put((PsiTypeVariable)right, constr);\n             }\n             else {\n               reduceTypeVar(constr, c);\n               return;\n             }\n           }\n      break;\n\n      case 2:\n           {\n             final Constraint c = myVarTypeConstraints.get(left);\n\n             if (c == null) {\n               final Constraint d = myTypeVarConstraints.get(left);\n\n               if (d != null) {\n                 reduceInterval(d, constr);\n                 return;\n               }\n\n               myVarTypeConstraints.put((PsiTypeVariable)left, constr);\n             }\n             else {\n               reduceVarType(constr, c);\n               return;\n             }\n           break;\n           }\n\n      case 3:\n           reduceTypeType(constr);\n           return;\n      }\n    }\n\n    //T1 < a < b ... < T2\n    {\n      for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n        final Constraint constr = c.next();\n        final PsiType left = constr.getLeft();\n        final PsiType right = constr.getRight();\n\n        if (!(left instanceof PsiTypeVariable) && right instanceof PsiTypeVariable) {\n          final HashSet<PsiTypeVariable> bound = new PsiTypeVarCollector().getSet(left);\n\n          if (bound.contains(right)){\n            myConstraints.remove(constr);\n            mySons = new ResolverTree[]{applyRule(myBindingFactory.create(((PsiTypeVariable)right), Bottom.BOTTOM))};\n\n            return;\n          }\n\n          final PsiManager manager = PsiManager.getInstance(myProject);\n          final PsiType leftType = left instanceof PsiWildcardType ? ((PsiWildcardType)left).getBound() : left;\n          final PsiType[] types = getTypeRange(PsiType.getJavaLangObject(manager, GlobalSearchScope.allScope(myProject)), leftType);\n\n          mySons = new ResolverTree[types.length];\n\n          if (types.length > 0) {\n            myConstraints.remove(constr);\n          }\n\n          for (int i = 0; i < types.length; i++) {\n            final PsiType type = types[i];\n            mySons[i] = applyRule(myBindingFactory.create(((PsiTypeVariable)right), type));\n          }\n\n          return;\n        }\n      }\n    }\n\n    //T1 < a < b < ...\n    {\n      final HashSet<PsiTypeVariable> haveLeftBound = new HashSet<PsiTypeVariable>();\n\n      Constraint target = null;\n      final HashSet<PsiTypeVariable> boundVariables = new HashSet<PsiTypeVariable>();\n\n      for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n        final Constraint constr = c.next();\n        final PsiType leftType = constr.getLeft();\n        final PsiType rightType = constr.getRight();\n\n        if (leftType instanceof PsiTypeVariable) {\n          boundVariables.add((PsiTypeVariable)leftType);\n\n          if (rightType instanceof PsiTypeVariable) {\n            boundVariables.add((PsiTypeVariable)rightType);\n            haveLeftBound.add(((PsiTypeVariable)rightType));\n          }\n          else if (!Util.bindsTypeVariables(rightType)) {\n            target = constr;\n          }\n        }\n      }\n\n      if (target == null) {\n        Binding binding = myBindingFactory.create();\n\n        for (final Iterator<PsiTypeVariable> v = myBindingFactory.getBoundVariables().iterator(); v.hasNext();) {\n          final PsiTypeVariable var = v.next();\n\n          if (!myCurrentBinding.binds(var) && !boundVariables.contains(var)) {\n            binding = binding.compose(myBindingFactory.create(var, Bottom.BOTTOM));\n          }\n        }\n\n        if (!binding.nonEmpty()) {\n          myConstraints.clear();\n        }\n\n        mySons = new ResolverTree[]{applyRule(binding)};\n      }\n      else {\n        final PsiType type = target.getRight();\n        final PsiTypeVariable var = (PsiTypeVariable)target.getLeft();\n\n        final Binding binding =\n          (haveLeftBound.contains(var) || type instanceof PsiWildcardType) || !mySettings.cookToWildcards()\n          ? myBindingFactory.create(var, type)\n          : myBindingFactory.create(var, PsiWildcardType.createExtends(PsiManager.getInstance(myProject), type));\n\n        myConstraints.remove(target);\n\n        mySons = new ResolverTree[]{applyRule(binding)};\n      }\n    }\n  }","id":106781,"modified_method":"private void reduce() {\n    if (myConstraints.size() == 0) {\n      return;\n    }\n\n    if (myCurrentBinding.isCyclic()) {\n      reduceCyclicVariables();\n    }\n\n    final HashMap<PsiTypeVariable, Constraint> myTypeVarConstraints = new HashMap<PsiTypeVariable, Constraint>();\n    final HashMap<PsiTypeVariable, Constraint> myVarTypeConstraints = new HashMap<PsiTypeVariable, Constraint>();\n\n    for (final Constraint constr : myConstraints) {\n      final PsiType left = constr.getLeft();\n      final PsiType right = constr.getRight();\n\n      switch ((left instanceof PsiTypeVariable ? 0 : 1) + (right instanceof PsiTypeVariable ? 0 : 2)) {\n        case 0:\n          continue;\n\n        case 1:\n          {\n            final Constraint c = myTypeVarConstraints.get(right);\n\n            if (c == null) {\n              final Constraint d = myVarTypeConstraints.get(right);\n\n              if (d != null) {\n                reduceInterval(constr, d);\n                return;\n              }\n\n              myTypeVarConstraints.put((PsiTypeVariable)right, constr);\n            }\n            else {\n              reduceTypeVar(constr, c);\n              return;\n            }\n          }\n          break;\n\n        case 2:\n        {\n          final Constraint c = myVarTypeConstraints.get(left);\n\n          if (c == null) {\n            final Constraint d = myTypeVarConstraints.get(left);\n\n            if (d != null) {\n              reduceInterval(d, constr);\n              return;\n            }\n\n            myVarTypeConstraints.put((PsiTypeVariable)left, constr);\n          }\n          else {\n            reduceVarType(constr, c);\n            return;\n          }\n          break;\n        }\n\n        case 3:\n          reduceTypeType(constr);\n          return;\n      }\n    }\n\n    //T1 < a < b ... < T2\n    {\n      for (final Constraint constr : myConstraints) {\n        final PsiType left = constr.getLeft();\n        final PsiType right = constr.getRight();\n\n        if (!(left instanceof PsiTypeVariable) && right instanceof PsiTypeVariable) {\n          final HashSet<PsiTypeVariable> bound = new PsiTypeVarCollector().getSet(left);\n\n          if (bound.contains(right)) {\n            myConstraints.remove(constr);\n            mySons = new ResolverTree[]{applyRule(myBindingFactory.create(((PsiTypeVariable)right), Bottom.BOTTOM))};\n\n            return;\n          }\n\n          final PsiManager manager = PsiManager.getInstance(myProject);\n          final PsiType leftType = left instanceof PsiWildcardType ? ((PsiWildcardType)left).getBound() : left;\n          final PsiType[] types = getTypeRange(PsiType.getJavaLangObject(manager, GlobalSearchScope.allScope(myProject)), leftType);\n\n          mySons = new ResolverTree[types.length];\n\n          if (types.length > 0) {\n            myConstraints.remove(constr);\n          }\n\n          for (int i = 0; i < types.length; i++) {\n            final PsiType type = types[i];\n            mySons[i] = applyRule(myBindingFactory.create(((PsiTypeVariable)right), type));\n          }\n\n          return;\n        }\n      }\n    }\n\n    //T1 < a < b < ...\n    {\n      final HashSet<PsiTypeVariable> haveLeftBound = new HashSet<PsiTypeVariable>();\n\n      Constraint target = null;\n      final HashSet<PsiTypeVariable> boundVariables = new HashSet<PsiTypeVariable>();\n\n      for (final Constraint constr : myConstraints) {\n        final PsiType leftType = constr.getLeft();\n        final PsiType rightType = constr.getRight();\n\n        if (leftType instanceof PsiTypeVariable) {\n          boundVariables.add((PsiTypeVariable)leftType);\n\n          if (rightType instanceof PsiTypeVariable) {\n            boundVariables.add((PsiTypeVariable)rightType);\n            haveLeftBound.add(((PsiTypeVariable)rightType));\n          }\n          else if (!Util.bindsTypeVariables(rightType)) {\n            target = constr;\n          }\n        }\n      }\n\n      if (target == null) {\n        Binding binding = myBindingFactory.create();\n\n        for (final PsiTypeVariable var : myBindingFactory.getBoundVariables()) {\n          if (!myCurrentBinding.binds(var) && !boundVariables.contains(var)) {\n            binding = binding.compose(myBindingFactory.create(var, Bottom.BOTTOM));\n          }\n        }\n\n        if (!binding.nonEmpty()) {\n          myConstraints.clear();\n        }\n\n        mySons = new ResolverTree[]{applyRule(binding)};\n      }\n      else {\n        final PsiType type = target.getRight();\n        final PsiTypeVariable var = (PsiTypeVariable)target.getLeft();\n\n        final Binding binding =\n          (haveLeftBound.contains(var) || type instanceof PsiWildcardType) || !mySettings.cookToWildcards()\n          ? myBindingFactory.create(var, type)\n          : myBindingFactory.create(var, PsiWildcardType.createExtends(PsiManager.getInstance(myProject), type));\n\n        myConstraints.remove(target);\n\n        mySons = new ResolverTree[]{applyRule(binding)};\n      }\n    }\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setDegree(final HashSet<PsiTypeVariable> set, TObjectIntHashMap<PsiTypeVariable> result) {\n    for (final Iterator<PsiTypeVariable> v = set.iterator(); v.hasNext();) {\n      final PsiTypeVariable var = v.next();\n      result.increment(var);\n    }\n  }","id":106782,"modified_method":"private void setDegree(final HashSet<PsiTypeVariable> set, TObjectIntHashMap<PsiTypeVariable> result) {\n    for (final PsiTypeVariable var : set) {\n      result.increment(var);\n    }\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reduceCyclicVariables() {\n    final HashSet<PsiTypeVariable> nodes = new HashSet<PsiTypeVariable>();\n    final HashSet<Constraint> candidates = new HashSet<Constraint>();\n\n    final HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>> ins = new HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>>();\n    final HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>> outs = new HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>>();\n\n    for (Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constraint = c.next();\n\n      final PsiType left = constraint.getLeft();\n      final PsiType right = constraint.getRight();\n\n      if (left instanceof PsiTypeVariable && right instanceof PsiTypeVariable) {\n        final PsiTypeVariable leftVar = (PsiTypeVariable)left;\n        final PsiTypeVariable rightVar = (PsiTypeVariable)right;\n\n        candidates.add(constraint);\n\n        nodes.add(leftVar);\n        nodes.add(rightVar);\n\n        final HashSet<PsiTypeVariable> in = ins.get(leftVar);\n        final HashSet<PsiTypeVariable> out = outs.get(rightVar);\n\n        if (in == null) {\n          final HashSet<PsiTypeVariable> newIn = new HashSet<PsiTypeVariable>();\n\n          newIn.add(rightVar);\n\n          ins.put(leftVar, newIn);\n        }\n        else {\n          in.add(rightVar);\n        }\n\n        if (out == null) {\n          final HashSet<PsiTypeVariable> newOut = new HashSet<PsiTypeVariable>();\n\n          newOut.add(leftVar);\n\n          outs.put(rightVar, newOut);\n        }\n        else {\n          out.add(leftVar);\n        }\n      }\n    }\n\n    final DFSTBuilder<PsiTypeVariable> dfstBuilder = new DFSTBuilder<PsiTypeVariable>(new Graph<PsiTypeVariable>() {\n                                                                                        public Collection<PsiTypeVariable> getNodes() {\n                                                                                          return nodes;\n                                                                                        }\n\n                                                                                        public Iterator<PsiTypeVariable> getIn(final PsiTypeVariable n) {\n                                                                                          final HashSet<PsiTypeVariable> in = ins.get(n);\n\n                                                                                          if (in == null) {\n                                                                                            return new HashSet<PsiTypeVariable>().iterator();\n                                                                                          }\n\n                                                                                          return in.iterator();\n                                                                                        }\n\n                                                                                        public Iterator<PsiTypeVariable> getOut(final PsiTypeVariable n) {\n                                                                                          final HashSet<PsiTypeVariable> out = outs.get(n);\n\n                                                                                          if (out == null) {\n                                                                                            return new HashSet<PsiTypeVariable>().iterator();\n                                                                                          }\n\n                                                                                          return out.iterator();\n                                                                                        }\n                                                                                      });\n\n    final LinkedList<Pair<Integer, Integer>> sccs = dfstBuilder.getSCCs();\n    final HashMap<PsiTypeVariable, Integer> index = new HashMap<PsiTypeVariable, Integer>();\n\n    for (Iterator<Pair<Integer, Integer>> i = sccs.iterator(); i.hasNext();) {\n      final Pair<Integer, Integer> p = i.next();\n      final Integer biT = p.getFirst();\n      final int binum = biT.intValue();\n\n      for (int j = 0; j < p.getSecond().intValue(); j++) {\n        index.put(dfstBuilder.getNodeByTNumber(binum + j), biT);\n      }\n    }\n\n    for (Iterator<Constraint> c = candidates.iterator(); c.hasNext();) {\n      final Constraint constraint = c.next();\n\n      if (index.get(constraint.getLeft()).equals(index.get(constraint.getRight()))) {\n        myConstraints.remove(constraint);\n      }\n    }\n\n    Binding binding = myBindingFactory.create();\n\n    for (Iterator<PsiTypeVariable> v = index.keySet().iterator(); v.hasNext();) {\n      final PsiTypeVariable fromVar = v.next();\n      final PsiTypeVariable toVar = dfstBuilder.getNodeByNNumber(index.get(fromVar).intValue());\n\n      if (!fromVar.equals(toVar)) {\n        binding = binding.compose(myBindingFactory.create(fromVar, toVar));\n\n        if (binding == null) {\n        break;\n        }\n      }\n    }\n\n    if (binding != null && binding.nonEmpty()) {\n      myCurrentBinding = myCurrentBinding.compose(binding);\n      myConstraints = apply(binding);\n    }\n  }","id":106783,"modified_method":"private void reduceCyclicVariables() {\n    final HashSet<PsiTypeVariable> nodes = new HashSet<PsiTypeVariable>();\n    final HashSet<Constraint> candidates = new HashSet<Constraint>();\n\n    final HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>> ins = new HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>>();\n    final HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>> outs = new HashMap<PsiTypeVariable, HashSet<PsiTypeVariable>>();\n\n    for (final Constraint constraint : myConstraints) {\n      final PsiType left = constraint.getLeft();\n      final PsiType right = constraint.getRight();\n\n      if (left instanceof PsiTypeVariable && right instanceof PsiTypeVariable) {\n        final PsiTypeVariable leftVar = (PsiTypeVariable)left;\n        final PsiTypeVariable rightVar = (PsiTypeVariable)right;\n\n        candidates.add(constraint);\n\n        nodes.add(leftVar);\n        nodes.add(rightVar);\n\n        final HashSet<PsiTypeVariable> in = ins.get(leftVar);\n        final HashSet<PsiTypeVariable> out = outs.get(rightVar);\n\n        if (in == null) {\n          final HashSet<PsiTypeVariable> newIn = new HashSet<PsiTypeVariable>();\n\n          newIn.add(rightVar);\n\n          ins.put(leftVar, newIn);\n        }\n        else {\n          in.add(rightVar);\n        }\n\n        if (out == null) {\n          final HashSet<PsiTypeVariable> newOut = new HashSet<PsiTypeVariable>();\n\n          newOut.add(leftVar);\n\n          outs.put(rightVar, newOut);\n        }\n        else {\n          out.add(leftVar);\n        }\n      }\n    }\n\n    final DFSTBuilder<PsiTypeVariable> dfstBuilder = new DFSTBuilder<PsiTypeVariable>(new Graph<PsiTypeVariable>() {\n                                                                                        public Collection<PsiTypeVariable> getNodes() {\n                                                                                          return nodes;\n                                                                                        }\n\n                                                                                        public Iterator<PsiTypeVariable> getIn(final PsiTypeVariable n) {\n                                                                                          final HashSet<PsiTypeVariable> in = ins.get(n);\n\n                                                                                          if (in == null) {\n                                                                                            return new HashSet<PsiTypeVariable>().iterator();\n                                                                                          }\n\n                                                                                          return in.iterator();\n                                                                                        }\n\n                                                                                        public Iterator<PsiTypeVariable> getOut(final PsiTypeVariable n) {\n                                                                                          final HashSet<PsiTypeVariable> out = outs.get(n);\n\n                                                                                          if (out == null) {\n                                                                                            return new HashSet<PsiTypeVariable>().iterator();\n                                                                                          }\n\n                                                                                          return out.iterator();\n                                                                                        }\n                                                                                      });\n\n    final LinkedList<Pair<Integer, Integer>> sccs = dfstBuilder.getSCCs();\n    final HashMap<PsiTypeVariable, Integer> index = new HashMap<PsiTypeVariable, Integer>();\n\n    for (final Pair<Integer, Integer> p : sccs) {\n      final Integer biT = p.getFirst();\n      final int binum = biT.intValue();\n\n      for (int j = 0; j < p.getSecond().intValue(); j++) {\n        index.put(dfstBuilder.getNodeByTNumber(binum + j), biT);\n      }\n    }\n\n    for (final Constraint constraint : candidates) {\n      if (index.get(constraint.getLeft()).equals(index.get(constraint.getRight()))) {\n        myConstraints.remove(constraint);\n      }\n    }\n\n    Binding binding = myBindingFactory.create();\n\n    for (final PsiTypeVariable fromVar : index.keySet()) {\n      final PsiTypeVariable toVar = dfstBuilder.getNodeByNNumber(index.get(fromVar).intValue());\n\n      if (!fromVar.equals(toVar)) {\n        binding = binding.compose(myBindingFactory.create(fromVar, toVar));\n\n        if (binding == null) {\n          break;\n        }\n      }\n    }\n\n    if (binding != null && binding.nonEmpty()) {\n      myCurrentBinding = myCurrentBinding.compose(binding);\n      myConstraints = apply(binding);\n    }\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillTypeRange(final PsiType lowerBound,\n                             final PsiType upperBound,\n                             final HashSet<PsiType> holder) {\n    if (lowerBound instanceof PsiClassType && upperBound instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult resultLower = ((PsiClassType)lowerBound).resolveGenerics();\n      final PsiClassType.ClassResolveResult resultUpper = ((PsiClassType)upperBound).resolveGenerics();\n\n      final PsiClass lowerClass = resultLower.getElement();\n      final PsiClass upperClass = resultUpper.getElement();\n\n      if (lowerClass != null && upperClass != null && !lowerClass.equals(upperClass)) {\n        final PsiSubstitutor upperSubst = resultUpper.getSubstitutor();\n        final PsiClass[] parents = upperClass.getSupers();\n        final PsiElementFactory factory = PsiManager.getInstance(myProject).getElementFactory();\n\n        for (int i = 0; i < parents.length; i++) {\n          final PsiClass parent = parents[i];\n\n          final PsiSubstitutor superSubstitutor = TypeConversionUtil.getClassSubstitutor(parent, upperClass, upperSubst);\n          if (superSubstitutor != null) {\n            final PsiClassType type = factory.createType(parent, superSubstitutor);\n            holder.add(type);\n            fillTypeRange(lowerBound, type, holder);\n          }\n        }\n      }\n    }\n    else if (lowerBound instanceof PsiArrayType && upperBound instanceof PsiArrayType) {\n      fillTypeRange(((PsiArrayType)lowerBound).getComponentType(), ((PsiArrayType)upperBound).getComponentType(), holder);\n    }\n  }","id":106784,"modified_method":"private void fillTypeRange(final PsiType lowerBound,\n                             final PsiType upperBound,\n                             final HashSet<PsiType> holder) {\n    if (lowerBound instanceof PsiClassType && upperBound instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult resultLower = ((PsiClassType)lowerBound).resolveGenerics();\n      final PsiClassType.ClassResolveResult resultUpper = ((PsiClassType)upperBound).resolveGenerics();\n\n      final PsiClass lowerClass = resultLower.getElement();\n      final PsiClass upperClass = resultUpper.getElement();\n\n      if (lowerClass != null && upperClass != null && !lowerClass.equals(upperClass)) {\n        final PsiSubstitutor upperSubst = resultUpper.getSubstitutor();\n        final PsiClass[] parents = upperClass.getSupers();\n        final PsiElementFactory factory = PsiManager.getInstance(myProject).getElementFactory();\n\n        for (final PsiClass parent : parents) {\n          final PsiSubstitutor superSubstitutor = TypeConversionUtil.getClassSubstitutor(parent, upperClass, upperSubst);\n          if (superSubstitutor != null) {\n            final PsiClassType type = factory.createType(parent, superSubstitutor);\n            holder.add(type);\n            fillTypeRange(lowerBound, type, holder);\n          }\n        }\n      }\n    }\n    else if (lowerBound instanceof PsiArrayType && upperBound instanceof PsiArrayType) {\n      fillTypeRange(((PsiArrayType)lowerBound).getComponentType(), ((PsiArrayType)upperBound).getComponentType(), holder);\n    }\n  }","commit_id":"57d417ad3d5a2b5dddd7649af31d8d5f240a0e29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onChange, onChanging and onError.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CHANGE)) {\n\t\t\tInputEvent evt = InputEvent.getInputEvent(request);\n\n\t\t\tfinal String value = evt.getValue();\n\t\t\t_txtByClient = value;\n\t\t\ttry {\n\t\t\t\tfinal Object oldval = _value;\n\t\t\t\tsetText(value); //always since it might have func even not change\n\t\t\t\tif (oldval == _value)\n\t\t\t\t\treturn; //Bug 1881557: don't post event if not modified\n\t\t\t} catch (WrongValueException ex) {\n\t\t\t\t_errmsg = ex.getMessage();\n\t\t\t\t\t//we have to 'remember' the error, so next call to getValue\n\t\t\t\t\t//will throw an exception with proper value.\n\t\t\t\tthrow ex;\n\t\t\t} finally {\n\t\t\t\t_txtByClient = null;\n\t\t\t}\n\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_CHANGING)) {\n\t\t\tEvents.postEvent(InputEvent.getInputEvent(request));\n\t\t} else if (cmd.equals(Events.ON_ERROR)) {\n\t\t\tErrorEvent evt = ErrorEvent.getErrorEvent(request);\n\t\t\tfinal String msg = evt.getMessage();\n\t\t\t_errmsg = msg != null && msg.length() > 0 ? msg: null;\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":106785,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onChange, onChanging and onError.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CHANGE)) {\n\t\t\tInputEvent evt = InputEvent.getInputEvent(request);\n\n\t\t\tfinal String value = evt.getValue();\n\t\t\t_txtByClient = value;\n\t\t\ttry {\n\t\t\t\tfinal Object oldval = _value;\n\t\t\t\tsetText(value); //always since it might have func even not change\n\t\t\t\tif (oldval == _value)\n\t\t\t\t\treturn; //Bug 1881557: don't post event if not modified\n\t\t\t} catch (WrongValueException ex) {\n\t\t\t\t_errmsg = ex.getMessage();\n\t\t\t\t\t//we have to 'remember' the error, so next call to getValue\n\t\t\t\t\t//will throw an exception with proper value.\n\t\t\t\tthrow ex;\n\t\t\t} finally {\n\t\t\t\t_txtByClient = null;\n\t\t\t}\n\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_CHANGING)) {\n\t\t\tEvents.postEvent(InputEvent.getInputEvent(request));\n\t\t} else if (cmd.equals(Events.ON_ERROR)) {\n\t\t\tErrorEvent evt = ErrorEvent.getErrorEvent(request);\n\t\t\tfinal String msg = evt.getMessage();\n\t\t\t_errmsg = msg != null && msg.length() > 0 ? msg: null;\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SELECTION)) {\n\t\t\tEvents.postEvent(SelectionEvent.getSelectionEvent(request));\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"dc27dcb5bd5f23dfc7b20e8e806ce22d33ba1922","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link LabelImageElement#service},\n\t * it also handles onClick.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":106786,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link LabelImageElement#service},\n\t * it also handles onClick.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (cmd.equals(Events.ON_CHANGE)) {\n\t\t\tfinal Map data = request.getData();\n\t\t\tif (getContent().indexOf(\"#color\") == 0) {\n\t\t\t\t_noSmartUpdate = true;\n\t\t\t\tsetContent(\"#color=\" + (String)data.get(\"color\"));\n\t\t\t\t_noSmartUpdate = false;\n\t\t\t\tEvents.postEvent(InputEvent.getInputEvent(request));\n\t\t\t}\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"bfaa57463734cc6c37acf8130d9a87009d3e9718","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)\n\t\t|| cmd.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| cmd.equals(Events.ON_RIGHT_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (cmd.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\t_left = evt.getLeft();\n\t\t\t_top = evt.getTop();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\t_width = evt.getWidth();\n\t\t\t_height = evt.getHeight();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\t_zIndex = evt.getZIndex();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_OK) || cmd.equals(Events.ON_CANCEL)\n\t\t|| cmd.equals(Events.ON_CTRL_KEY)) {\n\t\t\tEvents.postEvent(KeyEvent.getKeyEvent(request));\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":106787,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)\n\t\t|| cmd.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| cmd.equals(Events.ON_RIGHT_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (cmd.equals(Events.ON_OK) || cmd.equals(Events.ON_CANCEL)\n\t\t|| cmd.equals(Events.ON_CTRL_KEY)) {\n\t\t\tEvents.postEvent(KeyEvent.getKeyEvent(request));\n\t\t} else if (cmd.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\t_left = evt.getLeft();\n\t\t\t_top = evt.getTop();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\t_width = evt.getWidth();\n\t\t\t_height = evt.getHeight();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\t_zIndex = evt.getZIndex();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_DROP)) {\n\t\t\tDropEvent evt = DropEvent.getDropEvent(request);\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"3272efdc22877af89c610157e1a7ad18ae20ae89","url":"https://github.com/zkoss/zk"},{"original_method":"/** Renders the content of this component, excluding the enclosing\n\t * tags and children.\n\t *\n\t * <p>See also\n\t * <a href=\"http://docs.zkoss.org/zk/Render_Special_Properties\">Render Special Properties<\/a>\n\t * @since 5.0.0\n\t */\n\tprotected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\trender(renderer, \"tooltiptext\", _tooltiptext);\n\t\trender(renderer, \"width\", _width);\n\t\trender(renderer, \"height\", _height);\n\t\trender(renderer, \"sclass\", _sclass);\n\t\trender(renderer, \"zclass\", _zclass);\n\t\trender(renderer, \"style\", _style);\n\t\trender(renderer, \"left\", _left);\n\t\trender(renderer, \"top\", _top);\n\t\trender(renderer, \"draggble\", _draggable); //getDraggable is final\n\t\trender(renderer, \"droppable\", _droppable);  //getDroppable is final\n\n\t\tif (_zIndex >= 0) renderer.render(\"zIndex\", _zIndex);\n\n\t\trender(renderer, \"prolog\", _prolog);\n\t}","id":106788,"modified_method":"/** Renders the content of this component, excluding the enclosing\n\t * tags and children.\n\t *\n\t * <p>See also\n\t * <a href=\"http://docs.zkoss.org/zk/Render_Special_Properties\">Render Special Properties<\/a>\n\t * @since 5.0.0\n\t */\n\tprotected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\trender(renderer, \"tooltiptext\", _tooltiptext);\n\t\trender(renderer, \"width\", _width);\n\t\trender(renderer, \"height\", _height);\n\t\trender(renderer, \"sclass\", _sclass);\n\t\trender(renderer, \"zclass\", _zclass);\n\t\trender(renderer, \"style\", _style);\n\t\trender(renderer, \"left\", _left);\n\t\trender(renderer, \"top\", _top);\n\t\trender(renderer, \"draggable\", _draggable); //getDraggable is final\n\t\trender(renderer, \"droppable\", _droppable);  //getDroppable is final\n\n\t\tif (_zIndex >= 0) renderer.render(\"zIndex\", _zIndex);\n\n\t\trender(renderer, \"prolog\", _prolog);\n\t}","commit_id":"3272efdc22877af89c610157e1a7ad18ae20ae89","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)\n\t\t|| cmd.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| cmd.equals(Events.ON_RIGHT_CLICK)\n\t\t|| cmd.equals(Events.ON_MOUSE_OVER)\n\t\t|| cmd.equals(Events.ON_MOUSE_OUT)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (cmd.equals(Events.ON_OK) || cmd.equals(Events.ON_CANCEL)\n\t\t|| cmd.equals(Events.ON_CTRL_KEY)) {\n\t\t\tEvents.postEvent(KeyEvent.getKeyEvent(request));\n\t\t} else if (cmd.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\tsetLeftDirectly(evt.getLeft());\n\t\t\tsetTopDirectly(evt.getTop());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\tsetWidthDirectly(evt.getWidth());\n\t\t\tsetHeightDirectly(evt.getHeight());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\tsetZIndexDirectly(evt.getZIndex());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_DROP)) {\n\t\t\tDropEvent evt = DropEvent.getDropEvent(request);\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":106789,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_CLICK)\n\t\t|| cmd.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| cmd.equals(Events.ON_RIGHT_CLICK)\n\t\t|| cmd.equals(Events.ON_MOUSE_OVER)\n\t\t|| cmd.equals(Events.ON_MOUSE_OUT)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (cmd.equals(Events.ON_OK) || cmd.equals(Events.ON_CANCEL)\n\t\t|| cmd.equals(Events.ON_CTRL_KEY)) {\n\t\t\tEvents.postEvent(KeyEvent.getKeyEvent(request));\n\t\t} else if (cmd.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\tsetLeftDirectly(evt.getLeft());\n\t\t\tsetTopDirectly(evt.getTop());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\tsetWidthDirectly(evt.getWidth());\n\t\t\tsetHeightDirectly(evt.getHeight());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\tsetZIndexDirectly(evt.getZIndex());\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_DROP)) {\n\t\t\tDropEvent evt = DropEvent.getDropEvent(request);\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SWIPE)) {\n\t\t\tSwipeEvent evt = SwipeEvent.getSwipeEvent(request);\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"5e6c8543f173635da3b4f884ab037d2fdd8c8957","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String name = request.getName();\n\t\tif (name.equals(Events.ON_CLICK)\n\t\t|| name.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| name.equals(Events.ON_RIGHT_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (name.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\t_left = evt.getLeft();\n\t\t\t_top = evt.getTop();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\t_width = evt.getWidth();\n\t\t\t_height = evt.getHeight();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\t_zIndex = evt.getZIndex();\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":106790,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: it handles onClick, onDoubleClick, onRightClick\n\t * onMove, onSize, onZIndex.\n\t * @since 5.0.0\n\t */\n\tpublic void service(AuRequest request, boolean everError) {\n\t\tfinal String name = request.getName();\n\t\tif (name.equals(Events.ON_CLICK)\n\t\t|| name.equals(Events.ON_DOUBLE_CLICK)\n\t\t|| name.equals(Events.ON_RIGHT_CLICK)) {\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\n\t\t} else if (name.equals(Events.ON_MOVE)) {\n\t\t\tMoveEvent evt = MoveEvent.getMoveEvent(request);\n\t\t\t_left = evt.getLeft();\n\t\t\t_top = evt.getTop();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_SIZE)) {\n\t\t\tSizeEvent evt = SizeEvent.getSizeEvent(request);\n\t\t\t_width = evt.getWidth();\n\t\t\t_height = evt.getHeight();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_Z_INDEX)) {\n\t\t\tZIndexEvent evt = ZIndexEvent.getZIndexEvent(request);\n\t\t\t_zIndex = evt.getZIndex();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (name.equals(Events.ON_OK) || name.equals(Events.ON_CANCEL)\n\t\t|| name.equals(Events.ON_CTRL_KEY)) {\n\t\t\tEvents.postEvent(KeyEvent.getKeyEvent(request));\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"641155bf9eab5c3917c2ce5857ebe4873d6a5285","url":"https://github.com/zkoss/zk"},{"original_method":"protected void updateGeneral(\n\t\t\tActionRequest actionRequest, PortletPreferences preferences)\n\t\tthrows Exception {\n\n\t\tString allowAnonymousPosting = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"allowAnonymousPosting\");\n\t\tString enableFlags = ParamUtil.getString(\n\t\t\tactionRequest, \"enableFlags\");\n\t\tboolean enableMessageRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableMessageRatings\");\n\n\t\tpreferences.setValue(\"allow-anonymous-posting\", allowAnonymousPosting);\n\t\tpreferences.setValue(\"enable-flags\", enableFlags);\n\t\tpreferences.setValue(\n\t\t\t\"enable-message-ratings\", String.valueOf(enableMessageRatings));\n\t}","id":106791,"modified_method":"protected void updateRatings(\n\t\t\tActionRequest actionRequest, PortletPreferences preferences)\n\t\tthrows Exception {\n\n\t\tboolean enableMessageRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableMessageRatings\");\n\n\t\tpreferences.setValue(\n\t\t\t\"enable-message-ratings\", String.valueOf(enableMessageRatings));\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\n\t\tString tabs2 = ParamUtil.getString(actionRequest, \"tabs2\");\n\n\t\tif (tabs2.equals(\"email-from\")) {\n\t\t\tupdateEmailFrom(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"general\")) {\n\t\t\tupdateGeneral(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"message-added-email\")) {\n\t\t\tupdateEmailMessageAdded(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"message-updated-email\")) {\n\t\t\tupdateEmailMessageUpdated(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"rss\")) {\n\t\t\tupdateRSS(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"thread-priorities\")) {\n\t\t\tupdateThreadPriorities(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"user-ranks\")) {\n\t\t\tupdateUserRanks(actionRequest, preferences);\n\t\t}\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tpreferences.store();\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest, portletConfig.getPortletName() + \".doConfigure\");\n\t\t}\n\t}","id":106792,"modified_method":"public void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\n\t\tString tabs2 = ParamUtil.getString(actionRequest, \"tabs2\");\n\n\t\tif (tabs2.equals(\"anonymous-posting\")) {\n\t\t\tupdateAnonymousPosting(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"email-from\")) {\n\t\t\tupdateEmailFrom(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"message-added-email\")) {\n\t\t\tupdateEmailMessageAdded(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"message-updated-email\")) {\n\t\t\tupdateEmailMessageUpdated(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"ratings\")) {\n\t\t\tupdateRatings(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"rss\")) {\n\t\t\tupdateRSS(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"thread-priorities\")) {\n\t\t\tupdateThreadPriorities(actionRequest, preferences);\n\t\t}\n\t\telse if (tabs2.equals(\"user-ranks\")) {\n\t\t\tupdateUserRanks(actionRequest, preferences);\n\t\t}\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tpreferences.store();\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest, portletConfig.getPortletName() + \".doConfigure\");\n\t\t}\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tint pageDelta = ParamUtil.getInteger(actionRequest, \"pageDelta\");\n\t\tString pageDisplayStyle = ParamUtil.getString(\n\t\t\tactionRequest, \"pageDisplayStyle\");\n\t\tboolean enableRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableRatings\");\n\t\tboolean enableComments = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableComments\");\n\t\tboolean enableCommentRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableCommentRatings\");\n\t\tboolean enableFlags = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableFlags\");\n\n\t\tint rssDelta = ParamUtil.getInteger(actionRequest, \"rssDelta\");\n\t\tString rssDisplayStyle = ParamUtil.getString(\n\t\t\tactionRequest, \"rssDisplayStyle\");\n\t\tString rssFormat = ParamUtil.getString(actionRequest, \"rssFormat\");\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\n\t\tpreferences.setValue(\"page-delta\", String.valueOf(pageDelta));\n\t\tpreferences.setValue(\"page-display-style\", pageDisplayStyle);\n\t\tpreferences.setValue(\"enable-ratings\", String.valueOf(enableRatings));\n\t\tpreferences.setValue(\"enable-comments\", String.valueOf(enableComments));\n\t\tpreferences.setValue(\n\t\t\t\"enable-comment-ratings\", String.valueOf(enableCommentRatings));\n\t\tpreferences.setValue(\"enable-flags\", String.valueOf(enableFlags));\n\n\t\tpreferences.setValue(\"rss-delta\", String.valueOf(rssDelta));\n\t\tpreferences.setValue(\"rss-display-style\", rssDisplayStyle);\n\t\tpreferences.setValue(\"rss-format\", rssFormat);\n\n\t\tpreferences.store();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest, portletConfig.getPortletName() + \".doConfigure\");\n\t}","id":106793,"modified_method":"public void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tint pageDelta = ParamUtil.getInteger(actionRequest, \"pageDelta\");\n\t\tString pageDisplayStyle = ParamUtil.getString(\n\t\t\tactionRequest, \"pageDisplayStyle\");\n\t\tboolean enableRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableRatings\");\n\t\tboolean enableComments = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableComments\");\n\t\tboolean enableCommentRatings = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"enableCommentRatings\");\n\n\t\tint rssDelta = ParamUtil.getInteger(actionRequest, \"rssDelta\");\n\t\tString rssDisplayStyle = ParamUtil.getString(\n\t\t\tactionRequest, \"rssDisplayStyle\");\n\t\tString rssFormat = ParamUtil.getString(actionRequest, \"rssFormat\");\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\n\t\tpreferences.setValue(\"page-delta\", String.valueOf(pageDelta));\n\t\tpreferences.setValue(\"page-display-style\", pageDisplayStyle);\n\t\tpreferences.setValue(\"enable-ratings\", String.valueOf(enableRatings));\n\t\tpreferences.setValue(\"enable-comments\", String.valueOf(enableComments));\n\t\tpreferences.setValue(\n\t\t\t\"enable-comment-ratings\", String.valueOf(enableCommentRatings));\n\n\t\tpreferences.setValue(\"rss-delta\", String.valueOf(rssDelta));\n\t\tpreferences.setValue(\"rss-display-style\", rssDisplayStyle);\n\t\tpreferences.setValue(\"rss-format\", rssFormat);\n\n\t\tpreferences.store();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest, portletConfig.getPortletName() + \".doConfigure\");\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() throws JspException {\n\t\tint value = super.doEndTag();\n\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:image\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:message\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:messageHover\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:src\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:srcHover\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:url\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:method\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:target\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:label\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:toolTip\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:cssClass\");\n\n\t\t\treturn value;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_image = null;\n\t\t\t\t_imageHover = null;\n\t\t\t\t_message = null;\n\t\t\t\t_src = null;\n\t\t\t\t_srcHover = null;\n\t\t\t\t_url = null;\n\t\t\t\t_method = null;\n\t\t\t\t_target = null;\n\t\t\t\t_label = false;\n\t\t\t\t_toolTip = false;\n\t\t\t}\n\t\t}\n\t}","id":106794,"modified_method":"public int doEndTag() throws JspException {\n\t\tint value = super.doEndTag();\n\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:image\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:message\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:src\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:url\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:method\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:target\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:label\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:toolTip\");\n\t\t\trequest.removeAttribute(\"liferay-ui:icon:cssClass\");\n\n\t\t\treturn value;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_image = null;\n\t\t\t\t_message = null;\n\t\t\t\t_src = null;\n\t\t\t\t_url = null;\n\t\t\t\t_method = null;\n\t\t\t\t_target = null;\n\t\t\t\t_label = false;\n\t\t\t\t_toolTip = false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\trequest.setAttribute(\"liferay-ui:icon:image\", _image);\n\t\trequest.setAttribute(\"liferay-ui:icon:imageHover\", _imageHover);\n\t\trequest.setAttribute(\"liferay-ui:icon:message\", _message);\n\t\trequest.setAttribute(\"liferay-ui:icon:src\", _src);\n\t\trequest.setAttribute(\"liferay-ui:icon:srcHover\", _srcHover);\n\t\trequest.setAttribute(\"liferay-ui:icon:url\", _url);\n\t\trequest.setAttribute(\"liferay-ui:icon:method\", _method);\n\t\trequest.setAttribute(\"liferay-ui:icon:target\", _target);\n\t\trequest.setAttribute(\"liferay-ui:icon:label\", String.valueOf(_label));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:icon:toolTip\", String.valueOf(_toolTip));\n\t\trequest.setAttribute(\"liferay-ui:icon:cssClass\", _cssClass);\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","id":106795,"modified_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\trequest.setAttribute(\"liferay-ui:icon:image\", _image);\n\t\trequest.setAttribute(\"liferay-ui:icon:message\", _message);\n\t\trequest.setAttribute(\"liferay-ui:icon:src\", _src);\n\t\trequest.setAttribute(\"liferay-ui:icon:url\", _url);\n\t\trequest.setAttribute(\"liferay-ui:icon:method\", _method);\n\t\trequest.setAttribute(\"liferay-ui:icon:target\", _target);\n\t\trequest.setAttribute(\"liferay-ui:icon:label\", String.valueOf(_label));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:icon:toolTip\", String.valueOf(_toolTip));\n\t\trequest.setAttribute(\"liferay-ui:icon:cssClass\", _cssClass);\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getDisplayURL(ThemeDisplay themeDisplay) {\n\t\treturn getDisplayURL(\n\t\t\tthemeDisplay.getPortalURL(), themeDisplay.getPathMain());\n\n\t}","id":106796,"modified_method":"public String getDisplayURL(ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tGroup group = getGroup();\n\n\t\t\tif (group != null) {\n\t\t\t\tint publicLayoutsPageCount = group.getPublicLayoutsPageCount();\n\n\t\t\t\tif (publicLayoutsPageCount > 0) {\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\t\tsb.append(themeDisplay.getPortalURL());\n\t\t\t\t\tsb.append(themeDisplay.getPathMain());\n\t\t\t\t\tsb.append(\"/my_places/view?groupId=\");\n\t\t\t\t\tsb.append(group.getGroupId());\n\t\t\t\t\tsb.append(\"&privateLayout=0\");\n\n\t\t\t\t\treturn sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"ec9f66897cdf01c506ccb05d59fa1a2b5b058602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ServiceBuilder<String> addService(final ServiceName sname, final String abstractPath, final BatchBuilder batchBuilder) {\n        AbsolutePathService service = new AbsolutePathService(abstractPath);\n        return batchBuilder.addService(sname, service);\n    }","id":106797,"modified_method":"public static void addService(final ServiceName sname, final String abstractPath, final ServiceTarget target) {\n        AbsolutePathService service = new AbsolutePathService(abstractPath);\n        target.addService(sname, service);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder<String> addService(final String name, final String abstractPath, final BatchBuilder batchBuilder) {\n        return addService(pathNameOf(name), abstractPath, batchBuilder);\n    }","id":106798,"modified_method":"public static void addService(final String name, final String abstractPath, final ServiceTarget target) {\n        addService(pathNameOf(name), abstractPath, target);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <T> ServiceBuilder<T> addThreadFactoryDependency(final ServiceName serviceName, ServiceBuilder<T> serviceBuilder, Injector<ThreadFactory> injector, BatchBuilder builder) {\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            builder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = ThreadsServices.threadFactoryName(threadFactory);\n        }\n        return serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, injector);\n    }","id":106799,"modified_method":"protected <T> void addThreadFactoryDependency(final ServiceName serviceName, ServiceBuilder<T> serviceBuilder, Injector<ThreadFactory> injector, ServiceTarget target) {\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            target.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = ThreadsServices.threadFactoryName(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, injector);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add the deployment scanner service to a batch.\n     *\n     * @param batchBuilder the batch builder\n     * @param name the repository name\n     * @param relativeTo the relative to\n     * @param path the path\n     * @param scanInterval the scan interval\n     * @param timeUnit the time unit\n     * @param scanEnabled scan enabled\n     * @return\n     */\n    public static ServiceBuilder<DeploymentScanner> addService(final BatchBuilder batchBuilder,\n            final String name, final String relativeTo, final String path, final int scanInterval, TimeUnit unit, final boolean scanEnabled) {\n        final DeploymentScannerService service = new DeploymentScannerService(scanInterval, unit, scanEnabled);\n        final ServiceName serviceName = getServiceName(name);\n        final ServiceName pathService = serviceName.append(\"path\");\n\n        if(relativeTo != null) {\n            RelativePathService.addService(pathService, path, relativeTo, batchBuilder);\n        } else {\n            AbsolutePathService.addService(pathService, path, batchBuilder);\n        }\n\n        return batchBuilder.addService(serviceName, service)\n            .addDependency(pathService, String.class, service.pathValue)\n            .addDependency(DeploymentScannerFactory.SERVICE_NAME, DeploymentScannerFactory.class, service.scannerFactory)\n            .setInitialMode(Mode.ACTIVE);\n\n    }","id":106800,"modified_method":"/**\n     * Add the deployment scanner service to a batch.\n     *\n     * @param batchBuilder the batch builder\n     * @param name the repository name\n     * @param relativeTo the relative to\n     * @param path the path\n     * @param scanInterval the scan interval\n     * @param timeUnit the time unit\n     * @param scanEnabled scan enabled\n     * @return\n     */\n    public static void addService(final ServiceTarget batchBuilder,\n            final String name, final String relativeTo, final String path, final int scanInterval, TimeUnit unit, final boolean scanEnabled) {\n        final DeploymentScannerService service = new DeploymentScannerService(scanInterval, unit, scanEnabled);\n        final ServiceName serviceName = getServiceName(name);\n        final ServiceName pathService = serviceName.append(\"path\");\n\n        if(relativeTo != null) {\n            RelativePathService.addService(pathService, path, relativeTo, batchBuilder);\n        } else {\n            AbsolutePathService.addService(pathService, path, batchBuilder);\n        }\n\n        batchBuilder.addService(serviceName, service)\n            .addDependency(pathService, String.class, service.pathValue)\n            .addDependency(DeploymentScannerFactory.SERVICE_NAME, DeploymentScannerFactory.class, service.scannerFactory)\n            .setInitialMode(Mode.ACTIVE);\n\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void, P> resultHandler, P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        JMXConnectorService.addService(builder, serverBinding, registryBinding)\n            .addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n    }","id":106801,"modified_method":"/** {@inheritDoc} */\n    protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void, P> resultHandler, P param) {\n        final ServiceTarget target = updateContext.getBatchBuilder().subTarget();\n        target.addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n        JMXConnectorService.addService(target, serverBinding, registryBinding);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder<?> addService(final BatchBuilder batchBuilder, final String serverBinding, final String registryBinding) {\n        JMXConnectorService jmxConnectorService = new JMXConnectorService();\n        ServiceBuilder<Void> serviceBuilder = batchBuilder.addService(JMXConnectorService.SERVICE_NAME, jmxConnectorService)\n                .addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, jmxConnectorService.getMBeanServerServiceInjector())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(registryBinding), SocketBinding.class, jmxConnectorService.getRegistryPortBinding())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(serverBinding), SocketBinding.class, jmxConnectorService.getServerPortBinding())\n                .setInitialMode(ServiceController.Mode.ACTIVE);\n        return serviceBuilder;\n    }","id":106802,"modified_method":"public static void addService(final ServiceTarget target, final String serverBinding, final String registryBinding) {\n        JMXConnectorService jmxConnectorService = new JMXConnectorService();\n        target.addService(JMXConnectorService.SERVICE_NAME, jmxConnectorService)\n                .addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, jmxConnectorService.getMBeanServerServiceInjector())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(registryBinding), SocketBinding.class, jmxConnectorService.getRegistryPortBinding())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(serverBinding), SocketBinding.class, jmxConnectorService.getServerPortBinding())\n                .setInitialMode(ServiceController.Mode.ACTIVE);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder<String> addService(final ServiceName name, final String relativePath,\n            final String relativeTo, final BatchBuilder batchBuilder) {\n        RelativePathService service = new RelativePathService(relativePath);\n        return batchBuilder.addService(name, service)\n                    .addDependency(pathNameOf(relativeTo), String.class, service.injectedPath);\n    }","id":106803,"modified_method":"public static void addService(final ServiceName name, final String relativePath,\n            final String relativeTo, final ServiceTarget target) {\n        RelativePathService service = new RelativePathService(relativePath);\n        target.addService(name, service)\n                    .addDependency(pathNameOf(relativeTo), String.class, service.injectedPath);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder<String> addService(final String name, final String relativePath,\n            final String relativeTo, final BatchBuilder batchBuilder) {\n        return addService(pathNameOf(name), relativePath, relativeTo, batchBuilder);\n    }","id":106804,"modified_method":"public static void addService(final String name, final String relativePath,\n            final String relativeTo, final ServiceTarget target) {\n        addService(pathNameOf(name), relativePath, relativeTo, target);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final BatchBuilder batch = updateContext.getBatchBuilder();\n        final ServiceBuilder<?> builder = DeploymentScannerService.addService(batch, repositoryName(), relativeTo, path, interval, TimeUnit.MILLISECONDS, enabled);\n        builder.addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n    }","id":106805,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final ServiceTarget target = updateContext.getBatchBuilder().subTarget();\n        target.addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n        DeploymentScannerService.addService(target, repositoryName(), relativeTo, path, interval, TimeUnit.MILLISECONDS, enabled);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public <P> void applyUpdate(UpdateContext context, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final BatchBuilder batch = context.getBatchBuilder();\n        final ServiceBuilder<?> builder = createService(batch);\n        builder.addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n    }","id":106806,"modified_method":"/** {@inheritDoc} */\n    public <P> void applyUpdate(UpdateContext context, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final ServiceTarget target = context.getBatchBuilder().subTarget();\n        target.addListener(new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param));\n        createService(target);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final BatchBuilder batchBuilder = updateContext.getBatchBuilder();\n        final ServiceBuilder<SocketBinding> builder = SocketBindingService.addService(batchBuilder, this);\n        final UpdateResultHandler.ServiceStartListener<P> listener = new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param);\n        builder.addListener(listener);\n    }","id":106807,"modified_method":"protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void,P> resultHandler, P param) {\n        final ServiceTarget target = updateContext.getBatchBuilder().subTarget();\n        final UpdateResultHandler.ServiceStartListener<P> listener = new UpdateResultHandler.ServiceStartListener<P>(resultHandler, param);\n        target.addListener(listener);\n        SocketBindingService.addService(target, this);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder<SocketBinding> addService(BatchBuilder builder, SocketBindingAdd add) {\n        SocketBindingService service = new SocketBindingService(add.getName(), add.getPort(), add.isFixedPort(),\n                   add.getMulticastAddress(), add.getMulticastPort());\n        ServiceBuilder<SocketBinding> batch = builder\n            .addService(SocketBinding.JBOSS_BINDING_NAME.append(add.getName()), service);\n        batch.addDependency(NetworkInterfaceService.JBOSS_NETWORK_INTERFACE.append(add.getInterfaceName()),\n                NetworkInterfaceBinding.class, service.getInterfaceBinding());\n        batch.addDependency(SocketBindingManager.SOCKET_BINDING_MANAGER,\n                SocketBindingManager.class, service.getSocketBindings());\n        batch.setInitialMode(Mode.ON_DEMAND);\n        return batch;\n    }","id":106808,"modified_method":"public static void addService(ServiceTarget target, SocketBindingAdd add) {\n        SocketBindingService service = new SocketBindingService(add.getName(), add.getPort(), add.isFixedPort(),\n                   add.getMulticastAddress(), add.getMulticastPort());\n        ServiceBuilder<SocketBinding> batch = target\n            .addService(SocketBinding.JBOSS_BINDING_NAME.append(add.getName()), service);\n        batch.addDependency(NetworkInterfaceService.JBOSS_NETWORK_INTERFACE.append(add.getInterfaceName()),\n                NetworkInterfaceBinding.class, service.getInterfaceBinding());\n        batch.addDependency(SocketBindingManager.SOCKET_BINDING_MANAGER,\n                SocketBindingManager.class, service.getSocketBindings());\n        batch.setInitialMode(Mode.ON_DEMAND);\n    }","commit_id":"3ee9d4364ad73d133bb16804e0fcdb713577df7b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void collectDependencies(boolean checkOnly) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ?\n          usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) :\n          false\n        );\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    for (Dependency dependency : dependencies) {\n      ModuleReference moduleRef = dependency.getModuleRef();\n      if (moduleRef.getModuleFqName().contains(\"#\")) {\n        report(\"module cannot depend on generator: `\" + moduleRef.getModuleFqName() + \"'\", myOriginalModule);\n      }\n    }\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    // resolve all dependencies \n    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          if (genContext != null) {\n            genContext.showWarningMessage(myOriginalModule, \"unsatisfied dependency: \" + dep.getModuleRef().toString());\n          }\n          // TODO FIXME \n          // <node> \n          continue;\n        }\n      }\n\n      Boolean alreadyReexport = depsToReexport.get(resolved);\n      if (alreadyReexport != null && alreadyReexport.booleanValue()) {\n        continue;\n      }\n      depsToReexport.put(resolved, reexport);\n    }\n\n    // check & create \n    for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {\n      SNode resolved = entry.getKey();\n      boolean reexport = entry.getValue().booleanValue();\n\n      boolean found = false;\n      if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, \"uuid\"))) {\n        found = true;\n        boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, \"uuid\"));\n        if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\"))) {\n          report(\"wrong reexport status for dependency in build script for: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n        }\n      }\n\n      if (reexport && !(extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\")))) {\n        report(\"reexport dependency should be extracted into build script: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n      }\n      if (!(found)) {\n        if (checkOnly) {\n          continue;\n        }\n\n        SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n        SLinkOperations.setTarget(res, \"module\", resolved, false);\n        SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n      }\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final String relPath = BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p);\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            SNode dep = (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\") ?\n              SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true) :\n              it\n            );\n            return SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_a6ewnz_a0a1a0a0a0a0b0g0r0q(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true)), relPath);\n          }\n        }))) {\n          report(\"jar stub library should be extracted into build script: \" + relPath, myOriginalModule);\n        }\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n\n  }","id":106809,"modified_method":"private void collectDependencies(boolean checkOnly) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();\n    Set<String> extractedModules = new HashSet<String>();\n    for (SNode dep : SLinkOperations.getTargets(module, \"dependencies\", true)) {\n      boolean extracted = false;\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\")) {\n        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n        extracted = true;\n      }\n      if (SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\")) {\n        SNode onModule = SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\");\n        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) ?\n          usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\")) :\n          false\n        );\n        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"), SPropertyOperations.getBoolean(onModule, \"reexport\") || existing);\n        if (extracted) {\n          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, \"module\", false), \"uuid\"));\n        }\n      }\n    }\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    for (Dependency dependency : dependencies) {\n      ModuleReference moduleRef = dependency.getModuleRef();\n      if (moduleRef.getModuleFqName().contains(\"#\")) {\n        report(\"module cannot depend on generator: `\" + moduleRef.getModuleFqName() + \"'\", myOriginalModule);\n      }\n    }\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    // resolve all dependencies \n    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"unsatisfied dependency: \" + dep.getModuleRef().toString(), myOriginalModule);\n          continue;\n        }\n      }\n\n      Boolean alreadyReexport = depsToReexport.get(resolved);\n      if (alreadyReexport != null && alreadyReexport.booleanValue()) {\n        continue;\n      }\n      depsToReexport.put(resolved, reexport);\n    }\n\n    // check & create \n    for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {\n      SNode resolved = entry.getKey();\n      boolean reexport = entry.getValue().booleanValue();\n\n      boolean found = false;\n      if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, \"uuid\"))) {\n        found = true;\n        boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, \"uuid\"));\n        if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\"))) {\n          report(\"wrong reexport status for dependency in build script for: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n        }\n      }\n\n      if (reexport && !(extractedModules.contains(SPropertyOperations.getString(resolved, \"uuid\")))) {\n        report(\"reexport dependency should be extracted into build script: \" + SPropertyOperations.getString(resolved, \"name\"), myOriginalModule);\n      }\n      if (!(found)) {\n        if (checkOnly) {\n          continue;\n        }\n\n        SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n        SLinkOperations.setTarget(res, \"module\", resolved, false);\n        SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(res);\n      }\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final String relPath = BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p);\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            SNode dep = (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\") ?\n              SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true) :\n              it\n            );\n            return SNodeOperations.isInstanceOf(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_a6ewnz_a0a1a0a0a0a0b0g0r0q(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(dep, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true)), relPath);\n          }\n        }))) {\n          report(\"jar stub library should be extracted into build script: \" + relPath, myOriginalModule);\n        }\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadFile() {\n    String moduleFilePath = BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(myModule, \"path\", true), (genContext != null ?\n      Context.defaultContext(genContext) :\n      Context.defaultContext()\n    ));\n    try {\n      moduleFilePath = new File(moduleFilePath).getCanonicalPath();\n    } catch (IOException ex) {\n      // ignore \n    }\n    IFile file = FileSystem.getInstance().getFileByPath(moduleFilePath);\n    if (!(file.exists()) || file.isDirectory()) {\n      report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": file doesn't exist (\" + moduleFilePath + \")\", myOriginalModule);\n      return;\n    }\n\n    try {\n      ModuleDescriptor md = load(file);\n      if (md.getLoadException() != null) {\n        report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": exception: \" + md.getLoadException().getMessage(), myOriginalModule);\n        return;\n      }\n\n      myModuleDescriptor = md;\n      myModuleFile = file;\n    } catch (Exception ex) {\n      report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": exception: \" + ex.getMessage(), myOriginalModule);\n      ex.printStackTrace(System.err);\n    }\n  }","id":106810,"modified_method":"private void loadFile() {\n    String moduleFilePath = BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(myModule, \"path\", true), (genContext != null ?\n      Context.defaultContext(genContext) :\n      Context.defaultContext()\n    ));\n    try {\n      moduleFilePath = new File(moduleFilePath).getCanonicalPath();\n    } catch (IOException ex) {\n      // ignore \n    }\n    IFile file = FileSystem.getInstance().getFileByPath(moduleFilePath);\n    if (!(file.exists()) || file.isDirectory()) {\n      report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": file doesn't exist (\" + moduleFilePath + \")\", myOriginalModule);\n      return;\n    }\n\n    try {\n      ModuleDescriptor md = load(file);\n      if (md.getLoadException() != null) {\n        report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": exception: \" + md.getLoadException().getMessage(), myOriginalModule);\n        return;\n      }\n\n      myModuleDescriptor = md;\n      myModuleFile = file;\n    } catch (Exception ex) {\n      report(\"cannot import module file for \" + SPropertyOperations.getString(myModule, \"name\") + \": exception: \" + ex.getMessage(), myOriginalModule, ex);\n      ex.printStackTrace(System.err);\n    }\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    Set<SNode> seen = new HashSet<SNode>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      if (!(reexport)) {\n        continue;\n      }\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          if (genContext != null) {\n            genContext.showWarningMessage(myOriginalModule, \"unsatisfied dependency: \" + dep.getModuleRef().toString());\n          }\n          // TODO FIXME \n          // <node> \n          continue;\n        }\n      }\n\n      if (!(seen.add(resolved))) {\n        continue;\n      }\n\n      SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n      SLinkOperations.setTarget(res, \"module\", resolved, false);\n      SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n      SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n      SLinkOperations.setTarget(extr, \"dependency\", res, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":106811,"modified_method":"private void importDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    Set<SNode> seen = new HashSet<SNode>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n      if (!(reexport)) {\n        continue;\n      }\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"unsatisfied dependency: \" + dep.getModuleRef().toString(), myOriginalModule);\n          continue;\n        }\n      }\n\n      if (!(seen.add(resolved))) {\n        continue;\n      }\n\n      SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n      SLinkOperations.setTarget(res, \"module\", resolved, false);\n      SPropertyOperations.set(res, \"reexport\", \"\" + reexport);\n      SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n      SLinkOperations.setTarget(extr, \"dependency\", res, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String expandPath(@Nullable String path) {\n      if (path == null) {\n        return null;\n      }\n\n      if (moduleFile != null && (path.startsWith(MacrosFactory.LANGUAGE_DESCRIPTOR) || path.startsWith(MacrosFactory.DEVKIT_DESCRIPTOR) || path.startsWith(MacrosFactory.SOLUTION_DESCRIPTOR))) {\n        String relPath = path.substring(path.indexOf('}') + 1);\n        return IFileUtils.getCanonicalPath(moduleFile.getParent().getDescendant(relPath));\n      }\n      if (path.startsWith(\"${\")) {\n        int index = path.indexOf(\"}\");\n        if (index == -1) {\n          report(\"invalid macro in `\" + path + \"'\", null);\n          return path;\n        }\n\n        String macroName = path.substring(2, index);\n        SNode found = null;\n        for (SNode macro : SLinkOperations.getTargets(SNodeOperations.getAncestor(myOriginalModule, \"jetbrains.mps.build.structure.BuildProject\", false, false), \"macros\", true)) {\n          if (!(SNodeOperations.isInstanceOf(macro, \"jetbrains.mps.build.structure.BuildFolderMacro\"))) {\n            continue;\n          }\n\n          if (eq_a6ewnz_a0c0f0d0a1(SPropertyOperations.getString(macro, \"name\"), macroName)) {\n            found = SNodeOperations.cast(macro, \"jetbrains.mps.build.structure.BuildFolderMacro\");\n            break;\n          }\n        }\n        if (found == null) {\n          report(\"macro is not declared in build script: \" + path, null);\n          return path;\n        }\n\n        String localPath = BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(found, \"defaultPath\", true), (genContext != null ?\n          Context.defaultContext(genContext) :\n          Context.defaultContext()\n        ));\n        String relPath = path.substring(index + 1);\n        return IFileUtils.getCanonicalPath(FileSystem.getInstance().getFileByPath(localPath).getDescendant(relPath));\n      }\n      return path;\n    }","id":106812,"modified_method":"public String expandPath(@Nullable String path) {\n      if (path == null) {\n        return null;\n      }\n\n      if (moduleFile != null && (path.startsWith(MacrosFactory.LANGUAGE_DESCRIPTOR) || path.startsWith(MacrosFactory.DEVKIT_DESCRIPTOR) || path.startsWith(MacrosFactory.SOLUTION_DESCRIPTOR))) {\n        String relPath = path.substring(path.indexOf('}') + 1);\n        return IFileUtils.getCanonicalPath(moduleFile.getParent().getDescendant(relPath));\n      }\n      if (path.startsWith(\"${\")) {\n        int index = path.indexOf(\"}\");\n        if (index == -1) {\n          report(\"invalid macro in `\" + path + \"'\", null);\n          return path;\n        }\n\n        String macroName = path.substring(2, index);\n        SNode found = null;\n        for (SNode macro : SLinkOperations.getTargets(SNodeOperations.getAncestor(myOriginalModule, \"jetbrains.mps.build.structure.BuildProject\", false, false), \"macros\", true)) {\n          if (!(SNodeOperations.isInstanceOf(macro, \"jetbrains.mps.build.structure.BuildFolderMacro\"))) {\n            continue;\n          }\n\n          if (eq_a6ewnz_a0c0f0d0a1(SPropertyOperations.getString(macro, \"name\"), macroName)) {\n            found = SNodeOperations.cast(macro, \"jetbrains.mps.build.structure.BuildFolderMacro\");\n            break;\n          }\n        }\n        if (found == null) {\n          report(\"macro is not declared in build script: \" + path, null);\n          return path;\n        }\n\n        String localPath = BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(found, \"defaultPath\", true), (genContext != null ?\n          Context.defaultContext(genContext) :\n          Context.defaultContext()\n        ));\n        if (localPath == null) {\n          if (genContext != null) {\n            genContext.showWarningMessage(found, \"cannot resolve local path: \" + path + \", macro has no default value\");\n          }\n          return path;\n        }\n\n        String relPath = path.substring(index + 1);\n        return IFileUtils.getCanonicalPath(FileSystem.getInstance().getFileByPath(localPath).getDescendant(relPath));\n      }\n      return path;\n    }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void report(String message, SNode node) {\n    if (genContext == null) {\n      throw new ModuleLoader.ModuleLoaderException(message, node);\n    }\n\n    genContext.showErrorMessage(node, message);\n  }","id":106813,"modified_method":"protected void report(String message, SNode node) {\n    report(message, node, null);\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<SNode> convertPath(String path, SNode anchor) {\n    try {\n      return pathConverter.convertPath(path, SNodeOperations.getModel(myModule));\n    } catch (PathConverter.PathConvertException ex) {\n      report(ex.getMessage(), anchor);\n      return null;\n    }\n  }","id":106814,"modified_method":"private List<SNode> convertPath(String path, SNode anchor) {\n    try {\n      return pathConverter.convertPath(path, SNodeOperations.getModel(myModule));\n    } catch (PathConverter.PathConvertException ex) {\n      report(ex.getMessage(), anchor, ex);\n      return null;\n    }\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleLoaderException(String message, SNode node) {\n      super(message);\n      this.node = node;\n    }","id":106815,"modified_method":"public ModuleLoaderException(String message, SNode node, Throwable cause) {\n      super(message, cause);\n      this.node = node;\n    }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n\n    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());\n    ListSequence.fromList(SLinkOperations.getTargets(project, \"macros\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.structure.BuildFolderMacro\");\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        String path = normalizePath(BuildFolderMacro_Behavior.call_evaluate_4959435991187146982(SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\"), Context.defaultContext()), true);\n        if (path != null && path.length() > 1) {\n          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\")));\n        }\n      }\n    });\n    ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));\n    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Comparable<?>>() {\n      public Comparable<?> select(Tuples._2<String, SNode> it) {\n        return it._0().length() * 2 - ((it._1() == null ?\n          1 :\n          0\n        ));\n      }\n    }, false);\n  }","id":106816,"modified_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n\n    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());\n    final List<SNode> withoutPath = ListSequence.fromList(new ArrayList<SNode>());\n    ListSequence.fromList(SLinkOperations.getTargets(project, \"macros\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.structure.BuildFolderMacro\");\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        String path = normalizePath(BuildFolderMacro_Behavior.call_evaluate_4959435991187146982(SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\"), Context.defaultContext()), true);\n        if (path != null && path.length() > 1) {\n          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\")));\n        } else {\n          ListSequence.fromList(withoutPath).addElement(SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\"));\n        }\n      }\n    });\n    ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));\n    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Comparable<?>>() {\n      public Comparable<?> select(Tuples._2<String, SNode> it) {\n        return it._0().length() * 2 - ((it._1() == null ?\n          1 :\n          0\n        ));\n      }\n    }, false);\n    macrosWithoutPath = withoutPath;\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {\n    path = normalizePath(path, false);\n    String withSlash = normalizePath(path, true);\n    List<SNode> result = new ArrayList<SNode>();\n    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {\n      String mdir = m._0();\n      String currPath = (path.length() < mdir.length() ?\n        withSlash :\n        path\n      );\n      if (!(currPath.startsWith(mdir))) {\n        continue;\n      }\n      currPath = currPath.substring(mdir.length());\n      SNode relPath;\n      if (m._1() == null) {\n        relPath = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildSourceProjectRelativePath\", null);\n      } else {\n        relPath = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\", null);\n        SLinkOperations.setTarget(SNodeOperations.cast(relPath, \"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\"), \"macro\", m._1(), false);\n      }\n      buildCompositePath(relPath, currPath, model);\n      ListSequence.fromList(result).addElement(relPath);\n\n    }\n    if ((int) ListSequence.fromList(result).count() == 0) {\n      throw new PathConverter.PathConvertException(\"source path (\" + path + \") should be under working directory (\" + workingDirectory + \"), or any macros default directory\");\n\n    }\n    return result;\n  }","id":106817,"modified_method":"public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {\n    path = normalizePath(path, false);\n    String withSlash = normalizePath(path, true);\n    List<SNode> result = new ArrayList<SNode>();\n    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {\n      String mdir = (path.startsWith(\"$\") && m._1() != null ?\n        \"${\" + SPropertyOperations.getString(m._1(), \"name\") + \"}/\" :\n        m._0()\n      );\n      String currPath = (path.length() < mdir.length() ?\n        withSlash :\n        path\n      );\n\n      if (currPath.startsWith(mdir)) {\n        currPath = currPath.substring(mdir.length());\n      } else {\n        continue;\n      }\n      ListSequence.fromList(result).addElement(buildRelative(currPath, m._1(), model));\n    }\n    for (SNode m : Sequence.fromIterable(macrosWithoutPath)) {\n      String mdir = \"${\" + SPropertyOperations.getString(m, \"name\") + \"}/\";\n      String currPath = (path.length() < mdir.length() ?\n        withSlash :\n        path\n      );\n      if (currPath.startsWith(mdir)) {\n        currPath = currPath.substring(mdir.length());\n      } else {\n        continue;\n      }\n      ListSequence.fromList(result).addElement(buildRelative(currPath, m, model));\n    }\n    if ((int) ListSequence.fromList(result).count() == 0) {\n      throw new PathConverter.PathConvertException(\"source path (\" + path + \") should be under working directory (\" + workingDirectory + \"), or any macros default directory\");\n\n    }\n    return result;\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String normalizePath(String path, boolean addSlash) {\n    if (path == null || (path == null || path.length() == 0)) {\n      return null;\n    }\n    try {\n      path = new File(path).getCanonicalPath();\n      path = path.replace(\"\\\\\", \"/\");\n    } catch (IOException ignore) {\n      // ignore \n    }\n    if (addSlash && !(path.endsWith(\"/\"))) {\n      path = path + \"/\";\n    }\n    return path;\n  }","id":106818,"modified_method":"private static String normalizePath(String path, boolean addSlash) {\n    if (path == null || (path == null || path.length() == 0)) {\n      return null;\n    }\n    try {\n      path = (path.startsWith(\"${\") ?\n        path :\n        new File(path).getCanonicalPath()\n      );\n      path = path.replace(\"\\\\\", \"/\");\n    } catch (IOException ignore) {\n      // ignore \n    }\n    if (addSlash && !(path.endsWith(\"/\"))) {\n      path = path + \"/\";\n    }\n    return path;\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(SNode node) {\n    SNode module = SNodeOperations.as(node, \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\");\n    if (module == null) {\n      return;\n    }\n\n    SNode project = SNodeOperations.as(SNodeOperations.getContainingRoot(node), \"jetbrains.mps.build.structure.BuildProject\");\n    if ((project == null)) {\n      return;\n    }\n\n    PathConverter pathConverter = new PathConverter(project);\n\n    try {\n      VisibleModules visible = new VisibleModules(project, null);\n      visible.collect();\n      new ModuleLoader(module, visible, pathConverter, null).importRequired();\n    } catch (ModuleLoader.ModuleLoaderException ex) {\n      LOG.error(ex.getMessage());\n      // TODO report? \n    }\n  }","id":106819,"modified_method":"public void execute(SNode node) {\n    SNode module = SNodeOperations.as(node, \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\");\n    if (module == null) {\n      return;\n    }\n\n    SNode project = SNodeOperations.as(SNodeOperations.getContainingRoot(node), \"jetbrains.mps.build.structure.BuildProject\");\n    if ((project == null)) {\n      return;\n    }\n\n    PathConverter pathConverter = new PathConverter(project);\n\n    try {\n      VisibleModules visible = new VisibleModules(project, null);\n      visible.collect();\n      new ModuleLoader(module, visible, pathConverter, null).importRequired();\n    } catch (ModuleLoader.ModuleLoaderException ex) {\n      LOG.error(ex.getMessage(), ex);\n      // TODO report? \n    }\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode buildProject, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SNodeOperations.getModel(buildProject).isTransient() || SModelStereotype.isGeneratorModel(SNodeOperations.getModel(buildProject)) || !(SNodeOperations.getModel(buildProject).getModelDescriptor().isGeneratable())) {\n      return;\n    }\n\n    VisibleModules visible = null;\n    String workingDir = null;\n    for (final SNode module : ListSequence.fromList(SNodeOperations.getDescendants(buildProject, \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (SLinkOperations.getTarget(it, \"path\", true) != null);\n      }\n    })) {\n      if (visible == null) {\n        visible = new VisibleModules(buildProject, null);\n        visible.collect();\n        workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(buildProject, Context.defaultContext());\n        if ((workingDir == null || workingDir.length() == 0)) {\n          {\n            MessageTarget errorTarget = new NodeMessageTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(buildProject, \"working directory is unavailable\", \"r:473be7a1-ec10-4475-89b9-397d2558ecb0(jetbrains.mps.build.mps.typesystem)\", \"2531699772406302731\", null, errorTarget);\n          }\n          return;\n        }\n      }\n      final StringBuilder messages = new StringBuilder();\n      new ModuleLoader(module, visible, new PathConverter(buildProject), null) {\n        @Override\n        protected void report(String message, SNode node) {\n          if (messages.length() > 0) {\n            messages.append(\"\\n\");\n          }\n          messages.append(message);\n        }\n      }.checkModule();\n      if (messages.length() > 0) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(module, messages.toString(), \"r:473be7a1-ec10-4475-89b9-397d2558ecb0(jetbrains.mps.build.mps.typesystem)\", \"2531699772406302922\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.build.mps.typesystem.ReloadRequired_QuickFix\", false);\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n      }\n    }\n  }","id":106820,"modified_method":"public void applyRule(final SNode buildProject, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SNodeOperations.getModel(buildProject).isTransient() || SModelStereotype.isGeneratorModel(SNodeOperations.getModel(buildProject)) || !(SNodeOperations.getModel(buildProject).getModelDescriptor().isGeneratable())) {\n      return;\n    }\n\n    VisibleModules visible = null;\n    String workingDir = null;\n    for (final SNode module : ListSequence.fromList(SNodeOperations.getDescendants(buildProject, \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\", false, new String[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return (SLinkOperations.getTarget(it, \"path\", true) != null);\n      }\n    })) {\n      if (visible == null) {\n        visible = new VisibleModules(buildProject, null);\n        visible.collect();\n        workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(buildProject, Context.defaultContext());\n        if ((workingDir == null || workingDir.length() == 0)) {\n          {\n            MessageTarget errorTarget = new NodeMessageTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(buildProject, \"working directory is unavailable\", \"r:473be7a1-ec10-4475-89b9-397d2558ecb0(jetbrains.mps.build.mps.typesystem)\", \"2531699772406302731\", null, errorTarget);\n          }\n          return;\n        }\n      }\n      final StringBuilder messages = new StringBuilder();\n      new ModuleLoader(module, visible, new PathConverter(buildProject), null) {\n        @Override\n        protected void report(String message, SNode node, Exception cause) {\n          if (messages.length() > 0) {\n            messages.append(\"\\n\");\n          }\n          messages.append(message);\n        }\n      }.checkModule();\n      if (messages.length() > 0) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(module, messages.toString(), \"r:473be7a1-ec10-4475-89b9-397d2558ecb0(jetbrains.mps.build.mps.typesystem)\", \"2531699772406302922\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.build.mps.typesystem.ReloadRequired_QuickFix\", false);\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n      }\n    }\n  }","commit_id":"1a3cd775ae999ff6a2694610fff2c94d30ec577b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isGone() throws IOException {\n\t\tContentObject newBlock = null;\n\n\t\tif (null == _currentBlock && null == _goneBlock) {\n\t\t\tnewBlock = getFirstBlock(); // sets _goneBlock, but not _currentBlock\n\t\t}\n\t\tif (null == _goneBlock) {\n\t\t\tif (null != newBlock) {\n\t\t\t\tsetCurrentBlock(newBlock); // save it for reuse\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","id":106821,"modified_method":"/**\n\t * Is the stream GONE? I.E. Is there a single empty data block, of type GONE where\n\t * the first block should be? This convention is used to represent a stream that has been\n\t * deleted.\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic boolean isGone() throws IOException {\n\t\tContentObject newBlock = null;\n\n\t\t// TODO: once first block is always read in constructor this code will change\n\t\tif (null == _currentBlock && null == _goneBlock) {\n\t\t\tnewBlock = getFirstBlock(); // sets _goneBlock, but not _currentBlock\n\t\t}\n\t\tif (null == _goneBlock) {\n\t\t\tif (null != newBlock) {\n\t\t\t\tsetFirstBlock(newBlock); // save it for reuse\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Assumes starterBlock has been verified by caller.\n\t * @param starterBlock\n\t * @param library\n\t * @throws IOException\n\t */\n\tpublic CCNAbstractInputStream(ContentObject starterBlock, \t\t\t\n\t\t\tCCNLibrary library) throws IOException  {\n\t\tsuper();\n\t\tif (null == starterBlock) {\n\t\t\tthrow new IllegalArgumentException(\"starterBlock cannot be null!\");\n\t\t}\n\t\t_library = library; \n\t\tif (null == _library) {\n\t\t\t_library = CCNLibrary.getLibrary();\n\t\t}\n\t\tsetCurrentBlock(starterBlock);\n\t\t_publisher = starterBlock.signedInfo().getPublisherKeyID();\n\t\t_baseName = SegmentationProfile.segmentRoot(starterBlock.name());\n\t\ttry {\n\t\t\t_startingBlockIndex = SegmentationProfile.getSegmentNumber(starterBlock.name());\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tthrow new IOException(\"Stream starter block name does not contain a valid segment number, so the stream does not know what content to start with.\");\n\t\t}\n\t}","id":106822,"modified_method":"/**\n\t * Assumes starterBlock has been verified by caller.\n\t * @param starterBlock\n\t * @param library\n\t * @throws IOException\n\t */\n\tpublic CCNAbstractInputStream(ContentObject starterBlock, \t\t\t\n\t\t\tCCNLibrary library) throws IOException  {\n\t\tsuper();\n\t\tif (null == starterBlock) {\n\t\t\tthrow new IllegalArgumentException(\"starterBlock cannot be null!\");\n\t\t}\n\t\t_library = library; \n\t\tif (null == _library) {\n\t\t\t_library = CCNLibrary.getLibrary();\n\t\t}\n\t\tsetFirstBlock(starterBlock);\n\t\t_baseName = SegmentationProfile.segmentRoot(starterBlock.name());\n\t\ttry {\n\t\t\t_startingBlockIndex = SegmentationProfile.getSegmentNumber(starterBlock.name());\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tthrow new IOException(\"Stream starter block name does not contain a valid segment number, so the stream does not know what content to start with.\");\n\t\t}\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tprotected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"CCNBlockInputStream: reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\treturn 0; // nothing to read\n\t\t\t}\n\t\t\tsetCurrentBlock(firstBlock);\n\t\t} \n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, return what we read. On next read, pull next block.\n\t\tint remainingBytes = _blockReadStream.available();\n\t\t\n\t\tif (remainingBytes <= 0) {\n\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\tif (null == _currentBlock) {\n\t\t\t\t// in socket implementation, this would be EAGAIN\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tremainingBytes = _blockReadStream.available();\n\t\t}\n\t\t// Read minimum of remainder of this block and available buffer.\n\t\tlong readCount = (remainingBytes > len) ? len : remainingBytes;\n\t\tif (null != buf) { // use for skip\n\t\t\treadCount = _blockReadStream.read(buf, offset, len);\n\t\t} else {\n\t\t\treadCount = _blockReadStream.skip(len);\n\t\t}\n\t\tLibrary.logger().info(\"CCNBlockInputStream: read \" + readCount + \" bytes from block \" + _currentBlock.name());\n\t\treturn (int)readCount;\n\t}","id":106823,"modified_method":"@Override\n\tprotected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"CCNBlockInputStream: reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\treturn 0; // nothing to read\n\t\t\t}\n\t\t\tsetFirstBlock(firstBlock);\n\t\t} \n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, return what we read. On next read, pull next block.\n\t\tint remainingBytes = _blockReadStream.available();\n\t\t\n\t\tif (remainingBytes <= 0) {\n\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\tif (null == _currentBlock) {\n\t\t\t\t// in socket implementation, this would be EAGAIN\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tremainingBytes = _blockReadStream.available();\n\t\t}\n\t\t// Read minimum of remainder of this block and available buffer.\n\t\tlong readCount = (remainingBytes > len) ? len : remainingBytes;\n\t\tif (null != buf) { // use for skip\n\t\t\treadCount = _blockReadStream.read(buf, offset, len);\n\t\t} else {\n\t\t\treadCount = _blockReadStream.skip(len);\n\t\t}\n\t\tLibrary.logger().info(\"CCNBlockInputStream: read \" + readCount + \" bytes from block \" + _currentBlock.name());\n\t\treturn (int)readCount;\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tpublic long skip(long n) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"in skip(\"+n+\")\");\n\t\t\n\t\tif (n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (null == _header){\n\t\t\tsuper.skip(n);\n\t\t}\n\t\t\n\t\tint[] toGetBlockAndOffset = null;\n\t\tlong toGetPosition = 0;\n\t\t\n\t\tlong currentBlock = -1;\n\t\tint currentBlockOffset = 0;\n\t\tlong currentPosition = 0;\n\t\t\n\t\tif (_currentBlock == null) {\n\t\t\t//we do not have a block already\n\t\t\t//skip position is n\n\t\t\tcurrentPosition = 0;\n\t\t\ttoGetPosition = n;\n\t\t} else {\n\t\t    //we already have a block...  need to handle some tricky cases\n\t\t\tcurrentBlock = blockIndex();\n\t\t\tcurrentBlockOffset = (int)super.tell();\n\t\t\tcurrentPosition = _header.blockLocationToPosition(currentBlock, currentBlockOffset);\n\t\t\ttoGetPosition = currentPosition + n;\n\t\t}\n\t\t//make sure we don't skip past end of the object\n\t\tif (toGetPosition >= _header.length()) {\n\t\t\ttoGetPosition = _header.length();\n\t\t\t_atEOF = true;\n\t\t}\n\t\t\t\n\t\ttoGetBlockAndOffset = _header.positionToBlockLocation(toGetPosition);\n\t\t\n\t\t//make sure the position makes sense\n\t\t//is this a valid block?\n\t\tif (toGetBlockAndOffset[0] >= _header.blockCount()){\n\t\t\t//this is not a valid block number, subtract 1\n\t\t\tif (toGetBlockAndOffset[0] > 0) {\n\t\t\t\ttoGetBlockAndOffset[0]--;\n\t\t\t}\n\t\t\t//now we have the last block if the position was too long\n\t\t}\n\t\t\n\t\t//is the offset > 0?\n\t\tif (toGetBlockAndOffset[1] < 0) {\n\t\t\ttoGetBlockAndOffset[1] = 0;\n\t\t}\n\t\t\t\n\t\t//now we should get the block and check the offset\n\t\tsetCurrentBlock(getBlock(toGetBlockAndOffset[0]));\n\t\tif (_currentBlock == null) {\n\t\t\t//we had an error getting the block\n\t\t\tthrow new IOException(\"Error getting block \"+toGetBlockAndOffset[0]+\" in CCNInputStream.skip(\"+n+\")\");\n\t\t} else {\n\t\t\t//we have a valid block!\n\t\t\t//first make sure the offset is valid\n\t\t\tif (toGetBlockAndOffset[1] <= _currentBlock.contentLength()) {\n\t\t\t\t//this is good, our offset is somewhere in this block\n\t\t\t} else {\n\t\t\t\t//our offset is past the end of our block, reset to the end.\n\t\t\t\ttoGetBlockAndOffset[1] = _currentBlock.contentLength();\n\t\t\t}\n\t\t\t_blockReadStream.skip(toGetBlockAndOffset[1]);\n\t\t\treturn _header.blockLocationToPosition(toGetBlockAndOffset[0], toGetBlockAndOffset[1]) - currentPosition;\n\t\t}\n\t}","id":106824,"modified_method":"@Override\n\tpublic long skip(long n) throws IOException {\n\t\t\n\t\tLibrary.logger().info(\"in skip(\"+n+\")\");\n\t\t\n\t\tif (n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (null == _header){\n\t\t\tsuper.skip(n);\n\t\t}\n\t\t\n\t\tint[] toGetBlockAndOffset = null;\n\t\tlong toGetPosition = 0;\n\t\t\n\t\tlong currentBlock = -1;\n\t\tint currentBlockOffset = 0;\n\t\tlong currentPosition = 0;\n\t\t\n\t\tif (_currentBlock == null) {\n\t\t\t//we do not have a block already\n\t\t\t//skip position is n\n\t\t\tcurrentPosition = 0;\n\t\t\ttoGetPosition = n;\n\t\t} else {\n\t\t    //we already have a block...  need to handle some tricky cases\n\t\t\tcurrentBlock = blockIndex();\n\t\t\tcurrentBlockOffset = (int)super.tell();\n\t\t\tcurrentPosition = _header.blockLocationToPosition(currentBlock, currentBlockOffset);\n\t\t\ttoGetPosition = currentPosition + n;\n\t\t}\n\t\t//make sure we don't skip past end of the object\n\t\tif (toGetPosition >= _header.length()) {\n\t\t\ttoGetPosition = _header.length();\n\t\t\t_atEOF = true;\n\t\t}\n\t\t\t\n\t\ttoGetBlockAndOffset = _header.positionToBlockLocation(toGetPosition);\n\t\t\n\t\t//make sure the position makes sense\n\t\t//is this a valid block?\n\t\tif (toGetBlockAndOffset[0] >= _header.blockCount()){\n\t\t\t//this is not a valid block number, subtract 1\n\t\t\tif (toGetBlockAndOffset[0] > 0) {\n\t\t\t\ttoGetBlockAndOffset[0]--;\n\t\t\t}\n\t\t\t//now we have the last block if the position was too long\n\t\t}\n\t\t\n\t\t//is the offset > 0?\n\t\tif (toGetBlockAndOffset[1] < 0) {\n\t\t\ttoGetBlockAndOffset[1] = 0;\n\t\t}\n\t\t\t\n\t\t//now we should get the block and check the offset\n\t\t// TODO: once first block is always set in a constructor this conditional can be removed\n\t\tif (_currentBlock == null)\n\t\t\tsetFirstBlock(getBlock(toGetBlockAndOffset[0]));\n\t\telse\n\t\t\tsetCurrentBlock(getBlock(toGetBlockAndOffset[0]));\n\t\tif (_currentBlock == null) {\n\t\t\t//we had an error getting the block\n\t\t\tthrow new IOException(\"Error getting block \"+toGetBlockAndOffset[0]+\" in CCNInputStream.skip(\"+n+\")\");\n\t\t} else {\n\t\t\t//we have a valid block!\n\t\t\t//first make sure the offset is valid\n\t\t\tif (toGetBlockAndOffset[1] <= _currentBlock.contentLength()) {\n\t\t\t\t//this is good, our offset is somewhere in this block\n\t\t\t} else {\n\t\t\t\t//our offset is past the end of our block, reset to the end.\n\t\t\t\ttoGetBlockAndOffset[1] = _currentBlock.contentLength();\n\t\t\t}\n\t\t\t_blockReadStream.skip(toGetBlockAndOffset[1]);\n\t\t\treturn _header.blockLocationToPosition(toGetBlockAndOffset[0], toGetBlockAndOffset[1]) - currentPosition;\n\t\t}\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tpublic long seek(long position) throws IOException {\n\t\tLibrary.logger().info(\"Seeking stream to \" + position + \": have header? \" + ((_header == null) ? \"no.\" : \"yes.\"));\n\t\tif (null != _header) {\n\t\t\tint [] blockAndOffset = _header.positionToBlockLocation(position);\n\t\t\tLibrary.logger().info(\"seek:  position: \" + position + \" block: \" + blockAndOffset[0] + \" offset: \" + blockAndOffset[1]);\n\t\t\tLibrary.logger().info(\"currently have block \"+ currentBlockNumber());\n\t\t\tif (currentBlockNumber() == blockAndOffset[0]) {\n\t\t\t\t//already have the correct block\n\t\t\t\tif (super.tell() == blockAndOffset[1]){\n\t\t\t\t\t//already have the correct offset\n\t\t\t\t} else {\n\t\t\t\t\t// Reset and skip.\n\t\t\t\t\tif (_blockReadStream.markSupported()) {\n\t\t\t\t\t\t_blockReadStream.reset();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetCurrentBlock(_currentBlock);\n\t\t\t\t\t}\n\t\t\t\t\t_blockReadStream.skip(blockAndOffset[1]);\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}\n\t\t\t\n\t\t\tsetCurrentBlock(getBlock(blockAndOffset[0]));\n\t\t\tsuper.skip(blockAndOffset[1]);\n\t\t\tlong check = _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\tLibrary.logger().info(\"current position: block \"+blockAndOffset[0]+\" _blockOffset \"+super.tell()+\" (\"+check+\")\");\n\n\t\t\tif (_currentBlock != null) {\n\t\t\t\t_atEOF=false;\n\t\t\t}\n\t\t\t// Might be at end of stream, so different value than came in...\n\t\t\t//long check = _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\t//Library.logger().info(\"return val check: \"+check);\n\t\t\t\n\t\t\t//return _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\t//skip(check);\n\t\t\t\n\t\t\t//Library.logger().info(\" _blockOffset \"+_blockOffset);\n\t\t\treturn check;\n\t\t} else {\n\t\t\treturn super.seek(position);\n\t\t}\n\t}","id":106825,"modified_method":"@Override\n\tpublic long seek(long position) throws IOException {\n\t\tLibrary.logger().info(\"Seeking stream to \" + position + \": have header? \" + ((_header == null) ? \"no.\" : \"yes.\"));\n\t\tif (null != _header) {\n\t\t\tint [] blockAndOffset = _header.positionToBlockLocation(position);\n\t\t\tLibrary.logger().info(\"seek:  position: \" + position + \" block: \" + blockAndOffset[0] + \" offset: \" + blockAndOffset[1]);\n\t\t\tLibrary.logger().info(\"currently have block \"+ currentBlockNumber());\n\t\t\tif (currentBlockNumber() == blockAndOffset[0]) {\n\t\t\t\t//already have the correct block\n\t\t\t\tif (super.tell() == blockAndOffset[1]){\n\t\t\t\t\t//already have the correct offset\n\t\t\t\t} else {\n\t\t\t\t\t// Reset and skip.\n\t\t\t\t\tif (_blockReadStream.markSupported()) {\n\t\t\t\t\t\t_blockReadStream.reset();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetCurrentBlock(_currentBlock);\n\t\t\t\t\t}\n\t\t\t\t\t_blockReadStream.skip(blockAndOffset[1]);\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO: once first block is always set in a constructor this conditional can be removed\n\t\t\tif (_currentBlock == null)\n\t\t\t\tsetFirstBlock(getBlock(blockAndOffset[0]));\n\t\t\telse\n\t\t\t\tsetCurrentBlock(getBlock(blockAndOffset[0]));\n\t\t\tsuper.skip(blockAndOffset[1]);\n\t\t\tlong check = _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\tLibrary.logger().info(\"current position: block \"+blockAndOffset[0]+\" _blockOffset \"+super.tell()+\" (\"+check+\")\");\n\n\t\t\tif (_currentBlock != null) {\n\t\t\t\t_atEOF=false;\n\t\t\t}\n\t\t\t// Might be at end of stream, so different value than came in...\n\t\t\t//long check = _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\t//Library.logger().info(\"return val check: \"+check);\n\t\t\t\n\t\t\t//return _header.blockLocationToPosition(blockAndOffset[0], blockAndOffset[1]);\n\t\t\t//skip(check);\n\t\t\t\n\t\t\t//Library.logger().info(\" _blockOffset \"+_blockOffset);\n\t\t\treturn check;\n\t\t} else {\n\t\t\treturn super.seek(position);\n\t\t}\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tpublic synchronized void reset() throws IOException {\n\t\tsetCurrentBlock(getBlock(_markBlock));\n\t\t_blockReadStream.skip(_markOffset);\n\t\t_atEOF = false;\n\t\tLibrary.logger().finer(\"reset: block: \" + blockIndex() + \" offset: \" + _markOffset + \" eof? \" + _atEOF);\n\t}","id":106826,"modified_method":"@Override\n\tpublic synchronized void reset() throws IOException {\n\t\t// TODO: when first block is read in constructor this check can be removed\n\t\tif (_currentBlock == null)\n\t\t\tsetFirstBlock(getBlock(_markBlock));\n\t\telse\n\t\t\tsetCurrentBlock(getBlock(_markBlock));\n\t\t_blockReadStream.skip(_markOffset);\n\t\t_atEOF = false;\n\t\tLibrary.logger().finer(\"reset: block: \" + blockIndex() + \" offset: \" + _markOffset + \" eof? \" + _atEOF);\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public long seek(long position) throws IOException {\n\t\tLibrary.logger().info(\"Seeking stream to \" + position);\n\t\tsetCurrentBlock(getFirstBlock());\n\t\treturn skip(position);\n\t}","id":106827,"modified_method":"public long seek(long position) throws IOException {\n\t\tLibrary.logger().info(\"Seeking stream to \" + position);\n\t\t// TODO: when first block is read in constructor this check can be removed\n\t\tif (_currentBlock == null)\n\t\t\tsetFirstBlock(getFirstBlock());\n\t\telse\n\t\t\tsetCurrentBlock(getFirstBlock());\n\t\treturn skip(position);\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tif (_atEOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tLibrary.logger().finer(baseName() + \": reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\t_atEOF = true;\n\t\t\t\treturn -1; // nothing to read\n\t\t\t}\n\t\t\tsetCurrentBlock(firstBlock);\n\t\t} \n\t\tLibrary.logger().finer(\"reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t_currentBlock.contentLength());\n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, pull next block.\n\t\tint lenToRead = len;\n\t\tint lenRead = 0;\n\t\tlong readCount = 0;\n\t\twhile (lenToRead > 0) {\n\t\t\tif (null == _blockReadStream) {\n\t\t\t\tLibrary.logger().severe(\"Unexpected null block read stream!\");\n\t\t\t}\n\t\t\tif (null != buf) {  // use for skip\n\t\t\t\tLibrary.logger().finest(\"before block read: content length \"+_currentBlock.contentLength()+\" position \"+ tell() +\" available: \" + _blockReadStream.available() + \" dst length \"+buf.length+\" dst index \"+offset+\" len to read \"+lenToRead);\n\t\t\t\t// Read as many bytes as we can\n\t\t\t\treadCount = _blockReadStream.read(buf, offset, lenToRead);\n\t\t\t} else {\n\t\t\t\treadCount = _blockReadStream.skip(lenToRead);\n\t\t\t}\n\n\t\t\tif (readCount <= 0) {\n\t\t\t\tLibrary.logger().info(\"Tried to read at end of block, go get next block.\");\n\t\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\t\tif (null == _currentBlock) {\n\t\t\t\t\tLibrary.logger().info(\"next block was null, setting _atEOF, returning \" + ((lenRead > 0) ? lenRead : -1));\n\t\t\t\t\t_atEOF = true;\n\t\t\t\t\tif (lenRead > 0) {\n\t\t\t\t\t\treturn lenRead;\n\t\t\t\t\t}\n\t\t\t\t\treturn -1; // no bytes read, at eof\n\t\t\t\t}\n\t\t\t\tLibrary.logger().info(\"now reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t\t\t_currentBlock.contentLength());\n\t\t\t} else {\n\t\t\t\toffset += readCount;\n\t\t\t\tlenToRead -= readCount;\n\t\t\t\tlenRead += readCount;\n\t\t\t\tLibrary.logger().finest(\"     read \" + readCount + \" bytes for \" + lenRead + \" total, \" + lenToRead + \" remaining.\");\n\t\t\t}\n\t\t}\n\t\treturn lenRead;\n\t}","id":106828,"modified_method":"protected int readInternal(byte [] buf, int offset, int len) throws IOException {\n\t\t\n\t\tif (_atEOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tLibrary.logger().finer(baseName() + \": reading \" + len + \" bytes into buffer of length \" + \n\t\t\t\t((null != buf) ? buf.length : \"null\") + \" at offset \" + offset);\n\t\t// is this the first block?\n\t\tif (null == _currentBlock) {\n\t\t\tContentObject firstBlock = getFirstBlock();\n\t\t\tif (null == firstBlock) {\n\t\t\t\t_atEOF = true;\n\t\t\t\treturn -1; // nothing to read\n\t\t\t}\n\t\t\tsetFirstBlock(firstBlock);\n\t\t} \n\t\tLibrary.logger().finer(\"reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t_currentBlock.contentLength());\n\t\t\n\t\t// Now we have a block in place. Read from it. If we run out of block before\n\t\t// we've read len bytes, pull next block.\n\t\tint lenToRead = len;\n\t\tint lenRead = 0;\n\t\tlong readCount = 0;\n\t\twhile (lenToRead > 0) {\n\t\t\tif (null == _blockReadStream) {\n\t\t\t\tLibrary.logger().severe(\"Unexpected null block read stream!\");\n\t\t\t}\n\t\t\tif (null != buf) {  // use for skip\n\t\t\t\tLibrary.logger().finest(\"before block read: content length \"+_currentBlock.contentLength()+\" position \"+ tell() +\" available: \" + _blockReadStream.available() + \" dst length \"+buf.length+\" dst index \"+offset+\" len to read \"+lenToRead);\n\t\t\t\t// Read as many bytes as we can\n\t\t\t\treadCount = _blockReadStream.read(buf, offset, lenToRead);\n\t\t\t} else {\n\t\t\t\treadCount = _blockReadStream.skip(lenToRead);\n\t\t\t}\n\n\t\t\tif (readCount <= 0) {\n\t\t\t\tLibrary.logger().info(\"Tried to read at end of block, go get next block.\");\n\t\t\t\tsetCurrentBlock(getNextBlock());\n\t\t\t\tif (null == _currentBlock) {\n\t\t\t\t\tLibrary.logger().info(\"next block was null, setting _atEOF, returning \" + ((lenRead > 0) ? lenRead : -1));\n\t\t\t\t\t_atEOF = true;\n\t\t\t\t\tif (lenRead > 0) {\n\t\t\t\t\t\treturn lenRead;\n\t\t\t\t\t}\n\t\t\t\t\treturn -1; // no bytes read, at eof\n\t\t\t\t}\n\t\t\t\tLibrary.logger().info(\"now reading from block: \" + _currentBlock.name() + \" length: \" + \n\t\t\t\t\t\t_currentBlock.contentLength());\n\t\t\t} else {\n\t\t\t\toffset += readCount;\n\t\t\t\tlenToRead -= readCount;\n\t\t\t\tlenRead += readCount;\n\t\t\t\tLibrary.logger().finest(\"     read \" + readCount + \" bytes for \" + lenRead + \" total, \" + lenToRead + \" remaining.\");\n\t\t\t}\n\t\t}\n\t\treturn lenRead;\n\t}","commit_id":"be308eddc3cf9974ae8dcc481c8a184cf495fe93","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public List<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>> getChanges(final Tuples._2<Language, I> initialState, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {\n    if (initialState == null || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>());\n    }\n    final Language sourceModule = initialState._0();\n\n    final SearchResults results = new SearchResults();\n    results.add(new SearchResult<SModule>(sourceModule, \"migration script\"));\n\n    // todo: write guard migration with 'execute after' \n\n    RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>> change = new RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>() {\n      public SearchResults getSearchResults() {\n        return results;\n      }\n      public boolean needsToPreserveOldNode() {\n        return true;\n      }\n      public void confirm(Tuples._2<Language, F> finalState, SRepository repository, RefactoringSession refactoringSession) {\n        Language sourceModule = initialState._0();\n        Language targetModule = finalState._0();\n        LanguageStructureMigrationParticipant.MigrationBuilder logBuilder = LanguageStructureMigrationParticipant.MigrationBuilder.getBuilder(refactoringSession, sourceModule);\n        myStructureSpecialization.confirm(initialState, finalState, logBuilder);\n      }\n    };\n    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>(), change);\n  }","id":106829,"modified_method":"public List<RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>> getChanges(final Tuples._2<I, SNodeReference> initialState, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {\n    if (initialState == null || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>>());\n    }\n    final Language sourceModule = as_kz6lmo_a0a1a61(check_kz6lmo_a0a1a61(check_kz6lmo_a0a0b0q(initialState._1().resolve(repository))), Language.class);\n\n    final SearchResults results = new SearchResults();\n    if (sourceModule != null) {\n      results.add(new SearchResult<SModule>(sourceModule, \"migration script\"));\n    }\n\n    // todo: write guard migration with 'execute after' \n\n    RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>> change = new RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>() {\n      public SearchResults getSearchResults() {\n        return results;\n      }\n      public boolean needsToPreserveOldNode() {\n        return true;\n      }\n      public void confirm(Tuples._2<F, SNodeReference> finalState, SRepository repository, RefactoringSession refactoringSession) {\n        Language sourceModule = as_kz6lmo_a0a0a2a0a0i0q(check_kz6lmo_a0a0a2a0a0i0q(check_kz6lmo_a0a0a0c0a0a8a61(initialState._1().resolve(repository))), Language.class);\n        Language targetModule = as_kz6lmo_a0a1a2a0a0i0q(check_kz6lmo_a0a1a2a0a0i0q(check_kz6lmo_a0a0b0c0a0a8a61(finalState._1().resolve(repository))), Language.class);\n        if (sourceModule != null) {\n          LanguageStructureMigrationParticipant.MigrationBuilder logBuilder = LanguageStructureMigrationParticipant.MigrationBuilder.getBuilder(refactoringSession, sourceModule);\n          myStructureSpecialization.confirm(initialState, finalState, repository, logBuilder);\n        }\n      }\n    };\n    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>>(), change);\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationBuilder(RefactoringSession session, final Language language) {\n      final int languageVersion = language.getLanguageVersion();\n      myRefactoringStep = createPureMigrationScript_kz6lmo_a0b0d11(languageVersion, \"MigrationScript_\" + languageVersion);\n      session.registerChange(new Runnable() {\n        public void run() {\n          SModel migrationModel = LanguageAspect.MIGRATION.getOrCreate(language);\n          SModelInternal sm = (SModelInternal) (SModel) migrationModel;\n          for (SModelReference reference : ListSequence.fromList(SNodeOperations.getNodeDescendants(myRefactoringStep, null, true, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {\n            public Iterable<SReference> translate(SNode it) {\n              return SNodeOperations.getReferences(it);\n            }\n          }).select(new ISelector<SReference, SModelReference>() {\n            public SModelReference select(SReference it) {\n              return it.getTargetSModelReference();\n            }\n          }).distinct()) {\n            if (!(SModelOperations.getImportedModelUIDs(migrationModel).contains(reference))) {\n              sm.addModelImport(reference, true);\n            }\n          }\n          jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.addRootNode(migrationModel, myRefactoringStep);\n          language.setLanguageVersion(languageVersion + 1);\n        }\n      });\n    }","id":106830,"modified_method":"public MigrationBuilder(RefactoringSession session, final Language language) {\n      final int languageVersion = language.getLanguageVersion();\n      myRefactoringStep = createPureMigrationScript_kz6lmo_a0b0d11(languageVersion, \"MigrationScript_\" + languageVersion);\n      session.registerChange(new Runnable() {\n        public void run() {\n          SModel migrationModel = LanguageAspect.MIGRATION.getOrCreate(language);\n          SModelInternal sm = (SModelInternal) (SModel) migrationModel;\n          for (SModelReference reference : ListSequence.fromList(SNodeOperations.getNodeDescendants(myRefactoringStep, null, true, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {\n            public Iterable<SReference> translate(SNode it) {\n              return SNodeOperations.getReferences(it);\n            }\n          }).select(new ISelector<SReference, SModelReference>() {\n            public SModelReference select(SReference it) {\n              return it.getTargetSModelReference();\n            }\n          }).distinct()) {\n            if (!(SModelOperations.getImportedModelUIDs(migrationModel).contains(reference))) {\n              sm.addModelImport(reference);\n            }\n          }\n          jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.addRootNode(migrationModel, myRefactoringStep);\n          language.setLanguageVersion(languageVersion + 1);\n        }\n      });\n    }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Tuples._2<Language, SAbstractConcept> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\")) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<Language,SAbstractConcept>from((Language) SNodeOperations.getModel(movingNode).getModule(), MetaAdapterByDeclaration.getConcept(movingNode));\n    } else {\n      return null;\n    }\n  }","id":106831,"modified_method":"public Tuples._2<SAbstractConcept, SNodeReference> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\")) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<SAbstractConcept,SNodeReference>from(MetaAdapterByDeclaration.getConcept(movingNode), movingNode.getReference());\n    } else {\n      return null;\n    }\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void confirm(Tuples._2<Language, SAbstractConcept> initialState, Tuples._2<Language, SAbstractConcept> finalState, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_c4c66o_a0d0b(\"The concept was moved to language \\\"\" + SNodeOperations.getModel(to).getModule().getModuleName() + \"\\\"\"));\n    if (SNodeOperations.isInstanceOf(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) && SNodeOperations.isInstanceOf(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n      SLinkOperations.setTarget(SNodeOperations.cast(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\"), SNodeOperations.cast(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")));\n    } else if (SNodeOperations.isInstanceOf(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\")) && SNodeOperations.isInstanceOf(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"))) {\n      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\")), MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, 0x110356e9df4L, \"extends\"))).addElement(createInterfaceConceptReference_c4c66o_a0a0a0e0b(SNodeOperations.cast(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"))));\n    } else {\n      throw new IllegalStateException();\n    }\n    migrationBuilder.addPart(initialState._1().getDeclarationNode(), finalState._1().getDeclarationNode(), createMoveConcept_c4c66o_c0a5a1());\n  }","id":106832,"modified_method":"public void confirm(Tuples._2<SAbstractConcept, SNodeReference> initialState, Tuples._2<SAbstractConcept, SNodeReference> finalState, SRepository repository, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_c4c66o_a0d0b(\"The concept was moved to language \\\"\" + SNodeOperations.getModel(to).getModule().getModuleName() + \"\\\"\"));\n    if (SNodeOperations.isInstanceOf(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) && SNodeOperations.isInstanceOf(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"))) {\n      SLinkOperations.setTarget(SNodeOperations.cast(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\"), SNodeOperations.cast(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")));\n    } else if (SNodeOperations.isInstanceOf(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\")) && SNodeOperations.isInstanceOf(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"))) {\n      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(to, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\")), MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, 0x110356e9df4L, \"extends\"))).addElement(createInterfaceConceptReference_c4c66o_a0a0a0e0b(SNodeOperations.cast(from, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"))));\n    } else {\n      throw new IllegalStateException();\n    }\n    migrationBuilder.addPart(from, to, createMoveConcept_c4c66o_c0a5a1());\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void confirm(Tuples._2<Language, SContainmentLink> initialState, Tuples._2<Language, SContainmentLink> finalState, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_mzlq6b_a0d0b(\"The link was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    if ((boolean) LinkDeclaration__BehaviorDescriptor.isSingular_idhEwIfAt.invoke(from)) {\n      SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..1\");\n    } else {\n      SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..n\");\n    }\n    migrationBuilder.addPart(initialState._1().getDeclarationNode(), finalState._1().getDeclarationNode(), createMoveContainmentLink_mzlq6b_c0a5a1());\n  }","id":106833,"modified_method":"public void confirm(Tuples._2<SContainmentLink, SNodeReference> initialState, Tuples._2<SContainmentLink, SNodeReference> finalState, SRepository repository, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_mzlq6b_a0d0b(\"The link was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    if ((boolean) LinkDeclaration__BehaviorDescriptor.isSingular_idhEwIfAt.invoke(from)) {\n      SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..1\");\n    } else {\n      SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..n\");\n    }\n    migrationBuilder.addPart(from, to, createMoveContainmentLink_mzlq6b_c0a5a1());\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Tuples._2<Language, SContainmentLink> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\") && (SLinkOperations.getTarget(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98051c244L, \"specializedLink\")) == null) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<Language,SContainmentLink>from((Language) SNodeOperations.getModel(movingNode).getModule(), MetaAdapterByDeclaration.getContainmentLink(movingNode));\n    } else {\n      return null;\n    }\n  }","id":106834,"modified_method":"public Tuples._2<SContainmentLink, SNodeReference> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\") && (SLinkOperations.getTarget(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98051c244L, \"specializedLink\")) == null) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<SContainmentLink,SNodeReference>from(MetaAdapterByDeclaration.getContainmentLink(movingNode), movingNode.getReference());\n    } else {\n      return null;\n    }\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void confirm(Tuples._2<Language, SProperty> initialState, Tuples._2<Language, SProperty> finalState, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_fubpxk_a0d0b(\"The property was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    migrationBuilder.addPart(initialState._1().getDeclarationNode(), finalState._1().getDeclarationNode(), createMoveProperty_fubpxk_c0a4a1());\n  }","id":106835,"modified_method":"public void confirm(Tuples._2<SProperty, SNodeReference> initialState, Tuples._2<SProperty, SNodeReference> finalState, SRepository repository, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_fubpxk_a0d0b(\"The property was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    migrationBuilder.addPart(from, to, createMoveProperty_fubpxk_c0a4a1());\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Tuples._2<Language, SProperty> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\")) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<Language,SProperty>from((Language) SNodeOperations.getModel(movingNode).getModule(), MetaAdapterByDeclaration.getProperty(movingNode));\n    } else {\n      return null;\n    }\n  }","id":106836,"modified_method":"public Tuples._2<SProperty, SNodeReference> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\")) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<SProperty,SNodeReference>from(MetaAdapterByDeclaration.getProperty(movingNode), movingNode.getReference());\n    } else {\n      return null;\n    }\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Tuples._2<Language, SReferenceLink> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\") && (SLinkOperations.getTarget(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98051c244L, \"specializedLink\")) == null) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<Language,SReferenceLink>from((Language) SNodeOperations.getModel(movingNode).getModule(), MetaAdapterByDeclaration.getReferenceLink(movingNode));\n    } else {\n      return null;\n    }\n  }","id":106837,"modified_method":"public Tuples._2<SReferenceLink, SNodeReference> fetchState(SNode movingNode) {\n    if (SNodeOperations.isInstanceOf(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")) && SPropertyOperations.hasValue(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\") && (SLinkOperations.getTarget(SNodeOperations.cast(movingNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\")), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98051c244L, \"specializedLink\")) == null) && SNodeOperations.getModel(movingNode).getModule() instanceof Language) {\n      return MultiTuple.<SReferenceLink,SNodeReference>from(MetaAdapterByDeclaration.getReferenceLink(movingNode), movingNode.getReference());\n    } else {\n      return null;\n    }\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void confirm(Tuples._2<Language, SReferenceLink> initialState, Tuples._2<Language, SReferenceLink> finalState, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().getDeclarationNode(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_w90w7j_a0d0b(\"The link was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..1\");\n    migrationBuilder.addPart(from, to, createMoveReferenceLink_w90w7j_c0a5a1());\n  }","id":106838,"modified_method":"public void confirm(Tuples._2<SReferenceLink, SNodeReference> initialState, Tuples._2<SReferenceLink, SNodeReference> finalState, SRepository repository, LanguageStructureMigrationParticipant.MigrationBuilder migrationBuilder) {\n    SNode from = SNodeOperations.cast(initialState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SNode to = SNodeOperations.cast(finalState._1().resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), SPropertyOperations.getString_def(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), \"\") + \"_old\");\n    AttributeOperations.setAttribute(from, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_w90w7j_a0d0b(\"The link was moved to concept \\\"\" + INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SNodeOperations.cast(SNodeOperations.getParent(to), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) + \"\\\"\"));\n    SPropertyOperations.set(from, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, \"sourceCardinality\"), \"0..1\");\n    migrationBuilder.addPart(from, to, createMoveReferenceLink_w90w7j_c0a5a1());\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>> getChanges(final Tuples._2<Language, I> initialState, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {\n    if (initialState == null || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>());\n    }\n    Collection<SNode> instances = myStructureSpecialization.findInstances(initialState._1(), searchScope);\n\n    return CollectionSequence.fromCollection(instances).select(new ISelector<SNode, RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>() {\n      public RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>> select(SNode instance) {\n        final SNodeReference nodeRef = instance.getReference();\n        final SearchResults searchResults = new SearchResults();\n        searchResults.add(new SearchResult<SNode>(instance, \"instance\"));\n        RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>> change = new RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>() {\n          public MoveNodeRefactoringParticipant<Tuples._2<Language, I>, Tuples._2<Language, F>> getParticipant() {\n            return UpdateLocalInstancesParticipant.this;\n          }\n          public SearchResults getSearchResults() {\n            return searchResults;\n          }\n          public boolean needsToPreserveOldNode() {\n            return false;\n          }\n          public void confirm(final Tuples._2<Language, F> finalState, final SRepository repository, final RefactoringSession refactoringSession) {\n            refactoringSession.registerChange(new Runnable() {\n              public void run() {\n                SNode node = nodeRef.resolve(repository);\n                MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);\n                if (node == null || MapSequence.fromMap(copyMap.getCopyMap()).containsKey(node)) {\n                  myStructureSpecialization.doReplaceInstance(MapSequence.fromMap(copyMap.getCopyMap()).get(node), initialState._1(), finalState._1());\n                }\n                myStructureSpecialization.doReplaceInstance(node, initialState._1(), finalState._1());\n              }\n            });\n          }\n        };\n        return change;\n      }\n    }).toListSequence();\n  }","id":106839,"modified_method":"public List<RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>> getChanges(final Tuples._2<I, SNodeReference> initialState, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {\n    if (initialState == null || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {\n      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>>());\n    }\n    Collection<SNode> instances = myStructureSpecialization.findInstances(initialState._0(), searchScope);\n\n    return CollectionSequence.fromCollection(instances).select(new ISelector<SNode, RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>>() {\n      public RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>> select(SNode instance) {\n        final SNodeReference nodeRef = instance.getReference();\n        final SearchResults searchResults = new SearchResults();\n        searchResults.add(new SearchResult<SNode>(instance, \"instance\"));\n        RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>> change = new RefactoringParticipant.Change<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>>() {\n          public MoveNodeRefactoringParticipant<Tuples._2<I, SNodeReference>, Tuples._2<F, SNodeReference>> getParticipant() {\n            return UpdateLocalInstancesParticipant.this;\n          }\n          public SearchResults getSearchResults() {\n            return searchResults;\n          }\n          public boolean needsToPreserveOldNode() {\n            return false;\n          }\n          public void confirm(final Tuples._2<F, SNodeReference> finalState, final SRepository repository, final RefactoringSession refactoringSession) {\n            refactoringSession.registerChange(new Runnable() {\n              public void run() {\n                SNode node = nodeRef.resolve(repository);\n                MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);\n                if (node == null || MapSequence.fromMap(copyMap.getCopyMap()).containsKey(node)) {\n                  myStructureSpecialization.doReplaceInstance(MapSequence.fromMap(copyMap.getCopyMap()).get(node), initialState._0(), finalState._0());\n                }\n                myStructureSpecialization.doReplaceInstance(node, initialState._0(), finalState._0());\n              }\n            });\n          }\n        };\n        return change;\n      }\n    }).toListSequence();\n  }","commit_id":"193f52240a884ba4417097142f3368dadedddabc","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void cycleAlpha(NSWindow w, float start, float end, final int steps) {\n        if (DEBUG) out(\"cycleAlpha \" + start + \" -> \" + end + \" in \" + steps + \" steps\");\n        float alpha;\n        float delta = end - start;\n        float inc = delta / steps;\n        for (int i = 0; i < steps; i++) {\n            alpha = start + inc * i;\n            w.setAlphaValue(alpha);\n            if (DEBUG) out(\"alpha=\" + alpha);\n            //try { Thread.sleep(500); } catch (Exception e) {} // give CPU a break\n        }\n        // if end value isn't 0, and you don't manuall close the window,\n        // it will grab all mouse events, locking out everything below it!\n        //if (DEBUG) { if (end == 0) end=.1f; }\n        w.setAlphaValue(end);\n        if (DEBUG) {\n            out(\"cycleAlpha complete\");\n            //java.awt.Toolkit.getDefaultToolkit().beep();\n        }\n            \n    }","id":106840,"modified_method":"private static void cycleAlpha(NSWindow w, float start, float end, final int steps) {\n        if (DEBUG) out(w + \" cycleAlpha: \" + start + \" -> \" + end + \" in \" + steps + \" steps\");\n        //new Throwable(\"CYCLEALPHA\").printStackTrace();\n        float alpha;\n        float delta = end - start;\n        float inc = delta / steps;\n        for (int i = 0; i < steps; i++) {\n            alpha = start + inc * i;\n            w.setAlphaValue(alpha);\n            if (DEBUG) {\n                out(\"alpha=\" + alpha);\n                try { Thread.sleep(100); } catch (Exception e) {} // let us watch the reps\n            }\n            //Thread.yield();\n            try { Thread.sleep(8); } catch (Exception e) {} // 8ms wait = 125fps with theoretical render time of 0\n\n        }\n        w.setAlphaValue(end);\n\n        // NOTE: if end value is NOT zero (it's at least slightly visible), and you\n        // don't manually call w.close() on the window to hide it, it will grab all\n        // mouse events, locking out everything below it.  Callers of cycleAlpha are\n        // currently responsible for sorting that ...\n        \n        if (DEBUG) {\n            out(\"alpha=\" + end + \"; cycle complete\");\n            //java.awt.Toolkit.getDefaultToolkit().beep();\n        }\n            \n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void goBlack(NSWindow w) {\n        w.setAlphaValue(1);\n        //w.setBackgroundColor(NSColor.redColor());\n        w.orderFrontRegardless();\n        //w.orderFront(w);\n    }","id":106841,"modified_method":"public static void goBlack(NSWindow w) {\n        if (DEBUG) out(w + \" goBlack\");\n        w.setAlphaValue(1f);\n        w.orderFrontRegardless();\n        //w.orderFront(w);\n\n        //out(\"Sleeping...\"); try { Thread.currentThread().sleep(1000); } catch (Throwable t) {}\n\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void fadeUpMainWindow() {\n        cycleAlpha(getMainWindow(), 0, 1);\n    }","id":106842,"modified_method":"public static void fadeUpMainWindow() {\n        final NSWindow w = getMainWindow();\n        if (DEBUG) out(w + \" fadeUp main window\");\n        cycleAlpha(w, 0, 1);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void fadeFromBlack(NSWindow w) {\n        goBlack(w);\n        cycleAlpha(w, 1, 0);\n        w.close();  // bus-error of we haven't called setReleasedWhenClosed(false)\n    }","id":106843,"modified_method":"public static void fadeFromBlack(NSWindow w) {\n        if (DEBUG) out(w + \" fadeFromBlack\");\n        goBlack(w);\n        cycleAlpha(w, 1, 0);\n\n        // calling close is how the window becomes fully hidden (not just invisible),\n        // tho setReleasedWhenClosed(false) must have been called prior or we can get a bus-error\n        // accessing this again, as it may have been free'd.\n        w.close();\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"protected static void out(String s) {\n        System.out.println(\"MacOSX lib: \" + s);\n    }","id":106844,"modified_method":"protected static void out(String s) {\n        //System.out.println(\"MacOSX lib: \" + s);\n        Log.debug(s);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void makeMainInvisible() {\n        getMainWindow().setAlphaValue(0);\n    }","id":106845,"modified_method":"public static void makeMainInvisible() {\n        final NSWindow w = getMainWindow();\n        if (DEBUG) out(w + \" making main invisible\");\n        w.setAlphaValue(0);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void setMainAlpha(float alpha) {\n        getMainWindow().setAlphaValue(alpha);\n    }","id":106846,"modified_method":"public static void setMainAlpha(float alpha) {\n        final NSWindow w = getMainWindow();\n        if (DEBUG) out(w + \" setMainAlpha \" + alpha);\n        w.setAlphaValue(alpha);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"protected static void errout(String s) {\n        System.err.println(\"MacOSX lib: \" + s);\n    }","id":106847,"modified_method":"protected static void errout(String s) {\n        //System.err.println(\"MacOSX lib: \" + s);\n        Log.warn(s);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"private static NSWindow getFullScreenWindow() {\n        if (sFullScreen == null) {\n            Dimension screen = java.awt.Toolkit.getDefaultToolkit().getScreenSize();\n            sFullScreen = new NSWindow(new NSRect(0,0,screen.width,screen.height),\n                                       0,\n                                       //NSWindow.Retained,\n                                       NSWindow.NonRetained,\n                                       //NSWindow.Buffered,\n                                       true);\n            sFullScreen.setBackgroundColor(NSColor.blackColor());\n//            sFullScreen.setBackgroundColor(NSColor.redColor());\n//            out(\" RED COLOR \" + NSColor.redColor());\n//            out(\"FILL COLOR \" + sFullScreen.backgroundColor());\n//             if (DEBUG)\n//                 sFullScreen.setBackgroundColor(NSColor.redColor());\n//             else\n//                 sFullScreen.setBackgroundColor(NSColor.blackColor());\n            sFullScreen.setLevel(NSWindow.ScreenSaverWindowLevel); // this allows it over the  mac menu bar\n            sFullScreen.setHasShadow(false);\n            sFullScreen.setIgnoresMouseEvents(true);\n            sFullScreen.setReleasedWhenClosed(false);\n            sFullScreen.setTitle(\"_mac_full_screen_fader\"); // make sure starts with \"_\" (see keepWindowsOnTop)\n        }\n        return sFullScreen;\n    }","id":106848,"modified_method":"private static NSWindow getFullScreenWindow() {\n        if (sFullScreen == null) {\n            if (DEBUG) out(\"creating FSW:\");\n            final Dimension screen = java.awt.Toolkit.getDefaultToolkit().getScreenSize();\n            final NSRect size;\n            if (DEBUG)\n                size = new NSRect(200,200,screen.width/2,screen.height/2);\n            else\n                size = new NSRect(0,0,screen.width,screen.height);\n            sFullScreen =\n                new NSWindow(size,\n                             0,\n                             //NSWindow.Retained,\n                             //NSWindow.NonRetained,\n                             NSWindow.Buffered, // WINDOW IS ALWAYS WHITE UNLESS WE USED BUFFERED\n                             true);\n            if (DEBUG)\n                sFullScreen.setBackgroundColor(NSColor.redColor());\n            else\n                sFullScreen.setBackgroundColor(NSColor.blackColor());\n//            sFullScreen.setBackgroundColor(NSColor.redColor());\n//            out(\" RED COLOR \" + NSColor.redColor());\n//            out(\"FILL COLOR \" + sFullScreen.backgroundColor());\n//             if (DEBUG)\n//                 sFullScreen.setBackgroundColor(NSColor.redColor());\n//             else\n//                 sFullScreen.setBackgroundColor(NSColor.blackColor());\n            sFullScreen.setHasShadow(false);\n            sFullScreen.setIgnoresMouseEvents(true);\n            sFullScreen.setReleasedWhenClosed(false);\n            sFullScreen.setTitle(\"_mac_full_screen_fader\"); // make sure starts with \"_\" (see keepWindowsOnTop)\n            sFullScreen.setLevel(NSWindow.ScreenSaverWindowLevel); // this allows it over the  mac menu bar\n            if (DEBUG) out(sFullScreen + \"; created\");\n        }\n        return sFullScreen;\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void fadeFromBlack() {\n        fadeFromBlack(getFullScreenWindow());\n    }","id":106849,"modified_method":"public static void fadeFromBlack() {\n        if (DEBUG) out(\"fadeFromBlack\");\n        fadeFromBlack(getFullScreenWindow());\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"public static void fadeToBlack() {\n        NSWindow w = getFullScreenWindow();\n        w.setAlphaValue(0);\n        w.orderFront(w);\n        cycleAlpha(0, 1);\n    }","id":106850,"modified_method":"public static void fadeToBlack() {\n        NSWindow w = getFullScreenWindow();\n        if (DEBUG) out(w + \" fadeToBlack\");\n        //w.setAlphaValue(0);\n        w.orderFrontRegardless();\n        cycleAlpha(0, 1);\n        //cycleAlpha(0, .5f);\n        //cycleAlpha(1, 0);\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Set the entire contents of the given window to\n     * render with the given alpha, letting underlying\n     * operating system windows bleed through.\n     */\n    public static void setAlpha(Window w, float alpha) {\n        NSWindow nsw = getWindow(w);\n        if (nsw != null) {\n            nsw.setAlphaValue(alpha);\n        }\n    }","id":106851,"modified_method":"/**\n     * Set the entire contents of the given window to\n     * render with the given alpha, letting underlying\n     * operating system windows bleed through.\n     */\n    public static void setAlpha(Window w, float alpha) {\n        if (DEBUG) out(\"setAlpha \" + alpha + \" on \" + w);\n        setAlpha(getWindow(w), alpha);\n//         NSWindow nsw = getWindow(w);\n//         if (nsw != null) {\n//             nsw.setAlphaValue(alpha);\n//         }\n    }","commit_id":"afd5a5074360d4e40244f75961e9aabdca163d2c","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Replies the wiki language prefix for the given locale. The wiki language\n     * prefix has the form 'Xy:' where 'Xy' is a ISO 639 language code in title\n     * case.\n     *\n     * @param locale  the locale\n     * @return the wiki language prefix\n     */\n    static public String getWikiLanguagePrefix(Locale locale) {\n        String code = getJOSMLocaleCode(locale);\n        if (code.length() == 2) {\n            if (code.equals(\"en\")) return \"\";\n        } else if (code.matches(\"[^_]+_[^_]+\")) {\n            code = code.substring(0,2);\n        } else {\n            System.err.println(tr(\"Warning: failed to derive wiki language prefix from JOSM locale code ''{0}''. Using default code ''en''.\", code));\n            return \"\";\n        }\n        return code.substring(0,1).toUpperCase() + code.substring(1) + \":\";\n    }","id":106852,"modified_method":"/**\n     * Replies the wiki language prefix for the given locale. The wiki language\n     * prefix has the form 'Xy:' where 'Xy' is a ISO 639 language code in title\n     * case.\n     *\n     * @param locale  the locale\n     * @return the wiki language prefix\n     */\n    static public String getWikiLanguagePrefix(Locale locale) {\n        String code = getJOSMLocaleCode(locale);\n        if (code.length() == 2) {\n            if (code.equals(\"en\")) return \"\";\n        } else if (code.equals(\"zh_TW\") || code.equals(\"zh_CN\")) {\n            /* do nothing */\n        } else if (code.matches(\"[^_]+_[^_]+\")) {\n            code = code.substring(0,2);\n        } else {\n            System.err.println(tr(\"Warning: failed to derive wiki language prefix from JOSM locale code ''{0}''. Using default code ''en''.\", code));\n            return \"\";\n        }\n        return code.substring(0,1).toUpperCase() + code.substring(1) + \":\";\n    }","commit_id":"9ff33fb7edc5fbcd139da4a2933a4e50d8afb9f4","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Replies the local code used by JOSM for a given locale.\n     *\n     * In most cases JOSM uses the 2-character ISO 639 language code ({@see Locale#getLanguage()}\n     * to identify the locale of a localized resource, but in some cases it may use the\n     * programmatic name for locales, as replied by {@see Locale#toString()}.\n     *\n     * @param locale the locale. Replies \"en\" if null.\n     * @return the JOSM code for the given locale\n     */\n    static public String getJOSMLocaleCode(Locale locale) {\n        if (locale == null) return \"en\";\n        String full = locale.toString();\n        if (full.equals(\"iw_IL\"))\n            return \"he\";\n        /* list of non-single codes supported by josm */\n        else if (full.equals(\"en_GB\") || full.equals(\"en_AU\"))\n            return full;\n\n        return locale.getLanguage();\n    }","id":106853,"modified_method":"/**\n     * Replies the locale code used by JOSM for a given locale.\n     *\n     * In most cases JOSM uses the 2-character ISO 639 language code ({@see Locale#getLanguage()}\n     * to identify the locale of a localized resource, but in some cases it may use the\n     * programmatic name for locales, as replied by {@see Locale#toString()}.\n     *\n     * @param locale the locale. Replies \"en\" if null.\n     * @return the JOSM code for the given locale\n     */\n    static public String getJOSMLocaleCode(Locale locale) {\n        if (locale == null) return \"en\";\n        String full = locale.toString();\n        if (full.equals(\"iw_IL\"))\n            return \"he\";\n        /* list of non-single codes supported by josm */\n        else if (full.equals(\"en_GB\") || full.equals(\"pt_BR\") || full.equals(\"en_AU\") || full.equals(\"zh_TW\") || full.equals(\"zh_CN\"))\n            return full;\n\n        return locale.getLanguage();\n    }","commit_id":"9ff33fb7edc5fbcd139da4a2933a4e50d8afb9f4","url":"https://github.com/openstreetmap/josm"},{"original_method":"private boolean inInitState(Component focusOwner, KeyEvent e, boolean isModalContext, DataContext dataContext) {\n    // http://www.jetbrains.net/jira/browse/IDEADEV-12372\n    if (myLeftCtrlPressed && myRightAltPressed && focusOwner != null && e.getModifiers() == (KeyEvent.CTRL_MASK | KeyEvent.ALT_MASK)) {\n      final InputContext inputContext = focusOwner.getInputContext();\n      if (inputContext != null) {\n        @NonNls final String language = inputContext.getLocale().getLanguage();\n        if (language.equals(\"pl\") ||\n            language.equals(\"de\") ||\n            language.equals(\"fi\") ||\n            language.equals(\"fr\")) {\n          // don't search for shortcuts\n          return false;\n        }\n      }\n    }\n\n    KeyStroke originalKeyStroke=KeyStroke.getKeyStrokeForEvent(e);\n    KeyStroke keyStroke=getKeyStrokeWithoutMouseModifiers(originalKeyStroke);\n\n    boolean hasSecondStroke = fillActionsList(focusOwner, keyStroke, null, isModalContext);\n\n    if(myActions.size() == 0) {\n      if (SystemInfo.isMac) {\n        if (e.getID() == KeyEvent.KEY_PRESSED && e.getModifiersEx() == KeyEvent.ALT_DOWN_MASK && hasMnemonicInWindow(focusOwner, e.getKeyCode())) {\n          myPressedWasProcessed = true;\n          myState = STATE_PROCESSED;\n          return false;\n        }\n      }\n\n      // there's nothing mapped for this stroke\n      return false;\n    }\n\n    if(hasSecondStroke){\n      myFirstKeyStroke=keyStroke;\n      ArrayList<Pair<AnAction, KeyStroke>> secondKeyStorkes = new ArrayList<Pair<AnAction,KeyStroke>>();\n      for (AnAction action : myActions) {\n        Shortcut[] shortcuts = action.getShortcutSet().getShortcuts();\n        for (Shortcut shortcut : shortcuts) {\n          if (shortcut instanceof KeyboardShortcut) {\n            KeyboardShortcut keyShortcut = (KeyboardShortcut)shortcut;\n            if (keyShortcut.getFirstKeyStroke().equals(myFirstKeyStroke)) {\n              secondKeyStorkes.add(new Pair<AnAction, KeyStroke>(action, keyShortcut.getSecondKeyStroke()));\n            }\n          }\n        }\n      }\n\n      Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n      StringBuffer message = new StringBuffer();\n      message.append(KeyMapBundle.message(\"prefix.key.pressed.message\"));\n      message.append(' ');\n      for (int i = 0; i < secondKeyStorkes.size(); i++) {\n        Pair<AnAction, KeyStroke> pair = secondKeyStorkes.get(i);\n        if (i > 0) message.append(\", \");\n        message.append(pair.getFirst().getTemplatePresentation().getText());\n        message.append(\" (\");\n        message.append(KeymapUtil.getKeystrokeText(pair.getSecond()));\n        message.append(\")\");\n      }\n\n      WindowManager.getInstance().getStatusBar(project).setInfo(message.toString());\n      myState=STATE_WAIT_FOR_SECOND_KEYSTROKE;\n      return true;\n    }else{\n      if (processAction(e, dataContext)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }","id":106854,"modified_method":"private boolean inInitState(Component focusOwner, KeyEvent e, boolean isModalContext, DataContext dataContext) {\n    // http://www.jetbrains.net/jira/browse/IDEADEV-12372\n    if (myLeftCtrlPressed && myRightAltPressed && focusOwner != null && e.getModifiers() == (KeyEvent.CTRL_MASK | KeyEvent.ALT_MASK)) {\n      final InputContext inputContext = focusOwner.getInputContext();\n      if (inputContext != null) {\n        @NonNls final String language = inputContext.getLocale().getLanguage();\n        if (language.equals(\"pl\") ||\n            language.equals(\"de\") ||\n            language.equals(\"fi\") ||\n            language.equals(\"fr\") ||\n            language.equals(\"no\") ||\n            language.equals(\"da\") ||\n            language.equals(\"se\") ||\n            language.equals(\"pt\") ||\n            language.equals(\"tr\")) {\n          // don't search for shortcuts\n          return false;\n        }\n      }\n    }\n\n    KeyStroke originalKeyStroke=KeyStroke.getKeyStrokeForEvent(e);\n    KeyStroke keyStroke=getKeyStrokeWithoutMouseModifiers(originalKeyStroke);\n\n    boolean hasSecondStroke = fillActionsList(focusOwner, keyStroke, null, isModalContext);\n\n    if(myActions.size() == 0) {\n      if (SystemInfo.isMac) {\n        if (e.getID() == KeyEvent.KEY_PRESSED && e.getModifiersEx() == KeyEvent.ALT_DOWN_MASK && hasMnemonicInWindow(focusOwner, e.getKeyCode())) {\n          myPressedWasProcessed = true;\n          myState = STATE_PROCESSED;\n          return false;\n        }\n      }\n\n      // there's nothing mapped for this stroke\n      return false;\n    }\n\n    if(hasSecondStroke){\n      myFirstKeyStroke=keyStroke;\n      ArrayList<Pair<AnAction, KeyStroke>> secondKeyStorkes = new ArrayList<Pair<AnAction,KeyStroke>>();\n      for (AnAction action : myActions) {\n        Shortcut[] shortcuts = action.getShortcutSet().getShortcuts();\n        for (Shortcut shortcut : shortcuts) {\n          if (shortcut instanceof KeyboardShortcut) {\n            KeyboardShortcut keyShortcut = (KeyboardShortcut)shortcut;\n            if (keyShortcut.getFirstKeyStroke().equals(myFirstKeyStroke)) {\n              secondKeyStorkes.add(new Pair<AnAction, KeyStroke>(action, keyShortcut.getSecondKeyStroke()));\n            }\n          }\n        }\n      }\n\n      Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n      StringBuffer message = new StringBuffer();\n      message.append(KeyMapBundle.message(\"prefix.key.pressed.message\"));\n      message.append(' ');\n      for (int i = 0; i < secondKeyStorkes.size(); i++) {\n        Pair<AnAction, KeyStroke> pair = secondKeyStorkes.get(i);\n        if (i > 0) message.append(\", \");\n        message.append(pair.getFirst().getTemplatePresentation().getText());\n        message.append(\" (\");\n        message.append(KeymapUtil.getKeystrokeText(pair.getSecond()));\n        message.append(\")\");\n      }\n\n      WindowManager.getInstance().getStatusBar(project).setInfo(message.toString());\n      myState=STATE_WAIT_FOR_SECOND_KEYSTROKE;\n      return true;\n    }else{\n      if (processAction(e, dataContext)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }","commit_id":"d302312278d2e169152e2ac0297388144a2e056d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void report() {\n\t\tfor (XField xfield : statMap.keySet()) {\n\t\t\tFieldStats stats = statMap.get(xfield);\n\t\t\tif (!stats.interesting) continue;\n\t\t\tJCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t\t.getJCIPAnnotationDatabase();\n\t\t\tboolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n\t\t\tboolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n\t\t\tboolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName().replace('/','.'), \"ThreadSafe\");\n\t\t\tif (notThreadSafe) continue;\n\n\t\t\tWarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\t\t\t\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\t\t\tint numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\t\t\t\n\n\t\t\tint extra = 0;\n\t\t\tif (numWriteUnlocked > 0) extra = numNullCheckLocked;\n\t\t\tint locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n\t\t\tint biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra) );\n\t\t\tint unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n\t\t\tint biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n\t\t\t//int writes = numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (unlocked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n\t\t\t}\n\n\n\t\t\tif (guardedByThis) {\n\t\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n\t\t\t}\n\n\t\t\tif (threadSafe) {\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n\t\t}\n\t\t\tif (!guardedByThis && locked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"IS2: \" + xfield);\n\t\t\t\tif (guardedByThis) System.out.println(\"Guarded by this\");\n\t\t\t\tSystem.out.println(\"  RL: \" + numReadLocked);\n\t\t\t\tSystem.out.println(\"  WL: \" + numWriteLocked);\n\t\t\t\tSystem.out.println(\"  NL: \" + numNullCheckLocked);\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"  RU: \" + numReadUnlocked);\n\t\t\t\tSystem.out.println(\"  WU: \" + numWriteUnlocked);\n\t\t\t\tSystem.out.println(\"  NU: \" + numNullCheckUnlocked);\n\t\t\t}\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked-1))) > biasedLocked) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n\t\t\t}\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0) {\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No writes outside of constructor\");\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n//\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (numReadUnlocked + numReadLocked == 0) {\n\t\t\t\t// No reads outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No reads outside of constructor\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n\t\t\t}\n\n\t\t\tif (stats.getNumLocalLocks() == 0) {\n\t\t\t\tif (DEBUG) System.out.println(\"  No local locks\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n\t\t\t}\n\n\t\t\tint freq, printFreq;\n\t\t\tif (locked + unlocked > 0) {\n\t\t\t\tfreq = (100 * locked) / (locked + unlocked);\n\t\t\t\tprintFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n\t\t\t} else {\n\t\t\t\tprintFreq = freq = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (freq < MIN_SYNC_PERCENT) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"  Sync %: \" + freq);\n\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked) {\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n\t\t\t}\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (!propertySet.isFalsePositive(priority)) {\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, guardedByThis? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t\t\t.addField(xfield)\n\t\t\t\t\t\t.addInt(printFreq).describe(IntAnnotation.INT_SYNC_PERCENT);\n\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\n\t\t\t\t// Add source lines for unsynchronized accesses\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t\t}\n\n\t\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n\t\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (EVAL) {\n\t\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t\t}\n\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","id":106855,"modified_method":"public void report() {\n\t\tfor (XField xfield : statMap.keySet()) {\n\t\t\tFieldStats stats = statMap.get(xfield);\n\t\t\tif (!stats.interesting) continue;\n\t\t\tJCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t\t.getJCIPAnnotationDatabase();\n\t\t\tboolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n\t\t\tboolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n\t\t\tboolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName().replace('/','.'), \"ThreadSafe\");\n\t\t\tif (notThreadSafe) continue;\n\n\t\t\tWarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\t\t\t\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\t\t\tint numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\t\t\t\n\n\t\t\tint extra = 0;\n\t\t\tif (numWriteUnlocked > 0) extra = numNullCheckLocked;\n\t\t\tint locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n\t\t\tint biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra) );\n\t\t\tint unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n\t\t\tint biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n\t\t\t//int writes = numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (unlocked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n\t\t\t}\n\n\n\t\t\tif (guardedByThis) {\n\t\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n\t\t\t}\n\n\t\t\tif (threadSafe) {\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n\t\t}\n\t\t\tif (!guardedByThis && locked == 0 && !stats.isServletField()) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n\t\t\t}\n\t\t\t\n\t\t\tif (stats.isServletField() && numWriteUnlocked == 0 && numWriteUnlocked == 0) \n\t\t\t\tcontinue;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"IS2: \" + xfield);\n\t\t\t\tif (guardedByThis) System.out.println(\"Guarded by this\");\n\t\t\t\tSystem.out.println(\"  RL: \" + numReadLocked);\n\t\t\t\tSystem.out.println(\"  WL: \" + numWriteLocked);\n\t\t\t\tSystem.out.println(\"  NL: \" + numNullCheckLocked);\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"  RU: \" + numReadUnlocked);\n\t\t\t\tSystem.out.println(\"  WU: \" + numWriteUnlocked);\n\t\t\t\tSystem.out.println(\"  NU: \" + numNullCheckUnlocked);\n\t\t\t}\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked-1))) > biasedLocked && !stats.isServletField()) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n\t\t\t}\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0) {\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No writes outside of constructor\");\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n//\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (numReadUnlocked + numReadLocked == 0) {\n\t\t\t\t// No reads outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No reads outside of constructor\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n\t\t\t}\n\n\t\t\tif (stats.getNumLocalLocks() == 0) {\n\t\t\t\tif (DEBUG) System.out.println(\"  No local locks\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n\t\t\t}\n\n\t\t\tint freq, printFreq;\n\t\t\tif (locked + unlocked > 0) {\n\t\t\t\tfreq = (100 * locked) / (locked + unlocked);\n\t\t\t\tprintFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n\t\t\t} else {\n\t\t\t\tprintFreq = freq = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (freq < MIN_SYNC_PERCENT) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"  Sync %: \" + freq);\n\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked) {\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n\t\t\t}\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (!propertySet.isFalsePositive(priority) || stats.isServletField()) {\n\t\t\t\tBugInstance bugInstance;\n\t\t\t\tif (stats.isServletField())\n\t\t\t\t\tbugInstance = new BugInstance(this,  \"MSF_MUTABLE_SERVLET_FIELD\" , Priorities.NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t\t\t.addField(xfield);\n\t\t\t\telse bugInstance = new BugInstance(this, guardedByThis? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t.addField(xfield)\n\t\t\t\t.addInt(printFreq).describe(IntAnnotation.INT_SYNC_PERCENT);\n\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\n\t\t\t\t// Add source lines for unsynchronized accesses\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t\t}\n\n\t\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n\t\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (EVAL) {\n\t\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t\t}\n\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Iterator<SourceLineAnnotation> unsyncAccessIterator() {\n\t\t\tif (!interesting) throw new IllegalStateException(\"Not interesting\");\n\t\t\treturn FieldAccess.asSourceLineAnnotation(unsyncAccessList).iterator();\n\t\t}","id":106856,"modified_method":"FieldStats(XField field) {\n\t\t\tthis.field = field;\n\t\t\tservletField = FindInconsistentSync2.isServletField(field);\n\t\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the access statistics for given field.\n\t */\n\tprivate FieldStats getStats(XField field) {\n\t\tFieldStats stats = statMap.get(field);\n\t\tif (stats == null) {\n\t\t\tstats = new FieldStats();\n\t\t\tstatMap.put(field, stats);\n\t\t}\n\t\treturn stats;\n\t}","id":106857,"modified_method":"/**\n\t * Get the access statistics for given field.\n\t */\n\tprivate FieldStats getStats(XField field) {\n\t\tFieldStats stats = statMap.get(field);\n\t\tif (stats == null) {\n\t\t\tstats = new FieldStats(field);\n\t\t\tstatMap.put(field, stats);\n\t\t}\n\t\treturn stats;\n\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static boolean isConstructor(String methodName) {\n\t\treturn methodName.equals(\"<init>\")\n\t\t\t\t|| methodName.equals(\"<clinit>\")\n\t\t\t\t|| methodName.equals(\"readObject\")\n\t\t\t\t|| methodName.equals(\"clone\")\n\t\t\t\t|| methodName.equals(\"close\")\n\t\t\t\t|| methodName.equals(\"writeObject\")\n\t\t\t\t|| methodName.equals(\"toString\")\n\t\t\t\t|| methodName.equals(\"init\")\n\t\t\t\t|| methodName.equals(\"initialize\")\n\t\t\t\t|| methodName.equals(\"dispose\")\n\t\t\t\t|| methodName.equals(\"finalize\")\n\t\t\t\t|| methodName.equals(\"this\");\n\t}","id":106858,"modified_method":"private static boolean isConstructor(String methodName) {\n\t\treturn methodName.equals(\"<init>\")\n\t\t\t\t|| methodName.equals(\"<clinit>\")\n\t\t\t\t|| methodName.equals(\"readObject\")\n\t\t\t\t|| methodName.equals(\"clone\")\n\t\t\t\t|| methodName.equals(\"close\")\n\t\t\t\t|| methodName.equals(\"writeObject\")\n\t\t\t\t|| methodName.equals(\"toString\")\n\t\t\t\t|| methodName.equals(\"init\")\n\t\t\t\t|| methodName.startsWith(\"init\")\n\t\t\t\t|| methodName.startsWith(\"_\")\n\t\t\t\t|| methodName.indexOf('$') >= 0\n\t\t\t\t|| methodName.equals(\"initialize\")\n\t\t\t\t|| methodName.equals(\"dispose\")\n\t\t\t\t|| methodName.equals(\"finalize\")\n\t\t\t\t|| methodName.equals(\"this\")\n\t\t\t\t|| methodName.equals(\"_jspInit\")\n\t\t\t\t|| methodName.equals(\"_jspDestroy\")\n\t\t\t\t;\n\t\t\t\t\n\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void addAccess(MethodDescriptor method, InstructionHandle handle, boolean isLocked) {\n\t\t\tif (!interesting) return;\n\t\t\tif (!SYNC_ACCESS && isLocked)\n\t\t\t\treturn;\n\n\t\t\tif (!isLocked && syncAccessList.size() == 0 && unsyncAccessList.size() > 10) {\n\t\t\t\tinteresting = false;\n\t\t\t\tsyncAccessList = null;\n\t\t\t\tunsyncAccessList = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(isLocked ? syncAccessList : unsyncAccessList).add(new FieldAccess(method, handle.getPosition()));\n\t\t}","id":106859,"modified_method":"public void addAccess(MethodDescriptor method, InstructionHandle handle, boolean isLocked) {\n\t\t\tif (!interesting) return;\n\t\t\tif (!SYNC_ACCESS && isLocked)\n\t\t\t\treturn;\n\n\t\t\tif (!servletField && !isLocked && syncAccessList.size() == 0 && unsyncAccessList.size() > 10) {\n\t\t\t\tinteresting = false;\n\t\t\t\tsyncAccessList = null;\n\t\t\t\tunsyncAccessList = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(isLocked ? syncAccessList : unsyncAccessList).add(new FieldAccess(method, handle.getPosition()));\n\t\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t// Build self-call graph\n\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t@Override\n\t\t\t\t\t\t public boolean wantCallsFor(Method method) {\n\t\t\t\treturn !method.isPublic();\n\t\t\t}\n\t\t};\n\n\t\tSet<Method> lockedMethodSet;\n\t\t//Set<Method> publicReachableMethods;\n\t\tSet<Method> allMethods = new HashSet<Method>(Arrays.asList(javaClass.getMethods()));\n\n\t\ttry {\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\t\t\tlockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\t\t\t//publicReachableMethods = findPublicReachableMethods(classContext, selfCalls);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Method method : allMethods) {\n\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\t if (isConstructor(method.getName()))\n\t\t\t\t\t\t\t\t\t\t\t continue;\n\t\t\t\t\t\t\t\t\t\t\t */\n\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\tcontinue;\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t}\n\t\t}\n\t}","id":106860,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t// Build self-call graph\n\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t@Override\n\t\t\tpublic boolean wantCallsFor(Method method) {\n\t\t\t\treturn !method.isPublic();\n\t\t\t}\n\t\t};\n\n\t\tSet<Method> lockedMethodSet;\n\t\t//Set<Method> publicReachableMethods;\n\t\tSet<Method> allMethods = new HashSet<Method>(Arrays.asList(javaClass.getMethods()));\n\n\t\ttry {\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\t\t\tlockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\t\t\t//publicReachableMethods = findPublicReachableMethods(classContext, selfCalls);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Method method : allMethods) {\n\t\t\tif (DEBUG) System.out.println(\"******** Analyzing method \" + method.getName());\n\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\tcontinue;\n\n\n\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\tcontinue;\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"ef684d2ba0aa93a3d309d2008766a8dde6f0c8c3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private boolean isTokenToSkip(AnalyzedTokenReadings tokenReadings) {\n    for(AnalyzedToken token: tokenReadings) {\n      if( IPOSTag.adv.match(token.getPOSTag()) || IPOSTag.insert.match(token.getPOSTag()) )\n        return true;\n    }\n    return false;\n  }","id":106861,"modified_method":"private boolean isTokenToSkip(AnalyzedTokenReadings tokenReadings) {\n    for(AnalyzedToken token: tokenReadings) {\n//      System.out.println(\"    tag: \" + token.getPOSTag() + \" for \" + token.getToken());\n      if( IPOSTag.adv.match(token.getPOSTag())\n          || IPOSTag.contains(token.getPOSTag(), \"adv>\")\n          ||  IPOSTag.insert.match(token.getPOSTag()) )\n        return true;\n    }\n    return false;\n  }","commit_id":"4208032fef9cb59522a8d64cbb529334e1c936a3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();    \n\n    AnalyzedTokenReadings reqTokenReadings = null;\n    int i = -1;\n    for (AnalyzedTokenReadings tokenReadings: tokens) {\n      i++;\n\n      String posTag = tokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      //TODO: skip conj . \n\n      if (posTag == null || posTag.contains(IPOSTag.unknown.getText()) || posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME) ){\n        reqTokenReadings = null;\n        continue;\n      }\n\n      String token = tokenReadings.getAnalyzedToken(0).getToken();\n      if( posTag.contains(REQUIRE_VIDMINOK_SUBSTR) && tokenReadings.getReadingsLength() == 1 ) {\n        String prep = token;\n\n        if( prep.equals(\"\") && reverseSearch(tokens, i, \"\") )\n          continue;\n\n        if( prep.equalsIgnoreCase(\"\") )\n          continue;\n\n        if( (prep.equalsIgnoreCase(\"\") || prep.equalsIgnoreCase(\"\"))\n            && tokens.length > i+1 && tokens[i+1].getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\") ) {\n          reqTokenReadings = null;\n          continue;\n        }\n\n        reqTokenReadings = tokenReadings;\n        continue;\n      }\n\n      if( reqTokenReadings == null )\n        continue;\n\n      ArrayList<String> posTagsToFind = new ArrayList<String>();\n\n      //      if( tokens.length > i+1 && Character.isUpperCase(tokenReadings.getAnalyzedToken(0).getToken().charAt(0))\n      //        && hasRequiredPosTag(Arrays.asList(\"v_naz\"), tokenReadings)\n      //        && Character.isUpperCase(tokens[i+1].getAnalyzedToken(0).getToken().charAt(0)) )\n      //          continue; // \"  \"\n\n\n      //TODO: for numerics only v_naz\n      if( reqTokenReadings.getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\") ) { //&& tokenReadings.getAnalyzedToken(0).getPOSTag().equals(IPOSTag.numr) ) { \n        posTagsToFind.add(\"v_naz\");\n      }\n\n      String reqPosTag = reqTokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      Matcher matcher = REQUIRE_VIDMINOK_REGEX.matcher(reqPosTag);\n      while( matcher.find() ) {\n        posTagsToFind.add(matcher.group(1));\n      }\n\n      for(AnalyzedToken readingToken: tokenReadings) {\n        if( IPOSTag.numr.match(readingToken.getPOSTag()) ) {\n          posTagsToFind.add(\"v_naz\");  // TODO: only if noun is following?\n          break;\n        }\n      }\n\n      //      System.out.println(\"For \" + tokenReadings + \" to match \" + posTagsToFind + \" of \" + reqTokenReadings.getToken());\n      if( ! hasRequiredPosTag(posTagsToFind, tokenReadings) ) {\n        if( isTokenToSkip(tokenReadings) )\n          continue;\n\n        //        if( isTokenToIgnore(tokenReadings) ) {\n        //          reqTokenReadings = null;\n        //          continue;\n        //        }\n\n        String prep = reqTokenReadings.getAnalyzedToken(0).getToken();\n        if( prep.equalsIgnoreCase(\"\") || prep.equalsIgnoreCase(\"\") ) {\n          if( hasRequiredPosTag(Arrays.asList(\"p:v_naz\"), tokenReadings) ) {  //TODO: only for subset: ///... or by verb ///...\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        // exceptions\n        if( tokens.length > i+1 ) {\n          if( isCapitalized( token ) \n              && STREETS.contains( tokens[i+1].getAnalyzedToken(0).getToken()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag())\n              && token.equals(\"\") || token.equals(\"\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( reqTokenReadings.getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\")\n              && token.equals(\"\") \n              && IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"\") || token.equals(\"\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"\") ) {\n            //          reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"\") || token.equals(\"\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"\") ) {\n            //          reqTokenReadings = null;\n            continue;\n          }\n\n          if( tokens.length > i+2 && ( \n              (token.equals(\"\") || token.equals(\"\") || token.equals(\"\") || token.equals(\"\")) \n              && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"\")) ) {\n            //          reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        RuleMatch potentialRuleMatch = createRuleMatch(tokenReadings, reqTokenReadings, posTagsToFind);\n        ruleMatches.add(potentialRuleMatch);\n      }\n\n      reqTokenReadings = null;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","id":106862,"modified_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();    \n\n    AnalyzedTokenReadings reqTokenReadings = null;\n    int i = -1;\n    for (AnalyzedTokenReadings tokenReadings: tokens) {\n      i++;\n\n      String posTag = tokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      //TODO: skip conj . \n\n      if (posTag == null || posTag.contains(IPOSTag.unknown.getText()) || posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME) ){\n        reqTokenReadings = null;\n        continue;\n      }\n\n      String token = tokenReadings.getAnalyzedToken(0).getToken();\n      if( posTag.contains(REQUIRE_VIDMINOK_SUBSTR) && tokenReadings.getReadingsLength() == 1 ) {\n        String prep = token;\n\n        if( prep.equals(\"\") && reverseSearch(tokens, i, \"\") )\n          continue;\n\n        if( prep.equalsIgnoreCase(\"\") )\n          continue;\n\n        if( (prep.equalsIgnoreCase(\"\") || prep.equalsIgnoreCase(\"\"))\n            && tokens.length > i+1 && tokens[i+1].getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\") ) {\n          reqTokenReadings = null;\n          continue;\n        }\n\n        reqTokenReadings = tokenReadings;\n        continue;\n      }\n\n      if( reqTokenReadings == null )\n        continue;\n\n      ArrayList<String> posTagsToFind = new ArrayList<String>();\n\n      //      if( tokens.length > i+1 && Character.isUpperCase(tokenReadings.getAnalyzedToken(0).getToken().charAt(0))\n      //        && hasRequiredPosTag(Arrays.asList(\"v_naz\"), tokenReadings)\n      //        && Character.isUpperCase(tokens[i+1].getAnalyzedToken(0).getToken().charAt(0)) )\n      //          continue; // \"  \"\n\n\n      //TODO: for numerics only v_naz\n      if( reqTokenReadings.getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\") ) { //&& tokenReadings.getAnalyzedToken(0).getPOSTag().equals(IPOSTag.numr) ) { \n        posTagsToFind.add(\"v_naz\");\n      }\n\n      String reqPosTag = reqTokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      Matcher matcher = REQUIRE_VIDMINOK_REGEX.matcher(reqPosTag);\n      while( matcher.find() ) {\n        posTagsToFind.add(matcher.group(1));\n      }\n\n      for(AnalyzedToken readingToken: tokenReadings) {\n        if( IPOSTag.numr.match(readingToken.getPOSTag()) ) {\n          posTagsToFind.add(\"v_naz\");  // TODO: only if noun is following?\n          break;\n        }\n      }\n\n      //      System.out.println(\"For \" + tokenReadings + \" to match \" + posTagsToFind + \" of \" + reqTokenReadings.getToken());\n      if( ! hasRequiredPosTag(posTagsToFind, tokenReadings) ) {\n        if( isTokenToSkip(tokenReadings) )\n          continue;\n\n//        if( isTokenToIgnore(tokenReadings) ) {\n//          reqTokenReadings = null;\n//          continue;\n//        }\n\n        String prep = reqTokenReadings.getAnalyzedToken(0).getToken();\n        if( prep.equalsIgnoreCase(\"\") ) {\n          if( tokenReadings.getAnalyzedToken(0).getToken().compareToIgnoreCase(\"\") == 0 ) {  //    \n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        if( prep.equalsIgnoreCase(\"\") || prep.equalsIgnoreCase(\"\") ) {\n          if( hasRequiredPosTag(Arrays.asList(\"p:v_naz\"), tokenReadings) ) {  //TODO: only for subset: ///... or by verb ///...\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        // exceptions\n        if( tokens.length > i+1 ) {\n          if( isCapitalized( token ) \n              && STREETS.contains( tokens[i+1].getAnalyzedToken(0).getToken()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag())\n              && (token.equals(\"\") || token.equals(\"\")\n                  || token.equals(\"\") || token.equals(\"\") ) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( reqTokenReadings.getAnalyzedToken(0).getToken().equalsIgnoreCase(\"\")\n              && token.equals(\"\") \n              && IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"\") || token.equals(\"\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"\") ) {\n            //          reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"\") || token.equals(\"\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"\") ) {\n            //          reqTokenReadings = null;\n            continue;\n          }\n\n          if( prep.equalsIgnoreCase(\"\") && token.equals(\"\") \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( tokens[i+1].getAnalyzedToken(0).getToken().equals(\"\") \n              && tokens[i].getAnalyzedToken(0).getPOSTag().contains(\":abbr\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          \n          if( tokens.length > i+2 ) {\n            if ((token.equals(\"\") || token.equals(\"\") || token.equals(\"\") || token.equals(\"\")) \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"\")) {\n              //          reqTokenReadings = null;\n              continue;\n            }\n\n\n          }\n        }\n\n        RuleMatch potentialRuleMatch = createRuleMatch(tokenReadings, reqTokenReadings, posTagsToFind);\n        ruleMatches.add(potentialRuleMatch);\n      }\n\n      reqTokenReadings = null;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"4208032fef9cb59522a8d64cbb529334e1c936a3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testRule() throws IOException {\n    TokenAgreementRule rule = new TokenAgreementRule(TestTools.getMessages(\"uk\"));\n\n    JLanguageTool langTool = new JLanguageTool(new Ukrainian());\n\n    // correct sentences:\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   ?\")).length);\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"     \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"    \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"    \")).length);\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  1   1\"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  10\"))));\n    \n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  10\"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    \n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"    \"))));\n\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length); //TODO\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\" \"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"\"), matches[0].getSuggestedReplacements());\n\n    matches = rule.match(langTool.getAnalyzedSentence(\" \"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"\", \"\"), matches[0].getSuggestedReplacements());\n    \n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\" ' \")).length);\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"  ' \")).length);\n\n    AnalyzedSentence analyzedSentence = langTool.getAnalyzedSentence(\"   \");\n    RuleMatch[] match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    List<String> suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find : \" + suggestedReplacements, suggestedReplacements.contains(\"\"));\n  }","id":106863,"modified_method":"@Test\n  public void testRule() throws IOException {\n    TokenAgreementRule rule = new TokenAgreementRule(TestTools.getMessages(\"uk\"));\n\n    JLanguageTool langTool = new JLanguageTool(new Ukrainian());\n\n    // correct sentences:\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   ?\")).length);\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\" \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"     \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"    \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"  \")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"    \")).length);\n\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  1   1\"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  10\"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"    \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"     \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"  \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"   \"))));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(rule.match(langTool.getAnalyzedSentence(\"      \"))));\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"      \")).length);\n\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length); //TODO\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n//    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"   \")).length);\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\" \"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"\"), matches[0].getSuggestedReplacements());\n\n    matches = rule.match(langTool.getAnalyzedSentence(\" \"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"\", \"\"), matches[0].getSuggestedReplacements());\n    \n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\" ' \")).length);\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"  ' \")).length);\n\n    AnalyzedSentence analyzedSentence = langTool.getAnalyzedSentence(\"   \");\n    RuleMatch[] match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    List<String> suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find : \" + suggestedReplacements, suggestedReplacements.contains(\"\"));\n  }","commit_id":"4208032fef9cb59522a8d64cbb529334e1c936a3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testChunker() throws IOException {\n\n    TestTools.myAssert(\"  \", \n      \"/[null]SENT_START /[]verb:inf:imperf:intran:tran  /[null]null /[ ]<adv>|/[]noun:n:nv|/[]prep:rv_rod  /[null]null \" +\n      \"/[]verb:futr:s:1:perf:v-u|/[ ]<\/adv>\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n    \n    TestTools.myAssert(\"  .\", \n      \"/[null]SENT_START /[]verb:past:f:perf  /[null]null /[]noun:f:v_naz|/[]adj:f:v_naz  /[null]null /[]adv ./[null]null\",\n       tokenizer, sentenceTokenizer, tagger, demoDisambiguator);\n\n    TestTools.myAssert(\"  .\", \n      \"/[null]SENT_START /[]verb:past:f:perf  /[null]null /[]noun:f:v_naz  /[null]null /[]adv ./[null]null\",\n       tokenizer, sentenceTokenizer, tagger, disambiguator);\n      \n  }","id":106864,"modified_method":"public void testChunker() throws IOException {\n\n    TestTools.myAssert(\"  \", \n      \"/[null]SENT_START /[]verb:inf:imperf:intran:tran  /[null]null /[ ]<adv>|/[]prep:rv_rod  /[null]null \" +\n      \"/[]verb:futr:s:1:perf:v-u|/[ ]<\/adv>\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n    \n    TestTools.myAssert(\"  .\", \n      \"/[null]SENT_START /[]verb:past:f:perf  /[null]null /[]noun:f:v_naz|/[]adj:f:v_naz  /[null]null /[]adv ./[null]null\",\n       tokenizer, sentenceTokenizer, tagger, demoDisambiguator);\n\n    TestTools.myAssert(\"  .\", \n      \"/[null]SENT_START /[]verb:past:f:perf  /[null]null /[]noun:f:v_naz  /[null]null /[]adv ./[null]null\",\n       tokenizer, sentenceTokenizer, tagger, disambiguator);\n      \n  }","commit_id":"4208032fef9cb59522a8d64cbb529334e1c936a3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testTagger() throws IOException {\n    TestTools.myAssert(\"300 .  . .\", \n      \"300/[300]number -- /[]unknown:abbr -- /[]noun:n:nv|/[]prep:rv_rod -- /[null]null -- /[null]null\",\n       tokenizer, tagger);\n    \n    // one-way case sensitivity\n    TestTools.myAssert(\"\", \"/[]noun:m:v_dav\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_mis|/[]noun:m:v_dav\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:nv:abbr|/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_mis:ist|/[]noun:m:nv|/[]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist|/[]unknown\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]unknown\", tokenizer, tagger);\n\n    TestTools.myAssert(\"101,234\", \n        \"101,234/[101,234]number\",\n         tokenizer, tagger);\n\n    TestTools.myAssert(\"  \", \n      \"/[]noun:f:v_zna -- /[]impers -- /[]noun:m:v_oru|/[]noun:p:v_rod\",\n       tokenizer, tagger);\n       \n    String expected = \n      \"/[]adv -- /[]numr:m:v_naz|/[]numr:m:v_zna|/[]numr:n:v_naz|/[]numr:n:v_zna -- /[]noun:p:v_naz|/[]noun:p:v_zna\"\n    + \" -- /[]pron:m:v_dav|/[]pron:m:v_mis|/[]pron:n:v_dav|/[]pron:n:v_mis|/[]noun:m:v_dav|/[]noun:m:v_mis|/[]noun:m:v_rod\"\n    + \" -- /[]noun:f:v_naz|/[]adj:f:v_naz -- /[]noun:m:v_oru -- /[]prep:rv_rod:rv_zna:rv_oru\"\n    + \" -- /[]noun:m:v_oru:ist -- /[]noun:m:v_oru:ist -- /[]verb:past:m:perf -- /[]adv\"\n    + \" -- /[]excl|/[]part|/[]prep:rv_zna:rv_mis -- \"\n    + \"/[]noun:n:v_naz|/[]noun:n:v_rod|/[]noun:n:v_zna|/[]noun:p:v_naz|/[]noun:p:v_zna\";\n  \n    TestTools.myAssert(\"            .\",\n        expected, tokenizer, tagger);\n  }","id":106865,"modified_method":"public void testTagger() throws IOException {\n    TestTools.myAssert(\"300 .  . .\", \n      \"300/[300]number -- /[]unknown:abbr -- /[]noun:n:nv|/[]prep:rv_rod -- /[null]null -- /[null]null\",\n       tokenizer, tagger);\n\n    TestTools.myAssert(\"101,234\", \"101,234/[101,234]number\", tokenizer, tagger);\n    TestTools.myAssert(\"3,5-5,6% 7 7,4\", \"3,5-5,6%/[3,5-5,6%]number -- 7/[7]number -- 7,4/[7,4]number\", tokenizer, tagger);\n\n    // one-way case sensitivity\n    TestTools.myAssert(\"\", \"/[]noun:m:v_dav\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_mis|/[]noun:m:v_dav\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:nv:abbr|/[]noun:m:v_naz:ist\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_mis:ist|/[]noun:m:nv|/[]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]noun:m:v_naz:ist|/[]unknown\", tokenizer, tagger);\n    TestTools.myAssert(\"\", \"/[]unknown\", tokenizer, tagger);\n\n\n    TestTools.myAssert(\"  \", \n      \"/[]noun:f:v_zna -- /[]impers -- /[]noun:m:v_oru|/[]noun:p:v_rod\",\n       tokenizer, tagger);\n       \n    String expected = \n      \"/[]adv -- /[]numr:m:v_naz|/[]numr:m:v_zna|/[]numr:n:v_naz|/[]numr:n:v_zna -- /[]noun:p:v_naz|/[]noun:p:v_zna\"\n    + \" -- /[]pron:m:v_dav|/[]pron:m:v_mis|/[]pron:n:v_dav|/[]pron:n:v_mis|/[]noun:m:v_dav|/[]noun:m:v_mis|/[]noun:m:v_rod\"\n    + \" -- /[]noun:f:v_naz|/[]adj:f:v_naz -- /[]noun:m:v_oru -- /[]prep:rv_rod:rv_zna:rv_oru\"\n    + \" -- /[]noun:m:v_oru:ist -- /[]noun:m:v_oru:ist -- /[]verb:past:m:perf -- /[]adv\"\n    + \" -- /[]excl|/[]part|/[]prep:rv_zna:rv_mis -- \"\n    + \"/[]noun:n:v_naz|/[]noun:n:v_rod|/[]noun:n:v_zna|/[]noun:p:v_naz|/[]noun:p:v_zna\";\n  \n    TestTools.myAssert(\"            .\",\n        expected, tokenizer, tagger);\n  }","commit_id":"4208032fef9cb59522a8d64cbb529334e1c936a3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/** Tests an HTML element to determine if we should add a newline after the closing tag\n\t* for readability. All tags with newlines after the opening tag also get newlines after\n\t* the closing tag.\n\t* @return True if we should add a newline after the opening tag\n\t*/\n\tprivate Boolean newlineClose(String name) {\n\t\treturn ( newlineOpen(name) || name.equals(\"li\") || name.equals(\"option\"));\n\t}","id":106866,"modified_method":"/** Tests an HTML element to determine if we should add a newline after the closing tag\n\t* for readability. All tags with newlines after the opening tag also get newlines after\n\t* the closing tag.\n\t* @return True if we should add a newline after the opening tag\n\t*/\n\tprivate Boolean newlineClose(String name) {\n\t\treturn (newlineOpen(name) || name.equals(\"link\") || name.equals(\"li\") || name.equals(\"meta\") || name.equals(\"noscript\") || name.equals(\"option\") || name.equals(\"title\"));\n\t}","commit_id":"269976d34f9998332862b3ac0aa7d8c53c5ebc0f","url":"https://github.com/freenet/fred"},{"original_method":"/** Tests an HTML element to determine if we should add a newline after the opening tag\n\t * for readability\n\t * @param name The name of the html elemen\n\t * @return True if we should add a newline after the opening tag\n\t */\n\tprivate Boolean newlineOpen(String name) {\n\t\treturn (name.equals(\"div\") || name.equals(\"form\") || name.equals(\"input\") || name.equals(\"script\") || name.equals(\"table\") || name.equals(\"td\") || name.equals(\"tr\"));\n\t}","id":106867,"modified_method":"/** Tests an HTML element to determine if we should add a newline after the opening tag\n\t * for readability\n\t * @param name The name of the html elemen\n\t * @return True if we should add a newline after the opening tag\n\t */\n\tprivate Boolean newlineOpen(String name) {\n\t\treturn (name.equals(\"body\") || name.equals(\"div\") || name.equals(\"form\") || name.equals(\"head\") || name.equals(\"input\") || name.equals(\"ol\") || name.equals(\"script\") || name.equals(\"table\") || name.equals(\"td\") || name.equals(\"tr\") || name.equals(\"ul\"));\n\t}","commit_id":"269976d34f9998332862b3ac0aa7d8c53c5ebc0f","url":"https://github.com/freenet/fred"},{"original_method":"public StringBuilder generate(StringBuilder tagBuffer) {\n\t\tif(\"#\".equals(name)) {\n\t\t\tif(content != null) {\n\t\t\t\tHTMLEncoder.encodeToBuffer(content, tagBuffer);\n\t\t\t\treturn tagBuffer;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int childIndex = 0, childCount = children.size(); childIndex < childCount; childIndex++) {\n\t\t\t\tHTMLNode childNode = children.get(childIndex);\n\t\t\t\tchildNode.generate(tagBuffer);\n\t\t\t}\n\t\t\treturn tagBuffer;\n\t\t}\n\t\t// Perhaps this should be something else, but since I don't know if '#' was not just arbitrary chosen, I'll just pick '%'\n\t\t// This allows non-encoded text to be appended to the tag buffer\n\t\tif (\"%\".equals(name)) {\n\t\t\ttagBuffer.append(content);\n\t\t\treturn tagBuffer;\n\t\t}\n\t\ttagBuffer.append('<').append(name);\n\t\tSet<Map.Entry<String, String>> attributeSet = attributes.entrySet();\n\t\tfor (Map.Entry<String, String> attributeEntry : attributeSet) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tString attributeValue = attributeEntry.getValue();\n\t\t\ttagBuffer.append(' ');\n\t\t\tHTMLEncoder.encodeToBuffer(attributeName, tagBuffer);\n\t\t\ttagBuffer.append(\"=\\\"\");\n\t\t\tHTMLEncoder.encodeToBuffer(attributeValue, tagBuffer);\n\t\t\ttagBuffer.append('\"');\n\t\t}\n\t\tif (children.size() == 0) {\n\t\t\tif(content==null) {\n\t\t\t\tif (isEmptyElement(name)) {\n\t\t\t\t\ttagBuffer.append(\" />\");\n\t\t\t\t} else {\n\t\t\t\t\ttagBuffer.append(\"><\/\");\n\t\t\t\t\ttagBuffer.append(name);\n\t\t\t\t\ttagBuffer.append('>');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttagBuffer.append(\">\");\n\t\t\t\tHTMLEncoder.encodeToBuffer(content, tagBuffer);\n\t\t\t\ttagBuffer.append(\"<\/\");\n\t\t\t\ttagBuffer.append(name);\n\t\t\t\ttagBuffer.append(\">\");\n\t\t\t}\n\t\t} else {\n\t\t\ttagBuffer.append('>');\n\t\t\tif (newlineOpen(name)) {\n\t\t\t\ttagBuffer.append('\\n');\n\t\t\t}\n\t\t\tfor (int childIndex = 0, childCount = children.size(); childIndex < childCount; childIndex++) {\n\t\t\t\tHTMLNode childNode = children.get(childIndex);\n\t\t\t\tchildNode.generate(tagBuffer);\n\t\t\t}\n\t\t\ttagBuffer.append(\"<\/\");\n\t\t\ttagBuffer.append(name);\n\t\t\ttagBuffer.append('>');\n\t\t\tif (newlineClose(name)) {\n\t\t\t\ttagBuffer.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn tagBuffer;\n\t}","id":106868,"modified_method":"public StringBuilder generate(StringBuilder tagBuffer) {\n\t\tif(\"#\".equals(name)) {\n\t\t\tif(content != null) {\n\t\t\t\tHTMLEncoder.encodeToBuffer(content, tagBuffer);\n\t\t\t\treturn tagBuffer;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int childIndex = 0, childCount = children.size(); childIndex < childCount; childIndex++) {\n\t\t\t\tHTMLNode childNode = children.get(childIndex);\n\t\t\t\tchildNode.generate(tagBuffer);\n\t\t\t}\n\t\t\treturn tagBuffer;\n\t\t}\n\t\t// Perhaps this should be something else, but since I don't know if '#' was not just arbitrary chosen, I'll just pick '%'\n\t\t// This allows non-encoded text to be appended to the tag buffer\n\t\tif (\"%\".equals(name)) {\n\t\t\ttagBuffer.append(content);\n\t\t\treturn tagBuffer;\n\t\t}\n\t\ttagBuffer.append('<').append(name);\n\t\tSet<Map.Entry<String, String>> attributeSet = attributes.entrySet();\n\t\tfor (Map.Entry<String, String> attributeEntry : attributeSet) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tString attributeValue = attributeEntry.getValue();\n\t\t\ttagBuffer.append(' ');\n\t\t\tHTMLEncoder.encodeToBuffer(attributeName, tagBuffer);\n\t\t\ttagBuffer.append(\"=\\\"\");\n\t\t\tHTMLEncoder.encodeToBuffer(attributeValue, tagBuffer);\n\t\t\ttagBuffer.append('\"');\n\t\t}\n\t\tif (children.size() == 0) {\n\t\t\tif(content==null) {\n\t\t\t\tif (isEmptyElement(name)) {\n\t\t\t\t\ttagBuffer.append(\" />\");\n\t\t\t\t} else {\n\t\t\t\t\ttagBuffer.append(\"><\/\");\n\t\t\t\t\ttagBuffer.append(name);\n\t\t\t\t\ttagBuffer.append('>');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttagBuffer.append(\">\");\n\t\t\t\tHTMLEncoder.encodeToBuffer(content, tagBuffer);\n\t\t\t\ttagBuffer.append(\"<\/\");\n\t\t\t\ttagBuffer.append(name);\n\t\t\t\ttagBuffer.append(\">\");\n\t\t\t}\n\t\t} else {\n\t\t\ttagBuffer.append('>');\n\t\t\tif (newlineOpen(name)) {\n\t\t\t\ttagBuffer.append('\\n');\n\t\t\t}\n\t\t\tfor (int childIndex = 0, childCount = children.size(); childIndex < childCount; childIndex++) {\n\t\t\t\tHTMLNode childNode = children.get(childIndex);\n\t\t\t\tchildNode.generate(tagBuffer);\n\t\t\t}\n\t\t\ttagBuffer.append(\"<\/\");\n\t\t\ttagBuffer.append(name);\n\t\t\ttagBuffer.append('>');\n\t\t}\n\t\tif (newlineClose(name)) {\n\t\t\ttagBuffer.append('\\n');\n\t\t}\n\t\treturn tagBuffer;\n\t}","commit_id":"269976d34f9998332862b3ac0aa7d8c53c5ebc0f","url":"https://github.com/freenet/fred"},{"original_method":"public MessageElement[] getElements() {\r\n\t\t SObject con=qr.getRecords()[0];\r\n\t\t if(con==null) return null;\r\n\t\t\t return con.get_any();\r\n\t }","id":106869,"modified_method":"public MessageElement[] getElements() throws Exception {\r\n\t\t // Query first\r\n\t\t this.qr = this.binding.query(this.sql);\r\n\t\t // and then return records\r\n\t\t SObject con=qr.getRecords()[0];\r\n\t\t if(con==null) return null;\r\n\t\t\t return con.get_any();\r\n\t }","commit_id":"7b149d32839dd15b3a6806063d85eebd0c960239","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi){\r\n\t\tmeta=(SalesforceInputMeta)smi;\r\n\t\tdata=(SalesforceInputData)sdi;\r\n\t\t\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getInputFields().length;\r\n\t\t\t\r\n\t\t\t // Check if field list is filled \r\n\t\t\t if (data.nrfields==0) {\r\n\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t\t return false;\r\n\t\t\t }\r\n\t\t\t \r\n\t\t\tString soQL=environmentSubstitute(meta.getQuery());\r\n\t\t\t// check target URL\r\n\t\t\tString realUrl=environmentSubstitute(meta.getTargetURL());\r\n\t\t\tif(Const.isEmpty(realUrl)) {\r\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"SalesforceInput.TargetURLMissing.Error\"));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// check username\r\n\t\t\tString realUser=environmentSubstitute(meta.getUserName());\r\n\t\t\tif(Const.isEmpty(realUser)) {\r\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"SalesforceInput.UsernameMissing.Error\"));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\ttry  \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif(meta.isSpecifyQuery()) {\r\n\t\t\t\t\t// Check if user specified a query \r\n\t\t\t\t\t if (Const.isEmpty(soQL)) {\r\n\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.QueryMissing.DialogMessage\"));\r\n\t\t\t\t\t\t return false;\r\n\t\t\t\t\t }\r\n\t\t\t\t}else {\r\n\t\t\t\t\tdata.Module=environmentSubstitute(meta.getModule());\r\n\t\t\t\t\t// Check if module is specified \r\n\t\t\t\t\t if (Const.isEmpty(data.Module)) {\r\n\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.ModuleMissing.DialogMessage\"));\r\n\t\t\t\t\t\t return false;\r\n\t\t\t\t\t }\r\n\t\t\t\t\t // check records filter\r\n\t\t\t\t\t if(meta.getRecordsFilter()!=SalesforceConnectionUtils.RECORDS_FILTER_ALL){\r\n\t\t\t\t\t\t String realFromDateString=environmentSubstitute(meta.getReadFrom());\r\n\t\t\t\t\t\t if(Const.isEmpty(realFromDateString)) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.FromDateMissing.DialogMessage\")); \r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t String realToDateString=environmentSubstitute(meta.getReadTo());\r\n\t\t\t\t\t\t if(Const.isEmpty(realToDateString)) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.ToDateMissing.DialogMessage\")); \r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t try{\r\n\t\t\t\t\t\t\t SimpleDateFormat startDate=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\t\t\t\t\t\t SimpleDateFormat endDate=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\t\t\t\t\t\t startDate.parse(realFromDateString);\r\n\t\t\t\t\t\t\t endDate.parse(realToDateString);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t data.startCal = (GregorianCalendar) startDate.getCalendar();\r\n\t\t\t\t\t\t\t data.endCal = (GregorianCalendar)endDate.getCalendar(); \r\n\t\t\t\t\t\t }catch(Exception e) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInput.ErrorParsingDate\"),e);\r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t }\r\n\t\t\t\t}\r\n\t\t\t\t \r\n\t\t\t\tdata.limit=Const.toLong(environmentSubstitute(meta.getRowLimit()),0);\r\n\t\t\t\t\r\n\t\t\t\t// create a Salesforce connection\r\n\t\t\t\tdata.connection= new SalesforceConnection(log, realUrl, realUser,environmentSubstitute(meta.getPassword()));\r\n\t\t\t\t// set timeout\r\n\t\t\t\tdata.connection.setTimeOut(Const.toInt(environmentSubstitute(meta.getTimeOut()),0));\r\n\t\t\t\t// Do we use compression?\r\n\t\t\t\tif(meta.isUsingCompression()) data.connection.setUsingCompression(true);\r\n\t\t\t\t\r\n\t\t\t    // Build query if needed\r\n\t\t\t    if(meta.isSpecifyQuery()) {\r\n\t\t\t    \t// Free hand SOQL Query\r\n\t\t\t    \tdata.connection.setSQL(soQL.replace(\"\\n\\r\", \"\").replace(\"\\n\", \"\"));\r\n\t\t\t    } else {\r\n\t\t\t    \t// retrieve data from a module\r\n\t\t\t    \t// Set condition if needed\r\n\t\t\t    \tString realCondition=environmentSubstitute(meta.getCondition());\r\n\t\t\t    \tif(!Const.isEmpty(realCondition)) data.connection.setCondition(realCondition);\r\n\t\t\t    \t// Set module\r\n\t\t\t    \tdata.connection.setModule(data.Module);\r\n\t\t\t    \t// Set calendars for update or deleted records\r\n\t\t\t    \tif(meta.getRecordsFilter()!=SalesforceConnectionUtils.RECORDS_FILTER_ALL)\r\n\t\t\t    \t\tdata.connection.setCalendar(meta.getRecordsFilter(), data.startCal, data.endCal);\r\n\t\t\t    \t// Build now SOQL\r\n\t\t\t    \tdata.connection.setSQL(BuiltSOQl());\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Now connect ...\r\n\t\t\t    data.connection.connect();\t\r\n\r\n\t\t\t\t return true;\r\n\t\t\t} \r\n\t\t\tcatch(KettleException ke) \r\n\t\t\t{ \r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"SalesforceInput.Log.ErrorOccurredDuringStepInitialize\")+ke.getMessage()); //$NON-NLS-1$\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":106870,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi){\r\n\t\tmeta=(SalesforceInputMeta)smi;\r\n\t\tdata=(SalesforceInputData)sdi;\r\n\t\t\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getInputFields().length;\r\n\t\t\t\r\n\t\t\t // Check if field list is filled \r\n\t\t\t if (data.nrfields==0) {\r\n\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t\t return false;\r\n\t\t\t }\r\n\t\t\t \r\n\t\t\tString soSQL=environmentSubstitute(meta.getQuery());\r\n\t\t\t// check target URL\r\n\t\t\tString realUrl=environmentSubstitute(meta.getTargetURL());\r\n\t\t\tif(Const.isEmpty(realUrl)) {\r\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"SalesforceInput.TargetURLMissing.Error\"));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// check username\r\n\t\t\tString realUser=environmentSubstitute(meta.getUserName());\r\n\t\t\tif(Const.isEmpty(realUser)) {\r\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"SalesforceInput.UsernameMissing.Error\"));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\ttry  \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif(meta.isSpecifyQuery()) {\r\n\t\t\t\t\t// Check if user specified a query \r\n\t\t\t\t\t if (Const.isEmpty(soSQL)) {\r\n\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.QueryMissing.DialogMessage\"));\r\n\t\t\t\t\t\t return false;\r\n\t\t\t\t\t }\r\n\t\t\t\t}else {\r\n\t\t\t\t\tdata.Module=environmentSubstitute(meta.getModule());\r\n\t\t\t\t\t// Check if module is specified \r\n\t\t\t\t\t if (Const.isEmpty(data.Module)) {\r\n\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.ModuleMissing.DialogMessage\"));\r\n\t\t\t\t\t\t return false;\r\n\t\t\t\t\t }\r\n\t\t\t\t\t // check records filter\r\n\t\t\t\t\t if(meta.getRecordsFilter()!=SalesforceConnectionUtils.RECORDS_FILTER_ALL){\r\n\t\t\t\t\t\t String realFromDateString=environmentSubstitute(meta.getReadFrom());\r\n\t\t\t\t\t\t if(Const.isEmpty(realFromDateString)) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.FromDateMissing.DialogMessage\")); \r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t String realToDateString=environmentSubstitute(meta.getReadTo());\r\n\t\t\t\t\t\t if(Const.isEmpty(realToDateString)) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInputDialog.ToDateMissing.DialogMessage\")); \r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t try{\r\n\t\t\t\t\t\t\t SimpleDateFormat startDate=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\t\t\t\t\t\t SimpleDateFormat endDate=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\t\t\t\t\t\t startDate.parse(realFromDateString);\r\n\t\t\t\t\t\t\t endDate.parse(realToDateString);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t data.startCal = (GregorianCalendar) startDate.getCalendar();\r\n\t\t\t\t\t\t\t data.endCal = (GregorianCalendar)endDate.getCalendar(); \r\n\t\t\t\t\t\t }catch(Exception e) {\r\n\t\t\t\t\t\t\t log.logError(BaseMessages.getString(PKG, \"SalesforceInput.ErrorParsingDate\"),e);\r\n\t\t\t\t\t\t\t return false;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t }\r\n\t\t\t\t}\r\n\t\t\t\t \r\n\t\t\t\tdata.limit=Const.toLong(environmentSubstitute(meta.getRowLimit()),0);\r\n\t\t\t\t\r\n\t\t\t\t// create a Salesforce connection\r\n\t\t\t\tdata.connection= new SalesforceConnection(log, realUrl, realUser,environmentSubstitute(meta.getPassword()));\r\n\t\t\t\t// set timeout\r\n\t\t\t\tdata.connection.setTimeOut(Const.toInt(environmentSubstitute(meta.getTimeOut()),0));\r\n\t\t\t\t// Do we use compression?\r\n\t\t\t\tif(meta.isUsingCompression()) data.connection.setUsingCompression(true);\r\n\t\t\t\t\r\n\t\t\t    // Build query if needed\r\n\t\t\t    if(meta.isSpecifyQuery()) {\r\n\t\t\t    \t// Free hand SOQL Query\r\n\t\t\t    \tdata.connection.setSQL(soSQL.replace(\"\\n\\r\", \" \").replace(\"\\n\", \" \"));\r\n\t\t\t    } else {\r\n\t\t\t    \t// retrieve data from a module\r\n\t\t\t    \t// Set condition if needed\r\n\t\t\t    \tString realCondition=environmentSubstitute(meta.getCondition());\r\n\t\t\t    \tif(!Const.isEmpty(realCondition)) data.connection.setCondition(realCondition);\r\n\t\t\t    \t// Set module\r\n\t\t\t    \tdata.connection.setModule(data.Module);\r\n\t\t\t    \t// Set calendars for update or deleted records\r\n\t\t\t    \tif(meta.getRecordsFilter()!=SalesforceConnectionUtils.RECORDS_FILTER_ALL)\r\n\t\t\t    \t\tdata.connection.setCalendar(meta.getRecordsFilter(), data.startCal, data.endCal);\r\n\t\t\t    \t// Build now SOQL\r\n\t\t\t    \tdata.connection.setSQL(BuiltSOQl());\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Now connect ...\r\n\t\t\t    data.connection.connect();\t\r\n\r\n\t\t\t\t return true;\r\n\t\t\t} \r\n\t\t\tcatch(KettleException ke) \r\n\t\t\t{ \r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"SalesforceInput.Log.ErrorOccurredDuringStepInitialize\")+ke.getMessage()); //$NON-NLS-1$\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"7b149d32839dd15b3a6806063d85eebd0c960239","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get() \r\n { \r\n\t SalesforceConnection connection=null;\r\n\ttry {\r\n\t\t\r\n\t\tSalesforceInputMeta meta = new SalesforceInputMeta();\r\n\t\tgetInfo(meta);\r\n\t\t\r\n\t\t// Clear Fields Grid\r\n\t\twFields.removeAll();\r\n\t\t\r\n\t    // get real values\r\n\t    String realModule=transMeta.environmentSubstitute(meta.getModule());\r\n\t\tString realURL=transMeta.environmentSubstitute(meta.getTargetURL());\r\n\t\tString realUsername=transMeta.environmentSubstitute(meta.getUserName());\r\n\t\tString realPassword=transMeta.environmentSubstitute(meta.getPassword());\r\n\t\tint realTimeOut=Const.toInt(transMeta.environmentSubstitute(meta.getTimeOut()),0);\r\n\r\n\t\tconnection=new SalesforceConnection(log, realURL,realUsername,realPassword);\r\n\t\tconnection.setTimeOut(realTimeOut);\r\n\t\tif(meta.isSpecifyQuery())   {\r\n\t\t\t// Free hand SOQL\r\n\t\t\tString realQuery=transMeta.environmentSubstitute(meta.getQuery());\r\n\t\t\tconnection.setSQL(realQuery);\r\n\t\t\tconnection.connect();\r\n\t\t    // We are connected, do let's query\r\n\t\t\tMessageElement[] fields =  connection.getElements();\r\n\t\t\tint nrFields=fields.length;\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<nrFields;i++) {\r\n\t\t\t\t// get fieldname\r\n\t\t\t\tString fieldname=fields[i].getName();\r\n\t\t\t\t// return first value\r\n\t\t\t\tString firstValue=fields[i].getValue();\r\n\r\n\t            TableItem item = new TableItem(wFields.table,SWT.NONE);\r\n\t\t\t\titem.setText(1, fieldname);\r\n\t\t\t\titem.setText(2, fieldname);\r\n\t\t\t\r\n\t            // Try to guess field type\r\n\t\t\t\t// I know it's not clean (see up)\r\n\t            if(StringUtil.IsDate(firstValue,\"yyyy-MM-dd\")){\r\n\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_DATE));\r\n\t            \titem.setText(4, \"yyyy-MM-dd\");\t\t    \t\t\t\r\n\t            } else if(StringUtil.IsInteger(firstValue)) {\r\n\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\r\n\t            \titem.setText(5, \"\"+ValueMeta.DEFAULT_INTEGER_LENGTH);\r\n\t            } else if(StringUtil.IsNumber(firstValue)){\r\n\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER)); \r\n\t            } else if(firstValue.equals(\"true\")||firstValue.equals(\"false\")){\r\n\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_BOOLEAN));     \r\n\t            }else\r\n\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING));    \r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tconnection.connect();\r\n\r\n            Field[] fields = connection.getModuleFields(realModule);\r\n            \r\n            for (int i = 0; i < fields.length; i++)  {\r\n            \tString FieldLabel= fields[i].getLabel();\t\r\n            \tString FieldName= fields[i].getName();\t\r\n            \tString FieldType=fields[i].getType().getValue();\r\n            \tString FieldLengh =  fields[i].getLength() + \"\";\r\n \r\n            \tTableItem item = new TableItem(wFields.table,SWT.NONE);\r\n\t\t\t\titem.setText(1, FieldLabel);\r\n\t\t\t\titem.setText(2, FieldName);\r\n\t\t\t\r\n\t\t\t\t// Try to get the Type\r\n\t\t\t\tif (FieldType.equals(\"boolean\")) {\r\n\t\t\t\t\titem.setText(3, \"Boolean\");\r\n\t\t\t\t} else if (FieldType.equals(\"datetime\") || FieldType.equals(\"date\")) {\r\n\t\t\t\t\titem.setText(3, \"Date\");\r\n\t\t\t\t\titem.setText(4, DEFAULT_DATE_FORMAT);\r\n\t\t\t\t} else if (FieldType.equals(\"double\")) {\r\n\t\t\t\t\titem.setText(3, \"Number\");\r\n                } else if (FieldType.equals(\"int\")) {\r\n\t\t\t\t\titem.setText(3, \"Integer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\titem.setText(3, \"String\");\r\n\t\t        }\r\n\t\t\t\t\r\n\t\t\t\t// Get length\r\n\t\t\t\tif (!FieldType.equals(\"boolean\") && !FieldType.equals(\"datetime\") && !FieldType.equals(\"date\"))\r\n\t\t\t\t{\r\n\t\t\t\t\titem.setText(5, FieldLengh);\r\n\t\t\t\t}\t\t\t\t\t\r\n\t       }\r\n        }\r\n\t\twFields.removeEmptyRows();\r\n\t\twFields.setRowNums();\r\n\t\twFields.optWidth(true);\r\n\t} catch (KettleException e) {\r\n\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogTitle\"),\r\n\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogMessage\"),\te);\r\n\t} catch (Exception e) {\r\n\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogTitle\"),\r\n\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogMessage\"),e);\r\n\t}finally{\r\n\t\tif(connection!=null) {\r\n\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t}\r\n\t}\r\n }","id":106871,"modified_method":"private void get() \r\n { \r\n\t SalesforceConnection connection=null;\r\n\ttry {\r\n\t\t\r\n\t\tSalesforceInputMeta meta = new SalesforceInputMeta();\r\n\t\tgetInfo(meta);\r\n\t\t\r\n\t\t// Clear Fields Grid\r\n\t\twFields.removeAll();\r\n\t\t\r\n\t    // get real values\r\n\t    String realModule=transMeta.environmentSubstitute(meta.getModule());\r\n\t\tString realURL=transMeta.environmentSubstitute(meta.getTargetURL());\r\n\t\tString realUsername=transMeta.environmentSubstitute(meta.getUserName());\r\n\t\tString realPassword=transMeta.environmentSubstitute(meta.getPassword());\r\n\t\tint realTimeOut=Const.toInt(transMeta.environmentSubstitute(meta.getTimeOut()),0);\r\n\r\n\t\tconnection=new SalesforceConnection(log, realURL,realUsername,realPassword);\r\n\t\tconnection.setTimeOut(realTimeOut);\r\n\t\tif(meta.isSpecifyQuery())   {\r\n\t\t\t// Free hand SOQL\r\n\t\t\tString realQuery=transMeta.environmentSubstitute(meta.getQuery());\r\n\t\t\tconnection.setSQL(realQuery);\r\n\t\t\tconnection.connect();\r\n\t\t    // We are connected, so let's query\r\n\t\t\tMessageElement[] fields =  connection.getElements();\r\n\t\t\tint nrFields=fields.length;\r\n\t\t\t\r\n\t\t\tfor(int i=0; i<nrFields;i++) {\r\n\t\t\t\t// get fieldname\r\n\t\t\t\tString fieldname=fields[i].getName();\r\n\t\t\t\t// return first value\r\n\t\t\t\tString firstValue=fields[i].getValue();\r\n\t\t\t\t\r\n\t            TableItem item = new TableItem(wFields.table,SWT.NONE);\r\n\t\t\t\titem.setText(1, fieldname);\r\n\t\t\t\titem.setText(2, fieldname);\r\n\t\t\t\r\n\t            // Try to guess field type\r\n\t\t\t\t// I know it's not clean (see up)\r\n\t\t\t\tif(Const.NVL(firstValue, \"null\").equals(\"null\")) {\r\n\t\t\t\t\titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING)); \r\n\t\t\t\t}else {\r\n\t\t           if(StringUtil.IsDate(firstValue,DEFAULT_DATE_TIME_FORMAT)){\r\n\t\t\t            item.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_DATE));\r\n\t\t\t            item.setText(4, DEFAULT_DATE_TIME_FORMAT);\r\n\t\t            } else if(StringUtil.IsDate(firstValue,DEFAULT_DATE_FORMAT)){\r\n\t\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_DATE));\r\n\t\t            \titem.setText(4, DEFAULT_DATE_FORMAT);\r\n\t\t            } else if(StringUtil.IsInteger(firstValue)) {\r\n\t\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_INTEGER));\r\n\t\t            \titem.setText(5, String.valueOf(ValueMeta.DEFAULT_INTEGER_LENGTH));\r\n\t\t            } else if(StringUtil.IsNumber(firstValue)){\r\n\t\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_NUMBER)); \r\n\t\t            } else if(firstValue.equals(\"true\")||firstValue.equals(\"false\")){\r\n\t\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_BOOLEAN));     \r\n\t\t            }else {\r\n\t\t            \titem.setText(3, ValueMeta.getTypeDesc(ValueMeta.TYPE_STRING)); \r\n\t\t            }\r\n\t\t\t\t} \r\n\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tconnection.connect();\r\n\r\n            Field[] fields = connection.getModuleFields(realModule);\r\n            \r\n            for (int i = 0; i < fields.length; i++)  {\r\n            \tString FieldLabel= fields[i].getLabel();\t\r\n            \tString FieldName= fields[i].getName();\t\r\n            \tString FieldType=fields[i].getType().getValue();\r\n            \tString FieldLengh =  String.valueOf(fields[i].getLength());\r\n            \tString FieldPrecision =  String.valueOf(fields[i].getPrecision());\r\n \r\n            \tTableItem item = new TableItem(wFields.table,SWT.NONE);\r\n\t\t\t\titem.setText(1, FieldLabel);\r\n\t\t\t\titem.setText(2, FieldName);\r\n\t\t\t\r\n\t\t\t\t// Try to get the Type\r\n\t\t\t\tif (FieldType.equals(\"boolean\")) {\r\n\t\t\t\t\titem.setText(3, \"Boolean\");\r\n\t\t\t\t} else if (FieldType.equals(\"date\")) {\r\n\t\t\t\t\titem.setText(3, \"Date\");\r\n\t\t\t\t\titem.setText(4, DEFAULT_DATE_FORMAT);\r\n\t\t\t\t} else if (FieldType.equals(\"datetime\")) {\r\n\t\t\t\t\titem.setText(3, \"Date\");\r\n\t\t\t\t\titem.setText(4, DEFAULT_DATE_TIME_FORMAT);\r\n\t\t\t\t} else if (FieldType.equals(\"double\")) {\r\n\t\t\t\t\titem.setText(3, \"Number\");\r\n                } else if (FieldType.equals(\"int\")) {\r\n\t\t\t\t\titem.setText(3, \"Integer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\titem.setText(3, \"String\");\r\n\t\t        }\r\n\t\t\t\t\r\n\t\t\t\t// Get length\r\n\t\t\t\tif (!FieldType.equals(\"boolean\") && !FieldType.equals(\"datetime\") && !FieldType.equals(\"date\")) {\r\n\t\t\t\t\titem.setText(5, FieldLengh);\r\n\t\t\t\t}\t\r\n\t\t\t\t// Get precision\r\n\t\t\t\tif (!FieldType.equals(\"boolean\") && !FieldType.equals(\"datetime\") && !FieldType.equals(\"date\")){\r\n\t\t\t\t\titem.setText(6, FieldPrecision);\r\n\t\t\t\t}\r\n\t       }\r\n        }\r\n\t\twFields.removeEmptyRows();\r\n\t\twFields.setRowNums();\r\n\t\twFields.optWidth(true);\r\n\t} catch (KettleException e) {\r\n\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogTitle\"),\r\n\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogMessage\"),\te);\r\n\t} catch (Exception e) {\r\n\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogTitle\"),\r\n\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputMeta.ErrorRetrieveData.DialogMessage\"),e);\r\n\t}finally{\r\n\t\tif(connection!=null) {\r\n\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t}\r\n\t}\r\n }","commit_id":"7b149d32839dd15b3a6806063d85eebd0c960239","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Returns <code>true<\/code> in case the given extension is one of the known office file extensions.<p>\n     * \n     * Known extensions are: <code>.pdf, .odt, .ods, .odp, .odg, .doc, .xls, .ppt, .vsd<\/code>.<p>\n     * \n     * @param extension the extension to check, must start with a dot '.'\n     * @return <code>true<\/code> in case the given extension is one of the known office file extensions\n     */\n    public static boolean isOfficeExtension(String extension) {\n\n        if (extension != null) {\n            return (extension.equals(\".odt\")\n                || extension.equals(\".ods\")\n                || extension.equals(\".odp\")\n                || extension.equals(\".odg\")\n                || extension.equals(\".pdf\")\n                || extension.equals(\".doc\")\n                || extension.equals(\".xls\")\n                || extension.equals(\".vsd\") || extension.equals(\".ppt\"));\n        } else {\n            return false;\n        }\n    }","id":106872,"modified_method":"/**\n     * Returns <code>true<\/code> in case the given extension is one of the known office file extensions.<p>\n     * \n     * @param extension the extension to check, must start with a dot '.'\n     * @return <code>true<\/code> in case the given extension is one of the known office file extensions\n     */\n    public static boolean isOfficeExtension(String extension) {\n\n        // TODO: next modification move this to a static sorted map for faster lookup:\n        if (extension != null) {\n            return (extension.equals(\".odt\")\n                || extension.equals(\".ods\")\n                || extension.equals(\".odp\")\n                || extension.equals(\".odg\")\n                || extension.equals(\".pdf\")\n                || extension.equals(\".doc\")\n                || extension.equals(\".xls\")\n                || extension.equals(\".vsd\")\n                || extension.equals(\".ppt\")\n                || extension.equals(\".docx\")\n                || extension.equals(\".docm\")\n                || extension.equals(\".dotx\")\n                || extension.equals(\".dotm\")\n                || extension.equals(\".xlsx\")\n                || extension.equals(\".xlsm\")\n                || extension.equals(\".xlsb\")\n                || extension.equals(\".xlam\")\n                || extension.equals(\".pptx\")\n                || extension.equals(\".pptm\")\n                || extension.equals(\".ppsx\")\n                || extension.equals(\".ppsm\")\n                || extension.equals(\".potx\")\n                || extension.equals(\".potm\")\n                || extension.equals(\".ppam\")\n                || extension.equals(\".sldx\")\n                || extension.equals(\".sldm\") || extension.equals(\".thmx\")\n\n            );\n        } else {\n            return false;\n        }\n    }","commit_id":"93453fcc3aef6052645304b950afea98ca4ddeee","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@'\\\"`-]\", \"\");\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion. Note that we may need other contextual information\n      // to decide if e.g. we only want directories.\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      boolean isFileCompletion = false;\n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n      {\n         isFileCompletion = true;\n         addAutocompletionContextForFile(context, firstLine);\n      }\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', add in the autocompletion context --\n      // note that we still need parent contexts to give more information\n      // about the appropriate completion\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', add that context. Note that\n      // we still need outer contexts (so that e.g., if we try\n      // 'debug(stats::rnorm)' we know not to auto-insert parens)\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // If this is not a file completion, we need to further strip and\n      // then set the token. Note that the token will have already been\n      // set if this is a file completion.\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      if (!isFileCompletion)\n         context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getRCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      // Check to see if the token following the cursor is a `::` or `:::`.\n      // If that's the case, then we probably only want to complete package\n      // names.\n      if (tokenCursor.moveToNextToken())\n      {\n         if (tokenCursor.currentValue() == \":\" ||\n             tokenCursor.currentValue() == \"::\" ||\n             tokenCursor.currentValue() == \":::\")\n         {\n            return new AutocompletionContext(\n                  token,\n                  AutocompletionContext.TYPE_PACKAGE);\n         }\n         tokenCursor.moveToPreviousToken();\n      }\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\n               new String[]{ \"[\", \"(\" }, true);\n         \n         // commaCount == -1 implies we failed to find an opening bracket\n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position.\n      \n      // First, attempt to determine where the closing paren is located. If\n      // this fails, we'll just use the start cursor's position (and later\n      // attempt to finish the expression to make it parsable)\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string.\n      //\n      // We strip out the current statement under the cursor, so that\n      // match.call() can later properly resolve the current argument.\n      //\n      // Attempt to find the start of the current statement.\n      TokenCursor clone = startCursor.cloneCursor();\n      do\n      {\n         String value = clone.currentValue();\n         if (value.indexOf(\",\") != -1 || value.equals(\"(\"))\n            break;\n         \n         if (clone.bwdToMatchingToken())\n            continue;\n         \n      } while (clone.moveToPreviousToken());\n      Position startPosition = clone.currentPosition();\n      \n      // Include the opening paren if that's what we found\n      if (clone.currentValue().equals(\"(\"))\n         startPosition.setColumn(startPosition.getColumn() + 1);\n      \n      String beforeText = editor.getTextForRange(Range.fromPoints(\n            tokenCursor.currentPosition(),\n            startPosition));\n      \n      // Now, attempt to find the end of the current statement.\n      // Look for the ',' or ')' that ends the statement for the \n      // currently active argument.\n      boolean lookupSucceeded = false;\n      while (clone.moveToNextToken())\n      {\n         String value = clone.currentValue();\n         if (value.indexOf(\",\") != -1 || value.equals(\")\"))\n         {\n            lookupSucceeded = true;\n            break;\n         }\n         \n         // Bail if we find a closing paren (we should walk over matched\n         // pairs properly, so finding one implies that we have a parse error).\n         if (value.equals(\"]\") || value.equals(\"]]\") || value.equals(\"}\"))\n         {\n            break;\n         }\n         \n         if (clone.fwdToMatchingToken())\n            continue;\n      }\n      \n      String afterText = \"\";\n      if (lookupSucceeded)\n      {\n         afterText = editor.getTextForRange(Range.fromPoints(\n               clone.currentPosition(),\n               endPos));\n      }\n      \n      context.setFunctionCallString(\n            (beforeText + afterText).trim());\n      \n      // Try to identify whether we're producing autocompletions for\n      // a _named_ function argument; if so, produce completions tuned to\n      // that argument.\n      TokenCursor argsCursor = startCursor.cloneCursor();\n      do\n      {\n         String argsValue = argsCursor.currentValue();\n         \n         // Bail if we encounter tokens that we don't expect as part\n         // of the current expression -- this implies we're not really\n         // within a named argument, although this isn't perfect.\n         if (argsValue.equals(\",\") ||\n             argsValue.equals(\"(\"))\n         {\n            break;\n         }\n         \n         // If we encounter an '=', we assume that this is\n         // a function argument.\n         if (argsValue.equals(\"=\") && argsCursor.moveToPreviousToken())\n         {\n            context.setToken(token);\n            \n            ArrayList<String> argData = new ArrayList<String>();\n            argData.add(argsCursor.currentValue());\n            context.setAssocData(argData);\n            \n            ArrayList<Integer> dataType = new ArrayList<Integer>();\n            dataType.add(AutocompletionContext.TYPE_ARGUMENT);\n            context.setDataType(dataType);\n            \n            ArrayList<Integer> numCommas = new ArrayList<Integer>();\n            numCommas.add(0);\n            context.setNumCommas(numCommas);\n            \n            return context;\n         }\n         \n      } while (argsCursor.moveToPreviousToken());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","id":106873,"modified_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@'\\\"`-]\", \"\");\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion. Note that we may need other contextual information\n      // to decide if e.g. we only want directories.\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      boolean isFileCompletion = false;\n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n      {\n         isFileCompletion = true;\n         addAutocompletionContextForFile(context, firstLine);\n      }\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', add in the autocompletion context --\n      // note that we still need parent contexts to give more information\n      // about the appropriate completion\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', add that context. Note that\n      // we still need outer contexts (so that e.g., if we try\n      // 'debug(stats::rnorm)' we know not to auto-insert parens)\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // If this is not a file completion, we need to further strip and\n      // then set the token. Note that the token will have already been\n      // set if this is a file completion.\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      if (!isFileCompletion)\n         context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getRCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      // Check to see if the token following the cursor is a `::` or `:::`.\n      // If that's the case, then we probably only want to complete package\n      // names.\n      if (tokenCursor.moveToNextToken())\n      {\n         if (tokenCursor.currentValue() == \":\" ||\n             tokenCursor.currentValue() == \"::\" ||\n             tokenCursor.currentValue() == \":::\")\n         {\n            return new AutocompletionContext(\n                  token,\n                  AutocompletionContext.TYPE_PACKAGE);\n         }\n         tokenCursor.moveToPreviousToken();\n      }\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\n               new String[]{ \"[\", \"(\" }, true);\n         \n         // commaCount == -1 implies we failed to find an opening bracket\n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position.\n      \n      // First, attempt to determine where the closing paren is located. If\n      // this fails, we'll just use the start cursor's position (and later\n      // attempt to finish the expression to make it parsable)\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string.\n      //\n      // We strip out the current statement under the cursor, so that\n      // match.call() can later properly resolve the current argument.\n      //\n      // Attempt to find the start of the current statement.\n      TokenCursor clone = startCursor.cloneCursor();\n      do\n      {\n         String value = clone.currentValue();\n         if (value.indexOf(\",\") != -1 || value.equals(\"(\"))\n            break;\n         \n         if (clone.bwdToMatchingToken())\n            continue;\n         \n      } while (clone.moveToPreviousToken());\n      Position startPosition = clone.currentPosition();\n      \n      // Include the opening paren if that's what we found\n      if (clone.currentValue().equals(\"(\"))\n         startPosition.setColumn(startPosition.getColumn() + 1);\n      \n      String beforeText = editor.getTextForRange(Range.fromPoints(\n            tokenCursor.currentPosition(),\n            startPosition));\n      \n      // Now, attempt to find the end of the current statement.\n      // Look for the ',' or ')' that ends the statement for the \n      // currently active argument.\n      boolean lookupSucceeded = false;\n      while (clone.moveToNextToken())\n      {\n         String value = clone.currentValue();\n         if (value.indexOf(\",\") != -1 || value.equals(\")\"))\n         {\n            lookupSucceeded = true;\n            break;\n         }\n         \n         // Bail if we find a closing paren (we should walk over matched\n         // pairs properly, so finding one implies that we have a parse error).\n         if (value.equals(\"]\") || value.equals(\"]]\") || value.equals(\"}\"))\n         {\n            break;\n         }\n         \n         if (clone.fwdToMatchingToken())\n            continue;\n      }\n      \n      String afterText = \"\";\n      if (lookupSucceeded)\n      {\n         afterText = editor.getTextForRange(Range.fromPoints(\n               clone.currentPosition(),\n               endPos));\n      }\n      \n      context.setFunctionCallString(\n            (beforeText + afterText).trim());\n      \n      // Try to identify whether we're producing autocompletions for\n      // a _named_ function argument; if so, produce completions tuned to\n      // that argument.\n      TokenCursor argsCursor = startCursor.cloneCursor();\n      do\n      {\n         String argsValue = argsCursor.currentValue();\n         \n         // Bail if we encounter tokens that we don't expect as part\n         // of the current expression -- this implies we're not really\n         // within a named argument, although this isn't perfect.\n         if (argsValue.equals(\",\") ||\n             argsValue.equals(\"(\") ||\n             argsValue.equals(\"$\") ||\n             argsValue.equals(\"@\") ||\n             argsValue.equals(\"::\") ||\n             argsValue.equals(\":::\"))\n         {\n            break;\n         }\n         \n         // If we encounter an '=', we assume that this is\n         // a function argument.\n         if (argsValue.equals(\"=\") && argsCursor.moveToPreviousToken())\n         {\n            context.setToken(token);\n            \n            ArrayList<String> argData = new ArrayList<String>();\n            argData.add(argsCursor.currentValue());\n            context.setAssocData(argData);\n            \n            ArrayList<Integer> dataType = new ArrayList<Integer>();\n            dataType.add(AutocompletionContext.TYPE_ARGUMENT);\n            context.setDataType(dataType);\n            \n            ArrayList<Integer> numCommas = new ArrayList<Integer>();\n            numCommas.add(0);\n            context.setNumCommas(numCommas);\n            \n            return context;\n         }\n         \n      } while (argsCursor.moveToPreviousToken());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","commit_id":"a25137da6898a6467886ae20e06d66a4fbb58295","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void addLoadMetrics(Set<LoadMetric<LoadContext>> metrics, List<ModelNode> array) {\n        Iterator<ModelNode> it= array.iterator();\n\n        while(it.hasNext()) {\n            final ModelNode node= (ModelNode)it.next();\n            int capacity = node.get(CommonAttributes.CAPACITY).asInt(512);\n            int weight = node.get(CommonAttributes.WEIGHT).asInt(9);\n            String type = node.get(CommonAttributes.TYPE).asString();\n            Class<? extends LoadMetric> loadMetricClass = null;\n            LoadMetric<LoadContext> metric = null;\n            if (type.equals(\"ActiveSessionsLoadMetric\"))\n                loadMetricClass = ActiveSessionsLoadMetric.class;\n            if (type.equals(\"BusyConnectorsLoadMetric\"))\n                loadMetricClass = BusyConnectorsLoadMetric.class;\n            if (type.equals(\"ReceiveTrafficLoadMetric\"))\n                loadMetricClass = ReceiveTrafficLoadMetric.class;\n            if (type.equals(\"SendTrafficLoadMetric\"))\n                loadMetricClass = SendTrafficLoadMetric.class;\n            if (type.equals(\"RequestCountLoadMetric\"))\n                loadMetricClass = RequestCountLoadMetric.class;\n            if (loadMetricClass != null) {\n                try {\n                    metric = loadMetricClass.newInstance();\n                    metric.setCapacity(capacity);\n                    metric.setWeight(weight);\n                    metrics.add(metric);\n                } catch (InstantiationException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (IllegalAccessException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }","id":106874,"modified_method":"private void addLoadMetrics(Set<LoadMetric<LoadContext>> metrics, List<ModelNode> array) {\n        Iterator<ModelNode> it= array.iterator();\n\n        while(it.hasNext()) {\n            final ModelNode node= (ModelNode)it.next();\n            int capacity = node.get(CommonAttributes.CAPACITY).asInt(512);\n            int weight = node.get(CommonAttributes.WEIGHT).asInt(9);\n            String type = node.get(CommonAttributes.TYPE).asString();\n            Class<? extends LoadMetric> loadMetricClass = null;\n            LoadMetric<LoadContext> metric = null;\n\n            //  SourcedLoadMetric\n            if (type.equals(\"cpu\"))\n                loadMetricClass = AverageSystemLoadMetric.class;\n            if (type.equals(\"mem\"))\n                loadMetricClass = SystemMemoryUsageLoadMetric.class;\n\n            if (type.equals(\"heap\"))\n                loadMetricClass = HeapMemoryUsageLoadMetric.class;\n\n            // MBeanAttributeLoadMetric...\n            if (type.equals(\"sessions\"))\n                loadMetricClass = ActiveSessionsLoadMetric.class;\n            if (type.equals(\"receive-traffic\"))\n                loadMetricClass = ReceiveTrafficLoadMetric.class;\n            if (type.equals(\"send-traffic\"))\n                loadMetricClass = SendTrafficLoadMetric.class;\n            if (type.equals(\"requests\"))\n                loadMetricClass = RequestCountLoadMetric.class;\n\n            // MBeanAttributeRatioLoadMetric\n            if (type.equals(\"connection-pool\"))\n                loadMetricClass = ConnectionPoolUsageLoadMetric.class;\n            if (type.equals(\"busyness\"))\n                loadMetricClass = BusyConnectorsLoadMetric.class;\n\n\n            if (loadMetricClass != null) {\n                try {\n                    metric = loadMetricClass.newInstance();\n                    metric.setCapacity(capacity);\n                    metric.setWeight(weight);\n                    metrics.add(metric);\n                } catch (InstantiationException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (IllegalAccessException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }","commit_id":"90e5b7146c9cf4a34542dcadb9772d3b9ea1e753","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence sentence) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = sentence\n        .getTokensWithoutWhitespace();\n    // ignoring token 0, i.e. SENT_START\n    goToNextToken: for (int i = 1; i < tokens.length; i++) {\n      if (matchPostagRegexp(tokens[i], ADJECTIU)\n          && !matchPostagRegexp(tokens[i], CONCORDA)\n          && !matchPostagRegexp(tokens[i], GV)) {\n        final String token = tokens[i].getToken();\n        final String prevToken = tokens[i - 1].getToken();\n        String prevPrevToken = \"\";\n        if (i > 2) {\n          prevPrevToken = tokens[i - 2].getToken();\n        }\n        String nextToken = \"\";\n        if (i < tokens.length - 1) {\n          nextToken = tokens[i + 1].getToken();\n        }\n        int j;\n        // boolean adjectiveAgrees = false;\n        // boolean theRuleMaches = false;\n        // boolean isException = false;\n        boolean isPlural = true;\n        boolean isPrevNoun = false;\n        Pattern substPattern = null;\n        Pattern gnPattern = null;\n        Pattern adjPattern = null;\n        Matcher isUpperCase = UPPERCASE.matcher(token);\n\n        // Some exceptions\n        // per molt lleuger\n        if (prevPrevToken.equals(\"per\") && prevToken.equals(\"molt\")) {\n          continue goToNextToken;\n        }\n        // esquerra-dreta\n        if (i < tokens.length - 2 && token.equalsIgnoreCase(\"esquerra\")\n            && (nextToken.equals(\"-\") || nextToken.equals(\"/\"))\n            && tokens[i + 2].getToken().equalsIgnoreCase(\"dreta\")) {\n          continue goToNextToken;\n        }\n\n        // Counts nouns and determiners before the adjectives.\n        // Takes care of acceptable combinations.\n        int maxLevels = 4;\n        int[] cNt = new int[maxLevels];\n        int[] cNMS = new int[maxLevels];\n        int[] cNFS = new int[maxLevels];\n        int[] cNMP = new int[maxLevels];\n        int[] cNFP = new int[maxLevels];\n        int[] cNCS = new int[maxLevels];\n        int[] cNCP = new int[maxLevels];\n        int[] cDMS = new int[maxLevels];\n        int[] cDFS = new int[maxLevels];\n        int[] cDMP = new int[maxLevels];\n        int[] cDFP = new int[maxLevels];\n        int[] cN = new int[maxLevels];\n        int[] cD = new int[maxLevels];\n        /*\n         * for (j = 0; j < maxLevels; j++) { cNt[j] = 0; cNMS[j] = 0; cNFS[j] =\n         * 0; cNMP[j] = 0; cNFP[j] = 0; cDMS[j] = 0; cDFS[j] = 0; cDMP[j] = 0;\n         * cDFP[j] = 0; cN[j] = 0; cD[j] = 0; }\n         */\n\n        int level = 0;\n        j = 1;\n        // boolean keepCounting = true;\n        initializeApparitions();\n        while (i - j > 0 && keepCounting(tokens[i - j]) && level < maxLevels) {\n          if (!isPrevNoun) {\n            if (matchPostagRegexp(tokens[i - j], NOM) || (\n            // adjectiu o participi sense nom, per amb algun determinant davant\n                i - j - 1 > 0 && !matchPostagRegexp(tokens[i - j], NOM)\n                    && matchPostagRegexp(tokens[i - j], ADJECTIU) \n                    && matchPostagRegexp(tokens[i - j - 1], DET))) {\n              if (matchPostagRegexp(tokens[i - j], _GN_MS)) {\n                cNMS[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_FS)) {\n                cNFS[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_MP)) {\n                cNMP[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_FP)) {\n                cNFP[level]++;\n              }\n            }\n            if (!matchPostagRegexp(tokens[i - j], _GN_)) {\n              if (matchPostagRegexp(tokens[i - j], NOM_MS)) {\n                cNMS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_FS)) {\n                cNFS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_MP)) {\n                cNMP[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_FP)) {\n                cNFP[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_CS)) {\n                cNCS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_CP)) {\n                cNCP[level]++;\n              }\n            }\n          }\n          // avoid two consecutive nouns\n          if (matchPostagRegexp(tokens[i - j], NOM)) {\n            cNt[level]++;\n            isPrevNoun = true;\n            //initializeApparitions();\n          } else {\n            isPrevNoun = false;\n          }\n\n          if (matchPostagRegexp(tokens[i - j], DET_CS)) {\n            if (matchPostagRegexp(tokens[i - j + 1], NOM_MS)) {\n              cDMS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j + 1], NOM_FS)) {\n              cDFS[level]++;\n            }\n          }\n          if (!matchPostagRegexp(tokens[i - j], ADVERBI)) {\n            if (matchPostagRegexp(tokens[i - j], DET_MS)) {\n              cDMS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_FS)) {\n              cDFS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_MP)) {\n              cDMP[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_FP)) {\n              cDFP[level]++;\n            }\n          }\n          if (i - j > 0) {\n            if (matchRegexp(tokens[i - j].getToken(), PREPOSICIO_CANVI_NIVELL)\n                && !matchRegexp(tokens[i - j - 1].getToken(), COORDINACIO_IONI)\n                && !matchPostagRegexp(tokens[i - j + 1], ADVERBI)) {\n              level++;\n            }\n          }\n          if (level > 0\n              && matchRegexp(tokens[i - j].getToken(), COORDINACIO_IONI)) {\n            int k = 1;\n            while (k < 4\n                && i - j - k > 0\n                && (matchPostagRegexp(tokens[i - j - k], KEEP_COUNT)\n                    || matchRegexp(tokens[i - j - k].getToken(), KEEP_COUNT2) || matchPostagRegexp(\n                      tokens[i - j - k], ADVERBIS_ACCEPTATS))\n                && (!matchRegexp(tokens[i - j - k].getToken(), STOP_COUNT))) {\n              if (matchPostagRegexp(tokens[i - j - k], PREPOSICIONS)) {\n                j = j + k;\n                break;\n              }\n              k++;\n            }\n          }\n          updateApparitions(tokens[i - j]);\n          j++;\n        }\n        level++;\n        if (level > maxLevels) {\n          level = maxLevels;\n        }\n        j = 0;\n        int cNtotal = 0;\n        int cDtotal = 0;\n        while (j < level) {\n          cN[j] = cNMS[j] + cNFS[j] + cNMP[j] + cNFP[j] + cNCS[j] + cNCP[j];\n          cD[j] = cDMS[j] + cDFS[j] + cDMP[j] + cDFP[j];\n          cNtotal += cN[j];\n          cDtotal += cD[j];\n\n          // exceptions: adjective is plural and there are several nouns before\n          if (matchPostagRegexp(tokens[i], ADJECTIU_MP)\n              && (cN[j] > 1 || cD[j] > 1)\n              && (cNMS[j] + cNMP[j] + cNCS[j] + cNCP[j] + cDMS[j] + cDMP[j]) > 0\n              && (cNFS[j] + cNFP[j] <= cNt[j])) {\n            continue goToNextToken;\n          }\n          if (matchPostagRegexp(tokens[i], ADJECTIU_FP)\n              && (cN[j] > 1 || cD[j] > 1)\n              && ((cNMS[j] + cNMP[j] + cDMS[j] + cDMP[j]) == 0 || (cNt[j] > 0 && cNFS[j]\n                  + cNFP[j] >= cNt[j]))) {\n            continue goToNextToken;\n          }\n          // Adjective can't be singular\n          if (cN[j] + cD[j] > 0) { // && level>1\n            isPlural = isPlural && cD[j] > 1; // cN[j]>1\n          }\n          j++;\n        }\n        // there is no noun, (no determinant --> && cDtotal==0)\n        if (cNtotal == 0 && cDtotal == 0) { \n          continue goToNextToken;\n        }\n\n        // exception: noun (or adj) plural + two or more adjectives\n        if (i < tokens.length - 2) {\n          Matcher pCoordina = COORDINACIO.matcher(nextToken);\n          if (pCoordina.matches()) {\n            if (((matchPostagRegexp(tokens[i - 1], NOM_MP) || matchPostagRegexp(\n                tokens[i - 1], ADJECTIU_MP))\n                && matchPostagRegexp(tokens[i], ADJECTIU_MS) && matchPostagRegexp(\n                  tokens[i + 2], ADJECTIU_MS))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_MP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_MP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_MP) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_MP))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_FP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_FP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_FS) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_FS))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_FP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_FP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_FP) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_FP))) {\n              continue goToNextToken;\n            }\n          }\n        }\n        // exception: termes, paraules, etc.\n        if (matchRegexp(prevToken, EXCEPCIONS_PREVIA)) {\n          continue goToNextToken;\n        }\n        // exceptions: la meitat mascles\n        if (matchPostagRegexp(tokens[i - 1], EXCEPCIONS_PREVIA_POSTAG)) {\n          continue goToNextToken;\n        }\n        // exceptions: llevat de, tret de, majsucula inicial\n        if ((((token.equals(\"tret\") || token.equals(\"llevat\")) && (nextToken\n            .equals(\"de\") || nextToken.equals(\"que\")))\n            || token.equals(\"primer\")\n            || token.equals(\"junts\")\n            || token.equals(\"plegats\") || isUpperCase.matches())) {\n          continue goToNextToken;\n        }\n        // exceptions: ats, atesos..., donat, donats...\n        if (matchRegexp(token, EXCEPCIONS_PARTICIPI)) {\n          continue goToNextToken;\n        }\n        // exceptions: un cop, una volta, una vegada...\n        if (((prevPrevToken.equals(\"un\") && (prevToken.equals(\"cop\") || prevToken\n            .equals(\"colp\"))) || (prevPrevToken.equals(\"una\") && (prevToken\n            .equals(\"volta\") || prevToken.equals(\"vegada\"))))) {\n          continue goToNextToken;\n        }\n        // exceptions: segur que, just a\n        if (i < tokens.length - 1) {\n          if ((token.equals(\"segur\") || token.equals(\"major\") || token\n              .equals(\"menor\")) && nextToken.equals(\"que\")) {\n            continue goToNextToken;\n          }\n        }\n        // exceptions: sota mateix, dins mateix,\n        if (token.equals(\"mateix\") && matchPostagRegexp(tokens[i - 1], ADVERBI)) {\n          continue goToNextToken;\n        }\n\n        // patterns according to the analyzed adjective \n        if (matchPostagRegexp(tokens[i], ADJECTIU_CS)) {\n          substPattern = GN_CS;\n          adjPattern = ADJECTIU_S;\n          gnPattern = _GN_CS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_CP)) {\n          substPattern = GN_CP;\n          adjPattern = ADJECTIU_P;\n          gnPattern = _GN_CP;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_MS)) {\n          substPattern = GN_MS;\n          adjPattern = ADJECTIU_MS;\n          gnPattern = _GN_MS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_FS)) {\n          substPattern = GN_FS;\n          adjPattern = ADJECTIU_FS;\n          gnPattern = _GN_FS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_MP)) {\n          substPattern = GN_MP;\n          adjPattern = ADJECTIU_MP;\n          gnPattern = _GN_MP;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_FP)) {\n          substPattern = GN_FP;\n          adjPattern = ADJECTIU_FP;\n          gnPattern = _GN_FP;\n        }\n\n        if (substPattern == null || gnPattern == null || adjPattern == null) {\n          continue goToNextToken;\n        }\n\n        // combinations Det/Nom + adv (1,2..) + adj. \n        // If there is agreement, the rule doesn't match\n        j = 1;\n        boolean keepCount = true;\n        while (i - j > 0 && keepCount) {\n          if (matchPostagRegexp(tokens[i - j], NOM_DET)\n              && matchPostagRegexp(tokens[i - j], gnPattern)) {\n            continue goToNextToken; // there is a previous agreeing noun\n          } else if (!matchPostagRegexp(tokens[i - j], _GN_)\n              && matchPostagRegexp(tokens[i - j], substPattern)) {\n            continue goToNextToken; // there is a previous agreeing noun\n          }\n          keepCount = !matchPostagRegexp(tokens[i - j], NOM_DET);\n          j++;\n        }\n\n        // Necessary condition: previous token is a non-agreeing noun\n        // or it is adjective or adverb (not preceded by verb)\n        // /*&& !matchPostagRegexp(tokens[i],NOM)*/\n        if (!(((matchPostagRegexp(tokens[i - 1], NOM) && !matchPostagRegexp(\n            tokens[i - 1], substPattern)) || (i > 2\n            && ((matchPostagRegexp(tokens[i - 1], ADJECTIU) && !matchPostagRegexp(\n                tokens[i - 1], adjPattern))\n                || matchPostagRegexp(tokens[i - 1], ADVERBIS_ACCEPTATS) || matchPostagRegexp(\n                  tokens[i - 1], LOC_ADV))\n            && !matchPostagRegexp(tokens[i - 2], VERB) && !matchPostagRegexp(\n              tokens[i - 3], VERB))))) {\n          continue goToNextToken;\n        }\n\n        // Adjective can't be singular. The rule matches\n        if (!(isPlural && matchPostagRegexp(tokens[i], ADJECTIU_S))) {\n          //look into previous words\n          j = 1;\n          initializeApparitions();\n          while (i - j > 0 && keepCounting(tokens[i - j])) {\n            // there is a previous agreeing noun\n            if (matchPostagRegexp(tokens[i - j], NOM_DET)\n                && matchPostagRegexp(tokens[i - j], substPattern)) {\n              continue goToNextToken; \n            // there is a previous agreeing adjective (in a nominal group)\n            } else if (matchPostagRegexp(tokens[i - j], ADJECTIU)\n                && matchPostagRegexp(tokens[i - j], gnPattern)) {\n              continue goToNextToken;\n            // if there is no nominal group, it requires noun\n            } /*else if (!matchPostagRegexp(tokens[i - j], _GN_) \n                && matchPostagRegexp(tokens[i - j], substPattern)) {\n              continue goToNextToken; // there is a previous agreeing noun\n            }*/\n            updateApparitions(tokens[i - j]);\n            j++;\n          }\n        }\n\n        // The rule matches\n        final String msg = \"Reviseu la concordana de la paraula \\u00AB\"\n            + token + \"\\u00BB.\";\n        final RuleMatch ruleMatch = new RuleMatch(this,\n            tokens[i].getStartPos(), tokens[i].getStartPos() + token.length(),\n            msg, \"Reviseu la concordana.\");\n        ruleMatches.add(ruleMatch);\n      }\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","id":106875,"modified_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence sentence) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = sentence\n        .getTokensWithoutWhitespace();\n    // ignoring token 0, i.e. SENT_START\n    goToNextToken: for (int i = 1; i < tokens.length; i++) {\n      if (matchPostagRegexp(tokens[i], ADJECTIU)\n          && !matchPostagRegexp(tokens[i], CONCORDA)\n          && !matchPostagRegexp(tokens[i], GV)) {\n        final String token = tokens[i].getToken();\n        final String prevToken = tokens[i - 1].getToken();\n        String prevPrevToken = \"\";\n        if (i > 2) {\n          prevPrevToken = tokens[i - 2].getToken();\n        }\n        String nextToken = \"\";\n        if (i < tokens.length - 1) {\n          nextToken = tokens[i + 1].getToken();\n        }\n        int j;\n        // boolean adjectiveAgrees = false;\n        // boolean theRuleMaches = false;\n        // boolean isException = false;\n        boolean isPlural = true;\n        boolean isPrevNoun = false;\n        Pattern substPattern = null;\n        Pattern gnPattern = null;\n        Pattern adjPattern = null;\n        Matcher isUpperCase = UPPERCASE.matcher(token);\n\n        // Some exceptions\n        // per molt lleuger\n        if (prevPrevToken.equals(\"per\") && prevToken.equals(\"molt\")) {\n          continue goToNextToken;\n        }\n        // esquerra-dreta\n        if (i < tokens.length - 2 && token.equalsIgnoreCase(\"esquerra\")\n            && (nextToken.equals(\"-\") || nextToken.equals(\"/\"))\n            && tokens[i + 2].getToken().equalsIgnoreCase(\"dreta\")) {\n          continue goToNextToken;\n        }\n\n        // Counts nouns and determiners before the adjectives.\n        // Takes care of acceptable combinations.\n        int maxLevels = 4;\n        int[] cNt = new int[maxLevels];\n        int[] cNMS = new int[maxLevels];\n        int[] cNFS = new int[maxLevels];\n        int[] cNMP = new int[maxLevels];\n        int[] cNFP = new int[maxLevels];\n        int[] cNCS = new int[maxLevels];\n        int[] cNCP = new int[maxLevels];\n        int[] cDMS = new int[maxLevels];\n        int[] cDFS = new int[maxLevels];\n        int[] cDMP = new int[maxLevels];\n        int[] cDFP = new int[maxLevels];\n        int[] cN = new int[maxLevels];\n        int[] cD = new int[maxLevels];\n        /*\n         * for (j = 0; j < maxLevels; j++) { cNt[j] = 0; cNMS[j] = 0; cNFS[j] =\n         * 0; cNMP[j] = 0; cNFP[j] = 0; cDMS[j] = 0; cDFS[j] = 0; cDMP[j] = 0;\n         * cDFP[j] = 0; cN[j] = 0; cD[j] = 0; }\n         */\n\n        int level = 0;\n        j = 1;\n        // boolean keepCounting = true;\n        initializeApparitions();\n        while (i - j > 0 && keepCounting(tokens[i - j]) && level < maxLevels) {\n          if (!isPrevNoun) {\n            if (matchPostagRegexp(tokens[i - j], NOM) || (\n            // adjectiu o participi sense nom, per amb algun determinant davant\n                i - j - 1 > 0 && !matchPostagRegexp(tokens[i - j], NOM)\n                    && matchPostagRegexp(tokens[i - j], ADJECTIU) \n                    && matchPostagRegexp(tokens[i - j - 1], DET))) {\n              if (matchPostagRegexp(tokens[i - j], _GN_MS)) {\n                cNMS[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_FS)) {\n                cNFS[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_MP)) {\n                cNMP[level]++;\n              }\n              if (matchPostagRegexp(tokens[i - j], _GN_FP)) {\n                cNFP[level]++;\n              }\n            }\n            if (!matchPostagRegexp(tokens[i - j], _GN_)) {\n              if (matchPostagRegexp(tokens[i - j], NOM_MS)) {\n                cNMS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_FS)) {\n                cNFS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_MP)) {\n                cNMP[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_FP)) {\n                cNFP[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_CS)) {\n                cNCS[level]++;\n              } else if (matchPostagRegexp(tokens[i - j], NOM_CP)) {\n                cNCP[level]++;\n              }\n            }\n          }\n          // avoid two consecutive nouns\n          if (matchPostagRegexp(tokens[i - j], NOM)) {\n            cNt[level]++;\n            isPrevNoun = true;\n            //initializeApparitions();\n          } else {\n            isPrevNoun = false;\n          }\n\n          if (matchPostagRegexp(tokens[i - j], DET_CS)) {\n            if (matchPostagRegexp(tokens[i - j + 1], NOM_MS)) {\n              cDMS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j + 1], NOM_FS)) {\n              cDFS[level]++;\n            }\n          }\n          if (!matchPostagRegexp(tokens[i - j], ADVERBI)) {\n            if (matchPostagRegexp(tokens[i - j], DET_MS)) {\n              cDMS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_FS)) {\n              cDFS[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_MP)) {\n              cDMP[level]++;\n            }\n            if (matchPostagRegexp(tokens[i - j], DET_FP)) {\n              cDFP[level]++;\n            }\n          }\n          if (i - j > 0) {\n            if (matchRegexp(tokens[i - j].getToken(), PREPOSICIO_CANVI_NIVELL)\n                && !matchRegexp(tokens[i - j - 1].getToken(), COORDINACIO_IONI)\n                && !matchPostagRegexp(tokens[i - j + 1], ADVERBI)) {\n              level++;\n            }\n          }\n          if (level > 0\n              && matchRegexp(tokens[i - j].getToken(), COORDINACIO_IONI)) {\n            int k = 1;\n            while (k < 4\n                && i - j - k > 0\n                && (matchPostagRegexp(tokens[i - j - k], KEEP_COUNT)\n                    || matchRegexp(tokens[i - j - k].getToken(), KEEP_COUNT2) || matchPostagRegexp(\n                      tokens[i - j - k], ADVERBIS_ACCEPTATS))\n                && (!matchRegexp(tokens[i - j - k].getToken(), STOP_COUNT))) {\n              if (matchPostagRegexp(tokens[i - j - k], PREPOSICIONS)) {\n                j = j + k;\n                break;\n              }\n              k++;\n            }\n          }\n          updateApparitions(tokens[i - j]);\n          j++;\n        }\n        level++;\n        if (level > maxLevels) {\n          level = maxLevels;\n        }\n        j = 0;\n        int cNtotal = 0;\n        int cDtotal = 0;\n        while (j < level) {\n          cN[j] = cNMS[j] + cNFS[j] + cNMP[j] + cNFP[j] + cNCS[j] + cNCP[j];\n          cD[j] = cDMS[j] + cDFS[j] + cDMP[j] + cDFP[j];\n          cNtotal += cN[j];\n          cDtotal += cD[j];\n\n          // exceptions: adjective is plural and there are several nouns before\n          if (matchPostagRegexp(tokens[i], ADJECTIU_MP)\n              && (cN[j] > 1 || cD[j] > 1)\n              && (cNMS[j] + cNMP[j] + cNCS[j] + cNCP[j] + cDMS[j] + cDMP[j]) > 0\n              && (cNFS[j] + cNFP[j] <= cNt[j])) {\n            continue goToNextToken;\n          }\n          if (matchPostagRegexp(tokens[i], ADJECTIU_FP)\n              && (cN[j] > 1 || cD[j] > 1)\n              && ((cNMS[j] + cNMP[j] + cDMS[j] + cDMP[j]) == 0 || (cNt[j] > 0 && cNFS[j]\n                  + cNFP[j] >= cNt[j]))) {\n            continue goToNextToken;\n          }\n          // Adjective can't be singular\n          if (cN[j] + cD[j] > 0) { // && level>1\n            isPlural = isPlural && cD[j] > 1; // cN[j]>1\n          }\n          j++;\n        }\n        // there is no noun, (no determinant --> && cDtotal==0)\n        if (cNtotal == 0 && cDtotal == 0) { \n          continue goToNextToken;\n        }\n\n        // exception: noun (or adj) plural + two or more adjectives\n        if (i < tokens.length - 2) {\n          Matcher pCoordina = COORDINACIO.matcher(nextToken);\n          if (pCoordina.matches()) {\n            if (((matchPostagRegexp(tokens[i - 1], NOM_MP) || matchPostagRegexp(\n                tokens[i - 1], ADJECTIU_MP))\n                && matchPostagRegexp(tokens[i], ADJECTIU_MS) && matchPostagRegexp(\n                  tokens[i + 2], ADJECTIU_MS))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_MP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_MP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_MP) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_MP))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_FP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_FP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_FS) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_FS))\n                || ((matchPostagRegexp(tokens[i - 1], NOM_FP) || matchPostagRegexp(\n                    tokens[i - 1], ADJECTIU_FP))\n                    && matchPostagRegexp(tokens[i], ADJECTIU_FP) && matchPostagRegexp(\n                      tokens[i + 2], ADJECTIU_FP))) {\n              continue goToNextToken;\n            }\n          }\n        }\n        // exception: termes, paraules, etc.\n        if (matchRegexp(prevToken, EXCEPCIONS_PREVIA)) {\n          continue goToNextToken;\n        }\n        // exceptions: la meitat mascles\n        if (matchPostagRegexp(tokens[i - 1], EXCEPCIONS_PREVIA_POSTAG)) {\n          continue goToNextToken;\n        }\n        // exceptions: llevat de, tret de, majsucula inicial\n        if ((((token.equals(\"tret\") || token.equals(\"llevat\")) && (nextToken\n            .equals(\"de\") || nextToken.equals(\"que\")))\n            || token.equals(\"primer\")\n            || token.equals(\"junts\")\n            || token.equals(\"plegats\") || isUpperCase.matches())) {\n          continue goToNextToken;\n        }\n        // exceptions: ats, atesos..., donat, donats...\n        if (matchRegexp(token, EXCEPCIONS_PARTICIPI)) {\n          continue goToNextToken;\n        }\n        // exceptions: un cop, una volta, una vegada...\n        if ((((prevPrevToken.equals(\"un\") || prevPrevToken.equals(\"altre\")) && (prevToken.equals(\"cop\") || prevToken.equals(\"colp\"))) \n            || ((prevPrevToken.equals(\"una\") || prevPrevToken.equals(\"altra\")) && (prevToken.equals(\"volta\") || prevToken.equals(\"vegada\"))))\n            ) {\n          continue goToNextToken;\n        }\n        // exceptions: segur que, just a\n        if (i < tokens.length - 1) {\n          if ((token.equals(\"segur\") || token.equals(\"major\") || token\n              .equals(\"menor\")) && nextToken.equals(\"que\")) {\n            continue goToNextToken;\n          }\n        }\n        // exceptions: sota mateix, dins mateix,\n        if (token.equals(\"mateix\") && matchPostagRegexp(tokens[i - 1], ADVERBI)) {\n          continue goToNextToken;\n        }\n\n        // patterns according to the analyzed adjective \n        if (matchPostagRegexp(tokens[i], ADJECTIU_CS)) {\n          substPattern = GN_CS;\n          adjPattern = ADJECTIU_S;\n          gnPattern = _GN_CS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_CP)) {\n          substPattern = GN_CP;\n          adjPattern = ADJECTIU_P;\n          gnPattern = _GN_CP;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_MS)) {\n          substPattern = GN_MS;\n          adjPattern = ADJECTIU_MS;\n          gnPattern = _GN_MS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_FS)) {\n          substPattern = GN_FS;\n          adjPattern = ADJECTIU_FS;\n          gnPattern = _GN_FS;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_MP)) {\n          substPattern = GN_MP;\n          adjPattern = ADJECTIU_MP;\n          gnPattern = _GN_MP;\n        } else if (matchPostagRegexp(tokens[i], ADJECTIU_FP)) {\n          substPattern = GN_FP;\n          adjPattern = ADJECTIU_FP;\n          gnPattern = _GN_FP;\n        }\n\n        if (substPattern == null || gnPattern == null || adjPattern == null) {\n          continue goToNextToken;\n        }\n\n        // combinations Det/Nom + adv (1,2..) + adj. \n        // If there is agreement, the rule doesn't match\n        j = 1;\n        boolean keepCount = true;\n        while (i - j > 0 && keepCount) {\n          if (matchPostagRegexp(tokens[i - j], NOM_DET)\n              && matchPostagRegexp(tokens[i - j], gnPattern)) {\n            continue goToNextToken; // there is a previous agreeing noun\n          } else if (!matchPostagRegexp(tokens[i - j], _GN_)\n              && matchPostagRegexp(tokens[i - j], substPattern)) {\n            continue goToNextToken; // there is a previous agreeing noun\n          }\n          keepCount = !matchPostagRegexp(tokens[i - j], NOM_DET);\n          j++;\n        }\n\n        // Necessary condition: previous token is a non-agreeing noun\n        // or it is adjective or adverb (not preceded by verb)\n        // /*&& !matchPostagRegexp(tokens[i],NOM)*/\n        if (!(((matchPostagRegexp(tokens[i - 1], NOM) && !matchPostagRegexp(\n            tokens[i - 1], substPattern)) || (i > 2\n            && ((matchPostagRegexp(tokens[i - 1], ADJECTIU) && !matchPostagRegexp(\n                tokens[i - 1], adjPattern))\n                || matchPostagRegexp(tokens[i - 1], ADVERBIS_ACCEPTATS) || matchPostagRegexp(\n                  tokens[i - 1], LOC_ADV))\n            && !matchPostagRegexp(tokens[i - 2], VERB) && !matchPostagRegexp(\n              tokens[i - 3], VERB))))) {\n          continue goToNextToken;\n        }\n\n        // Adjective can't be singular. The rule matches\n        if (!(isPlural && matchPostagRegexp(tokens[i], ADJECTIU_S))) {\n          //look into previous words\n          j = 1;\n          initializeApparitions();\n          while (i - j > 0 && keepCounting(tokens[i - j])) {\n            // there is a previous agreeing noun\n            if (matchPostagRegexp(tokens[i - j], NOM_DET)\n                && matchPostagRegexp(tokens[i - j], substPattern)) {\n              continue goToNextToken; \n            // there is a previous agreeing adjective (in a nominal group)\n            } else if (matchPostagRegexp(tokens[i - j], ADJECTIU)\n                && matchPostagRegexp(tokens[i - j], gnPattern)) {\n              continue goToNextToken;\n            // if there is no nominal group, it requires noun\n            } /*else if (!matchPostagRegexp(tokens[i - j], _GN_) \n                && matchPostagRegexp(tokens[i - j], substPattern)) {\n              continue goToNextToken; // there is a previous agreeing noun\n            }*/\n            updateApparitions(tokens[i - j]);\n            j++;\n          }\n        }\n\n        // The rule matches\n        final String msg = \"Reviseu la concordana de la paraula \\u00AB\"\n            + token + \"\\u00BB.\";\n        final RuleMatch ruleMatch = new RuleMatch(this,\n            tokens[i].getStartPos(), tokens[i].getStartPos() + token.length(),\n            msg, \"Reviseu la concordana.\");\n        ruleMatches.add(ruleMatch);\n      }\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"abf2aad7b2a6ed595f3c4efce6d43541c80783db","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testRule() throws IOException {\r\n\r\n    // correct sentences:\r\n    \r\n    //amb la mirada de cadascun dels homes clavada en la de l'adversari\r\n    //de fer una torre o fortificaci bo i allegant que aix\r\n    // a confondre en un mateix amor amics i enemics\r\n    // es van posar en cam provets de presents\r\n    /* d'una banda tossut i, de l'altra, del tot inepte\r\n     * principis mascle i femella de la foscor//els elements reproductors mascle\r\n     * i femella// les formigues mascle i femella\r\n     */\r\n    /*\r\n     * multiwords: en aparena, en essncia,per essncia, amb excs,en reps,\r\n     * amb rapidesa, en algun grau, per molt de temps altres vegades estacionat,\r\n     * en molts casos subordinada?, era al principi instintiva, de moment\r\n     * imperfectament conegudes de llarg menys perfectes, s de totes passades\r\n     * exactament intermdia, s, en conjunt, gaireb intermdia en cert grau\r\n     * parallela en algun grau en grau lleuger menys distintes han estat de fet\r\n     * exterminades\r\n     */\r\n    // (en especial si hi ha un adverbi entremig: en algun grau ms distintes\r\n    //assertCorrect(\"Es van somriure l'una a l'altra encara dretes, suades i panteixants,\");\r\n    assertCorrect(\"despres de la revolta contra el poder pontifici iniciada a Bolonya\");\r\n    assertCorrect(\"-Aix, viatges sola? -va dir\");\r\n    assertCorrect(\"El riu passa engorjat en aquest sector \");\r\n    assertCorrect(\"i ronda amagat pels carrers\");\r\n    assertCorrect(\"Setmanari illustrat d'art, literatura i actualitats fundat a Barcelona\");\r\n    assertCorrect(\"Entitat oficial de crdit a mitj i llarg termini constituda l'any 1920\");\r\n    assertCorrect(\"edificacions superposades d'poca romana republicanes i imperials\");\r\n    assertCorrect(\"Fou un dels primers barris de barraques sorgit desprs del 1939\");\r\n    assertCorrect(\"i el premi a la investigaci mdica atorgat per la Funadaci\");\r\n    assertCorrect(\"no arriben als 300 mm de pluja anuals\");\r\n    assertCorrect(\"un dibuix de colors vius d'un noi ben plantat i una noia preciosa drets\");\r\n    assertCorrect(\"de la captura i l'assassinat recents\");\r\n    //assertCorrect(\", la captura i l'assassinat recents\"); //desambiguar \"la captura\"\r\n    //assertCorrect(\"la revolta contra el poder pontifici iniciada a Bolonya\"); //desambiguar \"la revolta\"\r\n    assertCorrect(\"donar estocades sense ordre ni concert mal dirigides\");\r\n    assertCorrect(\"trobarien un dels nanos mort de fred\");\r\n    assertCorrect(\"aquest text, el ms antic de l'obra fins ara conegut\");\r\n    assertCorrect(\"va reaccionar, la molt astuta, aix\");\r\n    assertCorrect(\"Sn de barba i cabellera blanques\");\r\n    assertCorrect(\"per a dur a terme tota la lectura i escriptura requerides\");\r\n    assertCorrect(\"al cam va trobar una branca de roure slida\");\r\n    assertCorrect(\"Tesis doctorals\");\r\n    assertCorrect(\"Va veure una cara rosada i arrugada, una boca sense dents oberta\");\r\n    assertCorrect(\"la vista en el magnfic ocell de potes i bec vermells\");\r\n    assertCorrect(\"-Malet ximple! -va exclamar Tom\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria classicitzants\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria classicitzant\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria retallats\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria retallada\");\r\n    assertCorrect(\"a confondre en un mateix amor amics i enemics\");\r\n    assertCorrect(\"En l'eix esquerra-dreta.\");\r\n    assertCorrect(\"podrien tamb esdevenir correlacionades\"); \r\n    assertCorrect(\"Cada polinomi en forma expandida\");\r\n    assertCorrect(\"El 1967 una partida de liberals rebel al govern\");\r\n    assertCorrect(\"El 1640 una junta de nobles reunida a Lisboa\");\r\n    assertCorrect(\"amb una expressi de dolor i de por barrejats.\");\r\n    assertCorrect(\"un tram ms tou, amb morfologia i color diferents.\");\r\n    assertCorrect(\"Especialment en matria de policia i finanament autonmics\");\r\n    assertCorrect(\"Especialment en matria de policia i justcia autonmiques\");\r\n    assertCorrect(\"l'obra de Boeci amb espontanetat i vigor notables\");\r\n    assertCorrect(\"tenen en canvi altres parts de llur estructura certament molt anormals:\");\r\n    assertCorrect(\"constitueix l'nica comunitat autnoma amb menys aturats\");\r\n    assertCorrect(\"durant tot l'any, i del sud-est, ms notoris a la primavera\");\r\n    assertCorrect(\"amb la veu i el posat cada cop ms agressius\");\r\n    assertCorrect(\"l'experincia sensitiva i la ra, degudament combinades.\");\r\n    assertCorrect(\"a la infermeria, d'all ms interessat\");\r\n    assertCorrect(\"el record, i absolutament fascinats\");\r\n    assertCorrect(\"no s'atorguen drets de visita tret que ho consenta el progenitor\");\r\n    assertCorrect(\"La meua filla viu amb mi la major part del temps\");\r\n    assertCorrect(\"que en l'actualitat viu a la ciutat de Santa Cruz\");\r\n    assertCorrect(\"sn submarines i la nostra gent viu al fons del mar.\");\r\n    assertCorrect(\"la meitat mascles i la meitat femelles\");\r\n    assertCorrect(\"s fora amarg\");\r\n    assertCorrect(\"Era poders, fora estrabullat\");\r\n    assertCorrect(\"Sn fora desconegudes\");\r\n    assertCorrect(\"Zeus, fora cansat de tot\");\r\n    assertCorrect(\"un carcter fix, per molt extraordinria que sigui la manera\");\r\n    assertCorrect(\"una quantitat copiosa de llavors olioses\");\r\n    assertCorrect(\"que cri sense variaci, per molt lleugers que fossin\");\r\n    assertCorrect(\"Bernab i Saule, un cop acomplerta la seva missi a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, un colp acomplerta la seva missi a Jerusalem\");\r\n    assertIncorrect(\"Bernab i Saule, el colp acomplerta la seva missi a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, una vegada acomplert el seu viatge a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, una volta acomplert el seu viatge a Jerusalem\");\r\n    assertCorrect(\"he passat una nit i un dia sencers a la deriva\");\r\n    assertCorrect(\"L'olor dels teus perfums, ms agradable que tots els blsams.\");\r\n    assertCorrect(\"La part superior esquerra\");\r\n    assertCorrect(\"I s, la crisi ser llarga, molt llarga, potser eterna.\");\r\n    assertCorrect(\"El rei ha trobat l'excusa i l'explicaci adequada.\");\r\n    //assertCorrect(\"t una manera de jugar aquestes gires tan femenina\");\r\n    assertCorrect(\"des de la tradicional divisi en dos regnes establida per Linnaeus\");\r\n    assertCorrect(\"aquestes activitats avui residuals donada ja la manca de territori\");\r\n    assertCorrect(\"instruments de clcul basats en boles anomenats yupana.\");\r\n    assertCorrect(\"El rei ha trobat l'excusa i l'explicaci adequades.\");\r\n    assertCorrect(\"Copa del mn femenina.\");\r\n    assertCorrect(\"Batalla entre asteques i espanyols coneguda com la Nit Trista.\");\r\n    assertCorrect(\"s un informe sobre la cultura japonesa realitzat per encrrec de l'exrcit d'Estats Units.\");\r\n    assertCorrect(\"Les perspectives de futur immediat.\");\r\n    assertCorrect(\"Les perspectives de futur immediates.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfiques.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfic.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfics.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfica.\");\r\n    assertCorrect(\"Les perspectives i el futur immediats.\");\r\n    assertCorrect(\"Un punt de densitat i gravetat infinites.\");\r\n    assertCorrect(\"De la literatura i la cultura catalanes.\");\r\n    assertCorrect(\"Es fa segons regles de lectura constants i regulars.\");\r\n    assertCorrect(\"Les meitats dreta i esquerra de la mandbula.\");\r\n    assertCorrect(\"Els perodes clssic i medieval.\");\r\n    // assertCorrect(\"Els costats superior i laterals.\");\r\n    assertCorrect(\"En una molcula de glucosa i una de fructosa unides.\");\r\n    // Should be Incorrect, but it is impossible to detect\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevat\");\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevats\");\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevada\");\r\n    assertCorrect(\"La massa, el radi i la lluminositat llistats per ell.\");\r\n    assertCorrect(\"La massa, el radi i la lluminositat llistada per ell.\");\r\n    assertCorrect(\"L'origen de l'bac est literalment perdut en el temps.\");\r\n    assertCorrect(\"L'origen ha esdevingut literalment perdut en el temps.\");\r\n    assertCorrect(\"En efecte, hi ha consideracions racistes, llavors fora comunes\");\r\n    assertCorrect(\"el personatge canvi fsicament: ms alt i prim que el seu germ\");\r\n    assertCorrect(\"un a baix i un altre a dalt identificat amb el smbol\");\r\n    assertCorrect(\"un a baix i un altre a dalt identificats amb el smbol\");\r\n    assertCorrect(\"El tabaquisme s l'addicci al tabac provocada per components.\");\r\n    assertCorrect(\"El \\\"treball\\\" en qesti, normalment associat a un lloc de treball pagat\");\r\n    assertCorrect(\"una organitzaci paramilitar de protecci civil tpicament catalana\");\r\n    assertCorrect(\"un Do dues octaves ms alt que l'anterior\");\r\n    assertCorrect(\"sn prcticament dos graus ms baixes\");\r\n    assertCorrect(\"s unes vint vegades ms gran que l'espermatozou.\");\r\n    assertCorrect(\"s unes 20 vegades ms gran que l'espermatozou.\");\r\n    assertCorrect(\"eren quatre vegades ms alts\");\r\n    assertCorrect(\"eren uns fets cada volta ms inexplicables\");\r\n    assertCorrect(\"El castell est totalment en runes i completament cobert de vegetaci.\");\r\n    assertCorrect(\"han estat tant elogiades per la crtica teatral, com polmiques\");\r\n    assertCorrect(\"Del segle XVIII per reconstruda recentment\");\r\n    // assertCorrect(\"vivien a la casa paterna, mig confosos entre els criats.\");\r\n    assertCorrect(\"La indstria, tradicionalment dedicada al txtil i ara molt diversificada,\");\r\n    assertCorrect(\"oficialment la comarca[2] del Moians, molt reivindicada\");\r\n    assertCorrect(\"En l'actualitat est del tot despoblada de residncia permanent.\");\r\n    assertCorrect(\"amb la terra repartida entre diversos propietaris, b que encara poc poblada\");\r\n    assertCorrect(\"al capdamunt de les Costes d'en Quintanes, sota mateix del Tur\");\r\n    assertCorrect(\"el Moviment per l\u2019Autodeterminaci cors\");\r\n    assertCorrect(\"amb una taula de logaritmes davant meu.\");\r\n    assertCorrect(\"la denominaci valenci per a la llengua prpia\");\r\n    assertCorrect(\"Com ms petita s l'obertura de diafragma, ms grans sn la profunditat de camp i la profunditat\");\r\n    assertCorrect(\"es movien mitjanant filferros, tot projectant ombres\");\r\n    assertCorrect(\"sota les grans persianes de color verd recalcades\");\r\n    assertCorrect(\"que seria en pocs anys fora hegemnica a Catalunya\");\r\n    assertCorrect(\"Era un home fora misteris\");\r\n\r\n    // errors:\r\n    assertIncorrect(\"s tan ple d'urgncies, tan ple de desitjs materials\");\r\n    assertIncorrect(\"Tesis doctoral\");\r\n    assertIncorrect(\"vaig posar mans a l'obra: a dins de casa mateix vaig cavar un sot per enterrar\");\r\n    assertIncorrect(\"amb alguns motllurats de guixeria retallat\");\r\n    assertIncorrect(\"amb alguns motllurats de guixeria retallades\");\r\n    assertIncorrect(\"Aquella va ser la seva pea mestre.\");\r\n    assertIncorrect(\"La petici de tramitar el cas per lesions dolosa.\");\r\n    // policia i justcia sn ms usualment femenins, encara que poden ser masculins\r\n    assertIncorrect(\"Especialment en matria de policia i justcia autonmics\");\r\n    assertIncorrect(\"amb rigor i honor barrejades.\");\r\n    assertIncorrect(\"hi ha hagut una certa recuperaci (3,2%), efecte en part de la descongesti madrilenya cap a les provncies limtrofs de Toledo i Guadalajara.\");\r\n    assertIncorrect(\"Son molt boniques\");\r\n    //assertIncorrect(\"La casa destrossat\"); ambigu\r\n    assertIncorrect(\"pantalons curt o llargs\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcada\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcat\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcats\");\r\n    assertIncorrect(\"Sn unes corbes de llum complexos.\");\r\n    assertIncorrect(\"fets moltes vegades inexplicable.\");\r\n    assertIncorrect(\"eren uns fets cada volta ms inexplicable\");\r\n    assertIncorrect(\"Unes explotacions ramaderes porcina.\");\r\n    // assertIncorrect(\"amb un rendiment del 5,62%, ms alta que el 5,44%\");\r\n    // assertIncorrect(\"un a baix i un altre a dalt identificada amb el smbol\");\r\n    // assertIncorrect(\"un a baix i un altre a dalt identificades amb el smbol\");\r\n    // assertIncorrect(\"En efecte, hi ha consideracions, llavors fora comuns\");\r\n    assertIncorrect(\"En efecte, hi ha consideracions llavors fora comuns\");\r\n    // assertIncorrect(\"En efecte, hi ha consideracions racistes, llavors fora comuns\");\r\n    assertIncorrect(\"amb una alineaci imprpiament habituals\");\r\n    assertIncorrect(\"amb una alineaci poc habituals\");\r\n    assertIncorrect(\"amb una alineaci molt poc habituals\");\r\n    // assertIncorrect(\"Era un home fora misteriosa\"); -> permet\r\n    // \"en pocs anys fora hegemnica\"\r\n    assertIncorrect(\"Era un home fora misteriosos\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa perfecte.\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa i l'explicaci adequats.\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa i l'explicaci adequat.\");\r\n    assertIncorrect(\"Les perspectives de futur immediata.\");\r\n    assertIncorrect(\"Les perspectives de futur immediats.\");\r\n    assertIncorrect(\"la llengua i la cultura catalans.\");\r\n    assertIncorrect(\"En una molcula de glucosa i una de fructosa units.\");\r\n    assertIncorrect(\"Un punt de densitat i gravetat infinits.\");\r\n    assertIncorrect(\"ndex de desenvolupament hum i qualitat de vida elevades.\");\r\n    // Should be Incorrect, but it is impossible to detect\r\n    // assertIncorrect(\"ndex de desenvolupament hum i qualitat de vida elevat\");\r\n    assertIncorrect(\"La massa, el radi i la lluminositat llistat per ell.\");\r\n    assertIncorrect(\"La massa, el radi i la lluminositat llistades per ell.\");\r\n    \r\n  }","id":106876,"modified_method":"public void testRule() throws IOException {\r\n\r\n    // correct sentences:\r\n    \r\n    //amb la mirada de cadascun dels homes clavada en la de l'adversari\r\n    //de fer una torre o fortificaci bo i allegant que aix\r\n    // a confondre en un mateix amor amics i enemics\r\n    // es van posar en cam provets de presents\r\n    /* d'una banda tossut i, de l'altra, del tot inepte\r\n     * principis mascle i femella de la foscor//els elements reproductors mascle\r\n     * i femella// les formigues mascle i femella\r\n     */\r\n    /*\r\n     * multiwords: en aparena, en essncia,per essncia, amb excs,en reps,\r\n     * amb rapidesa, en algun grau, per molt de temps altres vegades estacionat,\r\n     * en molts casos subordinada?, era al principi instintiva, de moment\r\n     * imperfectament conegudes de llarg menys perfectes, s de totes passades\r\n     * exactament intermdia, s, en conjunt, gaireb intermdia en cert grau\r\n     * parallela en algun grau en grau lleuger menys distintes han estat de fet\r\n     * exterminades\r\n     */\r\n    // (en especial si hi ha un adverbi entremig: en algun grau ms distintes\r\n    //assertCorrect(\"Es van somriure l'una a l'altra encara dretes, suades i panteixants,\");\r\n    assertCorrect(\"Ell i jo som una altra vegada partidaris del rei\"); \r\n    assertCorrect(\"despres de la revolta contra el poder pontifici iniciada a Bolonya\");\r\n    assertCorrect(\"-Aix, viatges sola? -va dir\");\r\n    assertCorrect(\"El riu passa engorjat en aquest sector \");\r\n    assertCorrect(\"i ronda amagat pels carrers\");\r\n    assertCorrect(\"Setmanari illustrat d'art, literatura i actualitats fundat a Barcelona\");\r\n    assertCorrect(\"Entitat oficial de crdit a mitj i llarg termini constituda l'any 1920\");\r\n    assertCorrect(\"edificacions superposades d'poca romana republicanes i imperials\");\r\n    assertCorrect(\"Fou un dels primers barris de barraques sorgit desprs del 1939\");\r\n    assertCorrect(\"i el premi a la investigaci mdica atorgat per la Funadaci\");\r\n    assertCorrect(\"no arriben als 300 mm de pluja anuals\");\r\n    assertCorrect(\"un dibuix de colors vius d'un noi ben plantat i una noia preciosa drets\");\r\n    assertCorrect(\"de la captura i l'assassinat recents\");\r\n    //assertCorrect(\", la captura i l'assassinat recents\"); //desambiguar \"la captura\"\r\n    //assertCorrect(\"la revolta contra el poder pontifici iniciada a Bolonya\"); //desambiguar \"la revolta\"\r\n    assertCorrect(\"donar estocades sense ordre ni concert mal dirigides\");\r\n    assertCorrect(\"trobarien un dels nanos mort de fred\");\r\n    assertCorrect(\"aquest text, el ms antic de l'obra fins ara conegut\");\r\n    assertCorrect(\"va reaccionar, la molt astuta, aix\");\r\n    assertCorrect(\"Sn de barba i cabellera blanques\");\r\n    assertCorrect(\"per a dur a terme tota la lectura i escriptura requerides\");\r\n    assertCorrect(\"al cam va trobar una branca de roure slida\");\r\n    assertCorrect(\"Tesis doctorals\");\r\n    assertCorrect(\"Va veure una cara rosada i arrugada, una boca sense dents oberta\");\r\n    assertCorrect(\"la vista en el magnfic ocell de potes i bec vermells\");\r\n    assertCorrect(\"-Malet ximple! -va exclamar Tom\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria classicitzants\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria classicitzant\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria retallats\");\r\n    assertCorrect(\"amb alguns motllurats de guixeria retallada\");\r\n    assertCorrect(\"a confondre en un mateix amor amics i enemics\");\r\n    assertCorrect(\"En l'eix esquerra-dreta.\");\r\n    assertCorrect(\"podrien tamb esdevenir correlacionades\"); \r\n    assertCorrect(\"Cada polinomi en forma expandida\");\r\n    assertCorrect(\"El 1967 una partida de liberals rebel al govern\");\r\n    assertCorrect(\"El 1640 una junta de nobles reunida a Lisboa\");\r\n    assertCorrect(\"amb una expressi de dolor i de por barrejats.\");\r\n    assertCorrect(\"un tram ms tou, amb morfologia i color diferents.\");\r\n    assertCorrect(\"Especialment en matria de policia i finanament autonmics\");\r\n    assertCorrect(\"Especialment en matria de policia i justcia autonmiques\");\r\n    assertCorrect(\"l'obra de Boeci amb espontanetat i vigor notables\");\r\n    assertCorrect(\"tenen en canvi altres parts de llur estructura certament molt anormals:\");\r\n    assertCorrect(\"constitueix l'nica comunitat autnoma amb menys aturats\");\r\n    assertCorrect(\"durant tot l'any, i del sud-est, ms notoris a la primavera\");\r\n    assertCorrect(\"amb la veu i el posat cada cop ms agressius\");\r\n    assertCorrect(\"l'experincia sensitiva i la ra, degudament combinades.\");\r\n    assertCorrect(\"a la infermeria, d'all ms interessat\");\r\n    assertCorrect(\"el record, i absolutament fascinats\");\r\n    assertCorrect(\"no s'atorguen drets de visita tret que ho consenta el progenitor\");\r\n    assertCorrect(\"La meua filla viu amb mi la major part del temps\");\r\n    assertCorrect(\"que en l'actualitat viu a la ciutat de Santa Cruz\");\r\n    assertCorrect(\"sn submarines i la nostra gent viu al fons del mar.\");\r\n    assertCorrect(\"la meitat mascles i la meitat femelles\");\r\n    assertCorrect(\"s fora amarg\");\r\n    assertCorrect(\"Era poders, fora estrabullat\");\r\n    assertCorrect(\"Sn fora desconegudes\");\r\n    assertCorrect(\"Zeus, fora cansat de tot\");\r\n    assertCorrect(\"un carcter fix, per molt extraordinria que sigui la manera\");\r\n    assertCorrect(\"una quantitat copiosa de llavors olioses\");\r\n    assertCorrect(\"que cri sense variaci, per molt lleugers que fossin\");\r\n    assertCorrect(\"Bernab i Saule, un cop acomplerta la seva missi a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, un colp acomplerta la seva missi a Jerusalem\");\r\n    assertIncorrect(\"Bernab i Saule, el colp acomplerta la seva missi a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, una vegada acomplert el seu viatge a Jerusalem\");\r\n    assertCorrect(\"Bernab i Saule, una volta acomplert el seu viatge a Jerusalem\");\r\n    assertCorrect(\"he passat una nit i un dia sencers a la deriva\");\r\n    assertCorrect(\"L'olor dels teus perfums, ms agradable que tots els blsams.\");\r\n    assertCorrect(\"La part superior esquerra\");\r\n    assertCorrect(\"I s, la crisi ser llarga, molt llarga, potser eterna.\");\r\n    assertCorrect(\"El rei ha trobat l'excusa i l'explicaci adequada.\");\r\n    //assertCorrect(\"t una manera de jugar aquestes gires tan femenina\");\r\n    assertCorrect(\"des de la tradicional divisi en dos regnes establida per Linnaeus\");\r\n    assertCorrect(\"aquestes activitats avui residuals donada ja la manca de territori\");\r\n    assertCorrect(\"instruments de clcul basats en boles anomenats yupana.\");\r\n    assertCorrect(\"El rei ha trobat l'excusa i l'explicaci adequades.\");\r\n    assertCorrect(\"Copa del mn femenina.\");\r\n    assertCorrect(\"Batalla entre asteques i espanyols coneguda com la Nit Trista.\");\r\n    assertCorrect(\"s un informe sobre la cultura japonesa realitzat per encrrec de l'exrcit d'Estats Units.\");\r\n    assertCorrect(\"Les perspectives de futur immediat.\");\r\n    assertCorrect(\"Les perspectives de futur immediates.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfiques.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfic.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfics.\");\r\n    assertCorrect(\"la tcnica i l'art cinematogrfica.\");\r\n    assertCorrect(\"Les perspectives i el futur immediats.\");\r\n    assertCorrect(\"Un punt de densitat i gravetat infinites.\");\r\n    assertCorrect(\"De la literatura i la cultura catalanes.\");\r\n    assertCorrect(\"Es fa segons regles de lectura constants i regulars.\");\r\n    assertCorrect(\"Les meitats dreta i esquerra de la mandbula.\");\r\n    assertCorrect(\"Els perodes clssic i medieval.\");\r\n    // assertCorrect(\"Els costats superior i laterals.\");\r\n    assertCorrect(\"En una molcula de glucosa i una de fructosa unides.\");\r\n    // Should be Incorrect, but it is impossible to detect\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevat\");\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevats\");\r\n    assertCorrect(\"ndex de desenvolupament hum i qualitat de vida elevada\");\r\n    assertCorrect(\"La massa, el radi i la lluminositat llistats per ell.\");\r\n    assertCorrect(\"La massa, el radi i la lluminositat llistada per ell.\");\r\n    assertCorrect(\"L'origen de l'bac est literalment perdut en el temps.\");\r\n    assertCorrect(\"L'origen ha esdevingut literalment perdut en el temps.\");\r\n    assertCorrect(\"En efecte, hi ha consideracions racistes, llavors fora comunes\");\r\n    assertCorrect(\"el personatge canvi fsicament: ms alt i prim que el seu germ\");\r\n    assertCorrect(\"un a baix i un altre a dalt identificat amb el smbol\");\r\n    assertCorrect(\"un a baix i un altre a dalt identificats amb el smbol\");\r\n    assertCorrect(\"El tabaquisme s l'addicci al tabac provocada per components.\");\r\n    assertCorrect(\"El \\\"treball\\\" en qesti, normalment associat a un lloc de treball pagat\");\r\n    assertCorrect(\"una organitzaci paramilitar de protecci civil tpicament catalana\");\r\n    assertCorrect(\"un Do dues octaves ms alt que l'anterior\");\r\n    assertCorrect(\"sn prcticament dos graus ms baixes\");\r\n    assertCorrect(\"s unes vint vegades ms gran que l'espermatozou.\");\r\n    assertCorrect(\"s unes 20 vegades ms gran que l'espermatozou.\");\r\n    assertCorrect(\"eren quatre vegades ms alts\");\r\n    assertCorrect(\"eren uns fets cada volta ms inexplicables\");\r\n    assertCorrect(\"El castell est totalment en runes i completament cobert de vegetaci.\");\r\n    assertCorrect(\"han estat tant elogiades per la crtica teatral, com polmiques\");\r\n    assertCorrect(\"Del segle XVIII per reconstruda recentment\");\r\n    // assertCorrect(\"vivien a la casa paterna, mig confosos entre els criats.\");\r\n    assertCorrect(\"La indstria, tradicionalment dedicada al txtil i ara molt diversificada,\");\r\n    assertCorrect(\"oficialment la comarca[2] del Moians, molt reivindicada\");\r\n    assertCorrect(\"En l'actualitat est del tot despoblada de residncia permanent.\");\r\n    assertCorrect(\"amb la terra repartida entre diversos propietaris, b que encara poc poblada\");\r\n    assertCorrect(\"al capdamunt de les Costes d'en Quintanes, sota mateix del Tur\");\r\n    assertCorrect(\"el Moviment per l\u2019Autodeterminaci cors\");\r\n    assertCorrect(\"amb una taula de logaritmes davant meu.\");\r\n    assertCorrect(\"la denominaci valenci per a la llengua prpia\");\r\n    assertCorrect(\"Com ms petita s l'obertura de diafragma, ms grans sn la profunditat de camp i la profunditat\");\r\n    assertCorrect(\"es movien mitjanant filferros, tot projectant ombres\");\r\n    assertCorrect(\"sota les grans persianes de color verd recalcades\");\r\n    assertCorrect(\"que seria en pocs anys fora hegemnica a Catalunya\");\r\n    assertCorrect(\"Era un home fora misteris\");\r\n\r\n    // errors:\r\n    assertIncorrect(\"s tan ple d'urgncies, tan ple de desitjs materials\");\r\n    assertIncorrect(\"Tesis doctoral\");\r\n    assertIncorrect(\"vaig posar mans a l'obra: a dins de casa mateix vaig cavar un sot per enterrar\");\r\n    assertIncorrect(\"amb alguns motllurats de guixeria retallat\");\r\n    assertIncorrect(\"amb alguns motllurats de guixeria retallades\");\r\n    assertIncorrect(\"Aquella va ser la seva pea mestre.\");\r\n    assertIncorrect(\"La petici de tramitar el cas per lesions dolosa.\");\r\n    // policia i justcia sn ms usualment femenins, encara que poden ser masculins\r\n    assertIncorrect(\"Especialment en matria de policia i justcia autonmics\");\r\n    assertIncorrect(\"amb rigor i honor barrejades.\");\r\n    assertIncorrect(\"hi ha hagut una certa recuperaci (3,2%), efecte en part de la descongesti madrilenya cap a les provncies limtrofs de Toledo i Guadalajara.\");\r\n    assertIncorrect(\"Son molt boniques\");\r\n    //assertIncorrect(\"La casa destrossat\"); ambigu\r\n    assertIncorrect(\"pantalons curt o llargs\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcada\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcat\");\r\n    assertIncorrect(\"sota les grans persianes de color verd recalcats\");\r\n    assertIncorrect(\"Sn unes corbes de llum complexos.\");\r\n    assertIncorrect(\"fets moltes vegades inexplicable.\");\r\n    assertIncorrect(\"eren uns fets cada volta ms inexplicable\");\r\n    assertIncorrect(\"Unes explotacions ramaderes porcina.\");\r\n    // assertIncorrect(\"amb un rendiment del 5,62%, ms alta que el 5,44%\");\r\n    // assertIncorrect(\"un a baix i un altre a dalt identificada amb el smbol\");\r\n    // assertIncorrect(\"un a baix i un altre a dalt identificades amb el smbol\");\r\n    // assertIncorrect(\"En efecte, hi ha consideracions, llavors fora comuns\");\r\n    assertIncorrect(\"En efecte, hi ha consideracions llavors fora comuns\");\r\n    // assertIncorrect(\"En efecte, hi ha consideracions racistes, llavors fora comuns\");\r\n    assertIncorrect(\"amb una alineaci imprpiament habituals\");\r\n    assertIncorrect(\"amb una alineaci poc habituals\");\r\n    assertIncorrect(\"amb una alineaci molt poc habituals\");\r\n    // assertIncorrect(\"Era un home fora misteriosa\"); -> permet\r\n    // \"en pocs anys fora hegemnica\"\r\n    assertIncorrect(\"Era un home fora misteriosos\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa perfecte.\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa i l'explicaci adequats.\");\r\n    assertIncorrect(\"El rei ha trobat l'excusa i l'explicaci adequat.\");\r\n    assertIncorrect(\"Les perspectives de futur immediata.\");\r\n    assertIncorrect(\"Les perspectives de futur immediats.\");\r\n    assertIncorrect(\"la llengua i la cultura catalans.\");\r\n    assertIncorrect(\"En una molcula de glucosa i una de fructosa units.\");\r\n    assertIncorrect(\"Un punt de densitat i gravetat infinits.\");\r\n    assertIncorrect(\"ndex de desenvolupament hum i qualitat de vida elevades.\");\r\n    // Should be Incorrect, but it is impossible to detect\r\n    // assertIncorrect(\"ndex de desenvolupament hum i qualitat de vida elevat\");\r\n    assertIncorrect(\"La massa, el radi i la lluminositat llistat per ell.\");\r\n    assertIncorrect(\"La massa, el radi i la lluminositat llistades per ell.\");\r\n    \r\n  }","commit_id":"abf2aad7b2a6ed595f3c4efce6d43541c80783db","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"protected void translate(String basedir, String file) throws Exception {\n\t\tfile = StringUtil.replace(\n\t\t\tfile, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\tint x = file.lastIndexOf(StringPool.SLASH);\n\t\tint y = file.indexOf(StringPool.PERIOD);\n\n\t\tString testPackagePath = StringUtil.replace(\n\t\t\tfile.substring(0, x), StringPool.SLASH, StringPool.PERIOD);\n\t\tString testName = file.substring(x + 1, y);\n\t\tString testMethodName =\n\t\t\t\"test\" + testName.substring(0, testName.length() - 4);\n\t\tString testFileName = basedir + \"/\" + file.substring(0, y) + \".java\";\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tsm.append(\"package \" + testPackagePath + \";\\n\\n\");\n\n\t\tsm.append(\"import com.liferay.portal.kernel.util.StringPool;\\n\");\n\t\tsm.append(\"import com.liferay.portalweb.portal.BaseTestCase;\\n\\n\");\n\n\t\tsm.append(\"public class \" + testName + \" extends BaseTestCase {\");\n\n\t\tsm.append(\"public void \" + testMethodName + \"() throws Exception {\");\n\n\t\tString xml = FileUtil.read(basedir + \"/\" + file);\n\n\t\tif ((xml.indexOf(\"<title>\" + testName + \"<\/title>\") == -1) ||\n\t\t\t(xml.indexOf(\"colspan=\\\"3\\\">\" + testName + \"<\/td>\") == -1)) {\n\n\t\t\tSystem.out.println(testName + \" has an invalid test name\");\n\t\t}\n\n\t\tx = xml.indexOf(\"<tbody>\");\n\t\ty = xml.indexOf(\"<\/tbody>\");\n\n\t\txml = xml.substring(x, y + 8);\n\n\t\tx = 0;\n\t\ty = 0;\n\n\t\twhile (true) {\n\t\t\tx = xml.indexOf(\"<tr>\", x);\n\t\t\ty = xml.indexOf(\"\\n<\/tr>\", x);\n\n\t\t\tif ((x == -1) || (y == -1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tx += 6;\n\t\t\ty++;\n\n\t\t\tString step = xml.substring(x, y);\n\n\t\t\tString[] params = getParams(step);\n\n\t\t\tString param1 = params[0];\n\t\t\tString param2 = fixParam(params[1]);\n\t\t\tString param3 = fixParam(params[2]);\n\n\t\t\tif (param1.equals(\"assertConfirmation\")) {\n\t\t\t\tparam2 = StringUtil.replace(param2, \"?\", \"[\\\\\\\\s\\\\\\\\S]\");\n\n\t\t\t\tsm.append(\"assertTrue(selenium.getConfirmation().matches(\\\"^\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"$\\\"));\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"click\") || param1.equals(\"mouseDown\") ||\n\t\t\t\t\t param1.equals(\"mouseUp\") || param1.equals(\"open\") ||\n\t\t\t\t\t param1.equals(\"selectFrame\") ||\n\t\t\t\t\t param1.equals(\"selectWindow\")) {\n\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"clickAndWait\")) {\n\t\t\t\tsm.append(\"selenium.click(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t\tsm.append(\"selenium.waitForPageToLoad(\\\"30000\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"close\")) {\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"();\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"pause\")) {\n\t\t\t\tsm.append(\"Thread.sleep(\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"select\") || param1.equals(\"type\") ||\n\t\t\t\t\t param1.equals(\"typeKeys\") ||\n\t\t\t\t\t param1.equals(\"waitForPopUp\")) {\n\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", \\\"\");\n\t\t\t\tsm.append(param3);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"selectAndWait\")) {\n\t\t\t\tsm.append(\"selenium.select(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", \\\"\");\n\t\t\t\tsm.append(param3);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t\tsm.append(\"selenium.waitForPageToLoad(\\\"30000\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"verifyTextPresent\") ||\n\t\t\t\t\t param1.equals(\"verifyTextNotPresent\")) {\n\n\t\t\t\tif (param1.equals(\"verifyTextPresent\")) {\n\t\t\t\t\tsm.append(\"verifyTrue\");\n\t\t\t\t}\n\t\t\t\telse if (param1.equals(\"verifyTextNotPresent\")) {\n\t\t\t\t\tsm.append(\"verifyFalse\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"(selenium.isTextPresent(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\"));\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"verifyTitle\")) {\n\t\t\t\tsm.append(\"verifyEquals(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", selenium.getTitle());\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"waitForElementNotPresent\") ||\n\t\t\t\t\t param1.equals(\"waitForElementPresent\") ||\n\t\t\t\t\t param1.equals(\"waitForTextPresent\")) {\n\n\t\t\t\tsm.append(\"for (int second = 0;; second++) {\");\n\t\t\t\tsm.append(\"if (second >= 60) {\");\n\t\t\t\tsm.append(\"fail(\\\"timeout\\\");\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"try {\");\n\t\t\t\tsm.append(\"if (\");\n\n\t\t\t\tif (param1.equals(\"waitForElementNotPresent\")) {\n\t\t\t\t\tsm.append(\"!\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"selenium.\");\n\n\t\t\t\tif (param1.equals(\"waitForElementNotPresent\") ||\n\t\t\t\t\tparam1.equals(\"waitForElementPresent\")) {\n\n\t\t\t\t\tsm.append(\"isElementPresent\");\n\t\t\t\t}\n\t\t\t\telse if (param1.equals(\"waitForTextPresent\")) {\n\t\t\t\t\tsm.append(\"isTextPresent\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\")) {\");\n\t\t\t\tsm.append(\"break;\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"catch (Exception e) {\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"Thread.sleep(1000);\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"waitForTable\")) {\n\t\t\t\tsm.append(\"for (int second = 0;; second++) {\");\n\t\t\t\tsm.append(\"if (second >= 60) {\");\n\t\t\t\tsm.append(\"fail(\\\"timeout\\\");\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"try {\");\n\t\t\t\tsm.append(\"if (StringPool.BLANK.equals(selenium.getTable(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\"))) {\");\n\t\t\t\tsm.append(\"break;\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"catch (Exception e) {\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"Thread.sleep(1000);\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(param1 + \" was not translated\");\n\t\t\t}\n\t\t}\n\n\t\tsm.append(\"}\");\n\t\tsm.append(\"}\");\n\n\t\tString content = sm.toString();\n\n\t\tServiceBuilder.writeFile(new File(testFileName), content);\n\t}","id":106877,"modified_method":"protected void translate(String basedir, String file) throws Exception {\n\t\tfile = StringUtil.replace(\n\t\t\tfile, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\tint x = file.lastIndexOf(StringPool.SLASH);\n\t\tint y = file.indexOf(StringPool.PERIOD);\n\n\t\tString testPackagePath = StringUtil.replace(\n\t\t\tfile.substring(0, x), StringPool.SLASH, StringPool.PERIOD);\n\t\tString testName = file.substring(x + 1, y);\n\t\tString testMethodName =\n\t\t\t\"test\" + testName.substring(0, testName.length() - 4);\n\t\tString testFileName = basedir + \"/\" + file.substring(0, y) + \".java\";\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tsm.append(\"package \" + testPackagePath + \";\\n\\n\");\n\n\t\tsm.append(\"import com.liferay.portal.kernel.util.StringPool;\\n\");\n\t\tsm.append(\"import com.liferay.portalweb.portal.BaseTestCase;\\n\\n\");\n\n\t\tsm.append(\"public class \" + testName + \" extends BaseTestCase {\");\n\n\t\tsm.append(\"public void \" + testMethodName + \"() throws Exception {\");\n\n\t\tString xml = FileUtil.read(basedir + \"/\" + file);\n\n\t\tif ((xml.indexOf(\"<title>\" + testName + \"<\/title>\") == -1) ||\n\t\t\t(xml.indexOf(\"colspan=\\\"3\\\">\" + testName + \"<\/td>\") == -1)) {\n\n\t\t\tSystem.out.println(testName + \" has an invalid test name\");\n\t\t}\n\n\t\tx = xml.indexOf(\"<tbody>\");\n\t\ty = xml.indexOf(\"<\/tbody>\");\n\n\t\txml = xml.substring(x, y + 8);\n\n\t\tx = 0;\n\t\ty = 0;\n\n\t\twhile (true) {\n\t\t\tx = xml.indexOf(\"<tr>\", x);\n\t\t\ty = xml.indexOf(\"\\n<\/tr>\", x);\n\n\t\t\tif ((x == -1) || (y == -1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tx += 6;\n\t\t\ty++;\n\n\t\t\tString step = xml.substring(x, y);\n\n\t\t\tString[] params = getParams(step);\n\n\t\t\tString param1 = params[0];\n\t\t\tString param2 = fixParam(params[1]);\n\t\t\tString param3 = fixParam(params[2]);\n\n\t\t\tif (param1.equals(\"assertConfirmation\")) {\n\t\t\t\tparam2 = StringUtil.replace(param2, \"?\", \"[\\\\\\\\s\\\\\\\\S]\");\n\n\t\t\t\tsm.append(\"assertTrue(selenium.getConfirmation().matches(\\\"^\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"$\\\"));\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"click\") || param1.equals(\"mouseDown\") ||\n\t\t\t\t\t param1.equals(\"mouseUp\") || param1.equals(\"open\") ||\n\t\t\t\t\t param1.equals(\"selectFrame\") ||\n\t\t\t\t\t param1.equals(\"selectWindow\")) {\n\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"clickAndWait\")) {\n\t\t\t\tsm.append(\"selenium.click(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t\tsm.append(\"selenium.waitForPageToLoad(\\\"30000\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"close\")) {\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"();\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"pause\")) {\n\t\t\t\tsm.append(\"Thread.sleep(\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"select\") || param1.equals(\"type\") ||\n\t\t\t\t\t param1.equals(\"typeKeys\") ||\n\t\t\t\t\t param1.equals(\"waitForPopUp\")) {\n\n\t\t\t\tsm.append(\"selenium.\");\n\t\t\t\tsm.append(param1);\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", \\\"\");\n\t\t\t\tsm.append(param3);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"selectAndWait\")) {\n\t\t\t\tsm.append(\"selenium.select(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", \\\"\");\n\t\t\t\tsm.append(param3);\n\t\t\t\tsm.append(\"\\\");\");\n\t\t\t\tsm.append(\"selenium.waitForPageToLoad(\\\"30000\\\");\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"verifyTextPresent\") ||\n\t\t\t\t\t param1.equals(\"verifyTextNotPresent\")) {\n\n\t\t\t\tif (param1.equals(\"verifyTextPresent\")) {\n\t\t\t\t\tsm.append(\"verifyTrue\");\n\t\t\t\t}\n\t\t\t\telse if (param1.equals(\"verifyTextNotPresent\")) {\n\t\t\t\t\tsm.append(\"verifyFalse\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"(selenium.isTextPresent(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\"));\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"verifyTitle\")) {\n\t\t\t\tsm.append(\"verifyEquals(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\", selenium.getTitle());\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"waitForElementNotPresent\") ||\n\t\t\t\t\t param1.equals(\"waitForElementPresent\") ||\n\t\t\t\t\t param1.equals(\"waitForTextNotPresent\") ||\n\t\t\t\t\t param1.equals(\"waitForTextPresent\")) {\n\n\t\t\t\tsm.append(\"for (int second = 0;; second++) {\");\n\t\t\t\tsm.append(\"if (second >= 60) {\");\n\t\t\t\tsm.append(\"fail(\\\"timeout\\\");\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"try {\");\n\t\t\t\tsm.append(\"if (\");\n\n\t\t\t\tif (param1.equals(\"waitForElementNotPresent\") ||\n\t\t\t\t\tparam1.equals(\"waitForTextNotPresent\")) {\n\n\t\t\t\t\tsm.append(\"!\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"selenium.\");\n\n\t\t\t\tif (param1.equals(\"waitForElementNotPresent\") ||\n\t\t\t\t\tparam1.equals(\"waitForElementPresent\")) {\n\n\t\t\t\t\tsm.append(\"isElementPresent\");\n\t\t\t\t}\n\t\t\t\telse if (param1.equals(\"waitForTextNotPresent\") ||\n\t\t\t\t\t\t param1.equals(\"waitForTextPresent\")) {\n\n\t\t\t\t\tsm.append(\"isTextPresent\");\n\t\t\t\t}\n\n\t\t\t\tsm.append(\"(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\")) {\");\n\t\t\t\tsm.append(\"break;\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"catch (Exception e) {\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"Thread.sleep(1000);\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t}\n\t\t\telse if (param1.equals(\"waitForTable\")) {\n\t\t\t\tsm.append(\"for (int second = 0;; second++) {\");\n\t\t\t\tsm.append(\"if (second >= 60) {\");\n\t\t\t\tsm.append(\"fail(\\\"timeout\\\");\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"try {\");\n\t\t\t\tsm.append(\"if (StringPool.BLANK.equals(selenium.getTable(\\\"\");\n\t\t\t\tsm.append(param2);\n\t\t\t\tsm.append(\"\\\"))) {\");\n\t\t\t\tsm.append(\"break;\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t\tsm.append(\"catch (Exception e) {\");\n\t\t\t\tsm.append(\"}\");\n\n\t\t\t\tsm.append(\"Thread.sleep(1000);\");\n\t\t\t\tsm.append(\"}\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(param1 + \" was not translated\");\n\t\t\t}\n\t\t}\n\n\t\tsm.append(\"}\");\n\t\tsm.append(\"}\");\n\n\t\tString content = sm.toString();\n\n\t\tServiceBuilder.writeFile(new File(testFileName), content);\n\t}","commit_id":"f8de87f54c7cd9fed3c84508be7dd87fe686a9c9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getMailBody(Map<String, String> fieldsMap) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (String fieldLabel : fieldsMap.keySet()) {\n\t\t\tString fieldValue = fieldsMap.get(fieldLabel);\n\n\t\t\tsb.append(fieldLabel);\n\t\t\tsb.append(\" : \");\n\t\t\tsb.append(fieldValue);\n\t\t\tsb.append(CharPool.NEW_LINE);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":106878,"modified_method":"protected String getMailBody(Map<String, String> fieldsMap) {\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (String fieldLabel : fieldsMap.keySet()) {\n\t\t\tString fieldValue = fieldsMap.get(fieldLabel);\n\n\t\t\tsb.append(fieldLabel);\n\t\t\tsb.append(\" : \");\n\t\t\tsb.append(fieldValue);\n\t\t\tsb.append(CharPool.NEW_LINE);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"4ea479864d8d429ed35666954dff5130de617182","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected boolean saveFile(Map<String, String> fieldsMap, String fileName) {\n\n\t\t// Save the file as a CSV format. Use delimiter from property\n\t\t// CSV_SEPARATOR, quote each entry with double quotes, and escape\n\t\t// double quotes in values a two double quotes.\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (String fieldLabel : fieldsMap.keySet()) {\n\t\t\tString fieldValue = fieldsMap.get(fieldLabel);\n\n\t\t\tsb.append(prepareFieldForCSVExport(fieldValue));\n\t\t}\n\n\t\tString s =\n\t\t\tsb.substring(\n\t\t\t\t0,\n\t\t\t\tsb.length() - PortletPropsValues.CSV_SEPARATOR.length()) +\n\t\t\t\t\tStringPool.NEW_LINE;\n\n\t\ttry {\n\t\t\tFileUtil.write(fileName, s, false, true);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"The web form data could not be saved to a file\", e);\n\n\t\t\treturn false;\n\t\t}\n\t}","id":106879,"modified_method":"protected boolean saveFile(Map<String, String> fieldsMap, String fileName) {\n\n\t\t// Save the file as a CSV format. Use delimiter from property\n\t\t// CSV_SEPARATOR, quote each entry with double quotes, and escape\n\t\t// double quotes in values a two double quotes.\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tfor (String fieldLabel : fieldsMap.keySet()) {\n\t\t\tString fieldValue = fieldsMap.get(fieldLabel);\n\n\t\t\tsb.append(getCSVFormatedValue(fieldValue));\n\t\t\tsb.append(PortletPropsValues.CSV_SEPARATOR);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(CharPool.NEW_LINE);\n\n\t\ttry {\n\t\t\tFileUtil.write(fileName, sb.toString(), false, true);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"The web form data could not be saved to a file\", e);\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"4ea479864d8d429ed35666954dff5130de617182","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void exportData(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletId = PortalUtil.getPortletId(resourceRequest);\n\n\t\tPortletPermissionUtil.check(\n\t\t\tthemeDisplay.getPermissionChecker(), themeDisplay.getPlid(),\n\t\t\tportletId, ActionKeys.CONFIGURATION);\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(resourceRequest);\n\n\t\tString databaseTableName = preferences.getValue(\n\t\t\t\"databaseTableName\", StringPool.BLANK);\n\t\tString title = preferences.getValue(\"title\", \"no-title\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tList<String> fieldLabels = new ArrayList<String>();\n\n\t\tfor (int i = 1; true; i++) {\n\t\t\tString fieldLabel = preferences.getValue(\n\t\t\t\t\"fieldLabel\" + i, StringPool.BLANK);\n\n\t\t\tString localizedfieldLabel = LocalizationUtil.getPreferencesValue(\n\t\t\t\tpreferences, \"fieldLabel\" + i, themeDisplay.getLanguageId());\n\n\t\t\tif (Validator.isNull(fieldLabel)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfieldLabels.add(fieldLabel);\n\n\t\t\tsb.append(prepareFieldForCSVExport(localizedfieldLabel));\n\t\t}\n\n\t\tsb.delete(\n\t\t\tsb.length() - PortletPropsValues.CSV_SEPARATOR.length(),\n\t\t\tsb.length());\n\n\t\tsb.append(CharPool.NEW_LINE);\n\n\t\tif (Validator.isNotNull(databaseTableName)) {\n\t\t\tList<ExpandoRow> rows = ExpandoRowLocalServiceUtil.getRows(\n\t\t\t\tthemeDisplay.getCompanyId(), WebFormUtil.class.getName(),\n\t\t\t\tdatabaseTableName, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tfor (ExpandoRow row : rows) {\n\t\t\t\tfor (String fieldName : fieldLabels) {\n\t\t\t\t\tString data = ExpandoValueLocalServiceUtil.getData(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\t\tWebFormUtil.class.getName(), databaseTableName,\n\t\t\t\t\t\tfieldName, row.getClassPK(), StringPool.BLANK);\n\n\t\t\t\t\tsb.append(prepareFieldForCSVExport(data));\n\t\t\t\t}\n\n\t\t\t\tsb.delete(\n\t\t\t\t\tsb.length() - PortletPropsValues.CSV_SEPARATOR.length(),\n\t\t\t\t\tsb.length());\n\n\t\t\t\tsb.append(CharPool.NEW_LINE);\n\t\t\t}\n\t\t}\n\n\t\tString fileName = title + \".csv\";\n\t\tbyte[] bytes = sb.toString().getBytes();\n\t\tString contentType = ContentTypes.APPLICATION_TEXT;\n\n\t\tPortletResponseUtil.sendFile(\n\t\t\tresourceRequest, resourceResponse, fileName, bytes, contentType);\n\t}","id":106880,"modified_method":"protected void exportData(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletId = PortalUtil.getPortletId(resourceRequest);\n\n\t\tPortletPermissionUtil.check(\n\t\t\tthemeDisplay.getPermissionChecker(), themeDisplay.getPlid(),\n\t\t\tportletId, ActionKeys.CONFIGURATION);\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(resourceRequest);\n\n\t\tString databaseTableName = preferences.getValue(\n\t\t\t\"databaseTableName\", StringPool.BLANK);\n\t\tString title = preferences.getValue(\"title\", \"no-title\");\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tList<String> fieldLabels = new ArrayList<String>();\n\n\t\tfor (int i = 1; true; i++) {\n\t\t\tString fieldLabel = preferences.getValue(\n\t\t\t\t\"fieldLabel\" + i, StringPool.BLANK);\n\n\t\t\tString localizedfieldLabel = LocalizationUtil.getPreferencesValue(\n\t\t\t\tpreferences, \"fieldLabel\" + i, themeDisplay.getLanguageId());\n\n\t\t\tif (Validator.isNull(fieldLabel)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfieldLabels.add(fieldLabel);\n\n\t\t\tsb.append(getCSVFormatedValue(localizedfieldLabel));\n\t\t\tsb.append(PortletPropsValues.CSV_SEPARATOR);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(CharPool.NEW_LINE);\n\n\t\tif (Validator.isNotNull(databaseTableName)) {\n\t\t\tList<ExpandoRow> rows = ExpandoRowLocalServiceUtil.getRows(\n\t\t\t\tthemeDisplay.getCompanyId(), WebFormUtil.class.getName(),\n\t\t\t\tdatabaseTableName, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tfor (ExpandoRow row : rows) {\n\t\t\t\tfor (String fieldName : fieldLabels) {\n\t\t\t\t\tString data = ExpandoValueLocalServiceUtil.getData(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\t\tWebFormUtil.class.getName(), databaseTableName,\n\t\t\t\t\t\tfieldName, row.getClassPK(), StringPool.BLANK);\n\n\t\t\t\t\tsb.append(getCSVFormatedValue(data));\n\t\t\t\t\tsb.append(PortletPropsValues.CSV_SEPARATOR);\n\t\t\t\t}\n\n\t\t\t\tsb.setIndex(sb.index() - 1);\n\n\t\t\t\tsb.append(CharPool.NEW_LINE);\n\t\t\t}\n\t\t}\n\n\t\tString fileName = title + \".csv\";\n\t\tbyte[] bytes = sb.toString().getBytes();\n\t\tString contentType = ContentTypes.APPLICATION_TEXT;\n\n\t\tPortletResponseUtil.sendFile(\n\t\t\tresourceRequest, resourceResponse, fileName, bytes, contentType);\n\t}","commit_id":"4ea479864d8d429ed35666954dff5130de617182","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private static XValueChildrenList getInheritedNodeSingletonList(final XValueChildrenList inheritedStaticFields,\n                                                                  final XValueChildrenList inheritedStaticProperties,\n                                                                  final XValueChildrenList inheritedFields,\n                                                                  final XValueChildrenList inheritedProperties) {\n    final XValue inheritedNode = new XValue() {\n      public void computePresentation(@NotNull final XValueNode node) {\n        node.setPresentation((Icon)null, null, \"\", \"Inherited members\", true);\n      }\n\n      public void computeChildren(@NotNull final XCompositeNode node) {\n        node.addChildren(inheritedStaticFields, false);\n        node.addChildren(inheritedStaticProperties, false);\n        node.addChildren(inheritedFields, false);\n        node.addChildren(inheritedProperties, true);\n      }\n    };\n\n    final XValueChildrenList inheritedSingleNodeList = new XValueChildrenList();\n    inheritedSingleNodeList.add(\"\", inheritedNode);\n    return inheritedSingleNodeList;\n  }","id":106881,"modified_method":"private static XValueChildrenList getWrappingSingletonList(final String nodeName, final XValueChildrenList... listsToWrap) {\n    final XValue inheritedNode = new XValue() {\n      public void computePresentation(@NotNull final XValueNode node) {\n        node.setPresentation((Icon)null, null, \"\", nodeName, true);\n      }\n\n      public void computeChildren(@NotNull final XCompositeNode node) {\n        for (final XValueChildrenList list : listsToWrap) {\n          node.addChildren(list, false);\n        }\n        node.addChildren(XValueChildrenList.EMPTY, true);\n      }\n    };\n\n    final XValueChildrenList inheritedSingleNodeList = new XValueChildrenList();\n    inheritedSingleNodeList.add(\"\", inheritedNode);\n    return inheritedSingleNodeList;\n  }","commit_id":"5876d4e6ac53257b4edfd252dfaece76c7cd3829","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void addChildren(final XCompositeNode node,\n                                  final LinkedHashMap<String, FlexValue> fieldNameToFlexValueMap,\n                                  final @Nullable NodeClassInfo nodeClassInfo) {\n    final List<FlexValue> elementsOfCollection = new LinkedList<FlexValue>();\n    final XValueChildrenList ownStaticFields = new XValueChildrenList();\n    final XValueChildrenList ownStaticProperties = new XValueChildrenList();\n    final XValueChildrenList ownFields = new XValueChildrenList();\n    final XValueChildrenList ownProperties = new XValueChildrenList();\n    final XValueChildrenList inheritedStaticFields = new XValueChildrenList();\n    final XValueChildrenList inheritedStaticProperties = new XValueChildrenList();\n    final XValueChildrenList inheritedFields = new XValueChildrenList();\n    final XValueChildrenList inheritedProperties = new XValueChildrenList();\n\n    for (final Map.Entry<String, FlexValue> entry : fieldNameToFlexValueMap.entrySet()) {\n      final String name = entry.getKey();\n      final FlexValue flexValue = entry.getValue();\n\n      if (isInteger(name)) {\n        elementsOfCollection.add(flexValue);\n        continue;\n      }\n\n      if (nodeClassInfo == null) {\n        ownFields.add(name, flexValue);\n      }\n      else {\n        if (updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnStaticFields, ownStaticFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnStaticProperties, ownStaticProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnFields, ownFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnProperties, ownProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedStaticFields, inheritedStaticFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedStaticProperties, inheritedStaticProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedFields, inheritedFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedProperties, inheritedProperties)) {\n          continue;\n        }\n\n        (nodeClassInfo.isDynamic ? ownFields : inheritedFields).add(name, flexValue);\n      }\n    }\n\n    Collections.sort(elementsOfCollection, ourArrayElementsComparator);\n\n    if (inheritedStaticFields.size() + inheritedStaticProperties.size() + inheritedFields.size() + inheritedProperties.size() > 0) {\n      final XValueChildrenList inheritedNodeSingletonList =\n        getInheritedNodeSingletonList(inheritedStaticFields, inheritedStaticProperties, inheritedFields, inheritedProperties);\n      node.addChildren(inheritedNodeSingletonList, false);\n    }\n\n    node.addChildren(ownStaticFields, false);\n    node.addChildren(ownStaticProperties, false);\n    node.addChildren(ownFields, false);\n    node.addChildren(ownProperties, false);\n\n    final XValueChildrenList elementsOfCollectionList = new XValueChildrenList();\n    for (final FlexValue flexValue : elementsOfCollection) {\n      elementsOfCollectionList.add(flexValue.myName, flexValue);\n    }\n    node.addChildren(elementsOfCollectionList, false);\n\n    node.addChildren(XValueChildrenList.EMPTY, true);\n  }","id":106882,"modified_method":"private static void addChildren(final XCompositeNode node,\n                                  final LinkedHashMap<String, FlexValue> fieldNameToFlexValueMap,\n                                  final @Nullable NodeClassInfo nodeClassInfo) {\n    final List<FlexValue> elementsOfCollection = new LinkedList<FlexValue>();\n    final XValueChildrenList ownStaticFields = new XValueChildrenList();\n    final XValueChildrenList ownStaticProperties = new XValueChildrenList();\n    final XValueChildrenList ownFields = new XValueChildrenList();\n    final XValueChildrenList ownProperties = new XValueChildrenList();\n    final XValueChildrenList inheritedStaticFields = new XValueChildrenList();\n    final XValueChildrenList inheritedStaticProperties = new XValueChildrenList();\n    final XValueChildrenList inheritedFields = new XValueChildrenList();\n    final XValueChildrenList inheritedProperties = new XValueChildrenList();\n\n    for (final Map.Entry<String, FlexValue> entry : fieldNameToFlexValueMap.entrySet()) {\n      final String name = entry.getKey();\n      final FlexValue flexValue = entry.getValue();\n\n      if (isInteger(name)) {\n        elementsOfCollection.add(flexValue);\n        continue;\n      }\n\n      if (nodeClassInfo == null) {\n        ownFields.add(name, flexValue);\n      }\n      else {\n        if (updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnStaticFields, ownStaticFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnStaticProperties, ownStaticProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnFields, ownFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myOwnProperties, ownProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedStaticFields, inheritedStaticFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedStaticProperties, inheritedStaticProperties) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedFields, inheritedFields) ||\n            updateIconAndAddToListIfMatches(name, flexValue, nodeClassInfo.myInheritedProperties, inheritedProperties)) {\n          continue;\n        }\n\n        (nodeClassInfo.myIsDynamic ? ownFields : inheritedFields).add(name, flexValue);\n      }\n    }\n\n    Collections.sort(elementsOfCollection, ourArrayElementsComparator);\n\n    XValueChildrenList inheritedNodeSingletonList = XValueChildrenList.EMPTY;\n    if (inheritedStaticFields.size() + inheritedStaticProperties.size() + inheritedFields.size() + inheritedProperties.size() > 0) {\n      inheritedNodeSingletonList = getWrappingSingletonList(\"Inherited members\", inheritedStaticFields, inheritedStaticProperties,\n                                                            inheritedFields, inheritedProperties);\n    }\n\n    if (nodeClassInfo != null && isCollectionWithDirectContent(nodeClassInfo.myFqn)) {\n      final XValueChildrenList fieldsAndPropertiesSingletonList =\n        getWrappingSingletonList(\"Fields and properties\", inheritedNodeSingletonList, ownStaticFields, ownStaticProperties, ownFields,\n                                 ownProperties);\n      node.addChildren(fieldsAndPropertiesSingletonList, false);\n    }\n    else {\n      node.addChildren(inheritedNodeSingletonList, false);\n      node.addChildren(ownStaticFields, false);\n      node.addChildren(ownStaticProperties, false);\n      node.addChildren(ownFields, false);\n      node.addChildren(ownProperties, false);\n    }\n\n    final XValueChildrenList elementsOfCollectionList = new XValueChildrenList();\n    for (final FlexValue flexValue : elementsOfCollection) {\n      elementsOfCollectionList.add(flexValue.myName, flexValue);\n    }\n    node.addChildren(elementsOfCollectionList, false);\n\n    node.addChildren(XValueChildrenList.EMPTY, true);\n  }","commit_id":"5876d4e6ac53257b4edfd252dfaece76c7cd3829","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public NodeClassInfo(final boolean dynamic,\n                       final Map<String, Icon> ownStaticFields,\n                       final Map<String, Icon> ownStaticProperties,\n                       final Map<String, Icon> ownFields,\n                       final Map<String, Icon> ownProperties,\n                       final Map<String, Icon> inheritedStaticFields,\n                       final Map<String, Icon> inheritedStaticProperties,\n                       final Map<String, Icon> inheritedFields,\n                       final Map<String, Icon> inheritedProperties) {\n    isDynamic = dynamic;\n    this.myOwnStaticFields = ownStaticFields;\n    this.myOwnStaticProperties = ownStaticProperties;\n    this.myOwnFields = ownFields;\n    this.myOwnProperties = ownProperties;\n    this.myInheritedStaticFields = inheritedStaticFields;\n    this.myInheritedStaticProperties = inheritedStaticProperties;\n    this.myInheritedFields = inheritedFields;\n    this.myInheritedProperties = inheritedProperties;\n  }","id":106883,"modified_method":"public NodeClassInfo(final String fqn,\n                       final boolean dynamic,\n                       final Map<String, Icon> ownStaticFields,\n                       final Map<String, Icon> ownStaticProperties,\n                       final Map<String, Icon> ownFields,\n                       final Map<String, Icon> ownProperties,\n                       final Map<String, Icon> inheritedStaticFields,\n                       final Map<String, Icon> inheritedStaticProperties,\n                       final Map<String, Icon> inheritedFields,\n                       final Map<String, Icon> inheritedProperties) {\n    myFqn = fqn;\n    myIsDynamic = dynamic;\n    myOwnStaticFields = ownStaticFields;\n    myOwnStaticProperties = ownStaticProperties;\n    myOwnFields = ownFields;\n    myOwnProperties = ownProperties;\n    myInheritedStaticFields = inheritedStaticFields;\n    myInheritedStaticProperties = inheritedStaticProperties;\n    myInheritedFields = inheritedFields;\n    myInheritedProperties = inheritedProperties;\n  }","commit_id":"5876d4e6ac53257b4edfd252dfaece76c7cd3829","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"static NodeClassInfo getNodeClassInfo(final @NotNull JSClass jsClass) {\n    final JSAttributeList classAttributes = jsClass.getAttributeList();\n    final boolean dynamic = classAttributes != null && classAttributes.hasModifier(JSAttributeList.ModifierType.DYNAMIC);\n\n    final Map<String, Icon> ownStaticFields = new THashMap<String, Icon>();\n    final Map<String, Icon> ownStaticProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> ownFields = new THashMap<String, Icon>();\n    final Map<String, Icon> ownProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedStaticFields = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedStaticProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedFields = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedProperties = new THashMap<String, Icon>();\n\n    fillMapsForClass(jsClass, ownStaticFields, ownStaticProperties, ownFields, ownProperties);\n    fillMapsForSupersRecursively(jsClass, new THashSet<JSClass>(), inheritedStaticFields, inheritedStaticProperties, inheritedFields,\n                                 inheritedProperties);\n\n    return new NodeClassInfo(dynamic, ownStaticFields, ownStaticProperties, ownFields, ownProperties, inheritedStaticFields,\n                             inheritedStaticProperties, inheritedFields, inheritedProperties);\n  }","id":106884,"modified_method":"static NodeClassInfo getNodeClassInfo(final @NotNull JSClass jsClass) {\n    final JSAttributeList classAttributes = jsClass.getAttributeList();\n    final boolean dynamic = classAttributes != null && classAttributes.hasModifier(JSAttributeList.ModifierType.DYNAMIC);\n\n    final Map<String, Icon> ownStaticFields = new THashMap<String, Icon>();\n    final Map<String, Icon> ownStaticProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> ownFields = new THashMap<String, Icon>();\n    final Map<String, Icon> ownProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedStaticFields = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedStaticProperties = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedFields = new THashMap<String, Icon>();\n    final Map<String, Icon> inheritedProperties = new THashMap<String, Icon>();\n\n    fillMapsForClass(jsClass, ownStaticFields, ownStaticProperties, ownFields, ownProperties);\n    fillMapsForSupersRecursively(jsClass, new THashSet<JSClass>(), inheritedStaticFields, inheritedStaticProperties, inheritedFields,\n                                 inheritedProperties);\n\n    return new NodeClassInfo(normalizeIfVector(jsClass.getQualifiedName()), dynamic, ownStaticFields, ownStaticProperties, ownFields,\n                             ownProperties, inheritedStaticFields, inheritedStaticProperties, inheritedFields, inheritedProperties);\n  }","commit_id":"5876d4e6ac53257b4edfd252dfaece76c7cd3829","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected Menu getAddEntryPortletTitleMenu(PortletRequest portletRequest) {\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(getPortletTitleMenuItems(portletRequest));\n\t\tmenu.setShowArrow(false);\n\n\t\treturn menu;\n\t}","id":106885,"modified_method":"protected Menu getAddEntryPortletTitleMenu(PortletRequest portletRequest) {\n\t\tList<MenuItem> portletTitleMenuItems = getPortletTitleMenuItems(\n\t\t\tportletRequest);\n\n\t\tif (ListUtil.isEmpty(portletTitleMenuItems)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(portletTitleMenuItems);\n\t\tmenu.setShowArrow(false);\n\n\t\treturn menu;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tmenus.add(getAddEntryPortletTitleMenu(portletRequest));\n\n\t\treturn menus;\n\t}","id":106886,"modified_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tMenu addEntryPortletTitleMenu = getAddEntryPortletTitleMenu(\n\t\t\tportletRequest);\n\n\t\tif (addEntryPortletTitleMenu == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tmenus.add(addEntryPortletTitleMenu);\n\n\t\treturn menus;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(getPortletTitleMenuItems(portletRequest));\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","id":106887,"modified_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<MenuItem> portletTitleMenuItems = getPortletTitleMenuItems(\n\t\t\tportletRequest);\n\n\t\tif (ListUtil.isEmpty(portletTitleMenuItems)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(portletTitleMenuItems);\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(getPortletTitleMenuItems(portletRequest));\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","id":106888,"modified_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<MenuItem> portletTitleMenuItems = getPortletTitleMenuItems(\n\t\t\tportletRequest);\n\n\t\tif (ListUtil.isEmpty(portletTitleMenuItems)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(portletTitleMenuItems);\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(getPortletTitleMenuItems(portletRequest));\n\t\tmenu.setShowArrow(false);\n\t\tmenu.setShowWhenSingleIcon(true);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","id":106889,"modified_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<MenuItem> portletTitleMenuItems = getPortletTitleMenuItems(\n\t\t\tportletRequest);\n\n\t\tif (ListUtil.isEmpty(portletTitleMenuItems)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(portletTitleMenuItems);\n\t\tmenu.setShowArrow(false);\n\t\tmenu.setShowWhenSingleIcon(true);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(getPortletTitleMenuItems(portletRequest));\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","id":106890,"modified_method":"@Override\n\tpublic List<Menu> getPortletTitleMenus(PortletRequest portletRequest) {\n\t\tList<MenuItem> portletTitleMenuItems = getPortletTitleMenuItems(\n\t\t\tportletRequest);\n\n\t\tif (ListUtil.isEmpty(portletTitleMenuItems)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Menu> menus = new ArrayList<>();\n\n\t\tMenu menu = new Menu();\n\n\t\tmenu.setDirection(\"down\");\n\t\tmenu.setExtended(false);\n\t\tmenu.setIcon(\"../aui/plus-sign-2\");\n\t\tmenu.setMenuItems(portletTitleMenuItems);\n\t\tmenu.setShowArrow(false);\n\n\t\tmenus.add(menu);\n\n\t\treturn menus;\n\t}","commit_id":"e5e7a5e2a22b6782f394e5262383a650bdf71708","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     *\n     * @param desc the descriptor of the sstable table to read from\n     * @param outs PrintStream to write the output to\n     * @param toExport the keys corresponding to the rows to export\n     * @param excludes keys to exclude from export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(Descriptor desc, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(desc);\n        SSTableScanner scanner = reader.getDirectScanner();\n\n        IPartitioner<?> partitioner = reader.partitioner;\n\n        if (excludes != null)\n            toExport.removeAll(Arrays.asList(excludes));\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // last key to compare order\n        DecoratedKey lastKey = null;\n\n        for (String key : toExport)\n        {\n            DecoratedKey decoratedKey = partitioner.decorateKey(hexToBytes(key));\n\n            if (lastKey != null && lastKey.compareTo(decoratedKey) > 0)\n                throw new IOException(\"Key out of order! \" + lastKey + \" > \" + decoratedKey);\n\n            lastKey = decoratedKey;\n\n            scanner.seekTo(decoratedKey);\n\n            if (!scanner.hasNext())\n                continue;\n\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (!row.getKey().equals(decoratedKey))\n                continue;\n\n            serializeRow(row, decoratedKey, outs);\n\n            if (i != 0)\n                outs.println(\",\");\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","id":106891,"modified_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     *\n     * @param desc the descriptor of the sstable table to read from\n     * @param outs PrintStream to write the output to\n     * @param toExport the keys corresponding to the rows to export\n     * @param excludes keys to exclude from export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(Descriptor desc, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(desc);\n        SSTableScanner scanner = reader.getDirectScanner();\n\n        IPartitioner<?> partitioner = reader.partitioner;\n\n        if (excludes != null)\n            toExport.removeAll(Arrays.asList(excludes));\n\n        outs.println(\"[\");\n\n        int i = 0;\n\n        // last key to compare order\n        DecoratedKey lastKey = null;\n\n        for (String key : toExport)\n        {\n            DecoratedKey decoratedKey = partitioner.decorateKey(hexToBytes(key));\n\n            if (lastKey != null && lastKey.compareTo(decoratedKey) > 0)\n                throw new IOException(\"Key out of order! \" + lastKey + \" > \" + decoratedKey);\n\n            lastKey = decoratedKey;\n\n            scanner.seekTo(decoratedKey);\n\n            if (!scanner.hasNext())\n                continue;\n\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (!row.getKey().equals(decoratedKey))\n                continue;\n\n            serializeRow(row, decoratedKey, outs);\n\n            if (i != 0)\n                outs.println(\",\");\n\n            i++;\n        }\n\n        outs.println(\"\\n]\");\n        outs.flush();\n\n        scanner.close();\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Get portion of the columns and serialize in loop while not more columns left in the row\n     * @param row SSTableIdentityIterator row representation with Column Family\n     * @param key Decorated Key for the required row\n     * @param out output stream\n     */\n    private static void serializeRow(SSTableIdentityIterator row, DecoratedKey key, PrintStream out)\n    {\n        ColumnFamily columnFamily = row.getColumnFamily();\n        boolean isSuperCF = columnFamily.isSuper();\n        CFMetaData cfMetaData = columnFamily.metadata();\n        AbstractType<?> comparator = columnFamily.getComparator();\n\n        writeKey(out, bytesToHex(key.key));\n        out.print(isSuperCF ? \"{\" : \"[\");\n\n        if (isSuperCF)\n        {\n            while (row.hasNext())\n            {\n                OnDiskAtom scol = row.next();\n                assert scol instanceof IColumn;\n                IColumn column = (IColumn)scol;\n                writeKey(out, comparator.getString(column.name()));\n                out.print(\"{\");\n                writeKey(out, \"deletedAt\");\n                out.print(column.getMarkedForDeleteAt());\n                out.print(\", \");\n                writeKey(out, \"subColumns\");\n                out.print(\"[\");\n                serializeIColumns(column.getSubColumns().iterator(), out, columnFamily.getSubComparator(), cfMetaData);\n                out.print(\"]\");\n                out.print(\"}\");\n\n                if (row.hasNext())\n                    out.print(\", \");\n            }\n        }\n        else\n        {\n            serializeColumns(row, out, comparator, cfMetaData);\n        }\n\n        out.print(isSuperCF ? \"}\" : \"]\");\n\n    }","id":106892,"modified_method":"/**\n     * Get portion of the columns and serialize in loop while not more columns left in the row\n     * @param row SSTableIdentityIterator row representation with Column Family\n     * @param key Decorated Key for the required row\n     * @param out output stream\n     */\n    private static void serializeRow(SSTableIdentityIterator row, DecoratedKey key, PrintStream out)\n    {\n        ColumnFamily columnFamily = row.getColumnFamily();\n        boolean isSuperCF = columnFamily.isSuper();\n        CFMetaData cfMetaData = columnFamily.metadata();\n        AbstractType<?> comparator = columnFamily.getComparator();\n\n        out.print(\"{\");\n        writeKey(out, \"key\");\n        writeJSON(out, bytesToHex(key.key));\n        out.print(\",\");\n\n        writeMeta(out, columnFamily);\n\n        writeKey(out, \"columns\");\n        out.print(isSuperCF ? \"{\" : \"[\");\n\n        if (isSuperCF)\n        {\n            while (row.hasNext())\n            {\n                SuperColumn scol = (SuperColumn)row.next();\n                assert scol instanceof IColumn;\n                IColumn column = (IColumn)scol;\n                writeKey(out, comparator.getString(column.name()));\n                out.print(\"{\");\n                writeMeta(out, scol);\n                writeKey(out, \"subColumns\");\n                out.print(\"[\");\n                serializeIColumns(column.getSubColumns().iterator(), out, columnFamily.getSubComparator(), cfMetaData);\n                out.print(\"]\");\n                out.print(\"}\");\n\n                if (row.hasNext())\n                    out.print(\", \");\n            }\n        }\n        else\n        {\n            serializeColumns(row, out, comparator, cfMetaData);\n        }\n\n        out.print(isSuperCF ? \"}\" : \"]\");\n        out.print(\"}\");\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n\n        SSTableIdentityIterator row;\n        SSTableScanner scanner = reader.getDirectScanner();\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // collecting keys to export\n        while (scanner.hasNext())\n        {\n            row = (SSTableIdentityIterator) scanner.next();\n\n            String currentKey = bytesToHex(row.getKey().key);\n\n            if (excludeSet.contains(currentKey))\n                continue;\n            else if (i != 0)\n                outs.println(\",\");\n\n            serializeRow(row, row.getKey(), outs);\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","id":106893,"modified_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n\n        SSTableIdentityIterator row;\n        SSTableScanner scanner = reader.getDirectScanner();\n\n        outs.println(\"[\");\n\n        int i = 0;\n\n        // collecting keys to export\n        while (scanner.hasNext())\n        {\n            row = (SSTableIdentityIterator) scanner.next();\n\n            String currentKey = bytesToHex(row.getKey().key);\n\n            if (excludeSet.contains(currentKey))\n                continue;\n            else if (i != 0)\n                outs.println(\",\");\n\n            serializeRow(row, row.getKey(), outs);\n\n            i++;\n        }\n\n        outs.println(\"\\n]\");\n        outs.flush();\n\n        scanner.close();\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testExportSimpleCf() throws IOException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        int nowInSec = (int)(System.currentTimeMillis() / 1000) + 42; //live for 42 seconds\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colA\")), ByteBufferUtil.bytes(\"valA\"), System.currentTimeMillis());\n        cfamily.addColumn(null, new ExpiringColumn(ByteBufferUtil.bytes(\"colExp\"), ByteBufferUtil.bytes(\"valExp\"), System.currentTimeMillis(), 42, nowInSec));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowB\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colB\")), ByteBufferUtil.bytes(\"valB\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowB\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colX\")), ByteBufferUtil.bytes(\"valX\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Standard1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex(\"rowExclude\")});\n\n        JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));\n\n        JSONArray rowA = (JSONArray)json.get(asHex(\"rowA\"));\n        JSONArray colA = (JSONArray)rowA.get(0);\n        assert hexToBytes((String)colA.get(1)).equals(ByteBufferUtil.bytes(\"valA\"));\n\n        JSONArray colExp = (JSONArray)rowA.get(1);\n        assert ((Long)colExp.get(4)) == 42;\n        assert ((Long)colExp.get(5)) == nowInSec;\n\n        JSONArray rowB = (JSONArray)json.get(asHex(\"rowB\"));\n        JSONArray colB = (JSONArray)rowB.get(0);\n        assert colB.size() == 3;\n\n        JSONArray rowExclude = (JSONArray)json.get(asHex(\"rowExclude\"));\n        assert rowExclude == null;\n    }","id":106894,"modified_method":"@Test\n    public void testExportSimpleCf() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        int nowInSec = (int)(System.currentTimeMillis() / 1000) + 42; //live for 42 seconds\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colA\")), ByteBufferUtil.bytes(\"valA\"), System.currentTimeMillis());\n        cfamily.addColumn(null, new ExpiringColumn(ByteBufferUtil.bytes(\"colExp\"), ByteBufferUtil.bytes(\"valExp\"), System.currentTimeMillis(), 42, nowInSec));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowB\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colB\")), ByteBufferUtil.bytes(\"valB\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowB\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"colX\")), ByteBufferUtil.bytes(\"valX\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Standard1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex(\"rowExclude\")});\n\n        JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));\n        assertEquals(\"unexpected number of rows\", 2, json.size());\n\n        JSONObject rowA = (JSONObject)json.get(0);\n        assertEquals(\"unexpected number of keys\", 2, rowA.keySet().size());\n        assertEquals(\"unexpected row key\",asHex(\"rowA\"),rowA.get(\"key\"));\n\n        JSONArray colsA = (JSONArray)rowA.get(\"columns\");\n        JSONArray colA = (JSONArray)colsA.get(0);\n        assert hexToBytes((String)colA.get(1)).equals(ByteBufferUtil.bytes(\"valA\"));\n\n        JSONArray colExp = (JSONArray)colsA.get(1);\n        assert ((Long)colExp.get(4)) == 42;\n        assert ((Long)colExp.get(5)) == nowInSec;\n\n        JSONObject rowB = (JSONObject)json.get(1);\n        assertEquals(\"unexpected number of keys\", 2, rowB.keySet().size());\n        assertEquals(\"unexpected row key\",asHex(\"rowB\"),rowB.get(\"key\"));\n\n        JSONArray colsB = (JSONArray)rowB.get(\"columns\");\n        JSONArray colB = (JSONArray)colsB.get(0);\n        assert colB.size() == 3;\n\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testExportSuperCf() throws IOException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Super4\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Super4\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superA\"), ByteBufferUtil.bytes(\"colA\")), ByteBufferUtil.bytes(\"valA\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowB\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superB\"), ByteBufferUtil.bytes(\"colB\")), ByteBufferUtil.bytes(\"valB\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowB\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superX\"), ByteBufferUtil.bytes(\"colX\")), ByteBufferUtil.bytes(\"valX\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Super4\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex(\"rowExclude\")});\n\n        JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));\n\n        JSONObject rowA = (JSONObject)json.get(asHex(\"rowA\"));\n        JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString(ByteBufferUtil.bytes(\"superA\")));\n        JSONArray subColumns = (JSONArray)superA.get(\"subColumns\");\n        JSONArray colA = (JSONArray)subColumns.get(0);\n        JSONObject rowExclude = (JSONObject)json.get(asHex(\"rowExclude\"));\n        assert hexToBytes((String)colA.get(1)).equals(ByteBufferUtil.bytes(\"valA\"));\n        assert colA.size() == 3;\n        assert rowExclude == null;\n    }","id":106895,"modified_method":"@Test\n    public void testExportSuperCf() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Super4\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Super4\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superA\"), ByteBufferUtil.bytes(\"colA\")), ByteBufferUtil.bytes(\"valA\"), System.currentTimeMillis());\n        // set deletion info on the super col\n        ((SuperColumn) cfamily.getColumn(ByteBufferUtil.bytes(\"superA\"))).setDeletionInfo(new DeletionInfo(0, 0));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowB\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superB\"), ByteBufferUtil.bytes(\"colB\")), ByteBufferUtil.bytes(\"valB\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowB\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Super4\", ByteBufferUtil.bytes(\"superX\"), ByteBufferUtil.bytes(\"colX\")), ByteBufferUtil.bytes(\"valX\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Super4\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[] { asHex(\"rowExclude\") });\n\n        JSONArray json = (JSONArray) JSONValue.parseWithException(new FileReader(tempJson));\n        assertEquals(\"unexpected number of rows\", 2, json.size());\n\n        // make sure only the two rows we expect are there\n        JSONObject rowA = (JSONObject) json.get(0);\n        assertEquals(\"unexpected number of keys\", 2, rowA.keySet().size());\n        assertEquals(\"unexpected row key\", asHex(\"rowA\"), rowA.get(\"key\"));\n        JSONObject rowB = (JSONObject) json.get(0);\n        assertEquals(\"unexpected number of keys\", 2, rowB.keySet().size());\n        assertEquals(\"unexpected row key\", asHex(\"rowA\"), rowB.get(\"key\"));\n\n        JSONObject cols = (JSONObject) rowA.get(\"columns\");\n\n        JSONObject superA = (JSONObject) cols.get(cfamily.getComparator().getString(ByteBufferUtil.bytes(\"superA\")));\n        JSONArray subColumns = (JSONArray) superA.get(\"subColumns\");\n        JSONArray colA = (JSONArray) subColumns.get(0);\n        assert hexToBytes((String) colA.get(1)).equals(ByteBufferUtil.bytes(\"valA\"));\n        assert colA.size() == 3;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRoundTripStandardCf() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"name\")), ByteBufferUtil.bytes(\"val\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"name\")), ByteBufferUtil.bytes(\"val\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Standard1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex(\"rowExclude\")});\n\n        // Import JSON to another SSTable file\n        File tempSS2 = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        SSTableImport.importJson(tempJson.getPath(), \"Keyspace1\", \"Standard1\", tempSS2.getPath());\n\n        reader = SSTableReader.open(Descriptor.fromFilename(tempSS2.getPath()));\n        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\", null, null), ByteBufferUtil.bytes(\"name\"));\n        ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);\n        assertTrue(cf != null);\n        assertTrue(cf.getColumn(ByteBufferUtil.bytes(\"name\")).value().equals(hexToBytes(\"76616c\")));\n\n        qf = QueryFilter.getNamesFilter(Util.dk(\"rowExclude\"), new QueryPath(\"Standard1\", null, null), ByteBufferUtil.bytes(\"name\"));\n        cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        assert cf == null;\n    }","id":106896,"modified_method":"@Test\n    public void testRoundTripStandardCf() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Standard1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"name\")), ByteBufferUtil.bytes(\"val\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        // Add rowExclude\n        cfamily.addColumn(new QueryPath(\"Standard1\", null, ByteBufferUtil.bytes(\"name\")), ByteBufferUtil.bytes(\"val\"), System.currentTimeMillis());\n        writer.append(Util.dk(\"rowExclude\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Standard1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[]{asHex(\"rowExclude\")});\n\n        // Import JSON to another SSTable file\n        File tempSS2 = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        new SSTableImport().importJson(tempJson.getPath(), \"Keyspace1\", \"Standard1\", tempSS2.getPath());\n\n        reader = SSTableReader.open(Descriptor.fromFilename(tempSS2.getPath()));\n        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\", null, null), ByteBufferUtil.bytes(\"name\"));\n        ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);\n        assertTrue(cf != null);\n        assertTrue(cf.getColumn(ByteBufferUtil.bytes(\"name\")).value().equals(hexToBytes(\"76616c\")));\n\n        qf = QueryFilter.getNamesFilter(Util.dk(\"rowExclude\"), new QueryPath(\"Standard1\", null, null), ByteBufferUtil.bytes(\"name\"));\n        cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        assert cf == null;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testExportCounterCf() throws IOException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Counter1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Counter1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(null, new CounterColumn(ByteBufferUtil.bytes(\"colA\"), 42, System.currentTimeMillis()));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Counter1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);\n\n        JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));\n\n        JSONArray rowA = (JSONArray)json.get(asHex(\"rowA\"));\n        JSONArray colA = (JSONArray)rowA.get(0);\n        assert hexToBytes((String)colA.get(0)).equals(ByteBufferUtil.bytes(\"colA\"));\n        assert ((String) colA.get(3)).equals(\"c\");\n        assert (Long) colA.get(4) == Long.MIN_VALUE;\n    }","id":106897,"modified_method":"@Test\n    public void testExportCounterCf() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Counter1\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"Counter1\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(null, new CounterColumn(ByteBufferUtil.bytes(\"colA\"), 42, System.currentTimeMillis()));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"Counter1\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);\n        JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));\n        assertEquals(\"unexpected number of rows\", 1, json.size());\n\n        JSONObject row = (JSONObject)json.get(0);\n        assertEquals(\"unexpected number of keys\", 2, row.keySet().size());\n        assertEquals(\"unexpected row key\",asHex(\"rowA\"),row.get(\"key\"));\n\n        JSONArray cols = (JSONArray)row.get(\"columns\");\n        JSONArray colA = (JSONArray)cols.get(0);\n        assert hexToBytes((String)colA.get(0)).equals(ByteBufferUtil.bytes(\"colA\"));\n        assert ((String) colA.get(3)).equals(\"c\");\n        assert (Long) colA.get(4) == Long.MIN_VALUE;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testEscapingDoubleQuotes() throws IOException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"ValuesWithQuotes\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"ValuesWithQuotes\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(null, new Column(ByteBufferUtil.bytes(\"data\"), UTF8Type.instance.fromString(\"{\\\"foo\\\":\\\"bar\\\"}\")));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"ValuesWithQuotes\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);\n\n        JSONObject json = (JSONObject) JSONValue.parse(new FileReader(tempJson));\n\n        JSONArray rowA = (JSONArray)json.get(asHex(\"rowA\"));\n        JSONArray data = (JSONArray)rowA.get(0);\n        assert hexToBytes((String)data.get(0)).equals(ByteBufferUtil.bytes(\"data\"));\n        assert data.get(1).equals(\"{\\\"foo\\\":\\\"bar\\\"}\");\n    }","id":106898,"modified_method":"@Test\n    public void testEscapingDoubleQuotes() throws IOException, ParseException\n    {\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"ValuesWithQuotes\");\n        ColumnFamily cfamily = ColumnFamily.create(\"Keyspace1\", \"ValuesWithQuotes\");\n        SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);\n\n        // Add rowA\n        cfamily.addColumn(null, new Column(ByteBufferUtil.bytes(\"data\"), UTF8Type.instance.fromString(\"{\\\"foo\\\":\\\"bar\\\"}\")));\n        writer.append(Util.dk(\"rowA\"), cfamily);\n        cfamily.clear();\n\n        SSTableReader reader = writer.closeAndOpenReader();\n\n        // Export to JSON and verify\n        File tempJson = File.createTempFile(\"ValuesWithQuotes\", \".json\");\n        SSTableExport.export(reader, new PrintStream(tempJson.getPath()), new String[0]);\n\n        JSONArray json = (JSONArray)JSONValue.parseWithException(new FileReader(tempJson));\n        assertEquals(\"unexpected number of rows\", 1, json.size());\n\n        JSONObject row = (JSONObject)json.get(0);\n        assertEquals(\"unexpected number of keys\", 2, row.keySet().size());\n        assertEquals(\"unexpected row key\",asHex(\"rowA\"),row.get(\"key\"));\n\n        JSONArray cols = (JSONArray)row.get(\"columns\");\n        JSONArray colA = (JSONArray)cols.get(0);\n        assert hexToBytes((String)colA.get(0)).equals(ByteBufferUtil.bytes(\"data\"));\n        assert colA.get(1).equals(\"{\\\"foo\\\":\\\"bar\\\"}\");\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Get JsonParser object for file\n     * @param fileName name of the file\n     * @return json parser instance for given file\n     * @throws IOException if any I/O error.\n     */\n    private static JsonParser getParser(String fileName) throws IOException\n    {\n        return factory.createJsonParser(new File(fileName));\n    }","id":106899,"modified_method":"/**\n     * Get JsonParser object for file\n     * @param fileName name of the file\n     * @return json parser instance for given file\n     * @throws IOException if any I/O error.\n     */\n    private JsonParser getParser(String fileName) throws IOException\n    {\n        return factory.createJsonParser(new File(fileName));\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Converts JSON to an SSTable file. JSON input can either be a file specified\n     * using an optional command line argument, or supplied on standard in.\n     *\n     * @param args command line arguments\n     * @throws IOException on failure to open/read/write files or output streams\n     * @throws ParseException on failure to parse JSON input\n     * @throws ConfigurationException on configuration error.\n     */\n    public static void main(String[] args) throws IOException, ParseException, ConfigurationException\n    {\n        CommandLineParser parser = new PosixParser();\n\n        try\n        {\n            cmd = parser.parse(options, args);\n        }\n        catch (org.apache.commons.cli.ParseException e)\n        {\n            System.err.println(e.getMessage());\n            printProgramUsage();\n            System.exit(1);\n        }\n\n        if (cmd.getArgs().length != 2)\n        {\n            printProgramUsage();\n            System.exit(1);\n        }\n\n        String json     = cmd.getArgs()[0];\n        String ssTable  = cmd.getArgs()[1];\n        String keyspace = cmd.getOptionValue(KEYSPACE_OPTION);\n        String cfamily  = cmd.getOptionValue(COLUMN_FAMILY_OPTION);\n\n        if (cmd.hasOption(KEY_COUNT_OPTION))\n        {\n            keyCountToImport = Integer.valueOf(cmd.getOptionValue(KEY_COUNT_OPTION));\n        }\n\n        if (cmd.hasOption(IS_SORTED_OPTION))\n        {\n            isSorted = true;\n        }\n\n        DatabaseDescriptor.loadSchemas();\n        if (Schema.instance.getNonSystemTables().size() < 1)\n        {\n            String msg = \"no non-system tables are defined\";\n            System.err.println(msg);\n            throw new ConfigurationException(msg);\n        }\n\n        try\n        {\n            importJson(json, keyspace, cfamily, ssTable);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.err.println(\"ERROR: \" + e.getMessage());\n            System.exit(-1);\n        }\n\n        System.exit(0);\n    }","id":106900,"modified_method":"/**\n     * Converts JSON to an SSTable file. JSON input can either be a file specified\n     * using an optional command line argument, or supplied on standard in.\n     *\n     * @param args command line arguments\n     * @throws IOException on failure to open/read/write files or output streams\n     * @throws ParseException on failure to parse JSON input\n     * @throws ConfigurationException on configuration error.\n     */\n    public static void main(String[] args) throws IOException, ParseException, ConfigurationException\n    {\n        CommandLineParser parser = new PosixParser();\n\n        try\n        {\n            cmd = parser.parse(options, args);\n        }\n        catch (org.apache.commons.cli.ParseException e)\n        {\n            System.err.println(e.getMessage());\n            printProgramUsage();\n            System.exit(1);\n        }\n\n        if (cmd.getArgs().length != 2)\n        {\n            printProgramUsage();\n            System.exit(1);\n        }\n\n        String json     = cmd.getArgs()[0];\n        String ssTable  = cmd.getArgs()[1];\n        String keyspace = cmd.getOptionValue(KEYSPACE_OPTION);\n        String cfamily  = cmd.getOptionValue(COLUMN_FAMILY_OPTION);\n\n        Integer keyCountToImport = null;\n        boolean isSorted = false;\n\n        if (cmd.hasOption(KEY_COUNT_OPTION))\n        {\n            keyCountToImport = Integer.valueOf(cmd.getOptionValue(KEY_COUNT_OPTION));\n        }\n\n        if (cmd.hasOption(IS_SORTED_OPTION))\n        {\n            isSorted = true;\n        }\n\n        DatabaseDescriptor.loadSchemas();\n        if (Schema.instance.getNonSystemTables().size() < 1)\n        {\n            String msg = \"no non-system tables are defined\";\n            System.err.println(msg);\n            throw new ConfigurationException(msg);\n        }\n\n        try\n        {\n           new SSTableImport(keyCountToImport,isSorted).importJson(json, keyspace, cfamily, ssTable);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.err.println(\"ERROR: \" + e.getMessage());\n            System.exit(-1);\n        }\n\n        System.exit(0);\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"public static int importSorted(String jsonFile, ColumnFamily columnFamily, String ssTablePath, IPartitioner<?> partitioner) throws IOException\n    {\n        int importedKeys = 0; // already imported keys count\n        long start = System.currentTimeMillis();\n\n        JsonParser parser = getParser(jsonFile);\n\n        if (keyCountToImport == null)\n        {\n            keyCountToImport = 0;\n            System.out.println(\"Counting keys to import, please wait... (NOTE: to skip this use -n <num_keys>)\");\n\n            parser.nextToken(); // START_OBJECT\n            while (parser.nextToken() != null)\n            {\n                parser.nextToken();\n                parser.skipChildren();\n                if (parser.getCurrentName() == null) continue;\n\n                keyCountToImport++;\n            }\n        }\n\n        System.out.printf(\"Importing %s keys...%n\", keyCountToImport);\n\n        parser = getParser(jsonFile); // renewing parser\n        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);\n\n        int lineNumber = 1;\n        DecoratedKey prevStoredKey = null;\n\n        while (parser.nextToken() != null)\n        {\n            String key = parser.getCurrentName();\n\n            if (key != null)\n            {\n                String tokenName = parser.nextToken().name();\n\n                if (tokenName.equals(\"START_ARRAY\"))\n                {\n                    if (columnFamily.getType() == ColumnFamilyType.Super)\n                    {\n                        throw new RuntimeException(\"Can't write Standard columns to the Super Column Family.\");\n                    }\n\n                    List<?> columns = parser.readValueAs(new TypeReference<List<?>>() {});\n                    addToStandardCF(columns, columnFamily);\n                }\n                else if (tokenName.equals(\"START_OBJECT\"))\n                {\n                    if (columnFamily.getType() == ColumnFamilyType.Standard)\n                    {\n                        throw new RuntimeException(\"Can't write Super columns to the Standard Column Family.\");\n                    }\n\n                    Map<?, ?> columns = parser.readValueAs(new TypeReference<Map<?, ?>>() {});\n                    addToSuperCF(columns, columnFamily);\n                }\n                else\n                {\n                    throw new UnsupportedOperationException(\"Only Array or Hash allowed as row content.\");\n                }\n\n                DecoratedKey currentKey = partitioner.decorateKey(hexToBytes(key));\n\n                if (prevStoredKey != null && prevStoredKey.compareTo(currentKey) != -1)\n                {\n                    System.err.printf(\"Line %d: Key %s is greater than previous, collection is not sorted properly. Aborting import. You might need to delete SSTables manually.%n\", lineNumber, key);\n                    return -1;\n                }\n\n                // saving decorated key\n                writer.append(currentKey, columnFamily);\n                columnFamily.clear();\n\n                prevStoredKey = currentKey;\n                importedKeys++;\n                lineNumber++;\n\n                long current = System.currentTimeMillis();\n\n                if (current - start >= 5000) // 5 secs.\n                {\n                    System.out.printf(\"Currently imported %d keys.%n\", importedKeys);\n                    start = current;\n                }\n\n                if (keyCountToImport == importedKeys)\n                    break;\n            }\n        }\n\n        writer.closeAndOpenReader();\n\n        return importedKeys;\n    }","id":106901,"modified_method":"private int importSorted(String jsonFile, ColumnFamily columnFamily, String ssTablePath,\n            IPartitioner<?> partitioner) throws IOException\n    {\n        int importedKeys = 0; // already imported keys count\n        long start = System.currentTimeMillis();\n\n        JsonParser parser = getParser(jsonFile);\n\n        if (keyCountToImport == null)\n        {\n            keyCountToImport = 0;\n            System.out.println(\"Counting keys to import, please wait... (NOTE: to skip this use -n <num_keys>)\");\n\n            parser.nextToken(); // START_ARRAY\n            while (parser.nextToken() != null)\n            {\n                parser.skipChildren();\n                if (parser.getCurrentToken() == JsonToken.END_ARRAY)\n                    break;\n\n                keyCountToImport++;\n            }\n        }\n\n        System.out.printf(\"Importing %s keys...%n\", keyCountToImport);\n\n        parser = getParser(jsonFile); // renewing parser\n        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);\n\n        int lineNumber = 1;\n        DecoratedKey prevStoredKey = null;\n\n        parser.nextToken(); // START_ARRAY\n        while (parser.nextToken() != null)\n        {\n            String key = parser.getCurrentName();\n            Map<?, ?> row = parser.readValueAs(new TypeReference<Map<?, ?>>(){});\n            DecoratedKey currentKey = partitioner.decorateKey(hexToBytes((String) row.get(\"key\")));\n\n            if (row.containsKey(\"metadata\"))\n                parseMeta((Map<?, ?>) row.get(\"metadata\"), columnFamily);\n\n\n            if (columnFamily.getType() == ColumnFamilyType.Super)\n                addToSuperCF((Map<?, ?>)row.get(\"columns\"), columnFamily);\n            else\n                addToStandardCF((List<?>)row.get(\"columns\"), columnFamily);\n\n            if (prevStoredKey != null && prevStoredKey.compareTo(currentKey) != -1)\n            {\n                System.err\n                        .printf(\"Line %d: Key %s is greater than previous, collection is not sorted properly. Aborting import. You might need to delete SSTables manually.%n\",\n                                lineNumber, key);\n                return -1;\n            }\n\n            // saving decorated key\n            writer.append(currentKey, columnFamily);\n            columnFamily.clear();\n\n            prevStoredKey = currentKey;\n            importedKeys++;\n            lineNumber++;\n\n            long current = System.currentTimeMillis();\n\n            if (current - start >= 5000) // 5 secs.\n            {\n                System.out.printf(\"Currently imported %d keys.%n\", importedKeys);\n                start = current;\n            }\n\n            if (keyCountToImport == importedKeys)\n                break;\n\n        }\n\n        writer.closeAndOpenReader();\n\n        return importedKeys;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Add super columns to a column family.\n     *\n     * @param row the super columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private static void addToSuperCF(Map<?, ?> row, ColumnFamily cfamily)\n    {\n        CFMetaData metaData = cfamily.metadata();\n        assert metaData != null;\n\n        AbstractType<?> comparator = metaData.comparator;\n\n        // Super columns\n        for (Map.Entry<?, ?> entry : row.entrySet())\n        {\n            Map<?, ?> data = (Map<?, ?>) entry.getValue();\n\n            addColumnsToCF((List<?>) data.get(\"subColumns\"), stringAsType((String) entry.getKey(), comparator), cfamily);\n\n            // *WARNING* markForDeleteAt has been DEPRECATED at Cassandra side\n            //BigInteger deletedAt = (BigInteger) data.get(\"deletedAt\");\n            //SuperColumn superColumn = (SuperColumn) cfamily.getColumn(superName);\n            //superColumn.markForDeleteAt((int) (System.currentTimeMillis()/1000), deletedAt);\n        }\n    }","id":106902,"modified_method":"/**\n     * Add super columns to a column family.\n     *\n     * @param row the super columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private void addToSuperCF(Map<?, ?> row, ColumnFamily cfamily)\n    {\n        CFMetaData metaData = cfamily.metadata();\n        assert metaData != null;\n\n        AbstractType<?> comparator = metaData.comparator;\n\n        // Super columns\n        for (Map.Entry<?, ?> entry : row.entrySet())\n        {\n            Map<?, ?> data = (Map<?, ?>) entry.getValue();\n\n            ByteBuffer superName = stringAsType((String) entry.getKey(), comparator);\n\n            addColumnsToCF((List<?>) data.get(\"subColumns\"), superName, cfamily);\n\n            if (data.containsKey(\"metadata\"))\n            {\n                parseMeta((Map<?, ?>) data.get(\"metadata\"), (SuperColumn) cfamily.getColumn(superName));\n            }\n        }\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"private static int importUnsorted(JsonParser parser, ColumnFamily columnFamily, String ssTablePath, IPartitioner<?> partitioner) throws IOException\n    {\n        int importedKeys = 0;\n        long start = System.currentTimeMillis();\n        Map<?, ?> data = parser.readValueAs(new TypeReference<Map<?, ?>>() {});\n\n        keyCountToImport = (keyCountToImport == null) ? data.size() : keyCountToImport;\n        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);\n\n        System.out.printf(\"Importing %s keys...%n\", keyCountToImport);\n\n        // sort by dk representation, but hold onto the hex version\n        SortedMap<DecoratedKey,String> decoratedKeys = new TreeMap<DecoratedKey,String>();\n\n        for (Object keyObject : data.keySet())\n        {\n            String key = (String) keyObject;\n            decoratedKeys.put(partitioner.decorateKey(hexToBytes(key)), key);\n        }\n\n        for (Map.Entry<DecoratedKey, String> rowKey : decoratedKeys.entrySet())\n        {\n            if (columnFamily.getType() == ColumnFamilyType.Super)\n            {\n                addToSuperCF((Map<?, ?>) data.get(rowKey.getValue()), columnFamily);\n            }\n            else\n            {\n                addToStandardCF((List<?>) data.get(rowKey.getValue()), columnFamily);\n            }\n\n            writer.append(rowKey.getKey(), columnFamily);\n            columnFamily.clear();\n\n            importedKeys++;\n\n            long current = System.currentTimeMillis();\n\n            if (current - start >= 5000) // 5 secs.\n            {\n                System.out.printf(\"Currently imported %d keys.%n\", importedKeys);\n                start = current;\n            }\n\n            if (keyCountToImport == importedKeys)\n                break;\n        }\n\n        writer.closeAndOpenReader();\n\n        return importedKeys;\n    }","id":106903,"modified_method":"private int importUnsorted(String jsonFile, ColumnFamily columnFamily, String ssTablePath, IPartitioner<?> partitioner) throws IOException\n    {\n        int importedKeys = 0;\n        long start = System.currentTimeMillis();\n\n        JsonParser parser = getParser(jsonFile);\n\n        Object[] data = parser.readValueAs(new TypeReference<Object[]>(){});\n\n        keyCountToImport = (keyCountToImport == null) ? data.length : keyCountToImport;\n        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);\n\n        System.out.printf(\"Importing %s keys...%n\", keyCountToImport);\n\n        // sort by dk representation, but hold onto the hex version\n        SortedMap<DecoratedKey,Map<?, ?>> decoratedKeys = new TreeMap<DecoratedKey,Map<?, ?>>();\n\n        for (Object row : data)\n        {\n            Map<?,?> rowAsMap = (Map<?, ?>)row;\n            decoratedKeys.put(partitioner.decorateKey(hexToBytes((String)rowAsMap.get(\"key\"))), rowAsMap);\n        }\n\n        for (Map.Entry<DecoratedKey, Map<?, ?>> row : decoratedKeys.entrySet())\n        {\n            if (row.getValue().containsKey(\"metadata\"))\n            {\n                parseMeta((Map<?, ?>) row.getValue().get(\"metadata\"), columnFamily);\n            }\n\n            Object columns = row.getValue().get(\"columns\");\n            if (columnFamily.getType() == ColumnFamilyType.Super)\n                addToSuperCF((Map<?, ?>) columns, columnFamily);\n            else\n                addToStandardCF((List<?>) columns, columnFamily);\n\n\n            writer.append(row.getKey(), columnFamily);\n            columnFamily.clear();\n\n            // ready the column family for the next row since we might have read deletionInfo metadata\n            columnFamily.delete(DeletionInfo.LIVE);\n\n            importedKeys++;\n\n            long current = System.currentTimeMillis();\n\n            if (current - start >= 5000) // 5 secs.\n            {\n                System.out.printf(\"Currently imported %d keys.%n\", importedKeys);\n                start = current;\n            }\n\n            if (keyCountToImport == importedKeys)\n                break;\n        }\n\n        writer.closeAndOpenReader();\n\n        return importedKeys;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Add columns to a column family.\n     *\n     * @param row the columns associated with a row\n     * @param superName name of the super column if any\n     * @param cfamily the column family to add columns to\n     */\n    private static void addColumnsToCF(List<?> row, ByteBuffer superName, ColumnFamily cfamily)\n    {\n        CFMetaData cfm = cfamily.metadata();\n        assert cfm != null;\n\n        for (Object c : row)\n        {\n            JsonColumn col = new JsonColumn<List>((List) c, cfm, (superName != null));\n            QueryPath path = new QueryPath(cfm.cfName, superName, col.getName());\n\n            if (col.isExpiring())\n            {\n                cfamily.addColumn(null, new ExpiringColumn(col.getName(), col.getValue(), col.timestamp, col.ttl, col.localExpirationTime));\n            }\n            else if (col.isCounter())\n            {\n                cfamily.addColumn(null, new CounterColumn(col.getName(), col.getValue(), col.timestamp, col.timestampOfLastDelete));\n            }\n            else if (col.isDeleted())\n            {\n                cfamily.addTombstone(path, col.getValue(), col.timestamp);\n            }\n            else if (col.isRangeTombstone())\n            {\n                cfamily.addAtom(new RangeTombstone(col.getName(), col.getValue(), col.timestamp, col.localExpirationTime));\n            }\n            else\n            {\n                cfamily.addColumn(path, col.getValue(), col.timestamp);\n            }\n        }\n    }","id":106904,"modified_method":"/**\n     * Add columns to a column family.\n     *\n     * @param row the columns associated with a row\n     * @param superName name of the super column if any\n     * @param cfamily the column family to add columns to\n     */\n    private void addColumnsToCF(List<?> row, ByteBuffer superName, ColumnFamily cfamily)\n    {\n        CFMetaData cfm = cfamily.metadata();\n        assert cfm != null;\n\n        for (Object c : row)\n        {\n            JsonColumn col = new JsonColumn<List>((List) c, cfm, (superName != null));\n            QueryPath path = new QueryPath(cfm.cfName, superName, col.getName());\n\n            if (col.isExpiring())\n            {\n                cfamily.addColumn(null, new ExpiringColumn(col.getName(), col.getValue(), col.timestamp, col.ttl, col.localExpirationTime));\n            }\n            else if (col.isCounter())\n            {\n                cfamily.addColumn(null, new CounterColumn(col.getName(), col.getValue(), col.timestamp, col.timestampOfLastDelete));\n            }\n            else if (col.isDeleted())\n            {\n                cfamily.addTombstone(path, col.getValue(), col.timestamp);\n            }\n            else if (col.isRangeTombstone())\n            {\n                cfamily.addAtom(new RangeTombstone(col.getName(), col.getValue(), col.timestamp, col.localExpirationTime));\n            }\n            else\n            {\n                cfamily.addColumn(path, col.getValue(), col.timestamp);\n            }\n        }\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"private static void addToStandardCF(List<?> row, ColumnFamily cfamily)\n    {\n        addColumnsToCF(row, null, cfamily);\n    }","id":106905,"modified_method":"private void addToStandardCF(List<?> row, ColumnFamily cfamily)\n    {\n        addColumnsToCF(row, null, cfamily);\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Convert a JSON formatted file to an SSTable.\n     *\n     * @param jsonFile the file containing JSON formatted data\n     * @param keyspace keyspace the data belongs to\n     * @param cf column family the data belongs to\n     * @param ssTablePath file to write the SSTable to\n     *\n     * @throws IOException for errors reading/writing input/output\n     */\n    public static void importJson(String jsonFile, String keyspace, String cf, String ssTablePath) throws IOException\n    {\n        ColumnFamily columnFamily = ColumnFamily.create(keyspace, cf);\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\n\n        int importedKeys = (isSorted) ? importSorted(jsonFile, columnFamily, ssTablePath, partitioner)\n                                      : importUnsorted(getParser(jsonFile), columnFamily, ssTablePath, partitioner);\n\n        if (importedKeys != -1)\n            System.out.printf(\"%d keys imported successfully.%n\", importedKeys);\n    }","id":106906,"modified_method":"/**\n     * Convert a JSON formatted file to an SSTable.\n     *\n     * @param jsonFile the file containing JSON formatted data\n     * @param keyspace keyspace the data belongs to\n     * @param cf column family the data belongs to\n     * @param ssTablePath file to write the SSTable to\n     *\n     * @throws IOException for errors reading/writing input/output\n     */\n    public int importJson(String jsonFile, String keyspace, String cf, String ssTablePath) throws IOException\n    {\n        ColumnFamily columnFamily = ColumnFamily.create(keyspace, cf);\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\n\n        int importedKeys = (isSorted) ? importSorted(jsonFile, columnFamily, ssTablePath, partitioner)\n                                      : importUnsorted(jsonFile, columnFamily, ssTablePath, partitioner);\n\n        if (importedKeys != -1)\n            System.out.printf(\"%d keys imported successfully.%n\", importedKeys);\n\n        return importedKeys;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testImportUnsortedMode() throws IOException, URISyntaxException\n    {\n        String jsonUrl = resourcePath(\"UnsortedSuperCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Super4\");\n\n        ColumnFamily columnFamily = ColumnFamily.create(\"Keyspace1\", \"Super4\");\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\n\n        SSTableImport.setKeyCountToImport(3);\n        int result = SSTableImport.importSorted(jsonUrl, columnFamily, tempSS.getPath(), partitioner);\n        assert result == -1;\n    }","id":106907,"modified_method":"@Test\n    public void testImportUnsortedMode() throws IOException, URISyntaxException\n    {\n        String jsonUrl = resourcePath(\"UnsortedCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n\n        new SSTableImport().importJson(jsonUrl, \"Keyspace1\", \"Standard1\", tempSS.getPath());\n\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext())\n            cf.addAtom(iter.next());\n        assert cf.getColumn(ByteBufferUtil.bytes(\"colAA\")).value().equals(hexToBytes(\"76616c4141\"));\n        assert !(cf.getColumn(ByteBufferUtil.bytes(\"colAA\")) instanceof DeletedColumn);\n        IColumn expCol = cf.getColumn(ByteBufferUtil.bytes(\"colAC\"));\n        assert expCol.value().equals(hexToBytes(\"76616c4143\"));\n        assert expCol instanceof ExpiringColumn;\n        assert ((ExpiringColumn) expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testImportSimpleCfOldFormat() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"SimpleCF.oldformat.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        SSTableImport.importJson(jsonUrl, \"Keyspace1\", \"Standard1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        assert cf.getColumn(ByteBufferUtil.bytes(\"colAA\")).value().equals(hexToBytes(\"76616c4141\"));\n        assert !(cf.getColumn(ByteBufferUtil.bytes(\"colAA\")) instanceof DeletedColumn);\n        IColumn expCol = cf.getColumn(ByteBufferUtil.bytes(\"colAC\"));\n        assert expCol.value().equals(hexToBytes(\"76616c4143\"));\n        assert expCol instanceof ExpiringColumn;\n        assert ((ExpiringColumn)expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;\n    }","id":106908,"modified_method":"@Test\n    public void testImportSimpleCfOldFormat() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"SimpleCF.oldformat.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        new SSTableImport(true).importJson(jsonUrl, \"Keyspace1\", \"Standard1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        assert cf.getColumn(ByteBufferUtil.bytes(\"colAA\")).value().equals(hexToBytes(\"76616c4141\"));\n        assert !(cf.getColumn(ByteBufferUtil.bytes(\"colAA\")) instanceof DeletedColumn);\n        IColumn expCol = cf.getColumn(ByteBufferUtil.bytes(\"colAC\"));\n        assert expCol.value().equals(hexToBytes(\"76616c4143\"));\n        assert expCol instanceof ExpiringColumn;\n        assert ((ExpiringColumn)expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testImportSuperCf() throws IOException, ParseException, URISyntaxException\n    {\n        String jsonUrl = resourcePath(\"SuperCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Super4\");\n        SSTableImport.importJson(jsonUrl, \"Keyspace1\", \"Super4\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk(\"rowA\"), new QueryPath(\"Super4\", null, null), ByteBufferUtil.bytes(\"superA\"));\n        ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);\n        IColumn superCol = cf.getColumn(ByteBufferUtil.bytes(\"superA\"));\n        assert superCol != null;\n        assert superCol.getSubColumns().size() > 0;\n        IColumn subColumn = superCol.getSubColumn(ByteBufferUtil.bytes(\"636f6c4141\"));\n        assert subColumn.value().equals(hexToBytes(\"76616c75654141\"));\n    }","id":106909,"modified_method":"@Test\n    public void testImportSuperCf() throws IOException, ParseException, URISyntaxException\n    {\n        String jsonUrl = resourcePath(\"SuperCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Super4\");\n        new SSTableImport(true).importJson(jsonUrl, \"Keyspace1\", \"Super4\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk(\"rowA\"), new QueryPath(\"Super4\", null, null), ByteBufferUtil.bytes(\"superA\"));\n        ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();\n        qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);\n        IColumn superCol = cf.getColumn(ByteBufferUtil.bytes(\"superA\"));\n        assertEquals(\"supercolumn deletion time did not match the expected time\", new DeletionInfo(0, 0),\n                ((SuperColumn) superCol).deletionInfo());\n        assert superCol != null;\n        assert superCol.getSubColumns().size() > 0;\n        IColumn subColumn = superCol.getSubColumn(ByteBufferUtil.bytes(\"636f6c4141\"));\n        assert subColumn.value().equals(hexToBytes(\"76616c75654141\"));\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testImportCounterCf() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"CounterCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Counter1\");\n        SSTableImport.importJson(jsonUrl, \"Keyspace1\", \"Counter1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Counter1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        IColumn c = cf.getColumn(ByteBufferUtil.bytes(\"colAA\"));\n        assert c instanceof CounterColumn: c;\n        assert ((CounterColumn) c).total() == 42;\n    }","id":106910,"modified_method":"@Test\n    public void testImportCounterCf() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"CounterCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Counter1\");\n        new SSTableImport(true).importJson(jsonUrl, \"Keyspace1\", \"Counter1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Counter1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        IColumn c = cf.getColumn(ByteBufferUtil.bytes(\"colAA\"));\n        assert c instanceof CounterColumn: c;\n        assert ((CounterColumn) c).total() == 42;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testImportSimpleCf() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"SimpleCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        SSTableImport.importJson(jsonUrl, \"Keyspace1\", \"Standard1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        assert cf.getColumn(ByteBufferUtil.bytes(\"colAA\")).value().equals(hexToBytes(\"76616c4141\"));\n        assert !(cf.getColumn(ByteBufferUtil.bytes(\"colAA\")) instanceof DeletedColumn);\n        IColumn expCol = cf.getColumn(ByteBufferUtil.bytes(\"colAC\"));\n        assert expCol.value().equals(hexToBytes(\"76616c4143\"));\n        assert expCol instanceof ExpiringColumn;\n        assert ((ExpiringColumn)expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;\n    }","id":106911,"modified_method":"@Test\n    public void testImportSimpleCf() throws IOException, URISyntaxException\n    {\n        // Import JSON to temp SSTable file\n        String jsonUrl = resourcePath(\"SimpleCF.json\");\n        File tempSS = tempSSTableFile(\"Keyspace1\", \"Standard1\");\n        new SSTableImport(true).importJson(jsonUrl, \"Keyspace1\", \"Standard1\", tempSS.getPath());\n\n        // Verify results\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));\n        QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk(\"rowA\"), new QueryPath(\"Standard1\"));\n        OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);\n        ColumnFamily cf = iter.getColumnFamily();\n        while (iter.hasNext()) cf.addAtom(iter.next());\n        assert cf.getColumn(ByteBufferUtil.bytes(\"colAA\")).value().equals(hexToBytes(\"76616c4141\"));\n        assert !(cf.getColumn(ByteBufferUtil.bytes(\"colAA\")) instanceof DeletedColumn);\n        IColumn expCol = cf.getColumn(ByteBufferUtil.bytes(\"colAC\"));\n        assert expCol.value().equals(hexToBytes(\"76616c4143\"));\n        assert expCol instanceof ExpiringColumn;\n        assert ((ExpiringColumn)expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;\n    }","commit_id":"d569f873de40f0336a9a34e260c1942866e48950","url":"https://github.com/apache/cassandra"},{"original_method":"protected DbEvaluation createEvaluation(DbIssue issue, String who, long when) {\r\n        DbUser user;\r\n        Query query = getPersistenceManager().newQuery(\"select from \" + persistenceHelper.getDbUserClass().getName()\r\n                                                       + \" where openid == :myopenid\");\r\n        List<DbUser> results = (List<DbUser>) query.execute(\"http://\" + who);\r\n        if (results.isEmpty()) {\r\n            user = persistenceHelper.createDbUser(\"http://\" + who, who);\r\n            getPersistenceManager().makePersistent(user);\r\n\r\n        } else {\r\n            user = results.iterator().next();\r\n        }\r\n        query.closeAll();\r\n        DbEvaluation eval = persistenceHelper.createDbEvaluation();\r\n        eval.setComment(\"my comment\");\r\n        eval.setDesignation(\"MUST_FIX\");\r\n        eval.setIssue(issue);\r\n        eval.setWhen(when);\r\n        eval.setWho(user.createKeyObject());\r\n        eval.setEmail(who);\r\n        return eval;\r\n    }","id":106912,"modified_method":"@SuppressWarnings({\"unchecked\"})\r\n    protected DbEvaluation createEvaluation(DbIssue issue, String who, long when) {\r\n        DbUser user;\r\n        Query query = getPersistenceManager().newQuery(\"select from \" + persistenceHelper.getDbUserClass().getName()\r\n                                                       + \" where openid == :myopenid\");\r\n        List<DbUser> results = (List<DbUser>) query.execute(\"http://\" + who);\r\n        if (results.isEmpty()) {\r\n            user = persistenceHelper.createDbUser(\"http://\" + who, who);\r\n            getPersistenceManager().makePersistent(user);\r\n\r\n        } else {\r\n            user = results.iterator().next();\r\n        }\r\n        query.closeAll();\r\n        DbEvaluation eval = persistenceHelper.createDbEvaluation();\r\n        eval.setComment(\"my comment\");\r\n        eval.setDesignation(\"MUST_FIX\");\r\n        eval.setIssue(issue);\r\n        eval.setWhen(when);\r\n        eval.setWho(user.createKeyObject());\r\n        eval.setEmail(who);\r\n        issue.addEvaluation(eval);\r\n        return eval;\r\n    }","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGetRecentEvaluations() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tDbEvaluation eval1 = createEvaluation(issue, \"someone1\", 100);\r\n\t\tDbEvaluation eval2 = createEvaluation(issue, \"someone2\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(issue, \"someone3\", 300);\r\n\t\tissue.addEvaluations(eval1, eval2, eval3);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(1, result.getIssuesCount());\r\n\r\n\t\t// check issues\r\n\t\tIssue foundissueProto = result.getIssues(0);\r\n\t\tcheckIssuesEqualExceptTimestamps(issue, foundissueProto);\r\n\r\n\t\t// check evaluations\r\n\t\tassertEquals(2, foundissueProto.getEvaluationsCount());\r\n\t\tcheckEvaluationsEqual(eval2, foundissueProto.getEvaluations(0));\r\n\t\tcheckEvaluationsEqual(eval3, foundissueProto.getEvaluations(1));\r\n\t}","id":106913,"modified_method":"public void testGetRecentEvaluations() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tcreateEvaluation(issue, \"someone1\", 100);\r\n\t\tDbEvaluation eval2 = createEvaluation(issue, \"someone2\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(issue, \"someone3\", 300);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(1, result.getIssuesCount());\r\n\r\n\t\t// check issues\r\n\t\tIssue foundissueProto = result.getIssues(0);\r\n\t\tcheckIssuesEqualExceptTimestamps(issue, foundissueProto);\r\n\r\n\t\t// check evaluations\r\n\t\tassertEquals(2, foundissueProto.getEvaluationsCount());\r\n\t\tcheckEvaluationsEqual(eval2, foundissueProto.getEvaluations(0));\r\n\t\tcheckEvaluationsEqual(eval3, foundissueProto.getEvaluations(1));\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testFindIssuesOnlyShowsLatestEvaluationFromEachPerson() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad1\", persistenceHelper);\r\n\t\tDbEvaluation eval1 = createEvaluation(foundIssue, \"first\", 100);\r\n\t\tDbEvaluation eval2 = createEvaluation(foundIssue, \"second\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(foundIssue, \"first\", 300);\r\n\t\tfoundIssue.addEvaluation(eval1);\r\n\t\tfoundIssue.addEvaluation(eval2);\r\n\t\tfoundIssue.addEvaluation(eval3);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n\t\tFindIssuesResponse result = findIssues(\"fad2\", \"fad1\");\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval2, eval3);\r\n\t}","id":106914,"modified_method":"public void testFindIssuesOnlyShowsLatestEvaluationFromEachPerson() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad1\", persistenceHelper);\r\n\t\tcreateEvaluation(foundIssue, \"first\", 100);\r\n\t\tDbEvaluation eval2 = createEvaluation(foundIssue, \"second\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(foundIssue, \"first\", 300);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n\t\tFindIssuesResponse result = findIssues(\"fad2\", \"fad1\");\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval2, eval3);\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGetRecentEvaluationsNoneFound() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tDbEvaluation eval1 = createEvaluation(issue, \"someone\", 100);\r\n\t\tDbEvaluation eval2 = createEvaluation(issue, \"someone\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(issue, \"someone\", 300);\r\n\t\tissue.addEvaluations(eval1, eval2, eval3);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(300).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(0, result.getIssuesCount());\r\n\t}","id":106915,"modified_method":"public void testGetRecentEvaluationsNoneFound() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tcreateEvaluation(issue, \"someone\", 100);\r\n\t\tcreateEvaluation(issue, \"someone\", 200);\r\n\t\tcreateEvaluation(issue, \"someone\", 300);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(300).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(0, result.getIssuesCount());\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGetRecentEvaluationsOnlyShowsLatestFromEachPerson() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tDbEvaluation eval1 = createEvaluation(issue, \"first\",  100);\r\n\t\tDbEvaluation eval2 = createEvaluation(issue, \"second\", 200);\r\n\t\tDbEvaluation eval3 = createEvaluation(issue, \"first\",  300);\r\n\t\tDbEvaluation eval4 = createEvaluation(issue, \"second\", 400);\r\n\t\tDbEvaluation eval5 = createEvaluation(issue, \"first\",  500);\r\n\t\tissue.addEvaluations(eval1, eval2, eval3, eval4, eval5);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(1, result.getIssuesCount());\r\n\r\n\t\t// check issues\r\n\t\tIssue foundissueProto = result.getIssues(0);\r\n\t\tcheckIssuesEqualExceptTimestamps(issue, foundissueProto);\r\n\r\n\t\t// check evaluations\r\n\t\tassertEquals(2, foundissueProto.getEvaluationsCount());\r\n\t\tcheckEvaluationsEqual(eval4, foundissueProto.getEvaluations(0));\r\n\t\tcheckEvaluationsEqual(eval5, foundissueProto.getEvaluations(1));\r\n\t}","id":106916,"modified_method":"public void testGetRecentEvaluationsOnlyShowsLatestFromEachPerson() throws Exception {\r\n\t\tDbIssue issue = createDbIssue(\"fad\", persistenceHelper);\r\n\t\tcreateEvaluation(issue, \"first\",  100);\r\n\t\tcreateEvaluation(issue, \"second\", 200);\r\n\t\tcreateEvaluation(issue, \"first\",  300);\r\n\t\tDbEvaluation eval4 = createEvaluation(issue, \"second\", 400);\r\n\t\tDbEvaluation eval5 = createEvaluation(issue, \"first\",  500);\r\n\r\n        getPersistenceManager().makePersistent(issue);\r\n\r\n\t\texecutePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\r\n\t\tcheckResponse(200);\r\n\t\tRecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\r\n\t\tassertEquals(1, result.getIssuesCount());\r\n\r\n\t\t// check issues\r\n\t\tIssue foundissueProto = result.getIssues(0);\r\n\t\tcheckIssuesEqualExceptTimestamps(issue, foundissueProto);\r\n\r\n\t\t// check evaluations\r\n\t\tassertEquals(2, foundissueProto.getEvaluationsCount());\r\n\t\tcheckEvaluationsEqual(eval4, foundissueProto.getEvaluations(0));\r\n\t\tcheckEvaluationsEqual(eval5, foundissueProto.getEvaluations(1));\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testFindIssuesWithEvaluations() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n\t\tDbEvaluation eval = createEvaluation(foundIssue, \"someone\", 100);\r\n\t\tfoundIssue.addEvaluation(eval);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        FindIssuesResponse result = findIssues(\"fad1\", \"fad2\");\r\n\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval);\r\n\t}","id":106917,"modified_method":"public void testFindIssuesWithEvaluations() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n\t\tDbEvaluation eval = createEvaluation(foundIssue, \"someone\", 100);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        FindIssuesResponse result = findIssues(\"fad1\", \"fad2\");\r\n\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval);\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testFindIssuesWithOldStyleEvaluation() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n\t\tDbEvaluation eval = createEvaluation(foundIssue, \"someone\", 100);\r\n        persistenceHelper.convertToOldStyleForTesting(eval);\r\n\t\tfoundIssue.addEvaluation(eval);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        FindIssuesResponse result = findIssues(\"fad1\", \"fad2\");\r\n\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval);\r\n\t}","id":106918,"modified_method":"public void testFindIssuesWithOldStyleEvaluation() throws Exception {\r\n\t\tDbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n\t\tDbEvaluation eval = createEvaluation(foundIssue, \"someone\", 100);\r\n        persistenceHelper.convertToOldStyleForTesting(eval);\r\n\r\n\t\t// apparently the evaluation is automatically persisted. throws\r\n\t\t// exception when attempting to persist the eval with the issue.\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        FindIssuesResponse result = findIssues(\"fad1\", \"fad2\");\r\n\r\n\t\tassertEquals(2, result.getFoundIssuesCount());\r\n        checkIssueEmpty(result.getFoundIssues(0));\r\n        checkTerseIssue(result.getFoundIssues(1), eval);\r\n\t}","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@SuppressWarnings({\"unchecked\"})\r\n    private void showStats(HttpServletRequest req, HttpServletResponse resp, PersistenceManager pm)\r\n            throws IOException {\r\n        List<DbEvaluation> evals = (List<DbEvaluation>) pm.newQuery(\"select from \" + persistenceHelper.getDbEvaluationClass().getName()\r\n                    + \" order by when\").execute();\r\n        Map<String,Integer> countByUser = new HashMap<String, Integer>();\r\n        for (DbEvaluation eval : evals) {\r\n            String email = eval.getEmail();\r\n            if (email == null)\r\n                continue;\r\n            Integer count = countByUser.get(email);\r\n            if (count == null) count = 0;\r\n            countByUser.put(email, count + 1);\r\n        }\r\n\r\n        List<String> labels = new ArrayList<String>();\r\n        List<Integer> values = new ArrayList<Integer>();\r\n        int max = 0;\r\n        for (Entry<String, Integer> entry : sortEntries(countByUser.entrySet())) {\r\n            String email = entry.getKey();\r\n            int count = entry.getValue();\r\n            labels.add(email + \"(\" + count + \")\");\r\n            values.add(count);\r\n            if (count > max)\r\n                max = count;\r\n        }\r\n\r\n        resp.setStatus(200);\r\n        Collections.reverse(values);\r\n        BarChart chart = GCharts.newBarChart(Plots.newBarChartPlot(Data.newData(values)));\r\n        chart.addYAxisLabels(AxisLabelsFactory.newAxisLabels(labels));\r\n        chart.addXAxisLabels(AxisLabelsFactory.newNumericRangeAxisLabels(0, max));\r\n        chart.setBarWidth(BarChart.AUTO_RESIZE);\r\n        chart.setSize(600, 500);\r\n        chart.setHorizontal(true);\r\n        chart.setTitle(\"Total Evaluations by User\");\r\n        showChartImg(resp, chart.toURLString());\r\n    }","id":106919,"modified_method":"@SuppressWarnings({\"unchecked\"})\r\n    private void showStats(HttpServletRequest req, HttpServletResponse resp, PersistenceManager pm)\r\n            throws IOException {\r\n        List<DbEvaluation> evals = (List<DbEvaluation>) pm.newQuery(\"select from \" + persistenceHelper.getDbEvaluationClass().getName()\r\n                    + \" order by when\").execute();\r\n        Map<String,Integer> totalCountByUser = new HashMap<String, Integer>();\r\n        Map<String,Integer> issueCountByUser = new HashMap<String, Integer>();\r\n        Multimap<String, String> issuesByUser = Multimaps.newSetMultimap(Maps.<String, Collection<String>>newHashMap(), new Supplier<Set<String>>() {\r\n            public Set<String> get() {\r\n                return Sets.newHashSet();\r\n            }\r\n        });\r\n        Map<Long,Integer> evalsByWeek = Maps.newHashMap();\r\n\r\n        for (DbEvaluation eval : evals) {\r\n            String email = eval.getEmail();\r\n            if (email == null)\r\n                continue;\r\n            issuesByUser.put(email, eval.getIssue().getHash());\r\n            Integer count = totalCountByUser.get(email);\r\n            if (count == null) count = 0;\r\n            totalCountByUser.put(email, count + 1);\r\n            issueCountByUser.put(email, issuesByUser.get(email).size());\r\n\r\n            long beginningOfWeek = getBeginningOfWeekInMillis(eval.getWhen());\r\n            Integer oldCount = evalsByWeek.get(beginningOfWeek);\r\n            evalsByWeek.put(beginningOfWeek, (oldCount == null ? 0 : oldCount) + 1);\r\n        }\r\n\r\n        BarChart issuesByUserChart = buildByUserChart(issueCountByUser);\r\n        issuesByUserChart.setTitle(\"Issues Evaluated by User\");\r\n        BarChart evalsByUserChart = buildByUserChart(totalCountByUser);\r\n        evalsByUserChart.setTitle(\"Total Evaluations by User\");\r\n\r\n        LineChart evalsOverTimeChart = createEvalsByWeekChart(evalsByWeek);\r\n        evalsOverTimeChart.setTitle(\"Evaluations Submitted\");\r\n\r\n        resp.setStatus(200);\r\n\r\n        resp.getOutputStream().print(\"<html>\" +\r\n                                     \"<head><title>FindBugs Cloud Stats<\/title><\/head>\" +\r\n                                     \"<body>\");\r\n        showChartImg(resp, evalsOverTimeChart.toURLString());\r\n        resp.getOutputStream().print(\"<br><br>\");\r\n        showChartImg(resp, evalsByUserChart.toURLString());\r\n        showChartImg(resp, issuesByUserChart.toURLString());\r\n    }","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByDate() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        DbEvaluation eval1 = createEvaluation(foundIssue, \"someone\", days(2));\r\n        DbEvaluation eval2 = createEvaluation(foundIssue, \"someone-else\", days(2));\r\n        DbEvaluation eval3 = createEvaluation(foundIssue, \"someone\", days(3));\r\n        DbEvaluation eval4 = createEvaluation(foundIssue, \"someone3\", days(3));\r\n        DbEvaluation eval5 = createEvaluation(foundIssue, \"someone3\", days(3));\r\n        DbEvaluation eval6 = createEvaluation(foundIssue, \"someone3\", days(5));\r\n        foundIssue.addEvaluation(eval1);\r\n        foundIssue.addEvaluation(eval2);\r\n        foundIssue.addEvaluation(eval3);\r\n        foundIssue.addEvaluation(eval4);\r\n        foundIssue.addEvaluation(eval5);\r\n        foundIssue.addEvaluation(eval6);\r\n\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        assertTrue(url.contains(\"someone-else|someone|someone3\"));\r\n        assertTrue(url.contains(\"chd=e:ApBSB7\")); // encoded data... not very test friendly\r\n    }","id":106920,"modified_method":"public void testGraphEvalsByDate() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        // week 1\r\n        createEvaluation(foundIssue, \"someone\", days(2));\r\n        createEvaluation(foundIssue, \"someone-else\", days(2));\r\n        createEvaluation(foundIssue, \"someone\", days(3));\r\n\r\n        // week 2\r\n        createEvaluation(foundIssue, \"someone3\", days(9));\r\n        createEvaluation(foundIssue, \"someone3\", days(10));\r\n\r\n        // week 4\r\n        createEvaluation(foundIssue, \"someone3\", days(24));\r\n        createEvaluation(foundIssue, \"someone3\", days(25));\r\n\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(0);\r\n        checkParam(url, \"chxl\", \"1:|3/21/10|3/28/10|4/4/10|4/11/10\");\r\n        checkParam(url, \"chd\", \"t:100.0,66.7,0.0,66.7\");\r\n    }","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByUser() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        DbEvaluation eval1 = createEvaluation(foundIssue, \"someone\", 100);\r\n        DbEvaluation eval2 = createEvaluation(foundIssue, \"someone-else\", 200);\r\n        DbEvaluation eval3 = createEvaluation(foundIssue, \"someone\", 300);\r\n        DbEvaluation eval4 = createEvaluation(foundIssue, \"someone3\", 300);\r\n        DbEvaluation eval5 = createEvaluation(foundIssue, \"someone3\", 300);\r\n        DbEvaluation eval6 = createEvaluation(foundIssue, \"someone3\", 300);\r\n        foundIssue.addEvaluation(eval1);\r\n        foundIssue.addEvaluation(eval2);\r\n        foundIssue.addEvaluation(eval3);\r\n        foundIssue.addEvaluation(eval4);\r\n        foundIssue.addEvaluation(eval5);\r\n        foundIssue.addEvaluation(eval6);\r\n\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(0);\r\n        assertTrue(url.contains(\"someone-else|someone|someone3\"));\r\n        assertTrue(url.contains(\"chd=e:ApBSB7\")); // encoded data... not very test friendly\r\n    }","id":106921,"modified_method":"public void testGraphEvalsByUser() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        createEvaluation(foundIssue, \"someone\", 100);\r\n        createEvaluation(foundIssue, \"someone-else\", 200);\r\n        createEvaluation(foundIssue, \"someone\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        \r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        checkParam(url, \"chxl\", \"0:|someone-else (1)|someone (2)|someone3 (3)\");\r\n        checkParam(url, \"chd\", \"t:100.0,66.7,33.3\");\r\n    }","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private long days(int days) {\r\n        return days*86400*1000;\r\n    }","id":106922,"modified_method":"/** starts at march 20, 2010 */\r\n    private long days(int days) {\r\n        return (1269043200L + (days*86400L))*1000;\r\n    }","commit_id":"5c7849ea01f5e2df3dc843e656cde12508c96d5d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private DefaultEclipseProject buildHierarchy(Project project) {\n        List<DefaultEclipseProject> children = new ArrayList<DefaultEclipseProject>();\n        for (Project child : project.getChildProjects().values()) {\n            children.add(buildHierarchy(child));\n        }\n\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        org.gradle.plugins.ide.eclipse.model.EclipseProject internalProject = eclipseModel.getProject();\n        String name = internalProject.getName();\n        String description = GUtil.elvis(internalProject.getComment(), null);\n        DefaultEclipseProject eclipseProject = new DefaultEclipseProject(name, project.getPath(), description, project.getProjectDir(), children);\n        for (DefaultEclipseProject child : children) {\n            child.setParent(eclipseProject);\n        }\n        addProject(project, eclipseProject);\n        return eclipseProject;\n    }","id":106923,"modified_method":"private Object buildHierarchy(Project project) {\n        List children = new ArrayList();\n        for (Project child : project.getChildProjects().values()) {\n            children.add(buildHierarchy(child));\n        }\n\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        org.gradle.plugins.ide.eclipse.model.EclipseProject internalProject = eclipseModel.getProject();\n        String name = internalProject.getName();\n        String description = GUtil.elvis(internalProject.getComment(), null);\n        Object eclipseProject = ReflectionUtil.newInstance(DefaultEclipseProject.class, name, project.getPath(), description, project.getProjectDir(), children);\n        for (Object child : children) {\n            ReflectionUtil.setProperty(child, \"parent\", eclipseProject);\n        }\n        addProject(project, eclipseProject);\n        return eclipseProject;\n    }","commit_id":"a1ad0e6c818b3ae09bc08172188f0a0f7d4bfac4","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultEclipseProject buildAll(GradleInternal gradle, Object currentModel) {\n        this.gradle = gradle;\n        Project root = gradle.getRootProject();\n        tasksFactory.collectTasks(root);\n        new EclipsePluginApplier().apply(root);\n        buildHierarchy(root);\n        populate(root);\n        return currentProject;\n    }","id":106924,"modified_method":"public Object buildAll(GradleInternal gradle, Object currentModel) {\n        this.gradle = gradle;\n        Project root = gradle.getRootProject();\n        tasksFactory.collectTasks(root);\n        new EclipsePluginApplier().apply(root);\n        buildHierarchy(root);\n        populate(root);\n        return currentProject;\n    }","commit_id":"a1ad0e6c818b3ae09bc08172188f0a0f7d4bfac4","url":"https://github.com/gradle/gradle"},{"original_method":"private void populate(Project project) {\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        EclipseClasspath classpath = eclipseModel.getClasspath();\n\n        classpath.setProjectDependenciesOnly(projectDependenciesOnly);\n        List<ClasspathEntry> entries = classpath.resolveDependencies();\n\n        List<ExternalDependencyVersion1> dependencies = new ExternalDependenciesFactory().create(project, entries);\n        List<EclipseProjectDependencyVersion2> projectDependencies = new EclipseProjectDependenciesFactory().create(projectMapping, entries);\n        List<EclipseSourceDirectoryVersion1> sourceDirectories = new SourceDirectoriesFactory().create(project, entries);\n\n        DefaultEclipseProject eclipseProject = projectMapping.get(project.getPath());\n        eclipseProject.setClasspath(dependencies);\n        eclipseProject.setProjectDependencies(projectDependencies);\n        eclipseProject.setSourceDirectories(sourceDirectories);\n        tasksFactory.populate(project, eclipseProject);\n\n        for (Project childProject : project.getChildProjects().values()) {\n            populate(childProject);\n        }\n    }","id":106925,"modified_method":"private void populate(Project project) {\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        EclipseClasspath classpath = eclipseModel.getClasspath();\n\n        classpath.setProjectDependenciesOnly(projectDependenciesOnly);\n        List<ClasspathEntry> entries = classpath.resolveDependencies();\n\n        final List<ExternalDependencyVersion1> externalDependencies = new LinkedList<ExternalDependencyVersion1>();\n        final List<EclipseProjectDependencyVersion2> projectDependencies = new LinkedList<EclipseProjectDependencyVersion2>();\n        final List<EclipseSourceDirectoryVersion1> sourceDirectories = new ArrayList<EclipseSourceDirectoryVersion1>();\n\n        for (ClasspathEntry entry : entries) {\n            if (entry instanceof Library) {\n                Library library = (Library) entry;\n                final File file = project.file(library.getPath());\n                final File source = library.getSourcePath() == null ? null : project.file(library.getSourcePath());\n                final File javadoc = library.getJavadocPath() == null ? null : project.file(library.getJavadocPath());\n                externalDependencies.add(new DefaultExternalDependency(file, javadoc, source));\n            } else if (entry instanceof ProjectDependency) {\n                final ProjectDependency projectDependency = (ProjectDependency) entry;\n                final String path = StringUtils.removeStart(projectDependency.getPath(), \"/\");\n                DefaultEclipseProjectDependency dep = ReflectionUtil.newInstance(DefaultEclipseProjectDependency.class, path, projectMapping.get(projectDependency.getGradlePath()));\n                projectDependencies.add(dep);\n            } else if (entry instanceof SourceFolder) {\n                String path = ((SourceFolder) entry).getPath();\n                sourceDirectories.add(new DefaultEclipseSourceDirectory(path, project.file(path)));\n            }\n        }\n\n        final Object eclipseProject = projectMapping.get(project.getPath());\n        ReflectionUtil.setProperty(eclipseProject, \"classpath\", externalDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"projectDependencies\", projectDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"sourceDirectories\", sourceDirectories);\n\n        List out = new ArrayList();\n        for (final Task t : tasksFactory.getTasks(project)) {\n            out.add(ReflectionUtil.newInstance(DefaultTask.class, eclipseProject, t.getPath(), t.getName(), t.getDescription()));\n        }\n        ReflectionUtil.setProperty(eclipseProject, \"tasks\", out);\n\n        for (Project childProject : project.getChildProjects().values()) {\n            populate(childProject);\n        }\n    }","commit_id":"a1ad0e6c818b3ae09bc08172188f0a0f7d4bfac4","url":"https://github.com/gradle/gradle"},{"original_method":"private URL rewriteUrlIfNeeded(String value) throws URISyntaxException\n    {\n        if (value == null)\n        {\n            return null;\n        }\n\n        try\n        {\n            URI uri;\n            if (value.startsWith(this.serverProto.concat(\"://\")))\n            {\n  \n                uri = new URI (value);\n            }\n            else\n            {\n                URL url = new URL(this.requestURL, value);\n                uri = url.toURI();\n            }\n\n            String actualProto = uri.getScheme();\n\n            \n            if (!this.serverProto.equalsIgnoreCase(actualProto))\n            {\n                // protocol is already correct\n                return null;\n            }\n\n            if (!this.serverName.equals(uri.getHost()))\n            {\n                // going to a different host\n                return null;\n            }\n\n            if (normalizePort(this.serverProto, this.serverPort) != normalizePort(actualProto, uri.getPort()))\n            {\n                // not to default port\n                return null;\n            }\n\n         \n            return new URI(this.clientProto,null, this.serverName, this.clientPort, uri.getPath(),uri.getQuery(),uri.getFragment()).toURL();\n        }\n        catch (MalformedURLException e)\n        {\n            return null;\n        }\n    }","id":106926,"modified_method":"private String rewriteUrlIfNeeded(String value) throws URISyntaxException\n    {\n        if (value == null)\n        {\n            return null;\n        }\n\n        try\n        {\n            URI uri;\n            if (value.startsWith(this.serverProto.concat(\"://\")))\n            {\n\n                uri = new URI (value);\n            }\n            else\n            {\n                URL url = new URL(this.requestURL, value);\n                uri = url.toURI();\n            }\n\n            String actualProto = uri.getScheme();\n\n\n            if (!this.serverProto.equalsIgnoreCase(actualProto))\n            {\n                // protocol is already correct\n                return null;\n            }\n\n            if (!this.serverName.equals(uri.getHost()))\n            {\n                // going to a different host\n                return null;\n            }\n\n            if (normalizePort(this.serverProto, this.serverPort) != normalizePort(actualProto, uri.getPort()))\n            {\n                // not to default port\n                return null;\n            }\n\n            final StringBuilder sb = new StringBuilder();\n            sb.append(this.clientProto);\n            sb.append(\"://\");\n            sb.append(this.serverName);\n            if ( this.clientPort != -1 )\n            {\n                sb.append(':');\n                sb.append(this.clientPort);\n            }\n            if ( uri.getPath() != null )\n            {\n                sb.append(uri.getPath());\n            }\n            if ( uri.getRawQuery() != null )\n            {\n                sb.append('?');\n                sb.append(uri.getRawQuery());\n            }\n            if ( uri.getRawFragment() != null )\n            {\n                sb.append('#');\n                sb.append(uri.getRawFragment());\n            }\n            return sb.toString();\n        }\n        catch (MalformedURLException e)\n        {\n            return null;\n        }\n    }","commit_id":"6625014e28a6bd2597de70f52f837d55adf9141e","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void setHeader(String name, String value)\n    {\n        if (HDR_LOCATION.equalsIgnoreCase(name))\n        {\n        \tURL rewritten = null;\n        \ttry {\n        \t\trewritten = rewriteUrlIfNeeded(value);\n        \t} catch (URISyntaxException e) {\n        \t\t// ignore\n        \t}\n            // Trying to set a redirect location to the original client-side URL, which should be https...\n            if (rewritten != null)\n            {\n                value = rewritten.toExternalForm();\n            }\n        }\n        super.setHeader(name, value);\n    }","id":106927,"modified_method":"@Override\n    public void setHeader(String name, String value)\n    {\n        if (HDR_LOCATION.equalsIgnoreCase(name))\n        {\n        \tString rewritten = null;\n        \ttry {\n        \t\trewritten = rewriteUrlIfNeeded(value);\n        \t} catch (URISyntaxException e) {\n        \t\t// ignore\n        \t}\n            // Trying to set a redirect location to the original client-side URL, which should be https...\n            if (rewritten != null)\n            {\n                value = rewritten;\n            }\n        }\n        super.setHeader(name, value);\n    }","commit_id":"6625014e28a6bd2597de70f52f837d55adf9141e","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void sendRedirect(String location) throws IOException\n    {\n    \tURL rewritten = null;\n    \ttry {\n    \t\trewritten = rewriteUrlIfNeeded(location);\n    \t} catch (URISyntaxException e) {\n    \t\tthrow new IOException (e);\n    \t}\n        if (rewritten != null)\n        {\n            location = rewritten.toExternalForm();\n        }\n        super.sendRedirect(location);\n    }","id":106928,"modified_method":"@Override\n    public void sendRedirect(String location) throws IOException\n    {\n    \tString rewritten = null;\n    \ttry {\n    \t\trewritten = rewriteUrlIfNeeded(location);\n    \t} catch (URISyntaxException e) {\n    \t\tthrow new IOException (e);\n    \t}\n        if (rewritten != null)\n        {\n            location = rewritten;\n        }\n        super.sendRedirect(location);\n    }","commit_id":"6625014e28a6bd2597de70f52f837d55adf9141e","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Returns whether it is a vertical tabbox.\n\t *\n\t * @since 3.0.3\n\t */\n\tpublic boolean isVertical() {\n\t\treturn \"vertical\".equals(getOrient());\n\t}","id":106929,"modified_method":"/**\n\t * Returns whether it is a vertical tabbox.\n\t *\n\t * @since 3.0.3\n\t */\n\tpublic boolean isVertical() {\n\t\tString orient = getOrient();\n\t\treturn \"vertical\".equals(orient) || \"right\".equals(orient) || \"left\".equals(orient);\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\t\t\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\tif (_panelSpacing != null )\n\t\t\trender(renderer, \"panelSpacing\", _panelSpacing);\n\t\tif (!\"horizontal\".equals(_orient))\n\t\t\trender(renderer, \"orient\", _orient);\n\t\tif (!_tabscroll)\n\t\t\trenderer.render(\"tabscroll\", _tabscroll);\n\t}","id":106930,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\t\t\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\tif (_panelSpacing != null )\n\t\t\trender(renderer, \"panelSpacing\", _panelSpacing);\n\t\tif (!isTop())\n\t\t\trender(renderer, \"orient\", _orient);\n\t\tif (!_tabscroll)\n\t\t\trenderer.render(\"tabscroll\", _tabscroll);\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the orient.\n\t *\n\t * <p>\n\t * Default: \"horizontal\".\n\t *\n\t * <p>\n\t * Note: only the default mold supports it (not supported if accordion).\n\t */\n\tpublic String getOrient() {\n\t\treturn _orient;\n\t}","id":106931,"modified_method":"/**\n\t * Returns the orient.\n\t *\n\t * <p>\n\t * Default: \"top\".\n\t *\n\t * <p>\n\t * Note: only the default mold supports it (not supported if accordion).\n\t */\n\tpublic String getOrient() {\n\t\treturn this._orient;\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Sets the orient.\n\t *\n\t * @param orient\n\t *            either \"horizontal\" or \"vertical\".\n\t */\n\tpublic void setOrient(String orient) throws WrongValueException {\n\t\tif (!\"horizontal\".equals(orient) && !\"vertical\".equals(orient) \n\t\t\t\t&& !\"vertical-right\".equals(orient) && !\"horizontal-bottom\".equals(orient))\n\t\t\tthrow new WrongValueException(\"Unknow orient : \" + orient);\n\t\tif (inAccordionMold())\n\t\t\tthrow new WrongValueException(\"Unsupported vertical orient in mold : \"+getMold());\n\t\tif (!Objects.equals(_orient, orient)) {\n\t\t\t_orient = orient;\n\t\t\tsmartUpdate(\"orient\", _orient);\n\t\t}\n\t}","id":106932,"modified_method":"/**\n\t * Sets the orient.\n\t *\n\t * @param orient\n\t *            \"horizontal\" same as \"top\", \"vertical\" same as \"left\", \"bottom, \"right\".\n\t */\n\tpublic void setOrient(String orient) throws WrongValueException {\n\t\tif (!\"horizontal\".equals(orient) && !\"top\".equals(orient) && !\"bottom\".equals(orient) \n\t\t\t\t&& !\"vertical\".equals(orient) && !\"right\".equals(orient) && !\"left\".equals(orient))\n\t\t\tthrow new WrongValueException(\"Unknow orient : \" + orient);\n\t\tif (inAccordionMold())\n\t\t\tthrow new WrongValueException(\"Unsupported vertical orient in mold : \"+getMold());\n\t\tif (!Objects.equals(_orient, orient)) {\n\t\t\tif (\"horizontal\".equals(orient))\n\t\t\t\tthis._orient = \"top\";\n\t\t\telse if (\"vertical\".equals(orient))\n\t\t\t\tthis._orient = \"left\";\n\t\t\telse\n\t\t\t\tthis._orient = orient;\n\t\t\tsmartUpdate(\"orient\", _orient);\n\t\t}\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"public String getZclass() {\n\t\tString cls = _zclass == null ? \"z-tabbox\" : _zclass;\n\t\tString orientCls = isHorizontalTop() ? \"\" : \" \" + (cls + \"-\" + this._orient);\n\t\tcls += inAccordionMold() ? \" \" + (cls + \"-\" + getMold()) : orientCls;\n\t\treturn cls;\n\t}","id":106933,"modified_method":"public String getZclass() {\n\t\tString cls = _zclass == null ? \"z-tabbox\" : _zclass;\n\t\tString orientCls = isTop() ? \"\" : \" \" + (cls + \"-\" + this._orient);\n\t\tcls += inAccordionMold() ? \" \" + (cls + \"-\" + getMold()) : orientCls;\n\t\treturn cls;\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns whether it is a horizontal tabbox.\n\t *\n\t * @since 3.0.3\n\t */\n\tpublic boolean isHorizontal() {\n\t\treturn getOrient().contains(\"horizontal\");\n\t}","id":106934,"modified_method":"/**\n\t * Returns whether it is a horizontal tabbox.\n\t *\n\t * @since 3.0.3\n\t */\n\tpublic boolean isHorizontal() {\n\t\tString orient = getOrient();\n\t\treturn \"horizontal\".equals(orient) || \"top\".equals(orient) || \"bottom\".equals(orient);\n\t}","commit_id":"f1de1c75d042168c45b9d79baa71c052bfe41aa1","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * Return the location data for this node, or null.\n     */\n    public LocationData getLocationData() {\n        return (node == null) ? null\n                : (node instanceof Element) ? (LocationData) ((Element) node).getData()\n                : (node instanceof Attribute) ? (LocationData) ((Attribute) node).getData()\n                : null;\n    }","id":106935,"modified_method":"/**\n     * Return the location data for this node, or null.\n     */\n    public LocationData getLocationData() {\n    \tfinal LocationData ret;\n    \tif ( node == null ) {\n    \t    ret = null;\n    \t} else if ( node.getNodeType() == org.dom4j.Node.ELEMENT_NODE ) {\n            ret = ( LocationData )( ( org.dom4j.Element )node ).getData();    \n        } else if ( node.getNodeType() == org.dom4j.Node.ATTRIBUTE_NODE ) {\n            ret = ( LocationData )( ( org.dom4j.Attribute )node ).getData();    \n        } else {\n            ret = null;\n        }\n    \treturn ret;\n    }","commit_id":"c08a1fb9b71b83ffc95a3afa29de0dd8fe4c4c4a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Converts the object into bytes for hashing.\n     * @param obj\n     * @return null if the obj is null or is a Volt null type.\n     */\n    public static byte[] valueToBytes(Object obj) {\n        if (VoltType.isNullVoltType(obj)) {\n            return null;\n        }\n        else if (obj instanceof Long) {\n            return Longs.toByteArray((Long) obj);\n        }\n        else if (obj instanceof String ) {\n            return ((String) obj).getBytes(Charsets.UTF_8);\n        }\n        else if (obj instanceof Integer) {\n            return Ints.toByteArray((Integer) obj);\n        }\n        else if (obj instanceof Short) {\n            return Ints.toByteArray((Integer) obj);\n        }\n        else if (obj instanceof Byte) {\n            return new byte[] { (Byte) obj };\n        }\n        else if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n\n        throw new RuntimeException(\n                \"TheHashinator#valueToBytes failed to convert a non-partitionable type.\");\n    }","id":106936,"modified_method":"/**\n     * Converts the object into bytes for hashing.\n     * @param obj\n     * @return null if the obj is null or is a Volt null type.\n     */\n    public static byte[] valueToBytes(Object obj) {\n        long value = 0;\n        byte[] retval = null;\n\n        if (VoltType.isNullVoltType(obj)) {\n            return null;\n        } else if (obj instanceof Long) {\n            value = ((Long) obj).longValue();\n        } else if (obj instanceof String ) {\n            retval = ((String) obj).getBytes(Charsets.UTF_8);\n        } else if (obj instanceof Integer) {\n            value = ((Integer)obj).intValue();\n        } else if (obj instanceof Short) {\n            value = ((Short)obj).shortValue();\n        } else if (obj instanceof Byte) {\n            value = ((Byte)obj).byteValue();\n        } else if (obj instanceof byte[]) {\n            retval = (byte[]) obj;\n        }\n\n        if (retval == null) {\n            ByteBuffer buf = ByteBuffer.allocate(8);\n            buf.order(ByteOrder.LITTLE_ENDIAN);\n            buf.putLong(value);\n            retval = buf.array();\n        }\n\n        return retval;\n    }","commit_id":"4dd7273c5b40b0c65018879c39ea7dbaabc7eda9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Converts a byte array with type back to the original partition value.\n     * This is the inverse of {@see TheHashinator#valueToBytes(Object)}.\n     * @param type VoltType of partition parameter.\n     * @param value Byte array representation of partition parameter.\n     * @return Java object of the correct type.\n     */\n    public static Object bytesToValue(VoltType type, byte[] value) {\n        switch (type) {\n        case NULL:\n            return null;\n        case BIGINT:\n            return Longs.fromByteArray(value);\n        case STRING:\n            return new String(value, Charsets.UTF_8);\n        case INTEGER:\n            return Ints.fromByteArray(value);\n        case SMALLINT:\n            return Shorts.fromByteArray(value);\n        case TINYINT:\n            return value[0];\n        default:\n            throw new RuntimeException(\n                    \"TheHashinator#bytesToValue failed to convert a non-partitionable type.\");\n        }\n    }","id":106937,"modified_method":"/**\n     * Converts a byte array with type back to the original partition value.\n     * This is the inverse of {@see TheHashinator#valueToBytes(Object)}.\n     * @param type VoltType of partition parameter.\n     * @param value Byte array representation of partition parameter.\n     * @return Java object of the correct type.\n     */\n    public static Object bytesToValue(VoltType type, byte[] value) {\n        if ((type == VoltType.NULL) || (value == null)) {\n            return null;\n        }\n\n        ByteBuffer buf = ByteBuffer.wrap(value);\n        buf.order(ByteOrder.LITTLE_ENDIAN);\n\n        switch (type) {\n        case BIGINT:\n            return buf.getLong();\n        case STRING:\n            return new String(value, Charsets.UTF_8);\n        case INTEGER:\n            return buf.getInt();\n        case SMALLINT:\n            return buf.getShort();\n        case TINYINT:\n            return buf.get();\n        case VARBINARY:\n            return value;\n        default:\n            throw new RuntimeException(\n                    \"TheHashinator#bytesToValue failed to convert a non-partitionable type.\");\n        }\n    }","commit_id":"4dd7273c5b40b0c65018879c39ea7dbaabc7eda9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void executeGoal( String task, MavenSession session, MavenProject project, MavenExecutionResponse response )\n        throws LifecycleExecutionException, ArtifactNotFoundException, MojoExecutionException,\n        ArtifactResolutionException, MojoFailureException\n    {\n        if ( phases.contains( task ) )\n        {\n            // we have a lifecycle phase, so lets bind all the necessary goals\n            Map lifecycleMappings = constructLifecycleMappings( session, task, project );\n            executeGoalWithLifecycle( task, session, lifecycleMappings, project, response );\n        }\n        else\n        {\n            executeStandaloneGoal( task, session, project, response );\n        }\n    }","id":106938,"modified_method":"private void executeGoal( String task, MavenSession session, MavenProject project, MavenExecutionResponse response )\n        throws LifecycleExecutionException, ArtifactNotFoundException, MojoExecutionException,\n        ArtifactResolutionException, MojoFailureException\n    {\n        if ( getPhaseToLifecycleMap().containsKey( task ) )\n        {\n            Lifecycle lifecycle = getLifecycleForPhase( task );\n\n            // we have a lifecycle phase, so lets bind all the necessary goals\n            Map lifecycleMappings = constructLifecycleMappings( session, task, project, lifecycle );\n            executeGoalWithLifecycle( task, session, lifecycleMappings, project, response, lifecycle );\n        }\n        else\n        {\n            executeStandaloneGoal( task, session, project, response );\n        }\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private Map findMappingsForLifecycle( MavenSession session, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        String packaging = project.getPackaging();\n        LifecycleMapping m;\n\n        try\n        {\n            m = (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging, session.getSettings(),\n                                                  session.getLocalRepository() );\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException(\n                \"Cannot load extension plugin obtaining lifecycle mappings for: \\'\" + packaging + \"\\'.\", e );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException(\n                \"Cannot load extension plugin obtaining lifecycle mappings for: \\'\" + packaging + \"\\'.\", e );\n        }\n\n        if ( m == null )\n        {\n            try\n            {\n                m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new LifecycleExecutionException(\n                    \"Cannot find lifecycle mapping for packaging: \\'\" + packaging + \"\\'.\", e );\n            }\n        }\n\n        return m.getPhases();\n    }","id":106939,"modified_method":"private Map findMappingsForLifecycle( MavenSession session, MavenProject project, Lifecycle lifecycle )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        String packaging = project.getPackaging();\n        Map mappings = null;\n\n        try\n        {\n            LifecycleMapping m = (LifecycleMapping) findExtension( project, LifecycleMapping.ROLE, packaging,\n                                                                   session.getSettings(),\n                                                                   session.getLocalRepository() );\n            if ( m != null )\n            {\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n        }\n        catch ( PluginVersionResolutionException e )\n        {\n            throw new LifecycleExecutionException(\n                \"Cannot load extension plugin obtaining lifecycle mappings for: \\'\" + packaging + \"\\'.\", e );\n        }\n        catch ( PluginManagerException e )\n        {\n            throw new LifecycleExecutionException(\n                \"Cannot load extension plugin obtaining lifecycle mappings for: \\'\" + packaging + \"\\'.\", e );\n        }\n\n        Map defaultMappings = lifecycle.getDefaultPhases();\n\n        if ( mappings == null )\n        {\n            try\n            {\n                LifecycleMapping m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n                mappings = m.getPhases( lifecycle.getId() );\n            }\n            catch ( ComponentLookupException e )\n            {\n                if ( defaultMappings == null )\n                {\n                    throw new LifecycleExecutionException(\n                        \"Cannot find lifecycle mapping for packaging: \\'\" + packaging + \"\\'.\", e );\n                }\n            }\n        }\n\n        if ( mappings == null )\n        {\n            if ( defaultMappings == null )\n            {\n                throw new LifecycleExecutionException(\n                    \"Cannot find lifecycle mapping for packaging: \\'\" + packaging + \"\\', and there is no default\" );\n            }\n            else\n            {\n                mappings = defaultMappings;\n            }\n        }\n\n        return mappings;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private List processGoalChain( String task, Map phaseMap )\n    {\n        List goals = new ArrayList();\n\n        // only execute up to the given phase\n        int index = phases.indexOf( task );\n\n        for ( int i = 0; i <= index; i++ )\n        {\n            String p = (String) phases.get( i );\n\n            List phaseGoals = (List) phaseMap.get( p );\n\n            if ( phaseGoals != null )\n            {\n                goals.addAll( phaseGoals );\n            }\n        }\n        return goals;\n    }","id":106940,"modified_method":"private List processGoalChain( String task, Map phaseMap, Lifecycle lifecycle )\n    {\n        List goals = new ArrayList();\n\n        // only execute up to the given phase\n        int index = lifecycle.getPhases().indexOf( task );\n\n        for ( int i = 0; i <= index; i++ )\n        {\n            String p = (String) lifecycle.getPhases().get( i );\n\n            List phaseGoals = (List) phaseMap.get( p );\n\n            if ( phaseGoals != null )\n            {\n                goals.addAll( phaseGoals );\n            }\n        }\n        return goals;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project,\n                                              String invokedVia, boolean canUsePrefix )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        String goal;\n        Plugin plugin = null;\n\n        PluginDescriptor pluginDescriptor = null;\n\n        StringTokenizer tok = new StringTokenizer( task, \":\" );\n        int numTokens = tok.countTokens();\n\n        if ( numTokens == 2 )\n        {\n            if ( !canUsePrefix )\n            {\n                String msg = \"Mapped-prefix lookup of mojos are only supported from direct invocation. \" +\n                    \"Please use specification of the form groupId:artifactId[:version]:goal instead. \" +\n                    \"(Offending mojo: \\'\" + task + \"\\', invoked via: \\'\" + invokedVia + \"\\')\";\n                throw new LifecycleExecutionException( msg );\n            }\n\n            String prefix = tok.nextToken();\n            goal = tok.nextToken();\n\n            // Steps for retrieving the plugin model instance:\n            // 1. request directly from the plugin collector by prefix\n            pluginDescriptor = pluginManager.getPluginDescriptorForPrefix( prefix );\n\n            // 2. look in the repository via search groups\n            if ( pluginDescriptor == null )\n            {\n                try\n                {\n                    plugin = pluginManager.getPluginDefinitionForPrefix( prefix, session, project );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException(\n                        \"Cannot resolve plugin-prefix: \\'\" + prefix + \"\\' from plugin mappings metadata.\", e );\n                }\n            }\n            else\n            {\n                plugin = new Plugin();\n\n                plugin.setGroupId( pluginDescriptor.getGroupId() );\n                plugin.setArtifactId( pluginDescriptor.getArtifactId() );\n                plugin.setVersion( pluginDescriptor.getVersion() );\n            }\n\n            // 3. search plugins in the current POM\n            if ( plugin == null )\n            {\n                for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n                {\n                    Plugin buildPlugin = (Plugin) i.next();\n\n                    try\n                    {\n                        PluginDescriptor desc = pluginManager.verifyPlugin( buildPlugin, project, session.getSettings(),\n                                                                            session.getLocalRepository() );\n                        if ( prefix.equals( desc.getGoalPrefix() ) )\n                        {\n                            plugin = buildPlugin;\n                        }\n                    }\n                    catch ( PluginManagerException e )\n                    {\n                        throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n                    }\n                    catch ( PluginVersionResolutionException e )\n                    {\n                        throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n                    }\n                }\n            }\n\n            // 4. default to o.a.m.plugins and maven-<prefix>-plugin\n            if ( plugin == null )\n            {\n                plugin = new Plugin();\n                plugin.setGroupId( PluginDescriptor.getDefaultPluginGroupId() );\n                plugin.setArtifactId( PluginDescriptor.getDefaultPluginArtifactId( prefix ) );\n            }\n\n            for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n            {\n                Plugin buildPlugin = (Plugin) i.next();\n\n                if ( buildPlugin.getKey().equals( plugin.getKey() ) )\n                {\n                    plugin = buildPlugin;\n                    break;\n                }\n            }\n        }\n        else if ( numTokens == 3 || numTokens == 4 )\n        {\n            plugin = new Plugin();\n\n            plugin.setGroupId( tok.nextToken() );\n            plugin.setArtifactId( tok.nextToken() );\n\n            if ( numTokens == 4 )\n            {\n                plugin.setVersion( tok.nextToken() );\n            }\n\n            goal = tok.nextToken();\n        }\n        else\n        {\n            String message = \"Invalid task '\" + task + \"': you must specify a valid lifecycle phase, or\" +\n                \" a goal in the format plugin:goal or pluginGroupId:pluginArtifactId:pluginVersion:goal\";\n            throw new LifecycleExecutionException( message );\n        }\n\n        if ( pluginDescriptor == null )\n        {\n            try\n            {\n                pluginDescriptor = pluginManager.verifyPlugin( plugin, project, session.getSettings(),\n                                                               session.getLocalRepository() );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n            }\n        }\n\n        // this has been simplified from the old code that injected the plugin management stuff, since\n        // pluginManagement injection is now handled by the project method.\n        project.addPlugin( plugin );\n\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( goal );\n        if ( mojoDescriptor == null )\n        {\n            throw new LifecycleExecutionException( \"Required goal not found: \" + task );\n        }\n\n        return mojoDescriptor;\n    }","id":106941,"modified_method":"private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project,\n                                              String invokedVia, boolean canUsePrefix )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        String goal;\n        Plugin plugin;\n\n        PluginDescriptor pluginDescriptor = null;\n\n        StringTokenizer tok = new StringTokenizer( task, \":\" );\n        int numTokens = tok.countTokens();\n\n        if ( numTokens == 2 )\n        {\n            if ( !canUsePrefix )\n            {\n                String msg = \"Mapped-prefix lookup of mojos are only supported from direct invocation. \" +\n                    \"Please use specification of the form groupId:artifactId[:version]:goal instead. \" +\n                    \"(Offending mojo: \\'\" + task + \"\\', invoked via: \\'\" + invokedVia + \"\\')\";\n                throw new LifecycleExecutionException( msg );\n            }\n\n            String prefix = tok.nextToken();\n            goal = tok.nextToken();\n\n            // Steps for retrieving the plugin model instance:\n            // 1. request directly from the plugin collector by prefix\n            pluginDescriptor = pluginManager.getPluginDescriptorForPrefix( prefix );\n\n            // 2. look in the repository via search groups\n            if ( pluginDescriptor == null )\n            {\n                try\n                {\n                    plugin = pluginManager.getPluginDefinitionForPrefix( prefix, session, project );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new LifecycleExecutionException(\n                        \"Cannot resolve plugin-prefix: \\'\" + prefix + \"\\' from plugin mappings metadata.\", e );\n                }\n            }\n            else\n            {\n                plugin = new Plugin();\n\n                plugin.setGroupId( pluginDescriptor.getGroupId() );\n                plugin.setArtifactId( pluginDescriptor.getArtifactId() );\n                plugin.setVersion( pluginDescriptor.getVersion() );\n            }\n\n            // 3. search plugins in the current POM\n            if ( plugin == null )\n            {\n                for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n                {\n                    Plugin buildPlugin = (Plugin) i.next();\n\n                    try\n                    {\n                        PluginDescriptor desc = pluginManager.verifyPlugin( buildPlugin, project, session.getSettings(),\n                                                                            session.getLocalRepository() );\n                        if ( prefix.equals( desc.getGoalPrefix() ) )\n                        {\n                            plugin = buildPlugin;\n                        }\n                    }\n                    catch ( PluginManagerException e )\n                    {\n                        throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n                    }\n                    catch ( PluginVersionResolutionException e )\n                    {\n                        throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n                    }\n                }\n            }\n\n            // 4. default to o.a.m.plugins and maven-<prefix>-plugin\n            if ( plugin == null )\n            {\n                plugin = new Plugin();\n                plugin.setGroupId( PluginDescriptor.getDefaultPluginGroupId() );\n                plugin.setArtifactId( PluginDescriptor.getDefaultPluginArtifactId( prefix ) );\n            }\n\n            for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n            {\n                Plugin buildPlugin = (Plugin) i.next();\n\n                if ( buildPlugin.getKey().equals( plugin.getKey() ) )\n                {\n                    plugin = buildPlugin;\n                    break;\n                }\n            }\n        }\n        else if ( numTokens == 3 || numTokens == 4 )\n        {\n            plugin = new Plugin();\n\n            plugin.setGroupId( tok.nextToken() );\n            plugin.setArtifactId( tok.nextToken() );\n\n            if ( numTokens == 4 )\n            {\n                plugin.setVersion( tok.nextToken() );\n            }\n\n            goal = tok.nextToken();\n        }\n        else\n        {\n            String message = \"Invalid task '\" + task + \"': you must specify a valid lifecycle phase, or\" +\n                \" a goal in the format plugin:goal or pluginGroupId:pluginArtifactId:pluginVersion:goal\";\n            throw new LifecycleExecutionException( message );\n        }\n\n        if ( pluginDescriptor == null )\n        {\n            try\n            {\n                pluginDescriptor = pluginManager.verifyPlugin( plugin, project, session.getSettings(),\n                                                               session.getLocalRepository() );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n            }\n        }\n\n        // this has been simplified from the old code that injected the plugin management stuff, since\n        // pluginManagement injection is now handled by the project method.\n        project.addPlugin( plugin );\n\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( goal );\n        if ( mojoDescriptor == null )\n        {\n            throw new LifecycleExecutionException( \"Required goal not found: \" + task );\n        }\n\n        return mojoDescriptor;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private Map constructLifecycleMappings( MavenSession session, String selectedPhase, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        // first, bind those associated with the packaging\n        Map lifecycleMappings = bindLifecycleForPackaging( session, selectedPhase, project );\n\n        // next, loop over plugins and for any that have a phase, bind it\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            bindPluginToLifecycle( plugin, session, lifecycleMappings, project );\n        }\n\n        return lifecycleMappings;\n    }","id":106942,"modified_method":"private Map constructLifecycleMappings( MavenSession session, String selectedPhase, MavenProject project,\n                                            Lifecycle lifecycle )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        // first, bind those associated with the packaging\n        Map lifecycleMappings = bindLifecycleForPackaging( session, selectedPhase, project, lifecycle );\n\n        // next, loop over plugins and for any that have a phase, bind it\n        for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n        {\n            Plugin plugin = (Plugin) i.next();\n\n            bindPluginToLifecycle( plugin, session, lifecycleMappings, project );\n        }\n\n        return lifecycleMappings;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private void forkProjectLifecycle( MojoDescriptor mojoDescriptor, MavenSession session, MavenProject project,\n                                       MavenExecutionResponse response )\n        throws ArtifactResolutionException, LifecycleExecutionException, MojoExecutionException, MojoFailureException,\n        ArtifactNotFoundException\n    {\n        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n\n        String targetPhase = mojoDescriptor.getExecutePhase();\n\n        Map lifecycleMappings = null;\n        if ( targetPhase != null )\n        {\n            // Create new lifecycle\n            lifecycleMappings = constructLifecycleMappings( session, targetPhase, project );\n\n            String executeLifecycle = mojoDescriptor.getExecuteLifecycle();\n            if ( executeLifecycle != null )\n            {\n                Lifecycle lifecycleOverlay;\n                try\n                {\n                    lifecycleOverlay = pluginDescriptor.getLifecycleMapping( executeLifecycle );\n                }\n                catch ( IOException e )\n                {\n                    throw new LifecycleExecutionException( \"Unable to read lifecycle mapping file\", e );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new LifecycleExecutionException( \"Unable to parse lifecycle mapping file\", e );\n                }\n\n                if ( lifecycleOverlay == null )\n                {\n                    throw new LifecycleExecutionException( \"Lifecycle '\" + executeLifecycle + \"' not found in plugin\" );\n                }\n\n                for ( Iterator i = lifecycleOverlay.getPhases().iterator(); i.hasNext(); )\n                {\n                    Phase phase = (Phase) i.next();\n                    for ( Iterator j = phase.getExecutions().iterator(); j.hasNext(); )\n                    {\n                        Execution e = (Execution) j.next();\n\n                        for ( Iterator k = e.getGoals().iterator(); k.hasNext(); )\n                        {\n                            String goal = (String) k.next();\n                            MojoDescriptor desc = getMojoDescriptor( pluginDescriptor, goal );\n\n                            MojoExecution mojoExecution = new MojoExecution( desc, (Xpp3Dom) e.getConfiguration() );\n                            addToLifecycleMappings( lifecycleMappings, phase.getId(), mojoExecution,\n                                                    session.getSettings() );\n                        }\n                    }\n                }\n            }\n\n            removeFromLifecycle( mojoDescriptor, lifecycleMappings );\n        }\n\n        MavenProject executionProject = new MavenProject( project );\n        if ( targetPhase != null )\n        {\n            executeGoalWithLifecycle( targetPhase, session, lifecycleMappings, executionProject, response );\n        }\n        else\n        {\n            String goal = mojoDescriptor.getExecuteGoal();\n            MojoDescriptor desc = getMojoDescriptor( pluginDescriptor, goal );\n            executeGoals( Collections.singletonList( new MojoExecution( desc ) ), session, executionProject, response );\n        }\n        project.setExecutionProject( executionProject );\n    }","id":106943,"modified_method":"private void forkProjectLifecycle( MojoDescriptor mojoDescriptor, MavenSession session, MavenProject project,\n                                       MavenExecutionResponse response )\n        throws ArtifactResolutionException, LifecycleExecutionException, MojoExecutionException, MojoFailureException,\n        ArtifactNotFoundException\n    {\n        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n\n        String targetPhase = mojoDescriptor.getExecutePhase();\n\n        Map lifecycleMappings = null;\n        if ( targetPhase != null )\n        {\n            Lifecycle lifecycle = getLifecycleForPhase( targetPhase );\n\n            // Create new lifecycle\n            lifecycleMappings = constructLifecycleMappings( session, targetPhase, project, lifecycle );\n\n            String executeLifecycle = mojoDescriptor.getExecuteLifecycle();\n            if ( executeLifecycle != null )\n            {\n                org.apache.maven.plugin.lifecycle.Lifecycle lifecycleOverlay;\n                try\n                {\n                    lifecycleOverlay = pluginDescriptor.getLifecycleMapping( executeLifecycle );\n                }\n                catch ( IOException e )\n                {\n                    throw new LifecycleExecutionException( \"Unable to read lifecycle mapping file\", e );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new LifecycleExecutionException( \"Unable to parse lifecycle mapping file\", e );\n                }\n\n                if ( lifecycleOverlay == null )\n                {\n                    throw new LifecycleExecutionException( \"Lifecycle '\" + executeLifecycle + \"' not found in plugin\" );\n                }\n\n                for ( Iterator i = lifecycleOverlay.getPhases().iterator(); i.hasNext(); )\n                {\n                    Phase phase = (Phase) i.next();\n                    for ( Iterator j = phase.getExecutions().iterator(); j.hasNext(); )\n                    {\n                        Execution e = (Execution) j.next();\n\n                        for ( Iterator k = e.getGoals().iterator(); k.hasNext(); )\n                        {\n                            String goal = (String) k.next();\n                            MojoDescriptor desc = getMojoDescriptor( pluginDescriptor, goal );\n\n                            MojoExecution mojoExecution = new MojoExecution( desc, (Xpp3Dom) e.getConfiguration() );\n                            addToLifecycleMappings( lifecycleMappings, phase.getId(), mojoExecution,\n                                                    session.getSettings() );\n                        }\n                    }\n                }\n            }\n\n            removeFromLifecycle( mojoDescriptor, lifecycleMappings );\n        }\n\n        MavenProject executionProject = new MavenProject( project );\n        if ( targetPhase != null )\n        {\n            Lifecycle lifecycle = getLifecycleForPhase( targetPhase );\n\n            executeGoalWithLifecycle( targetPhase, session, lifecycleMappings, executionProject, response, lifecycle );\n        }\n        else\n        {\n            String goal = mojoDescriptor.getExecuteGoal();\n            MojoDescriptor desc = getMojoDescriptor( pluginDescriptor, goal );\n            executeGoals( Collections.singletonList( new MojoExecution( desc ) ), session, executionProject, response );\n        }\n        project.setExecutionProject( executionProject );\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private void executeGoalWithLifecycle( String task, MavenSession session, Map lifecycleMappings,\n                                           MavenProject project, MavenExecutionResponse response )\n        throws ArtifactResolutionException, LifecycleExecutionException, MojoExecutionException, MojoFailureException,\n        ArtifactNotFoundException\n    {\n        List goals = processGoalChain( task, lifecycleMappings );\n\n        executeGoals( goals, session, project, response );\n    }","id":106944,"modified_method":"private void executeGoalWithLifecycle( String task, MavenSession session, Map lifecycleMappings,\n                                           MavenProject project, MavenExecutionResponse response, Lifecycle lifecycle )\n        throws ArtifactResolutionException, LifecycleExecutionException, MojoExecutionException, MojoFailureException,\n        ArtifactNotFoundException\n    {\n        List goals = processGoalChain( task, lifecycleMappings, lifecycle );\n\n        executeGoals( goals, session, project, response );\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private List segmentTaskListByAggregationNeeds( List tasks, MavenSession session, MavenProject project )\n        throws LifecycleExecutionException\n    {\n        List segments = new ArrayList();\n\n        if ( project != null )\n        {\n\n            TaskSegment currentSegment = null;\n            for ( Iterator it = tasks.iterator(); it.hasNext(); )\n            {\n                String task = (String) it.next();\n\n                // if it's a phase, then we don't need to check whether it's an aggregator.\n                // simply add it to the current task partition.\n                if ( phases.contains( task ) )\n                {\n                    if ( currentSegment != null && currentSegment.aggregate() )\n                    {\n                        segments.add( currentSegment );\n                        currentSegment = null;\n                    }\n\n                    if ( currentSegment == null )\n                    {\n                        currentSegment = new TaskSegment();\n                    }\n\n                    currentSegment.add( task );\n                }\n                else\n                {\n                    MojoDescriptor mojo = null;\n                    try\n                    {\n                        // definitely a CLI goal, can use prefix\n                        mojo = getMojoDescriptor( task, session, project, task, true );\n                    }\n                    catch ( ArtifactResolutionException e )\n                    {\n                        getLogger().info(\n                            \"Cannot find mojo descriptor for: \\'\" + task + \"\\' - Treating as non-aggregator.\" );\n                        getLogger().debug( \"\", e );\n                    }\n                    catch ( ArtifactNotFoundException e )\n                    {\n                        getLogger().info(\n                            \"Cannot find mojo descriptor for: \\'\" + task + \"\\' - Treating as non-aggregator.\" );\n                        getLogger().debug( \"\", e );\n                    }\n\n                    // if the mojo descriptor was found, determine aggregator status according to:\n                    // 1. whether the mojo declares itself an aggregator\n                    // 2. whether the mojo DOES NOT require a project to function (implicitly avoid reactor)\n                    if ( mojo != null && ( mojo.isAggregator() || !mojo.isProjectRequired() ) )\n                    {\n                        if ( currentSegment != null && !currentSegment.aggregate() )\n                        {\n                            segments.add( currentSegment );\n                            currentSegment = null;\n                        }\n\n                        if ( currentSegment == null )\n                        {\n                            currentSegment = new TaskSegment( true );\n                        }\n\n                        currentSegment.add( task );\n                    }\n                    else\n                    {\n                        if ( currentSegment != null && currentSegment.aggregate() )\n                        {\n                            segments.add( currentSegment );\n                            currentSegment = null;\n                        }\n\n                        if ( currentSegment == null )\n                        {\n                            currentSegment = new TaskSegment();\n                        }\n\n                        currentSegment.add( task );\n                    }\n                }\n            }\n\n            segments.add( currentSegment );\n        }\n        else\n        {\n            TaskSegment segment = new TaskSegment( false );\n            for ( Iterator i = tasks.iterator(); i.hasNext(); )\n            {\n                segment.add( (String) i.next() );\n            }\n            segments.add( segment );\n        }\n\n        return segments;\n    }","id":106945,"modified_method":"private List segmentTaskListByAggregationNeeds( List tasks, MavenSession session, MavenProject project )\n        throws LifecycleExecutionException\n    {\n        List segments = new ArrayList();\n\n        if ( project != null )\n        {\n\n            TaskSegment currentSegment = null;\n            for ( Iterator it = tasks.iterator(); it.hasNext(); )\n            {\n                String task = (String) it.next();\n\n                // if it's a phase, then we don't need to check whether it's an aggregator.\n                // simply add it to the current task partition.\n                if ( getPhaseToLifecycleMap().containsKey( task ) )\n                {\n                    if ( currentSegment != null && currentSegment.aggregate() )\n                    {\n                        segments.add( currentSegment );\n                        currentSegment = null;\n                    }\n\n                    if ( currentSegment == null )\n                    {\n                        currentSegment = new TaskSegment();\n                    }\n\n                    currentSegment.add( task );\n                }\n                else\n                {\n                    MojoDescriptor mojo = null;\n                    try\n                    {\n                        // definitely a CLI goal, can use prefix\n                        mojo = getMojoDescriptor( task, session, project, task, true );\n                    }\n                    catch ( ArtifactResolutionException e )\n                    {\n                        getLogger().info(\n                            \"Cannot find mojo descriptor for: \\'\" + task + \"\\' - Treating as non-aggregator.\" );\n                        getLogger().debug( \"\", e );\n                    }\n                    catch ( ArtifactNotFoundException e )\n                    {\n                        getLogger().info(\n                            \"Cannot find mojo descriptor for: \\'\" + task + \"\\' - Treating as non-aggregator.\" );\n                        getLogger().debug( \"\", e );\n                    }\n\n                    // if the mojo descriptor was found, determine aggregator status according to:\n                    // 1. whether the mojo declares itself an aggregator\n                    // 2. whether the mojo DOES NOT require a project to function (implicitly avoid reactor)\n                    if ( mojo != null && ( mojo.isAggregator() || !mojo.isProjectRequired() ) )\n                    {\n                        if ( currentSegment != null && !currentSegment.aggregate() )\n                        {\n                            segments.add( currentSegment );\n                            currentSegment = null;\n                        }\n\n                        if ( currentSegment == null )\n                        {\n                            currentSegment = new TaskSegment( true );\n                        }\n\n                        currentSegment.add( task );\n                    }\n                    else\n                    {\n                        if ( currentSegment != null && currentSegment.aggregate() )\n                        {\n                            segments.add( currentSegment );\n                            currentSegment = null;\n                        }\n\n                        if ( currentSegment == null )\n                        {\n                            currentSegment = new TaskSegment();\n                        }\n\n                        currentSegment.add( task );\n                    }\n                }\n            }\n\n            segments.add( currentSegment );\n        }\n        else\n        {\n            TaskSegment segment = new TaskSegment( false );\n            for ( Iterator i = tasks.iterator(); i.hasNext(); )\n            {\n                segment.add( (String) i.next() );\n            }\n            segments.add( segment );\n        }\n\n        return segments;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"private Map bindLifecycleForPackaging( MavenSession session, String selectedPhase, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        Map mappings = findMappingsForLifecycle( session, project );\n\n        Map lifecycleMappings = new HashMap();\n\n        for ( Iterator i = phases.iterator(); i.hasNext(); )\n        {\n            String phase = (String) i.next();\n\n            String phaseTasks = (String) mappings.get( phase );\n\n            if ( phaseTasks != null )\n            {\n                for ( StringTokenizer tok = new StringTokenizer( phaseTasks, \",\" ); tok.hasMoreTokens(); )\n                {\n                    String goal = tok.nextToken().trim();\n\n                    // Not from the CLI, don't use prefix\n                    MojoDescriptor mojoDescriptor = getMojoDescriptor( goal, session, project, selectedPhase, false );\n\n                    if ( mojoDescriptor.isDirectInvocationOnly() )\n                    {\n                        throw new LifecycleExecutionException( \"Mojo: \\'\" + goal +\n                            \"\\' requires direct invocation. It cannot be used as part of lifecycle: \\'\" +\n                            project.getPackaging() + \"\\'.\" );\n                    }\n\n                    addToLifecycleMappings( lifecycleMappings, phase, new MojoExecution( mojoDescriptor ),\n                                            session.getSettings() );\n                }\n            }\n\n            if ( phase.equals( selectedPhase ) )\n            {\n                break;\n            }\n        }\n\n        return lifecycleMappings;\n    }","id":106946,"modified_method":"private Map bindLifecycleForPackaging( MavenSession session, String selectedPhase, MavenProject project,\n                                           Lifecycle lifecycle )\n        throws ArtifactResolutionException, LifecycleExecutionException, ArtifactNotFoundException\n    {\n        Map mappings = findMappingsForLifecycle( session, project, lifecycle );\n\n        Map lifecycleMappings = new HashMap();\n\n        for ( Iterator i = lifecycle.getPhases().iterator(); i.hasNext(); )\n        {\n            String phase = (String) i.next();\n\n            String phaseTasks = (String) mappings.get( phase );\n\n            if ( phaseTasks != null )\n            {\n                for ( StringTokenizer tok = new StringTokenizer( phaseTasks, \",\" ); tok.hasMoreTokens(); )\n                {\n                    String goal = tok.nextToken().trim();\n\n                    // Not from the CLI, don't use prefix\n                    MojoDescriptor mojoDescriptor = getMojoDescriptor( goal, session, project, selectedPhase, false );\n\n                    if ( mojoDescriptor.isDirectInvocationOnly() )\n                    {\n                        throw new LifecycleExecutionException( \"Mojo: \\'\" + goal +\n                            \"\\' requires direct invocation. It cannot be used as part of lifecycle: \\'\" +\n                            project.getPackaging() + \"\\'.\" );\n                    }\n\n                    addToLifecycleMappings( lifecycleMappings, phase, new MojoExecution( mojoDescriptor ),\n                                            session.getSettings() );\n                }\n            }\n\n            if ( phase.equals( selectedPhase ) )\n            {\n                break;\n            }\n        }\n\n        return lifecycleMappings;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"public Map getPhases()\n    {\n        return phases;\n    }","id":106947,"modified_method":"public Map getPhases( String lifecycle )\n    {\n        if ( lifecycleMap == null )\n        {\n            lifecycleMap = new HashMap();\n\n            for ( Iterator i = lifecycles.iterator(); i.hasNext(); )\n            {\n                Lifecycle l = (Lifecycle) i.next();\n                lifecycleMap.put( l.getId(), l );\n            }\n        }\n        Lifecycle l = (Lifecycle) lifecycleMap.get( lifecycle );\n        return l != null ? l.getPhases() : null;\n    }","commit_id":"ae98e4f4b8892ae85d71bccd7e20ef558856262a","url":"https://github.com/apache/maven"},{"original_method":"protected File getAppServerDir(\n\t\tLiferayExtension liferayExtension, String dirNameKey) {\n\n\t\tFile appServerDir = liferayExtension.getAppServerDir();\n\n\t\tString dirName = getAppServerProperty(\n\t\t\tliferayExtension, liferayExtension.getAppServerType(), dirNameKey);\n\n\t\treturn new File(appServerDir, dirName);\n\t}","id":106948,"modified_method":"protected File getAppServerDir(\n\t\tLiferayExtension liferayExtension, File appServerDir,\n\t\tString dirNameKey) {\n\n\t\tString dirName = getAppServerProperty(\n\t\t\tliferayExtension, liferayExtension.getAppServerType(), dirNameKey);\n\n\t\treturn new File(appServerDir, dirName);\n\t}","commit_id":"2cbf23c7067b33ecb2dab1956998cff7377fa95b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureLiferayExtension(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tFile appServerParentDir = liferayExtension.getAppServerParentDir();\n\t\tString appServerType = liferayExtension.getAppServerType();\n\n\t\tif ((appServerParentDir == null) || Validator.isNull(appServerType)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile appServerDir = liferayExtension.getAppServerDir();\n\n\t\tif (appServerDir == null) {\n\t\t\tString appServerName = getAppServerProperty(\n\t\t\t\tliferayExtension, appServerType, \"name\");\n\t\t\tString appServerVersion = getAppServerProperty(\n\t\t\t\tliferayExtension, appServerType, \"version\");\n\n\t\t\tappServerDir = new File(\n\t\t\t\tappServerParentDir, appServerName + \"-\" + appServerVersion);\n\n\t\t\tliferayExtension.setAppServerDir(appServerDir);\n\t\t}\n\n\t\tliferayExtension.setAppServerDeployDir(\n\t\t\tgetAppServerDir(liferayExtension, \"deployDirName\"));\n\t\tliferayExtension.setAppServerLibGlobalDir(\n\t\t\tgetAppServerDir(liferayExtension, \"libGlobalDirName\"));\n\t\tliferayExtension.setAppServerPortalDir(\n\t\t\tgetAppServerDir(liferayExtension, \"portalDirName\"));\n\t}","id":106949,"modified_method":"protected void configureLiferayExtension(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tFile appServerParentDir = liferayExtension.getAppServerParentDir();\n\t\tString appServerType = liferayExtension.getAppServerType();\n\n\t\tif ((appServerParentDir == null) || Validator.isNull(appServerType)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile appServerDir = liferayExtension.getAppServerDir();\n\n\t\tif (appServerDir == null) {\n\t\t\tString appServerName = getAppServerProperty(\n\t\t\t\tliferayExtension, appServerType, \"name\");\n\t\t\tString appServerVersion = getAppServerProperty(\n\t\t\t\tliferayExtension, appServerType, \"version\");\n\n\t\t\tappServerDir = new File(\n\t\t\t\tappServerParentDir, appServerName + \"-\" + appServerVersion);\n\n\t\t\tliferayExtension.setAppServerDir(appServerDir);\n\t\t}\n\n\t\tif (liferayExtension.getAppServerDeployDir() == null) {\n\t\t\tFile appServerDeployDir = getAppServerDir(\n\t\t\t\tliferayExtension, appServerDir, \"deployDirName\");\n\n\t\t\tliferayExtension.setAppServerDeployDir(appServerDeployDir);\n\t\t}\n\n\t\tif (liferayExtension.getAppServerLibGlobalDir() == null) {\n\t\t\tFile appServerLibGlobalDir = getAppServerDir(\n\t\t\t\tliferayExtension, appServerDir, \"libGlobalDirName\");\n\n\t\t\tliferayExtension.setAppServerLibGlobalDir(appServerLibGlobalDir);\n\t\t}\n\n\t\tif (liferayExtension.getAppServerPortalDir() == null) {\n\t\t\tFile appServerPortalDir = getAppServerDir(\n\t\t\t\tliferayExtension, appServerDir, \"portalDirName\");\n\n\t\t\tliferayExtension.setAppServerPortalDir(appServerPortalDir);\n\t\t}\n\n\t\tif (liferayExtension.getDeployDir() == null) {\n\t\t\tFile deployDir = new File(appServerParentDir, \"deploy\");\n\n\t\t\tliferayExtension.setDeployDir(deployDir);\n\t\t}\n\t}","commit_id":"2cbf23c7067b33ecb2dab1956998cff7377fa95b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void configureTasks(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.configureTasks(project, liferayExtension);\n\n\t\tconfigureTaskDirectDeploy(project, liferayExtension);\n\t\tconfigureTaskWar(project, liferayExtension);\n\t}","id":106950,"modified_method":"@Override\n\tprotected void configureTasks(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.configureTasks(project, liferayExtension);\n\n\t\tconfigureTaskDeploy(project, liferayExtension);\n\t\tconfigureTaskDirectDeploy(project, liferayExtension);\n\t\tconfigureTaskWar(project, liferayExtension);\n\t}","commit_id":"2cbf23c7067b33ecb2dab1956998cff7377fa95b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void addTasks(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.addTasks(project, liferayExtension);\n\n\t\taddTaskDirectDeploy(project);\n\t}","id":106951,"modified_method":"@Override\n\tprotected void addTasks(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.addTasks(project, liferayExtension);\n\n\t\taddTaskDeploy(project);\n\t\taddTaskDirectDeploy(project);\n\t}","commit_id":"2cbf23c7067b33ecb2dab1956998cff7377fa95b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static NativeOsmandLibrary getLibrary(RenderingRulesStorage storage) {\n\t\tif (!isLoaded()) {\n\t\t\tsynchronized (NativeOsmandLibrary.class) {\n\t\t\t\tif (!isLoaded()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.debug(\"Loading native gnustl_shared...\"); //$NON-NLS-1$\n\t\t\t\t\t\tSystem.loadLibrary(\"gnustl_shared\");\n\t\t\t\t\t\tlog.debug(\"Loading native cpufeatures_proxy...\"); //$NON-NLS-1$\n\t\t\t\t\t\tSystem.loadLibrary(\"cpufeatures_proxy\");\n\t\t\t\t\t\tif (PlatformUtil.AVIAN_LIBRARY) {\n\t\t\t\t\t\t\tlog.debug(\"Loading load routing test...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"routing_test\");\n\t\t\t\t\t\t\ttestRoutingPing();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(android.os.Build.VERSION.SDK_INT >= 8) {\n\t\t\t\t\t\t\tlog.debug(\"Loading jnigraphics, since Android >= 2.2 ...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"jnigraphics\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!cpuHasNeonSupport()) {\n\t\t\t\t\t\t\tlog.debug(\"Loading native osmand...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"osmand\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.debug(\"Loading native osmand with NEON...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"osmand_neon\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog.debug(\"Creating NativeOsmandLibrary instance...\"); //$NON-NLS-1$\n\t\t\t\t\t\tlibrary = new NativeOsmandLibrary();\n\t\t\t\t\t\tlog.debug(\"Initializing rendering rules storage...\"); //$NON-NLS-1$\n\t\t\t\t\t\tNativeOsmandLibrary.initRenderingRulesStorage(storage);\n\t\t\t\t\t\tisNativeSupported = true;\n\t\t\t\t\t\tlog.debug(\"Native library loaded successfully\"); //$NON-NLS-1$\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlog.error(\"Failed to load native library\", e); //$NON-NLS-1$\n\t\t\t\t\t\tisNativeSupported = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn library;\n\t}","id":106952,"modified_method":"public static NativeOsmandLibrary getLibrary(RenderingRulesStorage storage) {\n\t\tif (!isLoaded()) {\n\t\t\tsynchronized (NativeOsmandLibrary.class) {\n\t\t\t\tif (!isLoaded()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.debug(\"Loading native gnustl_shared...\"); //$NON-NLS-1$\n\t\t\t\t\t\tSystem.loadLibrary(\"gnustl_shared\");\n\t\t\t\t\t\tlog.debug(\"Loading native cpufeatures_proxy...\"); //$NON-NLS-1$\n\t\t\t\t\t\tSystem.loadLibrary(\"cpufeatures_proxy\");\n\t\t\t\t\t\t/*(if (PlatformUtil.AVIAN_LIBRARY) {\n\t\t\t\t\t\t\tlog.debug(\"Loading load routing test...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"routing_test\");\n\t\t\t\t\t\t\ttestRoutingPing();\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tif(android.os.Build.VERSION.SDK_INT >= 8) {\n\t\t\t\t\t\t\tlog.debug(\"Loading jnigraphics, since Android >= 2.2 ...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"jnigraphics\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!cpuHasNeonSupport()) {\n\t\t\t\t\t\t\tlog.debug(\"Loading native osmand...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Core\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Network\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Concurrent\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Sql\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Xml\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"osmand\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.debug(\"Loading native osmand with NEON...\"); //$NON-NLS-1$\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Core_neon\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Network_neon\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Concurrent_neon\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Sql_neon\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"Qt5Xml_neon\");\n\t\t\t\t\t\t\tSystem.loadLibrary(\"osmand_neon\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog.debug(\"Creating NativeOsmandLibrary instance...\"); //$NON-NLS-1$\n\t\t\t\t\t\tlibrary = new NativeOsmandLibrary();\n\t\t\t\t\t\tlog.debug(\"Initializing rendering rules storage...\"); //$NON-NLS-1$\n\t\t\t\t\t\tNativeOsmandLibrary.initRenderingRulesStorage(storage);\n\t\t\t\t\t\tisNativeSupported = true;\n\t\t\t\t\t\tlog.debug(\"Native library loaded successfully\"); //$NON-NLS-1$\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlog.error(\"Failed to load native library\", e); //$NON-NLS-1$\n\t\t\t\t\t\tisNativeSupported = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn library;\n\t}","commit_id":"b756ec829fa4bed0f8794e5282713a91fcf366e6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Rectangle getContainingRectangle() {\n    int minX = Integer.MAX_VALUE;\n    int minY = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    int maxY = Integer.MIN_VALUE;\n    for (Rectangle nodeRect : Sequence.fromIterable(MapSequence.fromMap(myNodeLayout).values())) {\n      minX = Math.min(minX, nodeRect.x);\n      minY = Math.min(minY, nodeRect.y);\n      maxX = Math.max(maxX, nodeRect.x + nodeRect.width);\n      maxY = Math.max(maxY, nodeRect.x + nodeRect.height);\n    }\n    for (List<Point> path : Sequence.fromIterable(MapSequence.fromMap(myEdgeLayout).values())) {\n      for (Point p : ListSequence.fromList(path)) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n      }\n    }\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n  }","id":106953,"modified_method":"public Rectangle getContainingRectangle() {\n    int minX = Integer.MAX_VALUE;\n    int minY = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    int maxY = Integer.MIN_VALUE;\n    for (Rectangle rect : Sequence.fromIterable(MapSequence.fromMap(myNodeLayout).values()).concat(Sequence.fromIterable(MapSequence.fromMap(myLabelLayout).values()))) {\n      minX = Math.min(minX, rect.x);\n      minY = Math.min(minY, rect.y);\n      maxX = Math.max(maxX, rect.x + rect.width);\n      maxY = Math.max(maxY, rect.x + rect.height);\n    }\n    for (List<Point> path : Sequence.fromIterable(MapSequence.fromMap(myEdgeLayout).values())) {\n      for (Point p : ListSequence.fromList(path)) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n      }\n    }\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GraphLayout(Graph graph) {\n    myGraph = graph;\n    myNodeLayout = MapSequence.fromMap(new HashMap<Node, Rectangle>());\n    myEdgeLayout = MapSequence.fromMap(new HashMap<Edge, List<Point>>());\n  }","id":106954,"modified_method":"public GraphLayout(Graph graph) {\n    myGraph = graph;\n    myNodeLayout = MapSequence.fromMap(new HashMap<Node, Rectangle>());\n    myEdgeLayout = MapSequence.fromMap(new HashMap<Edge, List<Point>>());\n    myLabelLayout = MapSequence.fromMap(new HashMap<Edge, Rectangle>());\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void paint(GraphLayout layout, Graphics g) {\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      Iterator<Point> itr = ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge)).iterator();\n      Point cur = itr.next();\n      while (itr.hasNext()) {\n        Point next = itr.next();\n        g.drawLine(cur.x, cur.y, next.x, next.y);\n        cur = next;\n      }\n    }\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      g.drawRect(rect.x, rect.y, rect.width, rect.height);\n      g.drawString(Integer.toString(node.getIndex()), rect.x + 5, rect.y + 15);\n    }\n  }","id":106955,"modified_method":"public void paint(GraphLayout layout, Graphics g) {\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      Iterator<Point> itr = ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge)).iterator();\n      Point cur = itr.next();\n      while (itr.hasNext()) {\n        Point next = itr.next();\n        g.drawLine(cur.x, cur.y, next.x, next.y);\n        cur = next;\n      }\n    }\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      g.drawRect(rect.x, rect.y, rect.width, rect.height);\n      g.drawString(node.toString(), rect.x + 5, rect.y + 15);\n    }\n    Map<Edge, Rectangle> labelLayout = layout.getLabelLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(labelLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(labelLayout).get(edge);\n      g.drawRect(rect.x, rect.y, rect.width, rect.height);\n      g.drawString(edge.toString(), rect.x + 5, rect.y + 12);\n    }\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static GraphLayout shift(GraphLayout layout, int xShift, int yShift) {\n    GraphLayout newLayout = new GraphLayout(layout.getGraph());\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      int newX = rect.x + xShift;\n      int newY = rect.y + yShift;\n      newLayout.setLayoutFor(node, new Rectangle(newX, newY, rect.width, rect.height));\n    }\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      List<Point> newList = ListSequence.fromList(new ArrayList<Point>());\n      for (Point p : ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge))) {\n        ListSequence.fromList(newList).addElement(new Point(p.x + xShift, p.y + yShift));\n      }\n      newLayout.setLayoutFor(edge, newList);\n    }\n    return newLayout;\n  }","id":106956,"modified_method":"public static GraphLayout shift(GraphLayout layout, int xShift, int yShift) {\n    GraphLayout newLayout = new GraphLayout(layout.getGraph());\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      int newX = rect.x + xShift;\n      int newY = rect.y + yShift;\n      newLayout.setLayoutFor(node, new Rectangle(newX, newY, rect.width, rect.height));\n    }\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      List<Point> newList = ListSequence.fromList(new ArrayList<Point>());\n      for (Point p : ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge))) {\n        ListSequence.fromList(newList).addElement(new Point(p.x + xShift, p.y + yShift));\n      }\n      newLayout.setLayoutFor(edge, newList);\n    }\n    Map<Edge, Rectangle> labelLayout = layout.getLabelLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(labelLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(labelLayout).get(edge);\n      int newX = rect.x + xShift;\n      int newY = rect.y + yShift;\n      newLayout.setLabelLayout(edge, new Rectangle(newX, newY, rect.width, rect.height));\n    }\n    return newLayout;\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static GraphLayout scale(GraphLayout layout, double xScale, double yScale) {\n    GraphLayout newLayout = new GraphLayout(layout.getGraph());\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      int newX = (int) (rect.x * xScale);\n      int newY = (int) (rect.y * yScale);\n      int newWidth = (int) (rect.width * xScale);\n      int newHeight = (int) (rect.height * yScale);\n      newLayout.setLayoutFor(node, new Rectangle(newX, newY, newWidth, newHeight));\n    }\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      List<Point> newList = ListSequence.fromList(new ArrayList<Point>());\n      for (Point p : ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge))) {\n        ListSequence.fromList(newList).addElement(new Point((int) (p.x * xScale), (int) (p.y * yScale)));\n      }\n      newLayout.setLayoutFor(edge, newList);\n    }\n    return newLayout;\n  }","id":106957,"modified_method":"public static GraphLayout scale(GraphLayout layout, double xScale, double yScale) {\n    GraphLayout newLayout = new GraphLayout(layout.getGraph());\n    Map<Node, Rectangle> nodeLayout = layout.getNodeLayout();\n    for (Node node : SetSequence.fromSet(MapSequence.fromMap(nodeLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(nodeLayout).get(node);\n      int newX = (int) (rect.x * xScale);\n      int newY = (int) (rect.y * yScale);\n      int newWidth = (int) (rect.width * xScale);\n      int newHeight = (int) (rect.height * yScale);\n      newLayout.setLayoutFor(node, new Rectangle(newX, newY, newWidth, newHeight));\n    }\n    Map<Edge, List<Point>> edgeLayout = layout.getEdgeLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(edgeLayout).keySet())) {\n      List<Point> newList = ListSequence.fromList(new ArrayList<Point>());\n      for (Point p : ListSequence.fromList(MapSequence.fromMap(edgeLayout).get(edge))) {\n        ListSequence.fromList(newList).addElement(new Point((int) (p.x * xScale), (int) (p.y * yScale)));\n      }\n      newLayout.setLayoutFor(edge, newList);\n    }\n    Map<Edge, Rectangle> labelLayout = layout.getLabelLayout();\n    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(labelLayout).keySet())) {\n      Rectangle rect = MapSequence.fromMap(labelLayout).get(edge);\n      int newX = (int) (rect.x * xScale);\n      int newY = (int) (rect.y * yScale);\n      int newWidth = (int) (rect.width * xScale);\n      int newHeight = (int) (rect.height * yScale);\n      newLayout.setLabelLayout(edge, new Rectangle(newX, newY, newWidth, newHeight));\n    }\n    return newLayout;\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void layoutGraph() {\n    myLayouter.setLayoutLevel(myLayoutChoice.getSelectedLayoutLavel());\n    Scanner scanner = new Scanner(myTextArea.getText());\n    Map<Node, Dimension> nodeDimensions = MapSequence.fromMap(new HashMap<Node, Dimension>());\n    Graph g = null;\n    try {\n      g = GraphIO.scanGraph(scanner);\n      while (scanner.hasNextInt()) {\n        Node node = g.getNode(scanner.nextInt());\n        MapSequence.fromMap(nodeDimensions).put(node, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n    } catch (IllegalArgumentException e) {\n      JOptionPane.showMessageDialog(this, \"something is wrong in graph...\");\n    }\n    if (g != null) {\n      for (Node node : ListSequence.fromList(g.getNodes())) {\n        if (MapSequence.fromMap(nodeDimensions).get(node) == null) {\n          MapSequence.fromMap(nodeDimensions).put(node, new Dimension(DEFAULT_NODE_SIZE, DEFAULT_NODE_SIZE));\n        }\n      }\n      myCurrentLayout = myLayouter.doLayout(g, nodeDimensions);\n    }\n  }","id":106958,"modified_method":"private void layoutGraph() {\n    myLayouter.setLayoutLevel(myLayoutChoice.getSelectedLayoutLavel());\n    Scanner scanner = new Scanner(myTextArea.getText());\n    Map<Node, Dimension> nodeDimensions = MapSequence.fromMap(new HashMap<Node, Dimension>());\n    Map<Edge, Dimension> edgeDimensions = MapSequence.fromMap(new HashMap<Edge, Dimension>());\n    Graph g = null;\n    try {\n      g = GraphIO.scanGraph(scanner);\n      while (scanner.hasNextInt()) {\n        Node node = g.getNode(scanner.nextInt());\n        MapSequence.fromMap(nodeDimensions).put(node, new Dimension(scanner.nextInt(), scanner.nextInt()));\n      }\n    } catch (IllegalArgumentException e) {\n      JOptionPane.showMessageDialog(this, \"something is wrong in graph...\");\n    }\n    if (g != null) {\n      for (Node node : ListSequence.fromList(g.getNodes())) {\n        if (MapSequence.fromMap(nodeDimensions).get(node) == null) {\n          MapSequence.fromMap(nodeDimensions).put(node, new Dimension(DEFAULT_NODE_SIZE, DEFAULT_NODE_SIZE));\n        }\n      }\n      for (Edge edge : ListSequence.fromList(g.getEdges())) {\n        if (MapSequence.fromMap(edgeDimensions).get(edge) == null) {\n          MapSequence.fromMap(edgeDimensions).put(edge, new Dimension(DEFAULT_EDGE_X_SIZE, DEFAULT_EDGE_Y_SIZE));\n        }\n      }\n      myCurrentLayout = myLayouter.doLayout(g, nodeDimensions, edgeDimensions);\n    }\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeTempObjects(List<Edge> oldEdges, EmbeddedGraph embeddedGraph, GraphLayout graphLayout, Graph graph, Node addedNode) {\n    Set<Node> visited = SetSequence.fromSet(new HashSet<Node>());\n    for (Edge oldEdge : ListSequence.fromList(oldEdges)) {\n      List<Edge> history = embeddedGraph.findFullHistory(oldEdge);\n      System.out.println(\"history for edfe\" + oldEdge + \":\\n\" + history);\n      Node cur = oldEdge.getSource();\n      if (!(ListSequence.fromList(ListSequence.fromList(history).first().getAdjacentNodes()).contains(cur))) {\n        history = ListSequence.fromList(history).reversedList();\n      }\n      if (ListSequence.fromList(history).count() > 1) {\n        List<Point> oldEdgeLayout = ListSequence.fromList(new ArrayList<Point>());\n        List<Point> sourceHistoryPath = graphLayout.getLayoutFor(ListSequence.fromList(history).first());\n        Point sourcePoint;\n        if (ListSequence.fromList(history).first().getSource() == oldEdge.getSource()) {\n          sourcePoint = new Point(ListSequence.fromList(sourceHistoryPath).first());\n        } else {\n          sourcePoint = new Point(ListSequence.fromList(sourceHistoryPath).last());\n        }\n        List<Point> targetHistoryPath = graphLayout.getLayoutFor(ListSequence.fromList(history).last());\n        Point targetPoint;\n        if (ListSequence.fromList(history).last().getTarget() == oldEdge.getTarget()) {\n          targetPoint = new Point(ListSequence.fromList(targetHistoryPath).last());\n        } else {\n          targetPoint = new Point(ListSequence.fromList(targetHistoryPath).first());\n        }\n        for (Edge edge : ListSequence.fromList(history)) {\n          List<Point> edgeLayout = graphLayout.getLayoutFor(edge);\n          if (edge.getSource() != cur) {\n            edgeLayout = ListSequence.fromList(edgeLayout).reversedList();\n          }\n          if (cur.isDummy()) {\n            Rectangle rect = graphLayout.getLayoutFor(cur);\n            int y;\n            if (SetSequence.fromSet(visited).contains(cur)) {\n              y = rect.y + rect.height;\n              int shift = myEdgeDistance / 3;\n              int last = ListSequence.fromList(oldEdgeLayout).count() - 1;\n              ListSequence.fromList(oldEdgeLayout).getElement(last).translate(shift, 0);\n              ListSequence.fromList(oldEdgeLayout).getElement(last - 1).translate(shift, 0);\n              ListSequence.fromList(edgeLayout).getElement(0).translate(shift, 0);\n              ListSequence.fromList(edgeLayout).getElement(1).translate(shift, 0);\n            } else {\n              y = rect.y;\n              SetSequence.fromSet(visited).addElement(cur);\n            }\n            Point left = ListSequence.fromList(oldEdgeLayout).removeLastElement();\n            Point right = ListSequence.fromList(edgeLayout).removeElementAt(0);\n            ListSequence.fromList(oldEdgeLayout).addElement(new Point(left.x, y));\n            ListSequence.fromList(edgeLayout).insertElement(0, new Point(right.x, y));\n          }\n          ListSequence.fromList(oldEdgeLayout).addSequence(ListSequence.fromList(edgeLayout));\n          cur = edge.getOpposite(cur);\n        }\n        // during shift edges we can disconnect edge from node \n        Rectangle sourceRect = graphLayout.getLayoutFor(oldEdge.getSource());\n        if (!(GeomUtil.contains(sourceRect, ListSequence.fromList(oldEdgeLayout).first()))) {\n          ListSequence.fromList(oldEdgeLayout).insertElement(0, sourcePoint);\n        }\n        Rectangle targetRect = graphLayout.getLayoutFor(oldEdge.getTarget());\n        if (!(GeomUtil.contains(targetRect, ListSequence.fromList(oldEdgeLayout).last()))) {\n          ListSequence.fromList(oldEdgeLayout).addElement(targetPoint);\n        }\n        // or add point inside a node \n        Point second = ListSequence.fromList(oldEdgeLayout).getElement(1);\n        if (GeomUtil.contains(sourceRect, second)) {\n          ListSequence.fromList(oldEdgeLayout).removeElementAt(0);\n          ListSequence.fromList(oldEdgeLayout).removeElementAt(0);\n          ListSequence.fromList(oldEdgeLayout).insertElement(0, GeomUtil.findOnBorder(sourceRect, second, ListSequence.fromList(oldEdgeLayout).first()));\n        }\n        Point beforeLast = ListSequence.fromList(oldEdgeLayout).getElement(ListSequence.fromList(oldEdgeLayout).count() - 2);\n        if (GeomUtil.contains(targetRect, beforeLast)) {\n          ListSequence.fromList(oldEdgeLayout).removeLastElement();\n          ListSequence.fromList(oldEdgeLayout).removeLastElement();\n          ListSequence.fromList(oldEdgeLayout).addElement(GeomUtil.findOnBorder(targetRect, beforeLast, ListSequence.fromList(oldEdgeLayout).last()));\n        }\n        graphLayout.setLayoutFor(oldEdge, oldEdgeLayout);\n      } else {\n        Edge newEdge = ListSequence.fromList(history).getElement(0);\n        graphLayout.setLayoutFor(oldEdge, graphLayout.getLayoutFor(newEdge));\n      }\n    }\n    List<Node> nodesToRemove = ListSequence.fromList(graph.getNodes()).where(new IWhereFilter<Node>() {\n      public boolean accept(Node it) {\n        return it.isDummy();\n      }\n    }).toListSequence();\n    ListSequence.fromList(nodesToRemove).addElement(addedNode);\n    for (Node node : ListSequence.fromList(nodesToRemove)) {\n      MapSequence.fromMap(graphLayout.getNodeLayout()).removeKey(node);\n      for (Edge edge : ListSequence.fromList(node.getEdges())) {\n        MapSequence.fromMap(graphLayout.getEdgeLayout()).removeKey(edge);\n      }\n    }\n  }","id":106959,"modified_method":"private void removeTempObjects(List<Edge> oldEdges, EmbeddedGraph embeddedGraph, GraphLayout graphLayout, Graph graph, Node addedNode) {\n    Set<Node> visited = SetSequence.fromSet(new HashSet<Node>());\n    for (Edge oldEdge : ListSequence.fromList(oldEdges)) {\n      List<Edge> history = embeddedGraph.findFullHistory(oldEdge);\n      Node cur = oldEdge.getSource();\n      if (!(ListSequence.fromList(ListSequence.fromList(history).first().getAdjacentNodes()).contains(cur))) {\n        history = ListSequence.fromList(history).reversedList();\n      }\n      if (ListSequence.fromList(history).count() > 1) {\n        List<Point> oldEdgeLayout = ListSequence.fromList(new ArrayList<Point>());\n        List<Point> sourceHistoryPath = graphLayout.getLayoutFor(ListSequence.fromList(history).first());\n        Point sourcePoint;\n        if (ListSequence.fromList(history).first().getSource() == oldEdge.getSource()) {\n          sourcePoint = new Point(ListSequence.fromList(sourceHistoryPath).first());\n        } else {\n          sourcePoint = new Point(ListSequence.fromList(sourceHistoryPath).last());\n        }\n        List<Point> targetHistoryPath = graphLayout.getLayoutFor(ListSequence.fromList(history).last());\n        Point targetPoint;\n        if (ListSequence.fromList(history).last().getTarget() == oldEdge.getTarget()) {\n          targetPoint = new Point(ListSequence.fromList(targetHistoryPath).last());\n        } else {\n          targetPoint = new Point(ListSequence.fromList(targetHistoryPath).first());\n        }\n        for (Edge edge : ListSequence.fromList(history)) {\n          List<Point> edgeLayout = graphLayout.getLayoutFor(edge);\n          if (edge.getSource() != cur) {\n            edgeLayout = ListSequence.fromList(edgeLayout).reversedList();\n          }\n          if (cur.isDummy()) {\n            Rectangle rect = graphLayout.getLayoutFor(cur);\n            int y;\n            if (SetSequence.fromSet(visited).contains(cur)) {\n              y = rect.y + rect.height;\n              int shift = myEdgeDistance / 3;\n              int last = ListSequence.fromList(oldEdgeLayout).count() - 1;\n              ListSequence.fromList(oldEdgeLayout).getElement(last).translate(shift, 0);\n              ListSequence.fromList(oldEdgeLayout).getElement(last - 1).translate(shift, 0);\n              ListSequence.fromList(edgeLayout).getElement(0).translate(shift, 0);\n              ListSequence.fromList(edgeLayout).getElement(1).translate(shift, 0);\n            } else {\n              y = rect.y;\n              SetSequence.fromSet(visited).addElement(cur);\n            }\n            Point left = ListSequence.fromList(oldEdgeLayout).removeLastElement();\n            Point right = ListSequence.fromList(edgeLayout).removeElementAt(0);\n            ListSequence.fromList(oldEdgeLayout).addElement(new Point(left.x, y));\n            ListSequence.fromList(edgeLayout).insertElement(0, new Point(right.x, y));\n          }\n          ListSequence.fromList(oldEdgeLayout).addSequence(ListSequence.fromList(edgeLayout));\n          cur = edge.getOpposite(cur);\n        }\n        // during shift edges we can disconnect edge from node \n        Rectangle sourceRect = graphLayout.getLayoutFor(oldEdge.getSource());\n        if (!(GeomUtil.contains(sourceRect, ListSequence.fromList(oldEdgeLayout).first()))) {\n          ListSequence.fromList(oldEdgeLayout).insertElement(0, sourcePoint);\n        }\n        Rectangle targetRect = graphLayout.getLayoutFor(oldEdge.getTarget());\n        if (!(GeomUtil.contains(targetRect, ListSequence.fromList(oldEdgeLayout).last()))) {\n          ListSequence.fromList(oldEdgeLayout).addElement(targetPoint);\n        }\n        // or add point inside a node \n        Point second = ListSequence.fromList(oldEdgeLayout).getElement(1);\n        if (GeomUtil.contains(sourceRect, second)) {\n          ListSequence.fromList(oldEdgeLayout).removeElementAt(0);\n          ListSequence.fromList(oldEdgeLayout).removeElementAt(0);\n          ListSequence.fromList(oldEdgeLayout).insertElement(0, GeomUtil.findOnBorder(sourceRect, second, ListSequence.fromList(oldEdgeLayout).first()));\n        }\n        Point beforeLast = ListSequence.fromList(oldEdgeLayout).getElement(ListSequence.fromList(oldEdgeLayout).count() - 2);\n        if (GeomUtil.contains(targetRect, beforeLast)) {\n          ListSequence.fromList(oldEdgeLayout).removeLastElement();\n          ListSequence.fromList(oldEdgeLayout).removeLastElement();\n          ListSequence.fromList(oldEdgeLayout).addElement(GeomUtil.findOnBorder(targetRect, beforeLast, ListSequence.fromList(oldEdgeLayout).last()));\n        }\n        graphLayout.setLayoutFor(oldEdge, oldEdgeLayout);\n      } else {\n        Edge newEdge = ListSequence.fromList(history).getElement(0);\n        graphLayout.setLayoutFor(oldEdge, graphLayout.getLayoutFor(newEdge));\n      }\n    }\n    List<Node> nodesToRemove = ListSequence.fromList(graph.getNodes()).where(new IWhereFilter<Node>() {\n      public boolean accept(Node it) {\n        return it.isDummy();\n      }\n    }).toListSequence();\n    ListSequence.fromList(nodesToRemove).addElement(addedNode);\n    for (Node node : ListSequence.fromList(nodesToRemove)) {\n      MapSequence.fromMap(graphLayout.getNodeLayout()).removeKey(node);\n      for (Edge edge : ListSequence.fromList(node.getEdges())) {\n        MapSequence.fromMap(graphLayout.getEdgeLayout()).removeKey(edge);\n      }\n    }\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private GraphLayout createLayout(Graph graph, Map<Object, Rectangle> representation, Map<Node, Integer> xSize, Map<Node, Integer> ySize) {\n    GraphLayout layout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Rectangle rect = MapSequence.fromMap(representation).get(node);\n      if (!(node.isDummy())) {\n        int width = MapSequence.fromMap(xSize).get(node) - myEdgeDistance;\n        int meanEdgeX = 0;\n        List<Edge> edges = node.getEdges();\n        for (Edge edge : ListSequence.fromList(edges)) {\n          meanEdgeX += MapSequence.fromMap(representation).get(edge).x;\n        }\n        meanEdgeX /= ListSequence.fromList(edges).count();\n        int nodeX = meanEdgeX - width / 2;\n        if (nodeX < rect.x) {\n          nodeX = rect.x;\n        }\n        if (nodeX + width > rect.x + rect.width) {\n          nodeX = rect.x + rect.width - width;\n        }\n        layout.setLayoutFor(node, new Rectangle(nodeX, rect.y, width, MapSequence.fromMap(ySize).get(node)));\n      } else {\n        layout.setLayoutFor(node, rect);\n      }\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      List<Point> path = ListSequence.fromList(new ArrayList<Point>());\n      Rectangle sourceRect = layout.getLayoutFor(edge.getSource());\n      int sourceMinX = sourceRect.x;\n      int sourceMaxX = sourceRect.x + sourceRect.width;\n      int edgeX = MapSequence.fromMap(representation).get(edge).x;\n      boolean hasHorLines = false;\n      if (sourceMaxX < edgeX) {\n        ListSequence.fromList(path).addElement(new Point(sourceMaxX, sourceRect.y + sourceRect.height / 2));\n        hasHorLines = true;\n      }\n      if (edgeX < sourceMinX) {\n        ListSequence.fromList(path).addElement(new Point(sourceMinX, sourceRect.y + sourceRect.height / 2));\n        hasHorLines = true;\n      }\n      if (hasHorLines) {\n        ListSequence.fromList(path).addElement(new Point(edgeX, sourceRect.y + sourceRect.height / 2));\n      } else {\n        ListSequence.fromList(path).addElement(new Point(edgeX, sourceRect.y + sourceRect.height));\n      }\n      Rectangle targetRect = layout.getLayoutFor(edge.getTarget());\n      int targetMinX = targetRect.x;\n      int targetMaxX = targetRect.x + targetRect.width;\n      hasHorLines = false;\n      Point end = null;\n      if (targetMaxX < edgeX) {\n        end = new Point(targetMaxX, targetRect.y + targetRect.height / 2);\n        hasHorLines = true;\n      }\n      if (edgeX < targetMinX) {\n        end = new Point(targetMinX, targetRect.y + targetRect.height / 2);\n        hasHorLines = true;\n      }\n      if (hasHorLines) {\n        ListSequence.fromList(path).addElement(new Point(edgeX, targetRect.y + targetRect.height / 2));\n        ListSequence.fromList(path).addElement(end);\n      } else {\n        ListSequence.fromList(path).addElement(new Point(edgeX, targetRect.y));\n      }\n      layout.setLayoutFor(edge, path);\n    }\n    layout = LayoutTransform.shift(layout, 20, 20);\n    correctEdgesLayout(layout);\n    return layout;\n  }","id":106960,"modified_method":"private GraphLayout createLayout(Graph graph, Map<Object, Rectangle> representation, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> edgeSizes, Set<Edge> hasLabels) {\n    GraphLayout layout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Rectangle rect = MapSequence.fromMap(representation).get(node);\n      if (!(node.isDummy())) {\n        int width = MapSequence.fromMap(nodeSizes).get(node).width - myEdgeDistance;\n        int meanEdgeX = 0;\n        List<Edge> edges = node.getEdges();\n        for (Edge edge : ListSequence.fromList(edges)) {\n          meanEdgeX += MapSequence.fromMap(representation).get(edge).x;\n        }\n        meanEdgeX /= ListSequence.fromList(edges).count();\n        int nodeX = meanEdgeX - width / 2;\n        if (nodeX < rect.x) {\n          nodeX = rect.x;\n        }\n        if (nodeX + width > rect.x + rect.width) {\n          nodeX = rect.x + rect.width - width;\n        }\n        layout.setLayoutFor(node, new Rectangle(nodeX, rect.y, width, MapSequence.fromMap(nodeSizes).get(node).height));\n      } else {\n        layout.setLayoutFor(node, rect);\n      }\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      Rectangle edgeRect = MapSequence.fromMap(representation).get(edge);\n      if (SetSequence.fromSet(hasLabels).contains(edge)) {\n        Dimension labelSize = MapSequence.fromMap(edgeSizes).get(edge);\n        int mid = edgeRect.y + edgeRect.height / 2;\n        int height = labelSize.height - myEdgeDistance;\n        Rectangle labelRectangle = new Rectangle(edgeRect.x, mid - height / 2, labelSize.width - myEdgeDistance, height);\n        layout.setLabelLayout(edge, labelRectangle);\n      }\n      List<Point> path = ListSequence.fromList(new ArrayList<Point>());\n      Rectangle sourceRect = layout.getLayoutFor(edge.getSource());\n      int sourceMinX = sourceRect.x;\n      int sourceMaxX = sourceRect.x + sourceRect.width;\n      int edgeX = edgeRect.x;\n      boolean hasHorLines = false;\n      if (sourceMaxX < edgeX) {\n        ListSequence.fromList(path).addElement(new Point(sourceMaxX, sourceRect.y + sourceRect.height / 2));\n        hasHorLines = true;\n      }\n      if (edgeX < sourceMinX) {\n        ListSequence.fromList(path).addElement(new Point(sourceMinX, sourceRect.y + sourceRect.height / 2));\n        hasHorLines = true;\n      }\n      if (hasHorLines) {\n        ListSequence.fromList(path).addElement(new Point(edgeX, sourceRect.y + sourceRect.height / 2));\n      } else {\n        ListSequence.fromList(path).addElement(new Point(edgeX, sourceRect.y + sourceRect.height));\n      }\n      Rectangle targetRect = layout.getLayoutFor(edge.getTarget());\n      int targetMinX = targetRect.x;\n      int targetMaxX = targetRect.x + targetRect.width;\n      hasHorLines = false;\n      Point end = null;\n      if (targetMaxX < edgeX) {\n        end = new Point(targetMaxX, targetRect.y + targetRect.height / 2);\n        hasHorLines = true;\n      }\n      if (edgeX < targetMinX) {\n        end = new Point(targetMinX, targetRect.y + targetRect.height / 2);\n        hasHorLines = true;\n      }\n      if (hasHorLines) {\n        ListSequence.fromList(path).addElement(new Point(edgeX, targetRect.y + targetRect.height / 2));\n        ListSequence.fromList(path).addElement(end);\n      } else {\n        ListSequence.fromList(path).addElement(new Point(edgeX, targetRect.y));\n      }\n      layout.setLayoutFor(edge, path);\n    }\n    layout = LayoutTransform.shift(layout, 20, 20);\n    correctEdgesLayout(layout);\n    return layout;\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GraphLayout findSTLayout(Graph graph, Map<Node, Integer> xSize, Map<Node, Integer> ySize) {\n    if (graph.getNumNodes() == 1) {\n      GraphLayout layout = new GraphLayout(graph);\n      Node node = graph.getNode(0);\n      layout.setLayoutFor(node, new Rectangle(20, 20, MapSequence.fromMap(xSize).get(node) - myEdgeDistance, MapSequence.fromMap(ySize).get(node)));\n      return layout;\n    }\n    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(graph.getEdges()));\n    BiconnectAugmentation.makeBiconnected(graph);\n    Node addedNode = ListSequence.fromList(graph.getNodes()).last();\n    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new BiconnectedInitialEmbeddingFinder()).find(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      if (!(MapSequence.fromMap(xSize).containsKey(node))) {\n        MapSequence.fromMap(xSize).put(node, myNodeSize + myEdgeDistance);\n        MapSequence.fromMap(ySize).put(node, myNodeSize);\n      }\n    }\n    List<Node> outerNodes = ListSequence.fromList(new ArrayList<Node>());\n    for (Dart dart : ListSequence.fromList(embeddedGraph.getOuterFace().getDarts())) {\n      ListSequence.fromList(outerNodes).addElement(dart.getTarget());\n    }\n    Node s = ListSequence.fromList(outerNodes).getElement(0);\n    Node t = ListSequence.fromList(outerNodes).getElement((ListSequence.fromList(outerNodes).count()) / 2);\n    GraphOrientation.orientST(graph, s, t);\n    STPlanarGraph stPlanarGraph = new STPlanarGraph(embeddedGraph, s, t);\n    NodeConstraintsSupporter supporter = new NodeConstraintsSupporter();\n    supporter.setMinEdgeDistance(myEdgeDistance, 15);\n    Map<Object, Rectangle> representation = supporter.getRepresentation(stPlanarGraph, xSize, ySize);\n    GraphLayout graphLayout = this.createLayout(graph, representation, xSize, ySize);\n    if (myLayoutLevel > 0) {\n      this.removeTempObjects(oldEdges, embeddedGraph, graphLayout, graph, addedNode);\n    }\n    if (myLayoutLevel > 1) {\n      LayoutOptimizer.optimizeEdges(graphLayout);\n    }\n    return graphLayout;\n  }","id":106961,"modified_method":"public GraphLayout findSTLayout(Graph graph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> edgeSizes) {\n    if (graph.getNumNodes() == 1) {\n      GraphLayout layout = new GraphLayout(graph);\n      Node node = graph.getNode(0);\n      layout.setLayoutFor(node, new Rectangle(20, 20, MapSequence.fromMap(nodeSizes).get(node).width - myEdgeDistance, MapSequence.fromMap(nodeSizes).get(node).height));\n      return layout;\n    }\n    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());\n    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(graph.getEdges()));\n    BiconnectAugmentation.makeBiconnected(graph);\n    Node addedNode = ListSequence.fromList(graph.getNodes()).last();\n    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new BiconnectedInitialEmbeddingFinder()).find(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      if (!(MapSequence.fromMap(nodeSizes).containsKey(node))) {\n        MapSequence.fromMap(nodeSizes).put(node, new Dimension(myNodeSize, myNodeSize));\n      }\n    }\n    Map<Edge, Dimension> newEdgeSizes = MapSequence.fromMap(new HashMap<Edge, Dimension>());\n    Set<Edge> hasLabel = SetSequence.fromSet(new HashSet<Edge>());\n    for (Edge oldEdge : ListSequence.fromList(oldEdges)) {\n      List<Edge> history = embeddedGraph.findFullHistory(oldEdge);\n      Node cur = oldEdge.getSource();\n      if (!(ListSequence.fromList(ListSequence.fromList(history).first().getAdjacentNodes()).contains(cur))) {\n        history = ListSequence.fromList(history).reversedList();\n      }\n      Edge midEdge = ListSequence.fromList(history).getElement(ListSequence.fromList(history).count() / 2);\n      for (Edge edge : ListSequence.fromList(history)) {\n        if (edge == midEdge && MapSequence.fromMap(edgeSizes).get(oldEdge) != null) {\n          MapSequence.fromMap(newEdgeSizes).put(edge, MapSequence.fromMap(edgeSizes).get(oldEdge));\n          MapSequence.fromMap(myMovedLabels).put(oldEdge, edge);\n          SetSequence.fromSet(hasLabel).addElement(edge);\n        } else {\n          MapSequence.fromMap(newEdgeSizes).put(edge, new Dimension(myEdgeDistance, myEdgeDistance));\n        }\n      }\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      if (MapSequence.fromMap(newEdgeSizes).get(edge) == null) {\n        MapSequence.fromMap(newEdgeSizes).put(edge, new Dimension(myEdgeDistance, myEdgeDistance));\n      }\n    }\n    List<Node> outerNodes = ListSequence.fromList(new ArrayList<Node>());\n    for (Dart dart : ListSequence.fromList(embeddedGraph.getOuterFace().getDarts())) {\n      ListSequence.fromList(outerNodes).addElement(dart.getTarget());\n    }\n    Node s = ListSequence.fromList(outerNodes).getElement(0);\n    Node t = ListSequence.fromList(outerNodes).getElement((ListSequence.fromList(outerNodes).count()) / 2);\n    GraphOrientation.orientST(graph, s, t);\n    STPlanarGraph stPlanarGraph = new STPlanarGraph(embeddedGraph, s, t);\n    ConstraintsSupporter supporter = new ConstraintsSupporter();\n    supporter.setMinEdgeDistance(myEdgeDistance, 15);\n    Map<Object, Rectangle> representation = supporter.getRepresentation(stPlanarGraph, nodeSizes, newEdgeSizes);\n    GraphLayout graphLayout = this.createLayout(graph, representation, nodeSizes, newEdgeSizes, hasLabel);\n    if (myLayoutLevel > 0) {\n      this.removeTempObjects(oldEdges, embeddedGraph, graphLayout, graph, addedNode);\n    }\n    if (myLayoutLevel > 1) {\n      LayoutOptimizer.optimizeEdges(graphLayout);\n    }\n    return graphLayout;\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GraphLayout doLayout(Graph graph, Map<Node, Dimension> nodeSizes) {\n    Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);\n    int maxComponent = 0;\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      maxComponent = Math.max(maxComponent, MapSequence.fromMap(components).get(node));\n    }\n    Map<Node, Node> newNodes = new NodeMap<Node>(graph);\n    Map<Node, Graph> nodeSubgraphs = new NodeMap<Graph>(graph);\n    Map<Edge, Edge> newEdges = MapSequence.fromMap(new HashMap<Edge, Edge>());\n    List<Graph> subgraphs = ListSequence.fromList(new ArrayList<Graph>());\n    Map<Graph, Map<Node, Integer>> xSizes = MapSequence.fromMap(new HashMap<Graph, Map<Node, Integer>>());\n    Map<Graph, Map<Node, Integer>> ySizes = MapSequence.fromMap(new HashMap<Graph, Map<Node, Integer>>());\n    for (int i = 0; i <= maxComponent; i++) {\n      Graph subgraph = ListSequence.fromList(subgraphs).addElement(new Graph());\n      MapSequence.fromMap(xSizes).put(subgraph, MapSequence.fromMap(new HashMap<Node, Integer>()));\n      MapSequence.fromMap(ySizes).put(subgraph, MapSequence.fromMap(new HashMap<Node, Integer>()));\n    }\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Graph subgraph = ListSequence.fromList(subgraphs).getElement(MapSequence.fromMap(components).get(node));\n      Node newNode = subgraph.addNode();\n      MapSequence.fromMap(newNodes).put(node, newNode);\n      MapSequence.fromMap(nodeSubgraphs).put(node, subgraph);\n      MapSequence.fromMap(MapSequence.fromMap(xSizes).get(subgraph)).put(newNode, MapSequence.fromMap(nodeSizes).get(node).width + myEdgeDistance);\n      MapSequence.fromMap(MapSequence.fromMap(ySizes).get(subgraph)).put(newNode, MapSequence.fromMap(nodeSizes).get(node).height);\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      MapSequence.fromMap(newEdges).put(edge, MapSequence.fromMap(newNodes).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(newNodes).get(edge.getTarget())));\n    }\n    Map<Graph, GraphLayout> subgraphLayouts = MapSequence.fromMap(new HashMap<Graph, GraphLayout>());\n    int shiftX = 0;\n    for (Graph subgraph : ListSequence.fromList(subgraphs)) {\n      GraphLayout curLayout = findSTLayout(subgraph, MapSequence.fromMap(xSizes).get(subgraph), MapSequence.fromMap(ySizes).get(subgraph));\n      curLayout = LayoutTransform.shift(curLayout, shiftX, 0);\n      MapSequence.fromMap(subgraphLayouts).put(subgraph, curLayout);\n      shiftX = curLayout.getContainingRectangle().x + curLayout.getContainingRectangle().width + 30;\n    }\n    GraphLayout layout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Graph subgraph = MapSequence.fromMap(nodeSubgraphs).get(node);\n      layout.setLayoutFor(node, MapSequence.fromMap(subgraphLayouts).get(subgraph).getLayoutFor(MapSequence.fromMap(newNodes).get(node)));\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      Graph subgraph = MapSequence.fromMap(nodeSubgraphs).get(edge.getSource());\n      layout.setLayoutFor(edge, MapSequence.fromMap(subgraphLayouts).get(subgraph).getLayoutFor(MapSequence.fromMap(newEdges).get(edge)));\n    }\n    if (myLayoutLevel == 0) {\n      return MapSequence.fromMap(subgraphLayouts).get(ListSequence.fromList(subgraphs).getElement(0));\n    } else {\n      return layout;\n    }\n  }","id":106962,"modified_method":"public GraphLayout doLayout(Graph graph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> edgeSizes) {\n    Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);\n    int maxComponent = 0;\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      maxComponent = Math.max(maxComponent, MapSequence.fromMap(components).get(node));\n    }\n    Map<Node, Node> newNodes = new NodeMap<Node>(graph);\n    Map<Node, Graph> nodeSubgraphs = new NodeMap<Graph>(graph);\n    Map<Edge, Edge> newEdges = MapSequence.fromMap(new HashMap<Edge, Edge>());\n    List<Graph> subgraphs = ListSequence.fromList(new ArrayList<Graph>());\n    Map<Graph, Map<Node, Dimension>> subNodeSizes = MapSequence.fromMap(new HashMap<Graph, Map<Node, Dimension>>());\n    Map<Graph, Map<Edge, Dimension>> subEdgeSizes = MapSequence.fromMap(new HashMap<Graph, Map<Edge, Dimension>>());\n    for (int i = 0; i <= maxComponent; i++) {\n      Graph subgraph = ListSequence.fromList(subgraphs).addElement(new Graph());\n      MapSequence.fromMap(subNodeSizes).put(subgraph, MapSequence.fromMap(new HashMap<Node, Dimension>()));\n      MapSequence.fromMap(subEdgeSizes).put(subgraph, MapSequence.fromMap(new HashMap<Edge, Dimension>()));\n    }\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Graph subgraph = ListSequence.fromList(subgraphs).getElement(MapSequence.fromMap(components).get(node));\n      Node newNode = subgraph.addNode();\n      MapSequence.fromMap(newNodes).put(node, newNode);\n      MapSequence.fromMap(nodeSubgraphs).put(node, subgraph);\n      MapSequence.fromMap(MapSequence.fromMap(subNodeSizes).get(subgraph)).put(newNode, new Dimension(MapSequence.fromMap(nodeSizes).get(node).width + myEdgeDistance, MapSequence.fromMap(nodeSizes).get(node).height));\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      Edge newEdge = MapSequence.fromMap(newNodes).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(newNodes).get(edge.getTarget()));\n      MapSequence.fromMap(newEdges).put(edge, newEdge);\n      Graph subgraph = MapSequence.fromMap(nodeSubgraphs).get(edge.getSource());\n      MapSequence.fromMap(MapSequence.fromMap(subEdgeSizes).get(subgraph)).put(newEdge, new Dimension(MapSequence.fromMap(edgeSizes).get(edge).width + myEdgeDistance, MapSequence.fromMap(edgeSizes).get(edge).height + myEdgeDistance));\n    }\n    Map<Graph, GraphLayout> subgraphLayouts = MapSequence.fromMap(new HashMap<Graph, GraphLayout>());\n    int shiftX = 0;\n    for (Graph subgraph : ListSequence.fromList(subgraphs)) {\n      GraphLayout curLayout = findSTLayout(subgraph, MapSequence.fromMap(subNodeSizes).get(subgraph), MapSequence.fromMap(subEdgeSizes).get(subgraph));\n      curLayout = LayoutTransform.shift(curLayout, shiftX, 0);\n      MapSequence.fromMap(subgraphLayouts).put(subgraph, curLayout);\n      shiftX = curLayout.getContainingRectangle().x + curLayout.getContainingRectangle().width + 30;\n    }\n    GraphLayout layout = new GraphLayout(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      Graph subgraph = MapSequence.fromMap(nodeSubgraphs).get(node);\n      layout.setLayoutFor(node, MapSequence.fromMap(subgraphLayouts).get(subgraph).getLayoutFor(MapSequence.fromMap(newNodes).get(node)));\n    }\n    for (Edge edge : ListSequence.fromList(graph.getEdges())) {\n      GraphLayout subgraphLayout = MapSequence.fromMap(subgraphLayouts).get(MapSequence.fromMap(nodeSubgraphs).get(edge.getSource()));\n      layout.setLayoutFor(edge, subgraphLayout.getLayoutFor(MapSequence.fromMap(newEdges).get(edge)));\n      layout.setLabelLayout(edge, subgraphLayout.getLabelLayout(MapSequence.fromMap(myMovedLabels).get(MapSequence.fromMap(newEdges).get(edge))));\n    }\n    if (myLayoutLevel == 0) {\n      return MapSequence.fromMap(subgraphLayouts).get(ListSequence.fromList(subgraphs).getElement(0));\n    } else {\n      return layout;\n    }\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RectOrthogonalLayouter() {\n    myNodeSize = DEFAULT_NODE_SIZE;\n    myEdgeDistance = DEFAULT_EDGE_DISTANCE;\n    myLayoutLevel = 2;\n  }","id":106963,"modified_method":"public RectOrthogonalLayouter() {\n    myNodeSize = DEFAULT_NODE_SIZE;\n    myEdgeDistance = DEFAULT_EDGE_DISTANCE;\n    myMovedLabels = MapSequence.fromMap(new HashMap<Edge, Edge>());\n    myLayoutLevel = 1;\n  }","commit_id":"adbb77815d38193d1c242f8905ebe6f4eb26f66c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected MPSTreeNode rebuild() {\n    MPSTreeNode result = new TextMPSTreeNode((ListSequence.fromList(myAllDependencies).isEmpty() ?\n      \"no dependencies selected\" :\n      \"Dependencies found\"\n    ), null);\n    for (Tuples._3<Set<IModule>, Set<IModule>, Set<Language>> dep : ListSequence.fromList(myAllDependencies)) {\n      for (IModule m : SetSequence.fromSet(dep._0())) {\n        addChildDep(result, m, DependencyPathTree.DepType.M, \"\", dep._1(), dep._2(), SetSequence.fromSet(new HashSet<DependencyPathTree.Dep>()));\n      }\n    }\n    setRootVisible(ListSequence.fromList(myAllDependencies).isEmpty());\n    setShowsRootHandles(ListSequence.fromList(myAllDependencies).isNotEmpty());\n    expandAll();\n    return result;\n  }","id":106964,"modified_method":"protected MPSTreeNode rebuild() {\n    MPSTreeNode result = new TextMPSTreeNode((ListSequence.fromList(myAllDependencies).isEmpty() ?\n      \"no dependencies selected\" :\n      \"Dependencies found\"\n    ), null);\n    for (Tuples._3<Set<IModule>, Set<IModule>, Set<IModule>> dep : ListSequence.fromList(myAllDependencies)) {\n      for (IModule m : SetSequence.fromSet(dep._0())) {\n        addChildDep(result, m, DependencyPathTree.DepType.M, \"\", dep._1(), dep._2(), SetSequence.fromSet(new HashSet<DependencyPathTree.Dep>()));\n      }\n    }\n    setRootVisible(ListSequence.fromList(myAllDependencies).isEmpty());\n    setShowsRootHandles(ListSequence.fromList(myAllDependencies).isNotEmpty());\n    expandAll();\n    return result;\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addDependency(Iterable<IModule> from, Iterable<IModule> to, Iterable<Language> usedLanguage) {\n    ListSequence.fromList(myAllDependencies).addElement(MultiTuple.<Set<IModule>,Set<IModule>,Set<Language>>from(SetSequence.fromSetWithValues(new HashSet<IModule>(), from), SetSequence.fromSetWithValues(new HashSet<IModule>(), to), SetSequence.fromSetWithValues(new HashSet<Language>(), usedLanguage)));\n  }","id":106965,"modified_method":"public void addDependency(Iterable<IModule> from, Iterable<IModule> to, Iterable<IModule> usedLanguage) {\n    ListSequence.fromList(myAllDependencies).addElement(MultiTuple.<Set<IModule>,Set<IModule>,Set<IModule>>from(SetSequence.fromSetWithValues(new HashSet<IModule>(), from), SetSequence.fromSetWithValues(new HashSet<IModule>(), to), SetSequence.fromSetWithValues(new HashSet<IModule>(), usedLanguage)));\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private MPSTreeNode buildDependency(IModule from, DependencyPathTree.DepType type, String role, Set<IModule> dependency, Set<Language> usedlangauge, Set<DependencyPathTree.Dep> visited) {\n    if (SetSequence.fromSet(dependency).contains(from)) {\n      return new DependencyTreeLeafNode(from, role, null);\n    }\n    DependencyPathTree.Dep dep = new DependencyPathTree.Dep(from, type);\n    if (SetSequence.fromSet(visited).contains(dep)) {\n      return null;\n    }\n    SetSequence.fromSet(visited).addElement(dep);\n\n    MPSTreeNode result = new DependencyTreeNode(from, role, null);\n\n    switch (type) {\n      case M:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"depends on \", dependency, usedlangauge, visited);\n        }\n        if (from instanceof Language) {\n          for (Language l : ListSequence.fromList(((Language) from).getExtendedLanguages())) {\n            addChildDep(result, l, DependencyPathTree.DepType.D, \"extends language \", dependency, usedlangauge, visited);\n          }\n        }\n        for (ModuleReference devkit : ListSequence.fromList(from.getUsedDevkitReferences())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(devkit), DependencyPathTree.DepType.DK, \"uses devkit \", dependency, usedlangauge, visited);\n        }\n        for (ModuleReference l : ListSequence.fromList(from.getUsedLanguagesReferences())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(l), DependencyPathTree.DepType.UL, \"uses language \", dependency, usedlangauge, visited);\n        }\n        break;\n\n      case DK:\n        DevKit dk = (DevKit) from;\n        for (DevKit devkit : ListSequence.fromList(dk.getExtendedDevKits())) {\n          addChildDep(result, devkit, DependencyPathTree.DepType.DK, \"extends devkit \", dependency, usedlangauge, visited);\n        }\n        for (Language l : ListSequence.fromList(dk.getExportedLanguages())) {\n          addChildDep(result, l, DependencyPathTree.DepType.UL, \"exports language \", dependency, usedlangauge, visited);\n        }\n        for (Solution s : ListSequence.fromList(dk.getExportedSolutions())) {\n          addChildDep(result, s, DependencyPathTree.DepType.D, \"exports solution \", dependency, usedlangauge, visited);\n        }\n        break;\n\n      case UL:\n        Language ul = (Language) from;\n        for (Language l : ListSequence.fromList(ul.getExtendedLanguages())) {\n          addChildDep(result, l, DependencyPathTree.DepType.UL, \"extends language \", dependency, usedlangauge, visited);\n        }\n        if (isShowRuntime()) {\n          for (ModuleReference m : ListSequence.fromList(ul.getRuntimeModulesReferences())) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(m), DependencyPathTree.DepType.R, \"exports runtime \", dependency, usedlangauge, visited);\n          }\n        }\n        for (Dependency d : ListSequence.fromList(ul.getDependencies())) {\n          if (d.isReexport()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"re-exports dependency on \", dependency, usedlangauge, visited);\n          }\n        }\n        break;\n\n      case D:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          if (d.isReexport()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"re-exports dependency on \", dependency, usedlangauge, visited);\n\n          } else if (isShowRuntime()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.R, \"depends on \", dependency, usedlangauge, visited);\n          }\n\n        }\n        if (from instanceof Language) {\n          for (Language l : ListSequence.fromList(((Language) from).getExtendedLanguages())) {\n            addChildDep(result, l, DependencyPathTree.DepType.D, \"extends language \", dependency, usedlangauge, visited);\n          }\n        }\n        break;\n\n      case R:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.R, \"depends on \", dependency, usedlangauge, visited);\n        }\n      default:\n    }\n\n    return (result.getChildCount() > 0 ?\n      result :\n      null\n    );\n  }","id":106966,"modified_method":"@Nullable\n  private MPSTreeNode buildDependency(IModule from, DependencyPathTree.DepType type, String role, Set<IModule> dependency, Set<IModule> usedlangauge, Set<DependencyPathTree.Dep> visited) {\n    if ((type == DependencyPathTree.DepType.D || type == DependencyPathTree.DepType.R) && SetSequence.fromSet(dependency).contains(from)) {\n      return new DependencyTreeLeafNode(from, role, null);\n    }\n    if (type == DependencyPathTree.DepType.UL && SetSequence.fromSet(usedlangauge).contains(from)) {\n      return new DependencyTreeLeafNode(from, role, null);\n    }\n    DependencyPathTree.Dep dep = new DependencyPathTree.Dep(from, type);\n    if (SetSequence.fromSet(visited).contains(dep)) {\n      return null;\n    }\n    SetSequence.fromSet(visited).addElement(dep);\n\n    MPSTreeNode result = new DependencyTreeNode(from, role, null);\n\n    switch (type) {\n      case M:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"depends on \", dependency, usedlangauge, visited);\n        }\n        if (from instanceof Language) {\n          for (Language l : ListSequence.fromList(((Language) from).getExtendedLanguages())) {\n            addChildDep(result, l, DependencyPathTree.DepType.D, \"extends language \", dependency, usedlangauge, visited);\n          }\n        }\n        for (ModuleReference devkit : ListSequence.fromList(from.getUsedDevkitReferences())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(devkit), DependencyPathTree.DepType.DK, \"uses devkit \", dependency, usedlangauge, visited);\n        }\n        for (ModuleReference l : ListSequence.fromList(from.getUsedLanguagesReferences())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(l), DependencyPathTree.DepType.UL, \"uses language \", dependency, usedlangauge, visited);\n        }\n        break;\n\n      case DK:\n        DevKit dk = (DevKit) from;\n        for (DevKit devkit : ListSequence.fromList(dk.getExtendedDevKits())) {\n          addChildDep(result, devkit, DependencyPathTree.DepType.DK, \"extends devkit \", dependency, usedlangauge, visited);\n        }\n        for (Language l : ListSequence.fromList(dk.getExportedLanguages())) {\n          addChildDep(result, l, DependencyPathTree.DepType.UL, \"exports language \", dependency, usedlangauge, visited);\n        }\n        for (Solution s : ListSequence.fromList(dk.getExportedSolutions())) {\n          addChildDep(result, s, DependencyPathTree.DepType.D, \"exports solution \", dependency, usedlangauge, visited);\n        }\n        break;\n\n      case UL:\n        Language ul = (Language) from;\n        for (Language l : ListSequence.fromList(ul.getExtendedLanguages())) {\n          addChildDep(result, l, DependencyPathTree.DepType.UL, \"extends language \", dependency, usedlangauge, visited);\n        }\n        if (isShowRuntime()) {\n          for (ModuleReference m : ListSequence.fromList(ul.getRuntimeModulesReferences())) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(m), DependencyPathTree.DepType.R, \"exports runtime \", dependency, usedlangauge, visited);\n          }\n        }\n        for (Dependency d : ListSequence.fromList(ul.getDependencies())) {\n          if (d.isReexport()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"re-exports dependency on \", dependency, usedlangauge, visited);\n          }\n        }\n        break;\n\n      case D:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          if (d.isReexport()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.D, \"re-exports dependency on \", dependency, usedlangauge, visited);\n\n          } else if (isShowRuntime()) {\n            addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.R, \"depends on \", dependency, usedlangauge, visited);\n          }\n\n        }\n        if (from instanceof Language) {\n          for (Language l : ListSequence.fromList(((Language) from).getExtendedLanguages())) {\n            addChildDep(result, l, DependencyPathTree.DepType.D, \"extends language \", dependency, usedlangauge, visited);\n          }\n        }\n        break;\n\n      case R:\n        for (Dependency d : ListSequence.fromList(from.getDependencies())) {\n          addChildDep(result, MPSModuleRepository.getInstance().getModule(d.getModuleRef()), DependencyPathTree.DepType.R, \"depends on \", dependency, usedlangauge, visited);\n        }\n      default:\n    }\n\n    return (result.getChildCount() > 0 ?\n      result :\n      null\n    );\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addChildDep(MPSTreeNode parent, IModule m, DependencyPathTree.DepType type, String role, Set<IModule> dep, Set<Language> ulang, Set<DependencyPathTree.Dep> visited) {\n    MPSTreeNode child = buildDependency(m, type, role, dep, ulang, visited);\n    if (child != null) {\n      parent.add(child);\n    }\n  }","id":106967,"modified_method":"private void addChildDep(MPSTreeNode parent, IModule m, DependencyPathTree.DepType type, String role, Set<IModule> dep, Set<IModule> ulang, Set<DependencyPathTree.Dep> visited) {\n    MPSTreeNode child = buildDependency(m, type, role, dep, ulang, visited);\n    if (child != null) {\n      parent.add(child);\n    }\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<IModule> check_jxc64t_a0b0b0a0d0b(ModuleDependencyNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModules();\n    }\n    return null;\n  }","id":106968,"modified_method":"private static List<IModule> check_jxc64t_a0b0b0a0g0b(ModuleDependencyNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModules();\n    }\n    return null;\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void resetDependencies() {\n    myRightTree.resetDependencies();\n    Map<List<IModule>, List<IModule>> dependencies = MapSequence.fromMap(new HashMap<List<IModule>, List<IModule>>());\n    TreePath[] paths = myLeftTree.getSelectionPaths();\n    if (paths != null) {\n      for (TreePath path : paths) {\n        MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();\n        if (node instanceof ModuleDependencyNode) {\n          ModuleDependencyNode n = (ModuleDependencyNode) node;\n          List<IModule> from = check_jxc64t_a0b0b0a0d0b(n.getFromNode());\n          if (from != null) {\n            if (!(MapSequence.fromMap(dependencies).containsKey(from))) {\n              MapSequence.fromMap(dependencies).put(from, ListSequence.fromList(new ArrayList<IModule>()));\n            }\n            ListSequence.fromList(MapSequence.fromMap(dependencies).get(from)).addSequence(ListSequence.fromList(n.getModules()));\n          }\n        }\n      }\n    }\n    for (IMapping<List<IModule>, List<IModule>> dep : MapSequence.fromMap(dependencies)) {\n      myRightTree.addDependency(dep.key(), dep.value(), null);\n    }\n    myRightTree.rebuildLater();\n  }","id":106969,"modified_method":"public void resetDependencies() {\n    myRightTree.resetDependencies();\n\n    Map<List<IModule>, List<IModule>> dependencies = MapSequence.fromMap(new HashMap<List<IModule>, List<IModule>>());\n    Map<List<IModule>, List<IModule>> usedlanguages = MapSequence.fromMap(new HashMap<List<IModule>, List<IModule>>());\n\n    TreePath[] paths = myLeftTree.getSelectionPaths();\n    if (paths != null) {\n      for (TreePath path : paths) {\n        MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();\n        if (node instanceof ModuleDependencyNode) {\n          ModuleDependencyNode n = (ModuleDependencyNode) node;\n          List<IModule> from = check_jxc64t_a0b0b0a0g0b(n.getFromNode());\n          if (from != null) {\n            Map<List<IModule>, List<IModule>> collection = (n.isUsedLanguage() ?\n              usedlanguages :\n              dependencies\n            );\n            if (!(MapSequence.fromMap(collection).containsKey(from))) {\n              MapSequence.fromMap(collection).put(from, ListSequence.fromList(new ArrayList<IModule>()));\n            }\n            ListSequence.fromList(MapSequence.fromMap(collection).get(from)).addSequence(ListSequence.fromList(n.getModules()));\n          }\n        }\n      }\n    }\n    for (List<IModule> key : SetSequence.fromSet(MapSequence.fromMap(dependencies).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(usedlanguages).keySet()))) {\n      myRightTree.addDependency(key, MapSequence.fromMap(dependencies).get(key), MapSequence.fromMap(usedlanguages).get(key));\n    }\n    myRightTree.rebuildLater();\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doInit() {\n    Set<IModule> reqModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<IModule> rtModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<Language> usedLanguages = SetSequence.fromSet(new HashSet<Language>());\n\n    for (IModule module : ListSequence.fromList(myModules)) {\n      DependenciesManager depManager = module.getDependenciesManager();\n      SetSequence.fromSet(reqModules).addSequence(SetSequence.fromSet(depManager.getAllVisibleModules()));\n      SetSequence.fromSet(rtModules).addSequence(SetSequence.fromSet(depManager.getAllRequiredModules()));\n      SetSequence.fromSet(usedLanguages).addSequence(SetSequence.fromSet(depManager.getAllUsedLanguages()));\n    }\n\n    DependencyTree tree = (DependencyTree) getTree();\n\n    Set<IModule> allModules = (tree.isShowRuntime() ?\n      rtModules :\n      reqModules\n    );\n    for (IModule m : SetSequence.fromSet(allModules).sort(new ISelector<IModule, Comparable<?>>() {\n      public Comparable<?> select(IModule it) {\n        return it.getModuleFqName();\n      }\n    }, true)) {\n      add(new ModuleDependencyNode(m, !(SetSequence.fromSet(reqModules).contains(m)), getOperationContext()));\n    }\n\n    if (tree.isShowUsedLanguage()) {\n      MPSTreeNode usedlanguages = new TextMPSTreeNode(\"Used languages\", getOperationContext());\n      for (Language l : SetSequence.fromSet(usedLanguages).sort(new ISelector<Language, Comparable<?>>() {\n        public Comparable<?> select(Language it) {\n          return it.getModuleFqName();\n        }\n      }, true)) {\n        usedlanguages.add(new ModuleDependencyNode(l, false, getOperationContext()));\n      }\n      add(usedlanguages);\n    }\n    myInitialized = true;\n  }","id":106970,"modified_method":"protected void doInit() {\n    Set<IModule> reqModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<IModule> rtModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<Language> usedLanguages = SetSequence.fromSet(new HashSet<Language>());\n\n    for (IModule module : ListSequence.fromList(myModules)) {\n      DependenciesManager depManager = module.getDependenciesManager();\n      SetSequence.fromSet(reqModules).addSequence(SetSequence.fromSet(depManager.getAllVisibleModules()));\n      SetSequence.fromSet(rtModules).addSequence(SetSequence.fromSet(depManager.getAllRequiredModules()));\n      SetSequence.fromSet(usedLanguages).addSequence(SetSequence.fromSet(depManager.getAllUsedLanguages()));\n    }\n\n    DependencyTree tree = (DependencyTree) getTree();\n\n    Set<IModule> allModules = (tree.isShowRuntime() ?\n      rtModules :\n      reqModules\n    );\n    for (IModule m : SetSequence.fromSet(allModules).sort(new ISelector<IModule, Comparable<?>>() {\n      public Comparable<?> select(IModule it) {\n        return it.getModuleFqName();\n      }\n    }, true)) {\n      add(new ModuleDependencyNode(m, false, !(SetSequence.fromSet(reqModules).contains(m)), getOperationContext()));\n    }\n\n    if (tree.isShowUsedLanguage()) {\n      MPSTreeNode usedlanguages = new TextMPSTreeNode(\"Used languages\", getOperationContext());\n      for (Language l : SetSequence.fromSet(usedLanguages).sort(new ISelector<Language, Comparable<?>>() {\n        public Comparable<?> select(Language it) {\n          return it.getModuleFqName();\n        }\n      }, true)) {\n        usedlanguages.add(new ModuleDependencyNode(l, true, false, getOperationContext()));\n      }\n      add(usedlanguages);\n    }\n    myInitialized = true;\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleDependencyNode(IModule module, boolean isRuntime, IOperationContext context) {\n    this(ListSequence.fromListAndArray(new ArrayList<IModule>(), module), context);\n    if (isRuntime) {\n      setNodeIdentifier(getNodeIdentifier() + \" (runtime)\");\n    }\n  }","id":106971,"modified_method":"public ModuleDependencyNode(IModule module, boolean isUsedLanguage, boolean isRuntime, IOperationContext context) {\n    this(ListSequence.fromListAndArray(new ArrayList<IModule>(), module), context);\n    myUsedLanguage = isUsedLanguage;\n    if (isRuntime) {\n      setNodeIdentifier(getNodeIdentifier() + \" (runtime)\");\n    }\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleDependencyNode getFromNode() {\n    TreeNode n = getParent();\n    if (n != null && !(n instanceof ModuleDependencyNode)) {\n      n = n.getParent();\n    }\n    if (n != null && n instanceof ModuleDependencyNode) {\n      return (ModuleDependencyNode) n;\n    }\n    return null;\n  }","id":106972,"modified_method":"public ModuleDependencyNode getFromNode() {\n    TreeNode n = getParent();\n    if (n != null && isUsedLanguage()) {\n      n = n.getParent();\n    }\n    if (n != null && n instanceof ModuleDependencyNode) {\n      return (ModuleDependencyNode) n;\n    }\n    return null;\n  }","commit_id":"b38a0beeb8d3531129e72997292c7fce90910da4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object[] getRowFromWorkbooks()\n\t{\n\t\t// This procedure outputs a single Excel data row on the destination\n\t\t// rowsets...\n        \n        Object[] retval = null;\n\n\t\ttry\n\t\t{\n\t\t\t// First, see if a file has been opened?\n\t\t\tif (data.workbook == null)\n\t\t\t{\n\t\t\t\t// Open a new openFile..\n\t\t\t\tdata.file = data.files.getFile(data.filenr);\n\t\t\t\tdata.filename = KettleVFS.getFilename( data.file );\n\t\t\t\tif(meta.isAddResultFile())\r\n\t\t\t\t{\n\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, data.file, getTransMeta().getName(), toString());\n\t\t\t\t\tresultFile.setComment(\"File was read by an Excel input step\");\n\t\t\t\t\taddResultFile(resultFile);\r\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Opening openFile #\" + data.filenr + \" : \" + data.filename);\n                WorkbookSettings ws = new WorkbookSettings();\n                if (!Const.isEmpty(meta.getEncoding()))\n                {\n                    ws.setEncoding(meta.getEncoding());\n                }\n\t\t\t\tdata.workbook = Workbook.getWorkbook(data.file.getContent().getInputStream(), ws);\n                \n\t\t\t\tdata.errorHandler.handleFile(data.file);\n\t\t\t\t// Start at the first sheet again...\n\t\t\t\tdata.sheetnr = 0;\n\t\t\t\t\n\t\t\t\t// See if we have sheet names to retrieve, otherwise we'll have to get all sheets...\n\t\t\t\t//\n\t\t\t\tif (meta.readAllSheets())\n\t\t\t\t{\n\t\t\t\t\tdata.sheetNames = data.workbook.getSheetNames();\n\t\t\t\t\tdata.startColumn = new int[data.sheetNames.length];\n\t\t\t\t\tdata.startRow    = new int[data.sheetNames.length];\n\t\t\t\t\tfor (int i=0;i<data.sheetNames.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.startColumn[i] = data.defaultStartColumn;\n\t\t\t\t\t\tdata.startRow[i]    = data.defaultStartRow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean nextsheet = false;\n\n\t\t\t// What sheet were we handling?\n\t\t\tif (log.isDebug()) logDetailed(\"Get sheet #\" + data.filenr + \".\" + data.sheetnr);\n\t\t\tString sheetName = data.sheetNames[data.sheetnr];\n\t\t\tSheet sheet = data.workbook.getSheet(sheetName);\n\t\t\tif (sheet != null)\n\t\t\t{\n\t\t\t\t// at what row do we continue reading?\n\t\t\t\tif (data.rownr < 0)\n\t\t\t\t{\n\t\t\t\t\tdata.rownr = data.startRow[data.sheetnr];\n\n\t\t\t\t\t// Add an extra row if we have a header row to skip...\n\t\t\t\t\tif (meta.startsWithHeader())\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.rownr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Start at the specified column\n\t\t\t\tdata.colnr = data.startColumn[data.sheetnr];\n\n\t\t\t\t// Build a new row and fill in the data from the sheet...\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tCell line[] = sheet.getRow(data.rownr);\n\t\t\t\t\t// Already increase cursor 1 row\t\t\t\t\t\n\t\t\t\t\tint lineNr = ++data.rownr;\n\t\t\t\t\t// Excel starts counting at 0\n\t\t\t\t\tif (!data.filePlayList.isProcessingNeeded(data.file, lineNr, sheetName))\n\t\t\t\t\t{\n                        retval = null; // placeholder, was already null\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Get line #\" + lineNr + \" from sheet #\" + data.filenr + \".\" + data.sheetnr);\n\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Read line with \" + line.length + \" cells\");\n\t\t\t\t\t\tExcelInputRow excelInputRow = new ExcelInputRow(sheet.getName(), lineNr, line);\n\t\t\t\t\t\tObject[] r = fillRow(data.colnr, excelInputRow);\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Converted line to row #\" + lineNr + \" : \" + data.outputRowMeta.getString(r));\n\n                        boolean isEmpty = isLineEmpty(line);\n\t\t\t\t\t\tif (!isEmpty || !meta.ignoreEmptyRows())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Put the row\n\t\t\t\t\t\t\tretval = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data.rownr>sheet.getRows())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnextsheet=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isEmpty && meta.stopOnEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnextsheet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ArrayIndexOutOfBoundsException e)\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"Out of index error: move to next sheet!\");\n\t\t\t\t\t// We tried to read below the last line in the sheet.\n\t\t\t\t\t// Go to the next sheet...\n\t\t\t\t\tnextsheet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextsheet = true;\n\t\t\t}\n\n\t\t\tif (nextsheet)\n\t\t\t{\n\t\t\t\t// Go to the next sheet\n\t\t\t\tdata.sheetnr++;\n\n\t\t\t\t// Reset the start-row:\n\t\t\t\tdata.rownr = -1;\n\n\t\t\t\t// no previous row yet, don't take it from the previous sheet!\n\t\t\t\t// (that whould be plain wrong!)\n\t\t\t\tdata.previousRow = null;\n\n\t\t\t\t// Perhaps it was the last sheet?\n\t\t\t\tif (data.sheetnr >= data.sheetNames.length)\n\t\t\t\t{\n\t\t\t\t\tjumpToNextFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlogError(\"Error processing row from Excel file [\" + data.filename + \"] : \" + e.toString());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\treturn null;\n\t\t}\n\n\t\treturn retval;\n\t}","id":106973,"modified_method":"public Object[] getRowFromWorkbooks()\n\t{\n\t\t// This procedure outputs a single Excel data row on the destination\n\t\t// rowsets...\n        \n        Object[] retval = null;\n\n\t\ttry\n\t\t{\n\t\t\t// First, see if a file has been opened?\n\t\t\tif (data.workbook == null)\n\t\t\t{\n\t\t\t\t// Open a new openFile..\n\t\t\t\tdata.file = data.files.getFile(data.filenr);\n\t\t\t\tdata.filename = KettleVFS.getFilename( data.file );\n\t\t\t\tif(meta.isAddResultFile())\r\n\t\t\t\t{\n\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, data.file, getTransMeta().getName(), toString());\n\t\t\t\t\tresultFile.setComment(Messages.getString(\"ExcelInput.Log.FileReadByStep\"));\n\t\t\t\t\taddResultFile(resultFile);\r\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (log.isDetailed()) logDetailed(Messages.getString(\"ExcelInput.Log.OpeningFile\",\"\"+data.filenr + \" : \" + data.filename));\r\n\t\t\t\t\n                WorkbookSettings ws = new WorkbookSettings();\n                if (!Const.isEmpty(meta.getEncoding()))\n                {\n                    ws.setEncoding(meta.getEncoding());\n                }\n\t\t\t\tdata.workbook = Workbook.getWorkbook(data.file.getContent().getInputStream(), ws);\n                \n\t\t\t\tdata.errorHandler.handleFile(data.file);\n\t\t\t\t// Start at the first sheet again...\n\t\t\t\tdata.sheetnr = 0;\n\t\t\t\t\n\t\t\t\t// See if we have sheet names to retrieve, otherwise we'll have to get all sheets...\n\t\t\t\t//\n\t\t\t\tif (meta.readAllSheets())\n\t\t\t\t{\n\t\t\t\t\tdata.sheetNames = data.workbook.getSheetNames();\n\t\t\t\t\tdata.startColumn = new int[data.sheetNames.length];\n\t\t\t\t\tdata.startRow    = new int[data.sheetNames.length];\n\t\t\t\t\tfor (int i=0;i<data.sheetNames.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.startColumn[i] = data.defaultStartColumn;\n\t\t\t\t\t\tdata.startRow[i]    = data.defaultStartRow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean nextsheet = false;\n\n\t\t\t// What sheet were we handling?\n\t\t\tif (log.isDebug()) logDetailed(Messages.getString(\"ExcelInput.Log.GetSheet\",\"\"+data.filenr + \".\" + data.sheetnr));\r\n\t\t\t\n\t\t\tString sheetName = data.sheetNames[data.sheetnr];\n\t\t\tSheet sheet = data.workbook.getSheet(sheetName);\n\t\t\tif (sheet != null)\n\t\t\t{\n\t\t\t\t// at what row do we continue reading?\n\t\t\t\tif (data.rownr < 0)\n\t\t\t\t{\n\t\t\t\t\tdata.rownr = data.startRow[data.sheetnr];\n\n\t\t\t\t\t// Add an extra row if we have a header row to skip...\n\t\t\t\t\tif (meta.startsWithHeader())\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.rownr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Start at the specified column\n\t\t\t\tdata.colnr = data.startColumn[data.sheetnr];\n\n\t\t\t\t// Build a new row and fill in the data from the sheet...\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tCell line[] = sheet.getRow(data.rownr);\n\t\t\t\t\t// Already increase cursor 1 row\t\t\t\t\t\n\t\t\t\t\tint lineNr = ++data.rownr;\n\t\t\t\t\t// Excel starts counting at 0\n\t\t\t\t\tif (!data.filePlayList.isProcessingNeeded(data.file, lineNr, sheetName))\n\t\t\t\t\t{\n                        retval = null; // placeholder, was already null\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"ExcelInput.Log.GetLine\",\"\"+lineNr,data.filenr + \".\" + data.sheetnr));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"ExcelInput.Log.ReadLineWith\",\"\"+line.length));\r\n\t\t\t\t\t\t\n\t\t\t\t\t\tExcelInputRow excelInputRow = new ExcelInputRow(sheet.getName(), lineNr, line);\n\t\t\t\t\t\tObject[] r = fillRow(data.colnr, excelInputRow);\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"ExcelInput.Log.ConvertedLinToRow\",\"\"+lineNr,data.outputRowMeta.getString(r)));\n\t\t\t\t\t\t\n                        boolean isEmpty = isLineEmpty(line);\n\t\t\t\t\t\tif (!isEmpty || !meta.ignoreEmptyRows())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Put the row\n\t\t\t\t\t\t\tretval = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data.rownr>sheet.getRows())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnextsheet=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isEmpty && meta.stopOnEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnextsheet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ArrayIndexOutOfBoundsException e)\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"ExcelInput.Log.OutOfIndex\"));\r\n\t\t\t\t\t\n\t\t\t\t\t// We tried to read below the last line in the sheet.\n\t\t\t\t\t// Go to the next sheet...\n\t\t\t\t\tnextsheet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextsheet = true;\n\t\t\t}\n\n\t\t\tif (nextsheet)\n\t\t\t{\n\t\t\t\t// Go to the next sheet\n\t\t\t\tdata.sheetnr++;\n\n\t\t\t\t// Reset the start-row:\n\t\t\t\tdata.rownr = -1;\n\n\t\t\t\t// no previous row yet, don't take it from the previous sheet!\n\t\t\t\t// (that whould be plain wrong!)\n\t\t\t\tdata.previousRow = null;\n\n\t\t\t\t// Perhaps it was the last sheet?\n\t\t\t\tif (data.sheetnr >= data.sheetNames.length)\n\t\t\t\t{\n\t\t\t\t\tjumpToNextFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"ExcelInput.Error.ProcessRowFromExcel\",data.filename+\"\", e.toString()));\r\n\t\t\t\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\treturn null;\n\t\t}\n\n\t\treturn retval;\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private Object[] fillRow(int startcolumn, ExcelInputRow excelInputRow) throws KettleException\n\t{\n\t\tObject[] r = new Object[data.outputRowMeta.size()];\n\n\t\t// Keep track whether or not we handled an error for this line yet.\n\t\tboolean errorHandled = false;\n\n\t\t// Set values in the row...\n\t\tfor (int i = startcolumn; i < excelInputRow.cells.length && i - startcolumn < r.length; i++)\n\t\t{\n\t\t\tCell cell = excelInputRow.cells[i];\n\n\t\t\tint rowcolumn = i - startcolumn;\n\n\t\t\tValueMetaInterface targetMeta = data.outputRowMeta.getValueMeta(rowcolumn);\n\t\t\tValueMetaInterface sourceMeta = null;\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tcheckType(cell, targetMeta);\n\t\t\t}\n\t\t\tcatch (KettleException ex)\n\t\t\t{\n\t\t\t\tif (!meta.isErrorIgnored()) throw ex;\n\t\t\t\tlogBasic(\"Warning processing [\" + targetMeta + \"] from Excel file [\" + data.filename + \"] : \" + ex.getMessage());\n\t\t\t\tif (!errorHandled)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr, excelInputRow.sheetName);\n\t\t\t\t\terrorHandled = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (meta.isErrorLineSkipped())\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCellType cellType = cell.getType();\n\t\t\tif (CellType.BOOLEAN.equals(cellType) ||\n\t\t\t\tCellType.BOOLEAN_FORMULA.equals(cellType))\n\t\t\t{\n\t\t\t\tr[rowcolumn] = Boolean.valueOf( ((BooleanCell)cell).getValue() );\n                sourceMeta = data.valueMetaBoolean;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (CellType.DATE.equals(cellType) ||\n\t\t\t\t\tCellType.DATE_FORMULA.equals(cellType) )\n\t\t\t\t{\n\t\t\t\t\tDate date = ((DateCell) cell).getDate();\n\t\t\t\t\tlong time = date.getTime();\n\t\t\t\t\tint offset = TimeZone.getDefault().getOffset(time);\n                    r[rowcolumn] = new Date(time - offset);\n                    sourceMeta = data.valueMetaDate;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (CellType.LABEL.equals(cellType) ||\n\t\t\t\t\t    CellType.STRING_FORMULA.equals(cellType))\n\t\t\t\t\t{\n                        String string = ((LabelCell) cell).getString();\n\t\t\t\t\t\tswitch (meta.getField()[rowcolumn].getTrimType())\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_LEFT:\n\t\t\t\t\t\t\tstring = ValueDataUtil.leftTrim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_RIGHT:\n\t\t\t\t\t\t\tstring = ValueDataUtil.rightTrim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_BOTH:\n\t\t\t\t\t\t\tstring = ValueDataUtil.trim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n                        r[rowcolumn] = string;\n                        sourceMeta = data.valueMetaString;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (CellType.NUMBER.equals(cellType) ||\n\t\t\t\t\t\t    CellType.NUMBER_FORMULA.equals(cellType))\n\t\t\t\t\t\t{\n                            r[rowcolumn] = new Double( ((NumberCell)cell).getValue() );\n                            sourceMeta = data.valueMetaNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Unknown type : \" + cell.getType().toString() + \" : [\" + cell.getContents() + \"]\");\n                            r[rowcolumn] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tExcelInputField field = meta.getField()[rowcolumn];\n\n\t\t\t// Change to the appropriate type if needed...\n\t\t\t//\n\t\t\ttry\n\t\t\t{\n                // Null stays null folks.\n                //\n\t\t\t\tif (sourceMeta!=null  && sourceMeta.getType() != targetMeta.getType() && r[rowcolumn]!=null)\n\t\t\t\t{\n                    ValueMetaInterface sourceMetaCopy = sourceMeta.clone();\n                    sourceMetaCopy.setConversionMask(field.getFormat());\n                    sourceMetaCopy.setGroupingSymbol(field.getGroupSymbol());\n                    sourceMetaCopy.setDecimalSymbol(field.getDecimalSymbol());\n                    sourceMetaCopy.setCurrencySymbol(field.getCurrencySymbol());\n                    \n\t\t\t\t\tswitch (targetMeta.getType())\n\t\t\t\t\t{\n\t\t\t\t\t// Use case: we find a numeric value: convert it using the supplied format to the desired data type...\n\t\t\t\t\t//\n\t\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER:\n\t\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER:\n\t\t\t\t\t\tswitch (field.getType())\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_DATE:\n                            // number to string conversion (20070522.00 --> \"20070522\")\n                            //\n                            ValueMetaInterface valueMetaNumber = new ValueMeta(\"num\", ValueMetaInterface.TYPE_NUMBER);\n                            valueMetaNumber.setConversionMask(\"#\");\n                            Object string = sourceMetaCopy.convertData(valueMetaNumber, r[rowcolumn]);\n                            \n                            // String to date with mask...\n                            //\n                            r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n                            r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, r[rowcolumn]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// Use case: we find a date: convert it using the supplied format to String...\n\t\t\t\t\t//\n\t\t\t\t\tdefault:\n                        r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, r[rowcolumn]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (KettleException ex)\n\t\t\t{\n\t\t\t\tif (!meta.isErrorIgnored()) throw ex;\n\t\t\t\tlogBasic(\"Warning processing [\" + targetMeta + \"] from Excel file [\" + data.filename + \"] : \" + ex.toString());\n\t\t\t\tif (!errorHandled) // check if we didn't log an error already for this one.\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr, excelInputRow.sheetName);\n\t\t\t\t\terrorHandled=true;\n\t\t\t\t}\n\n\t\t\t\tif (meta.isErrorLineSkipped())\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    r[rowcolumn] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        int rowIndex = meta.getField().length;\n\n\t\t// Do we need to include the filename?\n\t\tif (!Const.isEmpty(meta.getFileField()))\n\t\t{\n\t\t\tr[rowIndex] = data.filename;\n            rowIndex++;\n\t\t}\n\n\t\t// Do we need to include the sheetname?\n\t\tif (!Const.isEmpty(meta.getSheetField()))\n\t\t{\n            r[rowIndex] = excelInputRow.sheetName;\n            rowIndex++;\n\t\t}\n\n\t\t// Do we need to include the sheet rownumber?\n\t\tif (!Const.isEmpty(meta.getSheetRowNumberField()))\n\t\t{\n            r[rowIndex] = new Long(data.rownr);\n            rowIndex++;\n\t\t}\n\t\t\n\t\t// Do we need to include the rownumber?\n\t\tif (!Const.isEmpty(meta.getRowNumberField()))\n\t\t{\n            r[rowIndex] = new Long(linesWritten + 1);\n            rowIndex++;\n\t\t}\n\n\t\treturn r;\n\t}","id":106974,"modified_method":"private Object[] fillRow(int startcolumn, ExcelInputRow excelInputRow) throws KettleException\n\t{\n\t\tObject[] r = new Object[data.outputRowMeta.size()];\n\n\t\t// Keep track whether or not we handled an error for this line yet.\n\t\tboolean errorHandled = false;\n\n\t\t// Set values in the row...\n\t\tfor (int i = startcolumn; i < excelInputRow.cells.length && i - startcolumn < r.length; i++)\n\t\t{\n\t\t\tCell cell = excelInputRow.cells[i];\n\n\t\t\tint rowcolumn = i - startcolumn;\n\n\t\t\tValueMetaInterface targetMeta = data.outputRowMeta.getValueMeta(rowcolumn);\n\t\t\tValueMetaInterface sourceMeta = null;\n            \n\t\t\ttry\n\t\t\t{\n\t\t\t\tcheckType(cell, targetMeta);\n\t\t\t}\n\t\t\tcatch (KettleException ex)\n\t\t\t{\n\t\t\t\tif (!meta.isErrorIgnored()) throw ex;\n\t\t\t\tlogBasic(Messages.getString(\"ExcelInput.Log.WarningProcessingExcelFile\",\"\"+targetMeta,\"\"+data.filename, ex.getMessage()));\n\t\t\t\t\r\n\t\t\t\tif (!errorHandled)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr, excelInputRow.sheetName);\n\t\t\t\t\terrorHandled = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (meta.isErrorLineSkipped())\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCellType cellType = cell.getType();\n\t\t\tif (CellType.BOOLEAN.equals(cellType) ||\n\t\t\t\tCellType.BOOLEAN_FORMULA.equals(cellType))\n\t\t\t{\n\t\t\t\tr[rowcolumn] = Boolean.valueOf( ((BooleanCell)cell).getValue() );\n                sourceMeta = data.valueMetaBoolean;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (CellType.DATE.equals(cellType) ||\n\t\t\t\t\tCellType.DATE_FORMULA.equals(cellType) )\n\t\t\t\t{\n\t\t\t\t\tDate date = ((DateCell) cell).getDate();\n\t\t\t\t\tlong time = date.getTime();\n\t\t\t\t\tint offset = TimeZone.getDefault().getOffset(time);\n                    r[rowcolumn] = new Date(time - offset);\n                    sourceMeta = data.valueMetaDate;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (CellType.LABEL.equals(cellType) ||\n\t\t\t\t\t    CellType.STRING_FORMULA.equals(cellType))\n\t\t\t\t\t{\n                        String string = ((LabelCell) cell).getString();\n\t\t\t\t\t\tswitch (meta.getField()[rowcolumn].getTrimType())\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_LEFT:\n\t\t\t\t\t\t\tstring = ValueDataUtil.leftTrim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_RIGHT:\n\t\t\t\t\t\t\tstring = ValueDataUtil.rightTrim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_BOTH:\n\t\t\t\t\t\t\tstring = ValueDataUtil.trim(string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n                        r[rowcolumn] = string;\n                        sourceMeta = data.valueMetaString;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (CellType.NUMBER.equals(cellType) ||\n\t\t\t\t\t\t    CellType.NUMBER_FORMULA.equals(cellType))\n\t\t\t\t\t\t{\n                            r[rowcolumn] = new Double( ((NumberCell)cell).getValue() );\n                            sourceMeta = data.valueMetaNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (log.isDetailed()) logDetailed(Messages.getString(\"ExcelInput.Log.UnknownType\", cell.getType().toString(),cell.getContents()));\r\n\t\t\t\t\t\t\t\n                            r[rowcolumn] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tExcelInputField field = meta.getField()[rowcolumn];\n\n\t\t\t// Change to the appropriate type if needed...\n\t\t\t//\n\t\t\ttry\n\t\t\t{\n                // Null stays null folks.\n                //\n\t\t\t\tif (sourceMeta!=null  && sourceMeta.getType() != targetMeta.getType() && r[rowcolumn]!=null)\n\t\t\t\t{\n                    ValueMetaInterface sourceMetaCopy = sourceMeta.clone();\n                    sourceMetaCopy.setConversionMask(field.getFormat());\n                    sourceMetaCopy.setGroupingSymbol(field.getGroupSymbol());\n                    sourceMetaCopy.setDecimalSymbol(field.getDecimalSymbol());\n                    sourceMetaCopy.setCurrencySymbol(field.getCurrencySymbol());\n                    \n\t\t\t\t\tswitch (targetMeta.getType())\n\t\t\t\t\t{\n\t\t\t\t\t// Use case: we find a numeric value: convert it using the supplied format to the desired data type...\n\t\t\t\t\t//\n\t\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER:\n\t\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER:\n\t\t\t\t\t\tswitch (field.getType())\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_DATE:\n                            // number to string conversion (20070522.00 --> \"20070522\")\n                            //\n                            ValueMetaInterface valueMetaNumber = new ValueMeta(\"num\", ValueMetaInterface.TYPE_NUMBER);\n                            valueMetaNumber.setConversionMask(\"#\");\n                            Object string = sourceMetaCopy.convertData(valueMetaNumber, r[rowcolumn]);\n                            \n                            // String to date with mask...\n                            //\n                            r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n                            r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, r[rowcolumn]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// Use case: we find a date: convert it using the supplied format to String...\n\t\t\t\t\t//\n\t\t\t\t\tdefault:\n                        r[rowcolumn] = targetMeta.convertData(sourceMetaCopy, r[rowcolumn]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (KettleException ex)\n\t\t\t{\n\t\t\t\tif (!meta.isErrorIgnored()) throw ex;\n\t\t\t\tlogBasic(Messages.getString(\"ExcelInput.Log.WarningProcessingExcelFile\",\"\"+targetMeta,\"\"+data.filename, ex.toString()));\r\n\t\t\t\tif (!errorHandled) // check if we didn't log an error already for this one.\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr, excelInputRow.sheetName);\n\t\t\t\t\terrorHandled=true;\n\t\t\t\t}\n\n\t\t\t\tif (meta.isErrorLineSkipped())\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    r[rowcolumn] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        int rowIndex = meta.getField().length;\n\n\t\t// Do we need to include the filename?\n\t\tif (!Const.isEmpty(meta.getFileField()))\n\t\t{\n\t\t\tr[rowIndex] = data.filename;\n            rowIndex++;\n\t\t}\n\n\t\t// Do we need to include the sheetname?\n\t\tif (!Const.isEmpty(meta.getSheetField()))\n\t\t{\n            r[rowIndex] = excelInputRow.sheetName;\n            rowIndex++;\n\t\t}\n\n\t\t// Do we need to include the sheet rownumber?\n\t\tif (!Const.isEmpty(meta.getSheetRowNumberField()))\n\t\t{\n            r[rowIndex] = new Long(data.rownr);\n            rowIndex++;\n\t\t}\n\t\t\n\t\t// Do we need to include the rownumber?\n\t\tif (!Const.isEmpty(meta.getRowNumberField()))\n\t\t{\n            r[rowIndex] = new Long(linesWritten + 1);\n            rowIndex++;\n\t\t}\n\n\t\treturn r;\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void checkType(Cell cell, ValueMetaInterface v) throws KettleException\n\t{\n\t\tif (!meta.isStrictTypes()) return;\n\t\tCellType cellType = cell.getType();\n\t\tif (cellType.equals(CellType.BOOLEAN))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_BOOLEAN))\n\t\t\t\tthrow new KettleException(\"Invalid type Boolean, expected \" + v.getTypeDesc());\n\t\t}\n\t\telse if (cellType.equals(CellType.DATE))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_DATE))\n\t\t\t\tthrow new KettleException(\"Invalid type Date: \" + cell.getContents() + \", expected \" + v.getTypeDesc());\n\t\t}\n\t\telse if (cellType.equals(CellType.LABEL))\n\t\t{\n\t\t\tif (v.getType() == ValueMetaInterface.TYPE_BOOLEAN || v.getType() == ValueMetaInterface.TYPE_DATE || v.getType() == ValueMetaInterface.TYPE_INTEGER || v.getType() == ValueMetaInterface.TYPE_NUMBER)\n\t\t\t\tthrow new KettleException(\"Invalid type Label: \" + cell.getContents() + \", expected \" + v.getTypeDesc());\n\t\t}\n\t\telse if (cellType.equals(CellType.EMPTY))\n\t\t{\n\t\t\t// ok\n\t\t}\n\t\telse if (cellType.equals(CellType.NUMBER))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_INTEGER || v.getType() == ValueMetaInterface.TYPE_BIGNUMBER || v.getType() == ValueMetaInterface.TYPE_NUMBER))\n\t\t\t\tthrow new KettleException(\"Invalid type Number: \" + cell.getContents() + \", expected \" + v.getTypeDesc());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleException(\"Unsupported type \" + cellType + \" with value: \" + cell.getContents());\n\t\t}\n\t}","id":106975,"modified_method":"private void checkType(Cell cell, ValueMetaInterface v) throws KettleException\n\t{\n\t\tif (!meta.isStrictTypes()) return;\n\t\tCellType cellType = cell.getType();\n\t\tif (cellType.equals(CellType.BOOLEAN))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_BOOLEAN))\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.InvalidTypeBoolean\",v.getTypeDesc()));\r\n\t\t\t\n\t\t}\n\t\telse if (cellType.equals(CellType.DATE))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_DATE))\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.InvalidTypeDate\", cell.getContents(),v.getTypeDesc()));\n\t\t\t\r\n\t\t}\n\t\telse if (cellType.equals(CellType.LABEL))\n\t\t{\n\t\t\tif (v.getType() == ValueMetaInterface.TYPE_BOOLEAN || v.getType() == ValueMetaInterface.TYPE_DATE || v.getType() == ValueMetaInterface.TYPE_INTEGER || v.getType() == ValueMetaInterface.TYPE_NUMBER)\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.InvalidTypeLabel\", cell.getContents(),v.getTypeDesc()));\n\t\t\t\r\n\t\t}\n\t\telse if (cellType.equals(CellType.EMPTY))\n\t\t{\n\t\t\t// ok\n\t\t}\n\t\telse if (cellType.equals(CellType.NUMBER))\n\t\t{\n\t\t\tif (!(v.getType() == ValueMetaInterface.TYPE_STRING || v.getType() == ValueMetaInterface.TYPE_NONE || v.getType() == ValueMetaInterface.TYPE_INTEGER || v.getType() == ValueMetaInterface.TYPE_BIGNUMBER || v.getType() == ValueMetaInterface.TYPE_NUMBER))\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.InvalidTypeNumber\", cell.getContents(),v.getTypeDesc()));\r\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.UnsupportedType\", \"\"+cellType,cell.getContents()));\r\n\t\t\t\n\t\t}\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void handleMissingFiles() throws KettleException\n\t{\n\t\tList<FileObject> nonExistantFiles = data.files.getNonExistantFiles();\n\n\t\tif (nonExistantFiles.size() != 0)\n\t\t{\n\t\t\tString message = FileInputList.getRequiredFilesDescription(nonExistantFiles);\n\t\t\tlog.logBasic(\"Required files\", \"WARNING: Missing \" + message);\n\t\t\tif (meta.isErrorIgnored())\n\t\t\t\tfor (FileObject fileObject : nonExistantFiles)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleNonExistantFile( fileObject );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new KettleException(\"Following required files are missing: \" + message);\n\t\t}\n\n\t\tList<FileObject> nonAccessibleFiles = data.files.getNonAccessibleFiles();\n\t\tif (nonAccessibleFiles.size() != 0)\n\t\t{\n\t\t\tString message = FileInputList.getRequiredFilesDescription(nonAccessibleFiles);\n\t\t\tlog.logBasic(\"Required files\", \"WARNING: Not accessible \" + message);\n\t\t\tif (meta.isErrorIgnored())\n\t\t\t\tfor (FileObject fileObject : nonAccessibleFiles)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleNonAccessibleFile(fileObject);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new KettleException(\"Following required files are not accessible: \" + message);\n\t\t}\n\t}","id":106976,"modified_method":"private void handleMissingFiles() throws KettleException\n\t{\n\t\tList<FileObject> nonExistantFiles = data.files.getNonExistantFiles();\n\n\t\tif (nonExistantFiles.size() != 0)\n\t\t{\n\t\t\tString message = FileInputList.getRequiredFilesDescription(nonExistantFiles);\n\t\t\tlog.logBasic(Messages.getString(\"ExcelInput.Log.RequiredFilesTitle\"), Messages.getString(\"ExcelInput.Warning.MissingFiles\", message));\r\n\t\t\t\n\t\t\tif (meta.isErrorIgnored())\n\t\t\t\tfor (FileObject fileObject : nonExistantFiles)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleNonExistantFile( fileObject );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.MissingRequiredFiles\", message));\r\n\t\t\t\r\n\t\t\t\n\t\t}\n\n\t\tList<FileObject> nonAccessibleFiles = data.files.getNonAccessibleFiles();\n\t\tif (nonAccessibleFiles.size() != 0)\n\t\t{\n\t\t\tString message = FileInputList.getRequiredFilesDescription(nonAccessibleFiles);\n\t\t\tlog.logBasic(Messages.getString(\"ExcelInput.Log.RequiredFilesTitle\"), Messages.getString(\"ExcelInput.Log.RequiredFilesMsgNotAccessible\",message));\r\n\t\t\t\n\t\t\tif (meta.isErrorIgnored())\n\t\t\t\tfor (FileObject fileObject : nonAccessibleFiles)\n\t\t\t\t{\n\t\t\t\t\tdata.errorHandler.handleNonAccessibleFile(fileObject);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new KettleException(Messages.getString(\"ExcelInput.Exception.RequiredFilesNotAccessible\",message));\r\n\t\t\t\n\t\t}\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (first)\n\t\t{\n\t\t\tfirst = false;\n            \n            data.outputRowMeta = new RowMeta(); // start from scratch!\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            if (meta.isAcceptingFilenames())\n            {\n                // Read the files from the specified input stream...\n                data.files.getFiles().clear();\n                \n                int idx = -1;\n                RowSet rowSet = findInputRowSet(meta.getAcceptingStepName());\n                Object[] fileRow = getRowFrom(rowSet);\n                while (fileRow!=null)\n                {\n                    if (idx<0)\n                    {\n                        idx = rowSet.getRowMeta().indexOfValue(meta.getAcceptingField());\n                        if (idx<0)\n                        {\n                            logError(\"The filename field [\"+meta.getAcceptingField()+\"] could not be found in the input rows.\");\n                            setErrors(1);\n                            stopAll();\n                            return false;\n                        }\n                    }\n                    String fileValue = rowSet.getRowMeta().getString(fileRow, idx);\n                    try\n                    {\n                        data.files.addFile(KettleVFS.getFileObject(fileValue));\n                    }\n                    catch(IOException e)\n                    {\n                        throw new KettleException(\"Unexpected error creating file object for \"+fileValue, e);\n                    }\n                    \n                    // Grab another row\n                    fileRow = getRowFrom(rowSet);\n                }\n                \n            }\n\n\t\t\thandleMissingFiles();\n\t\t}\n\n\t\t// See if we're not done processing...\n\t\t// We are done processing if the filenr >= number of files.\n\t\tif (data.filenr >= data.files.nrOfFiles())\n\t\t{\n\t\t\tif (log.isDetailed()) logDetailed(\"No more files to be processed! (\" + data.filenr + \" files done)\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tif (meta.getRowLimit() > 0 && data.rownr > meta.getRowLimit())\n\t\t{\n\t\t\t// The close of the openFile is in dispose()\n\t\t\tif (log.isDetailed()) logDetailed(\"Row limit of [\" + meta.getRowLimit() + \"] reached: stop processing.\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n       \n\t\tObject[] r = getRowFromWorkbooks();\n\t\tif (r != null)\n\t\t{\n\t\t\t// OK, see if we need to repeat values.\n\t\t\tif (data.previousRow != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < meta.getField().length; i++)\n\t\t\t\t{\n\t\t\t\t\tValueMetaInterface valueMeta = data.outputRowMeta.getValueMeta(i);\n                    Object valueData = r[i];\n                    \n\t\t\t\t\tif (valueMeta.isNull(valueData) && meta.getField()[i].isRepeated())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Take the value from the previous row.\n\t\t\t\t\t\tr[i] = data.previousRow[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remember this row for the next time around!\n\t\t\tdata.previousRow = data.outputRowMeta.cloneRow(r);\n\n\t\t\t// Send out the good news: we found a row of data!\n\t\t\tputRow(data.outputRowMeta, r);\n            \n\t\t\treturn true;\n\t\t}\n        else\n        {\n            // This row is ignored / eaten\n            // We continue though.\n            return true;\n        }\n\t}","id":106977,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (first)\n\t\t{\n\t\t\tfirst = false;\n            \n            data.outputRowMeta = new RowMeta(); // start from scratch!\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            if (meta.isAcceptingFilenames())\n            {\n                // Read the files from the specified input stream...\n                data.files.getFiles().clear();\n                \n                int idx = -1;\n                RowSet rowSet = findInputRowSet(meta.getAcceptingStepName());\n                Object[] fileRow = getRowFrom(rowSet);\n                while (fileRow!=null)\n                {\n                    if (idx<0)\n                    {\n                        idx = rowSet.getRowMeta().indexOfValue(meta.getAcceptingField());\n                        if (idx<0)\n                        {\n                            logError(Messages.getString(\"ExcelInput.Error.FilenameFieldNotFound\",\"\"+meta.getAcceptingField()));\n                            \r\n                            setErrors(1);\n                            stopAll();\n                            return false;\n                        }\n                    }\n                    String fileValue = rowSet.getRowMeta().getString(fileRow, idx);\n                    try\n                    {\n                        data.files.addFile(KettleVFS.getFileObject(fileValue));\n                    }\n                    catch(IOException e)\n                    {\n                        throw new KettleException(Messages.getString(\"ExcelInput.Exception.CanNotCreateFileObject\",fileValue), e);\r\n                        \n                    }\n                    \n                    // Grab another row\n                    fileRow = getRowFrom(rowSet);\n                }\n                \n            }\n\n\t\t\thandleMissingFiles();\n\t\t}\n\n\t\t// See if we're not done processing...\n\t\t// We are done processing if the filenr >= number of files.\n\t\tif (data.filenr >= data.files.nrOfFiles())\n\t\t{\n\t\t\tif (log.isDetailed()) logDetailed(Messages.getString(\"ExcelInput.Log.NoMoreFiles\",\"\"+data.filenr));\r\n\t\t\t\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tif (meta.getRowLimit() > 0 && data.rownr > meta.getRowLimit())\n\t\t{\n\t\t\t// The close of the openFile is in dispose()\n\t\t\tif (log.isDetailed()) logDetailed(Messages.getString(\"ExcelInput.Log.RowLimitReached\",\"\"+meta.getRowLimit()));\n\t\t\t\r\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n       \n\t\tObject[] r = getRowFromWorkbooks();\n\t\tif (r != null)\n\t\t{\n\t\t\t// OK, see if we need to repeat values.\n\t\t\tif (data.previousRow != null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < meta.getField().length; i++)\n\t\t\t\t{\n\t\t\t\t\tValueMetaInterface valueMeta = data.outputRowMeta.getValueMeta(i);\n                    Object valueData = r[i];\n                    \n\t\t\t\t\tif (valueMeta.isNull(valueData) && meta.getField()[i].isRepeated())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Take the value from the previous row.\n\t\t\t\t\t\tr[i] = data.previousRow[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remember this row for the next time around!\n\t\t\tdata.previousRow = data.outputRowMeta.cloneRow(r);\n\n\t\t\t// Send out the good news: we found a row of data!\n\t\t\tputRow(data.outputRowMeta, r);\n            \n\t\t\treturn true;\n\t\t}\n        else\n        {\n            // This row is ignored / eaten\n            // We continue though.\n            return true;\n        }\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tinitErrorHandling();\n\t\t\tinitReplayFactory();\n\t\t\tdata.files = meta.getFileList(this);\n\t\t\tif (data.files.nrOfFiles() == 0 && data.files.nrOfMissingFiles() == 0 && !meta.isAcceptingFilenames())\n\t\t\t{\n\t\t\t\tlogError(\"No file(s) specified! Stop processing.\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (meta.getEmptyFields().size() > 0)\n\t\t\t{\n\t\t\t\t// Determine the maximum filename length...\n\t\t\t\tdata.maxfilelength = -1;\n\n\t\t\t\tfor (FileObject file : data.files.getFiles())\n\t\t\t\t{\n\t\t\t\t\tString name = KettleVFS.getFilename(file);\n\t\t\t\t\tif (name.length() > data.maxfilelength) data.maxfilelength = name.length();\n\t\t\t\t}\n\n\t\t\t\t// Determine the maximum sheet name length...\n\t\t\t\tdata.maxsheetlength = -1;\n\t\t\t\tif (!meta.readAllSheets())\n\t\t\t\t{\n\t\t\t\t\tdata.sheetNames = new String[meta.getSheetName().length];\n\t\t\t\t\tdata.startColumn = new int[meta.getSheetName().length];\n\t\t\t\t\tdata.startRow    = new int[meta.getSheetName().length];\n\t\t\t\t\tfor (int i = 0; i < meta.getSheetName().length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.sheetNames[i] = meta.getSheetName()[i];\n\t\t\t\t\t\tdata.startColumn[i] = meta.getStartColumn()[i];\n\t\t\t\t\t\tdata.startRow[i] = meta.getStartRow()[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (meta.getSheetName()[i].length() > data.maxsheetlength) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata.maxsheetlength = meta.getSheetName()[i].length();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Allocated at open file time: we want ALL sheets.\n\t\t\t\t\tif (meta.getStartRow().length==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartRow = meta.getStartRow()[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartRow = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (meta.getStartColumn().length==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartColumn = meta.getStartColumn()[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartColumn = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(\"No input fields defined!\");\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}","id":106978,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tinitErrorHandling();\n\t\t\tinitReplayFactory();\n\t\t\tdata.files = meta.getFileList(this);\n\t\t\tif (data.files.nrOfFiles() == 0 && data.files.nrOfMissingFiles() == 0 && !meta.isAcceptingFilenames())\n\t\t\t{\r\n\t\t\t\t\n\t\t\t\tlogError(Messages.getString(\"ExcelInput.Error.NoFileSpecified\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (meta.getEmptyFields().size() > 0)\n\t\t\t{\n\t\t\t\t// Determine the maximum filename length...\n\t\t\t\tdata.maxfilelength = -1;\n\n\t\t\t\tfor (FileObject file : data.files.getFiles())\n\t\t\t\t{\n\t\t\t\t\tString name = KettleVFS.getFilename(file);\n\t\t\t\t\tif (name.length() > data.maxfilelength) data.maxfilelength = name.length();\n\t\t\t\t}\n\n\t\t\t\t// Determine the maximum sheet name length...\n\t\t\t\tdata.maxsheetlength = -1;\n\t\t\t\tif (!meta.readAllSheets())\n\t\t\t\t{\n\t\t\t\t\tdata.sheetNames = new String[meta.getSheetName().length];\n\t\t\t\t\tdata.startColumn = new int[meta.getSheetName().length];\n\t\t\t\t\tdata.startRow    = new int[meta.getSheetName().length];\n\t\t\t\t\tfor (int i = 0; i < meta.getSheetName().length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.sheetNames[i] = meta.getSheetName()[i];\n\t\t\t\t\t\tdata.startColumn[i] = meta.getStartColumn()[i];\n\t\t\t\t\t\tdata.startRow[i] = meta.getStartRow()[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (meta.getSheetName()[i].length() > data.maxsheetlength) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata.maxsheetlength = meta.getSheetName()[i].length();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Allocated at open file time: we want ALL sheets.\n\t\t\t\t\tif (meta.getStartRow().length==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartRow = meta.getStartRow()[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartRow = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (meta.getStartColumn().length==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartColumn = meta.getStartColumn()[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdata.defaultStartColumn = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"ExcelInput.Error.NotInputFieldsDefined\"));\r\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (data.workbook != null) data.workbook.close();\r\n\t\tif(data.file!=null) \r\n\t\t{\r\n\t\t\ttry{\r\n\t\t\tdata.file.close();\r\n\t\t\t}catch (Exception e){}\r\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tdata.errorHandler.close();\n\t\t}\n\t\tcatch (KettleException e)\n\t\t{\n\t\t\tif (log.isDebug()) \n            {\n                logDebug(\"Could not close errorHandler: \"+e.toString());\n                logDebug(Const.getStackTracker(e));\n            }\n\t\t}\n\n\t\tsuper.dispose(smi, sdi);\n\t}","id":106979,"modified_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (data.workbook != null) data.workbook.close();\r\n\t\tif(data.file!=null) \r\n\t\t{\r\n\t\t\ttry{\r\n\t\t\tdata.file.close();\r\n\t\t\t}catch (Exception e){}\r\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tdata.errorHandler.close();\n\t\t}\n\t\tcatch (KettleException e)\n\t\t{\n\t\t\tif (log.isDebug()) \n            {\n                logDebug(Messages.getString(\"ExcelInput.Error.CouldNotCloseErrorHandler\",e.toString()));\r\n                \n                logDebug(Const.getStackTracker(e));\n            }\n\t\t}\n\n\t\tsuper.dispose(smi, sdi);\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename;\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", \"The name of the transformation to launch\", optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Transformation in XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", \"List the transformations in the specified directory\", optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", \"Export all repository objects to one XML file\", optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", \"Run in safe mode: with extra checking enabled\", optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", \"specifies the jar filename\", optionJarFilename=new StringBuffer(), false, true),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n            System.exit(9);\n\t\t}\n\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        // start with the default logger until we find out otherwise\n        log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n\n\t\t// Parse the options...\n\t\tif( !CommandLineOption.parseArguments(args, options, log) ) {\n            log.logError(\"Pan\",  Messages.getString(\"Pan.Error.CommandLineError\"));\r\n           \n            System.exit(8);\n\t\t}\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (!Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\", \"Logging is at level : \"+log.getLogLevelLongDesc());\n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        // \n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartingToRun\"));\r\n        \n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingStepsHaltPan\"));\r\n\t\t\t\n            System.exit(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingJobEntriesHaltPan\"), e);\r\n            \n            System.exit(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tlog.logDebug(\"Pan\", \"Allocate new transformation.\");\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tlog.logDebug(\"Pan\", \"Starting to look at options...\");\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Parsing command line options.\");\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Load the transformation info...\");\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Allocate transformation...\");\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(transMeta);\r\n\t\t\t\t\t\t\t\t\t\t\ttrans.setRepository(rep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Getting list of transformations in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(\"Exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                            rep.exportAllObjects(null, optionExprep.toString(), directory);\n                                            System.out.println(\"Finished exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No transformation name supplied: which one should be run?\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the specified directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load transformation.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some fail-over mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Pan\", \"Loading transformation from XML file [\"+optionFilename+\"]\");\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                    \tif(log.isDetailed())  log.logDetailed(\"Pan\", \"Loading transformation from jar file [\"+optionJarFilename+\"]\");\n                        InputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"), null);\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(\"Error reading jarfile: \"+e.toString());\n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Getting the list of repositories...\");\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(\"Processing has stopped because of an error: \"+e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(\"ERROR: Pan can't continue because the transformation couldn't be loaded.\");\n                System.exit(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\t\t\t\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute((String[])args.toArray(new String[args.size()]));\n\t\t\t}\n\t\t\tcatch(KettleException e) {\n                System.out.println(\"Unable to prepare and initialize this transformation\");\n                System.exit(3);\n\t\t\t}\n\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(\"end\");\n\n\t\t\tlog.logMinimal(\"Pan\", \"Finished!\");\n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", \"Start=\"+begin+\", Stop=\"+end);\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t\t\tlog.logMinimal(\"Pan\", \"Processing ended after \"+(millis/1000)+\" seconds.\");\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n                System.exit(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                System.exit(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(\"ERROR occurred: \"+ke.getMessage());\n            log.logError(\"Pan\", \"Unexpected error occurred: \"+ke.getMessage());\n            System.exit(2);\n\t\t}\n\n\t}","id":106980,"modified_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename;\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", \"The name of the transformation to launch\", optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Transformation in XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", \"List the transformations in the specified directory\", optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", \"Export all repository objects to one XML file\", optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", \"Run in safe mode: with extra checking enabled\", optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", \"specifies the jar filename\", optionJarFilename=new StringBuffer(), false, true),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n            System.exit(9);\n\t\t}\n\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        // start with the default logger until we find out otherwise\n        log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n\n\t\t// Parse the options...\n\t\tif( !CommandLineOption.parseArguments(args, options, log) ) {\n            log.logError(\"Pan\",  Messages.getString(\"Pan.Error.CommandLineError\"));\r\n           \n            System.exit(8);\n\t\t}\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (!Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\",  Messages.getString(\"Pan.Log.Loglevel\",log.getLogLevelLongDesc()));\r\n           \n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        // \n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", Messages.getString(\"Pan.Log.StartingToRun\"));\r\n        \n\t\t\n\t\t/* Load the plugins etc.*/\n\t\ttry {\n\t\t\tStepLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlog.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingStepsHaltPan\"));\r\n\t\t\t\n            System.exit(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n\t\ttry \n\t\t{\n\t\t\tJobEntryLoader.init();\n\t\t}\n\t\tcatch(KettleException e)\n        {\n            log.logError(\"Pan\", Messages.getString(\"Pan.Error.LoadingJobEntriesHaltPan\"), e);\r\n            \n            System.exit(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Allocate new transformation.\");\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tlog.logDebug(\"Pan\", \"Starting to look at options...\");\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Parsing command line options.\");\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Load the transformation info...\");\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Allocate transformation...\");\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(transMeta);\r\n\t\t\t\t\t\t\t\t\t\t\ttrans.setRepository(rep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Getting list of transformations in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(\"Exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                            rep.exportAllObjects(null, optionExprep.toString(), directory);\n                                            System.out.println(\"Finished exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No transformation name supplied: which one should be run?\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the specified directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load transformation.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some fail-over mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Pan\", \"Loading transformation from XML file [\"+optionFilename+\"]\");\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                    \tif(log.isDetailed())  log.logDetailed(\"Pan\", \"Loading transformation from jar file [\"+optionJarFilename+\"]\");\n                        InputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"), null);\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(\"Error reading jarfile: \"+e.toString());\n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tif(log.isDebug()) log.logDebug(\"Pan\", \"Getting the list of repositories...\");\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(\"Processing has stopped because of an error: \"+e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(\"ERROR: Pan can't continue because the transformation couldn't be loaded.\");\n                System.exit(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\t\t\t\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute((String[])args.toArray(new String[args.size()]));\n\t\t\t}\n\t\t\tcatch(KettleException e) {\n                System.out.println(\"Unable to prepare and initialize this transformation\");\n                System.exit(3);\n\t\t\t}\n\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(\"end\");\n\n\t\t\tlog.logMinimal(\"Pan\", \"Finished!\");\n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", \"Start=\"+begin+\", Stop=\"+end);\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t\t\tlog.logMinimal(\"Pan\", \"Processing ended after \"+(millis/1000)+\" seconds.\");\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n                System.exit(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                System.exit(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(\"ERROR occurred: \"+ke.getMessage());\n            log.logError(\"Pan\", \"Unexpected error occurred: \"+ke.getMessage());\n            System.exit(2);\n\t\t}\n\n\t}","commit_id":"f5a94d4df980ead2f25a41320af176012079c021","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\n\t{\n\t\tlogBasic(\"Starting to run...\");\n\t\t\n\t\ttry\n\t\t{\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error in '\"+debug+\"' : \"+e.toString());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","id":106981,"modified_method":"public void run()\n\t{\n\t\tlogBasic(Messages.getString(\"DBProc.Log.StartingToRun\")); //$NON-NLS-1$\n\t\t\n\t\ttry\n\t\t{\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"DBProc.Log.UnexpectedError\")+debug+\"' : \"+e.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DBProcMeta)smi;\n\t\tdata=(DBProcData)sdi;\n\n\t\tRow r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t    \n\t\ttry\n\t\t{\n\t\t\trunProc(r); // add new values to the row in rowset[0].\n\t\t\tputRow(r);  // copy row to output rowset(s);\n\t\t\t\t\n\t\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"linenr \"+linesRead);\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(\"Because of an error, this step can't continue: \"+e.getMessage());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","id":106982,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DBProcMeta)smi;\n\t\tdata=(DBProcData)sdi;\n\n\t\tRow r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t    \n\t\ttry\n\t\t{\n\t\t\trunProc(r); // add new values to the row in rowset[0].\n\t\t\tputRow(r);  // copy row to output rowset(s);\n\t\t\t\t\n\t\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(Messages.getString(\"DBProc.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"DBProc.ErrorInStepRunning\")+e.getMessage()); //$NON-NLS-1$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(DBProcMeta)smi;\n\t\tdata=(DBProcData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tdata.db=new Database(meta.getDatabase());\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdata.db.connect();\n\t\t\t\t\n\t\t\t\tlogBasic(\"Connected to database...\");\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tlogError(\"An error occurred, processing will be stopped: \"+e.getMessage());\n\t\t\t\tdata.db.disconnect();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":106983,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(DBProcMeta)smi;\n\t\tdata=(DBProcData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tdata.db=new Database(meta.getDatabase());\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdata.db.connect();\n\t\t\t\t\n\t\t\t\tlogBasic(Messages.getString(\"DBProc.Log.ConnectedToDB\")); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"DBProc.Log.DBException\")+e.getMessage()); //$NON-NLS-1$\n\t\t\t\tdata.db.disconnect();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private synchronized void runProc(Row row)\n\t\tthrows KettleException\n\t{\n\t\tint i;\n\t\tRow add;\n\n        if (first)\n\t\t{\n\t\t\tfirst=false;\n\t\t\tdata.argnrs=new int[meta.getArgument().length];\n\t\t\t\n\t\t\tfor (i=0;i<meta.getArgument().length;i++)\n\t\t\t{\n\t\t\t\tif (!meta.getArgumentDirection()[i].equalsIgnoreCase(\"OUT\")) // IN or INOUT\n\t\t\t\t{\n\t\t\t\t\tdata.argnrs[i]=row.searchValueIndex(meta.getArgument()[i]);\n\t\t\t\t\tif (data.argnrs[i]<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogError(\"Error finding field: \"+meta.getArgument()[i]+\"]\");\n\t\t\t\t\t\tthrow new KettleStepException(\"Couldn't find field '\"+meta.getArgument()[i]+\"' in row!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdata.argnrs[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.db.setProcLookup(meta.getProcedure(), meta.getArgument(), meta.getArgumentDirection(), meta.getArgumentType(), \n\t\t\t                      meta.getResultName(), meta.getResultType());\n\t\t}\n\n\t\tdata.db.setProcValues(row, data.argnrs, meta.getArgumentDirection(), meta.getResultName()!=null); \n\n\t\tadd=data.db.callProcedure(meta.getArgument(), meta.getArgumentDirection(), meta.getArgumentType(), meta.getResultName(), meta.getResultType());\n\t\tfor (i=0;i<add.size();i++)\n\t\t{\n\t\t\trow.addValue( add.getValue(i) );\n\t\t}\n\t}","id":106984,"modified_method":"private synchronized void runProc(Row row)\n\t\tthrows KettleException\n\t{\n\t\tint i;\n\t\tRow add;\n\n        if (first)\n\t\t{\n\t\t\tfirst=false;\n\t\t\tdata.argnrs=new int[meta.getArgument().length];\n\t\t\t\n\t\t\tfor (i=0;i<meta.getArgument().length;i++)\n\t\t\t{\n\t\t\t\tif (!meta.getArgumentDirection()[i].equalsIgnoreCase(\"OUT\")) // IN or INOUT //$NON-NLS-1$\n\t\t\t\t{\n\t\t\t\t\tdata.argnrs[i]=row.searchValueIndex(meta.getArgument()[i]);\n\t\t\t\t\tif (data.argnrs[i]<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogError(Messages.getString(\"DBProc.Log.ErrorFindingField\")+meta.getArgument()[i]+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"DBProc.Exception.CouldnotFindField\",meta.getArgument()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdata.argnrs[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.db.setProcLookup(meta.getProcedure(), meta.getArgument(), meta.getArgumentDirection(), meta.getArgumentType(), \n\t\t\t                      meta.getResultName(), meta.getResultType());\n\t\t}\n\n\t\tdata.db.setProcValues(row, data.argnrs, meta.getArgumentDirection(), meta.getResultName()!=null); \n\n\t\tadd=data.db.callProcedure(meta.getArgument(), meta.getArgumentDirection(), meta.getArgumentType(), meta.getResultName(), meta.getResultType());\n\t\tfor (i=0;i<add.size();i++)\n\t\t{\n\t\t\trow.addValue( add.getValue(i) );\n\t\t}\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get()\n\t{\n\t\ttry\n\t\t{\n\t\t\tint i, count;\n\t\t\tRow r = transMeta.getPrevStepFields(stepname);\n\t\t\tif (r!=null)\n\t\t\t{\n\t\t\t\tTable table=wFields.table;\n\t\t\t\tcount=table.getItemCount();\n\t\t\t\tfor (i=0;i<r.size();i++)\n\t\t\t\t{\n\t\t\t\t\tValue v = r.getValue(i);\n\t\t\t\t\tTableItem ti = new TableItem(table, SWT.NONE);\n\t\t\t\t\tti.setText(0, \"\"+(count+i+1));\n\t\t\t\t\tti.setText(1, v.getName());\n\t\t\t\t\tti.setText(2, \"IN\");\n\t\t\t\t\tti.setText(3, v.getTypeDesc());\n\t\t\t\t}\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t\twFields.optWidth(true);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tnew ErrorDialog(shell, props, \"Get fields failed\", \"Unable to get fields from previous steps because of an error\", ke);\n\t\t}\n\n\t}","id":106985,"modified_method":"private void get()\n\t{\n\t\ttry\n\t\t{\n\t\t\tint i, count;\n\t\t\tRow r = transMeta.getPrevStepFields(stepname);\n\t\t\tif (r!=null)\n\t\t\t{\n\t\t\t\tTable table=wFields.table;\n\t\t\t\tcount=table.getItemCount();\n\t\t\t\tfor (i=0;i<r.size();i++)\n\t\t\t\t{\n\t\t\t\t\tValue v = r.getValue(i);\n\t\t\t\t\tTableItem ti = new TableItem(table, SWT.NONE);\n\t\t\t\t\tti.setText(0, \"\"+(count+i+1)); //$NON-NLS-1$\n\t\t\t\t\tti.setText(1, v.getName());\n\t\t\t\t\tti.setText(2, \"IN\"); //$NON-NLS-1$\n\t\t\t\t\tti.setText(3, v.getTypeDesc());\n\t\t\t\t}\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t\twFields.optWidth(true);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tnew ErrorDialog(shell, props, Messages.getString(\"DBProcDialog.FailedToGetFields.DialogTitle\"), Messages.getString(\"DBProcDialog.FailedToGetFields.DialogMessage\"), ke); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), \"getting key info...\");\n\t\t\n\t\tif (input.getArgument()!=null)\n\t\tfor (i=0;i<input.getArgument().length;i++)\n\t\t{\n\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\tif (input.getArgument()[i]      !=null) item.setText(1, input.getArgument()[i]);\n\t\t\tif (input.getArgumentDirection()[i]   !=null) item.setText(2, input.getArgumentDirection()[i]);\n\t\t\titem.setText(3, Value.getTypeDesc(input.getArgumentType()[i]));\n\t\t}\n\t\t\n\t\tif (input.getDatabase()!=null)   wConnection.setText(input.getDatabase().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getProcedure() !=null)   wProcName.setText(input.getProcedure());\n\t\tif (input.getResultName()!=null)   wResult.setText(input.getResultName());\n\t\twResultType.setText(Value.getTypeDesc(input.getResultType()));\n\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\twStepname.selectAll();\n\t}","id":106986,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), Messages.getString(\"DBProcDialog.Log.GettingKeyInfo\")); //$NON-NLS-1$\n\t\t\n\t\tif (input.getArgument()!=null)\n\t\tfor (i=0;i<input.getArgument().length;i++)\n\t\t{\n\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\tif (input.getArgument()[i]      !=null) item.setText(1, input.getArgument()[i]);\n\t\t\tif (input.getArgumentDirection()[i]   !=null) item.setText(2, input.getArgumentDirection()[i]);\n\t\t\titem.setText(3, Value.getTypeDesc(input.getArgumentType()[i]));\n\t\t}\n\t\t\n\t\tif (input.getDatabase()!=null)   wConnection.setText(input.getDatabase().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getProcedure() !=null)   wProcName.setText(input.getProcedure());\n\t\tif (input.getResultName()!=null)   wResult.setText(input.getResultName());\n\t\twResultType.setText(Value.getTypeDesc(input.getResultType()));\n\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\twStepname.selectAll();\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tint i;\n\t\n\t\tint nrargs = wFields.nrNonEmpty();\n\n\t\tinput.allocate(nrargs);\n\n\t\tlog.logDebug(toString(), \"Found \"+nrargs+\" arguments\");\n\t\tfor (i=0;i<nrargs;i++)\n\t\t{\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinput.getArgument()[i]       = item.getText(1);\n\t\t\tinput.getArgumentDirection()[i]    = item.getText(2);\n\t\t\tinput.getArgumentType()[i]   = Value.getType(item.getText(3));\n\t\t}\n\n\t\tinput.setDatabase( transMeta.findDatabase(wConnection.getText()) );\n\t\tinput.setProcedure( wProcName.getText() );\n\t\tinput.setResultName( wResult.getText() );\n\t\tinput.setResultType( Value.getType(wResultType.getText()) ); \n\n\t\tstepname = wStepname.getText(); // return value\n\n\t\tif (input.getDatabase()==null)\n\t\t{\n\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\tmb.setMessage(\"Please select a valid connection!\");\n\t\t\tmb.setText(\"ERROR\");\n\t\t\tmb.open();\n\t\t}\n\t\t\n\t\tdispose();\n\t}","id":106987,"modified_method":"private void ok()\n\t{\n\t\tint i;\n\t\n\t\tint nrargs = wFields.nrNonEmpty();\n\n\t\tinput.allocate(nrargs);\n\n\t\tlog.logDebug(toString(), Messages.getString(\"DBProcDialog.Log.FoundArguments\",String.valueOf(nrargs))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (i=0;i<nrargs;i++)\n\t\t{\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinput.getArgument()[i]       = item.getText(1);\n\t\t\tinput.getArgumentDirection()[i]    = item.getText(2);\n\t\t\tinput.getArgumentType()[i]   = Value.getType(item.getText(3));\n\t\t}\n\n\t\tinput.setDatabase( transMeta.findDatabase(wConnection.getText()) );\n\t\tinput.setProcedure( wProcName.getText() );\n\t\tinput.setResultName( wResult.getText() );\n\t\tinput.setResultType( Value.getType(wResultType.getText()) ); \n\n\t\tstepname = wStepname.getText(); // return value\n\n\t\tif (input.getDatabase()==null)\n\t\t{\n\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\tmb.setMessage(Messages.getString(\"DBProcDialog.InvalidConnection.DialogMessage\")); //$NON-NLS-1$\n\t\t\tmb.setText(Messages.getString(\"DBProcDialog.InvalidConnection.DialogTitle\")); //$NON-NLS-1$\n\t\t\tmb.open();\n\t\t}\n\t\t\n\t\tdispose();\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(\"DB Procedure Call\");\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin=Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(\"Step name \");\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n\t\t// ProcName line...\n\t\t// add button to get list of procedures on selected connection...\n\t\twbProcName = new Button(shell, SWT.PUSH);\n\t\twbProcName.setText(\" &Find it... \");\n\t\tfdbProcName = new FormData();\n\t\tfdbProcName.right= new FormAttachment(100, 0);\n\t\tfdbProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\twbProcName.setLayoutData(fdbProcName);\n\t\twbProcName.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tDatabaseMeta dbInfo = transMeta.findDatabase(wConnection.getText());\n\t\t\t\tif (dbInfo!=null)\n\t\t\t\t{\n\t\t\t\t\tDatabase db = new Database(dbInfo);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tdb.connect();\n\t\t\t\t\t\tString[] procs = db.getProcedures();\n\t\t\t\t\t\tif (procs!=null && procs.length>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, procs, \"Enter choice\", \"Select a procedure\");\n\t\t\t\t\t\t\tString proc = esd.open();\n\t\t\t\t\t\t\tif (proc!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twProcName.setText(proc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_INFORMATION);\n\t\t\t\t\t\t\tmb.setMessage(\"I couldn't find any procedures to select from.\");\n\t\t\t\t\t\t\tmb.setText(\"Sorry\");\n\t\t\t\t\t\t\tmb.open();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch(KettleDatabaseException dbe)\n\t\t\t\t\t{\n\t\t\t\t\t\tnew ErrorDialog(shell, props, \"Error\", \"Error getting list of available procedures\", dbe);\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tdb.disconnect();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\twlProcName=new Label(shell, SWT.RIGHT);\n\t\twlProcName.setText(\"Proc-name \");\n \t\tprops.setLook(wlProcName);\n\t\tfdlProcName=new FormData();\n\t\tfdlProcName.left = new FormAttachment(0, 0);\n\t\tfdlProcName.right= new FormAttachment(middle, -margin);\n\t\tfdlProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\twlProcName.setLayoutData(fdlProcName);\n\t\t\n\t\twProcName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wProcName);\n\t\twProcName.addModifyListener(lsMod);\n\t\tfdProcName=new FormData();\n\t\tfdProcName.left = new FormAttachment(middle, 0);\n\t\tfdProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\tfdProcName.right= new FormAttachment(wbProcName, -margin);\n\t\twProcName.setLayoutData(fdProcName);\n\t\t\n\t\t\n\t\t// Result line...\n\t\twlResult=new Label(shell, SWT.RIGHT);\n\t\twlResult.setText(\"Result name \");\n \t\tprops.setLook(wlResult);\n\t\tfdlResult=new FormData();\n\t\tfdlResult.left = new FormAttachment(0, 0);\n\t\tfdlResult.right= new FormAttachment(middle, -margin);\n\t\tfdlResult.top  = new FormAttachment(wProcName, margin*2);\n\t\twlResult.setLayoutData(fdlResult);\n\t\twResult=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wResult);\n\t\twResult.addModifyListener(lsMod);\n\t\tfdResult=new FormData();\n\t\tfdResult.left = new FormAttachment(middle, 0);\n\t\tfdResult.top  = new FormAttachment(wProcName, margin*2);\n\t\tfdResult.right= new FormAttachment(100, 0);\n\t\twResult.setLayoutData(fdResult);\n\n\n\t\t// ResultType line\n\t\twlResultType=new Label(shell, SWT.RIGHT);\n\t\twlResultType.setText(\"Result type \");\n \t\tprops.setLook(wlResultType);\n\t\tfdlResultType=new FormData();\n\t\tfdlResultType.left = new FormAttachment(0, 0);\n\t\tfdlResultType.right= new FormAttachment(middle, -margin);\n\t\tfdlResultType.top  = new FormAttachment(wResult, margin);\n\t\twlResultType.setLayoutData(fdlResultType);\n\t\twResultType=new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n \t\tprops.setLook(wResultType);\n\t\tString types[] = Value.getTypes();\n\t\tfor (int x=0;x<types.length;x++) wResultType.add(types[x]);\n\t\twResultType.select(0);\n\t\twResultType.addModifyListener(lsMod);\n\t\tfdResultType=new FormData();\n\t\tfdResultType.left = new FormAttachment(middle, 0);\n\t\tfdResultType.top  = new FormAttachment(wResult, margin);\n\t\tfdResultType.right= new FormAttachment(100, 0);\n\t\twResultType.setLayoutData(fdResultType);\n\n\t\twlFields=new Label(shell, SWT.NONE);\n\t\twlFields.setText(\"Parameters : \");\n \t\tprops.setLook(wlFields);\n\t\tfdlFields=new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.top  = new FormAttachment(wResultType, margin);\n\t\twlFields.setLayoutData(fdlFields);\n\t\t\n\t\tfinal int FieldsCols=3;\n\t\tfinal int FieldsRows=input.getArgument().length;\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[0]=new ColumnInfo(\"Name\",       ColumnInfo.COLUMN_TYPE_TEXT,   false);\n\t\tcolinf[1]=new ColumnInfo(\"Direction\",  ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"IN\", \"OUT\", \"INOUT\" } );\n\t\tcolinf[2]=new ColumnInfo(\"Type\",       ColumnInfo.COLUMN_TYPE_CCOMBO, Value.getTypes() );\n\t\t\n\t\twFields=new TableView(shell, \n\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t\t  colinf, \n\t\t\t\t\t\t\t  FieldsRows,  \n\t\t\t\t\t\t\t  lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t\t  );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(wlFields, margin);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(100, -50);\n\t\twFields.setLayoutData(fdFields);\n\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(\" &OK \");\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(\" &Get Fields \");\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(\" &Cancel \");\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wCancel }, margin, wFields);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();        } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tlsResize = new Listener() \n\t\t{\n\t\t\tpublic void handleEvent(Event event) \n\t\t\t{\n\t\t\t\tPoint size = shell.getSize();\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\n\t\t\t\twFields.redraw();\n\t\t\t}\n\t\t};\n\t\tshell.addListener(SWT.Resize, lsResize);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":106988,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DBProcDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin=Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DBProcDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n\t\t// ProcName line...\n\t\t// add button to get list of procedures on selected connection...\n\t\twbProcName = new Button(shell, SWT.PUSH);\n\t\twbProcName.setText(Messages.getString(\"DBProcDialog.Finding.Button\")); //$NON-NLS-1$\n\t\tfdbProcName = new FormData();\n\t\tfdbProcName.right= new FormAttachment(100, 0);\n\t\tfdbProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\twbProcName.setLayoutData(fdbProcName);\n\t\twbProcName.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tDatabaseMeta dbInfo = transMeta.findDatabase(wConnection.getText());\n\t\t\t\tif (dbInfo!=null)\n\t\t\t\t{\n\t\t\t\t\tDatabase db = new Database(dbInfo);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tdb.connect();\n\t\t\t\t\t\tString[] procs = db.getProcedures();\n\t\t\t\t\t\tif (procs!=null && procs.length>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, procs, Messages.getString(\"DBProcDialog.EnterSelection.DialogTitle\"), Messages.getString(\"DBProcDialog.EnterSelection.DialogMessage\")); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\tString proc = esd.open();\n\t\t\t\t\t\t\tif (proc!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twProcName.setText(proc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_INFORMATION);\n\t\t\t\t\t\t\tmb.setMessage(Messages.getString(\"DBProcDialog.NoProceduresFound.DialogMessage\")); //$NON-NLS-1$\n\t\t\t\t\t\t\tmb.setText(Messages.getString(\"DBProcDialog.NoProceduresFound.DialogTitle\")); //$NON-NLS-1$\n\t\t\t\t\t\t\tmb.open();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch(KettleDatabaseException dbe)\n\t\t\t\t\t{\n\t\t\t\t\t\tnew ErrorDialog(shell, props, Messages.getString(\"DBProcDialog.ErrorGettingProceduresList.DialogTitle\"), Messages.getString(\"DBProcDialog.ErrorGettingProceduresList.DialogMessage\"), dbe); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tdb.disconnect();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\twlProcName=new Label(shell, SWT.RIGHT);\n\t\twlProcName.setText(Messages.getString(\"DBProcDialog.ProcedureName.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlProcName);\n\t\tfdlProcName=new FormData();\n\t\tfdlProcName.left = new FormAttachment(0, 0);\n\t\tfdlProcName.right= new FormAttachment(middle, -margin);\n\t\tfdlProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\twlProcName.setLayoutData(fdlProcName);\n\t\t\n\t\twProcName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wProcName);\n\t\twProcName.addModifyListener(lsMod);\n\t\tfdProcName=new FormData();\n\t\tfdProcName.left = new FormAttachment(middle, 0);\n\t\tfdProcName.top  = new FormAttachment(wConnection, margin*2);\n\t\tfdProcName.right= new FormAttachment(wbProcName, -margin);\n\t\twProcName.setLayoutData(fdProcName);\n\t\t\n\t\t\n\t\t// Result line...\n\t\twlResult=new Label(shell, SWT.RIGHT);\n\t\twlResult.setText(Messages.getString(\"DBProcDialog.Result.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlResult);\n\t\tfdlResult=new FormData();\n\t\tfdlResult.left = new FormAttachment(0, 0);\n\t\tfdlResult.right= new FormAttachment(middle, -margin);\n\t\tfdlResult.top  = new FormAttachment(wProcName, margin*2);\n\t\twlResult.setLayoutData(fdlResult);\n\t\twResult=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wResult);\n\t\twResult.addModifyListener(lsMod);\n\t\tfdResult=new FormData();\n\t\tfdResult.left = new FormAttachment(middle, 0);\n\t\tfdResult.top  = new FormAttachment(wProcName, margin*2);\n\t\tfdResult.right= new FormAttachment(100, 0);\n\t\twResult.setLayoutData(fdResult);\n\n\n\t\t// ResultType line\n\t\twlResultType=new Label(shell, SWT.RIGHT);\n\t\twlResultType.setText(Messages.getString(\"DBProcDialog.ResultType.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlResultType);\n\t\tfdlResultType=new FormData();\n\t\tfdlResultType.left = new FormAttachment(0, 0);\n\t\tfdlResultType.right= new FormAttachment(middle, -margin);\n\t\tfdlResultType.top  = new FormAttachment(wResult, margin);\n\t\twlResultType.setLayoutData(fdlResultType);\n\t\twResultType=new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n \t\tprops.setLook(wResultType);\n\t\tString types[] = Value.getTypes();\n\t\tfor (int x=0;x<types.length;x++) wResultType.add(types[x]);\n\t\twResultType.select(0);\n\t\twResultType.addModifyListener(lsMod);\n\t\tfdResultType=new FormData();\n\t\tfdResultType.left = new FormAttachment(middle, 0);\n\t\tfdResultType.top  = new FormAttachment(wResult, margin);\n\t\tfdResultType.right= new FormAttachment(100, 0);\n\t\twResultType.setLayoutData(fdResultType);\n\n\t\twlFields=new Label(shell, SWT.NONE);\n\t\twlFields.setText(Messages.getString(\"DBProcDialog.Parameters.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlFields);\n\t\tfdlFields=new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.top  = new FormAttachment(wResultType, margin);\n\t\twlFields.setLayoutData(fdlFields);\n\t\t\n\t\tfinal int FieldsCols=3;\n\t\tfinal int FieldsRows=input.getArgument().length;\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[0]=new ColumnInfo(Messages.getString(\"DBProcDialog.ColumnInfo.Name\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tcolinf[1]=new ColumnInfo(Messages.getString(\"DBProcDialog.ColumnInfo.Direction\"),  ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { Messages.getString(\"DBProcDialog.ColumnInfo.Options.In\"), Messages.getString(\"DBProcDialog.ColumnInfo.Options.Out\"), Messages.getString(\"DBProcDialog.ColumnInfo.Options.Inout\") } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\tcolinf[2]=new ColumnInfo(Messages.getString(\"DBProcDialog.ColumnInfo.Type\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, Value.getTypes() ); //$NON-NLS-1$\n\t\t\n\t\twFields=new TableView(shell, \n\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t\t  colinf, \n\t\t\t\t\t\t\t  FieldsRows,  \n\t\t\t\t\t\t\t  lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t\t  );\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(wlFields, margin);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(100, -50);\n\t\twFields.setLayoutData(fdFields);\n\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"DBProcDialog.OK.Button\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DBProcDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"DBProcDialog.Cancel.Button\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wCancel }, margin, wFields);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();        } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tlsResize = new Listener() \n\t\t{\n\t\t\tpublic void handleEvent(Event event) \n\t\t\t{\n\t\t\t\tPoint size = shell.getSize();\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\n\t\t\t\twFields.redraw();\n\t\t\t}\n\t\t};\n\t\tshell.addListener(SWT.Resize, lsResize);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"id_connection\", database==null?-1:database.getID());\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"procedure\",     procedure);\n\t\n\t\t\tfor (int i=0;i<argument.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_name\",      argument[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_direction\", argumentDirection[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_type\",      Value.getTypeDesc(argumentType[i]));\n\t\t\t}\n\t\t\t\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"result_name\",     resultName);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"result_type\",     Value.getTypeDesc(resultType));\n\t\t\t\n\t\t\t// Also, save the step-database relationship!\n\t\t\tif (database!=null) rep.insertStepDatabase(id_transformation, id_step, database.getID());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\t}","id":106989,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"id_connection\", database==null?-1:database.getID()); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"procedure\",     procedure); //$NON-NLS-1$\n\t\n\t\t\tfor (int i=0;i<argument.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_name\",      argument[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_direction\", argumentDirection[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"arg_type\",      Value.getTypeDesc(argumentType[i])); //$NON-NLS-1$\n\t\t\t}\n\t\t\t\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"result_name\",     resultName); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"result_type\",     Value.getTypeDesc(resultType)); //$NON-NLS-1$\n\t\t\t\n\t\t\t// Also, save the step-database relationship!\n\t\t\tif (database!=null) rep.insertStepDatabase(id_transformation, id_step, database.getID());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"DBProcMeta.Exception.UnableToSaveStepInfo\")+id_step, e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode, ArrayList databases)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint i;\n\t\t\tint nrargs;\n\t\t\t\n\t\t\tString con = XMLHandler.getTagValue(stepnode, \"connection\");\n\t\t\tdatabase = Const.findDatabase(databases, con);\n\t\t\tprocedure  = XMLHandler.getTagValue(stepnode, \"procedure\");\n\t\n\t\t\tNode lookup = XMLHandler.getSubNode(stepnode, \"lookup\");\n\t\t\tnrargs    = XMLHandler.countNodes(lookup, \"arg\");\n\t\n\t\t\tallocate(nrargs);\n\t\n\t\t\tfor (i=0;i<nrargs;i++)\n\t\t\t{\n\t\t\t\tNode anode = XMLHandler.getSubNodeByNr(lookup, \"arg\", i);\n\t\t\t\t\n\t\t\t\targument    [i] = XMLHandler.getTagValue(anode, \"name\");\n\t\t\t\targumentDirection [i] = XMLHandler.getTagValue(anode, \"direction\");\n\t\t\t\targumentType[i] = Value.getType(XMLHandler.getTagValue(anode, \"type\"));\n\t\t\t}\n\t\t\t\n\t\t\tresultName = XMLHandler.getTagValue(stepnode, \"result\", \"name\"); //Optional, can be null\n\t\t\tresultType = Value.getType(XMLHandler.getTagValue(stepnode, \"result\", \"type\"));\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to read step information from XML\", e);\n\t\t}\n\t}","id":106990,"modified_method":"private void readData(Node stepnode, ArrayList databases)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint i;\n\t\t\tint nrargs;\n\t\t\t\n\t\t\tString con = XMLHandler.getTagValue(stepnode, \"connection\"); //$NON-NLS-1$\n\t\t\tdatabase = Const.findDatabase(databases, con);\n\t\t\tprocedure  = XMLHandler.getTagValue(stepnode, \"procedure\"); //$NON-NLS-1$\n\t\n\t\t\tNode lookup = XMLHandler.getSubNode(stepnode, \"lookup\"); //$NON-NLS-1$\n\t\t\tnrargs    = XMLHandler.countNodes(lookup, \"arg\"); //$NON-NLS-1$\n\t\n\t\t\tallocate(nrargs);\n\t\n\t\t\tfor (i=0;i<nrargs;i++)\n\t\t\t{\n\t\t\t\tNode anode = XMLHandler.getSubNodeByNr(lookup, \"arg\", i); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\targument    [i] = XMLHandler.getTagValue(anode, \"name\"); //$NON-NLS-1$\n\t\t\t\targumentDirection [i] = XMLHandler.getTagValue(anode, \"direction\"); //$NON-NLS-1$\n\t\t\t\targumentType[i] = Value.getType(XMLHandler.getTagValue(anode, \"type\")); //$NON-NLS-1$\n\t\t\t}\n\t\t\t\n\t\t\tresultName = XMLHandler.getTagValue(stepnode, \"result\", \"name\"); //Optional, can be null //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tresultType = Value.getType(XMLHandler.getTagValue(stepnode, \"result\", \"type\")); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"DBProcMeta.Exception.UnableToReadStepInfo\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tlong id_connection =   rep.getStepAttributeInteger(id_step, \"id_connection\"); \n\t\t\tdatabase = Const.findDatabase( databases, id_connection);\n\t\t\tprocedure = rep.getStepAttributeString(id_step, \"procedure\");\n\t\n\t\t\tint nrargs = rep.countNrStepAttributes(id_step, \"arg_name\");\n\t\t\tallocate(nrargs);\n\t\t\t\n\t\t\tfor (int i=0;i<nrargs;i++)\n\t\t\t{\n\t\t\t\targument[i]     = rep.getStepAttributeString(id_step, i, \"arg_name\");\n\t\t\t\targumentDirection[i]  = rep.getStepAttributeString(id_step, i, \"arg_direction\");\n\t\t\t\targumentType[i] = Value.getType( rep.getStepAttributeString(id_step, i, \"arg_type\") );\n\t\t\t}\n\t\t\t\n\t\t\tresultName =                rep.getStepAttributeString(id_step, \"result_name\");\n\t\t\tresultType = Value.getType( rep.getStepAttributeString(id_step, \"result_type\") );\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":106991,"modified_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tlong id_connection =   rep.getStepAttributeInteger(id_step, \"id_connection\");  //$NON-NLS-1$\n\t\t\tdatabase = Const.findDatabase( databases, id_connection);\n\t\t\tprocedure = rep.getStepAttributeString(id_step, \"procedure\"); //$NON-NLS-1$\n\t\n\t\t\tint nrargs = rep.countNrStepAttributes(id_step, \"arg_name\"); //$NON-NLS-1$\n\t\t\tallocate(nrargs);\n\t\t\t\n\t\t\tfor (int i=0;i<nrargs;i++)\n\t\t\t{\n\t\t\t\targument[i]     = rep.getStepAttributeString(id_step, i, \"arg_name\"); //$NON-NLS-1$\n\t\t\t\targumentDirection[i]  = rep.getStepAttributeString(id_step, i, \"arg_direction\"); //$NON-NLS-1$\n\t\t\t\targumentType[i] = Value.getType( rep.getStepAttributeString(id_step, i, \"arg_type\") ); //$NON-NLS-1$\n\t\t\t}\n\t\t\t\n\t\t\tresultName =                rep.getStepAttributeString(id_step, \"result_name\"); //$NON-NLS-1$\n\t\t\tresultType = Value.getType( rep.getStepAttributeString(id_step, \"result_type\") ); //$NON-NLS-1$\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"DBProcMeta.Exception.UnexpectedErrorReadingStepInfo\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tString error_message = \"\";\n\t\t\n\t\tif (database!=null)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\t\n\t\t\t\t// Look up fields in the input stream <prev>\n\t\t\t\tif (prev!=null && prev.size()>0)\n\t\t\t\t{\n\t\t\t\t\tboolean first=true;\n\t\t\t\t\terror_message = \"\";\n\t\t\t\t\tboolean error_found = false;\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<argument.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tValue v = prev.searchValue(argument[i]);\n\t\t\t\t\t\tif (v==null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t\t\t\terror_message+=\"Missing arguments, not found in input from previous steps:\"+Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terror_found=true;\n\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+argument[i]+Const.CR; \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // Argument exists in input stream: same type?\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (v.getType()!=argumentType[i] &&\n\t\t\t\t\t\t\t   !(v.isNumeric() && Value.isNumeric(argumentType[i])) \n\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_found=true;\n\t\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+argument[i]+\" (found but wrong type: \"+v.getTypeDesc()+\" vs. \"+Value.getTypeDesc(argumentType[i])+\")\"+Const.CR; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (error_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"All arguments found in the input stream.\", stepMeta);\n\t\t\t\t\t}\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror_message=\"Couldn't read fields from the previous step.\"+Const.CR;\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\terror_message = \"A an error occurred: \"+e.getMessage();\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message = \"Please select or create a connection!\";\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t}","id":106992,"modified_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tString error_message = \"\"; //$NON-NLS-1$\n\t\t\n\t\tif (database!=null)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\t\n\t\t\t\t// Look up fields in the input stream <prev>\n\t\t\t\tif (prev!=null && prev.size()>0)\n\t\t\t\t{\n\t\t\t\t\tboolean first=true;\n\t\t\t\t\terror_message = \"\"; //$NON-NLS-1$\n\t\t\t\t\tboolean error_found = false;\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0;i<argument.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tValue v = prev.searchValue(argument[i]);\n\t\t\t\t\t\tif (v==null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t\t\t\terror_message+=Messages.getString(\"DBProcMeta.CheckResult.MissingArguments\")+Const.CR; //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terror_found=true;\n\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+argument[i]+Const.CR;  //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // Argument exists in input stream: same type?\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (v.getType()!=argumentType[i] &&\n\t\t\t\t\t\t\t   !(v.isNumeric() && Value.isNumeric(argumentType[i])) \n\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_found=true;\n\t\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+argument[i]+Messages.getString(\"DBProcMeta.CheckResult.WrongTypeArguments\",v.getTypeDesc(),Value.getTypeDesc(argumentType[i]))+Const.CR;  //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (error_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"DBProcMeta.CheckResult.AllArgumentsOK\"), stepMeta); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror_message=Messages.getString(\"DBProcMeta.CheckResult.CouldNotReadFields\")+Const.CR; //$NON-NLS-1$\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\terror_message = Messages.getString(\"DBProcMeta.CheckResult.ErrorOccurred\")+e.getMessage(); //$NON-NLS-1$\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message = Messages.getString(\"DBProcMeta.CheckResult.InvalidConnection\"); //$NON-NLS-1$\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"DBProcMeta.CheckResult.ReceivingInfoFromOtherSteps\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"DBProcMeta.CheckResult.NoInpuReceived\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t}","commit_id":"be3921f8d308e082e490ecef9554c0891a1943b3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static SNode get_inputListType(SNode op) {\n    SNode parent = SNodeOperations.getParent(op, null, false, false);\n    if(SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression\")) {\n      SNode leftExpression = SLinkOperations.getTarget(parent, \"leftExpression\", true);\n      SNode listType = RulesFunctions_Collections.tryObtain_ListType(leftExpression);\n      if(listType != null) {\n        return listType;\n      } else \n      {\n        TypeChecker.getInstance().reportTypeError(leftExpression, \"list is expected\");\n      }\n    } else \n    {\n      TypeChecker.getInstance().reportTypeError(op, \"not expected here: is only applicable to list\");\n    }\n    return null;\n  }","id":106993,"modified_method":"public static SNode get_inputListType(SNode op) {\n    SNode parent = SNodeOperations.getParent(op, null, false, false);\n    if(SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression\")) {\n      SNode leftExpression = SLinkOperations.getTarget(parent, \"leftExpression\", true);\n      SNode leftExpressionType = TypeChecker.getInstance().getRuntimeSupport().checkedTypeOf(leftExpression);\n      SNode listType = TypeChecker.getInstance().getRuntimeSupport().coerce(leftExpressionType, HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.ext.collections.lang.structure.ListType\"), true);\n      if(listType != null) {\n        return listType;\n      } else \n      {\n        TypeChecker.getInstance().reportTypeError(leftExpression, \"list is expected but was \" + leftExpressionType);\n      }\n    } else \n    {\n      TypeChecker.getInstance().reportTypeError(op, \"not expected here: is only applicable to list\");\n    }\n    return null;\n  }","commit_id":"771352f19c6828b33dbd449994722ba7f0a0ed26","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode coerceTo_SequenceType(SNode type) {\n    SNode sequenceType = TypeChecker.getInstance().getRuntimeSupport().coerce(type, HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceType\"), true);\n    if(sequenceType != null) {\n      return sequenceType;\n    }\n    if(type == null) {\n      return null;\n    }\n    // ==========\n    // TEMP FIX FOR DNQ 1\n    if(\"jetbrains.teamsys.dnq.structure.PListType\".equals(type.getConceptFqName())) {\n      SNode classifierType = type.getChild(\"classifierType\");\n      return new QuotationClass_26().createNode(SNodeOperations.copyNode(classifierType));\n    }\n    // END TEMP FIX\n    // ==========\n    // ==========\n    // TEMP FIX FOR DNQ\n    // TODO: extract generics information\n    if(type != null) {\n      SModel model = TypeChecker.getInstance().getRuntimeTypesModel();\n      GlobalScope scope = GlobalScope.getInstance();\n      SNode entity = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"com.jetbrains.teamsys.database.Entity\", Classifier.class, scope));\n      if(entity == null) {\n        return null;\n      }\n      SNode entityType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(entityType, \"classifier\", entity, false);\n      SNode javaIterable = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"java.lang.Iterable\", Classifier.class, scope));\n      SNode javaIterableType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(javaIterableType, \"classifier\", javaIterable, false);\n      SLinkOperations.addChild(javaIterableType, \"parameter\", entityType);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(type, javaIterableType)) {\n        return new QuotationClass_27().createNode(SNodeOperations.copyNode(entity));\n      }\n      // ==========\n      SNode entityIterable = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"com.jetbrains.teamsys.database.EntityIterable\", Classifier.class, scope));\n      SNode entityIterableType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(entityIterableType, \"classifier\", entityIterable, false);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(type, entityIterableType)) {\n        return new QuotationClass_28().createNode(SNodeOperations.copyNode(entity));\n      }\n    }\n    // END FIX\n    // ==========\n    return null;\n  }","id":106994,"modified_method":"public static SNode coerceTo_SequenceType(SNode type) {\n    SNode sequenceType = TypeChecker.getInstance().getRuntimeSupport().coerce(type, HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceType\"), true);\n    if(sequenceType != null) {\n      return sequenceType;\n    }\n    if(type == null) {\n      return null;\n    }\n    // ==========\n    // TEMP FIX FOR DNQ 1\n    if(\"jetbrains.teamsys.dnq.structure.PListType\".equals(type.getConceptFqName())) {\n      SNode classifierType = type.getChild(\"classifierType\");\n      return new QuotationClass_27().createNode(SNodeOperations.copyNode(classifierType));\n    }\n    // END TEMP FIX\n    // ==========\n    // ==========\n    // TEMP FIX FOR DNQ\n    // TODO: extract generics information\n    if(type != null) {\n      SModel model = TypeChecker.getInstance().getRuntimeTypesModel();\n      GlobalScope scope = GlobalScope.getInstance();\n      SNode entity = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"com.jetbrains.teamsys.database.Entity\", Classifier.class, scope));\n      if(entity == null) {\n        return null;\n      }\n      SNode entityType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(entityType, \"classifier\", entity, false);\n      SNode javaIterable = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"java.lang.Iterable\", Classifier.class, scope));\n      SNode javaIterableType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(javaIterableType, \"classifier\", javaIterable, false);\n      SLinkOperations.addChild(javaIterableType, \"parameter\", entityType);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(type, javaIterableType)) {\n        return new QuotationClass_28().createNode(SNodeOperations.copyNode(entity));\n      }\n      // ==========\n      SNode entityIterable = BaseAdapter.fromAdapter(SModelUtil_new.findNodeByFQName(\"com.jetbrains.teamsys.database.EntityIterable\", Classifier.class, scope));\n      SNode entityIterableType = SModelOperations.createNewNode(model, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n      SLinkOperations.setTarget(entityIterableType, \"classifier\", entityIterable, false);\n      if(TypeChecker.getInstance().getSubtypingManager().isSubtype(type, entityIterableType)) {\n        return new QuotationClass_29().createNode(SNodeOperations.copyNode(entity));\n      }\n    }\n    // END FIX\n    // ==========\n    return null;\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_25().createNode(this.myMatchingPattern.PatternVar1);\n  }","id":106995,"modified_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_26().createNode(this.myMatchingPattern.PatternVar1);\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_24().createNode(this.myMatchingPattern.PatternVar);\n  }","id":106996,"modified_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_25().createNode(this.myMatchingPattern.PatternVar);\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_23().createNode(SLinkOperations.getTarget(type, \"elementType\", true));\n  }","id":106997,"modified_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_24().createNode(SLinkOperations.getTarget(type, \"elementType\", true));\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_30().createNode();\n  }","id":106998,"modified_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_31().createNode();\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_22().createNode(SLinkOperations.getTarget(type, \"elementType\", true));\n  }","id":106999,"modified_method":"public SNode getSubOrSuperType(SNode type) {\n    return new QuotationClass_23().createNode(SLinkOperations.getTarget(type, \"elementType\", true));\n  }","commit_id":"fe264f12e7fd1cfea5e16811231e6903e0aab9ea","url":"https://github.com/JetBrains/MPS"}]